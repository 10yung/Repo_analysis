Resolves https://github.com/kaitai-io/kaitai_struct/issues/204
Proposal for https://github.com/kaitai-io/kaitai_struct_java_runtime/issues/22. Annotations make it much easier to create a visualizer, especially, if input for visualizer is class, derived from kaitai-generated class and if https://github.com/kaitai-io/kaitai_struct/issues/672 will be implemented.

Right now I want to see, if it compiles and also receive some review comments.
Closes https://github.com/kaitai-io/kaitai_struct/issues/637
Relates to https://github.com/kaitai-io/kaitai_struct/issues/640

This is a Work In Progress. I expect to rebase to keep this branch up-to-date.
Some of the code generated by kaitai for C++ was triggering compiler warnings, this should fix the unused parameters, sign conversions and sign compare ones.  

Given that this code calls a new method `kaitai::to_signed` it strictly depends on https://github.com/kaitai-io/kaitai_struct_cpp_stl_runtime/pull/33 being merged as well, otherwise this won't work.
I need to access `typeProvider` property of LanguageCompiler from trait GenericChecks, so I made it public with `val`.

I reuse ConsistencyError for throwing if the last element of array doesn't satisfy repeat-until condition, but I'm not sure what should be present in the error message. Maybe it should throw a special type of Exception deriving from ConsistencyError, but I don't know.

I also add methods `blockScopeHeader` and `blockScopeFooter`, because in case there are multiple seq fields with repeat-until, I need to redeclare `_it` variable, every time with a different type. Java doesn't allow redeclaring variables in the same scope, so I wrap each check in its own.

For example, these are the generated repeat-until checks in the test format repeat_until_complex:
```java
        {
            TypeU1 _it = first().get(first().size() - 1);
            if (!(_it.count() == 0))
                throw new ConsistencyError("first", "UserTypeInstream(List(type_u1),None,List())", "_it.count() == 0");
        }
        {
            TypeU2 _it = second().get(second().size() - 1);
            if (!(_it.count() == 0))
                throw new ConsistencyError("second", "UserTypeInstream(List(type_u2),None,List())", "_it.count() == 0");
        }
        {
            int _it = third().get(third().size() - 1);
            if (!(_it == 0))
                throw new ConsistencyError("third", "Int1Type(false)", "_it == 0");
        }
```
When you want to write enum value, you need to call method
translator.enumToInt, which expects its arguments of type Ast.expr.
So we need a way to convert `Identifier` to `Ast.expr.Name`. I thought
that method Identifier.toAstIdentifier would serve this purpose,
but it doesn't work and I don't know how it was supposed to work.
Anyway, the conversion had been done as
`Ast.expr.Name(Ast.identifier(idToStr(id)))`. However,
this simple conversion is wrong. The `Identifier` is language-agnostic
object, but idToStr(id) converts it to language-dependent name.

So when you try to call `translator.translate(
  Ast.expr.Subscript(
    Ast.expr.Name(Ast.identifier(idToStr(id))),
    Ast.expr.Name(Ast.identifier(Identifier.INDEX))
  )
)` with id = NamedIdentifier('some_array'), idToStr(id) will return
'someArray' for Java, and the execution will fail when detecting
type of the container you try to subscript, because there is no field
with name 'someArray' (actualy, the ClassTypeProvider.determineType
method internally creates NamedIdentifier(attrName), so it fails
on constraint ^[a-z][a-z0-9_]*$).

Hence I felt the need to inject language-specific code to AST object,
so I created class Ast.expr.CodeLiteral(code) for this purpose.
The BaseTranslator for it just returns the `code` itself. In the future,
we may need also specify the DataType of the code literal, so that
detecting type on it doesn't fail, but I haven't needed it yet.
If someone would compile KSY format with --read-write option only (without --no-auto-read), instancing any user-generated class with empty parameter list would immediately fail with an exception (because autoRead is enabled, but there is no _io to read from).
Adding first things for custom scan and simulating terminator byte.
The output of the new "TypeScript" target is typescript that uses a class based format instead of a prototype-based one.
TypeScript allows for autocompletion, making it significantly easier to work with the output of complex formats.
Certain shortcuts were also taken for the time being, namely using a type of `any` instead of the `type 1 | type 2` for switch types