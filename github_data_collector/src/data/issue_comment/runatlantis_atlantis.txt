Generated by https://github.com/jsoref/spelling `f`; to maintain your repo, please consider `fchurn`
We have Atlantis running in a cluster on Project A and want it to manage resources for a cluster running on Project B.

The pod running Atlantis is using kubernetes service account mounted which has the necessary access to Project B , to handle all google provider terraform. But as soon as it attempts to do kubernetes provider planing it fails, because the cluster on Project B does not know the service account from Project A. 

I have attempted to exec in to the pod running Atlantis and via TF logs, which show that its trying to authenticate with the mentioned service account, the jwt decodes to something like 

``` "iss": "kubernetes/serviceaccount",
  "kubernetes.io/serviceaccount/namespace": "atlantis",
  "kubernetes.io/serviceaccount/service-account.name": "atlantis-deployer",
  "sub": "system:serviceaccount:atlantis:atlantis-deployer"
}```

There is no corresponding k8s service account or namespace in Cluster B, as Atlantis exists only in Cluster A. 

Does anyone have a similar use case working? 

Or should atlantis run in the same cluster as it is trying to manage, and I am just misunderstanding that completely. 
Hello, 
I am going through the [Test Drive](https://www.runatlantis.io/guide/test-drive.html) tutorial on a ubuntu18.04 WSL running on a windows 10 pro machine.
I am getting this error on [my demo repo](https://github.com/kennedy/atlantis-example/pull/1). 

anyone have an idea whats happening?
```
Error: goroutine panic. This is a bug.

invalid page type: 0: 4
/go/pkg/mod/github.com/boltdb/bolt@v1.3.1/cursor.go:256 (0x8a1602)
/go/pkg/mod/github.com/boltdb/bolt@v1.3.1/cursor.go:159 (0x8a0b9c)
/go/pkg/mod/github.com/boltdb/bolt@v1.3.1/bucket.go:112 (0x89cbc3)
/go/pkg/mod/github.com/boltdb/bolt@v1.3.1/tx.go:101 (0x8b2ea2)
/go/src/github.com/runatlantis/atlantis/server/events/db/boltdb.go:77 (0x8b2e7b)
/go/pkg/mod/github.com/boltdb/bolt@v1.3.1/db.go:598 (0x8a3ef7)
/go/src/github.com/runatlantis/atlantis/server/events/db/boltdb.go:76 (0x8b0b88)
/go/src/github.com/runatlantis/atlantis/server/events/locking/locking.go:81 (0xecaf49)
/go/src/github.com/runatlantis/atlantis/server/events/project_locker.go:60 (0xee6df0)
/go/src/github.com/runatlantis/atlantis/server/events/project_command_runner.go:137 (0xee315a)
/go/src/github.com/runatlantis/atlantis/server/events/project_command_runner.go:109 (0xee2d14)
/go/src/github.com/runatlantis/atlantis/server/events/command_runner.go:332 (0xecef65)
/go/src/github.com/runatlantis/atlantis/server/events/command_runner.go:131 (0xecc171)
/usr/local/go/src/runtime/asm_amd64.s:1357 (0x45b110)
```
Here is my console
```
➜  ~ atlantis testdrive
Welcome to Atlantis testdrive!

This mode sets up Atlantis on a test repo so you can try it out. We will
- fork an example terraform project to your username
- install terraform (if not already in your PATH)
- install ngrok so we can expose Atlantis to GitHub
- start Atlantis

Press Ctrl-c at any time to exit


github.com username: kennedy

To continue, we need you to create a GitHub personal access token
with "repo" scope so we can fork an example terraform project.

Follow these instructions to create a token (we don't store any tokens):
https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/#creating-a-token
- use "atlantis" for the token description
- add "repo" scope
- copy the access token

GitHub access token (will be hidden): 
=> forking repo 
=> fork completed!
=> terraform found in $PATH!
=> downloading ngrok        
=> downloaded ngrok successfully!
=> creating secure tunnel        
=> started tunnel!
=> starting atlantis server
⠋ => atlantis server is now securely exposed at https://****.ngrok.io

=> creating atlantis webhook
=> atlantis webhook created!  
=> creating a new pull request
=> pull request created!
=> opening pull request 
⠴ => opening pull request failed. please go to: https://github.com/kennedy/atlantis-example/pull/1 on the browser
atlantis is running    
 [press Ctrl-c to exit]
⠹ ^C
shutdown signal received, exiting....

Thank you for using atlantis :) 
For more information about how to use atlantis in production go to: https://www.runatlantis.io
```
Hey there,

we need a way to ignore `tfvars` files in the default plan.

Currently we are autogenerating our repo  config and it is 1332 lines of yaml and tends to cause issues with rebases & merges. Would you accept a PR for this?
Addresses #721 

Read commit by commit. Attempted to isolate changes.

Did not implement this for other VCS's. Github is my primary concern right now.

This will only hide "apply" comments, because IMO "plan" comments are important enough to have unminimized because they impact actual systems and thus may be useful when people need to audit changes or figure out what/how things broke.

I didn't test the entire flow, but did test my new code in isolation:
```go
func TestSpark(t *testing.T) {
	c, err := NewGithubClient(
		"github.com",
		"goodspark-bot",
		"GETYOUROWNKEY",
	)
	if err != nil {
		t.Logf("client error: %v", err)
		t.FailNow()
	}
	r, err := models.NewRepo(
		models.Github,
		"goodspark/asd",
		"https://github.com/goodspark/asd.git",
		"",
		"",
	)
	if err != nil {
		t.Logf("repo error: %v", err)
		t.FailNow()
	}
	err = c.HideOldComments(r, 7)
	if err != nil {
		t.Logf("hide error: %v", err)
		t.Fail()
	}
}
```

See: https://github.com/goodspark/asd/pull/7 for how it ran.
I see this PR https://github.com/runatlantis/atlantis/pull/502 references API deprecation doc, but apparently `actor` object still (as of today) contains `username` field and i get  `was missing fields: Key: 'PullRequestEvent.CommonEventData.Actor.Nickname' Error:Field validation for 'Nickname' failed on the 'required'` Error when receiving payload. @lkysow I guess this PR needs to be reverted?
It would be cool if Atlantis could add a label to a PR that currently held the lock. This would make it easier to see at a glance which PR was currently blocking without needing to view the web UI or look through comments.
It would be a huge architectural improvement if we can turn the Atlantis server into a stateless container with external transactional storage for locks.

An abstract key-value store that implements the [Backend interface](https://github.com/runatlantis/atlantis/blob/master/server/events/locking/locking.go#L28-L35) seems to be a good start. We can start with a simple implementation such as the leveldb and the community can add more implementations.

## Rationale
* A simple key-value store removes the requirement to manage the database schema.
* Any ACID-compatible database can be turned into a key-value store.
* Nowadays we have plenty of cloud providers for a hosted solution e.g. DynamoDB.

## Benefits
* HA and autoscaling is easier to achieve with stateless architecture.
* Fits well with modern hosting option e.g. Knative / Cloud Run.
* If atlantis / Hashicorp are to turn Atlantis into a hosted service, it will be easier to provide a hosted key-value backend.

Related: https://github.com/runatlantis/atlantis/issues/264
Hi,

Could be fine to integrate a command to launch test like `terratest` before merge.

something like:

`atlantis test` 

Do you have that or something like that in your roadmap? 
This adds flag to handle #884