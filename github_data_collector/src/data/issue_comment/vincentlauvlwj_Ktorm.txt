I wish we could have polymorphic relationships like we could do in Hibernate.

Indeed I know you can use interface to abstract out some of the fields, and put them into one own entity with such shared traits, to mock the behavior of polymorphic relationships, but it simply won't synchronize with the database design in mind.
I'm trying to use Ktorm on Android. Reading an existing database works fine with SQLDroid, but when I come to create records the function `BaseTable#insertAndGenerateKey()` fails with a null pointer error. The problem is that it results in a call to `conn.prepareStatement(sql, RETURN_GENERATED_KEYS)` which is not supported by SQLDroid.

å¤§ä½¬ï¼Œä½ å¥½ã€‚æˆ‘å°±æƒ³é—®é—®æ€ä¹ˆå°†æŸ¥è¯¢å‡ºæ¥ç»“æœä½¿ç”¨fastJSONè¿”å›ç»™å®¢æˆ·ç«¯ã€‚kotlinèŒæ–°ä¸€ä¸ªï¼Œå¤§ä½¬ä¸è¦éª‚æˆ‘ï¼Œè·ªè°¢å•¦ğŸ˜­
https://gitee.com/itdoer/ublog/blob/master/src/main/kotlin/top/rish/core/dao/BaseDaoImpl.kt
è¯šå¦‚æˆ‘ä¸ªäººé¡¹ç›®è¿™ä¸ªæ–‡ä»¶ï¼Œæˆ‘ä¸å¤ªä¼šå®ç°
`Database.connect("jdbc:mysql://127.0.0.1:3307/base-frame?charset=utf8mb4&useSSL=false", driver = "com.mysql.cj.jdbc.Driver", user = "root", password = "123456")`

var items2=iframeDict.findList { db.iframeDict.zdValue eq "ç§æœ‰åˆ†ç±»" }
items2 æŸ¥è¯¢ä¸åˆ°ç»“æœï¼Œå°†ä¸­æ–‡æ¢ä¸ºè‹±æ–‡ï¼ŒæŸ¥è¯¢æ­£å¸¸

ä»¥ä¸‹ä¸ºæ¨¡å‹å®šä¹‰ï¼š

object iframeDict : Table<iframeDict>("iframe_dict") {
val zdId by int("zd_ID").primaryKey().bindTo { it.zdId }
val zdName by varchar("zd_Name").bindTo { it.zdName }
val zdValue by varchar("zd_value").bindTo { it.zdValue }
val zdLabel by varchar("zd_label").bindTo { it.zdLabel }
val zdType by int("zd_type").bindTo { it.zdType }
val zdSort by int("zd_sort").bindTo { it.zdSort }
val zdParentid by int("zd_ParentID").bindTo { it.zdParentid }
val zdIsparent by int("zd_IsParent").bindTo { it.zdIsparent }
val zdIsshow by int("zd_IsShow").bindTo { it.zdIsshow }
val zdAttr by varchar("zd_Attr").bindTo { it.zdAttr }
}


interface iframeDict : Entity<iframeDict> {
companion object : Entity.Factory<iframeDict>()
val zdId: Int?
val zdName: String?
val zdValue: String?
val zdLabel: String?
val zdType: Int?
val zdSort: Int?
val zdParentid: Int?
val zdIsparent: Int?
val zdIsshow: Int?
val zdAttr: String?
}


![image](https://user-images.githubusercontent.com/45026715/71538147-46866200-2961-11ea-9c4e-6c30a2f904a0.png)
![image](https://user-images.githubusercontent.com/45026715/71538149-4dad7000-2961-11ea-9687-dfe7f4e4371f.png)
![image](https://user-images.githubusercontent.com/45026715/71538156-703f8900-2961-11ea-9c83-cfa912ec4164.png)
jdbcä¼šå°†ç»“æœè¿”å›ä¸ºboolean
è¿™æ˜¯æˆ‘ç”¨çš„é©±åŠ¨ç‰ˆæœ¬mysql:mysql-connector-java:5.1.48
èƒ½ä¸èƒ½ç›´æ¥æ‰§è¡Œsqlè¯­å¥ï¼Œè¿”å›Tæˆ–è€…List<T>
limitå’ŒorderByåŒæ—¶ä½¿ç”¨æ—¶ï¼Œcom.microsoft.sqlserver.jdbc.SQLServerException: Invalid column name 'AID'.ï¼Œä»£ç å¦‚ä¸‹ï¼š
var result = staff.innerJoin(department, on = department.aid eq staff.departmentAid)
                .innerJoin(stateStaff, on = stateStaff.id eq staff.stateId)
                .select(staff.phone, staff.name, stateStaff.name)
                .where { staff.aid eq 51 }
                .orderBy(staff.aid.desc())
                .limit(0, 15)
                .map { row -> StaffEntity(row[staff.phone] + "454", row[staff.name], row[stateStaff.name]) }

A few weeks ago, I implemented a service. Some tables had composite primary keys in SQL. I remember being astounded that this is implicitly supported when doing the Ktorm mapping.

Today I started integrating the service, but in the meantime, primary key uniqueness is checked (it is commit 2d341f1eaeca3a7e7588c8c5df862a3815014e81)! 

I wonder why it worked just as expected before...  maybe because I didn't use lookups by ID, but employed regular where clauses.

Have you already thought of how to realize compound/composite keys? I shall have a look, how other ORMs do it...
Hello.

I had a situation in which I had multiple `Database` s with the same connection parameters around. Rollback had no effect when I used the transaction scope as a method `db.useTransaction { ... }`, but succeeded whenever I used the function `useTransaction`, i.e. on the global instance.

I stepped through the code. `rollback` SQL is called reliably but in the case described above has no effect. 

As soon as I reduced the multiple connections to one, both ways of employing the transaction scope worked.

Maybe having multiple same connections is against the concept? Then of course it can also be correct undefined behaviour.

Great work by the way!