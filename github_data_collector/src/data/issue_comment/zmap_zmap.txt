Fixes #586

https://github.com/zmap/zmap/issues/586

Co-Authored-By: @rstrullu
We have the following bug to report. This bug targets all the known versions of Zmap.

In some (rare) cases, the IP generation of Zmap is flawed and the scan does not cover the full IP range or enter in an infinite loop. This occurs when the number generated by the random generator or the seed specified by the user (with the -e paramater or in the zmap.conf file) is equal to some problematic value. The probability is estimated to 7*10^(-9) (approximatively the euromillion jackpot probability) but is non zero. The bug can be reproduced with the following seed values and the current version of Zmap on github (commit f44fc15):

346296650 -> infinite loop
551370190 -> infinite loop
668513199 -> partial scan (63% of the scan)
950005475 -> partial scan (50% of the scan)
1853945527 -> partial scan (33% of the scan)
2250056444 -> infinite loop
2963139306 -> partial scan (12% of the scan)
8582731091 -> single IP generation
9561776755 -> single IP generation

This list is not exaustive and the number of problematic values is approximatively equal to 2^37.

The command line for testing the bug is the following:
zmap -p 80 -d -e [seed_value] | grep "ip" | wc -l
or equivalently for faster result:
ziterate -b ../conf/blacklist.conf -e [seed_value] | wc -l

The bug is due to the fact that the multiplication in the finite field is coded as a 64-bit unsigned multiplication followed by a modular reduction. This sequence of operations is sound when the two operands are less than 2^32. Some elements of the finite field used by Zmap are however greater than 2^32. In particular, if the primitive element generated by the RNG exceeds 2^32-14, then, during the generation of the cyclic group, one of the multiplication exceeds 2^64 and the multiplication in the finite field is flawed. Moreover, a special case occurs when the primitive element is greater than 2^32. In this case, the function that generates the primitive element (find_primroot) cast the value into 32 bits, resulting in a value that is not a primitive element.

To fix this bug, we recommand to modify the function that generate the primitive element of the finite field. However we do not recommand to change the multiplication of the finite field. Actually using a big number library like mpz will deeply impact the performance of the IP generation process. Moreover the multiplication on 64-bits and the reduction can be coded as two assembly instructions on modern CPUs and it is the most efficient method for coding the generation of the cyclic group. Therefore we only recommand to check that the primitive element is less or equal to 2^32-14. It ensures that all the multiplications with this operand will have a result less than 2^64. This can be done by modifying the function find_primroot in the file cyclic.c:

static uint32_t find_primroot(const cyclic_group_t *group, aesrand_t *aes)
{
  uint64_t retv;
  do {
	  uint32_t candidate =
	      (uint32_t)((aesrand_getword(aes) & 0xFFFFFFFF) % group->prime);
	  if (candidate == 0) {
		  ++candidate;
	  }
	  while (check_coprime(candidate, group) != COPRIME) {
		  ++candidate;
		  // special case where we need to restart check from begin
		  if (candidate >= group->prime) {
			  candidate = 1;
		  }
	  }
	  retv = isomorphism(candidate, group);
  } while (retv > ((1<<32)-14)); //bug fix
	return retv;
}

Rémi Strullu and Johan Mazel
A notable population of upnp devices respond using a non-standard srcport.
This commit removes the check for srcport == targetport for the validity checks,
leaving the decision of validity to the packet processor.
Can zmap be used for scanning network layer or transport layer?
I got a segmentation fault when using -X option. I use a PPPoE connection.

OS:
Ubuntu Desktop 18.04 LTS

version:
zmap Development Build. Commit f44fc15

commandline:
sudo zmap -p 443 -o openhost_tcp_443_20191104.txt -i ppp0 -X -r 100000

The code triggering the SEGV:
https://github.com/zmap/zmap/blob/f44fc155fe72f2ea63032b8b7dd39434865084af/src/recv.c#L76

backtrace:
Thread 2 "zmap" received signal SIGSEGV, Segmentation fault.
[Switching to Thread 0x7ffff65da700 (LWP 42933)]
__memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:226
226	../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S: No such file or directory
(gdb) bt
#0  __memmove_avx_unaligned_erms () at ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:226
#1  0x0000555555562f7a in handle_packet (buflen=56, bytes=0x7ffff5dd9fbc "") at /home/test/zmap/src/recv.c:76
#2  0x000055555557a365 in packet_cb (user=0x0, p=0x7ffff65d9d90, bytes=0x7ffff5dd9fbc "")
    at /home/test/zmap/src/recv-pcap.c:52
#3  0x00007ffff7b9a0b6 in ?? () from /usr/lib/x86_64-linux-gnu/libpcap.so.0.8
#4  0x00007ffff7b9ad64 in ?? () from /usr/lib/x86_64-linux-gnu/libpcap.so.0.8
#5  0x000055555557a75e in recv_packets () at /home/test/zmap/src/recv-pcap.c:126
#6  0x000055555556337e in recv_run (recv_ready_mutex=0x5555557a4380 <recv_ready_mutex>)
    at /home/test/zmap/src/recv.c:182
#7  0x0000555555566841 in start_recv (arg=0x5555557a6b90) at /home/test/zmap/src/zmap.c:101
#8  0x00007ffff6dd46db in start_thread (arg=0x7ffff65da700) at pthread_create.c:463
#9  0x00007ffff6afd88f in clone () at ../sysdeps/unix/sysv/linux/x86_64/clone.S:95
When multiple zmap processes are doing the UDP scanning on the same host, each zmap process will receive unrelated UDP responses belonging to other zmap processes. 

The bug reason is that the zmap UDP scan doesn't check whether the source port of received UDP response is same as the target port of the scanning. This bug only exists when multiple zmap processes run at the same time.
https://i.imgur.com/9zpQktp.png
I got this while trying to zmap and I have no idea how to fix it as I dont know a lot about VPS servers, could someone help?
In `output_modules/module_redis_csv.c` [line 185](https://github.com/zmap/zmap/blob/master/src/output_modules/module_redis_csv.c#L185), when copying `FS_BINARY` type field's value to the output buffer, the code is:

			hex_encode_str(out, (unsigned char *)f->value.ptr,
				       f->len);

This mistake (typo?) will cause that, when configured `--output-fields` to value like `saddr,timestamp_str,data`, the final output will only contain `data` field value -- `saddr` and `timestamp_str` values which have been copied to the `out` buffer will be overwritten by the above code mistakenly. 

The bug could be stably re-produced by the current HEAD code. Have tested the obvious bugfix method (of replacing `out` to `dataloc`) and that resolved the issue well. 
I am curious if zmap can support sending packets on one host and then receiving packets on another host？If it can, what command Ishould use?
**(see my last comment, this is the path that I took discovering this issue)**

During a zmap scan, I'm writing results to redis as resdis-csv format, and my redis queue is gaining a considerable amount more results than what is being reported in the zmap output.

For example, the 36.0.0.0/8 subnet at a 200/second rate is showing only 23 responses (after 10 minutes), but my redis queue has a factor of 100x the responses in the subnet.

I'm not sure if this is a bug with Redis, or some weird threading issue, but I'm running a second scan along side of the redis scan, outputting results to a file. The second scan is gathering results at a much slower rate even though the rate limit is set to 200.

What info do you need from me to look into this?