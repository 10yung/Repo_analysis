Support inject common mutations/getters/actions to each Module
### Version
3.1.2

### Reproduction link
[http://localhost:9529/login](http://localhost:9529/login)







### Steps to reproduce
1. typescript 正常书写modules 例如添加
@Action
public login() {}
2. webpack 采用热更新方式
3.修改modules代码 例如public login() { console.log(test)} 保存

### What is expected?
执行login的时候的用更新的代码

### What is actually happening?
以前的方法和新的方法都执行


---
热更新才会出现，需要动态的修改源码， 无法提供重现链接

正常打包不会出现这个问题，热更新的时候才会出现

查看store._actions 发现login对象是一个数组，有两条数据

<!-- generated by vue-issues. DO NOT REMOVE -->
### Version
3.1.2

### Reproduction link
[https://codepen.io/phymo/pen/bGNrJVQ](https://codepen.io/phymo/pen/bGNrJVQ)







### Steps to reproduce
vuex 3.1.2 shows tslint error: 
/node_modules/vuex/types/helpers.d.ts(8,85):
TS2370: A rest parameter must be of an array type.
/node_modules/vuex/types/helpers.d.ts(8,120):
TS2370: A rest parameter must be of an array type.


### What is expected?
no error

### What is actually happening?
updated to 3.1.2 then error occurs

<!-- generated by vue-issues. DO NOT REMOVE -->
Typo correction
That cause might be a promise.rejection or js error.

This way the action subscribers of the 'after' would not miss the end of the action,
as they would receive the existing 'action' and 'state' parameters, and the additional 'isSuccess' and 'errorResult' values. 
This applies for the then-side of the promise too, but there they would receive the result.

The true/false value might be useful for after action handlers, but the result might be too tempting to be used for modification for example, might be that too much info is handled out in this way. The same goes for the success-side of the after subscribers too.

While reviewing mind that: I cannot access github directly (firewalls), so this was a manual insertion of the locally working code. Typos might came along! (: In case there is a problem, tell me and I fix that, or say a thank you for your fix (:

when we use webpack,
and set babel presets property useBuiltIns is 'usage'
then the polyfill will be loaded when Promise used
so this way has a bug when we webpack,if we use vuex without used Promise,always show the error: vuex requires a Promise polyfill in this browser.

so I have change the validate Promise way to:
```
      try {
        new Promise(() => {})
      } catch (error) {
        assert(false, `vuex requires a Promise polyfill in this browser.`)
      }
```
This PR add the possibility to be warned in development for the problem described in 1120.
It adds a unit test for that scenario.

While testing this I found out another unit test that needed adjustment and did that in a separate commit. 

Fixes #1120
### Version
3.1.0

### Reproduction link
[https://codesandbox.io/s/vue-template-c2gtb](https://codesandbox.io/s/vue-template-c2gtb)







### Steps to reproduce
1. Open https://codesandbox.io/s/vue-template-c2gtb
2. Click on 'Go to Page with nested router' link
3. Click on 'commit event', it will show an alert box
4. Now change the nested route by clicking 'change nested route to reporting'

### What is expected?
Route changed to reporting without showing the 'hello' alert box.

### What is actually happening?
Its showing the 'hello' alert box again.

---
One of the releated issues
https://github.com/vuejs/vuex/issues/1570

<!-- generated by vue-issues. DO NOT REMOVE -->
### Version
3.1.1

### Reproduction link
[https://codesandbox.io/s/vuex-issue-with-mapstate-5zb3x](https://codesandbox.io/s/vuex-issue-with-mapstate-5zb3x)







### Steps to reproduce
In the reproduction link, there is a non namespaced module with has a count in it's state and a doubleCount in it's getters.

**In the HelloWorld component I am trying to use vuex helpers to access the state and the getters like:**

```js
...mapState(['count']),
...mapGetters(['doubleCount]')
```

### What is expected?
Since the module it's not namespaced I should be able to access the state and getters of the module with vuex helpers.

Both `mapState` and `mapGetters` should work fine.

### What is actually happening?
However, only the mapGetters helper it's working.

---
In order to get the `mapState` to work I should do:

```js
    ...mapState({
      count: state => state.myModule.count
    })
```

However IMHO, the mapState should work with just a string since the module in the end it's merged with the global store.

<!-- generated by vue-issues. DO NOT REMOVE -->