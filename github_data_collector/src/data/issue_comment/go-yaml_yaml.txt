My main goal is to allow a field of type `[][]string` to specify that the outer array is normal and the inner array is flow. With this FlowMarshaler it will become possible to accomplish that, as shown in the test case.
This is mainly a request and discussion proposal:
It has been around a year now since v3 is out. 
Is v3 not enough stable to mark it as default branch rather than v2?


I just realized this small typo while I was skimming through the documentation. I could've opened an issue but thought it'd be a hassle.
Such struct:
```
type Tmp struct {
	nodes []Node `yaml:"nodes,flow"`
}
```
will create such yaml file:
```
nodes: [{type: ss1, cipher: aes-256-cfb}, {type: ss2, cipher: aes-256-cfb}, {type: ss3, cipher: aes-256-cfb}, {type: ss4, cipher: aes-256-cfb}, {type: ss5, cipher: aes-256-cfb}]
```
Is there any way to create yaml file like this:
```
nodes:
  - {type: ss1, cipher: aes-256-cfb}
  - {type: ss2, cipher: aes-256-cfb}
  - {type: ss3, cipher: aes-256-cfb}
  - {type: ss4, cipher: aes-256-cfb}
  - {type: ss5, cipher: aes-256-cfb}
```
?
`
package main

import (
	"fmt"
	"io/ioutil"
	"log"

	"gopkg.in/yaml.v2"
)

//Nginx nginx  配置
type Nginx struct {
	Port    int    `yaml:"Port"`
	LogPath string `yaml:"LogPath"`
	Path    string `yaml:"Path"`
}

//Config   系统配置配置
type Config struct {
	Name      string  `yaml:"SiteName"`
	Addr      string  `yaml:"SiteAddr"`
	HTTPS     bool    `yaml:"Https"`
	SiteNginx []Nginx `yaml:"Nginx"`
}

func main() {
	var setting Config
	config, err := ioutil.ReadFile("./test.yaml")
	if err != nil {
		fmt.Print(err)
	}
	yaml.Unmarshal(config, &setting)
	data, err := yaml.Marshal(&setting)
	if err != nil {
		log.Fatalf("error: %v", err)
	}
	fmt.Printf("--- m dump:\n%s\n\n", string(data))
	ioutil.WriteFile("./out.yaml", data, 0777)
}
`

**Raw data：**

`
SiteName: seeta
SiteAddr: BeiJing
Https: true
Nginx:
    - Port: 443
      LogPath: >
          "/var/log//nginx/nginx.log"
      Path: "/opt/nginx/"
`

**Output after execution**

`
SiteName: seeta
SiteAddr: BeiJing
Https: true
Nginx:
- Port: 443
  LogPath: |
    "/var/log//nginx/nginx.log"
  Path: /opt/nginx/
`
the right arrow becomes vertical   "> "  ==>   "|"

=============================================
region: !region_component   ======>  region: ""


In some scenarios, you cannot manually add the `yaml` tag, such as grpc's automatic code generation. Such as:
```go
// Code generated by protoc-gen-go. DO NOT EDIT.
//...
type Metadata struct {
	Name                 string            `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
        //...
}
```

work flow：yaml(go struct) -> grpc -> server


I have drafted injection of struct info options to make them configurable. Are you okay with this approach?

I have tested marshaling/unmarshaling as follows:
```go
func MustParseConfig(s string) *Config {                                                   '.
    var cfg Config                                                                                 
    err := yaml.Unmarshal([]byte(s), &cfg)                                          
    if err != nil {                                                                        '.
        panic(fmt.Errorf("invalid config: %w", err))                                         
    }                                                                                               
    return &cfg                                                                                     
}                                                                                                   
                                                                                                    
func (c *Config) String() string {                                                                  
    b, _ := yaml.Marshal(c, yaml.WithFieldNameMarshaler(FieldNameMarshaler))                        
    return string(b)                                                                                
}                                                                                                   
                                                                                                    
func FieldNameMarshaler(f reflect.StructField) string {                                             
    return f.Name
}
```
```golang
package main                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  

import (
        "fmt"

        "gopkg.in/yaml.v2"
)

type Yerson struct {
        Provider struct {
                RootURL string `yaml:"rootURL"`
        } `yaml:"provider"`
}

func main() {
        var p1 Yerson
        err := yaml.Unmarshal([]byte("---\r\nprovider:\r\n  rootURL: abc\r\n"), &p1)
        if err != nil {
                fmt.Printf("err: %v\n", err)
                return
        }
        fmt.Printf("%#v\n", p1)
}
```

The above works correctly, but changing `v2` to `v3` causes it to fail with
```
err: yaml: line 3: mapping values are not allowed in this context
```

This seems to violate [YAML-1.2 section 5.4](https://yaml.org/spec/1.2/spec.html#id2774608).
Yaml that contains a merge key `<<` that is Unmarshaled into a `Node` and then Marshaled again has `!!merge <<` where `<<` is expected

Example: 

```
func main() {
	yamlNode := &yaml.Node{}
	contents := "<<: a"

	err := yaml.Unmarshal([]byte(contents), yamlNode)
	if err != nil {
		panic(err)
	}
	out, err := yaml.Marshal(yamlNode)
	if err != nil {
		panic(err)
	}

	log.Printf("expected :%v", string(contents))
	log.Printf("actual: %v", string(out))
}
```

Outputs:
```
expected :<<: a
actual: !!merge <<: a
```
Hi there! ,

I was just testing the indentation for a custom encoder and I saw different results for lists.

This is an example test:

```golang
import (
	"bytes"
	"fmt"
	"testing"

	"gopkg.in/yaml.v3"
)

type Element struct {
	One string `yaml:"one"`
	Two string `yaml:"two"`
}

type Elements struct {
	S []Element `yaml:"elements"`
}

type Root struct {
	Elements Elements `yaml:"root"`
}

func TestSliceIndent(t *testing.T) {
	root := Root{Elements{[]Element{{"one", "two"}}}}

	out, err := encode(root, 2)
	if err != nil {
		t.Error(err)
	}
	fmt.Printf("Encode 2 spaces: \n%s\n", string(out))

	out, err = encode(root, 4)
	if err != nil {
		t.Error(err)
	}
	fmt.Printf("Encode 4 spaces: \n%s\n", string(out))

	out, err = encode(root, 3)
	if err != nil {
		t.Error(err)
	}
	fmt.Printf("Encode 3 spaces: \n%s\n", string(out))

}

func encode(r Root, spaces int) ([]byte, error) {
	var b bytes.Buffer
	e := yaml.NewEncoder(&b)
	e.SetIndent(spaces)

	if err := e.Encode(&r); err != nil {
		return nil, err
	}
	return b.Bytes(), nil

}

```text

Encode 2 spaces:
root:
  elements:
  - one: one
    two: two

Encode 4 spaces:
root:
    elements:
      - one: one
        two: two

Encode 3 spaces:
root:
   elements:
    -
     one: one
     two: two

```

*All the results are valid yaml*, but I think the lists should have the format like the 4 spaces result. Also the 3 spaces indentation seems strange, although I don't know if anyone is using an odd number for indention 😄 . 

