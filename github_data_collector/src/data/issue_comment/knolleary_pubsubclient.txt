I've recently started to see the broker complaining about connection timeouts.  Some messages that seem to have been pubished OK also are not received.  It turns out that the fix is to delay for ~500ms before turning off the WiFi after a call to disconnect().  Presumably this is to allow time for the preceding messages and the disconnect to be transmitted or for an ACK to be received or something.

Is this normal/expected?  If so, is it possible to tell when it is safe to put the processor (ESP8266) to sleep after a disconnect() call? ie to find out when all the messages have actually been sent to the server?  I realise this may be determined from the WiFiClient perhaps.
is it possible to get QoS level in 2 in subscribe function ?? 
and please guide me if it is possible then is it possible to publish a message two times and get it delivered two times ?? or it will just be delivered only once in a life time if the topic is the same 
Get this panic after subscribing to other clients published topics. ( 3 in total) If I don't subscribe then all is fine. The panic occurs every 5-6hrs, clients publish data every 2 seconds. I'm using PubSub Client 2.7 with Arduino IDE 1.8.10 and ESP32, MQTT Server running on RPi.

Guru Meditation Error: Core  1 panic'ed (InstrFetchProhibited). Exception was unhandled.
11:26:01.081 -> Core 1 register dump:
11:26:01.081 -> PC      : 0x24401563  PS      : 0x00060630  A0      : 0x800d1989  A1      : 0x3ffcb480  
11:26:01.081 -> A2      : 0x3ffc1a94  A3      : 0x24401563  A4      : 0x00000001  A5      : 0x000efa59  
11:26:01.081 -> A6      : 0x00000001  A7      : 0x3ffc4edd  A8      : 0x800d3efd  A9      : 0x00000000  
11:26:01.081 -> A10     : 0x3ffc1b30  A11     : 0x3ffcb4a4  A12     : 0x3ffcb4a8  A13     : 0x3ffcb4ac  
11:26:01.081 -> A14     : 0x00000036  A15     : 0x00000038  SAR     : 0x0000000a  EXCCAUSE: 0x00000014  
11:26:01.081 -> EXCVADDR: 0x24401560  LBEG    : 0x4000c2e0  LEND    : 0x4000c2f6  LCOUNT  : 0xffffffff  
11:26:01.081 -> 
11:26:01.081 -> Backtrace: 0x24401563:0x3ffcb480 0x400d1986:0x3ffcb4d0 0x400d66d1:0x3ffcb4f0 0x4008d8d5:0x3ffcb510
11:26:01.081 -> 
11:26:01.081 -> Rebooting...
11:26:01.115 -> ets Jun  8 2016 00:22:57
11:26:01.115 -> 
11:26:01.115 -> rst:0xc (SW_CPU_RESET),boot:0x13 (SPI_FAST_FLASH_BOOT)
11:26:01.115 -> configsip: 0, SPIWP:0xee
11:26:01.115 -> clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
11:26:01.115 -> mode:DIO, clock div:1
11:26:01.115 -> load:0x3fff0018,len:4
11:26:01.115 -> load:0x3fff001c,len:1216
11:26:01.115 -> ho 0 tail 12 room 4
11:26:01.115 -> load:0x40078000,len:9720
11:26:01.115 -> ho 0 tail 12 room 4
11:26:01.115 -> load:0x40080400,len:6352
11:26:01.115 -> entry 0x400806b8

Code
#include <WiFi.h>
#include <PubSubClient.h>
#include <Timer.h>
#include <TimeLib.h>
#include <WiFiUdp.h>
#include <ArduinoOTA.h>


#define DEBUG 0
#define ANALOG_PIN 34

bool doorbellpushed = false;
bool timeisvalid = false;
bool blink = false;
bool connected = false;
bool  dataReady = false;

String DeviceID = "esp32-xx";  
String Location = "Front Door";
String firmware = "1.0";   
String movementTime = ".";
String bootTime=".";
String ip;
String alexa = "enabled";
String doorbellpushedTime = ".";
String currentTime;
String uTime = "??";
String topicData = "??";
String topic = "??";

Timer mqttPublish;
Timer IswiFiConnected;
Timer mqttSubscribe;
Timer cpuLED;



time_t LocalTime;


struct tm timeinfo;

// WiFi network name and password:
const char * networkName = "XXXXXXXX";
const char * networkPswd = "xxxxxxxxxxx";
const char mqttpwd[]= "xxxxxxxxxxxxxxxxxxxx";   // make unique for each device


unsigned long uptime = 0;
long lastReconnectAttempt = 0;
long iteration = 0;
int CpuledPin = 2;                  // change to 2
int deviceReset = 0;
int presence = 1;                   // 0=offline, 1=active
int port = 1883;
int onetime = 0;


char buffer[100];                  
char timeServer[] =       "uk.pool.ntp.org"; 
char MQTTServer[] = "xxx.xxx.xxx.xxx"; 

WiFiClient wifiClient;
PubSubClient client(wifiClient);

void callback(char* pubtopic, byte* payload, unsigned int len) {
  
 
   
    
 iteration++;
   dataReady = false;
  //Serial.print("Callback...");
  //Serial.println(iteration);
           
}


bool reconnect() {   // loops 10
  int loopcounter = 10;
  
  // Loop until we're reconnected
  while (!client.connected()) {
    Serial.print("Attempting MQTT connection...");
    // Attempt to connect
    if (client.connect("xxxxxxx", "xxxxxxx", mqttpwd) ) {
      Serial.println("connected");
     
    } else {
     
      Serial.print("failed, rc=");
      Serial.print(client.state());
      Serial.println(" try again in 5 seconds");
      // Wait 5 seconds before retrying
      delay(5000);
       --loopcounter;
      if(loopcounter == 0)
      {
       
        ESP.restart();
      }
    }
    
  }
  return client.connected();
}



void setup(){
  
  // Initilize hardware serial:
  Serial.begin(115200);
  btStop();
  setenv("TZ","GMT0BST,M3.5.0/01,M10.5.0/02",1);
  
  
  

// OTA SETUP

WiFi.mode(WIFI_STA);
DeviceID.toCharArray(buffer,DeviceID.length() + 1);
ArduinoOTA.setHostname(buffer);

  // Port defaults to 3232                            // ArduinoOTA.setPort(3232);
  // Hostname defaults to esp3232-[MAC]               // ArduinoOTA.setHostname("myesp32");
  // No authentication by default                     // ArduinoOTA.setPassword("admin");
  // Password can be set with it's md5 value as well  // MD5(admin) = 21232f297a57a5a743894a0e4a801fc3
  // ArduinoOTA.setPasswordHash("21232f297a57a5a743894a0e4a801fc3");
  ArduinoOTA.onStart([]() {
    String type;
    if (ArduinoOTA.getCommand() == U_FLASH)
      type = "sketch";
    else // U_SPIFFS
      type = "filesystem";
    // NOTE: if updating SPIFFS this would be the place to unmount SPIFFS using SPIFFS.end()
    Serial.println("Start updating " + type);
  });
  ArduinoOTA.onEnd([]() { Serial.println("\nEnd"); });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) {
    Serial.printf("Error[%u]: ", error);
    if (error == OTA_AUTH_ERROR)         Serial.println("Auth Failed");
    else if (error == OTA_BEGIN_ERROR)   Serial.println("Begin Failed");
    else if (error == OTA_CONNECT_ERROR) Serial.println("Connect Failed");
    else if (error == OTA_RECEIVE_ERROR) Serial.println("Receive Failed");
    else if (error == OTA_END_ERROR)     Serial.println("End Failed");
  });
  
ArduinoOTA.begin();

        
  //Connect to the WiFi network
  connectToWiFi(networkName, networkPswd);
  
  pinMode(CpuledPin, OUTPUT);
 

  
  digitalWrite(CpuledPin, HIGH);                          // Indicate Startup
  client.setServer(MQTTServer,port);                     
  client.setCallback(callback);
  configTime(0, 0, timeServer);
  
  Serial.println();
  Serial.print("Waiting for NTP TIME Server .");
  bool rc = localTime();
  int loopCounter = 200;
  
while (!rc && loopCounter > 0) {
  configTime(0, 0, timeServer);
  rc = localTime();
  Serial.print(".");
  delay(500);
  --loopCounter;
  if(loopCounter == 0){
    ESP.restart();
  }
  
}

  Serial.println();
  Serial.print("Successfully obtained TIME from NTP Server: ");
  Serial.println(timeServer);

  setenv("TZ","GMT0BST,M3.5.0/01,M10.5.0/02",1);

  cpuLED.every(750,ledBlink);                               // 750ms - blink led
  
  mqttPublish.every(2000, mqttUpdate);                      // 2s

  mqttSubscribe.every(1000000, subscribeMQTT);              // 1000s
   
  IswiFiConnected.every(60000, wiFiConnected);              // 60s
  
  digitalWrite(CpuledPin, LOW);

  bootTime = timeToString();
  
  
 
}

void loop()
{
  ArduinoOTA.handle();
 
  localTime();
 
  cpuLED.update();
  
  mqttPublish.update();
  
  mqttSubscribe.update();
    
  IswiFiConnected.update();
  
  if (!client.connected()) {
    long now = millis();
    if (now - lastReconnectAttempt > 5000) {
      lastReconnectAttempt = now;
      // Attempt to reconnect
      if (reconnect()) {
        lastReconnectAttempt = 0;
      }
    }
  } else {
    // Client connected

    client.loop();
  }


}


void ledBlink()
{
if(!blink) {
    digitalWrite(CpuledPin, HIGH);
    blink = true;
    return;
}
   
   if(blink) {
   digitalWrite(CpuledPin, LOW);
    blink = false;
   }
   
   
}



bool localTime()
{
  setenv("TZ","GMT0BST,M3.5.0/01,M10.5.0/02",1);
  
  if(!getLocalTime(&timeinfo)){
    Serial.print("Failed to obtain time - retrying ..");
    Serial.println();
    timeisvalid = false;
    return false;
  }
  
  
 
  currentTime = timeToString();
  timeisvalid = true;
  return true;
  
}
  
void mqttUpdate() {
  int len = 0;
  

     
      memset(buffer,0,100);
    
      
      firmware.toCharArray(buffer, 5);
      client.publish("home/dev1/status/firmware",buffer);

      len = DeviceID.length();
      DeviceID.toCharArray(buffer, len + 1);
      client.publish("home/dev1/status/deviceID", buffer);   

      len = Location.length();
      Location.toCharArray(buffer, len + 1);
      client.publish("home/dev1/status/location", buffer);
      
      uptime = uptime + 2;
      dtostrf(uptime,0, 0, buffer);
      client.publish("home/dev1/status/uptime", buffer);
    
      len = bootTime.length();
      bootTime.toCharArray(buffer, len + 1);
      client.publish("home/dev1/status/boot", buffer);
           
      len = ip.length();
      ip.toCharArray(buffer, len + 1);
      client.publish("home/dev1/status/ip", buffer);

      currentTime = timeToString();
      len = currentTime.length();
      currentTime.toCharArray(buffer, len + 1);  // just show time
      client.publish("home/dev1/status/time", buffer);


     

    
      dtostrf(iteration,0, 0, buffer);
      client.publish("home/dev1/status/CallBackCount", buffer); 


      if(onetime == 0)  {
        subscribeMQTT();
        delay(500);
        subscribeMQTT();
        ++onetime;
      }
  }


void wiFiConnected()
{
  int wifiStatus = 0;
  
  
 
    wifiStatus = WiFi.status();
  

  if(wifiStatus != WL_CONNECTED)
  {
    Serial.println("No wi-fi connectivity detected, restarting esp32..");   
        
        ESP.restart();

    
  }

  
}






void lastError()
{
    String p = "Startup";
    return;
  
}
  


void subscribeMQTT() {

      client.subscribe("home/dev1/cmd/reset",0);
      client.subscribe("home/dev2/status/uptime",0);
      client.subscribe("home/dev3/status/uptime",0);
      client.subscribe("home/dev4/status/uptime",0);
}

void connectToWiFi(const char * ssid, const char * pwd)
{
  Serial.println("Connecting to WiFi network: " + String(ssid));

  // delete old config
  WiFi.disconnect(true);
  
  //register event handler
  WiFi.onEvent(WiFiEvent);
  
  //Initiate connection
  WiFi.begin(ssid, pwd);

  Serial.println("Waiting for WIFI connection...");
}


void WiFiEvent(WiFiEvent_t event)
{
    switch(event) {
      case SYSTEM_EVENT_STA_GOT_IP:
          //When connected set 
          Serial.println();
          Serial.print("WiFi connected! IP address: ");
          Serial.println(WiFi.localIP()); 
          ip = WiFi.localIP().toString();
           
          //initializes the UDP state
          //This initializes the transfer buffer
          //udp.begin(WiFi.localIP(),udpPort);
          connected = true;
          
          break;
      case SYSTEM_EVENT_STA_DISCONNECTED:
          Serial.println("WiFi lost connection - restarting ESP32");
          connected = false;
          ESP.restart();
          break;
    }
}



String timeToString ()
{
  String s = "";
  String f = "0";

 
  
  if(timeinfo.tm_hour < 10 )
     { 
      s = s + f;
     }
      s = s + timeinfo.tm_hour;
      
 s = s + ":" ;
 
 if(timeinfo.tm_min < 10 )
     { 
      s = s + f;
     }
     
 s = s + timeinfo.tm_min;
 s = s + ":";
 
 if(timeinfo.tm_sec < 10 )
     { 
      s = s + f;
     }
 s = s + timeinfo.tm_sec;
 
 s = s + "  " + timeinfo.tm_mday; 
 s = s + "-" + (timeinfo.tm_mon + 1);
 s = s +"-" +  (timeinfo.tm_year + 1900);
 

  return s;
  
}




Hi there,

I'm working on a project where I want to connect a Controllino with an ESP8266-01 WiFi module. 
I can successfully connect to a WiFi and connect to a local (C#-based) broker on that WiFi. Both the PubSubClient and the broker confirms this.

However, I have run into an issue when I want to check for new messages and renew the connection (via mqttClient.loop()) in the void loop method. Likewise, if I want to check the current connectivity state (mqttClient.connected()), my WiFi connectivity stops working entirely, and I am no longer able to connect to the WiFi.

```//Libraries needed.
#include <PubSubClient.h>
#include <WiFiEsp.h>
#include <Controllino.h>  //Baseline Controllino library. Mandatory in order to use CONTROLLINO_xx aliases for pins in sketch.

//WiFi credentials, and Broker information.
char ssid[] = "XXXXX";            // Network SSID (name)
char pass[] = "xxxxxx!";        // Network password
int status = WL_IDLE_STATUS;     // the WiFi radio's status

char serverIP[] = "192.168.43.40";
int portNumber = 1883;
//char macArrayToSend[6]; For later use

//Setting up arrays for easier management of leds and buttons.
int buttonLEDs[] = {CONTROLLINO_D0, CONTROLLINO_D1, CONTROLLINO_D2, CONTROLLINO_D3, CONTROLLINO_D4, CONTROLLINO_D5, CONTROLLINO_D6, CONTROLLINO_D7, CONTROLLINO_D8};
int buttonAnalog[] = {CONTROLLINO_A0, CONTROLLINO_A1, CONTROLLINO_A2, CONTROLLINO_A3, CONTROLLINO_A4, CONTROLLINO_A5, CONTROLLINO_A6, CONTROLLINO_A7, CONTROLLINO_A8};

//WiFi Client. Used to establish connection to local WiFi
WiFiEspClient espClient;

//MQTT Client
PubSubClient mqttClient(serverIP, portNumber, espClient);

void callback(char* topic, byte* payload, unsigned int length) {
  Serial.print("Message arrived [");
  Serial.print(topic);
  Serial.print("] ");
  for (int i=0;i<length;i++) {
    Serial.print((char)payload[i]);
  }
  Serial.println();
}

//----------* Functions *---------//
void setupMQTTClient(){
  Serial.println("[MQTT] Attempting to connect to broker...");

  mqttClient.setCallback(callback);
  bool connectionResult = mqttClient.connect("CONTROLLINO", "superSecretUN", "superSecretPW");
    
  Serial.print("[MQTT] Connection result: ");
  Serial.println(connectionResult);

  while (!connectionResult){
    Serial.println("[MQTT] Connection failed!");
    delay(1500);
    connectionResult = mqttClient.connect("CONTROLLINO", "superSecretUN", "superSecretPW");
  }

  if (connectionResult){
    Serial.println("[MQTT] Connection established!");
    Serial.println("[MQTT] Subscribing to topic...");
    //mqttClient.subscribe("CONTROLLINO", 1); //Breaks the program
  }
}


void setupWiFi(){
  WiFi.init(&Serial2); //Initialize connection via Serial2.
     
  if (WiFi.status()==WL_NO_SHIELD){
    Serial.println("WiFiEsp] WiFi shield not present");
    while(true);
  }

  while (status != WL_CONNECTED) {
    Serial.print("[WiFiEsp] Attempting to connect to WPA SSID: ");
    Serial.println(ssid);
    // Connect to WPA/WPA2 network
    status = WiFi.begin(ssid, pass);
  }
  Serial.println("[WiFiEsp] WiFi connection established!");
  Serial.print("WIFI Status: ");
  Serial.println(status);
  
}

//Turns on a button LED and waits for button press before continuing.
bool turnOnButton(int input){
  if (input > 24){ //Edge cases where designated LED does not exist in PLC.
    return false;
  }
  if (input == -1){ //Edge case where a reset of all LEDs is requested.
    for (int i = 0; i < sizeof(buttonLEDs); i++){
      digitalWrite(buttonLEDs[i], LOW);
    }
    return true;
  }
  else{
    //Turn on LED
    digitalWrite(buttonLEDs[input], HIGH);
    
    while(digitalRead(buttonAnalog[input])== LOW){
      //Keep waiting for the user to push the button.
    }
    //The button has been pushed down by the user.
    Serial.println("Button pushed");
    digitalWrite(buttonLEDs[input], LOW);
    return true;                
  }
}

void printWifiStatus()
{
  //Print the SSID of the network currently connected to.
  Serial.print("SSID: ");
  Serial.println(WiFi.SSID());

  //Print WiFi module's IP address.
  IPAddress ip = WiFi.localIP();
  Serial.print("IP Address: ");
  Serial.println(ip);

  //Print WiFi module's MAC address.
  byte mac[6]={0,0,0,0,0,0};
  WiFi.macAddress(mac);
  Serial.print("MAC Address: ");
    Serial.print(mac[5], HEX);
    Serial.print(":");
    Serial.print(mac[4], HEX);
    Serial.print(":");
    Serial.print(mac[3], HEX);
    Serial.print(":");
    Serial.print(mac[2], HEX);
    Serial.print(":");
    Serial.print(mac[1], HEX);
    Serial.print(":");
    Serial.println(mac[0], HEX);
  
  //Print the received signal strength.
  long rssi = WiFi.RSSI();
  Serial.print("Signal strength (RSSI):");
  Serial.print(rssi);
  Serial.println(" dBm");
}

//Set up pins and LEDS using arrays.
void setupPins(){
  Serial.println("[CONTROLLINO] Setting up pins...");
  for (int i = 0; i < sizeof(buttonLEDs); i++){ 
    //Set up LED pins.
    pinMode(buttonLEDs[i], OUTPUT);
    digitalWrite(buttonLEDs[i], LOW);
    //Set up analog pins.
    pinMode(buttonAnalog[i], INPUT);
  }
  Serial.println("[CONTROLLINO] Pin setup succeeded");
}

void testButton(int input){
  bool test = false;
  Serial.print("Testing button: ");
  Serial.println(input);

  test = turnOnButton(input);
  if (test == true){
    Serial.println("Button succeeded");
  }else{
    Serial.println("Button failed");
  }
}
//----------* End of Functions *---------//


void setup() {
  Serial.begin(9600); //Regular serial printout to COM
  Serial2.begin(115200); //Serial connection to ESP8266 WiFi module

  setupPins();

  setupWiFi();
  
  printWifiStatus();
  
  setupMQTTClient();
}

void loop() {
  //mqttClient.loop() Breaks the program
}
```


Any help would be greatly appreciated, as I am at my wits end trying to get it to work ðŸ˜¢ 
must have statement for current Arduino Framework, see also https://github.com/knolleary/pubsubclient/issues/138#issuecomment-326113915
I loaded the code on arduino uno, and after 3/4 hours it crashes on time, can you help me?
I also tried with arduino due but it crashes after about 2 days


#include <Ethernet.h>
#include <PubSubClient.h>
#include <SPI.h>
#define CLIENT_ID       "Giardino"
//#define TOPIC           "temp"
#define PUBLISH_DELAY    3000
#define subscribe_DELAY    50000
//#include <avr/dtostrf.h>

#define relayPin1 6
#define relayPin2 4
#define relayPin3 5
#define relayPin4 7


String ip = "";
bool relaystate1 = LOW;
bool relaystate2 = LOW;
bool relaystate3 = LOW;
bool relaystate4 = LOW;
//int luminosita;  //Il valore letto dalla fotoresistenza
//int umidita;
//int sensorepioggia;
int x=0;
int a=0;
int b=0;
int c=0;
int CICLO=1;
unsigned long y=0;

EthernetClient Giardino;
PubSubClient mqttClient(Giardino);

unsigned long previousMillis;
unsigned long previousMillis2;
unsigned long lastMillis;

uint8_t mac[6] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x02};



void setup() {
   pinMode(relayPin1, OUTPUT);
  pinMode(relayPin2, OUTPUT);
  pinMode(relayPin3, OUTPUT);
  pinMode(relayPin4, OUTPUT);
  
   pinMode(A1, INPUT);
   pinMode(8, INPUT_PULLUP);
   pinMode(2,INPUT);
  // setup serial communication

  Serial.begin(9600);
  while (!Serial) {};
  Serial.println(F("MQTT Arduino Demo"));
  if (Ethernet.begin(mac) == 0) {
    //Serial.println(F("Unable to configure Ethernet using DHCP"));
    for (;;);
  }

  Serial.println(F("Ethernet configured via DHCP"));
  Serial.print(F("IP address: "));
  Serial.println(Ethernet.localIP());
  Serial.println();
  /*
    Serial.println(Ethernet.localIP()[0]);
    Serial.println(Ethernet.localIP()[1]);
    Serial.println(Ethernet.localIP()[2]);
    Serial.println(Ethernet.localIP()[3]);
  */
  if (Ethernet.linkStatus() == LinkOFF) {
    //Serial.println(F("Ethernet cable is not connected."));
  }

  ip = String (Ethernet.localIP()[0]);
  ip = ip + ".";
  ip = ip + String (Ethernet.localIP()[1]);
  ip = ip + ".";
  ip = ip + String (Ethernet.localIP()[2]);
  ip = ip + ".";
  ip = ip + String (Ethernet.localIP()[3]);
  //Serial.println(ip);

  // setup mqtt client
  mqttClient.setClient(Giardino);
  //mqttClient.setServer(mqttServer, 1883);
  // mqttClient.setServer("test.mosquitto.org", 1883);
  //  mqttClient.setServer( "raspberrypi.local",1883);
  //mqttClient.setServer("io.adafruit.com",1883);
  mqttClient.setServer( "server", 1883);
  //Serial.println(F("MQTT client configured"));
  mqttClient.setCallback(callback);
  
  previousMillis = millis();
 
 
    
    Serial.println();
}

  

  void loop() {
  
 while (!mqttClient.connected()) {

// Attempt to connect
mqttClient.connect("Giardino");

}
   char msgBuffer[20];
  if (millis() - previousMillis2 > subscribe_DELAY){
        //luminosita = !digitalRead(2);  //Lettura della luminositÃ 
       //sensorepioggia=digitalRead(8);
       //umidita = analogRead(A1);
       previousMillis2 = millis();
      mqttClient.publish("casa/Giardino/umiditÃ ",dtostrf(analogRead(A1),0,2, msgBuffer));
      mqttClient.publish("casa/Giardino/luminosita",dtostrf( (!digitalRead(2)),1,0, msgBuffer));
      mqttClient.publish("casa/Giardino/sensorepioggia",dtostrf(digitalRead(8),0,1, msgBuffer));


}
  if (millis() - previousMillis > PUBLISH_DELAY) {
      
    
    sendData();
    previousMillis = millis();
    relaystate1 = digitalRead(relayPin1);// Reads the state of a relay
    relaystate2 = digitalRead(relayPin2);// Reads the state of a relay
    relaystate3 = digitalRead(relayPin3);// Reads the state of a relay
    relaystate4 = digitalRead(relayPin4);// Reads the state of a relay
    //Serial.println(digitalRead(8));
  
  }

  mqttClient.loop();
  
   if (x == 1)
  {
    if (millis() - lastMillis > y && a == 1) 
    { //Serial.println(F("iniziato Ciclo If"));
      delay(10000);
      digitalWrite(relayPin2, LOW);
      b = 1;
      lastMillis = millis();
      digitalWrite(relayPin3, HIGH);
      a = 0;
      mqttClient.publish("casa/Giardino/conferma3", "1");
      mqttClient.publish("casa/Giardino/conferma2", "0");
    }
    if (b == 1)
    {
      if (millis() - lastMillis > y && b == 1)
      { //Serial.println(F("secondo step"));
        delay(10000);
        digitalWrite(relayPin3, LOW);
        b = 0;
        lastMillis = millis();
        c =1;
        digitalWrite(relayPin4, HIGH);
        mqttClient.publish("casa/Giardino/conferma4", "1");
      mqttClient.publish("casa/Giardino/conferma3", "0");
       
      }
    }
    if (c == 1)
    {
      if (millis() - lastMillis > y && c == 1)
      { Serial.println("terzo step");
        delay(10000);
        digitalWrite(relayPin4, LOW);
        c = 0;
        lastMillis = millis();
        
      mqttClient.publish("casa/Giardino/conferma4", "0");
          // Serial.println(F("fine ciclo irrigazione"));
      }
  }
  
  
}

 

 
}


void sendData() {
  
  char msgBuffer[20];
   
  if (mqttClient.connect(CLIENT_ID)) {
    
      
    mqttClient.subscribe("casa/Giardino/sb1");
    mqttClient.subscribe("casa/Giardino/sb2");
    mqttClient.subscribe("casa/Giardino/sb3");
    mqttClient.subscribe("casa/Giardino/sb4");
    mqttClient.subscribe("casa/Giardino/ciclo");
    mqttClient.subscribe("casa/Giardino/iniziociclo");
    mqttClient.subscribe("casa/Giardino/presenza");
    
   
  }
}

void callback(char* topic, byte* payload, unsigned int length) {
  char msgBuffer[20];
  
  // I am only using one ascii character as command, so do not need to take an entire word as payload
  // However, if you want to send full word commands, uncomment the next line and use for string comparison
   //payload[length] = '\0';            // terminate string with '0'
  //String strPayload = String((char*)payload);  // convert to string
  // Serial.println(strPayload); //can use this if using longer southbound topics
  //Serial.print(F("Message arrived ["));
  //Serial.print(topic);
  String topicStr = topic;
  String messageTemp;
 /* Serial.print("] ");//MQTT_BROKER
  Serial.println();
  Serial.print(F("Topic: "));
  Serial.println(topicStr);
  */
  for (int i = 0; i < length; i++) {
    //Serial.print((char)payload[i]);
    
    messageTemp += (char)payload[i];
  }
  //Serial.println();
 // Serial.println(payload[0]);
  
  
  
   if (topicStr == "casa/Giardino/sb1") 
    {


  if (messageTemp == "1")             // Message "1" in ASCII (turn output ON)
  {
        //
    digitalWrite(relayPin1, HIGH);
    mqttClient.publish("casa/Giardino/conferma1", "1");
  } else if (messageTemp == "0")      // Message "0" in ASCII (turn output OFF)
  {
    digitalWrite(relayPin1, LOW);     //
    mqttClient.publish("casa/Giardino/conferma1", "0");
    ;
  }

    
   }
   
   if (topicStr == "casa/Giardino/sb2") 
    {


  if (messageTemp == "1")             // Message "1" in ASCII (turn output ON)
  {
        //
     mqttClient.publish("casa/Giardino/conferma2", "1");
    digitalWrite(relayPin2, HIGH);
  } else if (messageTemp == "0")      // Message "0" in ASCII (turn output OFF)
  {
    digitalWrite(relayPin2, LOW);     //
     mqttClient.publish("casa/Giardino/conferma2", "0");
    
  }

    
   }
    if (topicStr == "casa/Giardino/sb3") 
    {


  if (messageTemp == "1")             // Message "1" in ASCII (turn output ON)
  {
        //
     mqttClient.publish("casa/Giardino/conferma3", "1");
    digitalWrite(relayPin3, HIGH);
  } else if (messageTemp == "0")      // Message "0" in ASCII (turn output OFF)
  {
    digitalWrite(relayPin3, LOW);     //
     mqttClient.publish("casa/Giardino/conferma3", "0");
    
  }

    
   }
    if (topicStr == "casa/Giardino/sb4") 
    {


  if (messageTemp == "1")             // Message "1" in ASCII (turn output ON)
  {
        //
     mqttClient.publish("casa/Giardino/conferma4", "1");
    digitalWrite(relayPin4, HIGH);
  } else if (messageTemp == "0")      // Message "0" in ASCII (turn output OFF)
  {
    digitalWrite(relayPin4, LOW);     //
     mqttClient.publish("casa/Giardino/conferma4", "0");
    
  }

    
   }

    if (topicStr == "casa/Giardino/ciclo") 
    {
CICLO =  messageTemp.toInt();


  mqttClient.publish("casa/Giardino/confermareciclo", messageTemp.c_str()); 
   y = CICLO * 50000;
    
   }
 
   if (topicStr == "casa/Giardino/iniziociclo") 
    { 
       if (messageTemp == "1")             // Message "1" in ASCII (turn output ON)
  {
        //
      x=1;
      a=1;
      digitalWrite(relayPin2, HIGH);
      mqttClient.publish("casa/Giardino/conferma2", "1");
      mqttClient.publish("casa/Giardino//conferma/iniziociclo", "1");
  } else if (messageTemp == "0")      // Message "0" in ASCII (turn output OFF)
  {
      x=0;
      a=0;
      
       mqttClient.publish("casa/Giardino//conferma/iniziociclo", "0");
  digitalWrite(relayPin2, LOW);
  digitalWrite(relayPin3, LOW);
  digitalWrite(relayPin4, LOW);
  mqttClient.publish("casa/Giardino/conferma2", "0");
  mqttClient.publish("casa/Giardino/conferma3", "0");
  mqttClient.publish("casa/Giardino/conferma4", "0");
  
  
  }

 
    
   }
   
  if (topicStr == "casa/Giardino/presenza") 
    {
    if (messageTemp == "ip") {
      mqttClient.publish("casa/Giardino/ip", ip.c_str());
      mqttClient.publish("casa/Giardino/nb/relay1", (relaystate1 == LOW) ? "OPEN" : "CLOSED"); 
    }
  
  
    
   }  

  
   }
  
Hi all!

I have an issue with pubsubclient library.
I use HardwareSerial in ESP32 with TinyGSM in order to send MQTT messages via GSM. When SIM800C is connected to GPRS, PubSubClient tries to connect to MQTT... and no connection, although Internet access is present and MQTT broker is up.

**Here are my codes:**

1. Interface declaration

```
HardwareSerial MySerial2(2);
//TinyGsm modem(MySerial2);

#define DUMP_AT_COMMANDS

#ifdef DUMP_AT_COMMANDS
  #include <StreamDebugger.h>
  StreamDebugger debugger(MySerial2, Serial);
  TinyGsm modem(debugger);
#else
  TinyGsm modem(MySerial2);
  
#endif

TinyGsmClient client(modem);
TinyGsmClientSecure secureClient(modem);
PubSubClient mqtt(client);
```

2. Modem interface initialization:
`MySerial2.begin(2400, SERIAL_8N1, 16, 17);`

3. mqttConnect:
```
boolean mqttConnect() {
  Serial.print("Connecting to ");
  Serial.print(mqtt_host);
  
  // Or, if you want to authenticate MQTT:
  //mqtt.setStream(debugger);
  mqtt.setStream(debugger)
  //mqtt.setClient(client);
  boolean status = mqtt.connect(tr_name, mqtt_token, NULL);
  //boolean status = mqtt.connect("TempLogger", "uerdekta", "FxTNPTyHTJhM");
  if (status == false) {
    Serial.println(" fail");
    Serial.println(mqtt.state());
    return false;
  }
  Serial.println(" OK");
//  mqtt.publish(topicInit, "GsmClientTest started");
  mqtt.subscribe("v1/devices/me/attributes/response/+");
  mqtt.subscribe("v1/devices/me/rpc/request/+");
  mqtt.subscribe("v1/devices/me/rpc/response/+");
  mqtt.subscribe("v1/devices/me/attributes");
  
  return mqtt.connected();
}
```

4. sendReceiveTelemetry:
```
void sendReceiveTelemetry(String temp) {
  StaticJsonBuffer<MQTT_SEND_SIZE> jsonBuffer;
  JsonObject& mqttSend = jsonBuffer.createObject();
  uint8_t atts = 0;
  inet = true;
  
  mqtt.setServer(mqtt_host, mqtt_port);
  mqtt.setCallback(mqttCallback);
  while (!mqttConnect() && atts < 10) atts++;
  
  int csq = modem.getSignalQuality();
  int bat = checkBatLite();
  String send;
  char sendArray[MQTT_SEND_SIZE];
  char pubsub[64];
  
  String pub;
  checkBattery(temp.toFloat());
  writeAlarm(temp.toFloat());
  struct coords currentLocation = getLocation();
  int loc_err = currentLocation.loc_err;
  Serial.println("MQTT is running...");
  // Ð”Ð°ÐµÐ¼ MQTT-ÐºÐ»Ð¸ÐµÐ½Ñ‚Ñƒ Ð¿Ñ€Ð¾Ñ€Ð°Ð±Ð¾Ñ‚Ð°Ñ‚ÑŒ 3 ÑÐµÐºÑƒÐ½Ð´Ñ‹
  mqttSend["ts"] = timestamp;
  mqttSend["temp"] = temp.toFloat();
  mqttSend["l_temp"] = lower_temp;
  mqttSend["h_temp"] = upper_temp;
  mqttSend["loc_err"] = currentLocation.loc_err;
  mqttSend["csq"] = csq;
  mqttSend["bat"] = bat;
  mqttSend["name"] = trackerName;
  mqttSend["tt_int"] = (uint32_t)TIME_TO_SLEEP;
  //mqttSend["loc_str"] = currentLocation.loc_string;
#ifdef COORDS_FILTER
  if (loc_err == 0 && (currentLocation.longitude != 0 || currentLocation.latitude != 0)) {
    mqttSend["lon"] = currentLocation.longitude;
    mqttSend["lat"] = currentLocation.latitude;
  }
#else
  mqttSend["lon"] = currentLocation.longitude;
  mqttSend["lat"] = currentLocation.latitude;
#endif
  mqttSend["imei"] = imei;
  mqttSend["mv"] = getVoltage();
  mqttSend.printTo(send);
  
  
  send.toCharArray(sendArray, MQTT_SEND_SIZE);
  Serial.println(sendArray);
  pub = "v1/devices/me/telemetry";
  pub.toCharArray(pubsub, 64);
  mqtt.publish(pubsub, sendArray);
  send = "{\"csq\":"+String(csq)+",\"bat\":"+String(bat)+",\"sharedKeys\":\"l_temp,h_temp,tt_int\"}";
  send.toCharArray(sendArray, MQTT_SEND_SIZE);
  pub = "v1/devices/me/attributes/request/1";
  pub.toCharArray(pubsub, 64);
  mqtt.publish(pubsub, sendArray);
  unsigned long int new_millis = millis(); // Ð¡Ð¾Ð·Ð´Ð°Ð½Ð¸Ðµ Ð½Ð¾Ð²Ð¾Ð¹ Ñ‚Ð¾Ñ‡ÐºÐ¸ Ð¾Ñ‚ÑÑ‡ÐµÑ‚Ð° Ð²Ñ€ÐµÐ¼ÐµÐ½Ð¸
  while(millis() - new_millis < 6000) {     
    mqtt.loop();
  }
  //mqtt.disconnect();


  //modem.gprsDisconnect(); 
  //inet = false;
  Serial.print("Ð’Ñ€ÐµÐ¼Ñ Ñ‚ÐµÐ»ÐµÐ¼ÐµÑ‚Ñ€Ð¸Ð¸: ");
  Serial.print(millis());
  Serial.println(" ms");  
}
```

Modem isn't in sleep mode and is able to respond commands.
**Here is debug log:**
```
Connecting to demo.thingsboard.ioAT+CIPCLOSE=1,1

ERROR
AT+CIPSSL=0

OK
AT+CIPSTART=1,"TCP","demo.thingsboard.io",1883

OK

1, CONNECT OK
AT+CIPSEND=1,42

>â(â€â„MQTTâ„ï¿½â€â…â€â†SMR_28â€â”i4T2XXXXXbanzZcSreKN
DATA ACCEPT:1,42

+CIPRXGET: 1,1
AT+CIPRXGET=4,1

+CIPRXGET: 4,1,4

OK
AT+CIPCLOSE=1,1

1, CLOSE OK
 fail
-4
```
I've been investigating timeout disconnect issues between pubsubclient and mosquitto and I noticed that MQTT_KEEPALIVE appears to be used for two things.  The first is this is the value that is sent on connection to the broker as the connection timeout.  The second is to determine when to send keepalive pings.

What I'm wondering is that if for example the MQTT_KEEPALIVE value is the default 15 seconds and on connection to the broker you provide that value, and then on the pubsubclient device you wait exactly MQTT_KEEPALIVE seconds before you send the ping isn't that cutting things a bit close - if there is any glitch at all the broker by all rights would disconnect you.  Shouldn't the value in the ping loop be a bit smaller than the value sent on connection to allow for a little wiggle room?

I'd maybe consider sending 20 seconds to the broker on connection if the ping loop on the client is set to send every 15 seconds.
I'm receiving JPG picture from a device connected to ESP32 with serial connection (baud rate 921600). Receiving part is done using the following code:

```
if (String(topic) == "esp32/face_enroll") {

/*here is some code related to getting message from the device and parsing it, I omit it because this part works as expected*/

byte incomingByte = 0;
byte nextByte = 0;
bool jpeg = 0;
byte jpeg_image[50000];
int i=0;

Serial.println("init");
if (mf1_jpeg.available() > 0)
{
  Serial.println("data");
  incomingByte = mf1_jpeg.read();
  if (incomingByte == 0xFF)
    { nextByte = mf1_jpeg.read(); 
      if (nextByte == 0xD8) {   jpeg = 1; i = 2; jpeg_image[0]=incomingByte; jpeg_image[1]=nextByte; Serial.println("jpg begin");}
    }
}

while (jpeg)
{
  incomingByte = mf1_jpeg.read();
  jpeg_image[i]=incomingByte;
  i++;
  
  if (incomingByte == 0xFF)
    { nextByte = mf1_jpeg.read(); 
      if (nextByte == 0xD9) { 
        jpeg = 0; 
        jpeg_image[i]=nextByte;
              Serial.println("jpg end");

              
      //client.publish("esp32/jpg", jpeg_image, 50000, false);
                
                Serial.println("finished");   
 }
    }
}
      break;}
     }
    if (!detected) { client.publish("esp32/result", "no_face_detected"); Serial.println("no_face_detected");}
    detected = 0;
delay(5);
    }
```

If the line about publishing is commented out, I can receive messages from the device, including jpg, which appears to be not corrupted (begins with ff d8 and ends with ff d9). If I try sending the jpg with client.publish, then esp 32 immediately after receiving message on face_enroll topic reboots with the following backtrace:

```
Connecting to orangepi
...
WiFi connected
IP address: 
192.168.43.159
Attempting MQTT connection...connected
ets Jun  8 2016 00:22:57

rst:0x8 (TG1WDT_SYS_RESET),boot:0x1b (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:1
load:0x3fff0018,len:4
load:0x3fff001c,len:1044
load:0x40078000,len:8896
load:0x40080400,len:5816
entry 0x400806ac
Guru Meditation Error: Core  1 panic'ed (Interrupt wdt timeout on CPU1)
Core 1 register dump:
PC      : 0x40081372  PS      : 0x00050034  A0      : 0x40084774  A1      : 0x3ffbe7a0  
A2      : 0x3ffbec00  A3      : 0x00000000  A4      : 0x00000001  A5      : 0x4008b2e0  
A6      : 0x00000004  A7      : 0x3ffb8614  A8      : 0x3ff40000  A9      : 0x00000008  
A10     : 0x00000000  A11     : 0x00000200  A12     : 0x00000000  A13     : 0x3ffb1db0  
A14     : 0x3ffb8000  A15     : 0xbaad5678  SAR     : 0x00000013  EXCCAUSE: 0x00000006  
EXCVADDR: 0x00000000  LBEG    : 0x00000000  LEND    : 0x00000000  LCOUNT  : 0x00000000  
Core 1 was running in ISR context:
EPC1    : 0x4000bff0  EPC2    : 0x00000000  EPC3    : 0x00000000  EPC4    : 0x40081372

Backtrace: 0x40081372:0x3ffbe7a0 0x40084771:0x3ffbe7d0 0x4000bfed:0x3ffb1e00 0x40089ce9:0x3ffb1e10 0x400d8547:0x3ffb1e30 0x400d859d:0x3ffb1e70 0x400d47d9:0x3ffb1ea0 0x400d48c7:0x3ffb1ec0 0x400d4c9e:0x3ffb1ee0 0x400d3986:0x3ffb1f20 0x400d1029:0x3ffb1f60 0x400d4e6f:0x3ffb1fb0 0x40088b7d:0x3ffb1fd0

Core 0 register dump:
PC      : 0x4013e01a  PS      : 0x00060134  A0      : 0x800d7d12  A1      : 0x3ffbbff0  
A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000000  A5      : 0x00000001  
A6      : 0x00060320  A7      : 0x00000000  A8      : 0x800d6d5a  A9      : 0x3ffbbfc0  
A10     : 0x00000000  A11     : 0x40084f14  A12     : 0x00060320  A13     : 0x3ffbb650  
A14     : 0x3ff000e0  A15     : 0x00000001  SAR     : 0x00000000  EXCCAUSE: 0x00000006  
EXCVADDR: 0x00000000  LBEG    : 0x00000000  LEND    : 0x00000000  LCOUNT  : 0x00000000  

Backtrace: 0x4013e01a:0x3ffbbff0 0x400d7d0f:0x3ffbc010 0x4008a361:0x3ffbc030 0x40088b7d:0x3ffbc050

Rebooting...
ets Jun  8 2016 00:22:57

rst:0xc (SW_CPU_RESET),boot:0x1b (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:1
load:0x3fff0018,len:4
load:0x3fff001c,len:1044
load:0x40078000,len:8896
load:0x40080400,len:5816
entry 0x400806ac
Guru Meditation Error: Core  1 panic'ed (Interrupt wdt timeout on CPU1)
Core 1 register dump:
PC      : 0x40081346  PS      : 0x00050034  A0      : 0x40084774  A1      : 0x3ffbe7a0  
A2      : 0x3ffbec28  A3      : 0x00000002  A4      : 0x00000001  A5      : 0x4008b2e0  
A6      : 0x00000004  A7      : 0x3ffb8614  A8      : 0x00000000  A9      : 0x3ff50000  
A10     : 0x00000200  A11     : 0x00000200  A12     : 0x00000000  A13     : 0x3ffb1db0  
A14     : 0x3ffb8000  A15     : 0xbaad5678  SAR     : 0x00000013  EXCCAUSE: 0x00000006  
EXCVADDR: 0x00000000  LBEG    : 0x00000000  LEND    : 0x00000000  LCOUNT  : 0x00000000  
Core 1 was running in ISR context:
EPC1    : 0x4000bff0  EPC2    : 0x00000000  EPC3    : 0x00000000  EPC4    : 0x40081346

Backtrace: 0x40081346:0x3ffbe7a0 0x40084771:0x3ffbe7d0 0x4000bfed:0x3ffb1e00 0x40089ce9:0x3ffb1e10 0x400d8547:0x3ffb1e30 0x400d859d:0x3ffb1e70 0x400d47d9:0x3ffb1ea0 0x400d48c7:0x3ffb1ec0 0x400d4c9e:0x3ffb1ee0 0x400d3986:0x3ffb1f20 0x400d1029:0x3ffb1f60 0x400d4e6f:0x3ffb1fb0 0x40088b7d:0x3ffb1fd0

Core 0 register dump:
PC      : 0x4013e01a  PS      : 0x00060134  A0      : 0x800d7d12  A1      : 0x3ffbbff0  
A2      : 0x00000000  A3      : 0x00000001  A4      : 0x00000000  A5      : 0x00000001  
A6      : 0x00060120  A7      : 0x00000000  A8      : 0x800d6d5a  A9      : 0x3ffbbfc0  
A10     : 0x00000000  A11     : 0x40084f14  A12     : 0x00060120  A13     : 0x3ffbb6c0  
A14     : 0x00000000  A15     : 0x3ffbbce0  SAR     : 0x00000000  EXCCAUSE: 0x00000006  
EXCVADDR: 0x00000000  LBEG    : 0x00000000  LEND    : 0x00000000  LCOUNT  : 0x00000000  

Backtrace: 0x4013e01a:0x3ffbbff0 0x400d7d0f:0x3ffbc010 0x4008a361:0x3ffbc030 0x40088b7d:0x3ffbc050

Rebooting...
ets Jun  8 2016 00:22:57

rst:0xc (SW_CPU_RESET),boot:0x1b (SPI_FAST_FLASH_BOOT)
configsip: 0, SPIWP:0xee
clk_drv:0x00,q_drv:0x00,d_drv:0x00,cs0_drv:0x00,hd_drv:0x00,wp_drv:0x00
mode:DIO, clock div:1
load:0x3fff0018,len:4
load:0x3fff001c,len:1044
load:0x40078000,len:8896
load:0x40080400,len:5816
entry 0x400806ac

Connecting to orangepi
...
```

The MQTT_MAX_PACKET_SIZE is set to 50000(changing it to 55000 doesn't make a difference). I have also tried publishing with client.beginPublish and write(payload, length) (or write(payload to send single bytes), all with the same result...

What I found working, sort of, is publishing bytes of jpg image right after receiving them from the device, or buffering them to buf[5000] array and then publishing them. Unfortunately the jpg image is corrupted when publishing this way (a lot of ff bytes in the body of jpg, doesn't end with ff d9, impossible to open).

Is there any work around this issue? It doesn't seem to be memory related...
Hello together,
I am working on a small programm for an ESP8266 that allows me to forwards MQTT messages from my local broker to Thingspeak channels.
I am using the Thingspeak library (Thingspeak.h).
As soon as the following code to update the Thingspeak channel is executed the connection to the MQTT broker is lost (reconnection appears).

`  if(ActualPwrState)
  {
    ActualPwrState = false;
    // Write to ThingSpeak. There are up to 8 fields in a channel, allowing you to store up to 8 different
    // pieces of information in a channel.  Here, we write to field 1.
    int x = ThingSpeak.writeField(myChannelNumber, 1, ActualPwrValue, myWriteAPIKey);
    if(x == 200){
      Serial.println("Channel update successful.");
    }
    else{
      Serial.println("Problem updating channel. HTTP error code " + String(x));
    }    
  }`

Any ideas what the issue is?