Hi,

Trying gcsf login session and open the browser but got this message:

Sign in with Google temporarily disabled for this app
This app has not been verified yet by Google in order to use Google Sign In.

Is there any fix for that?
[`kopia`](https://github.com/kopia/kopia) (backup tool) works fine with `davfs2`, but doesn't work with gcsf. It says that it can't find blob immediately after saving it.

Cross-link: https://github.com/kopia/kopia/issues/77
GCSF sometime unmounts itself. Looking at the logs it shows:

`Jul 10 10:24:14 bwei-arch gcsf[29756]: thread '<unnamed>' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option>
Jul 10 10:24:14 bwei-arch gcsf[29756]: note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
Jul 10 10:24:14 bwei-arch gcsf[29756]:  WARN  fuse::reply              > Reply not sent for operation 114220, replying with I/O erro`

(I am not sure if the above is relevant to the issue.)

Re-running `gcsf mount` resolves the issue.
In my case I had opened login link on my desktop, but OAuth redirect is failed, because client was running on different machine. Simple `wget -q <redirect-url>` in other terminal window on server machine finished login successfully. 

Please also examine `insync-headleass`, which allows login with auth code, which is generated by Google OAuth flow, from any machine.
``` ERROR gcsf > Could not mount to /root/mediaserver/drive: Transport endpoint is not connected (os error 107)``` 
This seems to occur randomly, not sure what causes it, but I logged in to my VPS to see this. Only way to fix it seems to be a restart of the whole system
After I have modified the .conf file adding this configuration:

1. allow_root => commented with #
2. mount_check = false

After a while, gcfs got finished. Macbook air version 10.11.6 - El capitan:

MacBook-Air-de-Miguel-Hernandez:Volumes Miguel$ gcsf mount /Volumes/Google/ -s  "account"
 INFO  gcsf > Creating and populating file system...
 INFO  gcsf::gcsf::drive_facade > Received page 1 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 2 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 3 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 4 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 5 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 6 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 7 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 8 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 9 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 10 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 11 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 12 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 13 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 14 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 15 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 16 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 17 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 18 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 19 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 20 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 21 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 22 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 23 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 24 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 25 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 26 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 27 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 28 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 29 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 30 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 31 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 32 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 33 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 34 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 35 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 36 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 37 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 38 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 39 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 40 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 41 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 42 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 43 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 44 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 45 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 46 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 47 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 48 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 49 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 50 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 51 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 52 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 53 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 54 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 55 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 56 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 57 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 58 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 59 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 60 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 61 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 62 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 63 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 64 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 65 containing 116 files
 INFO  gcsf::gcsf::drive_facade > Received page 1 containing 460 files
 INFO  gcsf::gcsf::drive_facade > Received page 2 containing 16 files
 INFO  gcsf                     > File sytem created.
 INFO  gcsf                     > Mounting to /Volumes/Google/
 INFO  gcsf                     > Mounted to /Volumes/Google/
 INFO  gcsf::gcsf::file_manager > Checking for changes and possibly applying them.
 INFO  gcsf::gcsf::file_manager > Checking for changes and possibly applying them.
 ERROR fuse::channel            > Failed to send FUSE reply: Socket is not connected (os error 57)


Hi @harababurel!

While there is an option to rename identical files, I would also like to have an option to overwrite identical files instead of just renaming. This new option would supersede the renaming option.


First, I was able to mount a google drive based on the directions. Cool. The systemd unit file will also be helpful. Thank you.

Next, it would be useful to create a "back pointer" to a url on the google drive and some way to recover it at the command line. I scanned the code a little bit. It uses fuse but not fuse_mt. I was thinking you could introduce an extended file attribute and attach it to the file that way, see https://docs.rs/fuse_mt/0.4.4/x86_64-unknown-linux-gnu/fuse_mt/enum.Xattr.html. Then whenever you write a file, you capture its associated url and stash it in `user.drive_url`. If you have that, then you can open the file in a browser with something like `xdg_open $(getfattr -n user.drive_url --only-value)`. Alternatively you introduce a "supporting file" containing the url. For a file `file.doc`, it's url would be `file.doc.gdrive_url`. It's a little cruftier.

I'm new to rust, so this might not be the right way to do it. But this would be a useful thing to have.
I dont know which operation exactly it is, but I keep getting this error(gcsf needs to be restarted after this):

```
 INFO  gcsf::gcsf::file_manager > Checking for changes and possibly applying them.
thread '<unnamed>' panicked at 'called `Option::unwrap()` on a `None` value', src/libcore/option.rs:355:21
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
stack backtrace:
   0: std::sys::unix::backtrace::tracing::imp::unwind_backtrace
             at src/libstd/sys/unix/backtrace/tracing/gcc_s.rs:49
   1: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:71
   2: std::panicking::default_hook::{{closure}}
             at src/libstd/sys_common/backtrace.rs:59
             at src/libstd/panicking.rs:211
   3: std::panicking::default_hook
             at src/libstd/panicking.rs:227
   4: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:491
   5: std::panicking::continue_panic_fmt
             at src/libstd/panicking.rs:398
   6: rust_begin_unwind
             at src/libstd/panicking.rs:325
   7: core::panicking::panic_fmt
             at src/libcore/panicking.rs:95
   8: core::panicking::panic
             at src/libcore/panicking.rs:59
   9: <core::option::Option<T>>::unwrap
             at /rustc/9fda7c2237db910e41d6a712e9a2139b352e558b/src/libcore/macros.rs:20
  10: gcsf::gcsf::file_manager::FileManager::get_node_id
             at src/gcsf/file_manager.rs:291
  11: gcsf::gcsf::file_manager::FileManager::add_file_locally
             at src/gcsf/file_manager.rs:372
  12: gcsf::gcsf::file_manager::FileManager::sync
             at src/gcsf/file_manager.rs:129
  13: <gcsf::gcsf::filesystem::GCSF as fuse::Filesystem>::readdir
             at src/gcsf/filesystem.rs:179
  14: fuse::request::Request::dispatch
             at /root/.cargo/registry/src/github.com-1ecc6299db9ec823/fuse-0.3.1/src/request.rs:311
  15: fuse::request::dispatch
             at /root/.cargo/registry/src/github.com-1ecc6299db9ec823/fuse-0.3.1/src/request.rs:34
  16: <fuse::session::Session<FS>>::run
             at /root/.cargo/registry/src/github.com-1ecc6299db9ec823/fuse-0.3.1/src/session.rs:79
  17: fuse::session::BackgroundSession::new::{{closure}}
             at /root/.cargo/registry/src/github.com-1ecc6299db9ec823/fuse-0.3.1/src/session.rs:130
  18: thread_scoped::scoped::{{closure}}
             at /root/.cargo/registry/src/github.com-1ecc6299db9ec823/thread-scoped-1.0.2/src/lib.rs:76
 WARN  fuse::reply              > Reply not sent for operation 2235356, replying with I/O error
```

I will try to get the verbose backtrace soon :)

This probably isn't a problem in gcsf itself but, anyway, I would like to understand what is happening.

When I open one of the exported google documents locally, using libreoffice, I always get the "corrupted file" dialog offering me to repair the file.

In general, if I chose to repair the file it's opened without problems in read-only mode afterwards, as expected.