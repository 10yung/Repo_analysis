I have tried to read the API documentation and searched online but I can't figure out how to get a subgraph that I can export to a .dot file. 

I have created a large graph with multiple root nodes. I want to export one .dot file for each root node and its subgraph.

Any tips or pointers would be appreciated. Please let me know if I can provide more information.
This is a question / probably a feature request.
Is there an easy way to get the difference between two `StableGraph`'s?
(I searched through this repository and docs.rs and couldn't find an answer.)
I'll probably extend this issue with more information later, when I have more information how to fix/implement this.
It should be possible to apply the difference set (after serialization + deserialization) on another machine, which should have the ability to gracefully handle slightly deviations between the "original" graph data of both machines (e.g. the downstream code would fallback to full transfer in that case).
This should include the ability to merge multiple "difference sets" if they don't overlap (e.g. the multiple "difference sets" don't change the same weights, updating different edges with the same incoming or outgoing node should be possible).

It might be possible to implement this using something like [`serde-diff`](https://crates.io/crates/serde-diff).

I think this mostly makes sense with `StableGraph` and other graphs with stable indices across node removal (+ `GraphMap`, which doesn't use indices).

(This issue thus at least requires the features `serde-1` and `stable_graph`.)

### Desired workflow

* Construct and populate a `StableGraph`
* `std::clone::Clone::clone()` it
* Modify the new graph, update it with new information from the environment
* Find the difference between the two graphs
* Apply the difference after serialization + deserialization on another machine

#### Alternative

* Construct and populate a `StableGraph`
* Create something similiar to a "database transaction"
* Modify the graph, update it with new information from the environment
* Get the difference set from the transaction
* Apply the difference after serialization + deserialization on another machine

This variant would have a lower performance overhead.

### Motivation

The goal is to avoid the need to transfer the entire graph every time it is changed, but instead only transferring a `patch`/difference set between the old and the new graph and applying it at the target machine.

I plan to later port a peer-to-peer network protocol to utilize `petgraph` to calculate routes between peers, in which a subset of peers change relatively often, while other peers including edges connecting them change not at all. The goal is to keep all peer's graph's synchronized without the overhead of a full graph transfer + manual walking and merging.

### Alternative

It is possible to avoid this approach and instead introduce some kind of "transaction"/"change cache"/"graph overlay" which implements the same methods as the underlying graph (to which it holds a (possible mutable or interior-mutable) reference), but stores updates to the graph in a separate data structure (the "overlay"), with the ability to extract the "overlay"/detach it from the original graph, and can be applied to another graph, if that graph does contain the nodes which were modified in the overlay (deletions shouldn't require existence, e.g. if a graph doesn't contain the nodes, which were marked as "removed" in the overlay (via some kind of "tombstone"), this isn't an error). This would probably be possible without modification of `petgraph` at all, but I'm not sure if it would scale well.
### Summary

There's now a couple of versions of matrix backed graphs (CSR & MatrixGraph).  It might be useful to implement these as a single struct that stores it's information in a generic parameter `Storage: Matrix` where `Matrix` is a minimal trait for a matrix


### Motivation

This would:

- Reduce duplication between the implementations.  Sparse & Dense matrices are just typedefs of the same generic type

- Allow (optionally) using external linear algebra libraries which would improve interop and make it simpler to implement certain algorithms

### Details

There would need to be a new `Matrix` trait that describes some very basic operations on matrices (creation, accessing, mutating).
The current lower triangular matrix (from MatrixGraph) & CSR implementations could remain so no dependencies are introduced.
Adaptors could be provided for some of the more popular libraries - nalgebra, sprs

I'd be happy to give this a go if I can find time
Creates an Undirected adaptor that erases the direction from a graph.

I believe I've implemented the required traits, though I'm not sure whether I should have implemented `IntoNeighborsDirected` and `IntoEdgesDirected`.  Let me know if I've missed any
I was asking myself upon reading the documentation, whether `remove_node()` also deletes connected edges. It seems to me that this is the case, so I updated the Documentation similarly to the documentation of the same function in MatrixGraph
This lets the vectors allocated for `tarjan_scc` be reused as well as lets the caller opt into a closure + iterator based output, avoiding the need to allocate and return `Vec`s.
This allows you to easily style dotfile output like so:

```
Dot::with_attr_getters(
       self.state_network,
        &[],
        &|_, _| "arrowhead = vee".to_string(),
        &|_, nr| format!("shape = box color = {}", if nr.id() == self.state { "red" } else { "black" }).to_string(),
);
```

![index](https://user-images.githubusercontent.com/1391608/71546203-59faf280-298c-11ea-9076-8d486b537745.png)

.
### Summary

The `retain_edges` function on Graph is rather slow in my test case (see below).
Upon looking quickly at the code, it seems to have a complexity of *O(e*e')*, where *e* is the total number of edges in the graph, and *e'* is the number of edges per node.

### Motivation

I work with a graph with a few thousands of nodes and hundreds of thousands of edges, and I need to remove some edges (about a quarter of the edges).
I can efficiently test, given an edge index, whether it should be removed or not
Insert your test case here, ideally in the form of Rust code that creates a
graph.
Using the `retain_edges` function is slow (and, from what I can see in the code, roughly equivalent to iterated use of the `remove_edge` function).
I did not find any way to do the bulk edge removal efficiently. Ideally, that should be possible to do in *O(e)* time.
For the kind of graph I work with, it is more efficient to clone the graph, then call `clear_edges`, and `extend_with_edge`.

### Details

* Ideally, the API of `retain_edges` would not change, but its implementation would be changed so that it has linear complexity. However I don't know if that is possible. (Namely: providing a consistent `Frozen` graph to the `visit` function might not be possible.)
* If the previous option is not possible, making a new API to retain edges that leaves the graph in a temporarily inconsistent state could be created (the `visit`function would then maybe only have access to the edge and to the nodes it connects).
* In any case, this performance behavior should better documented, as differs from common conventions, as far as I can tell (at least compared to `std`).
* I would be happy to implement any of this. I would welcome any idea on what should/can be done, and pointer explaining the details of the data-structure (Is <https://doc.rust-lang.org/1.0.0/rustc/middle/graph/index.html> the same structure as `Graph` ?)
See #107 .

This passes quickcheck tests against the current implementation of `simple_fast`, but might need some renaming/refactoring. The implementation uses the two recommendations of ["Finding Dominators in Practice"](http://jgaa.info/accepted/2006/GeorgiadisTarjanWerneck2006.10.1.pdf): replacing a `Vec<Vec<usize>>` for the buckets of each semi-dominator with a single `Vec<usize>` of size |V|, and skipping calls to `eval` for nodes semi-dominated by the root.

Somewhat foolishly, I had not actually checked the open pull requests and I now realize there is already an open pull request (#182). I'm happy to merge my work there, bring the documentation more in line, or anything that's appropriate. Just checking in to see if anyone has time to review, because I do think it would be nice to have the option for larger graphs!

r? @bluss