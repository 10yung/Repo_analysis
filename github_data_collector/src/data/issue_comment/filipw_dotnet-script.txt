```
dotnet tool uninstall dotnet-script -g
Tool 'dotnet-script' has multiple versions installed and cannot be uninstalled.
```
Version installed:
```
dotnet tool list -g
...
dotnet-script                  0.50.1         dotnet-script
...
```
Hello,

Thanks for your cool project which is very useful !
It seems that, we cannot have a set of scripts that could be instantiated multiple times & run concurrently from the same location.
![dotnet-script_issueMultipleScriptSameLocation](https://user-images.githubusercontent.com/5173267/71756222-ed518d80-2e8e-11ea-9273-7762ee1f8886.JPG)

It seem that [dotnet-script/src/Dotnet.Script.Core/Commands/ExecuteScriptCommand.cs](https://github.com/filipw/dotnet-script/blob/0848b0469146293b86a35798c8fe7711b0f1b91a/src/Dotnet.Script.Core/Commands/ExecuteScriptCommand.cs) `GetLibrary` method have an hardcoded 'default single name' for all scripts of the same location path which is : `script.dll`.

Is there a specific reason for that or are you able to use the scriptFileName or a GUID as unique identifier for example for your next release ?

Thanks a lot !
Running `dotnet script publish main.csx` returns the following:

```
> dotnet script publish main.csx      
dotnet publish failed with result '1'
```

This command had worked before, but for unknown reasons it has stopped working. The script itself is the script generated by the `dotnet script init` command, which is simply to print to the console a "Hello World!" message. 

I've checked permissions of the folder, uninstalled and reinstalled the tool, but nothing has changed.  Further attempts on trying to publish the script have been unsuccessful. It is, however, able to publish into a `.dll` oddly enough, and is able to execute properly as well as a `.dll`.

Other commands, such as `dotnet script main.csx` run successfully, and return the output message.
I'm getting an error when I run a script in multiple pieces, which would obviously be very useful in a REPL scenario. 

The error is:


> (1,88): error CS1503: Argument 2: cannot convert from 'System.Net.Http.FormUrlEncodedContent' to 'System.Net.Http.HttpContent'


![1574474673255](https://user-images.githubusercontent.com/969938/69471298-73909500-0d63-11ea-8a4d-dae890d5e869.gif)


I have researched and compared different C# scripting options, finding that dotnet-script has the most potential for my interests.  If the following capabilities are possible, I would appreciate tips (I've read every article about dotnet-script that I could find).  If they are not yet possible, let me suggest them as enhancements.

* Create a self-contained dotnet-script.exe that can be Xcopied to any system that has the .NET Core 3.0 runtime installed.

* Support a straightforward mechanism by which custom #commands can be added to the repl.

* Post simple examples of how to (1) execute a string of code at runtime, (2) execute a string with references passed to objects that will be available within the execution context, and (3) host a dotnet-script repl within an app.

Thanks for the fine work on dotnet-script!
The implicit output of expression results in the REPL is a great feature that obviates the need for `Console.WriteLine()` (and even does a better job at creating meaningful output than straight `.ToString()` stringification).

Especially for presumably typically short code passed to  `dotnet-script eval`, it would be handy to have automatic result printing as well, so that  instead of:

```sh
dotnet-script eval "Console.WriteLine(1+2)"
```

you could simply write something like:

```sh
dotnet-script eval "1+2"  -p
```
 
and have `3` automatically printed.



- If I use nuget reference, I wouldn't be able to run my script with csi:
`#r "nuget: System.DirectoryServices"`
 It will give me error
_"error CS0006: Metadata file 'nuget: System.DirectoryServices' could not be found"_

- If I don't use nuget reference, my csx file will work with csi but it won't work with dotnet-script:
`#r "System.DirectoryServices"`
 It will give me error
_error CS0006: Metadata file 'System.DirectoryServices.AccountManagement' could not be found_

Would it be possible to make my references consistent and work for both csi and dotnet-script? For example, not using nuget with #r for System packages like System.DirectoryServices
This may be a fringe use case but is there a way to save all required dependencies locally? This is similar to publishing, but would allow code changes / rebuilds to the CSX files without needing requiring nuget / internet access. Is sounds like internally this occurs in some way using the dependency cache, but the location of where the files are cached are not allowed to be specified. 

Effectively the workflow I'd be looking for is something like:
- `dotnet script restore ./deps` (or `dotnet script vendor`, `dotnet script snapshot`) - this would create the project.assets.json and store all the required dlls under ./deps
- `dotnet srcipt foo.csx -no-restore` (or `dotnet script foo.csx -vendored ./deps`) - this would run the CSX and rebuild if needed, but always used the data cached under ./deps not the current internal location. **This allows the folder to be easily copied with the scripts to more secured environments that may not have internet access for nuget.**
Is it possible to take advantage of dependency injection with dotnet-script?  I have some assemblies that utilize it heavily and it's going to be quite difficult to arrange a call to any of the code without DI in place.
This is a really neat project! New users may find it useful to see a list REPL commands when the REPL is launched:

```ps1
PS C:\Code> dotnet script
Commands:
  #help                     Show help information
  #load                     Load a script into the REPL (same as #load usage in CSX)
  #r                        ...
  ...
>
```

Invoking `#help` would show the list of REPL commands again. 