Enables lazy loading of tree components.

I still need Promises support as a leaf node, but unfortunately I can't trace the code enough.
Will be cool if it will possible to use bash's `_filedir` helper. 

See example in https://github.com/antonmedv/fx-completion/blob/master/complete.sh#L10

Just generate more advance bash script.
I have a setup/cleanup script that successfully adds and removes:

```bash
# begin app completion
. <(app --completion)
# end app completion
```

I have also setup this alias in `~/.zshrc`: `alias lando='bin/app.js'`.

`app --completion` outputs:

```bash
### app completion - begin. generated by omelette.js ###
if type compdef &>/dev/null; then
  _app_completion() {
    compadd -- `app --compzsh --compgen "${CURRENT}" "${words[CURRENT-1]}" "${BUFFER}"`
  }
  compdef _app_completion app
elif type complete &>/dev/null; then
  _app_completion() {
    local cur prev nb_colon
    _get_comp_words_by_ref -n : cur prev
    nb_colon=$(grep -o ":" <<< "$COMP_LINE" | wc -l)

    COMPREPLY=( $(compgen -W '$(app --compbash --compgen "$((COMP_CWORD - (nb_colon * 2)))" "$prev" "${COMP_LINE}")' -- "$cur") )

    __ltrim_colon_completions "$cur"
  }
  complete -F _app_completion app
fi
### app completion - end ###
```

My `app.js` contains:

```
    // Write your CLI template.
    var completion = omelette('app <test> <test2>')

// This is your logic
    completion.on('test', ({reply}) => { reply(['option1', 'option2']) });
    completion.on('test2', ({reply}) => { reply(['option3', 'option4']) });

    completion.init();
```

Now, I expect when that when I type `app<tab>` that I will see the options, but I do not. What are my next steps to troubleshooting? What command outputs the options that I hope to see? Is it possible that my JS is outputting garbage prematurely that breaks Zsh's autocompletion?
While educating myself on auto-complete, I was poking at `npm` and noticed that their autocomplete scripts allow for an infinite number of flags to be referenced by the completion mechanism, without regard to what position they're in. While the positioning that omelette provides is useful, removing that constraint would also be immensely useful. For reference, here is the script that results from running `$ npm completion`

```bash
###-begin-npm-completion-###
#
# npm command completion script
#
# Installation: npm completion >> ~/.bashrc  (or ~/.zshrc)
# Or, maybe: npm completion > /usr/local/etc/bash_completion.d/npm
#

if type complete &>/dev/null; then
  _npm_completion () {
    local words cword
    if type _get_comp_words_by_ref &>/dev/null; then
      _get_comp_words_by_ref -n = -n @ -n : -w words -i cword
    else
      cword="$COMP_CWORD"
      words=("${COMP_WORDS[@]}")
    fi

    local si="$IFS"
    IFS=$'\n' COMPREPLY=($(COMP_CWORD="$cword" \
                           COMP_LINE="$COMP_LINE" \
                           COMP_POINT="$COMP_POINT" \
                           npm completion -- "${words[@]}" \
                           2>/dev/null)) || return $?
    IFS="$si"
    if type __ltrim_colon_completions &>/dev/null; then
      __ltrim_colon_completions "${words[cword]}"
    fi
  }
  complete -o default -F _npm_completion npm
elif type compdef &>/dev/null; then
  _npm_completion() {
    local si=$IFS
    compadd -- $(COMP_CWORD=$((CURRENT-1)) \
                 COMP_LINE=$BUFFER \
                 COMP_POINT=0 \
                 npm completion -- "${words[@]}" \
                 2>/dev/null)
    IFS=$si
  }
  compdef _npm_completion npm
elif type compctl &>/dev/null; then
  _npm_completion () {
    local cword line point words si
    read -Ac words
    read -cn cword
    let cword-=1
    read -l line
    read -ln point
    si="$IFS"
    IFS=$'\n' reply=($(COMP_CWORD="$cword" \
                       COMP_LINE="$line" \
                       COMP_POINT="$point" \
                       npm completion -- "${words[@]}" \
                       2>/dev/null)) || return $?
    IFS="$si"
  }
  compctl -K _npm_completion npm
fi
###-end-npm-completion-###
```

Would it be possible to allow the same kind of "as many flags as you want in any position" functionality?
Hello,

Great tool! I have had a great pleasure to use it to create my own autocomplete stuff :-)

I have used the `.setupShellInitFile()` function to automatically setup the shell autocompletion. However when I do so and run `source ~/.zshrc`, it hangs forever. I have to `kill -9` the hanging process.

The added line in the `.zshrc` files is the following:

```
# .zshrc
. <(app --completion)
```

When I turn it into the following one, it does not hang and autocompletion works:

```
eval $(app --completion)
```

I am unsure about this issue. 
Do you have an idea?
The latest release on GitHub is v0.4.6 but npm lists v0.4.5 as the latest version. Could you please publish v0.4.6 to npm?
Hello! I've created tool for automating directory/file duplication and renaming, etc. The program is based on Yeoman (http://yeoman.io/).

Instead of binding Omellette's autocomplete functionality to a certain command (program), can it be bound to a certain function within a program?

For example, I run my automation tool by running `yo tcg` in Terminal ... then the user is immediately confronted with a series of prompts. It would be rad if Omelette could be used within these prompts (for the autocompletion of directory names, etc).

Is something like possible?
If I add autocompletion for my global cli, it works great (`mycli <tab>`), but if the same script is called through [npx](https://medium.com/@maybekatz/introducing-npx-an-npm-package-runner-55f7d4bd282b) (which calls local binaries, `npx mycli <tab>`, available in Node 8) autocompletion won't work for the same script.

Wondering is there a way to solve it easily ?
Is it possible to use omelette to create a [completer function for the `readline` module](https://nodejs.org/api/readline.html#readline_use_of_the_completer_function)?
Hi,
I tried to switch to 0.4.0 and the change of fetching method for `word` (https://github.com/f/omelette/commit/b74b23209f5b8254f0d28b120fdfbf034086c30c#diff-564d24cceffda49c18bf427e92b8baa3R23) makes the parameter `before` undefined when an incomplete word is tabbed.

Ex:
```
lorem <tab><tab>      -> a1 b1       üëç 
lorem a<tab>          -> a1          üëç
lorem a1 <tab><tab>   -> a2 b2 c2    üëç
lorem a1 a<tab>       -> nothing     üëé 
```

My script that goes like this
```js
const autocomplete = {
  'a1': {
    'a2': {
      'a3': {
        'a4': {},
        'b4': {}
      },
      'b3': {}
    },
    'b2': {},
    'c2': {}
  },
  'b1': {
    'a2': {},
    'b2': {
      'a3': {
        'a4': {},
        'b4': {}
      },
      'b3': {}
    },
    'c2': {}
  }
};


const completion = omelette('lorem');

completion.on('$1', ({ reply }) => {
  reply(Object.keys(autocomplete));
});

completion.on('$2', ({ reply, before }) => {
  try {
    reply(Object.keys(autocomplete[before]));
  } catch (e) {}
});

completion.on('$3', ({ reply, before, line }) => {
  const [, lvl1] = line.split(' ');
  try {
    reply(Object.keys(autocomplete[lvl1][before]));
  } catch (e) {}
});

completion.on('$4', ({ reply, before, line }) => {
  const [, lvl1, lvl2] = line.split(' ');
  try {
    reply(Object.keys(autocomplete[lvl1][lvl2][before]));
  } catch (e) {}
});

completion.init();
```