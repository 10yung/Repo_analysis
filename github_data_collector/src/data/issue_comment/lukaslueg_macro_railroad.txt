Fixes #8 
The SVGs generated by `macro_railroad` should display correctly on most modern browsers. Although we do not use too much CSS-trickery, we want to ensure that the most used browsers always render the same output. This is especially important if `macro_railroad` should ever get on a path to be included in some form into `rustdoc`.

Come up with a scheme to automatically test that SVGs generated for specified test-cases result in the same rendering across browsers.

A rough sketch could be a test-suite that takes certain macros as input, produces [variants](https://github.com/lukaslueg/macro_railroad/blob/master/tests/verification.rs#L35) of the diagrams, sends them to `selenium` to produce a screenshot and ensure that all screenshots look the same (for some definition).

Rust's [RFC1985](https://github.com/rust-lang/rfcs/blob/master/text/1985-tiered-browser-support.md) has a list of browsers that `rustdoc` should always support. As of now this is

> last 2 Chrome versions
> last 1 Firefox version
> Firefox ESR
> last 1 Safari version
> last 1 iOS version
> last 1 Edge version
> last 1 UCAndroid version
There is currently no way in Rust itself to have per-nonterminal documentation. For example, in [nom4::method](https://htmlpreview.github.io/?https://github.com/lukaslueg/macro_railroad/blob/master/examples/nom_examples.html#method), there is just no way to express what `a`, `_self` and `args` actually *do*.

One could come up with a convention to document this in a standardized way that does not hurt `rustdoc`, `rustc` or readability but can be parsed and use as tooltips, legend or something else in these diagrams. 

Cooked up example:

```rust
/// This is the panic-macro. It causes panic.
///
/// $msg:expr Something that evaluates to a string, may be printed to stderr if possible
/// $fmt::expr A format string, as used `::std::fmt`
/// $arg::tt Arguments to the format string
macro_rules! panic {
    () => { ... };
    ($msg:expr) => { ... };
    ($msg:expr,) => { ... };
    ($fmt:expr, $($arg:tt)+) => { ... };
}
```

We could associate that comment, parse the mini-language and use the hints as further explanation. Note that each `name:fragment` can only appear once, as `macro_railroads` already implies that a `name:fragment`-tuple carries the same meaning throughout the macro definition.
A diagram's geometry is separate from it's fine-tuned design via CSS. The current default CSS is probably not the best.

[Come up with a better CSS-theme](https://github.com/lukaslueg/railroad/issues/2) for `macro_railroad`.

A [dark theme would probably be useful](https://github.com/lukaslueg/railroad/issues/3).
It would be extremely useful to bidirectionally map span information to diagram elements so that

* we can highlight sections in the source-text which correspond to a diagram-element. The user might pick (mouseover) an element; the corresponding sections in the source should be highlighted; there may be multiple such sections in different arms (think of the "vertex" terminal in `gfx_defines`, which in the optimized form appears once but has two sources).
* we can highlight sections of the diagram which correspond to a syntax-element. The user might select parts of the text. The diagram-elements which are sourced by that part of the text should be highlighted.

This requires us to acquire, collect and map `CodeSpan`-information up to the point where we generate a diagram. The code to add custom data-attributes to an SVG-element is already in place. In addition to a diagram, we also give back some form of code-map. Some JS-code can then control the blinkenlights via CSS-rules regarding the affected SVG-nodes.
[Edit: problem has been identified, see next comment]

---

The macro below results in `ParseError(None)` from `parse_str::<MacroRules>`. Not very helpful. Is there any way to get more output?

```rust
macro_rules! unborrow {
    // =========================================================================================================
    // PRIVATE RULES

    // This rule fires when we have parsed all the arguments.
    // It just falls through to output stage.
    // (FIXME could fold the output rule into this one to reduce recursion)
    (@parse () -> ($names:tt $lets:tt) $($thru:tt)*) => {
        unborrow!(@out $names $lets $($thru)*)
    };

    // Parse an argument and continue parsing
    // This is the key rule, assigning a name for the argument and generating the let statement.
    (@parse ($arg:expr, $($rest:tt)*) -> ([$($names:ident),*] [$($lets:stmt);*]) $($thru:tt)*) => {
        unborrow!(@parse ($($rest)*) -> ([$($names,)* arg] [$($lets;)* let arg = $arg]) $($thru)*)
        //                                            ^                    ^
        // Right here an ident is created out of thin air using hygiene.
        // Every time the macro recurses, we get a new syntax context, so "arg" is actually a new identifier!
    };

    // Output stage for free functions.
    // Assembles the let statements and variable names into a block which computes the arguments,
    // calls the method, and returns its result.
    (@out [$($names:ident),*] [$($lets:stmt);*] ($($meth:ident)::+) $arg1:expr) => {{
        $($lets;)*
        $($meth)::+($arg1, $($names),*)
    }};
    
    // Output stage for object methods.
    (@out [$($names:ident),*] [$($lets:stmt);*] $($obj:ident).+) => {{
        $($lets;)*
        $($obj).+($($names),*)
    }};

    // =========================================================================================================
    // PUBLIC RULES

    // Macro entry point for object methods.
    ($($obj:ident).+ ($($args:expr),*)) => {
        unborrow!(@parse ($($args,)*) -> ([] []) $($obj).+)
        //                |               |  |   ^ info about the method call, saved for later
        //                |               |  ^ generated let statements
        //                |               ^ generated argument names
        //                ^ arguments to be parsed
    };

    // Macro entry point for free functions.
    ($($meth:ident)::+ ($arg1:expr, $($args:expr),*)) => {
        unborrow!(@parse ($($args,)*) -> ([] []) ($($meth)::+) $arg1)
    };
}
```

Hello!
Thanks for creating such a cool project! :smile: :tada: 

[tt-munchers](https://danielkeep.github.io/tlborm/book/pat-incremental-tt-munchers.html) are one of many macro programming patterns written about in [The Little Book of Macros](https://danielkeep.github.io/tlborm/book/README.html). Many of Rust's more complicated and powerful macros use this pattern to accomplish their functionality. These are probably the macros that would benefit the most from this project, so it would be really cool if there was a way to integrate them properly.

Basically, what we would need to do is "see through" that pattern and modify the diagram so that it reflects the way the macro is actually meant to be used instead of just the raw input syntax that it takes. This is definitely a non-trivial thing to detect in all cases, so I really just recommend starting from a few common patterns and working your way up.

Let's look at this example:

```rust
    // Given `ids!(0, a, b, d)`, this will produce:
    // let a = 0;
    // let b = 1;
    // let c = 2;
    macro_rules! ids {
        // Increment a given counter
        ($count:expr, $name:ident, $($rest:tt)*) => {
            ids!($count, $name);
            ids!($count + 1, $($rest)*);
        };
        // Support only one name and also make the ending comma optional
        ($count:expr, $name:ident) => {
            let $name = $count;
        };
        // Base case
        ($count:expr) => ();
    }
```

Running this in macro_railroad (correctly) produces the following diagram:

![image](https://user-images.githubusercontent.com/530939/44050955-bedc9b36-9ef5-11e8-9f49-b0f99d74a723.png)

This exactly matches the input syntax of the macro as it is written. It would be nice however, if the diagram represented how the macro is truly meant to be used:

![image](https://user-images.githubusercontent.com/530939/44051010-ee1922e8-9ef5-11e8-8c31-d35b6364fba6.png)

One potentially simple way to implement this would be to:

1. Detect "tt repetition" at the end of the declared input to a macro branch
    * This is anything in the form `(..., $($xxx:tt)*) => {...};` in `macro_rules`
    * Note that `$($xxx:tt)*` is different from `$($xxx:tt),*` -- the second **does not** fall under this pattern
2. Detect whether that tt repetition is passed back into the macro itself recursively
    * You might need to check if the tt repetition is passed back exactly the same with no additional tokens added within the repetition (so `$($xxx == 1)*` would be different)
    * If this happens, you can look at the macro call and figure out after which token the tt repetition is placed. Once you know that, you draw a line back to where the tokens from the tt repetition will be passed.
    * In the example above, the macro calls itself in the line `ids!($count + 1, $($rest)*);` -- you would draw a line back to just after the comma after `count`
        * The second image above shows the exact desired result
    * If the tt repetition is used anywhere else other than in a call to the same macro, do not treat it specially -- This implies that there may be multiple calls that a tt repetition is passed to, so you may draw arrows leaving one token and getting to multiple other tokens
    * Ideally you would support more complicated forms than just `$rest:tt` so any repetitions that get passed back into the macro would work, but maybe that can be a future enhancement

Some cases to think about:

* There may be multiple tt repetitions separated by some other token
    * `$($rest:tt)* , $($rest2:tt)*`
* If there are multiple tt repetitions **not** separated by any token, the first one will get everything and the second one is superfluous
    * `$($rest:tt)*$($rest2:tt)*` - `$rest2` will always be empty
* There are both `*` repetitions and `+` repetitions and the diagram will appear differently for both
* Some macros are [mutually recursive](https://en.wikipedia.org/wiki/Mutual_recursion) (in that they call each other) -- I don't think you need to worry about supporting this case

Hopefully I haven't scared you away with all of this information! I've tried to outline a lot of the cases for you to consider, but I'm sure I missed some as well. Given all of this, I really do recommend starting by supporting the most simple cases of this pattern and then working up to the more general case.

If this is implemented, even just for simpler cases, it would be extremely valuable as a documentation tool for so many macros.
```rust
macro_rules! x {
    (= >) => {
        println!("Space");
    };
    (=>) => {
        println!("No space");
    };
}

fn main() {
    x!(= >);
    x!(=>);
}
```

The two branches are currently seen as identical, even before optimizing. This is not correct.
We need more tests, especially of `lowering` to guarantee that we produce correct results in all cases. It would be a disaster if we produced visual representations that are *not* actually part of the syntax.