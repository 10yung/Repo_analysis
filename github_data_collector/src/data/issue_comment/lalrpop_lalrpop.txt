lalrpop == 0.17.2
rust == 1.40.0

I was trying to extend the tutorial to be able to parse variable assignment (string to parse "x = 1" a got an error that the token is not recognized:

Test code:
```rust
#[test]
fn test1() {
    let mut errors = Vec::new();
    let expr = lang::ExprsParser::new()
        .parse(&mut errors, "x = 1")
        .unwrap();
    assert_eq!(&format!("{:?}", expr), "");
}
```

Added to `.lalrpop`:

```rust
use crate::ast::{Expr, Opcode, Assignment, AssignCode};
...

pub Asgnmnt: Assignment<'input> = { 
    VarIdent AssignOp Expr => Assignment::Op(<>), 
};

VarIdent: &'input str = {
    r"[A-Za-z][0-9A-Za-z_]*|_[0-9A-Za-z_]+" => <>
};

AssignOp: AssignCode = {
    "=" => AssignCode::Assign,
};
```

Added to `ast.rs`:

```rust
pub enum Assignment<'ast> {
    Op2(&'ast str, AssignCode, Box<Expr>),
}

#[derive(Copy, Clone)]
pub enum AssignCode {
    Assign,
}
```

After that, to understand the error, I removed error manipulation code and got the following error:

```
---- tests::test1 stdout ----
thread 'tests::test1' panicked at 'called `Result::unwrap()` on an `Err` value: UnrecognizedToken { token: (0, Token(1, "x"), 1), expected: ["\"(\"", "r#\"[0-9]+\"#"] }', src\libcore\result.rs:1165:5
```

I know this issue has been raised in [323 ](https://github.com/lalrpop/lalrpop/issues/323)  and [138](https://github.com/lalrpop/lalrpop/issues/138), but I think I might have a way around it that isn't too clumsy.

@Marwes comments here about the approach that Gluon takes. Couldn't the `Lines` struct [from Gluon](https://github.com/gluon-lang/gluon/blob/f8326d21a14b5f21d203e9c43fa5bb7f0688a74c/base/src/source.rs) be generated prior to lexing. It could then be passed into the parser.

Since `Lines` is available to the parser, the line and column number could be found with `<start:@L> TOKEN <end:@R>`.

Am I on to something or not?
It'd be nice to get tree-sitter grammars autogenerated from lalrpop grammars, likely by some sort of command-line tool. This'd be a first step towards https://github.com/lalrpop/lalrpop/issues/453 for at least Neovim, Atom, and (I believe) VSCode.
see https://github.com/remexre/g1/runs/338256289#step:5:535

looks like it was broken by https://github.com/rust-lang/rust/pull/65112
Added an annotation not to skip the whitespace.
An example would be:

````rust
use std::str::FromStr;

#[LALR]
#[no_skip_whitespace]
grammar;

match {
    r"[[:alpha:]_[:digit:]]+" => WORD,
    "=" => EQUAL,
    "$" => EXPAND,
    "|" => PIPE
} else {
    r"[[:digit:]]+" => NUMBER,
    r"\s+" => WS
}

pub Command: String = {
    <s1:SimpleCommand> PIPE <s2:SimpleCommand>=> format! ("(command1 {}) |(command2 {})", s1, s2),
    <s:SimpleCommand> => format! ("{}", s)
};

SimpleCommand: String = {
    <e:SimpleCommandElement> => format! ("(command {}) (parameters)", e),
    <e:SimpleCommandElement> WS <p:Params> => format! ("(command {}) (parameters {})", e, p)
};

SimpleCommandElement: String = {
    <w:Words> => w,
    <a:Assignment> WS <s:SimpleCommandElement> => format! ("(assign {}) {}", a, s)
}

Params: String = {
    <w:Words> => {
        println! ("(parameter {})", w);
        format! ("(parameter {})", w)
    },
    <w:Words> WS <p:Params> => {
        println! ("(parameter {}) {}", w, p);
        format! ("(parameter {}) {}", w, p)
    }
}

Assignment: String = {
    <w1:WORD> EQUAL <w2:Words> => format! ("{} := {}", w1, w2),
    <w:WORD> EQUAL => format! ("{} := ()", w)
};

Words: String = {
    <w:Word> => w,
    <w:Word><e:Words> => 
    {
        println! ("(words (word {}) {})", w, e);
        format! ("(word {}) {}", w, e)
    }
}

Word: String = {
    <w:WORD> => {
        println! ("{}", w);
        w.to_string()
    },
    <e:Expand> => e
};

Expand: String = {
    EXPAND <w:WORD> => {
        println! ("(expand {})", w);
        format! ("(expand {})", w)
    }
};
````

The following grammar
```
grammar;

pub Foo: () = {
    r"a*"* "b" => ()
}
```
goes into an infinite loop with the input `c`.

From my limited debugging of this, it seems to continuously parse an empty `"a*"` token, instead of detecting `c` as an invalid token.

I guess ideally lalrpop would detect potentially empty regexes at build time, but this seems like it should at least error at runtime.
the `write_uses` call as defined within [lalrpop/src/rust/mod.rs](https://github.com/lalrpop/lalrpop/blob/c531b74798a4b2640784cb4909f32e294ba652d8/lalrpop/src/rust/mod.rs#L130-#L141) requires a prefix be passed to it to populate the output. It appears based on the decision at lines [133 & 134](https://github.com/lalrpop/lalrpop/blob/c531b74798a4b2640784cb4909f32e294ba652d8/lalrpop/src/rust/mod.rs#L133-#L134) if the prefix is an empty string, it will output nothing (even if an output is required). 

This patch aims to provide a default string which can be prefixed when required.

The goal is to address: https://github.com/lalrpop/lalrpop/issues/480
Make the code in the book the same as the `calculator` directory.
Add some explanation about `grammer` in `008_error_recovery.md`.
To work around [this issue](https://github.com/rust-lang/rust/issues/65707): otherwise, all tokens referenced in grammar need to be exported from crate.
Is there a simple example on how to create a language that is indentation-based with lalrpop?