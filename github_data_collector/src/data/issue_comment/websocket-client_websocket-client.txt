
tested by using samsung tv v2 api

When my WebSocket client try to reconnect, it is set to closing the original connection first. Howerver, the target WebSocket server is in a proxied environment behind nginx. It might times out after few hour. Then the close() hangs the whole program for 10-15 mins.

From the observation based on following code, it probably hangs in "frame = self.recv_frame()". So no matter how many timeout I set, it didn't work. I wonder if this is a bug, or something I should change. Please give me some advises, thank you!

websocket/_core.py close()
```
try:
    self.connected = False
    self.send(struct.pack('!H', status) +
              reason, ABNF.OPCODE_CLOSE)
    sock_timeout = self.sock.gettimeout()
    self.sock.settimeout(timeout)
    start_time = time.time()
    print(f'websocket.close() entering timeout loop gettimeout()={self.sock.gettimeout()}')
    while timeout is None or time.time() - start_time < timeout:
        try:
            frame = self.recv_frame()
            if frame.opcode != ABNF.OPCODE_CLOSE:
                continue
            if isEnabledForError():
                recv_status = struct.unpack("!H", frame.data[0:2])[0]
                if recv_status != STATUS_NORMAL:
                    error("close status: " + repr(recv_status))
            break
        except Exception as e:
            print(f'websocket.close() timeout loop exception',e)
            break
    self.sock.settimeout(sock_timeout)
    print(f'websocket.close() entering sock.shutdown gettimeout()={self.sock.gettimeout()}')
    self.sock.shutdown(socket.SHUT_RDWR)
except Exception as e:
    print(f'websocket.close() exception',e)
    pass

self.shutdown()
```

Why not always be thread safe? The following issue was a real head scratcher until we realized that this library has to be told that you are using threads.

-------------------------

We are seeing the following error occasionally.  It happens on multiple connections to the same server at the same time making me think this is actually a snapped connection in disguise.  Is this something that the websocket client can catch and raise as a more obvious error?

```
2019-12-05 13:06:10,413 [ERROR] root: [SSL: BAD_LENGTH] bad length (_ssl.c:2341)
Traceback (most recent call last):
  File "<our code>", line 268, in _check_for_connection_alive
    self.send_ws_ping()
  File "<our code>", line 226, in send_ws_ping
    self.ws.ping("keepalive")
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_core.py", line 294, in ping
    self.send(payload, ABNF.OPCODE_PING)
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_core.py", line 253, in send
    return self.send_frame(frame)
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_core.py", line 278, in send_frame
    l = self._send(data)
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_core.py", line 448, in _send
    return send(self.sock, data)
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_socket.py", line 151, in send
    return _send()
  File "/home/ubuntu/venv3.7/lib/python3.7/site-packages/websocket/_socket.py", line 136, in _send
    return sock.send(data)
  File "/usr/lib/python3.7/ssl.py", line 984, in send
    return self._sslobj.write(data)
ssl.SSLError: [SSL: BAD_LENGTH] bad length (_ssl.c:2341)
```
I'm using websocket-client to communicate with [Chrome devtools protocol](https://chromedevtools.github.io/devtools-protocol/). Some of the messages that come back from Chrome are large (they contain the whole DOM). While I was testing [my software](https://github.com/andresriancho/w3af/blob/feature/js/w3af/core/controllers/chrome/devtools/custom_websocket.py) I found a lot of issues, which I initially associated with the socket and how it was read, but they were actually generated by [validate_utf8](https://github.com/websocket-client/websocket-client/blob/38b0481fccb9d1d50282fb72be8fb4124a6b9078/websocket/_utils.py#L92).

I'm not using `wsaccel`.

All my issues were fixed when I started using `skip_utf8_validation` in the `WebSocket` class.

Not really sure how you guys can reproduce this, but the basics are:
 * Capture websocket packets using wireshark
 * Send websocket messages to Chrome (or any other server)
 * Receive large message
 * Verify that in wireshark the server sent the message at timestamp X
 * Verify that the [socket](https://docs.python.org/2/library/socket.html) returned the message to the upper layers at X+0.001
 * Verify that the websocket returned the message to the upper layers at X+3.0001 , where the extra three seconds (could be more in some cases) are associated with `validate_utf8`

Then run the same test with `skip_utf8_validation` and you'll find that there is no delay.


In my opinion when the user makes a read but the opcode is unknown (not binary nor text) instead of returning an empty string an exception should be raised. The semantics of an empty string is unknown for client code and we should not use return values for unknown situations. I can submit a pull request if this is agreed.


https://github.com/websocket-client/websocket-client/blob/3c25814664fef5b78716ed8841123ed1c0d17824/websocket/_core.py#L318
I am having issues getting this library to ignore the proxy.  In my example, I have a target running on a private network interface.  I do not want it to use the proxy in this case.  

When I try this:
```
from websocket import create_connection
self.conn = create_connection('ws://192.168.2.159:8181', timeout=1)
```
I receive a 503 due to the proxy.  Very frustrating - is there a way to tell it to just _completely_ ignore the proxy?

Sadly, even this does not work:
```
from websocket import create_connection
self.conn = create_connection('ws://192.168.2.159:8181', timeout=1, http_no_proxy='192.168.2.159')
```

I need to specify all 3 to get it to work.

```
from websocket import create_connection
self.conn = create_connection('ws://192.168.2.159:8181', timeout=1, http_proxy_host="proxy.site.com", http_proxy_port=8181, http_no_proxy='192.168.2.159')
```
I do not want to do this.  How do I avoid it?

I'm writing a client-side script and use a provided server that I have no power over.

As far as I can tell, it sends the wrong opcodes: when it sends several continuous frames it sends them with the opcode ABNF OPCODE_TEXT (2) and a flag fin indicating that the message is not done which results in an "Illegal frame" error (the client receives a message, validates the first frame, expects to receive a second one with OPCODE_CONT (0), instead receives a new frame with OPCODE_TEXT (2) and throws an exception).

I found two ways to work around it,  both include modifying the websocket-client files

1) Comment out the validation case in _abnf.py file, lines 421-423 
` if self.recving_frames and \
                frame.opcode in (ABNF.OPCODE_TEXT, ABNF.OPCODE_BINARY):
            raise WebSocketProtocolException("Illegal frame")`

2)Or adding a flag to recv_data_frame method in _core.py to indicate if the script is encountering the issue, described above. If so, replace the opcode from the server to OPCODE_CONT for all the messages after 1st one.

There are obvious downsides for both approaches and I was wondering if anyone might have some advice on how to go about this without hacking existing libraries :) 
Since our own project has its own log output, I want to integrate the websocket log output into our own log module. Can i do that?