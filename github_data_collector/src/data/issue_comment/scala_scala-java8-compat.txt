I've been using the aws dynamodb async sdk, but I find that I cannot catch exceptions after I convert a `CompletableFuture` to Scala.
When I run
```
    client
      .createTable(tableSchema.createTableRequest(tableName))
      .thenApply[Unit](_ => Unit)
      .exceptionally {
        case _: Throwable => // exception is now property handled
      }
```
I can successfully catch the exception.

However when I run
```
     import scala.compat.java8.FutureConverters.toScala

    val cf = client
      .createTable(tableSchema.createTableRequest(tableName))
    toScala(cf).recover {
      case _: Throwable => // never gets executed
    }
```
I cannot actually catch the exception. Any clues on why?
Recent travis build: https://travis-ci.org/scala/scala-java8-compat/builds/582046003

The 2.12.8 and 2.11.12 versions show:

```
[error] /home/travis/build/scala/scala-java8-compat/target/java/scala/compat/java8/StreamShapeLowPriority.java:3:1:  error: illegal combination of modifiers: public and protected
[error]   protected abstract class BaseStreamShape<T extends java.lang.Object, S extends java.util.stream.BaseStream<?, S>, St extends scala.compat.java8.collectionImpl.Stepper<?>> implements scala.compat.java8.StreamShape<T, S> {
[error]                      ^
```

The generated file: https://gist.github.com/lrytz/899f08e00d48ca14a4943bcfe834e38e
In cases like Spark, functions need to be serialized. So the FromJavaFunction and the likes should have a default constructor and be serializable.
Currently when a `CompletionStage` fails with a `RuntimeException` this is wrapped in a `CompletionException`.
When converting `CompletionStage` to a Scala `Future` this is not unwrapped thus making it cumbersome recover from it (with an extra recover step that throws the original wrapped exception for example).

The JAR for version 0.8.0 had a fully-populated manifest, generated by BND; but 0.9.0 doesn’t, nor does the JAR produced by building HEAD manually. I haven’t figured out *why* that is yet...
I think the [documentation](https://github.com/scala/scala-java8-compat#usage-examples) regarding function conversion is wrong (at least the java code example) and doesn't compile.

To convert a java function to a scala function (like in baz) I have to write the following:
```
import static scala.compat.java8.JFunction.*;
...
// instead of return bar(functionConverters.asScalaFromFunction(f)) -> where should functionConverters come from?
return bar(func(f)); 
...

```
It says [here](https://github.com/scala/scala-java8-compat/blob/master/src/main/scala/scala/compat/java8/FutureConverters.scala#L23) that the `CompletionStage` returned by `FutureConverters` doesn't support the `toCompletableFuture()` interface at all. However, it can be used fine to retrieve the value of a completed future, and/or wait for it. That functionality is currently used by e.g. akka.

The documentation could probably be extended to reflect that waiting / getting is fine, but completing is not.

Maybe I missed it, but it would be great to have an on-line, published version of the scaladocs.

See @paulp's comment here: https://github.com/scala/slip/issues/19#issuecomment-141782414

gist: https://gist.github.com/paulp/846dbd5a67c6bed3c2e9

In `private class CF[T] extends CompletableFuture[T] with (Try[T] => Unit) {` as an example.
So if a Java user downcasts to CompletableFuture, it won't go haywire.
