MMmmkay, over the last 30 hours (or so) I learned that manual mapping is a non-trivial task.
![the_general_problem](https://user-images.githubusercontent.com/10997340/72206943-a0237c00-348b-11ea-9116-271b9ed5bf8b.png)

This is the first iteration of a generic manual mapper for the DynamicInvoke API. It has a set of use-cases that it works for but it won't be able to load any arbitrary module (see future todo list). In general any PE you can reflectively load now through Stephen Fewer's loader should work here as well.

You can test it with the following snippets:
```cs
namespace MapTest
{
    class Program
    {
        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate int MessageBox(IntPtr hWnd, String text, String caption, int options);

        [UnmanagedFunctionPointer(CallingConvention.StdCall)]
        public delegate int TestFunc();

        static void Main(string[] args)
        {

            // (1) Mimikatz x64
            SharpSploit.Execution.PE.PE_MANUAL_MAP ManMap = SharpSploit.Execution.DynamicInvoke.Generic.MapModuleToMemory(@"C:\Users\b33f\Tools\Mimikatz\x64\mimikatz.exe");
            SharpSploit.Execution.DynamicInvoke.Generic.CallMappedPEModule(ManMap.PEINFO, ManMap.ModuleBase);

            // (2) Call test DLL by DLLMain
            //SharpSploit.Execution.PE.PE_MANUAL_MAP ManMap = SharpSploit.Execution.DynamicInvoke.Generic.MapModuleToMemory(@"C:\Users\b33f\Tools\Dll-Template\Dll-Template\x64\Release\Dll-Template.dll");
            //SharpSploit.Execution.DynamicInvoke.Generic.CallMappedDLLModule(ManMap.PEINFO, ManMap.ModuleBase);

            // (3) Call test DLL by export (Also calls DllMain as part of init)
            //SharpSploit.Execution.PE.PE_MANUAL_MAP ManMap = SharpSploit.Execution.DynamicInvoke.Generic.MapModuleToMemory(@"C:\Users\b33f\Tools\Dll-Template\Dll-Template\x64\Release\Dll-Template.dll");
            //object[] FunctionArgs = { };
            //SharpSploit.Execution.DynamicInvoke.Generic.CallMappedDLLModuleExport(ManMap.PEINFO, ManMap.ModuleBase, "test", typeof(TestFunc), FunctionArgs);

            // (4) User32!MessageBox ==> This does not work
            //                       ==> Need to fix in future
            //SharpSploit.Execution.PE.PE_MANUAL_MAP ManMap = SharpSploit.Execution.DynamicInvoke.Generic.MapModuleToMemory(@"C:\Windows\System32\user32.dll");
            //object[] FunctionArgs = { IntPtr.Zero, "Hello", "Howdy", 0 };
            //SharpSploit.Execution.DynamicInvoke.Generic.CallMappedDLLModuleExport(ManMap.PEINFO, ManMap.ModuleBase, "MessageBoxA", typeof(MessageBox), FunctionArgs);
            

            //==========================================================[Sleep]
            while (true)
            {
                System.Threading.Thread.Sleep(2000);
            }
        }
    }
}
```

**Core new functions**
* MapModuleToMemory(string ModulePath)
* MapModuleToMemory(byte[] ModuleByteArray)
* CallMappedPEModule(PE.PE_META_DATA PEINFO, IntPtr ModuleMemoryBase)
* CallMappedDLLModule(PE.PE_META_DATA PEINFO, IntPtr ModuleMemoryBase)
* CallMappedDLLModuleExport(PE.PE_META_DATA PEINFO, IntPtr ModuleMemoryBase, String ExportName, Type FunctionDelegateType, object[] Parameters)

**To do at a later date**

* WOW64 support, currently it works for x64 on x64 and x32 on x32.
* Implement code to handle TLS callbacks
* Modify the default security cookie generated by the module
* Add module entry to RtlInsertInvertedFunctionTable->LdrpInvertedFunctionTable to add exception handling outside of known image bases
* Handle non-standard DLL entry points. For example, user32 does not implement DllMain, instead it exposes UserClientDllInitialize which populates the KernelCallbackTable

**Testing**

If you want to use the code to test the new functionality, you can: grab the latest mimikatz version, grab and compile the test DLL from [HERE](https://github.com/FuzzySecurity/DLL-Template)
This PR is a first stab at providing a Reverse Port Forwarding capability, using Sockets.

#### Summary of Additions
- `SharpSploit.Pivoting` namespace.
  - `ReversePortForwarding` class.
    - `AddReversePortForward` function - adds a single reverse port foward of a given `BindPort`, `ForwardAddress` and `ForwardPort`.
    - `ListReversePortForwards` function - lists all currently active reverse port forwards.
    - `DeleteReversePortForward` function - deletes a single reverse port forward of a given a `BindPort`.
    - `FlushReversePortForwards` function - deletes all currently active reverse port forwards.
Provides a DInvoke function to manually map a DLL from disk into memory using `NtCreateSection` + `NtMapViewOfSection`. After the DLL is mapped, it's exports may be used reflectively using `GetExportAddress`. This completely bypasses all user-mode API hooks and results in the DLL executing from what appears to be normally mapped memory, except that `LoadLibrary` is never called and the module is not referenced as a loaded module in the PEB.

![image](https://user-images.githubusercontent.com/17090738/68719995-d0c66280-057b-11ea-8a32-c3fe82835957.png)

Am working on adding Module Overloading to hide DLLs downloaded into memory and allow them to be executed from "file-backed" memory, appearing to be a legitimate, signed DLL on disk. Hasherezade and I have a PoC working and I am converting it to C#. https://github.com/hasherezade/module_overloading

Incidentally, there are real-world examples of attackers using this technique, such as in: https://blog.malwarebytes.com/threat-analysis/2018/08/process-doppelganging-meets-process-hollowing_osiris/
There currently doesn't appear to be a list of desired features, improvements, bug fixes, etc. It is hard to know what is considered "in-scope" for this project and what you might think is best left to other projects. If there is a todo list, it will be easier for people to contribute. 