I'm copying and pasting the tagging example from the docs into my IntelliJ Scratch file and I get a compiler error. I'm using Macwire 2.2.2 and Scala 2.11.8.

```
import com.softwaremill.macwire._
import com.softwaremill.tagging._

class Berry()
trait Black
trait Blue

case class Basket(blueberry: Berry @@ Blue, blackberry: Berry @@ Black)

lazy val blueberry = wire[Berry].taggedWith[Blue]
lazy val blackberry = wire[Berry].taggedWith[Black]
lazy val basket = wire[Basket]
```
Error Message
```
Error:(14, 26) Cannot find a value of type: [com.softwaremill.tagging.@@[Berry,Blue]]
val basket = wire[Basket]
```

Any ideas what I'm doing wrong?
Somehow macwire thinks that function from untagged dep to tagged (`T => T @@ Tag`) is actually valid tagged dep (`T @@ Tag`).

Sample code:
```scala
object MacwireWiring {

  import com.softwaremill.macwire._
  import com.softwaremill.tagging._

  trait Tag
  object Tag {
    def TaggedString(value: String): String @@ Tag = value.taggedWith[Tag]
  }
  class ServiceWithTaggedDep(tagged: String @@ Tag)

  object Wiring {
    val taggedString: String @@ Tag = Tag.TaggedString("this will compile")
    val successfullyWiredService: ServiceWithTaggedDep = wire[ServiceWithTaggedDep]
  }

  object FailingWiring {
    import Tag._

    val taggedString: String @@ Tag = TaggedString("but this fails")
    val failedServiceWiring: ServiceWithTaggedDep = wire[ServiceWithTaggedDep]
  }

}
```

And an error:
```
[error] MacwireWiring.scala:22:57: Found multiple values of type [String @@ MacwireWiring.Tag]: [List(TaggedString, taggedString)]
[error]     val failedServiceWiring: ServiceWithTaggedDep = wire[ServiceWithTaggedDep]
[error]     
```

Looks like macwire can't figure out difference between `taggedString: String @@ Tag` and `TaggedString: String => String @@ Tag`
Would it be possible to add feature which would allow to resolve optional dependencies?

Pseudo-implementation (which doesn't work): 
```scala
  def wireOpt[T](enabled: Boolean): Option[T] = {
    if (enabled) {
      Some(wire[T])
    } else {
      None
    }
  }
```

Thanks for awesome library!
building on the example of [multi-wiring via wireSet](https://github.com/adamw/macwire#multi-wiring-wireset) would it be possible to achieve this:

```
trait Musician
class RockBand(musicians: Iterable[Musician])

class Singer extends Musician
class Guitarist extends Musician
class Drummer extends Musician
class Bassist extends Musician

trait RockBandModule {

  lazy val musicians: Iterable[Musician] = wireAll[Musician] // all above musicians classes will be instantiated

  lazy val rockBand  = wire[RockBand]
}
```

namely: have a `wireAll[Base]` method to instantiate all non-abstract classes derived from `Base`

it would be handy not to have to list all implementations (as in the wireSet example) of given trait and have it wired automatically so in case you add more implementations they will be added to the collection without any modifications to the module code
I'm [adding](https://github.com/retronym/scala/pull/28) compilation time tracing to `scalac` to show how long each file/class/method takes to typecheck. The trace drills down further to measure time spent in implicit searches and in macro expansions.

I generated traces for a relatively large Scala build: https://github.com/guardian/frontend. This project uses MacWire for DI within a Play application.

The generated report suggests that 4% of total compilation time is spent in the `wire` macro:

![image](https://user-images.githubusercontent.com/65551/46646442-9565a180-cbcd-11e8-8d1a-40185cb6475c.png)

![image](https://user-images.githubusercontent.com/65551/46646420-7cf58700-cbcd-11e8-9df2-126912ff2ca0.png)

I'm having trouble getting a good look at this through Flight Recorder to make concrete suggestions about what could be optimized, but I thought I'd lodge this ticket as-is in the meantime.
The section on factories shows two alternatives on how to define a factory:
```
def taxCalculator(taxBase: Double) = wire[TaxCalculator]
    // or: lazy val taxCalculator = (taxBase: Double) => wire[TaxCalculator]
```
It does not show though, how a class can depend on such factory. 

This [answer on SO](https://stackoverflow.com/questions/25457400/injectable-factory-with-macwire) shows, how to inject a factory defined in a val (or lazy val) - second line in the documentation snippet

However, I have found no way on how to inject a factory, which is defined using a def - first line in the documentation snippet.

The following does not compile:

```scala
object Foo {
  trait Dep
  abstract class Abs {
    def foo: Dep
  }
  trait T {
    def bar: Dep
  }

  val d: Dep = new Dep {}

  val a: Abs = wire[Abs]
  val t: T = wire[T]

  def main(args: Array[String]): Unit =
    println(s"a.foo ${a.foo}")
}
```

MacWire says

```
Error: class Abs is abstract; cannot be instantiated
  val a: Abs = wire[Abs]
Error: Cannot find a public constructor nor a companion object for [Foo.T]
  val t: T = wire[T]
```

It would be nice if macwire could wire abstract classes and traits when it can satisfy abstract members like it does for constructor args.
I am new to Scala and Macwire and trying to figure out how to access instances that are wired using modules organized as classes. If modules are defined as traits, one can extend them and access the wired instances in them as below,

```
trait UserModule {
  lazy val userFinder: UserFinder = wire[UserFinder]
}

class UserFinderSpec extends FlatSpec with UserModule {
 assert userFinder.find(...) should ...
}
```

If my modules are organized as classes with composition, how do I access the instances?

```
class UserFinder(databaseConnection: databaseConnection) {
}

@Module
class DatabaseConnectionModule {
   lazy val databaseConnection: DatabaseConnection = ...
}

@Module
class UserModule(databaseConnectionModule: DatabaseConnectionModule) {
    lazy val userFinder:UserFinder = wire[UserFinder]
}
```

```
class UserFinderSpec extends FlatSpec {
    //How to access UserFinder here?
    //val wired = wiredInModule(new UserModule(new DatabaseConnectionModule))
    //val userFinder = wired.lookup(classOf[UserFinder]
    //Above way to access the instances seems complicated 
    //as I need to instantiate the modules with it's dependency chain which can be very long in my use-case.
}
```
If we want to use an alternative constructor for a regular class, we can use the `wireWith` function to select the factory that we want. It would be nice to have this functionality for akka actors as well, either via currying / partial application or factory functions. 

For example:

```scala
import akka.actor.{Actor, ActorRef, ActorSystem}

class DatabaseAccess()
class UserFinderActor(configArg: Int, databaseAccess: DatabaseAccess) extends Actor {
  override def receive: Receive = {
    case m => // ...
  }
}
object UserFinderActor {
  def apply(configArg: Int)(databaseAccess: DatabaseAccess) = new UserFinderActor(configArg,databaseAccess) 
}

import com.softwaremill.macwire._
import com.softwaremill.macwire.akkasupport._
  
val theDatabaseAccess = wire[DatabaseAccess]
					     
val system = ActorSystem("actor-system")

val theUserFinder = wireActorWith(UserFinderActor(1) _)("userFinder")  
```
Problem description, steps to reproduce and (a bit of) discussion: 

https://stackoverflow.com/questions/48657546/macwire-wirewith-and-implicit-parameters.

Minimal example:


    import com.softwaremill.macwire._

    object A {
      def props(x: Int)(implicit y: String): A = new A(x)
    }

    class A(x: Int)(implicit y: String) {
       val sum: String = s"$x + $y"
    }

    object App {
       def main(): Unit = {
         val xVal: Int = 3
         implicit val yVal: String = "5"

         // val aInstance = wire[A] // works
         // val aInstance = A.props(xVal) // works
         val aInstance: A = wireWith(A.props _) // compile error

         println(aInstance.sum)
      }
    }

    App.main()


Error: 

    Error:(21, 33) type mismatch; found   : Int required: String
        val aInstance: A = wireWith(A.props _)