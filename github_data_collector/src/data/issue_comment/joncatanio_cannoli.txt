It would be handy to have the lexer/parser separate from the compiler if possible. That would allow projects to make an interpreted version without having to rewrite the lexer/parser. 
Fields like `lineno` would be really beneficial to have in the AST so the compiler can report better error messages. Doing this in rust is a little more complicated since we can't pattern match structs and there isn't really a way to extend a class like one would in Java. We could apply traits to structs/enums but this only allows us to create similar functions not fields. The best way to achieve this is use a combination of enums and structs. An encapsulating struct can provide common fields with a `variant` field that represents the AST enum that is currently used.

```
enum AstNode {
   stmt: Statement,
   expr: Expression,
   ...
}

struct Node {
   lineno: usize,
   ...,
   variant: AstNode
} 
```

This is just a simple example that allows us to avoid adding common fields to each enum arm.
A context should be passed down through to each call. CPython represents this context with keywords like `del` which may change the context from `Load` or `Store` to `Del`. It shouldn't be conceptually difficult but it is quite a large update that needs to be done when the parser is in a more complete state.
Add concise and helpful rust doc comments prefixed with `///` or `//!` to all modules and crates.

Resources:
- [Rust By Example comment overview](https://rustbyexample.com/meta/doc.html)
- [Rust By Example intro to comments](https://rustbyexample.com/hello/comment.html)
- [Rust 2nd Edition Book](https://doc.rust-lang.org/book/second-edition/ch14-02-publishing-to-crates-io.html#making-useful-documentation-comments)