I am looking to support ABAC for a CMS-type system, where there could be thousands to potentially even more ABAC rules. Writing one long matcher isn't feasible in this case, nor is having multiple enforcers. Is there any other workaround this?

An ABAC policy for us is something like `If user age is between 24 and 64, then they can "view" some "resource"`. Any thoughts?
In our system we have hundreds of thousands of users with hundreds of basic rules and hundreds of thousands of further overrides to the basic rules. This is straightforward to implement in casbin, for example.

A model such as:
```ini
[request_definition]
r = sub, rol, act

[policy_definition]
p = sub, rol, act, eft

[role_definition]
g = _, _

[policy_effect]
e = some(where (p.eft == allow)) && !some(where (p.eft == deny))

[matchers]
m = (g(r.rol, p.rol) && r.act == p.act) || (r.sub == p.sub && r.act == p.act)
```

And policy such as:
```csv
# general role-level rules
p,      , admin   , write       , allow
p,      , engineer, edit-reports, allow
p,      , user    , report      , allow

# specific user overrides
p, marc ,         , edit-reports, deny
p, alice,         , edit-reports, allow

# role hierarchy 
g, engineer, user
g, admin, user
```

Now the challenge however is that the specific user overrides part is huge in real life and loading it up slows performance down a lot, one could try to use the FilteredAdapter but it clears the main model at each call so it's not suited to be called per-request. The SyncedEnforcer is very coarse locking and effectively would serialize each http request on the permissions check. 

None of this would be necessary if the adapter could load the general role-level ruleset and allow for the user to pass in a set of overrides valid only for the specific Enforce call. This way you would avoid the vast majority of locking problems since nothing shared would need to be mutated, and at the same time you can deal with caching of the overrides separately.
I am new to casbin, I just read all doc yesterday but I still have one question
If one application, have mutil kind user table how can I get the specific table rbac roles list
example table: admin, user

maybe is add table_name as doman ??
~question
Thanks to such a great team for making casbin! I am still new to using Casbin and RBAC access control models. I have some questions to ask:

In the [official documentation](https://casbin.org/docs/en/rbac) RBAC model mentions:

> 4. If A has role B, B has role C, then A has role C. This transitivity is infinite for now.

I want to ask:

1. Can this situation be simulated using casbin? can you provide a example ~
2. How does Casbin's RBAC model resolve policy conflicts, can you give an example to explain it? Or suggest what document or source code should I read?

Thanksï¼

HI~ 
Would you plan to support pattern function in 3rd args(domain) of g?

In my case, I may want to define some inheritance relations between global roles, and assign a role to a user (like alice) in a specific project. 

The policy and model seem like following:
```csv
g, finance_viewer, app_viewer, *
g, alice, finance_viewer, project_a
```
```ini
[request_definition]
r = sub, dom, obj, act

[policy_definition]
p = sub, dom, obj, act

[role_definition]
g = _, _, _
g2 = _, _

[policy_effect]
e = some(where (p.eft == allow))

[matchers]
m = g(r.sub, p.sub, r.dom) && g2(r.obj,p.obj) && r.dom == p.dom && r.obj == p.obj && r.act == p.act
```  
Although there are some ways to solve in my case, it will be grateful if casbin can support pattern like `*` at domain~  


Hi,

I've been working for a week on optimizing Casbin library.

Basically, I'm trying the following approach:
- store policies in an in-memory database (sqlite - but I might change this);
- transforming a matcher into a parametrized query (for the mentioned database);
- when Enforce(...) is called, we query the database in order to find the related policies;
- the expression evaluator then evaluates only the restricted set of policies.

In addition to that:
- all complex variables in the matcher are transformed to scalar variables (r.obj.property => r_obj_property). This speeds up the evaluation, but I first did it because it's easier to store only scalar variables in the database;
- I use Google's Common Expression Language instead of govaluate, mainly because this lib allows manipulating the expression Abstract Syntax Tree (this is something I need for transforming the expression to a database query).

My main concern is to keep Casbin API unchanged, I hope I'll be able to do this.

Do you have any comments, criticism...? Things I might have not considered?

Hello, I was giving [some update to SQLAlchemy adapter](https://github.com/pycasbin/sqlalchemy-adapter/pull/5), but I found out that there's no set standard on handling the empty string policy field.

I read https://github.com/casbin/casbin/issues/171#issuecomment-445434013 and the original author @hsluoyz doesn't seem to have a strong opinion on whether to allow empty string or not.

However, I think we should whether 1) do not allow empty string in the first place when writing rules, or 2) explicitly separate empty string and null in the persistence. This is because if we allow empty string on rules, we cannot differentiate whether it's a valid rule element when we do the loading.

Consider a following rule example:
```
'p', 'x', '', 'y', 'z'
```

Above can be persisted in several ways as below:
```
| v0 | v1   | v2 | v3 | v4   | v5   |
|----|------|----|----|------|------|
| x  |      | y  | z  | null | null |
| x  | null | y  | z  | null | null |
| x  |      | y  | z  |      |      |
```

The first option is okay, we can differentiate between empty and nil, so that when loading we can decide that it's `'x', '', 'y', 'z'`.
The second and third option is not okay, because we cannot differentiate between the two, which lead to a situation where we can't decide it should whether be `'x', '', 'y', 'z'` or `'x', '', 'y', 'z', '', ''`, or even `'x'`.. when loading.

If you look at current implementation of one most famous orm adapter(xorm-adapter in Go), this behavior is actually giving a false result.
[Here](https://github.com/casbin/xorm-adapter/blob/master/adapter.go#L28), it sets the field as nonnull, and give empty string '' by default.
[Here](https://github.com/casbin/xorm-adapter/blob/master/adapter.go#L224), it does not forbid an empty string input.
However, [here](https://github.com/casbin/xorm-adapter/blob/master/adapter.go#L177) when loading, it ignores the value if it's an empty string.
So if we've ever inputted `'x', '', 'y', 'z'`, it will save in db with third option illustrated above, and be loaded as `'x', 'y', 'z'`, which is wrong.

So it might seem trivial, and ever question whoever will input an empty string field, it's important for the adapter library to have a standard behavior so that all adapters can be compatible (e.g. when switching from lang A to lang B(change of adapter) while staying with same DB, it should just work).

Also, in my case it happened to me, when I was working on 'RBAC with domains' model, where I was tempted to put empty string '' on tenant of a 'root' role. So I wish there would be a standard behavior on handling empty string.

I think @hsluoyz you can make a judgement call. What do you think?
In my opinion, it's simpler to just forbid the use of empty string field on the policy, raising invalid argument error when input with empty string comes in.
I see it have ```AddPolicy()``` but it just add one by one policy
if I want to add 2000 policy on db adapter ? 
In the docs there is a note where the decision not to have multiple matchers is left open for discussion.  Here is the use case I have where I use multiple matchers, and some code that I use currently to do it:

I have a role with a pattern "foo/bar/*" that grants an access level of "read/write" to a user.  
I have another role with a pattern "foo/bar/secret/*" that restricts access to "read".

I give a user both the above roles and I expect the following behavior:

Enforce(user, "foo/bar/baz", "write") -> true
Enforce(user, "foo/bar/secret/baz", "write") -> false

In order to do this I created a "negative" matcher.  When I find a role where access is granted I do a check for a role that matches the "negative" of the above role:

```golang
<REDACTED>
```

This "works" of course, but it does illustrate that these "negative" matchers are necessary in order to support this sort of RBAC scenario.  