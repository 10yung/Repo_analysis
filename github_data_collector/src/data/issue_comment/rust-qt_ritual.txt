Would it be possible to provide an example of deploying custom qt code via ritual? EG say i want to implement a custom class inheriting from QSortFilterProxyModel on the c++ side and integrate it into a rust-qt project. What is involved?. Maybe just create a project illustrating what is involved?
I was wondering if there is anything complementary in this relatively new crate:
[qmetaobject-rs](https://github.com/woboq/qmetaobject-rs)
Could the approach be combined with rust-qt to add support for signals/slots/etc?
I have a QListWidget that I am looking to connect a signal from (the signal appears in the docs as coming from QListView via Deref). I implement a SlotOfQListOfQModelIndex  and attempt to connect them like so:
```
withpackage_ptr
                .indexes_moved()
                .connect(&form.withpackage_moved);
```
This compiles fine, but when launching the application, I get this error:
```
QObject::connect: No such signal QListWidget::indexesMoved(const QList< QModelIndex >&)
QObject::connect:  (sender name:   'WithsListWidget')
```
That definitely looks like the right C++ signature to me....

# Update
I tried implementing this using the qlistview and the QStandardItemModel. I ran into the same issue.  

My slot is defined like so:
```
SlotOfQListOfQModelIndex::new(
                    move |indexlist: Ref<QListOfQModelIndex>| {
                        println!("ohboy");
                    },
```

is it an issue with my slot?  I suspect there is a signature mismatch between the signal which is a const pointer and the slot, which is a const reference...

NB I also tried this with a RawSlotOfQListOFQModelIndex ....

# Or...
The signal is not defined correctly in the library. 
in QT, the signature of the method is :
```
void QListView::indexesMoved(const QModelIndexList &indexes)
```
but in rust-qt it is:
```
pub fn indexes_moved(&self) -> Signal<(*const QListOfQModelIndex,)>
```
shouldnt that be
```
pub fn indexes_moved(&self) -> Signal<(const QListOfQModelIndex&,)>
```
This would be great to get support for, as I dont think there is a way without custom signals to do meaningful work outside the main thread and update the gui when done.

https://doc.qt.io/qt-5/qtconcurrent-index.html


Will vulkan api be supported in the future? 
Hi, 

I'd like to use Rust QT bindings for an embedded target. The build host is an x86, the target is an aarch64 architecture. However I can't figure out how to cross compile the qt bindings crate.

I suppose it has something to with the c_lib part which is part of each crate generated by ritual.
From my build logs I see that the host compiler instead of the target is used for c_lib. I think this is because cmake does not get setup for cross-compiling during this build step.

Further, it might be necessecary to re-generate my own crates to match the qt-version used on the cross target and not the host (https://github.com/rust-qt/ritual#generating-qt-crates).

What is the preferred way to select the sysroot/cross toolchain in ritual?

By the way, I am using buildroot.

The missing include file (see log below) is present int the sysroot of the target (but not on the host).

Thanks for your help

```
$> PATH="<path-to-dev-dir>/devel/build/br2/host/bin:<path-to-dev-dir>/devel/build/br2/host/sbin:<path-to-home>/.cargo/bin:<path-to-home>/.cargo/bin:/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games" \
SYSROOT=<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot \
PKG_CONFIG_ALLOW_CROSS=1 \
CARGO_HOME=<path-to-dev-dir>/devel/build/br2/host/share/cargo \
cargo build --release --target=aarch64-unknown-linux-gnu --manifest-path=<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/Cargo.toml --verbose -j1

[...]

error: failed to run custom build command for `qt_gui v0.3.0`

Caused by:
  process didn't exit successfully: `<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/release/build/qt_gui-2731c6cc43cc56ed/build-script-build` (exit code: 1)
--- stdout
-- The C compiler identification is GNU 8.3.0
-- The CXX compiler identification is GNU 8.3.0
-- Check for working C compiler: /usr/bin/cc
-- Check for working C compiler: /usr/bin/cc -- works
-- Detecting C compiler ABI info
-- Detecting C compiler ABI info - done
-- Detecting C compile features
-- Detecting C compile features - done
-- Check for working CXX compiler: /usr/bin/c++
-- Check for working CXX compiler: /usr/bin/c++ -- works
-- Detecting CXX compiler ABI info
-- Detecting CXX compiler ABI info - done
-- Detecting CXX compile features
-- Detecting CXX compile features - done

[...]

-- RITUAL_âINCLUDE_PATH=<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5;<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux\
-gnu/sysroot/usr/include/qt5/QtGui;<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5/QtCore
-- RITUAL_LIBRARY_PATH=<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/lib
-- RITUAL_LIBRARY_TYPE=STATIC
-- RITUAL_LINKED_LIBS=Qt5Gui;Qt5Core
-- RITUAL_CPP_LIB_VERSION=51202
-- RITUAL_COMPILER_FLAGS=-std=gnu++11 -fPIC
-- Configuring done
-- Generating done
-- Build files have been written to: <path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/aarch64-unknown-linux-gnu/release/build/qt_gui-15ef8cd72196cd53/out/c_lib_build
/usr/bin/make -f CMakeFiles/Makefile2 clean

[...]

/usr/bin/c++  -DQT_GUI_C_LIBRARY -DQT_NO_VERSION_TAGGING -DRITUAL_CPP_LIB_VERSION=51202 -I<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/aarch64-unknown-linux-gnu/releas
e/build/qt_gui-15ef8cd72196cd53/out/c_lib_build/sized_types_autogen/include -I<path-to-dev-dir>/devel/build/br2/host/share/cargo/registry/src/github.com-1ecc6299db9ec823/qt_gui-0.3.0/c_lib
 -I<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/aarch64-unknown-linux-gnu/release/build/qt_gui-15ef8cd72196cd53/out/c_lib_build -I<path-to-dev-dir>/devel/bu
ild/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5 -I<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5/QtGui -I<path-to-home>/cherry
/cobra/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5/QtCore  -Wall -Wextra -Wno-deprecated-declarations -Werror=return-type -std=gnu++11 -fPIC -O3 -DNDEBUG   -o CMakeFiles/
sized_types.dir/sized_types.cxx.o -c <path-to-dev-dir>/devel/build/br2/host/share/cargo/registry/src/github.com-1ecc6299db9ec823/qt_gui-0.3.0/c_lib/sized_types.cxx
make[2]: Leaving directory '<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/aarch64-unknown-linux-gnu/release/build/qt_gui-15ef8cd72196cd53/out/c_lib_build'
make[1]: Leaving directory '<path-to-dev-dir>/devel/build/br2/build/qt-examples-custom/target/aarch64-unknown-linux-gnu/release/build/qt_gui-15ef8cd72196cd53/out/c_lib_build'
--- stderr
In file included from <path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5/QtGui/QtGui:45,
                 from <path-to-dev-dir>/devel/build/br2/host/share/cargo/registry/src/github.com-1ecc6299db9ec823/qt_gui-0.3.0/c_lib/sized_types.cxx:1:
<path-to-dev-dir>/devel/build/br2/host/aarch64-buildroot-linux-gnu/sysroot/usr/include/qt5/QtGui/qopengl.h:105:13: fatal error: GLES3/gl32.h: No such file or directory
 #   include <GLES3/gl32.h>
             ^~~~~~~~~~~~~~
compilation terminated.
make[2]: *** [CMakeFiles/sized_types.dir/build.make:66: CMakeFiles/sized_types.dir/sized_types.cxx.o] Error 1
make[1]: *** [CMakeFiles/Makefile2:71: CMakeFiles/sized_types.dir/all] Error 2
make: *** [Makefile:133: all] Error 2
Error:
   command failed with exit code: 2: "cmake" "--build" "." "--" "-j1" "install"
```
Would be nice to get this at some point!

https://doc.qt.io/qt-5/qtwebengine-index.html
Hello guys,

I'm trying to use rust-qt on Windows.
I'm using only qt_widgets dependency and "cargo build" for the build. 
Qt5.8.0 is installed.
I have an error when cmake is called for qt_core, qt_gui and qt_widgets.

DC2R_INCLUDE_PATHS variable seems to be bad : 
"-DC2R_INCLUDE_PATHS=
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\QtWidgets;
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\QtCore;
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;
	C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\QtGui"

Is it the problem ?

**Here the error message :**

```
error: failed to run custom build command for `qt_core v0.2.3`
process didn't exit successfully: `d:\DEV\RustProjects\qt_test\target\release\build\qt_core-1774efd2dc7f4c7f\build-script-build` (exit code: 101)
--- stderr
Executing command: "qmake" "-query" "QT_VERSION"
QT_VERSION = "5.8.0"
Detecting Qt directories
Executing command: "qmake" "-query" "QT_INSTALL_HEADERS"
QT_INSTALL_HEADERS = "C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include"
Executing command: "qmake" "-query" "QT_INSTALL_LIBS"
QT_INSTALL_LIBS = "C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/lib"
Executing command: "qmake" "-query" "QT_INSTALL_DOCS"
QT_INSTALL_DOCS = "C:/dev/Qt/Qt5.8.0/Docs/Qt-5.8"
Building C++ wrapper library
Executing command: "cmake" "C:\\Users\\QuanticBoss\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\qt_core-0.2.3\\c_lib" "-G" "NMake Makefiles" "-DC2R_LIBRARY_TYPE=SHARED" "-DC2R_INCLUDE_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\QtCore" "-DC2R_LIB_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/lib" "-DC2R_FRAMEWORK_PATHS=" "-DC2R_LINKED_LIBS=Qt5Core" "-DC2R_LINKED_FRAMEWORKS=" "-DC2R_COMPILER_FLAGS=" "-DCMAKE_BUILD_TYPE=Release" "-DCMAKE_INSTALL_PREFIX=d:\\DEV\\RustProjects\\qt_test\\target\\release\\build\\qt_core-bc5039f4e0227f37\\out\\c_lib_install"
Error:
   0: Le fichier spécifié est introuvable. (os error 2)
   1: failed to run command: "cmake" "C:\\Users\\QuanticBoss\\.cargo\\registry\\src\\github.com-1ecc6299db9ec823\\qt_core-0.2.3\\c_lib" "-G" "NMake Makefiles" "-DC2R_LIBRARY_TYPE=SHARED" "-DC2R_INCLUDE_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\QtCore" "-DC2R_LIB_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/lib" "-DC2R_FRAMEWORK_PATHS=" "-DC2R_LINKED_LIBS=Qt5Core" "-DC2R_LINKED_FRAMEWORKS=" "-DC2R_COMPILER_FLAGS=" "-DCMAKE_BUILD_TYPE=Release" "-DCMAKE_INSTALL_PREFIX=d:\\DEV\\RustProjects\\qt_test\\target\\release\\build\\qt_core-bc5039f4e0227f37\\out\\c_lib_install"
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Error(Msg("failed to run command: \"cmake\" \"C:\\\\Users\\\\QuanticBoss\\\\.cargo\\\\registry\\\\src\\\\github.com-1ecc6299db9ec823\\\\qt_core-0.2.3\\\\c_lib\" \"-G\" \"NMake Makefiles\" \"-DC2R_LIBRARY_TYPE=SHARED\" \"-DC2R_INCLUDE_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include;C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/include\\\\QtCore\" \"-DC2R_LIB_PATHS=C:/dev/Qt/Qt5.8.0/5.8/msvc2015_64/lib\" \"-DC2R_FRAMEWORK_PATHS=\" \"-DC2R_LINKED_LIBS=Qt5Core\" \"-DC2R_LINKED_FRAMEWORKS=\" \"-DC2R_COMPILER_FLAGS=\" \"-DCMAKE_BUILD_TYPE=Release\" \"-DCMAKE_INSTALL_PREFIX=d:\\\\DEV\\\\RustProjects\\\\qt_test\\\\target\\\\release\\\\build\\\\qt_core-bc5039f4e0227f37\\\\out\\\\c_lib_install\""), (Some(Os { code: 2, kind: NotFound, message: "Le fichier spécifié est introuvable." }), None))', src\libcore\result.rs:997:5
note: Run with `RUST_BACKTRACE=1` environment variable to display a backtrace.
```

**Thanks**
Could generated qt crates depends locally only on generated crates?
There is a option `--no-local-paths` but it make all qt crates depends on version from crates.io.

With `--no-local-paths`:
```
qt-test000 v0.1.0 (file:///mnt/another/srcs/myPijul/qt-test000)
├── qt_core v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_core)
│   ├── cpp_utils v0.2.0
│   └── libc v0.2.32
├── qt_gui v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_gui)
│   ├── cpp_utils v0.2.0 (*)
│   ├── libc v0.2.32 (*)
│   └── qt_core v0.2.2
│       ├── cpp_utils v0.2.0 (*)
│       └── libc v0.2.32 (*)
├── qt_ui_tools v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_ui_tools)
│   ├── cpp_utils v0.2.0 (*)
│   ├── libc v0.2.32 (*)
│   ├── qt_core v0.2.2 (*)
│   ├── qt_gui v0.2.2
│   │   ├── cpp_utils v0.2.0 (*)
│   │   ├── libc v0.2.32 (*)
│   │   └── qt_core v0.2.2 (*)
│   └── qt_widgets v0.2.2
│       ├── cpp_utils v0.2.0 (*)
│       ├── libc v0.2.32 (*)
│       ├── qt_core v0.2.2 (*)
│       └── qt_gui v0.2.2 (*)
└── qt_widgets v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_widgets)
    ├── cpp_utils v0.2.0 (*)
    ├── libc v0.2.32 (*)
    ├── qt_core v0.2.2 (*)
    └── qt_gui v0.2.2 (*)
```
Without:
```
qt-test000 v0.1.0 (file:///mnt/another/srcs/myPijul/qt-test000)
├── qt_core v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_core)
│   ├── cpp_utils v0.2.0 (file:///tmp/cpp_to_rust/cpp_to_rust/cpp_utils)
│   └── libc v0.2.31
├── qt_gui v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_gui)
│   ├── cpp_utils v0.2.0 (file:///tmp/cpp_to_rust/cpp_to_rust/cpp_utils) (*)
│   ├── libc v0.2.31 (*)
│   └── qt_core v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_core) (*)
├── qt_ui_tools v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_ui_tools)
│   ├── cpp_utils v0.2.0 (file:///tmp/cpp_to_rust/cpp_to_rust/cpp_utils) (*)
│   ├── libc v0.2.31 (*)
│   ├── qt_core v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_core) (*)
│   ├── qt_gui v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_gui) (*)
│   └── qt_widgets v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_widgets)
│       ├── cpp_utils v0.2.0 (file:///tmp/cpp_to_rust/cpp_to_rust/cpp_utils) (*)
│       ├── libc v0.2.31 (*)
│       ├── qt_core v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_core) (*)
│       └── qt_gui v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_gui) (*)
└── qt_widgets v0.2.2 (file:///mnt/another/srcs/myPijul/qt-test000/qt_widgets) (*)
```

Is it possible to use cpp_utils from crates.io while qt crates be generated?
Can you provide an example or docs for extending a Qt class? E.g. A simple example that extends `qt_widgets::main_window::MainWindow` and overrides [`closeEvent`](http://doc.qt.io/qt-5/qwidget.html#closeEvent)? This is commonly needed to intercept closing of a window.

(I assume this is not implemented per https://github.com/rust-qt/cpp_to_rust/issues/26, I'll just leave this open because a simple example showing this, once done, has a lot of value and it can make it clear to other users that this is not implemented yet.)