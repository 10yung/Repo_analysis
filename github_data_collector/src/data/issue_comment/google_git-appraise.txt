
Use [CodeLingo](https://codelingo.io) to automatically fix function comments following the
[Code Review Comments guidelines](https://github.com/golang/go/wiki/CodeReviewComments#error-strings).

This patch was generated by running the CodeLingo Rewrite Flow over the "[go-error-fmt](https://github.com/codelingo/codelingo/blob/master/tenets/codelingo/code-review-comments/go-error-fmt/codelingo.yaml)" Tenet. Note: the same Tenet can be used to automate PR reviews and generate contributor docs.

[Install CodeLingo to drive Continuous Higher Standards](https://github.com/apps/codelingo)

[Learn about CodeLingo](https://codelingo.io)

This commit adds different color highlighting to different review states
in the output of "git-appraise list".

The default colors are:
- abandon: magenta,
- accepted: green,
- danger: yellow red bold blink,
- pending: cyan,
- rejected: yellow red bold strike,
- submitted: yellow,
- tbr: red white bold blink.

They can be modified by the user by setting the corresponding
configuration options in the color.appraise section. E.g. to use magenta
for the "pending" state, set color.appraise.pending to "magenta":
```
 [color "appraise"]
     pending = magenta
```
Currently, use of `gpg` is [hardcoded](https://github.com/google/git-appraise/blob/98c8fb2f1cf2716d4d63b59c0a5edc44c54c4dd3/review/gpg/signable.go#L65). Instead, it ought to check whether a user has the config key `gpg.program` set, and use it if so. If not, it can fall back on a default.
It would be a big improvement if we provided a way of authenticating review metadata (i.e. git-notes).

To do that, I think we should try to imitate the model git uses for GPG signing commits.

This would mean adding a -S flag to all of the git appraise subcommands that generate review metadata (e.g. review requests, comments, etc). That metadata would then be signed prior to being written. We would use the user's GPG key defined in the user.signingkey config setting to generate this signature. Additionally, the generated git-notes commits would be signed with that same key.

When displaying reviews/comments/etc, we would include information about whether or not the metadata was signed and whether or not the signature could be verified.

We would also want to add a --verify-signatures flag to the git appraise pull command which would cause the merge to fail if any of the incoming git-notes commits or review metadata were not verifiably signed. This would correspond to the same, existing flag in the git merge command. The git appraise pull command should also take a -S flag to cause the git-notes merge commit to be signed. If the --verify-signatures flag is provided then the -S flag should be implied.

To sign a metadata entry, we could do something like the following:

1. Add a signature field to the various JSON schemas.
2. Initially fill in that field with a placeholder value like gpgsignature.
3. Serialize the JSON object as a single line string.
4. Generate a detached GPG signature of this string.
5. Encode the generated signature as a single-line JSON string.
6. Replace the placeholder value with the encoded signature.
7. Write out this final value as the actual git-notes entry.
8. Verifying the signature would then involve running that process in reverse.

This would mean that signing changes and checking signatures would be an optional feature that each individual community could decide for itself whether or not to adopt.

We should also provide some way of distributing the public GPG keys of contributors inside of the repository. The best approach would probably be to replicate the logic we are using in #88 for storing the list of forks in the repository.
This change adds the concept of "forks" to git-appraise.

The underlying idea is that each contributor can have their own personal repository to which they push, and that the overarching repository can be viewed as a compilation of those separate repositories.

In essence, we are adding symbolic links to other repositories inside the repo itself, and then resolving those links on the client side.

Each entry in this collection of symbolic links is what we call a "fork", and the collection includes all of the information that a client needs to know how to fetch from each fork and which notes should be merged from each fork.

By doing this, we unlock the ability to perform reviews across multiple remote repositories, and even entirely separate hosting providers.

For example, one contributor could have a repository that they push to on GitHub, another can have one on GitLab, and a third could have one stored in GitTorrent, and all three could push to their respective repositories while reviewing code from each other.

This fixes #71 
Hello,

I open this topic just to start a joint discussion on what it takes to offer a GUI integration for the popular Atom Editor.

I also asked in the Atom Editor Forum to find like-minded persons:

https://discuss.atom.io/t/gui-for-git-appraise-code-review-comments/52261
I'm working on vim integration for git-appraise. g
Trying to get a list of reviews programmatically, git-appraise list -json dumps the entirety of all reviews, rather than just the "headline" details. Ideally it will leave dumping of the individual review details to git-appraise show. On busy repositories, git appraise list -a -o json could be prohibitively large I guess?

it would be nice to have a manpage (maybe just including some of the current docs) that can show up in `git help appraise`
This is meant for situations where an outside contributor requests a pull from their repository to an upstream repository.

In that scenario, the outside contributor can pull reviews from the upstream repository, and can push their review metadata to their repository. However, the maintainers of the upstream repository probably do not want to pull review metadata for all reviews from that outside contributor's repository, but do want to pull review metadata for that one request.

I imagine a scenario like the following:

1. A repository (that we'll call `upstream`) is hosted somewhere.
2. Outside contributor creates their own fork of that repository (that we'll call `fork`).
3. Outside contributor makes some changes in their fork.
4. The contributor requests a pull (either via `git request-pull` or something like a GitHub pull request) from their fork into the upstream repository.
5. The maintainers of the upstream repository fetch the changes from the fork into a branch and create a review request to merge that branch into the master branch.
6. The maintainers add some comments to the review.
7. The outside contributor runs `git appraise pull <upstream>` to fetch the review request and comments from the upstream repository. They then respond to the comments and run `git appraise push <fork>` to push their comments to their fork.
8. The upstream maintainers run something like `git appraise pull --only-comments <review> <fork>` to pull *just* the comments for that review from the fork, and then they run `git appraise push <upstream>` to push the combined review metadata to the upstream repository.
9. Repeat steps 6-8 until the maintainers are happy with the review and submit it.

Since the upstream only really cares about the comments from the contributor (the review requests will be different because the review refs will be different, and the maintainers may want to abandon the review), I'm thinking this can all be supported by adding a flag to the `git appraise pull` subcommand that tells it to only pull the notes from the `refs/notes/devtools/discuss` ref, and to only merge in the notes for a specified review.