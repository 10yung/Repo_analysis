Currently we only detect strings in fileinfo (with `--strings` option) in what is assumed as sections containing data. However there are cases when there might be strings also in sections containing code or sections that are for some reason not marked as a data sections. The original premise of this was to lower the amount of garbage detected as strings (as some byte sequences might represent readable strings).

However not having certain strings detected can be punishing, so we should also start detecting strings in all sections while making the threshold stricter for sections which do not resemble data sections. Threshold would be the same for data sections as it was until now.
Same as we do with .NET and VB, we should also extract information about Go binaries because they seem to contain some useful information.

The very first thing we should try to obtain is `Go build ID` located at the start of code section (at least in PE). Some other information might be available too (https://rednaga.io/2016/09/21/reversing_go_binaries_like_a_pro/). This is more of a research ticket.

Structure of Go binaries might differ when built as PE, ELF or Mach-O so part of this ticket is also doing it for all common native file formats.
1. As we run **retdec-decompiler.py xxx.elf --stop-after bin2llvmir**, a xxx.elf.json file will be generated during the process, which by default will be used to generate xxx.elf.ll (LLVM IR file) later.

2. According to **retdec-decompiler.py**, if I understand correctly, "--config" gives users the option to specify the json config file to be used to generate the LLVM IR file. 

3. In order to test if "--config" works properly, I ran the command **retdec-decompiler.py xxx.elf --stop-after bin2llvmir --config path/to/the/xxx.elf.json/that/was/generated/in/step1**. With this command, I explicitly asked retdec to use the json file that is the same as the one that would be automatically generated. In theory, a same LLVM IR file should be generated since essentially an identical json file is used despite that one command has "--config" option, while the other does not. However, the LLVM IR generated in step 3 is different from the one generated in step 1, which can be told by the decompiled main() function explained below.

In binary, the range of main() function is 0x8018ab8 - 0x801aee3.
The code blocks are (in the gap between any two code blocks are data due to optimization):
0x8018ab8 - 0x8018d91
0x8018e3c - 0x8018f15
.............
0x801ab78 - 0x801aee3

With the command in step 1, the decompiled main() function is as follows, which seems to be correct as at the end of the function, there is a branch to 0x8018e3c which is exactly the second code block. **However, I didn't find any branches to 0x8018f20 which is the third code block in the LLVM IR, so as other following code blocks. This might be another failure to look into**. 
```
define i32 @main(i32 %argc, i8** %argv) {
dec_label_pc_8018ab8:
  %cpsr_z.global-to-local = alloca i1, align 1
  %sl.global-to-local = alloca i32, align 4
........
  %v0_801aa90.pr = load i1, i1* %cpsr_z.global-to-local, align 1
  br i1 %v0_801aa90.pr, label %dec_label_pc_8018e3c, label %bb544
bb544:                                            ; preds = %bb543
  store i32 1, i32* @r1, align 4
  br label %dec_label_pc_8018e3c
}

```


With the command in step 3, the main() function was misdecompiled as **multiple** functions, which obviously is incorrect.
```
define i32 @main(i32 %argc, i8** %argv) {
dec_label_pc_8018ab8:
  %tmp = ptrtoint i8** %argv to i32
  store i32 %tmp, i32* @r1, align 4
  store i32 %argc, i32* @r0, align 8
  %stack_var_0 = alloca i32, align 4
  %v0_8018ab8 = load i1, i1* @cpsr_n, align 1
  br i1 %v0_8018ab8, label %bb, label %.thread
.thread:                                          ; preds = %dec_label_pc_8018ab8
  store i32 134318784, i32* @lr, align 4
  br label %dec_label_pc_8018ac0
bb:                                               ; preds = %dec_label_pc_8018ab8
  %v1_8018ab8 = load i32, i32* @r0, align 8
  %v2_8018ab8 = inttoptr i32 %v1_8018ab8 to i32*
  store i32 %v1_8018ab8, i32* %v2_8018ab8, align 4
......
._crit_edge:                                      ; preds = %bb4, %bb5
  ret i32 %v1_8018ac4
}


define i32 @function_8018ac8(i32 %arg1, i32 %arg2, i32 %arg3, i32 %arg4) {
dec_label_pc_8018ac8:
  store i32 %arg4, i32* @r3, align 4
.......
}


define i32 @function_8018b20() {
dec_label_pc_8018b20:
  store i32 134318884, i
..........
}


define i32 @function_8018b2a(i32 %arg1, i32 %arg2, i32 %arg3, i32 %arg4) {
dec_label_pc_8018b2a:
  %cpsr_c.global-to-local = alloca i1, align 1
......
}
........................................
```

**Why I wanted to use "--config" option:**
I found that the json file generated by retdec was not very accurate, e.g. some functions' start/end address and some globals are misidentified. Thus, I modified the json file to make it consistent with the binary. In this case, I must use "--config" to let retdec use the my modified more accurate json file.

**My attempts:**
I tried to hard code the json file path in **retdec-decompiler.py** and **retdec-color-c.py** in various ways , but none of them worked.

Any thoughts/help would be appreciated!
Hi
I tested retdec on the test:
Original C file:
```C++
$ cat test.c 
struct A{
	int arr[2];
};
void test_fn(struct A * p){
	p->arr[0] = 0;
```
I translate to LLVM IR code
```llvm
clang -S -emit-llvm test.c -o test.ll && cat test.ll

; ModuleID = 'test.c'
source_filename = "test.c"
...
%struct.A = type { [2 x i32] }

; Function Attrs: noinline nounwind optnone uwtable
define void @test_fn(%struct.A*) #0 {
  %2 = alloca %struct.A*, align 8
  store %struct.A* %0, %struct.A** %2, align 8
  %3 = load %struct.A*, %struct.A** %2, align 8
  %4 = getelementptr inbounds %struct.A, %struct.A* %3, i32 0, i32 0
  %5 = getelementptr inbounds [2 x i32], [2 x i32]* %4, i64 0, i64 0
  store i32 0, i32* %5, align 4
  ret void
}
```
Then i applied llvmir2hlltool:
```C++
$ retdec-llvmir2hll -o test.retdec.c -target-hll=c test.ll ; cat test.retdec.c 
//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2019 Retargetable Decompiler <info@retdec.com>
//
#include <stdint.h>
// ------------------------ Structures ------------------------
struct struct_A {
    int32_t e0[2];
};
// ------------------- Function Prototypes --------------------
void test_fn(struct struct_A * a1);
// ------------------------ Functions -------------------------
void test_fn(struct struct_A * a1) {
    (&a1->e0)[0] = 0; // <--- error 
}
```
line `(&a1->e0)[0] = 0;` has error 
operator **&** is extra ~~or operator **->** is wrong which need to replace on operator **.**~~ (sorry, i was wrong)
I experimented with RetDec and a simple C program. I compiled the program with **clang** (Apple clang version 11.0.0 (clang-1100.0.33.8)) on macOS 10.14.
The program contains a simple **switch-case statement** which is compiled to a **lookup table and lookup + indirect branching assembly code**.
When decompiling the code, **the switch-cases are missing in the recovered LLVM IR code**. I tried disabling all of the optimization passes used in `bin2llvmir`. It turns out that the **indirect branch instruction is not correctly reconstructed** and therefore the switch-cases are unreachable blocks of code (removed by optimizations). 
The problem is unaffected by the optimization level (`-O0` or `-O2`) used for compilation.

The C program in question:
```C
#include <stdio.h>
int main() {
    char operator;
    int n1, n2;
    printf("Enter an operator (+, -, *, /): ");
    scanf("%c", &operator);
    printf("Enter two operands: ");
    scanf("%d %d",&n1, &n2);
    switch(operator)
    {
        case '+':
            printf("%d + %d = %d",n1, n2, n1+n2);
            break;
        case '-':
            printf("%d - %d = %d",n1, n2, n1-n2);
            break;
        case '*':
            printf("%d * %d = %d",n1, n2, n1*n2);
            break;
        case '/':
            printf("%d / %d = %d",n1, n2, n1/n2);
            break;
        // operator doesn't match any case constant +, -, *, /
        default:
            printf("Error! operator is not correct");
    }
    return 0;
}
```

The correctly disassembled switch-statement in IDA:
![image](https://user-images.githubusercontent.com/1275898/66997419-b57a4b80-f0d2-11e9-9643-1c54e5491683.png)

And the incorrectly reconstructed LLVM IR code from RetDec (before RetDec optimization passes):
![image](https://user-images.githubusercontent.com/1275898/66997750-59fc8d80-f0d3-11e9-8626-7342a15e35e8.png)

Consecutively, the optimized IR code is missing large parts of the program, same for the reconstructed C program. If I can help with this issue any further by providing binaries or anything else, let me know. 

I decompiled this function using the latest retdec from Oct 16 on Linux:
```
0000000000000000 <func1643>:
   0:	48 89 f8             	mov    %rdi,%rax
   3:	c1 e8 1f             	shr    $0x1f,%eax
   6:	c3                   	retq   
```
the result is:
```
define i64 @func1643(i64 %arg1) local_unnamed_addr {
dec_label_pc_0:
  %tmp7 = icmp slt i64 %arg1, 0
  %v3_3 = zext i1 %tmp7 to i64
  ret i64 %v3_3
}
```
but these functions don't return the same thing when the argument is 0x80000000LL: the object code returns 1 and the decompiled code returns 0.
I try to decompile the full source, 
each process return output will have Warning: out of memory; trying to recover

but
```
 -> running CArrayArgOptimizer ( 104.87s )
Running phase: variable renaming [readable] ( 105.07s )
LLVM ERROR: Could not acquire a cryptographic context: The specified procedure could not be found.  (0x7F)
Error: Decompilation of file D:\NNN.bc failed
```

here is the file sample:
https://drive.google.com/open?id=1pPbk0nE9qrk4EnwCeo7vXKeV5kxMkkhw

This project is the best ever project existed in mankind. I feel thankful to these amazing contributors and the coder(s). I salute.
I wanted to compile to try debugging but I am stuck in LLVM\ something .h missing. 
Also when I use release version of March built 0x7F is identified ^look above

edit: when I use latest commit built using windows server, this is the error output
```
LLVM ERROR: out of memory
0x00007FF7339C2935 (0x0000000000000001 0x0000000000000040 0x000000952FFFDF40 0x00007FF847D5BF01) <unknown module>
0x00007FF847DBDB77 (0x0000000000000040 0x000000952FFFDF40 0x00007FF847D5BF01 0x0000001B00000008) <unknown module>
0x0000000000000001 (0x000000952FFFDF40 0x00007FF847D5BF01 0x0000001B00000008 0x0000000000000000) <unknown module>
0x0000000000000040 (0x00007FF847D5BF01 0x0000001B00000008 0x0000000000000000 0x0000001B00000000) <unknown module>
0x000000952FFFDF40 (0x0000001B00000008 0x0000000000000000 0x0000001B00000000 0x0000000000000001) <unknown module>
0x00007FF847D5BF01 (0x0000000000000000 0x0000001B00000000 0x0000000000000001 0x0000000000000000) <unknown module>
0x0000001B00000008 (0x0000001B00000000 0x0000000000000001 0x0000000000000000 0x0000026F59A88F40) <unknown module>
Error: Decompilation of file D:\NNN.bc failed
 ```
Dear, RetDec developers.

I really appreciate that you make this tool.
But, I found some problems. I am not sure whether this is ARM's THUMB architecture specific.

Based on my guess, the problem is that some functions are not lifted into LLVM.
This function is "not explicitly" called by other function because it is run by "pthread_create".
However, this is not a standard pthread create. That means that my target binary running on the embedded device w/ RTOS (RIOT) - not Linux.
Therefore, pthead_create is included in the binary codes as a normal function.

Specifically, the problem is that.
1) This function is not called by the other functions. That's why I think RetDec didn't lift it.

2) Also, when this function's pointer value is passed into an argument to "pthread_create". This function pointer value should be "actual function pointer value + 1". 
When a function is executed with ARM's Thumb mode, its pointer value must be +1; otherwise, that function will be executed in the ARM's "ARM mode".  (I strongly believe you know ARM architecture supports both ARM and Thumb modes which is the unique ARM scheme. But, I put this description just in case.)

3) As I mentioned, my target firmware is not an application binary for Linux. It is a bare-metal firmware including RTOS (+ pthread related functions). 
That's why pthread functions are considered as a just normal function.
Then, RetDec may not take special processing to pthread functions I guess


In this context, could you help me to solve this problem?
Even if that is not possible (at least very soon), is there a way to "forcibly" convert such "unlifted" functions?
I think the fundamental reason why that function is not lifted is related to optimization.
For example, I guess that function is considered as garbage since it is not called by any other functions during some analysis (e.g., a sort of points-to analysis I guess...?)
If that is possible, I am fine with it at this time since I need to emergently solve this problem.

Or at this time, I can assume my firmware has a symbol against the target unlifted function temporarily.

Thank you for your help :) 

PS. the converted "pthread_create" call looks like this 
  %v9_80015a4 = call i32 @pthread_create(i32* nonnull %th_id1_-44, i32 %v2_8001596, i8* (i8*)* inttoptr (i32 134222901 to i8* (i8*)*), i8* null)

i8* (i8*)* inttoptr (i32 134222901 to i8* (i8*)*) -> this was originally a function pointer to thread handler function. But, since the last bit is set (13422290"1"), it was not recognized as a function pointer maybe....

I'm trying to get a feel for how retdec works but am unable to successfully de-compile a GCC compiled shared object file and re-compile the object file with Clang.

I'm using Debian and the retdec-v3.3 pre-built debian binary.

Here is `test.c`:
```c
#include <stdio.h>

void print_hello(void);

int main()
{
      print_hello();
}
```

Here is `shared.c`:
```c
#include <stdio.h>

void print_hello(void) {
      printf("\n\nShared Hello World!\n\n");
}
```

Here is what I am doing:
```bash
# Compile `test.c` to LLVM bitcode
clang test.c -emit-llvm -c -o test.bc

# Compile `shared.c` to x86-64 ELF file
gcc -shared shared.c -o shared

# De-compiles `shared` to `shared.bc`
/opt/retdec/bin/retdec-decompiler.py shared
```

Everything above seems to work great. Now I try to produce a final output binary using the bitcode files:

```bash
clang-10 test.bc shared.bc -o test
```

This fails with:
```
warning: overriding the module target triple with x86_64-unknown-linux-gnu [-Woverride-module]
1 warning generated.
/usr/bin/ld: /tmp/shared-e43926.o: in function `_fini':
test:(.text+0x140): multiple definition of `_fini'; /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o:(.fini+0x0): first defined here
/usr/bin/ld: /tmp/shared-e43926.o: in function `_init':
test:(.text+0x0): multiple definition of `_init'; /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o:(.init+0x0): first defined here
/usr/bin/ld: /usr/lib/gcc/x86_64-linux-gnu/8/../../../x86_64-linux-gnu/crti.o: in function `_init':
(.init+0x7): undefined reference to `__gmon_start__'
/usr/bin/ld: /tmp/shared-e43926.o: in function `_init':
test:(.text+0x19): undefined reference to `__gmon_start__'
/usr/bin/ld: test:(.text+0x1f): undefined reference to `__unnamed_1'
/usr/bin/ld: /tmp/shared-e43926.o: in function `__do_global_dtors_aux':
test:(.text+0xcc): undefined reference to `__unnamed_1'
clang-10: error: linker command failed with exit code 1 (use -v to see invocation)
```

Am I doing something wrong? What could I do to make this simple example work?
I am testing retdec on Juliet 1.3 Test Suite Dataset

when i apply retdec-decompile to binary, the result is quite different as i expect.
I upload binary and c source code in my repositoy
https://github.com/leepeter2019/test

binary file is "CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01.out"
i build c source code with linux gcc compiler

original file is "CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01.c"
translated file is "CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01_retdec.c"

the function is interested in is 
`
void CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01_bad()
{
    int * data;
    data = (int *)ALLOCA(10*sizeof(int));
    /* POTENTIAL FLAW: Don't initialize data */
    ; /* empty statement needed for some flow variants */
    /* POTENTIAL FLAW: Use data without initializing it */
    {
        int i;
        for(i=0; i<10; i++)
        {
            printIntLine(data[i]);
        }
    }
}
`

the result of retdec is 
`// From module:   /home/vmware/test/Juliet_Test_Suite_v1.3_for_C_Cpp/testcases/CWE457_Use_of_Uninitialized_Variable/CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01.c
// Address range: 0x804893b - 0x80489ba
// Line range:    22 - 36
void CWE457_Use_of_Uninitialized_Variable__int_array_alloca_no_init_01_bad(void) {
    int32_t v1 = __readgsdword(20); // 0x8048941
    int32_t v2 = g2 - 64; // 0x8048990
    for (int32_t i = 0; i < 10; i++) {
        // 0x804897f
        *(int32_t *)(v2 - 16) = *(int32_t *)(4 * i + (g2 - 49 & -16));
        printIntLine(i);
        v2 = g2 + 16;
    }
    // 0x80489a6
    if (__readgsdword(20) != v1) {
        // 0x80489b3
        __stack_chk_fail();
    }
}`

Can you explain why the result on 'printIntLine(i)' is different original 'printIntLine(data[i])'?

I have another question.
When I apply retdec-decompiler, it shows which options they use for fileinfo and bin2IR. But the IR and C result is different from 'using retdec-decompiler' and 'using retdec-fileinfo and retdec-bin2llvmir with same options as retdec-decompiler'. Can you explain why the result of using directly retdec-decomipler and the result of using retdec-fileinfo, retdec-bin2llvmir and retdec-llvmir2hll as sequence' 

Thanks