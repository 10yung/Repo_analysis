While reading file from a network drive we are getting below error.

**short read in readEvents on** 
what changes needs to be done on networkDrive permission to get rid of this issue?
it is working fine with windows inbuild drive (i.e. C: / D: )


My Code is as follows.

```
package main

import (
	"fmt"
	"log"
	"os"
	"time"

	"github.com/howeyc/fsnotify"
)

func main() {
	fmt.Println("hello world")
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}

	go func() {
		for {
			select {
			case ev := <-watcher.Event:
				log.Println("Custom:", ev)
				log.Println("event:", ev)
			case err := <-watcher.Error:
				log.Println("error:", err)
			}
		}
	}()

	err = watcher.Watch(os.Args[1])
	if err != nil {
		log.Fatal(err)

	}

	time.Sleep(2 * time.Hour)
}
```

Every exported function in a program should have a doc comment. The first sentence should be a summary that starts with the name being declared.
From [effective go](https://golang.org/doc/effective_go.html#commentary).


PR generated by [CodeLingo](https://codelingo.io). [Install here](https://github.com/apps/codelingo) to drive Continuous Higher Standards.

I found out that I can not add watch, so I modified it to public, can be merge?
```
watcher, err := fsnotify.NewWatcher()
...
watcher.AddWatch("/tmp/mydir", flags)
```
Hi,

What are the build instructions to build  fsnotify. Also trying to add s390x support,but can't find any build file to build the code.


Hi,

I was referring to the below example to get used to this module as I need to watch a repo file and based on events I need to perform certain actions:

Issue:
 For testing, I am watching one file "/home/ankit/delta.txt". 

The problem is that I receive events only first time if any modification is done to the file /home/ankit/delta.txt but after that I never receive any events, even If I access/remove/modify this file?

Output of my implementation:
2017/06/27 12:02:49 event: "/home/ankit/delta.txt": RENAME
2017/06/27 12:02:49 event: "/home/ankit/delta.txt": MODIFY|ATTRIB
2017/06/27 12:02:49 event: "/home/ankit/delta.txt": DELETE

My OS Details:
DISTRIB_ID=Ubuntu
DISTRIB_RELEASE=14.04
DISTRIB_CODENAME=trusty
DISTRIB_DESCRIPTION="Ubuntu 14.04.5 LTS"

************************************************************************
package main

import (
	"log"

	"github.com/howeyc/fsnotify"
)

func main() {
	watcher, err := fsnotify.NewWatcher()
	if err != nil {
		log.Fatal(err)
	}

	done := make(chan bool)

	// Process events
	go func() {
		for {
			select {
			case ev := <-watcher.Event:
				log.Println("event:", ev)
			case err := <-watcher.Error:
				log.Println("error:", err)
			}
		}
	}()

	err = watcher.Watch("/home/ankit/delta.txt")
	if err != nil {
		log.Fatal(err)
	}
	
	// Hang so program doesn't exit
	<-done

	/* ... do stuff ... */
	watcher.Close()
}
************************************************************************
Hi,

What I encounter is, the watcher can detect event in a directory when files are copied, written, deleted, or edited one by one in the folder. But when when I tried to paste multiple files all together in one command into the folder. The watcher is most likely to only detect one file and ignore the rest of the other files that was copied to the folder.

Any solution to this issue? Will greatly appreciate your help.

Thanks.
OS:window7
folder 
create:
"D:\test\新建文件夹": CREATE
rename
2015/11/24 15:02:39 event: "D:\test\新建文件夹": RENAME
2015/11/24 15:02:39 event: "D:\test\test": RENAME

delete
2015/11/24 15:03:12 event: "D:\test\test": DELETE
MODIFY
2015/11/24 15:04:37 event: "D:\test\ww": MODIFY

file
create
2015/11/24 15:05:33 event: "D:\test\新建文本文档.txt": CREATE
rename
2015/11/24 15:05:52 event: "D:\test\新建文本文档.txt": RENAME
2015/11/24 15:05:52 event: "D:\test\test.txt": RENAME
2015/11/24 15:05:52 event: "D:\test\test.txt": MODIFY
why print MODIFY?
MODIFY
2015/11/24 15:06:14 event: "D:\test\test.txt": MODIFY
2015/11/24 15:06:14 event: "D:\test\test.txt": MODIFY
2015/11/24 15:06:14 event: "D:\test\test.txt": MODIFY
why this line run 3times?
delete
2015/11/24 15:08:15 event: "D:\test\test.txt": DELETE

OS:centos
folder 
create:
2015/11/24 15:11:52 event: "/root/桌面/test/untitled folder": CREATE
rename
2015/11/24 15:12:23 event: "/root/桌面/test/untitled folder": RENAME
2015/11/24 15:12:23 event: "/root/桌面/test/test": CREATE
delete
2015/11/24 15:17:18 event: "/root/桌面/test/test": RENAME
MODIFY
nothing

file
create
2015/11/24 15:20:10 event: "/root/桌面/test/new file": CREATE
rename
2015/11/24 15:20:31 event: "/root/桌面/test/new file": RENAME
2015/11/24 15:20:31 event: "/root/桌面/test/test": CREATE
MODIFY
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": CREATE
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY|ATTRIB
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY|ATTRIB
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY|ATTRIB
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": MODIFY
2015/11/24 15:20:58 event: "/root/桌面/test/test": RENAME                //rename
2015/11/24 15:20:58 event: "/root/桌面/test/.gedit-save-D5SP8X": RENAME
2015/11/24 15:20:58 event: "/root/桌面/test/test": CREATE
2015/11/24 15:20:58 event: "/root/桌面/test/test~": DELETE
About file test  only 2 lines but it's rename and create 
delete
2015/11/24 15:29:53 event: "/root/桌面/test/test": RENAME

func main() {
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        log.Fatal(err)
    }

```
done := make(chan bool)

// Process events
go func() {
    for {
        select {
        case ev := <-watcher.Event:
            log.Println("event:", ev)
            if ev.IsModify() {
                log.Println("xxxxxxxxxxxx")
            }
        case err := <-watcher.Error:
            log.Println("error:", err)
        }
    }
}()

err = watcher.Watch("/root/桌面/test")
//err = watcher.Watch("/hard/psq")
if err != nil {
    log.Fatal(err)
}

// Hang so program doesn't exit
<-done

//select{}

/* ... do stuff ... */
watcher.Close()
```

}

if i watch a file ,
package main

import (
    "log"
    //"fmt"
    "github.com/howeyc/fsnotify"
)

func test(){
    log.Println("test")
}

func main() {
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        log.Fatal(err)
    }

```
done := make(chan bool)

// Process events
go func() {
    for {
        select {
        case ev := <-watcher.Event:
            //log.Println("event:", ev)
            if ev.IsModify() {
                log.Println("xxxxxxxxxxxx")
            }
            //test()
        case err := <-watcher.Error:
            log.Println("error:", err)
        }
    }
}()

err = watcher.Watch("/root/桌面/test/test.txt")
//err = watcher.Watch("/hard/psq")
if err != nil {
    log.Fatal(err)
}

// Hang so program doesn't exit
<-done

//select{}

/* ... do stuff ... */
watcher.Close()
```

}
when i MODIFY the file  test.txt it's only print in the first time . in windows it's print 3times

An fd-per-watch quickly consumes more file descriptors than are allowed. Would you accept a patch that uses a single inotify instance and multiple watchers? This appears to be the [approach recommended by the Linux kernel docs](https://github.com/torvalds/linux/blob/164c09978cebebd8b5fc198e9243777dbaecdfa0/Documentation/filesystems/inotify.txt#L221-L223).

Hi. 
go version go1.3.1 linux/amd64 

I runed 2 containers: 
1) with application source code in volume. 
2) with daemon (https://github.com/beego/bee) which listen changes of files in volumes (--volumes-from app_container) 

in volumes (folder mounted by NFS), your library can see when i change files inside container, but when i change it from outside - no notifications.

I found out in https://docs.google.com/document/d/1xl_aRcCbksFRmCKtoyRQG9L7j6DIdMZtrkFAoi5EXaA/edit
that this problem with NFS is known, but "It is unclear how important that case is"

Suggest me please: Must i create ticket about it in Go bug tracker? 

```
package main

import (
    // "bytes"
    "fmt"
    "github.com/howeyc/fsnotify"
    "log"
    //"os/exec"
    //"strings"
)

func main() {
    watcher, err := fsnotify.NewWatcher()
    if err != nil {
        log.Fatal(err)
    }

    done := make(chan bool)

    // Process events
    go func() {
        for {
            select {

                        //  it is called twice when one file is modified in windows !!
            case ev := <-watcher.Event:
                        fmt.Println(ev)
            case err := <-watcher.Error:
                log.Println("error:", err)
            }
        }
    }()

    err = watcher.Watch("c:\\test")
    if err != nil {
        log.Fatal("not exists")

    }
    <-done

    watcher.Close()
}
```
