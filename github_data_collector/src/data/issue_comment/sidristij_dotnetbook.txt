Добрый вечер, Станислав.

https://github.com/sidristij/dotnetbook/blob/master/book/ru/Memory/01-02-MemoryManagement-Basics.md

Из главы книги по ссылке выше:

> 
> Как они хранятся? Если строка интернирована, то она хранится как обычная строка в куче. Но ее надо как-то найти, чтобы проверить, что точно такая же строка уже существует. Куча иногда может достигать нескольких сотен гигабайт и поиск будет очень дорогим решением. Поэтому интернированные строки хранятся отдельно (предполагается, что их будет не так много).
> 
> У каждого домена при этом (системного или с базовым типом BaseDomain) есть внутренние таблицы, которая нам не доступны. Среди прочих существует Large Heap Handle Table. Существует два типа внутренних массивов, основанных на bucket-ах. Это массив статиков. Имеются ввиду статические члены классов, которые хранятся в массивах. У каждого домена есть ссылка на массив статиков. И дальше ячейками являются ссылки на значения. И еще одна - pinning handles. Это таблица запиненных элементов. Для тех случаев, когда вы пинуете объект в памяти, можете сделать это двумя путями. Первый - это через API, а второй - через ключевое слово fixed в C#. Это два совершенно разных механизма.

Не совсем понятен ход мысли, поскольку до этого момента всё более менее плавно шло, а потом довольно резкий переход к доменам. Создается ощущение. что по поводу строк еще не договорили, а к доменам еще не подвели.
Здравствуйте! Вы не думали задействовать https://www.gitbook.com/, чтобы сделать книгу доступной на читалках?
Здравствуйте, Станислав!
Читаю вашу статью:
[habr.com/ru/company/clrium/blog/464169](http://habr.com/ru/company/clrium/blog/464169)
Есть несколько замечаний:

1. «мы пляшем от корней, уходя вглубь графа через исходящие поля объекта» — тяжелая для восприятия фраза. Так и не понял, что она значит.
2. «Указатель + размер против SyncBlockIndex + VMT + какое-либо поле — в случае объекта)». Что такое SyncBlockIndex, VMT? В статье ни слова — если это есть в книге в предыдущих главах, то вопрос снимается, но все же хотелось расшифровки аббревиатур.
3. «объекты будут случайно проваливаться в старшее поколение (если GC сработал „прям вот сейчас, во время яростного выделения памяти под множество объектов“).» Не совсем понятен процесс «проваливания». В целом это относится ко всему абзацу.
4. Хотелось бы увидеть картинки. С ними восприятие улучшилось бы.
P.S. Я плохо знаю основы работы с GC, но статья в некотором роде приоткрыла завесу. Большое спасибо. Если хотите, то могу посидеть(углубится в тему в т.ч. в другие источники) и более детально помочь проработать статью, чтобы она стала более доступной для понимания.


[MemorySpan.md](https://github.com/sidristij/dotnetbook/blob/master/book/ru/MemorySpan.md) mentions that `stackalloc` requires type to be value type: «Однако, конечно, TType должен быть только значимым типом, т.к. `stackalloc` работает только со значимыми типами.»

But this is not enough; `TType` has to be _unmanaged_ type. For example, `ArraySegment<int>` is value type, but at the same time it is also _managed_ type (since it contains reference):
```cs
Span<ArraySegment<int>> bad = stackalloc ArraySegment<int>[count];
```

> Error CS0208: Cannot take the address of, get the size of, or declare a pointer to a managed type ('ArraySegment<int>')

As of March 22, 2019, the book content isn't available at https://clrbook.com/ probably due to Github Pages misconfiguration.


[Глава Exceptional Flow: Types](https://github.com/sidristij/dotnetbook/blob/master/ru/ExceptionalFlow/4-Exceptions-Types.md)