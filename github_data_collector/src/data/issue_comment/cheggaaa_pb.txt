I want to add the break line between prefix and the progress bar
```[1/3]Prefix [2/3]#####################################################--------------------------------------------------------------------------------------------21/58```

to be like this:
```
[1/3]Prefix 
[2/3]#####################################################--------------------------------------------------------------------------------------------21/58
```

my code:
```go
bar.Prefix(fmt.Sprintf("[1/3] Prefix)) // add \n after this won't work
bar.Increment()
bar.BarEnd = fmt.Sprintf(
 "%v/%v",
 bar.Get(),
 len(total),
                  )
```

Many thanks!!
I use to import this package from `gopkg.in` but, checking on the site the `v3` is supported but if I try to update keeping `gopkg.in` I got this nice error:

```
Command failed: go get -d ./...
go: finding gopkg.in/cheggaaa/pb.v3 v3.0.1
go: gopkg.in/cheggaaa/pb.v3@v3.0.1: go.mod has non-....v3 module path "github.com/cheggaaa/pb" at revision v3.0.1
go: error loading module requirements
```

There are some way to keep using gopkg?
Hey there :wave: I know that pb does not have any support for parallel exectuion, but when running two dedicated applications in parallel the ioctl on `/dev/tty`

https://github.com/cheggaaa/pb/blob/f907f6f5dd81f77c2bbc1cde92e4c5a04720cb11/pb_x.go#L77

blocks which cause that they will never finish. So when running this with a simple `go run main.go` works fine:

```go
package main

import (
	"github.com/cheggaaa/pb"
)

func main() {
	pool := pb.NewPool(&pb.ProgressBar{})

	if err := pool.Start(); err != nil {
		return
	}

	if err := pool.Stop(); err != nil {
		return
	}
}
```

But running this application in parallel blocks and will never finish, which should happen because both processes sharing the same `/dev/tty`:

```
> echo go run main.go > commands
> echo go run main.go >> commands
> parallel < commands
[wait]
```
I think this issue could be fixed with some system wide mutex but I'm not sure if this is a nice solution. :-/
When there is too many of bars, the entire page re-renders at each interval, which causes lagging and stuttering in the terminal screen. I am looking for a hack to stop the rendering of completed bars.
Every exported function in a program should have a doc comment. The first sentence should be a summary that starts with the name being declared.
From [effective go](https://golang.org/doc/effective_go.html#commentary).


PR generated by [CodeLingo](https://codelingo.io). [Install here](https://github.com/apps/codelingo) to drive Continuous Higher Standards.

I'm using v1 and it's pretty OK when I have up to 25-30 progress bars running concurrently.

However, when it reachs 100, the output starts stuttering, and instead of overriding the current bars it simply prints new lines. What's happening doesn't look deterministic.

I'm working on a concurrent file downloader application, which simply requests chunks via byte serving. And each concurrent unit is tasked to download 50MiB. So if the target file is 5010MiB, there will be 101 progress bars -- 50MiB for first 100, 10MiB for the last chunk. There is also a semaphore limiting the max concurrent workers to 20.

[![asciicast](https://asciinema.org/a/QR0zGXifHUmBXi3DVmo8du2tQ.svg)](https://asciinema.org/a/QR0zGXifHUmBXi3DVmo8du2tQ)

Here is the func main:
```go
func main() {
	fid := uuid.NewV4().String()

	h1, err := http.Head(link)
	if err != nil {
		panic(err)
	}
	defer h1.Body.Close()

	if h1.StatusCode != http.StatusOK {
		panic("Head request did not return with 200?")
	}

	if h1.ContentLength == -1 {
		panic("Content-Length is -1. We don't welcome this. This may mean that content is served in chunks and length is unknown.")
	} else if h1.ContentLength < 100*1024*1024 {
		panic("This content is smaller than 100MiB.") // won't do files smaller than 100mib.
	}

	if acceptRanges := h1.Header.Get("Accept-Ranges"); acceptRanges != "bytes" {
		panic("Accept-Ranges header is not bytes. Why? Byte serving may not be available?")
	}

	var bars []*pb.ProgressBar
	chunks := findChunks(int(h1.ContentLength), bufSize)
	concurrency := len(chunks)

	for k, v := range chunks {
		b1 := pb.New(v.bufsize).
			Prefix("[" + strconv.Itoa(k) + "]:").
			SetUnits(pb.U_BYTES)

		bars = append(bars, b1)
	}

	pool, err := pb.StartPool(bars...)
	if err != nil {
		panic(err)
	}

	ch := make(chan string, concurrency)
	sem := make(chan struct{}, 20)
	wg := new(sync.WaitGroup)

	for i := 0; i < concurrency; i++ {
		wg.Add(1)

		sem <- struct{}{}

		go func(i int) {
			defer func() {
				<-sem
				wg.Done()
			}()

			chunk := chunks[i]
			bar := bars[i]
			defer bar.Finish()

			startRange := chunk.offset + 1
			if i == 0 {
				// if this is the first part of the demanded content,
				// the range start must be 0.
				startRange = 0
			}

			// Demanding partial content from upstream provider.
			var r1 *http.Response
			{
				// req, _ := http.NewRequest("GET", link, nil)
				req, _ := http.NewRequest("GET", h1.Request.URL.String(), nil)
				req.Header.Set("Range", fmt.Sprintf(
					"bytes=%d-%d",
					startRange,
					chunk.offset+chunk.bufsize,
				))

				r1, err = http.DefaultClient.Do(req)
				if err != nil {
					panic(err)
				}
				defer r1.Body.Close()

				if r1.StatusCode != http.StatusPartialContent {
					panic(fmt.Errorf("wasn't status code supposed to be 206? but it was %v", r1.Status))
				}
			}

			r1.Body = bar.NewProxyReader(r1.Body)

			// Left-padding the number of chunks with zeros so that
			// they can be lexicographically ordered.
			padCount := len(strconv.Itoa(concurrency)) + 1

			// Retrieving Swift authentication details using long-lived Bearer token.
			cnf, home := getSwiftConf()
			home += "/" + fid
			home += "/" + fmt.Sprintf("%0*d", padCount, i)

			// Uploading the chunk to Swift.
			{
				req, _ := http.NewRequest("PUT", home, r1.Body)
				req.Header.Set("X-Auth-Token", cnf.Token)

				r2, err := http.DefaultClient.Do(req)
				if err != nil {
					panic(err)
				}
				defer r2.Body.Close()
			}

			ch <- home
		}(i)
	}

	wg.Wait()
	pool.Stop()

	close(ch)

	for v := range ch {
		fmt.Println(v)
	}

	fmt.Println("\ndone.")
}
```
Hello ! I created a quick project which takes avantage of pb's quick and easy to use API.
It can be found [here](https://github.com/jesuiscamille/gopexels).

I was thinking you could create a list of projects that use your library, as in [goinsta's README](https://github.com/ahmdrz/goinsta#projects-using-goinsta)...
Just a suggestion though ðŸ˜ƒ !

Have a good day (or night, depends on your timezone ðŸ˜„) !
`pb.StartPool` failed...
It's seem to be that `Finish` method doing all magic in goroutine. So when it's finished it doesn't mean exactly that printing is finished too. For example

```
wg.Wait()
bar.Finish()

println("Done")
println("Checked: N")
println("Completed: N")
```

Sometimes it works exactly like expected
```
 10000 / 10000 [======================] 100.00% 2s
Done
Checked: N
Completed: N
```

Sometimes it's not
```
 9164 / 10000 [=======================>--]  91.64%Done
Checked: N
Completed: N
 10000 / 10000 [======================] 100.00% 2s
```
How to reproduce:
```go
bar := pb.New(1000)
bar.Output = os.Stderr
bar.Start()
```
Run with:
```shell
myprogram > output
```

Expected:
Progress bar is drawn because output goes to Stderr and Stderr is a terminal.

Actual:
No progress bar is drawn, only counters and percentage is shown.