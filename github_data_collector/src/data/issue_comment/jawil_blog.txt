

我们的项目是通过pm2来部署的一个nodejs应用。
最近发现，我们更新完应用文件，然后restart对应pm2应用之后，更新的内容未生效，还是原来的内容，这是pm2的缓存么，只有把pm2进程杀掉，然后重新部署才生效。求大神指点
### 起始
同许多初学 `Javascript` 的菜鸟一样，起初，我也是采用拼接字符串的形式，将 `JSON` 数据嵌入 `HTML` 中。开始时代码量较少，暂时还可以接受。但当页面结构复杂起来后，其弱点开始变得无法忍受起来：

* 书写不连贯。每写一个变量就要断一下，插入一个 + 和 "。十分容易出错。
* 无法重用。`HTML` 片段都是离散化的数据，难以对其中重复的部分进行提取。
* 无法很好地利用 [`<template>`](http://www.zhangxinxu.com/wordpress/2014/07/hello-html5-template-tag/) 标签。这是 `HTML5` 中新增的一个标签，标准极力推荐将 `HTML` 模板放入 [`<template>`](http://www.zhangxinxu.com/wordpress/2014/07/hello-html5-template-tag/)  标签中，使代码更简洁。

当时我的心情就是这样的：
这TMD是在逗我吗。

于是出来了后来的 `ES6`，[ES6的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)用起来着实方便，对于比较老的项目，项目没`webpack`，`gulp` 等构建工具，无法使用 `ES6` 的语法，但是想也借鉴这种优秀的处理字符串拼接的方式，我们不妨可以试着自己写一个，主要是思路，可以使用 `ES6` 语法模拟 [ES6的模板字符串](http://es6.ruanyifeng.com/#docs/string#%E6%A8%A1%E6%9D%BF%E5%AD%97%E7%AC%A6%E4%B8%B2)的这个功能。

后端返回的一般都是 [`JSON`](http://www.json.org/json-zh.html) 的数据格式，所以我们按照下面的规则进行模拟。

### 需求描述
>实现一个 render(template, context) 方法，将 template 中的占位符用 context 填充。

### 要求：
>不需要有控制流成分（如 循环、条件 等等），只要有变量替换功能即可
>级联的变量也可以展开
>被转义的的分隔符 { 和 } 不应该被渲染，分隔符与变量之间允许有空白字符

```js
var obj = {name:"二月",age:"15"};
var str = "{{name}}很厉害，才{{age}}岁";
输出：二月很厉害，才15岁。
```
**PS：本文需要对[正则表达式](https://github.com/jawil/blog/issues/20)有一定的了解，如果还不了解[正则表达式](https://github.com/jawil/blog/issues/20)，建议先去学习一下，正则也是面试笔试必备的技能，上面链接末尾有不少正则学习的链接。**

**如果是你，你会怎么实现？可以先尝试自己写写，实现也不难。**

先不说我的实现，我把这个题给其他好友做的时候，实现的不尽相同，我们先看几位童鞋的实现，然后在他们的基础上找到常见的误区以及实现不够优雅的地方。

### 二月童鞋：

```js
let str = "{{name}}很厉害，才{{age}}岁"
let obj = {name: '二月', age: 15}
function test(str, obj){
    let _s = str.replace(/\{\{(\w+)\}\}/g, '$1')
    let result
    for(let k in obj) {
      _s = _s.replace(new RegExp(k, 'g'), obj[k])
    }
  return _s
}
const s = test(str, obj)
```
最基本的是实现了，但是代码还是有很多问题没考虑到，首先 Object 的 key 值不一定只是 \w，
还有就是如果字符串是这种的：

```js
let str = "{{name}}很name厉害，才{{age}}岁"`
会输出 ：二月很厉害二月害，才15岁
```
此处你需要了解正则的分组才会明白 `$1` 的含义，错误很明显，把本来就是字符串不要替换的 `name` 也给替换了，从代码我们可以看出二月的思路。

1. 代码的作用目标是 `str`，先用正则匹配出 `{{name}}` 和 `{{age}}`，然后用分组获取括号的 `name`,`age`,最后用 `replace` 方法把 `{{name}}` 和 `{{age}}` 替换成 `name` 和 `age`，最后字符串就成了 **name很name厉害，才age岁**，最后 `for in` 循环的时候才导致一起都被替换掉了。
2. 用 `for in` 循环完全没必要，能不用 `for in` 尽量不要用 `for in`，`for in` 会遍历自身以及原型链所有的属性。

### 志钦童鞋：

```js
var str = "{{name}}很厉害，才{{age}}岁";
var str2 = "{{name}}很厉name害，才{{age}}岁{{name}}";

var obj = {name: '周杰伦', age: 15};
function fun(str, obj) {
    var arr;
    arr = str.match(/{{[a-zA-Z\d]+}}/g);
    for(var i=0;i<arr.length;i++){
        arr[i] = arr[i].replace(/{{|}}/g,'');
        str = str.replace('{{'+arr[i]+'}}',obj[arr[i]]);
    }
    return str;
}
console.log(fun(str,obj));
console.log(fun(str2,obj));
```

思路是正确的，知道最后要替换的是 `{{name}}` 和 `{{age}}` 整体，而不是像二月童鞋那样最后去替换 `name`，所有跑起来肯定没问题，实现是实现了但是感觉有点那个，我们要探讨的是一行代码也就是代码越少越好。

### 小维童鞋：

```js
function a(str, obj) {
  var str1 = str;
  for (var key in obj) {
    var re = new RegExp("{{" + key + "}}", "g");
    str1 = str1.replace(re, obj[key]);
  }
  console.log(str1);
}
const str = "{{name}}很厉name害{{name}}，才{{age}}岁";
const obj = { name: "jawil", age: "15" };
a(str, obj);
```
实现的已经简单明了了，就是把 `obj` 的 `key` 值遍历，然后拼成 `{{key}}`，最后用 `obj[key]` 也就是 `value` 把 `{{key}}` 整个给替换了，思路很好，跟我最初的版本一个样。

### 我的实现：

```js
function parseString(str, obj) {
  Object.keys(obj).forEach(key => {
    str = str.replace(new RegExp(`{{${key}}}`,'g'), obj[key]);
  });
  return str;
}
const str = "{{name}}很厉name害{{name}}，才{{age}}岁";
const obj = { name: "jawil", age: "15" };
console.log(parseString(str, obj));
```
其实这里还是有些问题的，首先我没用 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环就是为了考虑不必要的循环，因为 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环会遍历原型链所有的可枚举属性，造成不必要的循环。

我们可以简单看一个例子，看看 [`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)的可怕性。

```js
// Chrome v63
const div = document.createElement('div');
let m = 0;
for (let k in div) {
  m++;
}
let n = 0;
console.log(m); // 231
console.log(Object.keys(div).length); // 0
```
一个 DOM 节点属性竟然有这么多的属性，列举这个例子只是让大家看到 [`for in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 遍历的效率问题，不要轻易用 [`for in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环，通过这个 `DOM` 节点之多也可以一定程度了解到 `React `的 `Virtual DOM` 的思想和优越性。


除了用 [`for in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环获取 `obj` 的 `key` 值，还可以用 [`Object.key()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys) 获取，[`Object.getOwnPropertyNames()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) 以及 `Reflect.ownKeys()`也可以获取，那么这几种有啥区别呢？这里就简单说一下他们的一些区别。

>[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in)循环：会遍历对象自身的属性，以及原型属性，[`for...in`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in) 循环只遍历可枚举(不包括 [`enumerable`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty)为 `false` )属性。像 `Array` 和 `Object` 使用内置构造函数所创建的对象都会继承自 `Object.prototype` 和 `String.prototype` 的不可枚举属性;
>
>[`Object.key()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys)：可以得到自身可枚举的属性,但得不到原型链上的属性;
>
>[`Object.getOwnPropertyNames()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames)：可以得到自身所有的属性(包括不可枚举),但得不到原型链上的属性, Symbols 属性也得不到.
>
>[`Reflect.ownKeys`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect/ownKeys)：该方法用于返回对象的所有属性，基本等同于 [`Object.getOwnPropertyNames()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyNames) 与 [`Object.getOwnPropertySymbols`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols) 之和。

上面说的可能比较抽象，不够直观。可以看个我写的 `DEMO`，一切简单明鸟。

```js
const parent = {
  a: 1,
  b: 2,
  c: 3
};
const child = {
  d: 4,
  e: 5,
  [Symbol()]: 6
};
child.__proto__ = parent;
Object.defineProperty(child, "d", { enumerable: false });

for (var attr in child) {
  console.log("for...in:", attr);// a,b,c,e
}
console.log("Object.keys:", Object.keys(child));// [ 'e' ]
console.log("Object.getOwnPropertyNames:", Object.getOwnPropertyNames(child)); // [ 'd', 'e' ]
console.log("Reflect.ownKeys:", Reflect.ownKeys(child)); //  [ 'd', 'e', Symbol() ]
```

### 最后实现
上面的实现其实已经很简洁了，但是还是有些不完美的地方，通过 [MDN](https://developer.mozilla.org/zh-CN/) 首先我们先了解一下 [replace](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace) 的用法。

通过文档里面写的 `str.replace(regexp|substr, newSubStr|function)` ，我们可以发现  [replace](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace) 方法可以传入 `function` 回调函数，

`function (replacement)` 一个用来创建新子字符串的函数，该函数的返回值将替换掉第一个参数匹配到的结果。参考这个[指定一个函数作为参数](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/replace#%E6%8C%87%E5%AE%9A%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E4%BD%9C%E4%B8%BA%E5%8F%82%E6%95%B0)。

有了这句话，其实就很好实现了，先看看具体代码再做下一步分析。

```js
function render(template, context) {
  return template.replace(/\{\{(.*?)\}\}/g, (match, key) => context[key]);
}
const template = "{{name}}很厉name害，才{{age}}岁";
const context = { name: "jawil", age: "15" };
console.log(render(template, context));
```
可以对照上面文档的话来做分析：**该函数的返回值(`obj[key]=jawil`)将替换掉第一个参数(`match=={{name}}`)匹配到的结果。**

简单分析一下：`.*?` 是正则固定搭配用法，表示[非贪婪匹配](http://blog.csdn.net/lxcnn/article/details/4756030)模式，尽可能匹配少的，什么意思呢？举个简单的例子。

先看一个例子：

```
源字符串：aa<div>test1</div>bb<div>test2</div>cc

正则表达式一：<div>.*</div>

匹配结果一：<div>test1</div>bb<div>test2</div>

正则表达式二：<div>.*?</div>

匹配结果二：<div>test1</div>（这里指的是一次匹配结果，不使用/g，所以没包括<div>test2</div>）
```
根据上面的例子，从匹配行为上分析一下，什是[贪婪与非贪婪匹配](http://blog.csdn.net/lxcnn/article/details/4756030)模式。

利用[非贪婪匹配](http://blog.csdn.net/lxcnn/article/details/4756030)模就能匹配到所有的`{{name}}`，`{{age}}`，上面的也说到过[正则分组](https://segmentfault.com/a/1190000004429477)，分组匹配到的就是 `name`，也就是 `function` 的第二个参数 `key`。

**所以这行代码的意思就很清楚，正则匹配到`{{name}}`，分组获取 `name`，然后把 `{{name}}` 替换成  `obj[name](jawil)`。**

当然后来发现还有一个小问题，如果有空格的话就会匹配失败，类似这种写法：

```js
const template = "{{name   }}很厉name害，才{{age   }}岁";
```

所以在上面的基础上还要去掉空格，其实也很简单，用正则或者 [`String.prototype.trim()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/String/Trim) 方法都行。

```js
function render(template, context) {
  return template.replace(/\{\{(.*?)\}\}/g, (match, key) => context[key.trim()]);
}
const template = "{{name   }}很厉name害，才{{age   }}岁";
const context = { name: "jawil", age: "15" };
console.log(render(template, context));
```

**将函数挂到 String 的原型链，得到最终版本**

甚至，我们可以通过修改原型链，实现一些很酷的效果：

```js
String.prototype.render = function (context) {
  return this.replace(/\{\{(.*?)\}\}/g, (match, key) => context[key.trim()]);
};
```

如果{}中间不是数字，则{}本身不需要转义，所以最终最简洁的代码：

```js
String.prototype.render = function (context) {
  return this.replace(/{{(.*?)}}/g, (match, key) => context[key.trim()]);
};
```

之后，我们便可以这样调用啦：

```js
"{{name}}很厉name害，才{{ age  }}岁".render({ name: "jawil", age: "15" });
```

### 收获
通过一个小小的模板字符串的实现，领悟到要把一个功能实现不难，要把做到完美真是难上加难，需要对基础掌握牢固，有一定的沉淀，然后不断地打磨才能比较优雅的实现，通过由一个很小的点往往可以拓展出很多的知识点。

### 一张图快速入门正则表达式：
![](https://s3.51cto.com/wyfs02/M01/8E/56/wKioL1i-JzeTfP9EAAOl7gISmj4980.gif)

**有些东西很好用，但是你未必知道；有些东西你可能用过，但是你未必知道原理。**
实现一个目的有多种途径，俗话说，条条大路通罗马。很多内容来自平时的一些收集以及过往博客文章底下的精彩评论，收集整理拓展一波，发散一下大家的思维以及拓展一下知识面。

**茴字有四种写法，233333...， 文末有彩蛋有惊喜。**

### 1、简短优雅地实现 sleep 函数
很多语言都有 `sleep` 函数，显然 `js` 没有，那么如何能简短优雅地实现这个方法？
#### 1.1 普通版
```JavaScript
function sleep(sleepTime) {
	for(var start = +new Date; +new Date - start <= sleepTime;) {}
}
var t1 = +new Date()
sleep(3000)
var t2 = +new Date()
console.log(t2 - t1)
```
优点：简单粗暴，通俗易懂。
缺点：这是最简单粗暴的实现，确实 sleep 了，也确实卡死了，CPU 会飙升，无论你的服务器 CPU 有多么 Niubility。

#### 1.2  Promise 版本
```JavaScript
function sleep(time) {
  return new Promise(resolve => setTimeout(resolve, time))
}

const t1 = +new Date()
sleep(3000).then(() => {
  const t2 = +new Date()
  console.log(t2 - t1)
})
```
优点：这种方式实际上是用了 setTimeout，没有形成进程阻塞，不会造成性能和负载问题。
缺点：虽然不像 callback 套那么多层，但仍不怎么美观，而且当我们需要在某过程中需要停止执行（或者在中途返回了错误的值），还必须得层层判断后跳出，非常麻烦，而且这种异步并不是那么彻底，还是看起来别扭。

#### 1.3 Generator 版本
```JavaScript
function sleep(delay) {
  return function(cb) {
    setTimeout(cb.bind(this), delay)
  };
}

function* genSleep() {
  const t1 = +new Date()
  yield sleep(3000)
  const t2 = +new Date()
  console.log(t2 - t1)
}

async(genSleep)

function async(gen) {
  const iter = gen()
  function nextStep(it) {
    if (it.done) return
    if (typeof it.value === "function") {
      it.value(function(ret) {
        nextStep(iter.next(ret))
      })
    } else {
      nextStep(iter.next(it.value))
    }
  }
  nextStep(iter.next())
}
```

优点：同 Promise 优点，另外代码就变得非常简单干净，没有 then 那么生硬和恶心。
缺点：但不足也很明显，就是每次都要执行 next() 显得很麻烦，虽然有 [**co**](https://github.com/tj/co)（第三方包）可以解决，但就多包了一层，不好看，错误也必须按 [**co**](https://github.com/tj/co) 的逻辑来处理，不爽。

**[**co**](https://github.com/tj/co) 之所以这么火并不是没有原因的，当然不是仅仅实现 `sleep` 这么无聊的事情，而是它活生生的借着`generator/yield` 实现了很类似 `async/await` 的效果！这一点真是让我三观尽毁刮目相看。**

```JavaScript
const co = require("co")
function sleep(delay) {
  return function(cb) {
    setTimeout(cb.bind(this), delay)
  }
}

co(function*() {
  const t1 = +new Date()
  yield sleep(3000)
  const t2 = +new Date()
  console.log(t2 - t1)
})
```

#### 1.4 Async/Await 版本
```JavaScript
function sleep(delay) {
  return new Promise(reslove => {
    setTimeout(reslove, delay)
  })
}

!async function test() {
  const t1 = +new Date()
  await sleep(3000)
  const t2 = +new Date()
  console.log(t2 - t1)
}()
```
优点：同 Promise 和 Generator 优点。 Async/Await 可以看做是 Generator 的语法糖，Async 和 Await 相较于 * 和 yield 更加语义，另外各个函数都是扁平的，不会产生多余的嵌套，代码更加清爽易读。
缺点： ES7 语法存在兼容性问题，有 babel 一切兼容性都不是问题

至于 `Async/Await` 比 `Promise` 和 `Generator` 的好处可以参考这两篇文章：
[Async/Await 比 Generator 的四个改进点](https://juejin.im/post/59f9ce7a51882554f666220f)
 [关于Async/Await替代Promise的6个理由](https://juejin.im/post/58ede4c1b123db43cc365551)

#### 1.5 不要忘了开源的力量
**在 javascript 优雅的写 sleep 等于如何优雅的不优雅，2333**
>这里有 C++ 实现的模块：https://github.com/ErikDubbelboer/node-sleep

```JavaScript
const sleep = require("sleep")

const t1 = +new Date()
sleep.msleep(3000)
const t2 = +new Date()
console.log(t2 - t1)
```

优点：能够实现更加精细的时间精确度，而且看起来就是真的 sleep 函数，清晰直白。
缺点：缺点需要安装这个模块，`^_^`，这也许算不上什么缺点。


**从一个间简简单单的 sleep 函数我们就就可以管中窥豹，看见 JavaScript 近几年来不断快速的发展，不单单是异步编程这一块，还有各种各样的新技术和新框架，见证了 JavaScript 的繁荣。**

**你可能不知道的前端知识点：Async/Await是目前前端异步书写最优雅的一种方式**

### 2、获取时间戳
上面第一个用多种方式实现 `sleep` 函数，我们可以发现代码有 `+new Date()`获取时间戳的用法，这只是其中的一种，下面就说一下其他两种以及 `+new Date()`的原理。

#### 2.1 普通版
```JavaScript
var timestamp=new Date().getTime()
```
优点：具有普遍性，大家都用这个
缺点：目前没有发现

#### 2.2 进阶版

```JavaScript
var timestamp = (new Date()).valueOf()
```
>valueOf 方法返回对象的原始值(Primitive,'Null','Undefined','String','Boolean','Number'五种基本数据类型之一)，可能是字符串、数值或 bool 值等，看具体的对象。

优点：说明开发者原始值有一个具体的认知，让人眼前一亮。
缺点: 目前没有发现

#### 2.3 终极版
```JavaScript
var timestamp = +new Date()
```
优点：对 JavaScript 隐式转换掌握的比较牢固的一个表现
缺点：目前没有发现

现在就简单分析一下为什么 `+new Date()` 拿到的是时间戳。

**一言以蔽之，这是隐式转换的玄学，实质还是调用了 valueOf() 的方法。**

我们先看看 `ECMAScript` 规范对一元运算符的规范：

**一元+ 运算符**

 一元 `+` 运算符将其操作数转换为 `Number` 类型并反转其正负。注意负的 `+0` 产生 `-0`，负的 `-0` 产生 `+0`。产生式 `UnaryExpression : - UnaryExpression` 按照下面的过程执行。
>1. 令 expr 为解释执行 UnaryExpression 的结果 .
>2. 令 oldValue 为 ToNumber(GetValue(expr)).
>3. 如果 oldValue is NaN ，return NaN.
>4. 返回 oldValue 取负（即，算出一个数字相同但是符号相反的值）的结果。

**+new Date() 相当于 ToNumber(new Date())**

我们再来看看 `ECMAScript` 规范对 `ToNumber` 的定义：

![](https://pic4.zhimg.com/50/v2-13fd97309c849e099df01963f85e2913_hd.jpg)

我们知道 `new Date()` 是个对象，满足上面的 `ToPrimitive()`，所以进而成了 `ToPrimitive(new Date())`。

接着我们再来看看 `ECMAScript` 规范对 `ToPrimitive` 的定义，一层一层来，抽丝剥茧。

![](https://pic4.zhimg.com/50/v2-29c47ccb682883d8b43ab9f97096b5c3_hd.jpg)

这个 `ToPrimitive` 刚开始可能不太好懂，我来大致解释一下吧：

**ToPrimitive(obj,preferredType)**

`JavaScript` 引擎内部转换为原始值 `ToPrimitive(obj,preferredType)` 函数接受两个参数，第一个 `obj` 为被转换的对象，第二个`preferredType` 为希望转换成的类型（默认为空，接受的值为 `Number` 或 `String`）

在执行 `ToPrimitive(obj,preferredType)` 时如果第二个参数为空并且 `obj` 为 `Date` 的实例时，此时 `preferredType` 会被设置为 `String`，其他情况下 `preferredType` 都会被设置为`Number` 如果 `preferredType` 为 `Number`，`ToPrimitive` 执行过程如下：

>1. 如果obj为原始值，直接返回；
>2. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；
>3. 否则调用 obj.toString()，如果执行结果是原始值，返回之；
>4. 否则抛异常。

如果 `preferredType` 为 `String`，将上面的第2步和第3步调换，即：

>1. 如果obj为原始值，直接返回；
>2. 否则调用 obj.toString()，如果执行结果是原始值，返回之；
>3. 否则调用 obj.valueOf()，如果执行结果是原始值，返回之；
>4. 否则抛异常。

首先我们要明白 `obj.valueOf()` 和 `obj.toString()` 还有原始值分别是什么意思,这是弄懂上面描述的前提之一:

**`toString` 用来返回对象的字符串表示。**

```JavaScript
var obj = {};
console.log(obj.toString());//[object Object]

var arr2 = [];
console.log(arr2.toString());//""空字符串

var date = new Date();
console.log(date.toString());//Sun Feb 28 2016 13:40:36 GMT+0800 (中国标准时间)
```
**`valueOf` 方法返回对象的原始值，可能是字符串、数值或 `bool` 值等，看具体的对象。**

```JavaScript
var obj = {
  name: "obj"
}
console.log(obj.valueOf()) //Object {name: "obj"}

var arr1 = [1]
console.log(arr1.valueOf()) //[1]

var date = new Date()
console.log(date.valueOf())//1456638436303
如代码所示，三个不同的对象实例调用valueOf返回不同的数据
```
**原始值指的是 `'Null','Undefined','String','Boolean','Number','Symbol'` 6种基本数据类型之一，上面已经提到过这个概念，这里再次申明一下。**

最后分解一下其中的过程：`+new Date():`

>1. 运算符 `new` 的优先级高于一元运算符 `+`，所以过程可以分解为：
var time=new Date();
+time
>2. 根据上面提到的规则相当于：`ToNumber(time)`
>3. `time` 是个日期对象，根据 `ToNumber` 的转换规则，所以相当于：`ToNumber(ToPrimitive(time))`
>4. 根据 `ToPrimitive` 的转换规则：`ToNumber(time.valueOf())`，`time.valueOf()` 就是 原始值 得到的是个时间戳，假设 `time.valueOf()=1503479124652`
>5. 所以 `ToNumber(1503479124652)` 返回值是 `1503479124652` 这个数字。
>6. 分析完毕

**你可能不知道的前端知识点：隐式转换的妙用**


### 3、数组去重
注：暂不考虑`对象字面`量，`函数`等引用类型的去重，也不考虑 `NaN`, `undefined`, `null`等特殊类型情况。
>数组样本：[1, 1, '1', '2', 1]

#### 3.1 普通版
`无需思考，我们可以得到 O(n^2) 复杂度的解法。定义一个变量数组 res 保存结果，遍历需要去重的数组，如果该元素已经存在在 res 中了，则说明是重复的元素，如果没有，则放入 res 中。`

```JavaScript
var a = [1, 1, '1', '2', 1]
function unique(arr) {
    var res = []
    for (var i = 0, len = arr.length; i < len; i++) {
        var item = arr[i]
        for (var j = 0, len = res.length; j < jlen; j++) {
            if (item === res[j]) //arr数组的item在res已经存在,就跳出循环
                break
        }
        if (j === jlen) //循环完毕,arr数组的item在res找不到,就push到res数组中
            res.push(item)
    }
    return res
}
console.log(unique(a)) // [1, 2, "1"]
```
优点： 没有任何兼容性问题，通俗易懂，没有任何理解成本
缺点： 看起来比较臃肿比较繁琐，时间复杂度比较高`O(n^2)`

#### 3.2 进阶版
``` JavaScript
var a =  [1, 1, '1', '2', 1]
function unique(arr) {
    return arr.filter(function(ele,index,array){
        return array.indexOf(ele) === index//很巧妙,这样筛选一对一的,过滤掉重复的
    })
}
console.log(unique(a)) // [1, 2, "1"]
```
优点：很简洁，思维也比较巧妙，直观易懂。
缺点：不支持 `IE9` 以下的浏览器，时间复杂度还是`O(n^2)`

#### 3.3 时间复杂度为O(n)
```JavaScript
var a =  [1, 1, '1', '2', 1]
function unique(arr) {
    var obj = {}
    return arr.filter(function(item, index, array){
        return obj.hasOwnProperty(typeof item + item) ? 
        false : 
        (obj[typeof item + item] = true)
    })
}

console.log(unique(a)) // [1, 2, "1"]
```
优点：`hasOwnProperty` 是对象的属性(名称)存在性检查方法。对象的属性可以基于 `Hash` 表实现，因此对属性进行访问的时间复杂度可以达到`O(1)`;
`filter` 是数组迭代的方法，内部还是一个 `for` 循环，所以时间复杂度是 `O(n)`。
缺点：不兼容 `IE9` 以下浏览器，其实也好解决，把 `filter` 方法用 `for` 循环代替或者自己模拟一个 filter 方法。

#### 3.4 终极版
>以 Set 为例，ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。

```JavaScript
const unique = a => [...new Set(a)]
```

优点：`ES6` 语法，简洁高效，我们可以看到，去重方法从原始的 `14` 行代码到 `ES6` 的 `1` 行代码，其实也说明了 `JavaScript` 这门语言在不停的进步，相信以后的开发也会越来越高效。
缺点：兼容性问题，现代浏览器才支持，有 `babel` 这些都不是问题。

**你可能不知道的前端知识点：ES6 新的数据结构 Set 去重**

### 4、数字格式化 1234567890 --> 1,234,567,890
#### 4.1 普通版
```JavaScript
function formatNumber(str) {
  let arr = [],
    count = str.length

  while (count >= 3) {
    arr.unshift(str.slice(count - 3, count))
    count -= 3
  }

  // 如果是不是3的倍数就另外追加到上去
  str.length % 3 && arr.unshift(str.slice(0, str.length % 3))

  return arr.toString()

}
console.log(formatNumber("1234567890")) // 1,234,567,890
```
优点：自我感觉比网上写的一堆 for循环 还有 if-else 判断的逻辑更加清晰直白。
缺点：太普通
#### 4.2 进阶版
```JavaScript
function formatNumber(str) {

  // ["0", "9", "8", "7", "6", "5", "4", "3", "2", "1"]
  return str.split("").reverse().reduce((prev, next, index) => {
    return ((index % 3) ? next : (next + ',')) + prev
  })
}

console.log(formatNumber("1234567890")) // 1,234,567,890
```
优点：把 JS 的 API 玩的了如指掌
缺点：可能没那么好懂，不过读懂之后就会发出我怎么没想到的感觉

#### 4.3 正则版
```JavaScript
function formatNumber(str) {
  return str.replace(/\B(?=(\d{3})+(?!\d))/g, ',')
}

console.log(formatNumber("123456789")) // 1,234,567,890
```
下面简单分析下正则`/\B(?=(\d{3})+(?!\d))/g`：

>1. `/\B(?=(\d{3})+(?!\d))/g`：正则匹配边界`\B`，边界后面必须跟着`(\d{3})+(?!\d)`;
>2. `(\d{3})+`：必须是1个或多个的3个连续数字;
>3. `(?!\d)`：第2步中的3个数字不允许后面跟着数字;
>4. `(\d{3})+(?!\d)`：所以匹配的边界后面必须跟着`3*n`（n>=1）的数字。

最终把匹配到的所有边界换成`,`即可达成目标。

优点：代码少，浓缩的就是精华
缺点：需要对正则表达式的位置匹配有一个较深的认识，门槛大一点

#### 4.4 API版
```JavaScript
(123456789).toLocaleString('en-US')  // 1,234,567,890
```
如图，你可能还不知道 `JavaScript` 的 `toLocaleString` 还可以这么玩。

![](https://ws4.sinaimg.cn/large/006tNbRwgy1fmqt4dome4j30x60ca77m.jpg)

**还可以使用** [Intl对象 - MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Intl)

>Intl 对象是 ECMAScript 国际化 API 的一个命名空间，它提供了精确的字符串对比，数字格式化，日期和时间格式化。Collator，NumberFormat 和 DateTimeFormat 对象的构造函数是 Intl 对象的属性。

```JavaScript
new Intl.NumberFormat().format(1234567890) // 1,234,567,890
```
优点：简单粗暴，直接调用 API
缺点：[Intl兼容性](https://caniuse.com/#search=Intl)不太好，不过 toLocaleString的话 IE6 都支持

**你可能不知道的前端知识点：Intl对象 和 toLocaleString的方法。**

### 5、交换两个整数
let a = 3,b = 4 变成 a = 4, b = 3

#### 5.1 普通版
首先最常规的办法，引入一个 temp 中间变量

```JavaScript
let a = 3,b = 4
let temp = a
a = b
b = temp
console.log(a, b)
```
优点：一眼能看懂就是最好的优点
缺点：硬说缺点就是引入了一个多余的变量

#### 5.2 进阶版
在不引入中间变量的情况下也能交互两个变量

```JavaScript
let a = 3,b = 4
a += b
b = a - b
a -= b
console.log(a, b)
```
优点：比起楼上那种没有引入多余的变量，比上面那一种稍微巧妙一点
缺点：当然缺点也很明显，整型数据溢出，比如说对于32位字符最大表示有符号数字是2147483647，也就是Math.pow(2,31)-1，如果是2147483645和2147483646交换就失败了。

#### 5.3 终极版
利用一个数异或本身等于０和异或运算符合交换率。

```JavaScript
let a = 3,b = 4
  a ^= b
  b ^= a
  a ^= b
console.log(a, b)
```

 下面用竖式进行简单说明：(10进制化为二进制)
 
```JavaScript
    a = 011
(^) b = 100
则  a = 111(a ^ b的结果赋值给a，a已变成了7)
(^) b = 100
则  b = 011(b^a的结果赋给b，b已经变成了3)
(^) a = 111
则  a = 100(a^b的结果赋给a，a已经变成了4)

```

从上面的竖式可以清楚的看到利用异或运算实现两个值交换的基本过程。
       
下面从深层次剖析一下：

>1.对于开始的两个赋值语句，a = a ^ b，b = b ^ a，相当于b = b ^ (a ^ b) = a  ^ b ^ b，而b ^ b 显然等于0。因此b = a ^ 0，显然结果为a。
>2. 同理可以分析第三个赋值语句，a = a ^ b = (a ^ b) ^ a = b

注：
1. ^ 即”异或“运算符。
>它的意思是判断两个相应的位值是否为”异“，为”异"(值不同)就取真（1）;否则为假（0）。
2. ^ 运算符的特点是与0异或，保持原值；与本身异或，结果为0。

优点：不存在引入中间变量，不存在整数溢出
缺点：前端对位操作这一块可能了解不深，不容易理解

#### 5.4 究极版
熟悉 `ES6` 语法的人当然不会对解构陌生

```JavaScript
var a = 3,b = 4;
[b, a] = [a, b]
```
其中的解构的原理，我暂时还没读过 ES6的规范，不知道具体的细则，不过我们可以看看 `babel` 是自己编译的，我们可以看出点门路。

哈哈，简单粗暴，不知道有没有按照 ES 的规范，其实可以扒一扒 v8的源码，chrome 已经实现这种解构用法。

![](https://ws2.sinaimg.cn/large/006tNc79gy1fml887kqqgj31ho0owtdo.jpg)

**这个例子和前面的例子编写风格有何不同**，你如果细心的话就会发现这两行代码多了一个**分号**，对于我这种编码不写分号的洁癖者，为什么加一个分号在这里，其实是有原因的，这里就简单普及一下，**建议大家还是写代码写上分号**。

#### 5.4 ECMAScript 自动分号;插入(作为补充，防止大家以后踩坑)
尽管 JavaScript 有 C 的代码风格，但是它不强制要求在代码中使用分号，实际上可以省略它们。

JavaScript 不是一个没有分号的语言，恰恰相反上它需要分号来就解析源代码。 因此 JavaScript 解析器在遇到由于缺少分号导致的解析错误时，会自动在源代码中插入分号。

##### 5.4.1例子

```JavaScript
var foo = function() {
} // 解析错误，分号丢失
test()
```
  自动插入分号，解析器重新解析。

```JavaScript
var foo = function() {
}; // 没有错误，解析继续
test()
```

##### 5.4.2工作原理

下面的代码没有分号，因此解析器需要自己判断需要在哪些地方插入分号。

```JavaScript
(function(window, undefined) {
    function test(options) {
        log('testing!')

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            'long string to pass here',
            'and another long string to pass'
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}
})(window)

```
下面是解析器"猜测"的结果。

```JavaScript
(function(window, undefined) {
    function test(options) {

        // 没有插入分号，两行被合并为一行
        log('testing!')(options.list || []).forEach(function(i) {

        }); // <- 插入分号

        options.value.test(
            'long string to pass here',
            'and another long string to pass'
        ); // <- 插入分号

        return; // <- 插入分号, 改变了 return 表达式的行为
        { // 作为一个代码段处理
            foo: function() {}
        }; // <- 插入分号
    }
    window.test = test; // <- 插入分号

// 两行又被合并了
})(window)(function(window) {
    window.someLibrary = {}; // <- 插入分号
})(window); //<- 插入分号

```
解析器显著改变了上面代码的行为，在另外一些情况下也会做出错误的处理。


##### 5.4.3 ECMAScript对自动分号插入的规则

我们翻到7.9章节，看看其中插入分号的机制和原理，清楚只写以后就可以尽量以后少踩坑

**必须用分号终止某些 ECMAScript 语句 ( 空语句 , 变量声明语句 , 表达式语句 , do-while 语句 , continue 语句 , break 语句 , return 语句 ,throw 语句 )。这些分号总是明确的显示在源文本里。然而，为了方便起见，某些情况下这些分号可以在源文本里省略。描述这种情况会说：这种情况下给源代码的 token 流自动插入分号。**  ![](http://ww1.sinaimg.cn/large/a660cab2gy1fda3cg7drhj21io0lathb)
![](http://ww1.sinaimg.cn/large/a660cab2gy1fda3coditaj21dw0iiag1)

还是比较抽象，看不太懂是不是，不要紧，我们看看实际例子，总结出几个规律就行，我们先不看抽象的，看着头晕，看看具体的总结说明， **化抽象为具体** 。

 首先这些规则是基于两点：

 1. 以换行为基础；
 2. 解析器会尽量将新行并入当前行，当且仅当符合ASI规则时才会将新行视为独立的语句。

###### 5.4.3.1 ASI的规则

**1. 新行并入当前行将构成非法语句，自动插入分号。**

```JavaScript
if(1 < 10) a = 1
console.log(a)
// 等价于
if(1 < 10) a = 1;
console.log(a);
```
**2. 在continue,return,break,throw后自动插入分号**

```JavaScript
return
{a: 1}
// 等价于
return;
{a: 1};
```
**3. ++、--后缀表达式作为新行的开始，在行首自动插入分号**

```JavaScript
a
++
c
// 等价于
a;
++c;
```
**4. 代码块的最后一个语句会自动插入分号**

```JavaScript
function(){ a = 1 }
// 等价于
function(){ a = 1; }
```
###### 5.4.3.2 No ASI的规则

**1. 新行以 ( 开始**

```JavaScript
var a = 1
var b = a
(a+b).toString()
// 会被解析为以a+b为入参调用函数a，然后调用函数返回值的toString函数
var a = 1
var b =a(a+b).toString()
```

**2. 新行以 [ 开始**

```JavaScript
var a = ['a1', 'a2']
var b = a
[0,1].slice(1)
// 会被解析先获取a[1]，然后调用a[1].slice(1)。
// 由于逗号位于[]内，且不被解析为数组字面量，而被解析为运算符，而逗号运算符会先执
行左侧表达式，然后执行右侧表达式并且以右侧表达式的计算结果作为返回值
var a = ['a1', 'a2']
var b = a[0,1].slice(1)
```

**3. 新行以 / 开始**

```JavaScript
var a = 1
var b = a
/test/.test(b)
// /会被解析为整除运算符，而不是正则表达式字面量的起始符号。浏览器中会报test前多了个.号
var a = 1
var b = a / test / .test(b)

```

**4. 新行以 + 、 - 、 % 和 * 开始**

```JavaScript
var a = 2
var b = a
+a
// 会解析如下格式
var a = 2
var b = a + a
```

**5. 新行以 , 或 . 开始**

```JavaScript
var a = 2
var b = a
.toString()
console.log(typeof b)
// 会解析为
var a = 2
var b = a.toString()
console.log(typeof b)
```
到这里我们已经对ASI的规则有一定的了解了，另外还有一样有趣的事情，就是“空语句”。

```JavaScript
// 三个空语句
;;;

// 只有if条件语句，语句块为空语句。
// 可实现unless条件语句的效果
if(1>2);else
  console.log('2 is greater than 1 always!');

// 只有while条件语句，循环体为空语句。
var a = 1
while(++a < 100);
```

##### 5.4.4 结论
建议绝对不要省略分号，同时也提倡将花括号和相应的表达式放在一行， 对于只有一行代码的 if 或者 else 表达式，也不应该省略花括号。 这些良好的编程习惯不仅可以提到代码的一致性，而且可以防止解析器改变代码行为的错误处理。
 [关于JavaScript 语句后应该加分号么？(点我查看)](https://www.zhihu.com/question/20298345)我们可以看看知乎上大牛们对着个问题的看法。

**你可能不知道的前端知识点：原来 JavaScript 还有位操作以及分号的使用细则**


### 6、将 argruments 对象(类数组)转换成数组
`{0:1,1:2,2:3,length:3}`这种形式的就属于类数组，就是按照数组下标排序的对象，还有一个 `length `属性，有时候我们需要这种对象能调用数组下的一个方法，这时候就需要把把类数组转化成真正的数组。
#### 6.1 普通版

```JavaScript
var makeArray = function(array) {
  var ret = []
  if (array != null) {
    var i = array.length
    if (i == null || typeof array === "string") ret[0] = array
    else while (i) ret[--i] = array[i];
  }
  return ret
}
makeArray({0:1,1:2,2:3,length:3}) //[1,2,3]
```
优点：通用版本，没有任何兼容性问题
缺点：太普通

#### 6.2 进阶版
```JavaScript
var arr = Array.prototype.slice.call(arguments);
```
这种应该是大家用过最常用的方法，至于为什么可以这么用，很多人估计也是一知半解，反正我看见大家这么用我也这么用，要搞清为什么里面的原因，我们还是从规范和源码说起。

照着规范的流程，自己看看推演一下就明白了：
[英文版15.4.4.10 Array.prototype.slice (start, end) ](http://es5.github.io/#x15.4.4.10)
[中文版15.4.4.10 Array.prototype.slice (start, end) ](http://yanhaijing.com/es5/#352)
如果你想知道 `JavaScript` 的 `sort` 排序的机制，到底是哪种排序好，用的哪种，也可以从规范看出端倪。

在官方的解释中，如[[mdn](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/slice)]
> The slice() method returns a shallow copy of a portion of an array into a new array object.

**简单的说就是根据参数，返回数组的一部分的 `copy`。所以了解其内部实现才能确定它是如何工作的。所以查看 `V8` 源码中的 `Array.js`     可以看到如下的代码：**

方法  `ArraySlice`，[源码地址](https://github.com/v8/v8/blob/ad82a40509c5b5b4680d4299c8f08d6c6d31af3c/src/js/array.js)，第 `660` 行,直接添加到 `Array.prototype` 上的“入口”，内部经过参数、类型等等的判断处理，分支为 `SparseSlice` 和 `SimpleSlice` 处理。

`slice.call` 的作用原理就是，利用 `call`，将 `slice` 的方法作用于 `arrayLike`，`slice` 的两个参数为空，`slice` 内部解析使得 `arguments.lengt` 等于0的时候 相当于处理 `slice(0)` ： 即选择整个数组，`slice` 方法内部没有强制判断必须是 `Array` 类型，`slice` 返回的是新建的数组（使用循环取值）”，所以这样就实现了类数组到数组的转化，`call` 这个神奇的方法、`slice` 的处理缺一不可。

直接看 `slice` 怎么实现的吧。其实就是将 `array-like` 对象通过下标操作放进了新的 `Array` 里面：

```JavaScript
// This will work for genuine arrays, array-like objects, 
    // NamedNodeMap (attributes, entities, notations),
    // NodeList (e.g., getElementsByTagName), HTMLCollection (e.g., childNodes),
    // and will not fail on other DOM objects (as do DOM elements in IE < 9)
    Array.prototype.slice = function(begin, end) {
      // IE < 9 gets unhappy with an undefined end argument
      end = (typeof end !== 'undefined') ? end : this.length;

      // For native Array objects, we use the native slice function
      if (Object.prototype.toString.call(this) === '[object Array]'){
        return _slice.call(this, begin, end); 
      }

      // For array like object we handle it ourselves.
      var i, cloned = [],
        size, len = this.length;

      // Handle negative value for "begin"
      var start = begin || 0;
      start = (start >= 0) ? start : Math.max(0, len + start);

      // Handle negative value for "end"
      var upTo = (typeof end == 'number') ? Math.min(end, len) : len;
      if (end < 0) {
        upTo = len + end;
      }

      // Actual expected size of the slice
      size = upTo - start;

      if (size > 0) {
        cloned = new Array(size);
        if (this.charAt) {
          for (i = 0; i < size; i++) {
            cloned[i] = this.charAt(start + i);
          }
        } else {
          for (i = 0; i < size; i++) {
            cloned[i] = this[start + i];
          }
        }
      }

      return cloned;
    };
```
优点：最常用的版本，兼容性较强
缺点：ie 低版本，无法处理 dom 集合的 slice call 转数组。（虽然具有数值键值、length 符合ArrayLike 的定义，却报错）搜索资料得到 ：因为 ie 下的 dom 对象是以 com 对象的形式实现的，js 对象与com对象不能进行转换 。

#### 6.3 ES6 版本
使用 `Array.from`, 值需要对象有 `length` 属性, 就可以转换成数组

```JavaScript
var arr = Array.from(arguments);
```

扩展运算符

```JavaScript
var args = [...arguments];
```
`ES6` 中的扩展运算符...也能将某些数据结构转换成数组，这种数据结构必须有便利器接口。
优点：直接使用内置 API，简单易维护
缺点：兼容性，使用 babel 的 profill 转化可能使代码变多，文件包变大

**你可能不知道的前端知识点：slice 方法的具体原理**


### 7、数字取整 2.33333 => 2
#### 7.1 普通版

```JavaScript
const a = parseInt(2.33333)
```
`parseInt()` 函数解析一个字符串参数，并返回一个指定基数的整数 (数学系统的基础)。这个估计是直接取整最常用的方法了。
更多关于 `parseInt()` 函数可以查看 [MDN 文档](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/parseInt)

#### 7.2 进阶版
```JavaScript
const a = Math.trunc(2.33333)
```
`Math.trunc()` 方法会将数字的小数部分去掉，只保留整数部分。
特别要注意的是：`Internet Explorer` 不支持这个方法，不过写个 `Polyfill` 也很简单：

```JavaScript
Math.trunc = Math.trunc || function(x) {
  if (isNaN(x)) {
    return NaN;
  }
  if (x > 0) {
    return Math.floor(x);
  }
  return Math.ceil(x);
};
```
数学的事情还是用数学方法来处理比较好。

#### 7.3 黑科技版
##### 7.3.1 ~~number
双波浪线 ~~ 操作符也被称为“双按位非”操作符。你通常可以使用它作为代替 Math.trunc() 的更快的方法。

```JavaScript
console.log(~~47.11)  // -> 47
console.log(~~1.9999) // -> 1
console.log(~~3)      // -> 3
console.log(~~[])     // -> 0
console.log(~~NaN)    // -> 0
console.log(~~null)   // -> 0
```

失败时返回0,这可能在解决 Math.trunc() 转换错误返回 NaN 时是一个很好的替代。
但是当数字范围超出 ±2^31−1 即：2147483647 时，异常就出现了：

```JavaScript
// 异常情况
console.log(~~2147493647.123) // -> -2147473649 🙁
```

##### 7.3.2 number | 0
| (按位或) 对每一对比特位执行或（OR）操作。

```JavaScript
console.log(20.15|0);          // -> 20
console.log((-20.15)|0);       // -> -20
console.log(3000000000.15|0);  // -> -1294967296 🙁
```

##### 7.3.3 number ^ 0
^ (按位异或)，对每一对比特位执行异或（XOR）操作。

```JavaScript
console.log(20.15^0);          // -> 20
console.log((-20.15)^0);       // -> -20
console.log(3000000000.15^0);  // -> -1294967296 🙁
```

##### 7.3.4 number << 0
<< (左移) 操作符会将第一个操作数向左移动指定的位数。向左被移出的位被丢弃，右侧用 0 补充。

```JavaScript
console.log(20.15 < < 0);     // -> 20
console.log((-20.15) < < 0);  //-20
console.log(3000000000.15 << 0);  // -> -1294967296 🙁
```
上面这些按位运算符方法执行很快，当你执行数百万这样的操作非常适用，速度明显优于其他方法。但是代码的可读性比较差。还有一个特别要注意的地方，处理比较大的数字时（当数字范围超出 ±2^31−1 即：2147483647），会有一些异常情况。使用的时候明确的检查输入数值的范围。

### 8、数组求和
#### 8.1 普通版
```JavaScript
let arr = [1, 2, 3, 4, 5]
function sum(arr){
    let x = 0
    for(let i = 0; i < arr.length; i++){
        x += arr[i]
    }
    return x
}
sum(arr) // 15
```
优点：通俗易懂，简单粗暴
缺点：没有亮点，太通俗

#### 8.2 优雅版
```JavaScript
let arr = [1, 2, 3, 4, 5]
function sum(arr) {
return arr.reduce((a, b) => a + b)
}
sum(arr) //15
```
优点：简单明了，数组迭代器方式清晰直观
缺点：不兼容 IE 9以下浏览器


#### 8.3 终极版
```JavaScript
let arr = [1, 2, 3, 4, 5]
function sum(arr) {
return eval(arr.join("+"))
}
sum(arr) //15
```
优点：让人一时看不懂的就是"好方法"。
缺点：
>eval 不容易调试。用 chromeDev 等调试工具无法打断点调试，所以麻烦的东西也是不推荐使用的…

>性能问题，在旧的浏览器中如果你使用了eval，性能会下降10倍。在现代浏览器中有两种编译模式：fast path和slow path。fast path是编译那些稳定和可预测（stable and predictable）的代码。而明显的，eval 不可预测，所以将会使用 slow path ，所以会慢。

更多关于 `eval` 的探讨可以关注这篇文章: [JavaScript 为什么不推荐使用 eval？](https://www.zhihu.com/question/20591877)

**你可能不知道的前端知识点：eval的使用细则**



### 最后
**祝大家圣诞快乐🎄，欢迎补充和交流。**
![](https://ws3.sinaimg.cn/large/006tNbRwgy1fmqonrultsj30ni0smdih.jpg)
![](https://ws2.sinaimg.cn/large/006tNbRwgy1fmqonyprg9j30v00tyqgk.jpg)
![](https://ws4.sinaimg.cn/large/006tNbRwgy1fmqoopktdjg30dw07q7wh.gif)
[![](https://badge.juejin.im/entry/59c9521e6fb9a00a437b1dbc/likes.svg?style=flat)](https://juejin.im/entry/59c9521e6fb9a00a437b1dbc/detail)
之前不久，由于自己平时涉猎还算广泛，总结了一篇博客：[这些JavaScript编程黑科技，装逼指南，高逼格代码，让你惊叹不已](https://github.com/jawil/blog/issues/24)，没想到受到了大家的欢迎，有人希望能博主还能整理个 `CSS` 的一些黑魔法小技巧，无奈我 `CSS` 一直很渣，没什么干货，最近写了一个 `Chrome` 插件 [GayHub](https://github.com/jawil/GayHub)，算是把 `GitHub` 的样式审查了个变，在写的过程中，也收获了很多关于 `CSS` 的小技巧，尤其是开始的第一个技巧，学习到了很多，于是再加上一波搜集，就诞生这篇博文，欢迎补充~~~😂。

### 1、利用 `CSS` 的 `content` 属性 `attr` 抓取资料

#### 需求
>**鼠标悬浮实现一个提示的文字，类似github的这种，如图：**

![](https://ws3.sinaimg.cn/large/006tNc79gy1fjvw8i8swsj309p05z3zc.jpg)

想必大家都想到了伪元素 `after`，但是文字怎么获得呢，又不能用 `JavaScript`。

`CSS` 的伪元素是个很強大的东西，我们可以利用他做很多运用，通常为了做一些效果，`content:" "` 多半会留空，但其实可以在里面写上 `attr` 抓资料哦！

```html
<div data-msg="Open this file in Github Desktop">  
hover
</div>
```
```css
div{
width:100px;
border:1px solid red;  
position:relative;
}
div:hover:after{
content:attr(data-msg);
position:absolute;
font-size: 12px;
width:200%;
line-height:30px;
text-align:center;
left:0;
top:25px;
border:1px solid green;
}
```
在 `attr` 里面塞入我们在 `html` 新增的 `data-msg` 属性，这样伪元素 `(:after)` 就会得到该值。

#### 最终效果

![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjvwlydep5j30lb0d40w1.jpg)

同样的，你还可以结合其他强大的选择器使用，例如：**使用属性选择器选择空链接**

显示没有文本值但是 `href` 属性具有链接的 `a` 元素的链接：

```css
a[href^="http"]:empty::before {
  content: attr(href);
}
```
这样做很方便。

### 2、利用用 `:valid` 和 `:invalid` 来做表单即时校验
#### 需求
>**让表单检验变得简单优雅，不需要写冗长的 JS 代码来校验设置样式**

`html5` 丰富了表单元素，提供了类似 `required`,`email`,`tel` 等表单元素属性。同样的，我们可以利用 `:valid` 和 `:invalid` 来做针对html5表单属性的校验。

  * `:required` 伪类指定具有required 属性的表单元素
  * `:valid` 伪类指定一个通过匹配正确的所要求的表单元素
  * `:invalid` 伪类指定一个不匹配指定要求的表单元素
  
#### 代码

```html
 <div class="container">
    <div class="row" style="margin-top: 2rem;">
      <form>
        <div class="form-group">
          <label>name</label>
          <input type="text" required placeholder="请输入名称">
        </div>
        <div class="form-group">
          <label>email</label>
          <input type="email" required placeholder="请输入邮箱">
        </div>
        <div class="form-group">
          <label>homepage</label>
          <input type="url" placeholder="请输入博客url">
        </div>
        <div class="form-group">
          <label>Comments</label>
          <textarea required></textarea>
        </div>
      </form>
    </div>
  </div>
```
```css
.valid {
  border-color: #429032;
  box-shadow: inset 5px 0 0 #429032;
}

.invalid {
  border-color: #D61D1D;
  box-shadow: inset 5px 0 0 #D61D1D;
}

.form-group {
  width: 32rem;
  padding: 1rem;
  border: 1px solid transparent;
  &:hover {
    border-color: #eee;
    transition: border .2s;
  }
  label {
    display: block;
    font-weight: normal;
  }
  input,
  textarea {
    display: block;
    width: 100%;
    line-height: 2rem;
    padding: .5rem .5rem .5rem 1rem;
    border: 1px solid #ccc;
    outline: none;
    &:valid {
      @extend .valid;
    }
    &:invalid {
      @extend .invalid;
    } 
  }
}
```
更多伪元素技巧可以参看这篇文章：[你不知道的CSS](https://segmentfault.com/a/1190000011194809)

#### 最终效果
![](https://segmentfault.com/img/bVU8qM?w=385&h=417)


### 3、利用 `nth-of-type` 选择某范围内的子元素
#### 需求
>**table表格红绿相间，显示的更加直观**

#### 代码

```html
<table>
  <tbody>
    <tr>
      <td>1</td>
    </tr>
    <tr>
      <td>2</td>
    </tr>
    <tr>
      <td>3</td>
    </tr>
    <tr>
      <td>4</td>
    </tr>
    <tr>
      <td>5</td>
    </tr>
    <tr>
      <td>6</td>
    </tr>
  </tbody>
</table>
```
```css
tbody tr:nth-of-type(2n){  
background-color: red;
}

tbody tr:nth-of-type(2n+1){
background-color: green;
}
```


#### 最终效果

![](https://ws2.sinaimg.cn/large/006tNc79gy1fjw692qenij30n30fg0v9.jpg)

**你也这样来做，选择5-10的子元素。**

```css
table tr:nth-child(n+5):nth-child(-n+10) {
    background-color: red;
}
```

### 4、让文字像古诗一样竖着呈现
#### 需求
>**有时候，需要容器的文字从上到下排列，而不是从左往右排列，如图所示：**

![](https://ws3.sinaimg.cn/large/006tNc79gy1fjw81a4dhfj305k06igli.jpg)

这是[segmentfault](https://segmentfault.com)的回到顶部，他的实现很简单，就是设置一定宽度让其折行，如果我要实现这种需求呢？

![](http://image.zhangxinxu.com/image/blog/201604/yongliu-s.jpg)

#### 代码
`writing-mode` 这个 `CSS` 属性，我们是不是很少见到，很少用到！我们往往称不常见的东西为“生僻”，就像是不常见的文字我们叫“生僻字”，因此不常见的 `CSS` 属性，我们可以叫做“生僻属性”，`writing-mode` 给我们的感觉就是一个“生僻属性”，很弱，可有可无。这个属性可以追溯到 `IE 5.5` 时代，兼容性是相当好的。

```html
<h4>咏柳</h4>
<p>碧玉妆成一树高，<br>万条垂下绿丝绦。<br>不知细叶谁裁出，<br>二月春风似剪刀。</p>

<div class="verticle-mode">
    <h4>咏柳</h4>
    <p>碧玉妆成一树高，<br>万条垂下绿丝绦。<br>不知细叶谁裁出，<br>二月春风似剪刀。</p>
```
```css
.verticle-mode {
    writing-mode: tb-rl;
    -webkit-writing-mode: vertical-rl;      
    writing-mode: vertical-rl;
}
/* IE7比较弱，需要做点额外的动作 */
.verticle-mode {
    *width: 120px;
}
.verticle-mode h4,
.verticle-mode p {
    *display: inline;
    *writing-mode: tb-rl;
}
.verticle-mode h4 {
    *float:right;
}
```
#### 最终效果
![](https://ws3.sinaimg.cn/large/006tNc79gy1fjw8cenoejj30b3087jsb.jpg)

更多细节与讨论请移步张鑫旭老师的这篇文章：[改变CSS世界纵横规则的writing-mode属性](http://www.zhangxinxu.com/wordpress/2016/04/css-writing-mode/)

### 5、实现鼠标悬浮内容自动撑开的过渡动画
#### 需求
>**需要为一个列表添加个动画，容器的高度是不确定的，也就是高度为 `auto`，悬浮时候撑开内容有个过渡动画**

如下图所示：

![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjw5fmrj23g308c0gejza.gif)

而用 `CSS3` 实现的话，由于高度的不确定，而 `transtion` 是需要具体的树枝，所以设置 `height:auto` 是无法实现效果的，可以通过 `max-height` 这个属性间接的实现这么个效果，`css` 样式是这样的：

### 代码

```html
<ul>
  <li>
    <div class="hd"> 列表1 </div>
    <div class="bd">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>
  </li>
  <li>
    <div class="hd"> 列表1 </div>
    <div class="bd">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>
  </li>
  <li>
    <div class="hd"> 列表1 </div>
    <div class="bd">列表内容<br>内容列表内容<br>内容列表内容<br>内容</div>
  </li>
</ul>
```
```css
.bd {
  max-height:0;
  overflow:hidden;
  transition: all 1s ease-out;
}
li:hover .bd {
  max-height: 600px;
  transition-timing-function: ease-in;
}
```
#### 最终效果
跟前面 `GIF` 差不多，这里就不录 `GIF` 了，有兴趣的可以自己尝试感受一下

![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjw5oizfvhj30n50f3tcz.jpg)



### 6、利用 `pointer-events` 禁用 `a` 标签事件效果
#### 需求：
>**在做 `tab` 切换的时候，当选中当前项，禁用当前标签的事件，只有切换其他 `tab` 的时候，才重新请求新的数据。**

`pointer-events` 是一个用于 `HTML` 指针事件的属性。

`pointer-events` 可以禁用 `HTML` 元素的 `hover/focus/active` 等动态效果。

默认值为 `auto`，语法：`pointer-events: auto | none | visiblepainted | visiblefill | visiblestroke | visible | painted | fill | stroke | all;`
#### 代码

```html 
 <ul>
    <li>
        <a class="tab" href="https://google.com">aaa</a>
    </li>
    <li>
         <a class="tab active" href="https://facebook.com">bbb</a>
    </li>
    <li>
        <a class="tab" href="https://stackoverflow.com">ccc</a>
     </li>
    </ul>
```
 
```css
   .active{
         pointer-events: none;
     }
```
#### 最终效果

![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjvwxj6u5ej30ne0d0tb8.jpg)

好像没什么效果😂




### 7、`CSS` 如何实现文字两端对齐

#### 需求
>**红框所在的文字有四个字的、三个字的、两个字的，如果不两端对齐可以选择居中对齐，或者右对齐。但是如果要想文字两端对齐呢？**

#### 代码

```html
<div>姓名</div>
<div>手机号码</div>
<div>验证码</div>
<div>账号</div>
<div>密码</div>
```
```css
div{
margin:10px 0; 
width:100px;
border:1px solid red;
text-align-last: justify;
}
```
#### 最终效果
![](https://ws2.sinaimg.cn/large/006tNc79gy1fjvvy1cg22j30ks0ft0uw.jpg)




### 8、使用 `:not()` 去除导航上不需要的属性
#### 需求
>**有时候导航栏需要之间需要用逗号,进行隔离，但是最后一个不需要**

#### 代码

```html
<ul class="nav">
  <li>a</li>
  <li>b</li>
  <li>c</li>
  <li>d</li>
  <li>e</li>
</ul>
```
```css
li{
list-style:none;
margin-bottom:10px;
display:inline-block;
}

ul > li:not(:last-child)::after {
  content: ",";
}
```
当然，你可以使用 `.nav li + li`(不包括第一个li) 或者 `.nav li:first-child ~ li`(不包括最后一个li)， 但是使用 `:not()` 的意图特别清晰，`CSS`选择器按照人类描述它的方式定义边框。

#### 最后效果
![](https://ws3.sinaimg.cn/large/006tNc79gy1fjw51ewgx6j30mj0cswgg.jpg)

或者，你已经学习了一些关于 使用 :not()，你还可以尝试：

```css
/* 选择1到3的元素并显示 */
li:not(:nth-child(-n+3)){
  display: none;
}
```

### 9、移动web页面支持弹性滚动
#### 需求
>**在IOS机型中，非body元素的滚动条会非常不流畅，又不想用JS模拟滚动条。**

传统 `pc` 端中，子容器高度超出父容器高度，通常使用 `overflow:auto` 可出现滚动条拖动显示溢出的内容，而移动`web`开发中，由于浏览器厂商的系统不同、版本不同，导致有部分机型尤其是 `IOS` 机型不支持弹性滚动，从而在开发中制造了所谓的 `BUG`。

#### 代码

```css
body{
-webkit-overflow-scrolling: touch; /* ios5+ */
}
ele{
overflow:auto;
}
```
`-webkit-overflow-scrolling`属性具有继承效果，所以在 `body` 上设置即可，这样局部滚动条就非常的流畅了。

#### 最终效果
所有滚动条都相当的流畅了



### 10、美化浏览器自带的 `radio` ，`checkbox` 属性
#### 需求
>**设计师：你那个单选框按钮好丑啊，跟我的设计稿差好远。程序员：我有什么办法，浏览器就是这样的。。。**

记得刚开始写页面时候，被浏览器各种默认的 `UI` 样式恶心到了，当初确实也没啥办法，反正也不影响功能，就那样吧。

**先讲一下原理：checkbox hack技术**
>我们使用 `CSS` 一些特殊的选择器，然后配合单选框以及复选框自带的一些特性，可以实现元素的显示隐藏效果。然后通过一些简单的扩展，我们可以不使用任何 `JavaScript` 代码实现类似：自定义的单复选框，“更多”展开与收起效果，选项卡切换效果，或是多级下拉列表效果等等。

>相信很多前端开发人员都会遇到 `boss` 让修改 `checkbox` 和 `radio` 样式，毕竟自带的样式太丑了。后来我们发现修改自带样式并不是那么容易，最后直接使出杀手锏——点击之后替换图片。

今天教大家一种方法，不用替换图片，随意修改样式。

>先讲一下原理：两个关键东东，一是伪类选择器 `:checked`，表示对应控件元素（单选框或是复选框）选中时的样式；二就是加号 `+` 相邻兄弟选择器，这个符号表示选择后面的兄弟节点。于是，两者配合，就可以轻松自如控制后面元素的显示或者隐藏，或是其他样式了。

>而如何让单复选框选中和不选中了，那就是 `label` 标签了哈，`for` 属性锚定对应的单选框或是复选框，然后点击这里的 `label` 标签元素的时候，对应的单复选框就会选中或是取消选中。然后，就有上面的效果啦！

#### 代码
这里只给一个 `radio` 单选框的代码,仅供参考:

```html
<div class="radio-beauty-container">
    <label>
        <span class="radio-name">前端工程师</span>
        <input type="radio" name="radioName" id="radioName1" hidden/>
        <label for="radioName1" class="radio-beauty"></label>
    </label>
    <label>
        <span class="radio-name">后端工程师</span>
        <input type="radio" name="radioName" id="radioName2" hidden/>
        <label for="radioName2" class="radio-beauty"></label>
    </label>
    <label>
        <span class="radio-name">全栈工程师</span>
        <input type="radio" name="radioName" id="radioName3" hidden/>
        <label for="radioName3" class="radio-beauty"></label>
    </label>
</div>
```
```
.radio-beauty-container {
    font-size: 0;
    $bgc: green;
    %common {
        padding: 2px;
        background-color: $bgc;
        background-clip: content-box;
    }
    .radio-name {
        vertical-align: middle;
        font-size: 16px;
    }
    .radio-beauty {
        width: 18px;
        height: 18px;
        box-sizing: border-box;
        display: inline-block;
        border: 1px solid $bgc;
        vertical-align: middle;
        margin: 0 15px 0 3px;
        border-radius: 50%;
        &:hover {
            box-shadow: 0 0 7px $bgc;
            @extend %common;
        }
    }
    input[type="radio"]:checked+.radio-beauty {
        @extend %common;
    }
}
```
#### 最终效果

![](http://p1.pstatp.com/large/106c00024a844dd53299)

美化radio单选框在线预览地址：[点击我呀](http://codepen.io/jawil/pen/NRYRrw)
美化checkbox复选框在线预览地址：[点击我呀](http://codepen.io/jawil/pen/qaoarB)

更多关于这方面的介绍和例子可以参看**张鑫旭**大神的这篇文章：[CSS radio/checkbox单复选框元素显隐技术](http://www.zhangxinxu.com/wordpress/2012/01/css-css3-selector-element-display-tab-listdown/)



### 11、改变 `input` 焦点光标的颜色
#### 需求
>**设计师觉得默认的光标颜色有点与整体设计风格不符合，有点突兀，想换成红色的**

#### 代码
```html
<input value="This field uses a default caret." />
<input class="custom" value="I have a custom caret color!" />
```
```css
input {
  caret-color: auto;
  display: block;
  margin-bottom: .5em;
}

input.custom {
  caret-color: red;
}
```

#### 最终效果
![](https://ws1.sinaimg.cn/large/006tNc79gy1fjvw32mv8cj30l10cnjtp.jpg)


### 12、`rem` 布局不再使用 `JavaScript` 设置
这里不探讨 `rem` 的原理以及细节，还不熟悉的童鞋建议去恶补一下。
#### 需求
>**有时候，移动端用 `rem` 布局时候，根据不同的屏幕宽度要设置不同的 `font-size` 来做到适配，要写一坨 `JS` 来设置，能不能不用JS呢？**

例如：以 `750px` 设计稿作为基准，根节点设置 `font-size` 为 `100px` ,只考虑 `DPR` 为 `2` 的情况，只考虑最简单的情况

```JavaScript
 document.querySelector('html').style.fontSize = `${window.innerWidth / 7.5 }px`;
```

#### 代码
现在移动端 `css3` 单位 `vw` ,`wh` 兼容性已经很不错了，在不需要兼容太低版本的安卓机情况下可以这样来：

```css
html{
font-size: calc(100vw  /  7.5)
}
```

#### 最终结果
就这么简单的设置，`rem` 就可以使用了



### 13、利用 `transparent` 属性实现各种三角形，提示框
#### 需求
>**在不使用图片的情况，实现一个简单的三角形箭头**

#### 代码

```css
#triangle-right {
    width: 0;
    height: 0;
    border-top: 50px solid transparent;
    border-left: 100px solid red;
    border-bottom: 50px solid transparent;
}
```

#### 最终效果

![](https://ws1.sinaimg.cn/large/006tNc79gy1fjw08bpi3cj30nd0e1dhr.jpg)

复杂点的话，同样的原理还可以实现一个**五角星**，原理都是利用 `transparent` 的透明属性。

### 14、让网站所有图片变成黑白色彩的
#### 需求
>**记得2008年时候汶川大地震时候，很多网站图片都变成黑白色彩悼念逝者**

#### 代码

```html
<img src="https://user-gold-cdn.xitu.io/2017/9/25/0844cf44a8d8c4ed026d6c488a6e9b80?
imageView2/1/w/500/h/200/q/85/interlace/1" alt="" class="desaturate">
```
```css
img.desaturate {
    filter: grayscale(100%);
    -webkit-filter: grayscale(100%);
    -moz-filter: grayscale(100%);
    -ms-filter: grayscale(100%);
    -o-filter: grayscale(100%);
}
```

#### 最终效果
![](https://ws4.sinaimg.cn/large/006tNc79gy1fjw7f4nxpsj30ng0gngrv.jpg)


### 15、实现文字的波浪线效果
#### 需求
>**实现文字波浪线的强调效果，如图所示**

![](https://segmentfault.com/img/remote/1460000009645776?w=274&h=101)

 相信大家对于 `text-decoration` 这个属性并不陌生，在重置 `a` 标签的默认样式时，我们经常要这样写：`text-decoration: none;` 可能对它了解的人也很少，实际上 `text-decoration` 是一个复合属性，由 `line`、`style` 和 `color` 组成。

  所以我们可以实现这样的效果：  
![](https://segmentfault.com/img/remote/1460000009645775)

  可惜的是 `line` 只有 `underline` (下划线)、`overline` (上划线)和 `line-through` (删除线)。如果突然需要下划波浪线，怎么办呢？不要急，神奇的 `CSS` 会帮你做到的。首先，你需要先了解一下[渐变的使用技巧](http://www.jianshu.com/p/3b9c19746d6c)。

  说一下这里的思路，我们首先要用两段渐变构造一个基本元素：'X'(这里我就不放图了)，下一步就比较重要了，我们要截取'X'的上半部分，得到一个'V',从而结合 `repeat` 形成波浪线。下面是用 `scss` 写的一个 `mixin` ，方便以后使用。

#### 代码
```css
    @mixin waveline($color,$h) {
        position: relative;
        &::after {
            content: '';
            display: block;
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: $h;
            background: linear-gradient(135deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%),
                        linear-gradient(45deg, transparent, transparent 45%, $color, transparent 55%, transparent 100%);
            background-size: $h * 2 $h * 2;
        }
    }
```

#### 最终效果
![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjw7ukvagij30np0c3wgp.jpg)
  

### 兼容性
这些技巧在当前版本的`Chrome`，`Firefox`， `Safari`， 以及`Edge`， 和`IE11`可以工作，移动端基本都没问题，`IE` 重度开发者慎用。

**相关兼容性自行查找：https://caniuse.com/**

### 推荐一波
#### 有趣的 GitHub 仓库
国服第一切图仔的 CSS 仓库：你想知道的 CSS 奇技淫巧，在这里，都有。[iCSS -- interesting css](https://github.com/chokcoco/iCSS)

#### 张鑫旭老师的博客
[前端技术](http://www.zhangxinxu.com/wordpress/)

![](https://avatars0.githubusercontent.com/u/8554143?v=4&s=460)

受益颇多，所以推荐一波。😂



### github源码地址：https://github.com/jawil/GayHub
[![](https://badge.juejin.im/entry/59ba24ab5188257e8466e460/likes.svg?style=flat-square)](https://juejin.im/entry/59ba24ab5188257e8466e460/detail)
<p align="center"><img src="https://ws3.sinaimg.cn/large/006tNc79gy1fjg0akcj3fj30b40b4gm2.jpg" /></p>
<h1 align="center">Chrome —— GayHub</h1>
<p align="center">一款强大的 GitHub 的 Chrome 扩展 —— GayHub，优化 GitHub 的阅读体验。</p>
<p align="center">为了进一步提高 GitHub 阅览体验这个小目标 ，让大家更方便的畅游 Github，因此诞生了 GayHub。</p>
<p align="center">
   <a href="https://github.com/jawil/GayHub/blob/master/download/gayhub-1.3.crx?raw=true" download><img src="https://img.shields.io/badge/lastest_version-1.0.3-blue.svg"></a>
   <a target="_blank" href="https://chrome.google.com/webstore/detail/gayhub/mdcffelghikdiafnfodjlgllenhlnejl"><img src="https://img.shields.io/badge/download-_chrome_webstore-brightgreen.svg" download></a>
   <a href="https://github.com/jawil/GayHub/blob/master/download/gayhub-1.3.crx?raw=true"><img src="https://img.shields.io/badge/download-_crx-brightgreen.svg" download></a>
</p>

***

### 马上使用：

* [Chrome 应用商店](https://chrome.google.com/webstore/detail/gayhub/mdcffelghikdiafnfodjlgllenhlnejl) 或者 [离线下载](https://github.com/jawil/GayHub/blob/master/download/gayhub-1.3.crx?raw=true) 或者 [下载测试版](https://github.com/jawil/GayHub/blob/master/download/test.crx?raw=true)


### 温馨提示

**请自行忽略下面截图书签栏等不健康网站，为了您的健康，请转移你犀利的目光。1024**

### 主要功能一览：

- **文件目录树：**

给 `github` 插上翅膀，让你轻松切换文件，方便阅读，把 `Vscode` 的精美的侧边栏完美移植到 `github` 上，颜值颇高，`100` 多种精美图标完美移植，加上`Pjax`的无刷新切换文件，体验颇佳。

截图：对于微软的VScode和TypeScript这种大型开源，10000+文件的解析起来也毫无压力，稍等片刻即可打开，颜值与性能并存。

![](http://opb6zkmf0.bkt.clouddn.com/006tNc79gy1fjfyqib2edj30zg0l3dtx.jpg)

 温馨提示：不要打开`Linux`这种巨无霸的开源，因为从`GitHub`接口拉取所有目录文件名数据都需要几分钟。。。
 
- **TOC导航：**  

  为了清晰明了的概览整个`GitHub`文档、`issue`、`wiki`的结构层次，为此开发了这个强大的功能，支持任意层次嵌套，能完美解析内容的所有嵌套标题，性能优越，滑动起来如丝滑般流畅。
  
  截图：不管你嵌套多少层，解析不出来算我输。
  
![006tNc79gy1fjc8ic7g3fj30zd0kzk8d](http://opeokf4uk.bkt.clouddn.com/006tNc79gy1fjc8ic7g3fj30zd0kzk8d.jpg)
 
 - **夜间暗色主题：**  
 
 GitHub的白色主题在晚上稍微有些刺眼，就在stylish上找了一套暗色主题修改一下移植到了github上，喜欢暗色主题可以开启，默认不开启。
 
 截图：透明加暗色，感觉颜值有个提升，因人而异，我还是喜欢亮色的主题，习惯了
 
 ![](http://opb6zkmf0.bkt.clouddn.com/QQ20170914-135012.png)
 

- **图片全屏预览：**

  `GitHub`默认点击图片会跳转到另一个窗口，有时候无意点到也会跳转到另一个页面，体验稍差，为此添加了一个类似知乎点击图片全屏查看的功能
  
  截图：
  
 ![](https://ws2.sinaimg.cn/large/006tNc79gy1fjgkem4rnoj30zi0l2afd.jpg)

- **复制代码：**

  方便的帮助用户实现点击复制代码的功能，告别冗长的移动拖动选中再复制黏贴的繁琐步骤，轻轻一点，`demo`我有。
  
  截图：
  
  ![](http://ovycyj9pr.bkt.clouddn.com/QQ20170908-164449.png)

- **图像展示** 

进入首页，大佬图像一览无余，更清晰直观的看出大佬的各种动态，关注大佬的一举一动，时刻关心最新开源技术。

![](http://opb6zkmf0.bkt.clouddn.com/QQ20170909-105120.png)

### 大屏全貌
在大屏幕下，会展示所有的内容，在mac等小屏幕下默认只显示侧边栏目录树，而TOC默认是隐藏的。

截图：

![1](http://opeokf4uk.bkt.clouddn.com/1.jpg)

###  说明

> 如果对您有帮助，您可以点右上角 "Star" 支持一下 谢谢！ ^_^

> 或者您可以 "follow" 一下，我会不断开源更多的有趣的项目

> 如有问题请直接在 Issues 中提，或者您发现问题并有非常好的解决方案，欢迎 PR 👍

### 许可：
[![license-badge]][license-link]

<!-- Link -->
[www-badge]:        https://img.shields.io/badge/website-_simpread.ksria.com-1DBA90.svg
[www-link]:         http://ksria.com/simpread
[version-badge]:    https://img.shields.io/badge/lastest_version-1.0.3-blue.svg
[version-link]:     https://github.com/kenshin/simpread/releases
[chrome-badge]:     https://img.shields.io/badge/download-_chrome_webstore-brightgreen.svg
[chrome-link]:      https://chrome.google.com/webstore/detail/%E7%AE%80%E6%82%A6-simpread/ijllcpnolfcooahcekpamkbidhejabll
[offline-badge]:    https://img.shields.io/badge/download-_crx-brightgreen.svg
[offline-link]:     http://ksria.com/simpread/crx/1.0.3/simpread.crx
[license-badge]:    https://img.shields.io/github/license/mashape/apistatus.svg
[license-link]:     https://opensource.org/licenses/MIT

**github源码地址：https://github.com/jawil/GayHub**

欢迎测bug和提出你认为需要改进的地方，送截图某论坛邀请码。😁
[![](https://badge.juejin.im/entry/5998f8396fb9a0247c6ec9cd/likes.svg?style=flat)](https://juejin.im/entry/5998f8396fb9a0247c6ec9cd/detail)
**Javascript是一门很吊的语言，我可能学了假的JavaScript，哈哈，大家还有什么推荐的，补充送那啥邀请码。**

**本文秉承着：你看不懂是你SB，我写的代码就要牛逼。**

### 1、单行写一个评级组件
"★★★★★☆☆☆☆☆".slice(5 - rate, 10 - rate);定义一个变量rate是1到5的值，然后执行上面代码，看图

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipc4o8jujj30dx0fqjs7.jpg)

才发现插件什么的都弱爆了

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipi6xsa7uj306o06odg0.jpg)
来源：[来自知乎用户蜗牛老湿的回答](https://www.zhihu.com/question/46943112/answer/113583615)

### 2、如何装逼用代码骂别人SB

```JavaScript
(!(~+[])+{})[--[~+""][+[]]*[~+[]] + ~~!+[]]+({}+[])[[~!+[]]*~+[]]
```
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fiph82ae7xj30f803gaab.jpg)
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipim72hyxj306j03pglk.jpg)
了解为什么请移步：[一行能装逼的JavaScript代码](http://www.jfh.com/jfperiodical/article/3224)

### 3、如何用代码优雅的证明自己NB
这个牛逼了

```JavaScript
	console.log(([][[]]+[])[+!![]]+([]+{})[!+[]+!![]])
```
![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipdkgl7myj30ch045aaa.jpg)

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipiacsfkfj30bo0agjrg.jpg)

### 4、JavaScript 错误处理的方式的正确姿势
😂😂😂，舅服你

```JavaScript
try {
    something
} catch (e) {
    window.location.href =
        "http://stackoverflow.com/search?q=[js]+" +
        e.message;
}
```
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipc7jv37sj30c809lq36.jpg)

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipic015pij307d05at8m.jpg)

### 5、从一行代码里面学点JavaScript

```JavaScript
[].forEach.call($$("*"),function(a){
    a.style.outline="1px solid #"+(~~(Math.random()*(1<<24))).toString(16)
})
```
翻译成正常语言就是这样的

```JavaScript
Array.prototype.forEach.call(document.querySelectorAll('*'), 
dom => dom.style.outline = `1px solid #${parseInt(Math.random() * 
Math.pow(2,24)).toString(16)}`)
```

接下来在浏览器控制看看：something magic happens

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipgsovd4dj30xa0eln0f.jpg)
![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipip3xx44j30go097mxf.jpg)
具体分析请参见这篇文章：[从一行代码里面学点JavaScript](https://sdk.cn/news/3025)

### 6、论如何优雅的取随机字符串

```JavaScript
Math.random().toString(16).substring(2) 
Math.random().toString(36).substring(2) 
```
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipckf384pj309803tt91.jpg)

### 7、\(10\)\["toString"\]\(\) === "10"
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fiphohmxl9j309f0570sx.jpg)
解析请移步：[js奇淫技巧1](http://qylanikin.lofter.com/post/1cbb3f55_cc787c9)

### 8、匿名函数自执行
这么多写法你选择哪一种？我选择死亡。

```JavaScript
( function() {}() );
( function() {} )();
[ function() {}() ];

~ function() {}();
! function() {}();
+ function() {}();
- function() {}();

delete function() {}();
typeof function() {}();
void function() {}();
new function() {}();
new function() {};

var f = function() {}();

1, function() {}();
1 ^ function() {}();
1 > function() {}();
// ...
```
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipirtvdxnj30iu0g80tl.jpg)

### 9、另外一种undefined
从来不需要声明一个变量的值是undefined，因为JavaScript会自动把一个未赋值的变量置为undefined。所有如果你在代码里这么写，会被鄙视的

```JavaScript
var data = undefined;
```
但是如果你就是强迫症发作，一定要再声明一个暂时没有值的变量的时候赋上一个undefined。那你可以考虑这么做：

```JavaScript
 var data = void 0; // undefined
```
void在JavaScript中是一个操作符，对传入的操作不执行并且返回undefined。void后面可以跟()来用，例如void(0)，看起来是不是很熟悉？没错，在HTML里阻止带href的默认点击操作时，都喜欢把href写成javascript:void(0)，实际上也是依靠void操作不执行的意思。

当然，除了出于装逼的原因外，实际用途上不太赞成使用void，因为void的出现是为了兼容早起ECMAScript标准中没有undefined属性。void 0的写法让代码晦涩难懂。
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fiph76wloqj30dw0ai0ta.jpg)

### 10、论如何优雅的取整

```JavaScript
var a = ~~2.33

var b= 2.33 | 0

var c= 2.33 >> 0
```
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipcqcollxj308z05g74e.jpg)

### 11、如何优雅的实现金钱格式化：1234567890 --> 1,234,567,890
用正则魔法实现：

```JavaScript
var test1 = '1234567890'
var format = test1.replace(/\B(?=(\d{3})+(?!\d))/g, ',')

console.log(format) // 1,234,567,890
```
非正则的优雅实现：

```JavaScript
 function formatCash(str) {
       return str.split('').reverse().reduce((prev, next, index) => {
            return ((index % 3) ? next : (next + ',')) + prev
       })
}
console.log(formatCash('1234567890')) // 1,234,567,890
```
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipivjpb63j306o05lmzr.jpg)

###  12、这个我服，还有这个你很机智
我服

```JavaScript
while (1) {
    alert('牛逼你把我关了啊')
}
```
你很机智，好一个障眼法

```html
清除缓存： <a href="javascript:alert('清除成功');">清除缓存</a>
```
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipiexe82vj307o053746.jpg)

### 13、逗号运算符

```JavaScript
var a = 0; 
var b = ( a++, 99 ); 
console.log(a);  // 1
console.log(b);  // 99
```
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipetbjrkwj30d204v0t1.jpg)

### 14、论如何最佳的让两个整数交换数值
常规办法：

```JavaScript
var a=1,b=2;
a += b;
b = a - b;
a -= b;
```
缺点也很明显，整型数据溢出，对于32位字符最大表示数字是2147483647，如果是2147483645和2147483646交换就失败了。
黑科技办法：

```JavaScript
a ^= b;
b ^= a;
a ^= b;
```
![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipd3k9c8zj309706cwen.jpg)

哈哈😄，看不懂的童鞋建议去补习一下C语言的位操作，我就不去复习了，以前学嵌入式时候学的位操作都忘了

### 15、实现标准JSON的深拷贝

```JavaScript
var a = {
    a: 1,
    b: { c: 1, d: 2 }
}
var b=JSON.parse(JSON.stringify(a))
```
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipfjzx1w9j30bc06dt93.jpg)

不考虑IE的情况下，标准JSON格式的对象蛮实用，不过对于undefined和function的会忽略掉。

### 16、不用Number、parseInt和parseFloat和方法把"1"字符串转换成数字
哈哈，不准用强制类型转换，那么就想到了强大了隐式转换

```JavaScript
var a =1 
+a
```
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipdb6yztnj307y04h3yj.jpg)

### 17、如何装逼的写出"hello world!"

滚动条很长哦😯

```JavaScript
([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[+[]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[])+(!+[]+!![]+!![]+!![]+!![]+!![]+!![]+[]))+([]+{})[+!![]]+(!![]+[])[+!![]]+(![]+[])[!+[]+!![]]+([][[]]+[])[!+[]+!![]]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[+[]]+([][[]]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()([][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(![]+[])[!+[]+!![]+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+([]+[][(![]+[])[!+[]+!![]+!![]]+([]+{})[+!![]]+(!![]+[])[+!![]]+(!![]+[])[+[]]][([]+{})[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]]+(![]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+[]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(!![]+[])[+[]]+([]+{})[+!![]]+(!![]+[])[+!![]]]((!![]+[])[+!![]]+([][[]]+[])[!+[]+!![]+!![]]+(!![]+[])[+[]]+([][[]]+[])[+[]]+(!![]+[])[+!![]]+([][[]]+[])[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]+!![]+!![]]+(![]+[])[!+[]+!![]]+([]+{})[+!![]]+([]+{})[!+[]+!![]+!![]+!![]+!![]]+(+{}+[])[+!![]]+(!![]+[])[+[]]+([][[]]+[])[!+[]+!![]+!![]+!![]+!![]]+([]+{})[+!![]]+([][[]]+[])[+!![]])())[!+[]+!![]+!![]]+([][[]]+[])[!+[]+!![]+!![]])()(([]+{})[+[]])[+[]]+(!+[]+!![]+[])+(+!![]+[]))
```
居然能运行，牛逼的隐式转换
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipe2e4w5wj30hs08ota4.jpg)
![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipixk4m50j309z078mxt.jpg)

### 18、parseInt(0.0000008) === 8
![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipbwrvnq0j307i03pmx8.jpg)

![](https://ws4.sinaimg.cn/large/006tKfTcgy1fipigonkitj307e074t92.jpg)

### 19、++[[]][+[]]+[+[]] == 10
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipbyod0sxj308y04smx8.jpg)

强大的隐式转换，23333

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipihgatwvj3069069jra.jpg)

### 20、0.1 + 0.2 == 0.3

![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipc0vvbnsj306l03rglm.jpg)

`0.1 +0.2 == 0.3` 竟然是不成立的。。。。所以这就是为什么数据库存储对于货币的最小单位都是分。

简单说，`0.1`和`0.2`的二进制浮点表示都不是精确的，所以相加后不是`0.3`，接近（不等于）
`0.30000000000000004`。

所以，比较数字时，应该有个宽容值。ES6中这个宽容值被预定义了：`Number.EPSILON`。

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipiiub4lqj3068061a9x.jpg)

### 21、最短的代码实现数组去重

```JavaScript
[...new Set([1, "1", 2, 1, 1, 3])]
```
前不久面试阿里就问了这道题，哈哈，所以也写上一下

![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipecc1ftkj30a603tglr.jpg)

### 22、用最短的代码实现一个长度为m(6)且值都n(8)的数组

```JavaScript
Array(6).fill(8)
```
这个够短了吧，好像是当初哪里看到的一个面试题，就自己想到了ES6的一些API

![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipehmuow7j30a604ft8u.jpg)


### 23、短路表达式
条件判断

```JavaScript
var a = b && 1
    // 相当于
if (b) {
    a = 1
} else {
    a = b
}

var a = b || 1
    // 相当于
if (b) {
    a = b
} else {
    a = 1
}
```
### 24、JavaScript版迷宫
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipe4dm5zuj30go08ogmd.jpg)
逃出迷宫，2333
![](https://ws2.sinaimg.cn/large/006tKfTcgy1fipizki4i1g30c80c874n.gif)

### 25、取出一个数组中的最大值和最小值

```JavaScript
var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411]; 
var maxInNumbers = Math.max.apply(Math, numbers); 
var minInNumbers = Math.min.apply(Math, numbers);
```
![](https://ws3.sinaimg.cn/large/006tKfTcgy1fipelb9ry7j30dt062q3j.jpg)

### 26、将argruments对象转换成数组

```JavaScript
var argArray = Array.prototype.slice.call(arguments);

或者ES6：

var argArray = Array.from(arguments)
```

### 27、javascript高逼格之Function构造函数
很多JavaScript教程都告诉我们，不要直接用内置对象的构造函数来创建基本变量，例如var arr = new Array(2); 的写法就应该用var arr = [1, 2];的写法来取代。

但是，Function构造函数（注意是大写的Function）有点特别。Function构造函数接受的参数中，第一个是要传入的参数名，第二个是函数内的代码（用字符串来表示）。

```JavaScript
var f = new Function('a', 'alert(a)');
f('jawil'); // 将会弹出窗口显示jawil
```
这种方式可以根据传入字符串内容来创建一个函数 是不是高大上？！
![](https://ws1.sinaimg.cn/large/006tKfTcgy1fipj2ajcxmj3051054q2y.jpg)

### 28、从一个数组中找到一个数，O(n)的算法，找不到就返回 null。
正常的版本:

```JavaScript
function find (x, y) {
  for ( let i = 0; i < x.length; i++ ) {
    if ( x[i] == y ) return i;
  }
  return null;
}
 
let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
```
结果到了函数式成了下面这个样子（好像上面的那些代码在下面若影若现，不过又有点不太一样，为了消掉if语言，让其看上去更像一个表达式，动用了 ? 号表达式）：

```JavaScript
//函数式的版本
const find = ( f => f(f) ) ( f =>
  (next => (x, y, i = 0) =>
    ( i >= x.length) ?  null :
      ( x[i] == y ) ? i :
        next(x, y, i+1))((...args) =>
          (f(f))(...args)))
 
let arr = [0,1,2,3,4,5]
console.log(find(arr, 2))
console.log(find(arr, 8))
```
[如何读懂并写出装逼的函数式代码](http://coolshell.cn/articles/17524.html)

**最后奉劝大家一句：莫装逼、白了少年头，2333。。。原文收录在我的 GitHub博客 (https://github.com/jawil/blog) ，喜欢的可以关注最新动态，大家一起多交流学习，共同进步，以学习者的身份写博客，记录点滴。**

一般阿里社招都是招3-5年的P6+高级工程师，当初自己一年经验也没有想过有这个面试机会。

虽然没想着换工作，但是经常关注一些招聘网站的信息，某一天，在某boss上有个人找我，叫我发一下简历，我一看是阿里的某技术专家，虽然之前也有阿里的在某boss上给我要简历，但是我深知自己经验不足，然后给boss说我是16届的，只有一年经验，然后就没有然后了。这次我依然这么回复，但是这boss说，没关系，他喜欢基础好的，让我可以试一试，于是我也抱着试一试的心态发了简历。

简历发过去之后，boss就给我打了电话，让我简单的介绍一下自己，我就噼里啪啦说了一些，还说了一些题外话。然后boss就开始问我问题。

由于面了四轮，所以最开始的面试记忆有点模糊了，细细回想，又感觉记忆犹新。

### 1.电话初探
#### 1.说一下你了解CSS盒模型。
我就说了一下IE的怪异盒模型和标注浏览器的盒模型，然后可以通过box-sizing属性控制两种盒模型的变换。

#### 2.说一下box-sizing的应用场景。
这个也不难，简单说了一两个应用场景，具体就不一一细说了。

#### 3.说一下你了解的弹性FLEX布局.
这个我也比较了解，各种概念和属性能想到的说了一大堆，也扯到了Grid布局，基本这个也没啥问题。

#### 4.说一下一个未知宽高元素怎么上下左右垂直居中。
说了一下flex弹性布局的实现，说了一下兼容性，扯到了postcss的一些东西，然后说了一下常规的兼容性比较好的实现。

#### 5.说一下原型链，对象，构造函数之间的一些联系。
这个我之前写过相关的文章，自己也有比较深入的理解，所以这个也不在话下，噼里啪啦说了一大堆，也不知道面试官听得咋样。

#### 6.DOM事件的绑定的几种方式
说了三种，然后说了一些冒泡，默认事件，以及DOM2，DOM3级的一些标准。

#### 7.说一下你项目中用到的技术栈，以及觉得得意和出色的点，以及让你头疼的点，怎么解决的。
这个因人而异，开放性问题，主要考察平时项目的一些积累吧，这个我回答感觉也比较ok。

#### 8.有没有了解http2.0,websocket,https，说一下你的理解以及你所了解的特性。
这个我看过一些文章，但是没有什么印象，扯了一些概念，但是回答的不是很深。

**第一轮电话初探，大约面了50分钟，就记起来这么多，还有一些细节问题可能淡忘了，总体来说，面的都是以基础为主，然后boss说把我简历推荐给内部，进行正式的社招流程。**

### 一轮技术面
然后当天晚上一个女的面试官就给我打电话了，说八点半进行下一轮技术面试，没想到效率这么快，我都没怎么准备。
这次就直接省略自我介绍了。

#### 1.webpack的入口文件怎么配置，多个入口怎么分割啥的，我也没太听清楚。
这个自己就说了一下自己的理解，以及自己用node写的多入口怎么配置，然后面试官说不是多入口配置，然后我又说了一下自己的理解，然后这题就过了。

#### 2.我看到你的项目用到了Babel的一个插件：transform-runtime以及stage-2，你说一下他们的作用。
这个我也还算比较了解，就说了一下ES的一些API，比如generator啥的默认不转换，只转换语法，需要这个来转换，然后说profill啥的，扯了一下stage-1，stage-2，stage-3，这个问题回答还算清楚。

#### 3.我看到你的webpack配置用到webpack.optimize.UglifyJsPlugin这个插件，有没有觉得压缩速度很慢，有什么办法提升速度。
这个我主要回答了一下，我之前也没怎么了解，一个想到是缓存原理，压缩只重新压缩改变的，还有就是减少冗余的代码，压缩只用于生产阶段，然后面试官问还有呢？我就说，还可以从硬件上提升，可以得到质的飞跃，比如换台I9处理器的电脑。。。。

#### 4.简历上看见你了解http协议。说一下200和304的理解和区别
这个噼里啪啦说了一堆，协商缓存和强制缓存的区别，流程，还有一些细节，提到了expires,Cache-Control,If-none-match,Etag,last-Modified的匹配和特征，这一块之前有过比较详细的了解，所以还是应答如流。

#### 5.DOM事件中target和currentTarget的区别
这个没答上来。。。

#### 6.说一下你平时怎么解决跨域的。以及后续JSONP的原理和实现以及cors怎么设置。
我就说了一下Jason和cors,然后问我JSONP的原理以及cors怎么设置，这一块自己也实践过，所以还是对答如流的。

#### 7.说一下深拷贝的实现原理。
这个也还好，就是考虑的细节不是很周全，先是说了一种JSON.stringify和JSON.parse的实现，以及这种实现的缺点，主要就是非标准JSOn格式无法拷贝以及兼容性问题，然后问了我有么有用过IE8的一个什么JSON框架，我也不记得是什么了，因为我压根没听过，然后说了一下尾递归实现深拷贝的原理，还问了我**typeof null是啥**，这个当然是Object。。。

#### 8.说一下项目中觉得可以改进的地方以及做的很优秀的地方？
这个也是因人而异，开放性问题，大致扯了一下自己的经历，也还OK。

**最后问了有什么需要问的地方，面试到这里基本就结束了，大约面了一个多钟头，还是蛮累的。总体来说，回答的广度和深度以及细节都还算OK，觉得这轮面试基本没什么悬念。**


### 二轮技术面
过了几天，接到阿里另一个面试官的电话，上一轮面试通过了，这次是二轮技术面，说估计一个钟头。这次依然跳过自我介绍之类的，直奔主题。

#### 1.有没有自己写过webpack的loader,他的原理以及啥的，记得也不太清楚。
这个我就说了一下，然后loader配置啥的，也还ok。

#### 2.有没有去研究webpack的一些原理和机制，怎么实现的。
这个我简单说了一下我自己了解的，因为这一块我也没深入去研究，所以说的应该比较浅。

#### 3.babel把ES6转成ES5或者ES3之类的原理是什么，有没有去研究。
这一块我说了一下自己的思路，大致也还OK，我也没去深入研究怎么转换的，之前好像看过类似的文章，自己也只观察过转换之后的代码是啥样的，至于怎么转换的规则，真的没去深入观察。

#### 4.git大型项目的团队合作，以及持续集成啥的。
这里我就说了一下自己了解的git flow方面的东西，因为没有实战经验，所以我就选择性说明了这一块的不熟练，然后面试官也没细问。

#### 5.什么是函数柯里化？以及说一下JS的API有哪些应用到了函数柯里化的实现？
这个我就说了一下函数柯里化一些了解，以及在函数式编程的应用，最后说了一下JS中bind函数和数组的reduce方法用到了函数柯里化。

#### 6.ES6的箭头函数this问题，以及拓展运算符。
这一块主要是API和概念的问题，扯了一些规范以及严格模式下其他情况this只想问题。

#### 7.JS模块化Commonjs,UMD,CMD规范的了解，以及ES6的模块化跟其他几种的区别，以及出现的意义。
这个也是说了一下自己的理解和认知，自己对模块化历史以及一些规范都有所涉猎，这一块也还凑合。

#### 8.说一下Vue实现双向数据绑定的原理，以及vue.js和react.js异同点，如果让你选框架，你怎么怎么权衡这两个框架，分析一下。
主要是发布订阅的设计模式，还有就是ES5的Object.defineProperty的getter和setter机制，然后顺便扯了一下Angular的脏检测，以及alvon.js最先用到这种方式。然后扯了一下vue.js和react.js异同点，权衡框架选择，调研分析之类，噼里啪啦说了一大堆。

#### 9.我看你也写博客，说一下草稿的交互细节以及实现原理。
这一款就按照自己用过简书或者掘金，SG这类草稿的体验，详细说了一下，这个开放性问题，说到点基本就OK。

**最后面试官问我有什么想问的吗，面试到这里基本就结束了，差不多面了一个小时，说过几天就会给答复，如果过了就会去阿里园区进行下一轮的技术面。**

### 三轮技术面
上一轮发挥感觉没前两轮发挥好，所以还是有点不自信的，没想到第三天后，就来电话了，通知我去阿里园区面试。

因为阿里西溪园区距离我不到十公里，我就踩着共享单车一点钟就出发了，天气比较热，飘在路上，百感交集，身边一辆法拉利轰鸣而过，又一辆兰博基尼呼啸而过，我心里一万头草泥马奔腾，MLGB，心里暗想，为神马开这车的人不是此刻看文章的你？

走到半路了，面试官给我打电话了，说我怎么还没到，说约定的是两点钟，我一下子就懵逼了，短信只有一个游客访问ID，并没有通知我具体时间，反正不管谁的疏忽，我肯定是要迟到了，于是我快马加鞭，踩着贼难骑的共享单车，背着微风，一路狂奔，到阿里园区已是汗流浃背，油光满面，气喘乎乎。。。

面试迟到了，印象肯定不好，加上满头大汗的形象也不太好，加上自己饥渴难耐，这面是估计要GG了，一进来就直奔主题，这次是两个大Boss面试我。

#### 第一个面试官
#### 1.先自我介绍一下，说一下项目的技术栈，以及项目中遇到的一些问题啥的。
这个问题就是个开场白，简要说明一下，问题都不大，这个面试官就是第一次打电话给我面试的那个boss，所以技术那块boss心里也有个底细，所以没再问技术问题。

#### 2.一个业务场景，面对产品不断迭代，以及需求的变动该怎么应对，具体技术方案实现。

具体业务场景，我就不一一描述，Boss在白板上画了一个大致的模块图，然后做了一些需求描述。
然后需求一层一层的改变，然后往下挖，主要是考察应对产品能力，以及对代码的可维护性和可拓展性这些考察，开放性问题，我觉得还考察一些沟通交流方面的能力，因为有些地方面试官故意说得很含糊，反正就是一个综合能力，以及对产品的理解，中间谈到怎么实现，也问到了一些具体的点，记得问到的有一下几个。
>**① 怎么获取一个元素到视图顶部的距离。**
>**② getBoundingClientRect获取的top和offsetTop获取的top区别**
>**③事件委托**

#### 第二个面试官
#### 1.业务场景：比如说百度的一个服务不想让阿里使用，如果识别到是阿里的请求，然后跳转到404或者拒绝服务之类的？
主要是考察http协议头Referer，然后怎么判断是阿里的ip或者啥的，我也不太清楚。

#### 2.二分查找的时间复杂度怎么求，是多少
。。。排序的还算清楚一点，查找真的不知所措，没回答上来，也没猜，意义不大，不会就是不会。

#### 3.XSS是什么，攻击原理，怎么预防。
这个很简单，跨站脚本攻击XSS(cross site scripting)，攻击类型主要有两种：反射型和存储型，简单说了一下如何防御：
>**①转义**
>**②DOM解析白名单**
>**③第三方库**
>**④CSP**

自己对`web`安全这块系统学习过，前前后后大约了解了很多，对于`XSS`,`CSRF`,`点击劫持`，`Cookie安全`，`HTTP窃听篡改`，`密码安全`，`SQL注入`，`社会工程学`都有一定了解，所以这个自然也不在话下。

#### 4.线性顺序存储结构和链式存储结构有什么区别？以及优缺点。
我是类比JS数组和对象来回答的，反正还算凑合吧，自己都数据结构这块多少还是有些印象，所以入了前端，对数据结构和算法确实一直淡忘了。

#### 5.分析一下移动端日历，PC端日历以及桌面日历的一些不同和需要注意的地方。
这个我能想到的大致都说了一遍，不同的场景交互和细节以及功能都有所偏差，以及功能的侧重都可能不同。

#### 6.白板写代码，用最简洁的代码实现数组去重。
我写了两种实现方式：
ES6实现：

```JavaScript
[...new Set([1,2,3,1,'a',1,'a'])]
```
ES5实现：

```JavaScript
[1,2,3,1,'a',1,'a'].filter(function(ele,index,array){
    return index===array.indexOf(ele)
})
```

#### 7.怎么实现草稿，多终端同步，以及冲突问题？
这个回答的不算好，本来也想到类比git的处理方式，但是说的时候往另外一个方面说了，导致与面试官想要的结果不一样。


**最后说目前的工作经验达不到P6水平，业务类稍弱，阿里现在社招只要P6的高级工程师，但是可以以第二梯队进去，就是以第三方签署就业协议，一年后可以转正，就是俗称的外包。多少还是有点遗憾，面了四轮面了个外包，最后放弃这份工作了。**

**最后，感谢boss一直以来的关照和器重。**







**最近看了很多这方面的文章，能搜到的基本看了个遍，但感觉还是似懂非懂，知道这个东西，很难说出这是个什么东西，先整理一些概念，慢慢消化，以后慢慢探索其中的原因。**
### 1、PX(CSS pixels)
#### 1.1 定义
>**虚拟像素**，可以理解为“直觉”像素，`CSS`和`JS`使用的抽象单位，浏览器内的一切长度都是以`CSS`像素为单位的，`CSS`像素的单位是**px**。 

#### 1.2 注意
在`CSS`规范中，长度单位可以分为两类，绝对(`absolute`)单位以及相对(`relative`)单位。`px`是一个**相对单位**，相对的是设备像素(`device pixel`)。

在同样一个设备上，每1个CSS像素所代表的物理像素是可以变化的(**即CSS像素的第一方面的相对性**); 
  
在不同的设备之间，每1个CSS像素所代表的物理像素是可以变化的(**即CSS像素的第二方面的相对性**);


#### 1.3 那么PX到底是什么？
`px`实际是`pixel`（像素）的缩写，根据 [维基百科](https://zh.wikipedia.org/wiki/%E5%83%8F%E7%B4%A0)的解释，**它是图像显示的基本单元，既不是一个确定的物理量，也不是一个点或者小方块，而是一个抽象概念**。所以在谈论像素时一定**要清楚它的上下文**！一定要清楚它的上下文！一定要清楚它的上下文！

不同的设备，图像基本采样单元是不同的，显示器上的物理像素等于显示器的点距，而打印机的物理像素等于打印机的墨点。而衡量点距大小和打印机墨点大小的单位分别称为`ppi`和`dpi`：

**ppi**：每英寸多少像素数，放到显示器上说的是每英寸多少物理像素及显示器设备的点距。

**dpi**：每英寸多少点。

关于打印机的点距我们不去关心，只要知道 **当用于描述显示器设备时ppi与dpi是同一个概念** 。

#### 1.4 CSS像素的真正含义
由于不同的物理设备的物理像素的大小是不一样的，所以`css`认为浏览器应该对`css`中的像素进行调节，使得浏览器中 1css像素的大小在不同物理设备上看上去大小总是差不多 ，目的是为了保证阅读体验一致。为了达到这一点浏览器可以直接按照设备的**物理像素**大小进行换算，而`css`规范中使用**"参考像素"**来进行换算。

**1参考像素**即为从一臂之遥看解析度为`96DPI`的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。它并不是1/96英寸长度，而是从一臂之遥的距离处看解析度为`96DPI`的设备输出一单位（即1/96英寸）时视线与水平线的夹角。通常认为常人臂长为28英寸，所以它的视角是:
**(1/96)in / (28in * 2 * PI / 360deg) = 0.0213度。**

由于`css`像素是一个**视角单位**，所以在真正实现时，为了方便基本都是根据**设备像素**换算的。浏览器根据硬件设备能够直接获取`css`像素

#### 1.5 举个栗子来理解css像素的相对性
作为Web开发者，我们接触的更多的是用于控制元素样式的样式单位像素。这里的像素我们称之为CSS像素。

CSS像素有什么特别的地方？我们可以借用[quirksmode](http://www.quirksmode.org/mobile/viewports.html)中的这个例子：

假设我们用PC浏览器打开一个页面，浏览器此时的宽度为800px，页面上同时有一个400px宽的块级元素容器。很明显此时块状容器应该占页面的一半。

但如果我们把页面放大（通过“Ctrl键”加上“+号键”），放大为200%，也就是原来的两倍。此时块状容器则横向占满了整个浏览器。

吊诡的是此时我们既没有调整浏览器窗口大小，也没有改变块状元素的css宽度，但是它看上去却变大了一倍——这是因为我们把CSS像素放大为了原来的两倍。

CSS像素与屏幕像素1：1同样大小时：

![](http://imglf2.ph.126.net/U8rd2OugqE3QTmmIjeymtA==/6630788489746091618.gif)  

CSS像素(黑色边框)开始被拉伸，此时1个CSS像素大于1个屏幕像素

![](http://imglf2.ph.126.net/OVUK3NwQXcVkh3qSvzwOPA==/6630482825513296967.gif)  

也就是说默认情况下一个CSS像素应该是等于一个物理像素的宽度的，但是浏览器的放大操作让一个CSS像素等于了两个设备像素宽度。在后面你会看到更复杂的情况，在高PPI的设备上，CSS像素甚至在默认状态下就相当于多个物理像素的尺寸。

**从上面的例子可以看出，CSS像素从来都只是一个相对值。**


### 2、DP(device pixels)
#### 2.1 定义
>**设备像素（物理像素）**，顾名思义，显示屏是由一个个**物理像素**点组成的，通过控制每个像素点的颜色，使屏幕显示出不同的图像，屏幕从工厂出来那天起，它上面的**物理像素点**就固定不变了，单位**pt**。

#### 2.2 注意
**`pt`在`css`单位中属于真正的绝对单位，`1pt = 1/72(inch)`,`inch`及英寸，而1英寸等于2.54厘米。**

不同的设备，其图像基本单位是不同的，比如显示器的点距，可以认为是显示器的**物理像素**。现在的液晶显示器的点距一般在`0.25mm`到`0.29mm`之间。而打印机的墨点，也可以认为是打印机的物理像素，`300DPI`就是`0.085mm`，`600DPI`就是`0.042mm`。 

注意，我们通常所说的**显示器分辨率**，其实是指**桌面设定的分辨率**，而不是显示器的**物理分辨率**。只不过现在液晶显示器成为主流，由于液晶的显示原理与`CRT`不同，只有在桌面分辨率与物理分辨率一致的情况下，显示效果最佳，所以现在我们的桌面分辨率几乎总是与显示器的物理分辨率一致了。 

#### 2.3 小知识
小知识:屏幕普遍采用RGB色域(红、绿、蓝三个子像素构成),而印刷行业普遍使用CMYK色域(青、品红、黄和黑)

![](http://opeokf4uk.bkt.clouddn.com/1.jpeg)

#### 2.4 设备像素(DP)与CSS像素之间的关系
获得设备像素比（dpr）后，便可得知设备像素与CSS像素之间的比例。当这个比率为1:1时，使用1个设备像素显示1个CSS像素。当这个比率为2:1时，使用4个设备像素显示1个CSS像素，当这个比率为3:1时，使用9（3*3）个设备像素显示1个CSS像素。
所以，有如下公式：
>**DPR = 设备像素/CSS像素**

 
### 3、DIP(Device independent Pixel)
设备独立像素，也称为逻辑像素，简称`dip`。
根据上述设备像素与`CSS`像素之间的关系、及`DPR`的官方定义，我们可以推断出：
>**CSS像素 =设备独立像素 = 逻辑像素**

下面，还是引用 http://www.cnblogs.com/2050/p/3877280.html 文中的内容说明：

在移动端浏览器中以及某些桌面浏览器中，window对象有一个`devicePixelRatio`属性，它的官方的定义为：设备物理像素和设备独立像素的比例，也就是 **devicePixelRatio = 物理像素 / 独立像素**。 
`CSS`像素就可以看做是设备的独立像素，所以通过`devicePixelRatio`，我们可以知道该设备上一个`css`像素代表多少个物理像素。例如，在`Retina`屏的`iphone`上，`devicePixelRatio`的值为2，也就是说1个`css`像素相当于2个物理像素。但是要注意的是，`devicePixelRato`在不同的浏览器中还存在些许的兼容性问题，所以我们现在还并不能完全信赖这个东西，具体的情况可以看下[这篇文章](https://www.quirksmode.org/blog/archives/2012/06/devicepixelrati.html)。

为什么是“每四个一组”？而且要让这四个一组来显示“原来屏幕的一个像素”？这大概就是 Retina 显示技术的一种表现吧。而这“每四个一组”的“大像素”，可以被称作“设备独立像素”，`device independent pixel` ，或者 `density-independentpixel` ，它可以是系统中的一个点，这个点代表一个可以由程序使用的虚拟像素，然后由相关系统转换为物理像素。

“设备独立像素”也有人称为“CSS像素”，一种形象的说法，更倾向于表明与 `CSS` 中尺寸的对应。

设备独立像素与物理像素的对应关系，可以这样看：

![](https://ws3.sinaimg.cn/large/006tNc79gy1fg9dtxn9lzj30dw05raar.jpg)

类似的每四个一组的对应关系，也许正是 `Retina` 显示技术所做的。


### 4、DPR(device pixels ratio)
#### 4.1 定义
>**设备像素比（dpr** 描述的是未缩放状态下，`物理像素`和`CSS像素`的初始比例关系，计算方法如下图。

![](http://7xvh1r.com1.z0.glb.clouddn.com/dpr.png)

#### 4.2 理解
**设备像素比(dpr)** 是指在移动开发中1个css像素占用多少设备像素，如2代表1个css像素用2x2个设备像素来绘制。

**设备像素比(dpr)**，公式为`1px = (dpr)^2 * 1dp`，可以理解为1px由多少个设备像素组成；

![](https://lizhiyao.github.io/2017/04/01/viewport/device%20pixel%20and%20css%20pixel.png)

### 5、PPI(pixels per inch)
#### 5.1 定义
>**每英寸像素取值**，更确切的说法应该是像素密度，也就是衡量单位物理面积内拥有像素值的情况。

#### 5.2 ppi是如何计算出来的呢？  
顾名思义，每英寸的像素点（设备像素），已知屏幕分辨率和主对角线的尺寸，则`ppi`等于
以爱疯6为例：
![](http://upload-images.jianshu.io/upload_images/1993435-b7fcee1a41b997f3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

```
var 斜边尺寸 = V(1920^2+1080^2) V代表开根号 
var ppi = 斜边尺寸/5.5 
ppi = 401ppi
```
![](https://ws1.sinaimg.cn/large/006tNbRwgy1fg8jp0e051j30sw07ojsa.jpg)

**我们知道，ppi越高，每英寸像素点越多，图像越清晰；我们可以类比物体的密度，密度越大，单位体积的质量就越大，ppi越高，单位面积的像素越多。**

#### 5.3 ppi和dpr到底什么关系？
毕竟这些参数是外国人先发明的，他们会优先选择自己熟悉的计量单位作为显示设备的工厂标准参数，因此`ppi`就用作显示设备的工业标准；

告诉业界人士，`ppi`达到多少是高清屏，此时对应的dpr是多少，而不直接告诉你我现在的显示设备`dpr`是多少，**毕竟人们直接听到像素分辨率会更加有反应。**

**设备像素比与ppi相关，一般是ppi/160的整数倍：**

![](https://ws3.sinaimg.cn/large/006tNbRwgy1fg8jey6lffj30hu04cmy4.jpg)



### 6、倍率与逻辑像素
#### 6.1 基本关系
![](https://ws1.sinaimg.cn/large/006tNbRwgy1fg99m0t4h9j30m80gojr7.jpg)
用iPhone 3gs和4s来举例。假设有个邮件列表界面，我们不妨按照PC端网页设计的思维来想象。3gs上大概只能显示4-5行，4s就能显示9-10行，而且每行会变得特别宽。但两款手机其实是一样大的。如果照这种方式显示，3gs上刚刚好的效果，在4s上就会小到根本看不清字。
![](https://ws4.sinaimg.cn/large/006tNbRwgy1fg99mqyzcej30m80b4jrs.jpg)
在现实中，这两者效果却是一样的。这是因为Retina屏幕把2x2个像素当1个像素使用。比如原本44像素高的顶部导航栏，在`Retina`屏上用了88个像素的高度来显示。导致界面元素都变成2倍大小，反而和3gs效果一样了。画质却更清晰。

在以前，iOS应用的资源图片中，同一张图通常有两个尺寸。你会看到文件名有的带@2x字样，有的不带。其中不带@2x的用在普通屏上，带@2x的用在`Retina`屏上。只要图片准备好，iOS会自己判断用哪张，`Android`道理也一样。

由此可以看出，苹果以普通屏为基准，给`Retin`a屏定义了一个2倍的倍率（`iPhone 6plus`除外，它达到了3倍）。实际像素除以倍率，就得到逻辑像素尺寸。只要两个屏幕逻辑像素相同，它们的显示效果就是相同的。

#### 6.2 Retina显示屏
这是一种显示技术，可以将把更多的像素点压缩至一块屏幕里，从而达到更高的分辨率并提高屏幕显示的细腻程度，这种分辨率在正常观看距离下足以使人肉眼无法分辨其中的单独像素。

最先使用`retina`屏幕是iphone 4，屏幕分辨率为960 * 640（326ppi）。

对比如下两幅图，可以清晰地看出是否 `Retina` 屏的显示差异： 
![](https://ws3.sinaimg.cn/large/006tNc79gy1fg9dnuekaqj30bo07s3z4.jpg)
图2  iPhone 3GS

![](https://ws1.sinaimg.cn/large/006tNc79gy1fg9dob0dn0j30bo07st9i.jpg)  
图3  iPhone 4

两代iPhone 的物理尺寸（屏幕宽高有多少英寸）是一样的，从上图可以看出，iphone 4的显示效果要明显好于iphone 3GS，虽然 iPhone 4 分辨率提高了，但它不同于普通的电脑显示器那样为了显示更多的内容，而是提升显示相同内容时的画面精细程度。这种提升方式是靠提升单位面积屏幕的像素数量，即像素密度来提升分辨率，这样做的主要目的是为了提高屏幕显示画面的精细程度。以第三代 `MacBook Pro with Retina Display`为例， 工作时显卡渲染出的2880x1880个像素每四个一组，输出原来屏幕的一个像素显示的大小区域内的图像。这样一来，用户所看到的图标与文字的大小与原来的1440x900分辨率显示屏相同，但精细度是原来的4倍。

注意：在桌面显示器中，我们调整了显示分辨率，比如从 800 * 600 调整到 1024 * 768 时，屏幕的文字图标会变小，显示的内容更多了。但 `Retina` 显示方式不会产生这样的问题，或者说， **Retina 显示技术解决的是显示画面精细程度的问题，而不是解决显示内容容量的问题。**

### 7、分辨率、像素和屏幕尺寸
`PPI` 说的是像素密度，而分辨率说的是块屏幕的像素尺寸，譬如说 1334*750 就是 iPhone（6\~7）的分辨率，说 iPhone（6\~7）的分辨率是 326 是错误的表述，326 是它的像素密度，单位是 `PPI`。

询问别人一粒像素有多大是一个非常鸡贼的问题（小心面试遇到这样的题），虽然我们说像素是构成屏幕的发光的点，是物理的，但是像素在脱离了屏幕尺寸之后是没有大小可言的，你可以将 1920 * 1080 颗像素放到一台 40 寸的小米电视机里面，也可以将同样多的像素全部塞到一台 5.5 寸的 iPhone7 Plus 手机里面去，那么对于 40 寸的电视而言，每个像素颗粒当然会大于 5.5 寸的手机的像素。

![](https://ws3.sinaimg.cn/large/006tNc79gy1fg9fnde8adj30go0akjrl.jpg)

所以光看屏幕的分辨率对于设计师来说是不具备多少实际意义的，通过分辨率计算得出的像素密度（PPI）才是设计师要关心的问题，我们通过屏幕分辨率和屏幕尺寸就能计算出屏幕的像素密度的。

再次使用 iPhone（6\~7）作为例子。我们知道该屏幕的横向物理尺寸为 2.3 英寸 ，且横向具有 750 颗像素，根据下面的公式，我们能够算出 iPhone（6\~7）的屏幕是 326 PPI，意为每寸存在 326 颗像素。

其实不论我们怎么除，计算得出来的`像素密度（PPI）`都会是这个数，宽存在像素除以宽物理长度，高存在像素除以高物理长度，得数都接近于 326。

### 8、Viewport
#### 8.1 PPK的关于三个viewport的理论
[ppk大神](http://www.quirksmode.org/)对于移动设备上的viewport有着非常多的研究（[第一篇](http://www.quirksmode.org/mobile/viewports.html)，[第二篇](http://www.quirksmode.org/mobile/viewports2.html)，[第三篇](http://www.quirksmode.org/mobile/metaviewport/)），有兴趣的同学可以去看一下，本文中有很多数据和观点也是出自那里。ppk认为，移动设备上有三个viewport。

首先，移动设备上的浏览器认为自己必须能让所有的网站都正常显示，即使是那些不是为移动设备设计的网站。但如果以浏览器的可视区域作为`viewport`的话，因为移动设备的屏幕都不是很宽，所以那些为桌面浏览器设计的网站放到移动设备上显示时，必然会因为移动设备的`viewport`太窄，而挤作一团，甚至布局什么的都会乱掉。也许有人会问，现在不是有很多手机分辨率都非常大吗，比如768x1024，或者1080x1920这样，那这样的手机用来显示为桌面浏览器设计的网站是没问题的吧？前面我们已经说了，`css`中的1px并不是代表屏幕上的1px，你分辨率越大，`css`中1px代表的物理像素就越多，`devicePixelRatio`的值也越大，这很好理解，因为你分辨率增大了，但屏幕尺寸并没有变大多少，必须让`css`中的1px代表更多的物理像素，才能让1px的东西在屏幕上的大小与那些低分辨率的设备差不多，不然就会因为太小而看不清。所以在1080x1920这样的设备上，在默认情况下，也许你只要把一个div的宽度设为300多px（视`devicePixelRatio`的值而定），就是满屏的宽度了。回到正题上来，如果把移动设备上浏览器的可视区域设为viewport的话，某些网站就会因为`viewport`太窄而显示错乱，所以这些浏览器就决定默认情况下把`viewport`设为一个较宽的值，比如980px，这样的话即使是那些为桌面设计的网站也能在移动浏览器上正常显示了。ppk把这个浏览器默认的`viewport`叫做 **layout viewport**。
    
这个`layout viewport`的宽度可以通过`document.documentElement.clientWidth` 来获取。

然而，**layout viewport** 的宽度是大于浏览器可视区域的宽度的，所以我们还需要一个`viewport`来代表 浏览器可视区域的大小，ppk把这个`viewport`叫做 **visual viewport** 。`visual viewport`的宽度可以通过window.innerWidth 来获取，但在Android 2, Oprea mini 和 UC 8中无法正确获取。

![](https://ws1.sinaimg.cn/large/006tNc79gy1fg9labp1ebj30sq0ajamm.jpg)

现在我们已经有两个`viewport`了：**layout viewport** 和  **visual viewport**。但浏览器觉得还不够，因为现在越来越多的网站都会为移动设备进行单独的设计，所以必须还要有一个能完美适配移动设备的`viewport`。所谓的完美适配指的是，首先不需要用户缩放和横向滚动条就能正常的查看网站的所有内容；第二，显示的文字的大小是合适，比如一段14px大小的文字，不会因为在一个高密度像素的屏幕里显示得太小而无法看清，理想的情况是这段14px的文字无论是在何种密度屏幕，何种分辨率下，显示出来的大小都是差不多的。当然，不只是文字，其他元素像图片什么的也是这个道理。ppk把这个`viewport`叫做 **ideal viewport**，也就是第三个`viewport`——移动设备的理想`viewport`。

`ideal viewport`并没有一个固定的尺寸，不同的设备拥有有不同的`ideal viewport`。所有的`iphone`的`ideal viewport`宽度都是320px，无论它的屏幕宽度是320还是640，也就是说，在`iphone`中，`css`中的320px就代表`iphone`屏幕的宽度。

![](https://ws3.sinaimg.cn/large/006tNc79gy1fg9l926vv0j30fb05s3zf.jpg)

但是安卓设备就比较复杂了，有320px的，有360px的，有384px的等等，关于不同的设备`ideal viewport`的宽度都为多少，可以到[http://viewportsizes.com](http://viewportsizes.com/)去查看一下，里面收集了众多设备的理想宽度。

再总结一下：ppk把移动设备上的`viewport`分为 **layout viewport** 、 **visual viewport** 和 **ideal viewport** 三类，其中的`ideal viewport`是最适合移动设备的`viewport`，`ideal viewport`的宽度等于移动设备的屏幕宽度，只要在css中把某一元素的宽度设为`ideal viewport`的宽度(单位用px)，那么这个元素的宽度就是设备屏幕的宽度了，也就是宽度为100%的效果。`ideal viewport` 的意义在于，无论在何种分辨率的屏幕下，那些针对`ideal viewport `而设计的网站，不需要用户手动缩放，也不需要出现横向滚动条，都可以完美的呈现给用户。

 

#### 8.2 利用meta标签对viewport进行控制

移动设备默认的`viewport`是`layout viewport`，也就是那个比屏幕要宽的`viewport`，但在进行移动设备网站的开发时，我们需要的是`ideal viewport`。那么怎么才能得到`ideal viewport`呢？这就该轮到`meta`标签出场了。

我们在开发移动设备的网站时，最常见的的一个动作就是把下面这个东西复制到我们的`head`标签中：

`<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0">`

该`meta`标签的作用是让当前`viewport`的宽度等于设备的宽度，同时不允许用户手动缩放。也许允不允许用户缩放不同的网站有不同的要求，但让`viewport`的宽度等于设备的宽度，这个应该是大家都想要的效果，如果你不这样的设定的话，那就会使用那个比屏幕宽的默认`viewport`，也就是说会出现横向滚动条。

这个`nam`e为`viewport`的`meta`标签到底有哪些东西呢，又都有什么作用呢？

`meta viewport` 标签首先是由苹果公司在其`safari`浏览器中引入的，目的就是解决移动设备的`viewport`问题。后来安卓以及各大浏览器厂商也都纷纷效仿，引入对`meta viewport`的支持，事实也证明这个东西还是非常有用的。

在苹果的规范中，`meta viewport` 有**6**个属性(暂且把`content`中的那些东西称为一个个属性和值)，如下：

![](https://ws2.sinaimg.cn/large/006tNc79gy1fg9kx4zcvlj30n004k0ud.jpg)

这些属性可以同时使用，也可以单独使用或混合使用，多个属性同时使用时用逗号隔开就行了。

此外，在安卓中还支持  `target-densitydpi`  这个私有属性，它表示目标设备的密度等级，作用是决定`css`中的1px代表多少物理像素

![](https://ws1.sinaimg.cn/large/006tNc79gy1fg9mfu2qucj30n6010t8v.jpg)

特别说明的是，当 `target-densitydpi=device-dpi` 时， css中的1px会等于物理像素中的1px。

因为这个属性只有安卓支持，并且安卓已经决定要废弃`<strike>target-densitydpi</strike>`  这个属性了，所以这个属性我们要避免进行使用  。


#### 8.3 把当前的viewport宽度设置为 ideal viewport 的宽度

要得到`ideal viewport`就必须把默认的`layout viewport`的宽度设为移动设备的屏幕宽度。因为`meta viewport`中的`width`能控制`layout viewport`的宽度，所以我们只需要把`width`设为`width-device`这个特殊的值就行了。

`<meta name="viewport" content="width=device-width">`

下图是这句代码在各大移动端浏览器上的测试结果：

![](https://ws1.sinaimg.cn/large/006tNc79gy1fg9kz91kklj30op04d3yk.jpg)

可以看到通过`width=device-width`，所有浏览器都能把当前的`viewport`宽度变成`ideal viewport`的宽度，但要注意的是，在iphone和ipad上，无论是竖屏还是横屏，宽度都是竖屏时`ideal viewport`的宽度。

这样的写法看起来谁都会做，没吃过猪肉，谁还没见过猪跑啊~，确实，我们在开发移动设备上的网页时，不管你明不明白什么是`viewport`，可能你只需要这么一句代码就够了。

可是你肯定不知道
    
`<meta name="viewport" content="initial-scale=1">`

这句代码也能达到和前一句代码一样的效果，也可以把当前的的`viewport`变为 `ideal viewport`。

呵呵，傻眼了吧，因为从理论上来讲，这句代码的作用只是不对当前的页面进行缩放，也就是页面本该是多大就是多大。那为什么会有 `width=device-width` 的效果呢？

要想清楚这件事情，首先你得弄明白这个缩放是相对于什么来缩放的，因为这里的缩放值是1，也就是没缩放，但却达到了 ideal viewport 的效果，所以，那答案就只有一个了，缩放是相对于 `ideal viewport`来进行缩放的，当对`ideal viewport`进行100%的缩放，也就是缩放值为1的时候，不就得到了 `ideal viewport` 吗？事实证明，的确是这样的。下图是各大移动端的浏览器当设置了`<meta name="viewport" content="initial-scale=1"> `后是否能把当前的`viewport` 宽度变成 `ideal viewport` 的宽度的测试结果。

![](https://ws3.sinaimg.cn/large/006tNc79gy1fg9l0j5l4yj30ok04eq2z.jpg)

测试结果表明 `initial-scale=1` 也能把当前的 `viewport` 宽度变成 `ideal viewport` 的宽度，但这次轮到了windows phone 上的IE 无论是竖屏还是横屏都把宽度设为竖屏时 `ideal viewport` 的宽度。但这点小瑕疵已经无关紧要了。

但如果 `width` 和 `initial-scale=1` 同时出现，并且还出现了冲突呢？比如：
    
`<meta name="viewport" content="width=400, initial-scale=1">`

`width=400` 表示把当前 `viewport` 的宽度设为`400px`，`initial-scale=1` 则表示把当前 `viewport` 的宽度设为ideal viewport的宽度，那么浏览器到底该服从哪个命令呢？是书写顺序在后面的那个吗？不是。当遇到这种情况时，浏览器会取它们两个中较大的那个值。例如，当`width=400`，`ideal viewport` 的宽度为320时，取的是400；当width=400， ideal viewport的宽度为480时，取的是`ideal viewport`的宽度。（ps:在uc9浏览器中，当initial-scale=1时，无论width属性的值为多少，此时viewport的宽度永远都是ideal viewport的宽度）

最后，总结一下，要把当前的viewport宽度设为ideal viewport的宽度，既可以设置 width=device-width，也可以设置 initial-scale=1，但这两者各有一个小缺陷，就是iphone、ipad以及IE 会横竖屏不分，通通以竖屏的ideal viewport宽度为准。所以，最完美的写法应该是，两者都写上去，这样就 initial-scale=1 解决了 iphone、ipad的毛病，width=device-width则解决了IE的毛病：
    
`<meta name="viewport" content="width=device-width, initial-scale=1">`

#### 8.4 关于meta viewport的更多知识
##### 8.4.1 关于缩放以及initial-scale的默认值

首先我们先来讨论一下缩放的问题，前面已经提到过，缩放是相对于 `ideal viewport` 缩放的，缩放值越大，当前viewport的宽度就会越小，反之亦然。例如在iphone中，`ideal viewport` 的宽度是320px，如果我们设置 `initial-scale=2` ，此时 `viewport` 的宽度会变为只有160px了，这也好理解，放大了一倍嘛，就是原来1px的东西变成2px了，但是1px变为2px并不是把原来的320px变为640px了，而是在实际宽度不变的情况下，1px变得跟原来的2px的长度一样了，所以放大2倍后原来需要320px才能填满的宽度现在只需要160px就做到了。因此，我们可以得出一个公式：
>visual viewport宽度 = ideal viewport宽度  / 当前缩放值

>当前缩放值 = ideal viewport宽度  / visual viewport宽度

 ps: `visual viewport` 的宽度指的是浏览器可视区域的宽度。

大多数浏览器都符合这个理论，但是安卓上的原生浏览器以及IE有些问题。安卓自带的`webkit`浏览器只有在 `initial-scale = 1` 以及没有设置`width`属性时才是表现正常的，也就相当于这理论在它身上基本没用；而IE则根本不甩initial-scale这个属性，无论你给他设置什么，`initial-scale`表现出来的效果永远是1。

好了，现在再来说下 `initial-scale` 的默认值问题，就是不写这个属性的时候，它的默认值会是多少呢？很显然不会是1，因为当 `initial-scale = 1` 时，当前的 `layout viewport` 宽度会被设为 `ideal viewport` 的宽度，但前面说了，各浏览器默认的 `layout viewport` 宽度一般都是980啊，1024啊，800啊等等这些个值，没有一开始就是 `ideal viewport` 的宽度的，所以 `initial-scale` 的默认值肯定不是1。安卓设备上的 `initial-scale` 默认值好像没有方法能够得到，或者就是干脆它就没有默认值，一定要你显示的写出来这个东西才会起作用，我们不管它了，这里我们重点说一下iphone和ipad上的 `initial-scale` 默认值。

根据测试，我们可以在iphone和ipad上得到一个结论，就是无论你给 `layout viewpor` 设置的宽度是多少，而又没有指定初始的缩放值的话，那么iphone和ipad会自动计算 `initial-scale` 这个值，以保证当前 `layout viewport` 的宽度在缩放后就是浏览器可视区域的宽度，也就是说不会出现横向滚动条。比如说，在iphone上，我们不设置任何的 `viewport meta` 标签，此时 `layout viewport` 的宽度为980px，但我们可以看到浏览器并没有出现横向滚动条，浏览器默认的把页面缩小了。根据上面的公式，`当前缩放值 = ideal viewport宽度  / visual viewport宽度`，我们可以得出：

>当前缩放值 = 320 / 980

也就是当前的 `initial-scale` 默认值应该是 0.33这样子。当你指定了 `initial-scale` 的值后，这个默认值就不起作用了。

总之记住这个结论就行了：**在iphone和ipad上，无论你给viewport设的宽的是多少，如果没有指定默认的缩放值，则iphone和ipad会自动计算这个缩放值，以达到当前页面不会出现横向滚动条(或者说viewport的宽度就是屏幕的宽度)的目的。**

![](https://ws1.sinaimg.cn/large/006tNc79gy1fg9lipudr0j30q80cdwg9.jpg)

##### 8.4.2 动态改变meta viewport标签

第一种方法

可以使用 `document.write` 来动态输出 `meta viewport` 标签，例如：

```JavaScript
document.write('<meta name="viewport" content="width=device-width,initial-scale=1">')
```
第二种方法

通过 `setAttribute` 来改变 

```JavaScript
<meta id="testViewport" name="viewport" content="width = 380">
<script>
var mvp = document.getElementById('testViewport');
mvp.setAttribute('content','width=480');
</script>
```
 

安卓2.3自带浏览器上的一个 `bug`

```JavaScript
<meta name="viewport" content="width=device-width">

<script type="text/javascript">
alert(document.documentElement.clientWidth); //弹出600，正常情况应该弹出320
</script>

<meta name="viewport" content="width=600">

<script type="text/javascript">
alert(document.documentElement.clientWidth); //弹出320，正常情况应该弹出600
</script>
```

测试的手机 `ideal viewport` 宽度为320px，第一次弹出的值是600,但这个值应该是第行meta标签的结果啊，然后第二次弹出的值是320，这才是第一行meta标签所达到的效果啊，所以在安卓2.3(或许是所有2.x版本中)的自带浏览器中，对 `meta viewport` 标签进行覆盖或更改，会出现让人非常迷糊的结果。


### 最后我们来看一个栗子来加深上面概念的印象：
一只笔的像素如下：
![](https://ws1.sinaimg.cn/large/006tNbRwgy1fg8k14mf55j30ci09twej.jpg)

这只笔在屏幕c,d,e下的显示效果如下：
![](https://ws3.sinaimg.cn/large/006tNbRwgy1fg8k1v79x9j30go09qa9y.jpg)

看到同一张图片在各屏幕显示大小不一。
我们希望不同屏幕显示图片的大小要一致。
我们要计算图片缩放比例。
计算公式：
(图片逻辑像素大小px1) / (图片缩放后实际像素大小px2) = (设备像素dp) / (设备独立像素dips)
px2 = px1 * (dp / dips)
px2 = px1 * dpr
此时，这只笔在屏幕c,d,e下的显示效果如下：
![](https://ws2.sinaimg.cn/large/006tNbRwgy1fg8k398o8wj30go0c0q2x.jpg)

>通过上面的我们可以看到，不同的 `DPR` (设备像素比)要想显示大小一样，必须准备三张不同分辨率的图片，那么，我想一张图片就在三种不同的屏幕下显示一样的大小，能做到吗？当然能做到，这就需要缩放了，要自己计算缩放多麻烦，那有没有一种简单的方式呢？当然有，那就是你在熟悉不过的**px**,你会发现设置图片宽度为**50px**以后，在各个移动终端的大小看起来都一样，这是什么原因呢。


按照 `CSS` 规范的定义，`CSS` 中的 `px` 是一个相对长度，它相对的，是 `viewing device` 的分辨率。这个`viewing device`，通常就是电脑显示器。典型的电脑显示器的分辨率是`96DPI`，也就是1像素为1/96英寸（实际上，假设我们的显示器分辨率都与物理分辨率一致，而液晶点距其实是0.25mm到0.29mm之间，所以不太可能是正好1/96英寸，而只是接近）。 

一般来说，`px` 就是对应设备的物理像素，然而如果输出设备的解析度与电脑显示器大不相同，输出效果就会有问题。例如打印机输出到纸张上，其解析度比电脑屏幕要高许多，如果不缩放，直接使用设备的物理像素，那电脑上的照片由 `600DPI` 的打印机打出来就比用显示器看小了约6倍。 

所以 `CSS` 规定，在这种情况下，浏览器应该对像素值进行缩放调节，以保持阅读体验的大体一致。也就是要保持一定像素的长度在不同设备输出上看上去的大小总是差不多。 

怎样确保这一点呢？直接按照设备物理像素的大小进行换算当然是一个方式，但是CSS考虑得更多，它建议，转换应按照“参考像素”（`reference pixel`）来进行。 

眼睛看到的大小，取决于可视角度。而可视角度取决于物体的实际大小以及物体与眼睛的距离。10米远处一个1米见方的东西，与1米远处的10厘米见方的东西，看上去的大小差不多是一样的，所谓一叶障目不见泰山，讲的就是这个常识。 

因此CSS规范使用视角来定义“参考像素”，1参考像素即为从一臂之遥看解析度为96DPI的设备输出（即1英寸96点）时，1点（即1/96英寸）的视角。 

请注意这个差别——`CSS`规范定义的参考像素并不是1/96英寸，而是1/96英寸在一臂之遥的看起来的视角。通常认为常人臂长为28英寸，所以其视角可以计算出来是0.0213度。`（即(1/96)in / (28in * 2 * PI / 360deg) ） `

我们在使用不同设备输出时，眼睛与设备输出的典型距离是不同的。比如电脑显示器，通常是一臂之距，而看书和纸张时（对应于打印机的设备输出），则通常会更近一些。看电视时则会更远，比如一般建议是电视机屏幕对角线的2.5到3倍长——如果你是个42'彩电，那就差不多是3米远。看电影的话……我就不知道多远了，您自己量吧。 

因此，1参考像素： 
对于电脑显示器是0.26mm（即1/96英寸）； 
对于激光打印机是0.20mm（假设阅读距离通常为55cm，即21英寸）； 

而换算时，对于300DPI的打印机（即每个点是1/300英寸），1px通常会四舍五入到3dots，也就是0.25mm左右；而对于600DPI的打印机，则可能四舍五入到5dots，也就是0.21mm。 

![](http://www.w3.org/TR/CSS2/images/pixel1.png)

上图中，左边的屏幕（可以认为是电脑屏幕）的典型视觉距离是71厘米即28英寸，其1px对应了0.28mm；
而右边的屏幕（可以认为是你的42寸高清电视）的典型视觉距离是3.5米即120英寸，其1px对应1.3mm。42寸的1080p电视，分辨率是1920*1080，则其物理像素只有0.5mm左右，可见确实是高清哦。

综上，`px` 是一个相对单位，而且在特定设备上总是一个近似值（原则是尽量接近参考像素）。 

然而，如果你把绝对单位理解为对输出效果的绝对掌控，事情却大相径庭。就网页输出的最主要对象——电脑屏幕来说，`px` 可被视为一个基准单位——与桌面分辨率一致，如果是液晶屏，则几乎总是与液晶屏物理分辨率一致——也就是说网页设计者设定的1px，就是“最终看到这个网页的用户的显示器上的1个点距”！反倒是那些绝对单位，其实一点也不绝对。 


### 参考文章
[深入理解移动端像素知识与Viewport知识](http://blog.csdn.net/aiolos1111/article/details/51967744)
[移动端H5页面的设计稿尺寸（上）](http://zikoman.lofter.com/post/3bf3bb_6da8d80#)
[移动端H5页面的设计稿尺寸（下）](http://zikoman.lofter.com/post/3bf3bb_6da8e55#)
[你真的了解像素吗](http://www.cnblogs.com/dojo-lzz/p/6683036.html?utm_source=debugrun&utm_medium=referral)
[移动前端开发之viewport的深入理解](http://www.cnblogs.com/2050/p/3877280.html)
[设备像素，设备独立像素，CSS像素](http://yunkus.com/physical-pixel-device-independent-pixels/)
[移动端开发系列——像素与viewport](http://www.jianshu.com/p/76130f4d7cf9)
[移动端高清、多屏适配方案 ](http://div.io/topic/1092?page=2)
[像素（px）到底是个什么单位](http://hax.iteye.com/blog/374323)
[CSS 长度单位](https://yukun.im/css/469)
[彻底理解 UI 及 Web 的尺寸单位：基本概念](https://medium.com/uxabc/understanding-ui-units-8acdc0575388)
[针对iPhone的pt、Android的dp、HTML的css像素与dpr、设计尺寸和物理像素的浅分析](https://www.idaima.com/a/13245.html)


