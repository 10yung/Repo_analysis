Being log spammed with the following:

> Passing 'info' command to redis as is; administrative commands cannot be effectively namespaced and should be called on the redis connection directly; passthrough has been deprecated and will be removed in redis-namespace 2.0 (at /usr/local/lita/builds/1.1.2/vendor/bundle/ruby/2.3.0/gems/lita-4.7.1/lib/lita/handlers/info.rb:43:in `redis_info')

Anything that can be done to stop the logspam as it looks to be causing the bot to crash after a couple days. These are being written every time a new message comes through.
Is it possible to add an HTTP URL for an adapter? I know this can be added for handlers, but when I tro to add it for an adapter, I receive the following error:

```
Gem Load Error is: undefined local variable or method `http' for Lita::Adapters::Glip:Class
```
Hi guys,
I'm curently using the slack app bot to post the interactive message with button into slack, and return the command to call lita working the rest (ex: save data). I try to get this script working only on 1 bot (lita of course) but I cannot find anyway to get lita to handle the callback message from itself after pressing on Save button.
Please advice me some guides for this, thanks
I am trying to create a new handler and Lita does not seem to be registering it. I am running Lita version 4.7.1 and ruby 2.3. I have used the `lita handler` command to generate the scaffolding of the handler and just added the basic `echo` example as the handler code.  I have created a gem and deployed it to my internal gem repo. I see that `bundle install` is pulling in my gem along with other community handlers. but when asking lita `echo hello` nothing happens and no errors are thrown. also saying `help` there is not any refernce to "echo" . 

here is my handler code(this is just the echo example)

```ruby
module Lita
  module Handlers
    class EchoHandler < Handler
      route(/^echo\s+(.+)/, :echo, command: true, help: {
              "echo TEXT" => "Replies back with TEXT."
      })

      def echo(response)
        response.reply(response.matches)
      end

      
    end
    Lita.register_handler(EchoHandler)
  end
end

```

other than a few changes in the gemspec to remove `TODO` that is all I have modified from the autogenerated files. Is there something else I need to for the handler to be registered? Is there a way to check to see if it is loaded? I have put Lita in debug but there is no info related to my handler

Is there a way I can configure Lita to send requests to slack and any other "selected" http endpoints using a proxy?
Hey, so I have a sufficiently complex plugin that has multiple sub-components. The reason these components are all in one plugin is because they have a large amount of shared dependencies, and keeping them together just makes everything easier to maintain. The problem is that it appears the default configuration builder doesn't really handle namespacing as the documentation seems to indicate. I have a test that exposes the issue but before I went to far in trying to address it I wanted to make sure that this is something that you'd want to support. 

```ruby
context "with multiple handlers with the same namespace" do
  it "has all the attributes for each handler" do
    registry.register_handler(:foo) { config :bar, default: :baz }

    registry.register_handler(:moo) do
      namespace "foo"
      config :mar, default: :maz
    end

    registry.register_handler(:too) do
      namespace "foo"
      config :tar, default: :taz
    end

    expect(config.handlers.foo.bar).to eq(:baz)
    expect(config.handlers.foo.mar).to eq(:maz)
    expect(config.handlers.foo.tar).to eq(:taz)
  end
end
```

the result of this test is this: 

```
  1) Lita::DefaultConfiguration handlers config with multiple handlers with the same namespace has all the attributes for each handler
     Failure/Error: expect(config.handlers.foo.bar).to eq(:baz)

     NoMethodError:
       undefined method `bar' for #<Lita::Configuration:0x007ff5a98ae1b0>
       Did you mean?  tar
     # ./spec/lita/default_configuration_spec.rb:68:in `block (4 levels) in <top (required)>'
```

Is this the intended behavior? Is this something that Lita even supports?
I am adding lita as a bot to our whole org but I want to be able to restrict access to some critical plugins (github or CodeDeploy integrations) to the engineers.

Currently I believe I need to fork these gems to restrict the routes to the right Lita group. Or is there a way to do this at a global level that I missed.

If this does not exist I'll take a jab at a PR for this.
Hi,

I'm working on an adapter for Discord (the existing one doesn't support oauth properly imo). For this I'm also trying to override the default help command to generate something specific to discord. ie: I'm putting everything in a code block and aligning the content to a sort of table. 

I was able to get this to work by adding a new command to the adapter, but Lita still outputs the default help command output too. 

Is it possible to disable this default help command?
Hi,

I try to have Lita BOT to send_messages to a hipchat room, but never succeeded.
Here are my code:

```ruby
    def get_target_by_user(owner)
      user = Lita::User.find_by_name(owner)

      # Need to prevent the user does not exist in hipchat.
      return nil if user.nil?

      return Lita::Source.new(user: user)
    end

    def get_target_by_room(room)
      room = Lita::Room.find_by_name(room)

      # Need to prevent the user does not exist in hipchat.
      return nil if room.nil?

      robot.join(room)
      return Lita::Source.new(room: room)
    end

    def send_message_to_target(target, header, msg)
      log.info("sending message to #{target.inspect}")
      robot.send_messages(target, header)
      robot.send_messages(target, msg)
    end

    def send_message(owner, cc, header, msg)
      receivers = [owner]
      receivers += cc if not cc.nil?
      receivers.each do |owner|
        begin
          target = get_target_by_user(owner)
          if target.nil?
            target = get_target_by_room(owner)
          end

          next if target.nil? # skip if user does not exist in hipchat.

          send_message_to_target(target, header, msg)
        rescue StandardError => e
          log.error("Error when sending message to #{target}: #{e}")
        end
      end
    end
    header = "(failed) Test"
        msg = "Test message\n"
        config.notify_to.each do |owner|
          send_message(owner, nil, header, msg)
        end
```
And the log likes the following: We can see it sent to the user successfully, but did not send message to the room. So what could be the problem?
```
[] [DEBUG] Already in room with JID 599001_devtestroom@conf.hipchat.com
[] [INFO] sending message to #<Lita::Source:0x007fe42d4648f8 @user=nil, @room="599001_devtestroom", @room_object=#<Lita::Room:0x007fe42d466018 @id="599001_devtestroom", @metadata={"name"=>"599001_devtestroom"}, @name="599001_devtestroom">, @private_message=false>
[] [INFO] sending message to #<Lita::Source:0x007fe42d45dbe8 @user=#<Lita::User:0x007fe42d45dcd8 @id="599001_4263932@chat.hipchat.com", @metadata={"mention_name"=>"AutumnWang", "email"=>"autumn.wang@illumio.com", "name"=>"Autumn Wang"}, @name="Autumn Wang">, @private_message=true>
[] [DEBUG] Sending message to JID 599001_4263932@chat.hipchat.com: (failed) Test
[] [DEBUG] Sending message to JID 599001_4263932@chat.hipchat.com: Test message

```
Is there a way to optionally make a route a command using a config parameter?

For example:

``` ruby
route(/foo/, :bar, command: config.command, help: { 'foo' => 'returns bar' })
```
