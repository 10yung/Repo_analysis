We should add overloads like `EnterBarrierAsync` for all blocking methods. And also would be nice to rewrite existing tests to use this APIs, this may help with racy issues on CI.



## Introduction ##

Once #4126 will be merged, we will need to improve metrics loading, that is implemented in `DefaultCollector`.

The basic idea is to collect:

- Current CPU load on the node, in %
- Current Memory usage, in %

Using that information, `AdaptiveLoadBalancingRoutingLogic` will calculate availability of each node and will perform "smart" routing.

Ideally, we should collect more complete list:

- CPU usage by current process
- CPU total usage on the node machine (this will be used for routing)
- Memory usage by current process (in bytes)
- Memory total usage on the node machine
- Memory available on the node machine (this with previous one will give total utilization in %)

## What we have right now ##

### CPU ###

There is no API available in `netstandard2.1` to collect CPU metrics out-of-the-box, like `PerformanceCounters`. So what we are doing now is using `Process.TotalProcessorTime` property, to get time, dedicated to current process. Having total time elapsed, we can give some estimation of CPU usage by current process.

But talking about CPU **total** usage, this approach would require to get all processes info with `Process.GetProcesses()` - which is very time consuming (especially when we have to deal with access violation exceptions here), when there are lots of processes.
So total CPU usage is just **the same** as current process CPU usage now. This is more or less fine for routing based on .NET process load, but not ideal if there are some other heavy processes running on machine.

## Memory ##

 Candidate list includes:

- `GC.GetTotalMemory` to get currently allocated managed memory size. There is also [`GC.GetGCMemoryInfo`](https://docs.microsoft.com/ru-ru/dotnet/api/system.gc.gettotalmemory?view=netframework-4.8) - that will provide struct with `TotalAvailableMemoryBytes` property, but this method is only available at `.netstandard3.0`, and we are targeting `2.1`

- PerformanceCouters, which are working under Windows, and there is Mono implementation. There are some other Windows-only ways to get metrics.

- `Process` class, which provides multiple memory-related properties

- Using P/Invoke and working with native API

- Getting some shell commands output, specific for OS


Currently, we are using the cross-platform sources available for `netstandard2.1` - the `Process` class. 

#### First issue ####
Same as for CPU: this is quite heavy to get all processes information. So current implementation treats `MemoryUsage` as current process usage, which is useful, but not ideal for nodes routing.

#### Second issue ####
Another issue is understanding the term of "used" memory, and getting "available" memory info. 

To track unmanaged memory as well as managed, [`Process.PrivateMemorySize64`](https://docs.microsoft.com/ru-ru/dotnet/api/system.diagnostics.process.privatememorysize64?view=netframework-4.8) is used instead of `GC.GetTotalMemory`. It works well by itself. But it is hard to know the upper limit for this value, because it is not the *allocated physical memory from RAM* (see documentation). 
Getting "available" memory is much more tricky, and I did not find anything available under .NET Core sdk to get this value. Ideally would be getting available size of installed physical memory (or available part of it in cloud environment). So far, the `Process.VirtualMemorySize64` is used - but is is just a number of bytes in **virtual** address space, and does not correlate much with really available memory. But still it is one of the upper bounds for available memory, and can be used to get % of memory load (relative to other node).

In my understanding, ideally would be loading `Available MBytes` PerformanceCounter (but on all platforms) to get available memory, and get some way to load installed total available memory. This two would allow to get `% Used Memory` on the node, and perform routing. And provide all different `Process` properties in addition, like `WorkingSet`, `PrivateMemorySize64`, and others.

Maybe there is some other convenient approach. The main idea here is that while current `used / available` relation is `Process.PrivateMemorySize64 / Process.VirtualMemorySize64` - it is always is range of `[0, 1]` and reflects the memory load. So we can compare nodes based on this. But value of `0.5` does not guarantee that there is available memory on the node at all, so need some more accurate values for node's  memory capacity calculation.


Akka Version: 1.3.15
Akka Component: Akka.Persistence.Sql.Common & Akka.Persistence.SQLServer
Platform: Linux Containers

SQL generated by Akka for accessing the EventJournal and the SnapshotStore create parameters with different sizes. This has an impact on SQL Server specifically, but other backends may also be affected. SQL Server Generates a query plan based upon the parameters passed, so when they are different in size then another query plan is generated rather than using an existing plan. In our production environment the insert/update statement for SnapshotStore created 15,523 different query plans in the plan cache. This makes repeated execution of the statements more expensive as it must search the cache first, before generating a new one should it not find a match. The main difference between the plans was the the size of the `@Payload` parameter `varbinary` field  being passed. The EventJournal queries have a similar problem. 

The `AddParameter` method within the `Akka.Persistence.Sql.Common/Snapshot/QueryExecutor.cs` and the `Akka.Persistence.Sql.Common/Journal/QueryExecutor.cs` does not take a size field so it is using the size of the data passed which causes the problem for MS SQL Server, it would be better to take a size field that would be set to the same size as the column.  However this could have a detrimental effect on implementations for other Databases that do not have query plan caches.  

It looks like it would be possible to override the methods in the Akka.Persistence.SQLServer project but this would mean copying large amounts of code to change a small amount of code. Does anyone else have an opinion on the best way to resolve this ?





I'm looking for some clarifications regarding contributing:

* https://github.com/akkadotnet/akka.net/blob/dev/README.md says Akka.NET is part of the .NET Foundation, but the project is not listed on https://dotnetfoundation.org/projects
* Contributing to .NET Foundation projects (afaik) requires signing a CLA. There is https://github.com/akkadotnet/akka.net/issues/791 but I can't find the follow-up for that issue. PRs don't seem to have a bot for CLA signing.
* Source files list the .NET Foundation, e.g. `Copyright (C) 2013-2019 .NET Foundation <https://github.com/akkadotnet/akka.net>`
* https://github.com/akkadotnet/akka.net/blob/dev/CONTRIBUTING.md does not mention .NET Foundation

Is the transition to a .NET Foundation project an ongoing effort? Do contributors need to sign a CLA?
Akka supports double wildcards in the actor deployment configuration. This is documented [here](https://doc.akka.io/docs/akka/2.5.4/scala/general/configuration.html#actor-deployment-configuration) (it's missing in the current docs):

> you can use double-wildcards in the last position to match all child actors and their children recursively: `/someParent/**`

The relevant PR for this feature is https://github.com/akka/akka/pull/20525. See https://github.com/akka/akka/blob/6278968af56f36b8ff3fd4a0a443e5218bceb838/akka-actor/src/main/scala/akka/util/WildcardIndex.scala for current version of this file.

It would be great to have this available in Akka.NET too. This will allow simplifying configuration from
```
"/foo/*" {
	dispatcher = bar
}
"/foo/*/*" {
	dispatcher = bar
}
"/foo/*/*/*" {
	dispatcher = bar
}
```
to
```
"/foo/**" {
	dispatcher = bar
}
```
Working on removing the `Akka.Configuration` namespace and migrating everything to the stand-alone HOCON library in https://github.com/akkadotnet/HOCON

So this will be a binary-incompatible change that will likely require an re-compilation of Akka.NET projects, but the upshot is that HOCON can now be upgraded and extended independently of Akka.NET itself, allowing for things such as Microsoft.Extensions.Configuration integration without directly touching the `ActorSystem` or Akka.NET itself.

This PR will likely take a few iterations and some upgrades to the HOCON library itself.
This will close #2070 , and maybe some other related issues.

The goal of this PR is to port [Akka.Cluster.Metrics](https://github.com/akka/akka/tree/master/akka-cluster-metrics) into Akka.NET. Maybe this will span into several pull requests, will see.

I will keep this in draft state until will have working specs for this (that is, once this will be ready for final reviews/merge).

I will start from implementing the core functions and metric collectors, and then will add adaptive load balancing routers.
Akka.NET 1.4.0-beta3

It appears that enabling 'serialize-messages = on' while using clustering breaks the actor system with the following error. 

Looks like clustering has some difficulty correctly serializing its messages when turned on.

Here is a project which reproduces the error https://www.dropbox.com/s/o9al6adwl609p7o/AkkaTest.zip?dl=0

```

[ERROR][22/12/2019 12:32:41 AM][Thread 0005][[akka://PubSubSystem/system/cluster/core#342317816]] Swallowing exception during message send
Cause: Newtonsoft.Json.JsonSerializationException: Unable to find a constructor to use for type System.Collections.Immutable.ImmutableHashSet`1[System.Type]. Path 'To.$values', line 1, position 376.
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue, Object& newValue, String& id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1 creator, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, String id, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)
   at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType)
   at Newtonsoft.Json.JsonConvert.DeserializeObject(String value, Type type, JsonSerializerSettings settings)
   at Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(Byte[] bytes, Type type)
   at Akka.Serialization.Serialization.Deserialize(Byte[] bytes, Int32 serializerId, String manifest)
   at Akka.Actor.ActorCell.SerializeAndDeserializePayload(Object obj)
   at Akka.Actor.ActorCell.SerializeAndDeserialize(Envelope envelope)
   at Akka.Actor.ActorCell.SendMessage(Envelope message)
[DEBUG][22/12/2019 12:32:41 AM][Thread 0005][akka://PubSubSystem/system/clusterEventBusListener] Started (Akka.Cluster.ClusterReadView+EventBusListener)
[ERROR][22/12/2019 12:32:41 AM][Thread 0019][[akka://PubSubSystem/system/cluster/core#342317816]] Swallowing exception during message send
Cause: Newtonsoft.Json.JsonSerializationException: Unable to find a constructor to use for type System.Collections.Immutable.ImmutableHashSet`1[System.Type]. Path 'To.$values', line 1, position 368.
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue, Object& newValue, String& id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1 creator, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, String id, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)
   at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType)
   at Newtonsoft.Json.JsonConvert.DeserializeObject(String value, Type type, JsonSerializerSettings settings)
   at Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(Byte[] bytes, Type type)
   at Akka.Serialization.Serialization.Deserialize(Byte[] bytes, Int32 serializerId, String manifest)
   at Akka.Actor.ActorCell.SerializeAndDeserializePayload(Object obj)
   at Akka.Actor.ActorCell.SerializeAndDeserialize(Envelope envelope)
   at Akka.Actor.ActorCell.SendMessage(Envelope message)
[DEBUG][22/12/2019 12:32:41 AM][Thread 0019][akka://PubSubSystem/system/remote-watcher] Started (Akka.Cluster.ClusterRemoteWatcher)
[DEBUG][22/12/2019 12:32:41 AM][Thread 0009][EventStream] subscribing [akka://PubSubSystem/system/cluster/core/daemon#73339279] to channel Akka.Remote.QuarantinedEvent
[ERROR][22/12/2019 12:32:41 AM][Thread 0007][[akka://PubSubSystem/system/cluster/core#342317816]] Swallowing exception during message send
Cause: Newtonsoft.Json.JsonSerializationException: Unable to find a constructor to use for type System.Collections.Immutable.ImmutableHashSet`1[System.Type]. Path 'To.$values', line 1, position 379.
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewList(JsonReader reader, JsonArrayContract contract, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateList(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, Object existingValue, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ReadMetadataProperties(JsonReader reader, Type& objectType, JsonContract& contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue, Object& newValue, String& id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.ResolvePropertyAndCreatorValues(JsonObjectContract contract, JsonProperty containerProperty, JsonReader reader, Type objectType)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObjectUsingCreatorWithParameters(JsonReader reader, JsonObjectContract contract, JsonProperty containerProperty, ObjectConstructor`1 creator, String id)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateNewObject(JsonReader reader, JsonObjectContract objectContract, JsonProperty containerMember, JsonProperty containerProperty, String id, Boolean& createdFromNonDefaultCreator)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateObject(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.CreateValueInternal(JsonReader reader, Type objectType, JsonContract contract, JsonProperty member, JsonContainerContract containerContract, JsonProperty containerMember, Object existingValue)
   at Newtonsoft.Json.Serialization.JsonSerializerInternalReader.Deserialize(JsonReader reader, Type objectType, Boolean checkAdditionalContent)
   at Newtonsoft.Json.JsonSerializer.DeserializeInternal(JsonReader reader, Type objectType)
   at Newtonsoft.Json.JsonConvert.DeserializeObject(String value, Type type, JsonSerializerSettings settings)
   at Akka.Serialization.NewtonSoftJsonSerializer.FromBinary(Byte[] bytes, Type type)
   at Akka.Serialization.Serialization.Deserialize(Byte[] bytes, Int32 serializerId, String manifest)
   at Akka.Actor.ActorCell.SerializeAndDeserializePayload(Object obj)
   at Akka.Actor.ActorCell.SerializeAndDeserialize(Envelope envelope)
   at Akka.Actor.ActorCell.SendMessage(Envelope message)
```
