### Bindgen Invocation

```Rust
    let bindings = bindgen::Builder::default()
        .header("wrapper.h")
        .clang_arg(include_path)
        .blacklist_item("YDB_NOTTP")
        // Finish the builder and generate the bindings.
        .generate()
        // Unwrap the Result and panic on failure.
        .expect("Unable to generate bindings");
```

### Actual Results

```
error: failed to run custom build command for `clang-sys v0.28.1`

Caused by:
  process didn't exit successfully: `/home/joshua/Documents/Programming/yottadb/ydbrust/target/debug/build/clang-sys-0bef6ce726fcb6d1/build-script-build` (exit code: 101)
--- stderr
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: "couldn\'t find any valid shared libraries matching: [\'libclang.so\', \'libclang-*.so\'], set the `LIBCLANG_PATH` environment variable to a path where one of these files can be found (invalid: [])"', src/libcore/result.rs:1165:5
stack backtrace:
   0: backtrace::backtrace::libunwind::trace
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/libunwind.rs:88
   1: backtrace::backtrace::trace_unsynchronized
             at /cargo/registry/src/github.com-1ecc6299db9ec823/backtrace-0.3.40/src/backtrace/mod.rs:66
   2: std::sys_common::backtrace::_print_fmt
             at src/libstd/sys_common/backtrace.rs:77
   3: <std::sys_common::backtrace::_print::DisplayBacktrace as core::fmt::Display>::fmt
             at src/libstd/sys_common/backtrace.rs:61
   4: core::fmt::write
             at src/libcore/fmt/mod.rs:1028
   5: std::io::Write::write_fmt
             at src/libstd/io/mod.rs:1412
   6: std::sys_common::backtrace::_print
             at src/libstd/sys_common/backtrace.rs:65
   7: std::sys_common::backtrace::print
             at src/libstd/sys_common/backtrace.rs:50
   8: std::panicking::default_hook::{{closure}}
             at src/libstd/panicking.rs:188
   9: std::panicking::default_hook
             at src/libstd/panicking.rs:205
  10: std::panicking::rust_panic_with_hook
             at src/libstd/panicking.rs:464
  11: std::panicking::continue_panic_fmt
             at src/libstd/panicking.rs:373
  12: rust_begin_unwind
             at src/libstd/panicking.rs:302
  13: core::panicking::panic_fmt
             at src/libcore/panicking.rs:139
  14: core::result::unwrap_failed
             at src/libcore/result.rs:1165
  15: core::result::Result<T,E>::unwrap
             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libcore/result.rs:933
  16: build_script_build::dynamic::link
             at ./build/dynamic.rs:194
  17: build_script_build::main
             at ./build.rs:78
  18: std::rt::lang_start::{{closure}}
             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61
  19: std::rt::lang_start_internal::{{closure}}
             at src/libstd/rt.rs:48
  20: std::panicking::try::do_call
             at src/libstd/panicking.rs:287
  21: __rust_maybe_catch_panic
             at src/libpanic_unwind/lib.rs:78
  22: std::panicking::try
             at src/libstd/panicking.rs:265
  23: std::panic::catch_unwind
             at src/libstd/panic.rs:396
  24: std::rt::lang_start_internal
             at src/libstd/rt.rs:47
  25: std::rt::lang_start
             at /rustc/73528e339aae0f17a15ffa49a8ac608f50c6cf14/src/libstd/rt.rs:61
  26: main
  27: __libc_start_main
  28: _start
```

### Expected Results

bindgen should successfully find clang in one of the following places:

```
$ echo $(llvm-config --libdir)/libclang*
/usr/lib/llvm-8/lib/libclang-8.so.1 /usr/lib/llvm-8/lib/libclang.so.1
```

This works fine with bindgen 0.51, it only breaks with 0.52.

See also https://github.com/KyleMayes/clang-sys/issues/98.
I'm trying to generate bindings for a small C program with pthread. How do I add the "-pthread" flag in the build.rs script?

Thanks!
Quite related to https://github.com/rust-lang/rust-bindgen/issues/1706

I've tried a number of things and this doesn't seem to fix or remove the generated block type alias.

### Input C/C++ Header

```Objective-C
// bindgen-flags:  --blacklist-function enumerateObjectsUsingBlock  --blacklist-type FooWithBlock* --generate-block --objc-extern-crate --block-extern-crate  -- -x objective-c -fblocks
// bindgen-osx-only

@interface FooWithBlock<__covariant ObjectType>
- (void)enumerateObjectsUsingBlock:(void (^)(ObjectType obj, int idx))block;
@end

```

### Bindgen Invocation

```
$ bindgen input.h --blacklist-function enumerateObjectsUsingBlock  --blacklist-type FooWithBlock* --generate-block --objc-extern-crate --block-extern-crate  -- -x objective-c -fblocks
```

### Actual Results

```
/* automatically generated by rust-bindgen */

pub type _bindgen_ty_id_5 =
    *const ::block::Block<(*mut ObjectType, ::std::os::raw::c_int), ()>;
```

### Expected Results

Nothing I would think.
Some of the annoying things in the Foundation Framework have blocks in generics as seen [here](https://developer.apple.com/documentation/foundation/nsorderedset/1413531-enumerateobjectsusingblock?language=objc).

Another odd thing about this is that it may be dependent on clang itself as I've had different results from macOS 10.14 to 10.15.

### Input C/C++ Header

```Objective-C
// bindgen-flags: --generate-block --objc-extern-crate -- -x objective-c -fblocks
// bindgen-osx-only

@interface FooWithBlock<__covariant ObjectType>
- (void)enumerateObjectsUsingBlock:(void (^)(ObjectType obj, int idx))block;
@end

```

### Bindgen Invocation

```
$ bindgen input.h --generate-block --objc-extern-crate --block-extern-crate -- -x objective-c -fblocks
```

### Actual Results

```
/* automatically generated by rust-bindgen */

#[macro_use]
extern crate objc;
#[allow(non_camel_case_types)]
pub type id = *mut objc::runtime::Object;
use block;
pub trait FooWithBlock<ObjectType> {
    unsafe fn enumerateObjectsUsingBlock_(self, block: _bindgen_ty_id_5);
}
impl<ObjectType: 'static> FooWithBlock<ObjectType> for id {
    unsafe fn enumerateObjectsUsingBlock_(self, block: _bindgen_ty_id_5) {
        msg_send!(self, enumerateObjectsUsingBlock: block)
    }
}
pub type _bindgen_ty_id_5 =
    *const ::block::Block<(*mut ObjectType, ::std::os::raw::c_int), ()>;
```

The issue here being `_bindgen_ty_id_5` having `ObjectType` outside of it.

### Expected Results

It's unclear what `_bindgen_ty_id_5_` really should be.

I'm on the fence for filing this issue because after testing out all of the iOS frameworks on my system, I've had this issue happen twice but I figure it's useful for documentation purposes if it doesn't get fixed.

According to the apple [developer docs](https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/ProgrammingWithObjectiveC/DefiningClasses/DefiningClasses.html#//apple_ref/doc/uid/TP40011210-CH3-SW8):
> ` - (void)someMethodWithValue:(SomeType)value;`
> Note: The value1 and value2 value names used above aren’t strictly part of the method declaration, which means it’s not necessary to use exactly the same value names in the declaration as you do in the implementation. The only requirement is that the signature matches, which means you must keep the name of the method as well as the parameter and return types exactly the same.
> 
> As an example, this method has the same signature as the one shown above:
> `- (void)someMethodWithFirstValue:(SomeType)info1 secondValue:(AnotherType)info2;`

This is also against apples guidelines I'm quite sure (cause why would it not).

Anyway, this is an issue because the headers for [translateInCameraSpaceByX:Y:Z from SCNCameraController in SceneKit](https://developer.apple.com/documentation/scenekit/scncameracontroller/2867569-translateincameraspacebyx?language=objc) and [dividerImageForLeftSegmentState:rightSegmentState from UIStepper in UIKit](https://developer.apple.com/documentation/uikit/uistepper/1624072-dividerimageforleftsegmentstate) have the same name (`state` and `deltaX` respectively).

Ideally, the method names in the generation are from the sender name variable name. This is also related to #1703 because method headers that don't have sender names require the existing functionality.

### Input Objective-C Header

```
@interface CAMediaTimingFunction
- (float *)dividerImageForLeftSegmentState:(float)state
                         rightSegmentState:(float)state;
@end
```

### Bindgen Invocation
```
$ bindgen input.h -- -x objective-c
```

### Actual Results

```
use objc;
#[allow(non_camel_case_types)]
pub type id = *mut objc::runtime::Object;
pub trait CAMediaTimingFunction {
    unsafe fn dividerImageForLeftSegmentState_rightSegmentState_(
        self,
        state: f32,
        state: f32,
    ) -> *mut f32;
}
impl CAMediaTimingFunction for id {
    unsafe fn dividerImageForLeftSegmentState_rightSegmentState_(
        self,
        state: f32,
        state: f32,
    ) -> *mut f32 {
        msg_send ! ( self , dividerImageForLeftSegmentState : state rightSegmentState : state )
    }
}
```

### Expected Results

```
pub trait CAMediaTimingFunction {
    unsafe fn dividerImageForLeftSegmentState_rightSegmentState_(
        self,
        state: f32,
        rightSegmentState: f32,
    ) -> *mut f32;
}
impl CAMediaTimingFunction for id {
    unsafe fn dividerImageForLeftSegmentState_rightSegmentState_(
        self,
        state: f32,
        rightSegmentState: f32,
    ) -> *mut f32 {
        msg_send ! ( self , dividerImageForLeftSegmentState : state rightSegmentState : rightSegmentState )
    }
}
```
https://github.com/rust-lang/rust-bindgen/commit/7d61f36a5bfcfe2ea533f5edcae8bb6991683432 fixed error that prevents the docs.rs docs from being generated: https://docs.rs/crate/bindgen/0.52.0/builds . It would be nice to have a working docs link again.
<!-- Thanks for filing a bindgen issue! We appreciate it :-) -->

### Input C/C++ Header

Note: In the real world, priority is an enum, but I wanted to keep this header minimal, as the outcome is the same.
```C++
extern "C" {
    void op_log(const char *message, const int priority = 1, const int line = -1, const char *function = "", const char *file = "");
}
```

### Bindgen Invocation
This is probably irrelevant, but for completeness:
```Rust
let bindings = bindgen::Builder::default()
        .clang_arg("include/rust_wrapper/wrapper.hpp")
        .clang_arg("-I./openpose/include")
        .clang_arg("-xc++")
        .clang_arg("-std=c++14")
        .parse_callbacks(Box::new(bindgen::CargoCallbacks))
        .generate()
        .expect("Unable to generate bindings");
```

### Actual Results

```rust
extern "C" {
    pub fn op_log(
        message: *const ::std::os::raw::c_char,
        priority: op_Priority,
        line: ::std::os::raw::c_int,
        function: *const ::std::os::raw::c_char,
        file: *const ::std::os::raw::c_char,
    );
}

```
### Expected Results
```rust
extern "C" {
    pub fn op_log(
        message: *const ::std::os::raw::c_char,
        priority: ::std::Option<op_Priority>,
        line: ::std::Option<::std::os::raw::c_int>,
        function:  ::std::Option<*const ::std::os::raw::c_char>,
        file:  ::std::Option<*const ::std::os::raw::c_char>,
    );
}
```

Now I am uncertain whether extern "C" supports that, as it might change the ABI, but if that's the case, one could keep op_log private (maybe _op_log) and expose a small op_log wrapper, which only passes the parameters when Some().

Alternatively, one could extract the default values and pass them using said wrapper.

Maybe you have a different idea as well :)
I'm getting a fail test for the Kangaroo Twelve hash function. The thing has quite some weird alignments depending on the architecture targeted so I'm not surprised (had similar issues when trying to write the bindings by hand):

```rust
#[test]
fn bindgen_test_layout_KangarooTwelve_Instance() {
    assert_eq!(
        ::std::mem::size_of::<KangarooTwelve_Instance>(),
        456usize,
        concat!("Size of: ", stringify!(KangarooTwelve_Instance))
    );
```

to replicate the problem: 

1. `git clone https://github.com/mimoo/xkcp-sys.git`
1. `git checkout bindgen`
1. `cargo build` or `cargo test`
1. to check the .h note the OUT_DIR in the failed test: `/home/vagrant/work/xkcp-sys/target/debug/build/<sys-xkcp-OUT_DIR>/out/XKCP/bin/generic64/libkeccak.a.headers/`

if you check the .h files you'll see this something like this:

```c
#define KeccakP1600_stateSizeInBytes    200
#define KeccakP1600_stateAlignment      8

// ...

typedef struct {
    KeccakWidth1600_12rounds_SpongeInstance queueNode;
    KeccakWidth1600_12rounds_SpongeInstance finalNode;
    size_t fixedOutputLength;
    size_t blockNumber;
    unsigned int queueAbsorbedLen;
    KangarooTwelve_Phases phase;
} KangarooTwelve_Instance;

// ...

KCP_DeclareSpongeStructure(KeccakWidth1600_12rounds, KeccakP1600_stateSizeInBytes, KeccakP1600_stateAlignment)
    KCP_DeclareSpongeFunctions(KeccakWidth1600_12rounds)

// ...

#define KCP_DeclareSpongeStructure(prefix, size, alignment) \
    ALIGN(alignment) typedef struct prefix##_SpongeInstanceStruct { \
        unsigned char state[size]; \
        unsigned int rate; \
        unsigned int byteIOIndex; \
        int squeezing; \
    } prefix##_SpongeInstance;
```
# Input C/C++ Header

```
#ifndef _PACKED_H_
#define _PACKED_H_

#include <stdint.h>

struct mystruct {
	unsigned	a : 2;
	unsigned	b : 4;
	unsigned	c : 3;
	unsigned	d : 5;
	unsigned	e : 2;
	uint16_t	f;
	uint32_t	g;
} __attribute__((packed));

#endif
```

### Bindgen Invocation

```
let bindings = bindgen::Builder::default()
    .header("wrapper.h")
    .parse_callbacks(Box::new(bindgen::CargoCallbacks))
    .generate()
    .expect("Unable to generate bindings");
```

### Actual Results

In Windows:
```
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mystruct {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub f: u16,
    pub g: u32,
    pub __bindgen_padding_0: [u8; 2usize],
}
```

### Expected Results

In Linux:
```
#[repr(C, packed)]
#[derive(Debug, Copy, Clone)]
pub struct mystruct {
    pub _bitfield_1: __BindgenBitfieldUnit<[u8; 2usize], u8>,
    pub f: u16,
    pub g: u32,
}
```

### Link to repo
https://github.com/Olangu/bindgen-bug
<!-- Thanks for filing a bindgen issue! We appreciate it :-) -->

### Input C Header

```C
struct mystruct {
};
```

### Bindgen Invocation
This is specifically for windows.  I've installed LLVM according to the documentation, and I'm setting my LIBCLANG_PATH like so (in powershell):
```
$env:LIBCLANG_PATH="C:\Program Files\LLVM\bin\"
```
Then I invoke bindgen like so:
```
bindgen test.h  -o src/bindings.rs
```

### Actual Results
```rust
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mystruct {
    pub _address: u8,
}
#[test]
fn bindgen_test_layout_mystruct() {
    assert_eq!(
        ::std::mem::size_of::<mystruct>(),
        4usize,
        concat!("Size of: ", stringify!(mystruct))
    );
    assert_eq!(
        ::std::mem::align_of::<mystruct>(),
        1usize,
        concat!("Alignment of ", stringify!(mystruct))
    );
}
```
### Expected Results
I expected it to generate an empty rust struct, like so:
```rust
/* automatically generated by rust-bindgen */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct mystruct {}
#[test]
fn bindgen_test_layout_mystruct() {
    assert_eq!(
        ::std::mem::size_of::<mystruct>(),
        0usize,
        concat!("Size of: ", stringify!(mystruct))
    );
    assert_eq!(
        ::std::mem::align_of::<mystruct>(),
        1usize,
        concat!("Alignment of ", stringify!(mystruct))
    );
}
```
From [this issue](https://github.com/rust-lang/rust-bindgen/issues/551) I understand that the 
_address field is supposed to be added for C++ structs, but this is a C struct.  Also, the tests 
that are generated are incorrect, the u8 _address field is 1usize not 4usize. 

I've tested this on linux and it's not a problem there.  

Here are the debugging logs:
```
[2019-11-20T23:44:04Z INFO  bindgen] Clang Version: clang version 8.0.1 (tags/RELEASE_801/final)
[2019-11-20T23:44:04Z WARN  bindgen] Using clang (8, 0), expected (3, 9)
[2019-11-20T23:44:04Z DEBUG bindgen] Generating bindings, libclang at C:\Program Files\LLVM\bin\libclang.dll
[2019-11-20T23:44:04Z DEBUG bindgen] Trying to find clang with flags: []
[2019-11-20T23:44:05Z DEBUG bindgen] Found clang: Clang { path: "C:\\Program Files\\LLVM\\bin\\clang.exe", version: Some(CXVersion { Major: 8, Minor: 0, Subminor: 1 }), c_search_paths: Some(["C:\\Program Files\\LLVM\\lib\\clang\\8.0.1\\include", "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.23.28105\\include", "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\shared", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\um", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\winrt"]), cpp_search_paths: Some(["C:\\Program Files\\LLVM\\lib\\clang\\8.0.1\\include", "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.23.28105\\include", "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\shared", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\um", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\winrt"]) }
[2019-11-20T23:44:05Z DEBUG bindgen] Fixed-up options: BindgenOptions { blacklisted_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, blacklisted_functions: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, blacklisted_items: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, opaque_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustfmt_path: None, whitelisted_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, whitelisted_functions: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, whitelisted_vars: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, default_enum_style: Consts, bitfield_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustified_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustified_non_exhaustive_enums: RegexSet { items: [], matched: [], set: None, record_matches: false }, constified_enum_modules: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, constified_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, builtins: false, emit_ast: false, emit_ir: false, emit_ir_graphviz: None, enable_cxx_namespaces: false, enable_function_attribute_detection: false, disable_name_namespacing: false, layout_tests: true, impl_debug: false, impl_partialeq: false, derive_copy: true, derive_debug: true, derive_default: false, derive_hash: false, derive_partialord: false, derive_ord: false, derive_partialeq: false, derive_eq: false, use_core: false, ctypes_prefix: None, time_phases: false, namespaced_constants: true, msvc_mangling: false, convert_floats: true, raw_lines: [], module_lines: {}, clang_args: ["-isystem", "C:\\Program Files\\LLVM\\lib\\clang\\8.0.1\\include", "-isystem", "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.23.28105\\include", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\shared", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\um", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\winrt", "test.h"], input_header: Some("test.h"), input_unsaved_files: [], parse_callbacks: None, codegen_config: FUNCTIONS | TYPES | VARS | METHODS | CONSTRUCTORS | DESTRUCTORS, conservative_inline_namespaces: false, generate_comments: true, generate_inline_functions: false, whitelist_recursively: true, objc_extern_crate: false, generate_block: false, block_extern_crate: false, enable_mangling: true, detect_include_paths: true, prepend_enum_name: true, rust_target: Stable_1_33, rust_features: RustFeatures { untagged_union: true, associated_const: true, builtin_clone_impls: true, repr_align: true, i128_and_u128: true, must_use_function: true, repr_transparent: true, min_const_fn: true, repr_packed_n: true, thiscall_abi: false, non_exhaustive: false }, record_matches: true, rustfmt_bindings: true, rustfmt_configuration_file: None, no_partialeq_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, no_copy_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, no_hash_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, array_pointers_in_arguments: false }
[2019-11-20T23:44:05Z DEBUG bindgen::ir::item] Item::from_ty_with_id: ItemId(1)
        ty = Type(struct mystruct, kind: Record, cconv: 100, decl: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")), canon: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))),
        location = Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] builtin_or_resolved_ty: Type(struct mystruct, kind: Record, cconv: 100, decl: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")), canon: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), Some(Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), Some(ItemId(0))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] Not resolved, maybe builtin?
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] builtin_or_resolved_ty: Type(struct mystruct, kind: Record, cconv: 100, decl: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")), canon: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), Some(Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), Some(ItemId(0))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] Not resolved, maybe builtin?
[2019-11-20T23:44:05Z DEBUG bindgen::ir::ty] from_clang_ty: ItemId(1), ty: Type(struct mystruct, kind: Record, cconv: 100, decl: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")), canon: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), loc: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::ty] currently_parsed_types: [PartialType { decl: Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")), id: ItemId(1) }]
[2019-11-20T23:44:05Z DEBUG bindgen::ir::comp] CompInfo::from_ty(Struct, Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] BindgenContext::add_item(Item { id: ItemId(1), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Type(Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: BeforeComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }) }, declaration: Some(Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct"))), loc: Some(Cursor(mystruct kind: StructDecl, loc: test.h:1:8, usr: Some("c:@S@mystruct")))
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] add_item_to_module: adding ItemId(1) as child of parent module ItemId(0)
[2019-11-20T23:44:05Z DEBUG bindgen::ir::context] No replacements to process
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_vtable] constrain ItemId(1)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_vtable]     comp considers its own methods and bases
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_vtable] constrain ItemId(0)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::sizedness] constrain TypeId(ItemId(1))
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::sizedness]     comp considers its own fields and bases
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::sizedness] inserting ZeroSized for TypeId(ItemId(1))
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params] constrain ItemId(1)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]   initially, used set is {}
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]     other item: join with successors' usage
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]   finally, used set is {}
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params] constrain ItemId(0)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]   initially, used set is {}
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]     other item: join with successors' usage
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::template_params]   finally, used set is {}
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] constrain: ItemId(1)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] ty: Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: AfterComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive]     can derive Debug because there are no members
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] inserting ItemId(1) can_derive<Debug>=Yes
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] constrain: ItemId(0)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive]     can derive Debug because there are no members
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] inserting ItemId(0) can_derive<Debug>=Yes
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] constrain: ItemId(1)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] ty: Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: AfterComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive]     can derive Copy because there are no members
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] inserting ItemId(1) can_derive<Copy>=Yes
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] constrain: ItemId(0)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive]     can derive Copy because there are no members
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::derive] inserting ItemId(0) can_derive<Copy>=Yes
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_type_param_in_array] constrain: ItemId(1)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_type_param_in_array]     comp doesn't have array
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_type_param_in_array] constrain: ItemId(0)
[2019-11-20T23:44:05Z TRACE bindgen::ir::analysis::has_type_param_in_array]     not a type; ignoring
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] codegen: BindgenOptions { blacklisted_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, blacklisted_functions: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, blacklisted_items: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, opaque_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustfmt_path: None, whitelisted_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, whitelisted_functions: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, whitelisted_vars: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, default_enum_style: Consts, bitfield_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustified_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, rustified_non_exhaustive_enums: RegexSet { items: [], matched: [], set: None, record_matches: false }, constified_enum_modules: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, constified_enums: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, builtins: false, emit_ast: false, emit_ir: false, emit_ir_graphviz: None, enable_cxx_namespaces: false, enable_function_attribute_detection: false, disable_name_namespacing: false, layout_tests: true, impl_debug: false, impl_partialeq: false, derive_copy: true, derive_debug: true, derive_default: false, derive_hash: false, derive_partialord: false, derive_ord: false, derive_partialeq: false, derive_eq: false, use_core: false, ctypes_prefix: None, time_phases: false, namespaced_constants: true, msvc_mangling: false, convert_floats: true, raw_lines: [], module_lines: {}, clang_args: ["-isystem", "C:\\Program Files\\LLVM\\lib\\clang\\8.0.1\\include", "-isystem", "C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Professional\\VC\\Tools\\MSVC\\14.23.28105\\include", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\Include\\10.0.18362.0\\ucrt", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\shared", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\um", "-isystem", "C:\\Program Files (x86)\\Windows Kits\\10\\include\\10.0.18362.0\\winrt", "test.h"], input_header: Some("test.h"), input_unsaved_files: [], parse_callbacks: None, codegen_config: FUNCTIONS | TYPES | VARS | METHODS | CONSTRUCTORS | DESTRUCTORS, conservative_inline_namespaces: false, generate_comments: true, generate_inline_functions: false, whitelist_recursively: true, objc_extern_crate: false, generate_block: false, block_extern_crate: false, enable_mangling: true, detect_include_paths: true, prepend_enum_name: true, rust_target: Stable_1_33, rust_features: RustFeatures { untagged_union: true, associated_const: true, builtin_clone_impls: true, repr_align: true, i128_and_u128: true, must_use_function: true, repr_transparent: true, min_const_fn: true, repr_packed_n: true, thiscall_abi: false, non_exhaustive: false }, record_matches: true, rustfmt_bindings: true, rustfmt_configuration_file: None, no_partialeq_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, no_copy_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, no_hash_types: RegexSet { items: [], matched: [], set: Some(RegexSet([])), record_matches: true }, array_pointers_in_arguments: false }
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] <Item as CodeGenerator>::codegen: self = Item { id: ItemId(0), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Module(Module { name: Some("root"), kind: Normal, children: {ItemId(1)} }) }
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] <Module as CodeGenerator>::codegen: item = Item { id: ItemId(0), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Module(Module { name: Some("root"), kind: Normal, children: {ItemId(1)} }) }
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] <Item as CodeGenerator>::codegen: self = Item { id: ItemId(1), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Type(Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: AfterComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }) }
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] <Type as CodeGenerator>::codegen: item = Item { id: ItemId(1), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Type(Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: AfterComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }) }
[2019-11-20T23:44:05Z DEBUG bindgen::codegen] <CompInfo as CodeGenerator>::codegen: item = Item { id: ItemId(1), local_id: Cell { value: None }, next_child_local_id: Cell { value: 1 }, canonical_name_cache: RefCell { value: None }, comment: None, annotations: Annotations { opaque: false, hide: false, use_instead_of: None, disallow_copy: false, private_fields: None, accessor_kind: None, constify_enum_variant: false, derives: [] }, parent_id: ItemId(0), kind: Type(Type { name: Some("mystruct"), layout: Some(Layout { size: 4, align: 1, packed: false }), kind: Comp(CompInfo { kind: Struct, fields: AfterComputingBitfieldUnits([]), template_params: [], methods: [], constructors: [], destructor: None, base_members: [], inner_types: [], inner_vars: [], has_own_virtual_method: false, has_destructor: false, has_nonempty_base: false, has_non_type_template_params: false, packed_attr: false, found_unknown_attr: false, is_forward_declaration: false }), is_const: false }) }
```

