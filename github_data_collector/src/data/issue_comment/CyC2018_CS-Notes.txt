[快速选择这里](https://github.com/Felyne/CS-Notes/blob/master/notes/Leetcode%20%E9%A2%98%E8%A7%A3%20-%20%E6%8E%92%E5%BA%8F.md#%E5%BF%AB%E9%80%9F%E9%80%89%E6%8B%A9):
堆也可以用于求解 Kth Element 问题，得到了大小为 k 的最小堆之后，因为使用了大顶堆来实现，因此堆顶元素就是`第 k 大`的元素
改正:  
这里是最小堆，应该是 "第 k 小"




for循环中嵌入while循环，这个时间复杂度应该不是O(n)了吧
原版实现，在计算 matrix[i][j] <= mid 的 count 时，耗时较高
请问算法的动画是用什么画的，我看draw.io不能动呀


如果进行 N 次操作，那么大约需要操作节点的次数为 `N-1+N=2N-1`，其中 N-1 表示 N-1 个不是尾节点的每个节点以 O(1) 的时间复杂度操作节点的总次数，N 表示 1 个尾节点以 O(N) 的时间复杂度操作节点的总次数。`(2N-1)/N ~ 2`，因此该算法的平均时间复杂度为 O(1)。

O(1) 和 O(N) 能理解  但 2N-1， N ~ 2 怎么理解？
