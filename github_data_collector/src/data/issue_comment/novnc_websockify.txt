Trying to start websockify on RHEL 6 gives:

    Starting webserver and WebSockets proxy on port 6080
    /usr/bin/python: websockify is a package and cannot be directly executed
    Failed to start WebSockets proxy

RHEL 6 has Python 2.6, this issue seems to have been fixed in python 2.7:

https://bugs.python.org/issue2751
This pull request builds on b46fab5 to further sanitize the port value that comes in when using the BaseTokenAPI plugin.

As far as I can tell, b46fab5 _only_ supports ascii based port values like `ssh` and not integer-based values like `22`. This results in identical failures to the ones described in novnc/websockify#399:

```
WebSocket server settings:
  - Listen on :80
  - No SSL/TLS support (no cert file)
  - proxying from :80 to targets generated by BaseTokenAPI
172.17.0.1 - - [02/Sep/2019 19:05:25] 172.17.0.1: Plain non-SSL (ws://) WebSocket connection
172.17.0.1 - - [02/Sep/2019 19:05:25] 172.17.0.1: Path: '/websockify?token=8bff5517-f620-461c-82df-6eb42163411b'
172.17.0.1 - - [02/Sep/2019 19:05:25] connecting to: 172.16.16.16:5910

172.17.0.1 - - [02/Sep/2019 19:05:25] Failed to connect to 172.16.16.16:5910
```

This commit makes two changes:
1. Strips any leading or trailing spaces from the port value
2. Checks to see if the ascii-encoded string is composed of digits, and if so, coerce the value to an `int`
There could be any error during a normal GET operation or even during a
'server-up' check before making an upgrade call. These errors are
currently unhandled, as a result the exception rises to the top of the
stack and if run_once is not used the entire process crashes with an
exception.

This problem become widely visible when using the
WebSocketProxy  which uses a request handler class.
To handle every request a new process is spawned and if it is an invalid
request (empty request, SSL HELLO etc) the process crashes.

With this patch in such a case the request is caught and an error is
sent back, allowing a graceful termination of process.
Added a [PyInstaller](https://www.pyinstaller.org/) .spec file to build a frozen distribution.
Also set "C" locale to limit required encodings modules.
I currently can't find a way to gracefully reload websockify in case the certificate changes.

With graceful I'd mean something similar to haproxy - when you reload haproxy, all existing connections are still served, but new ones receive the new certificate. At the moment, I restart websockify, which terminates any connections.

This would - I imagine - become more needed with let's encrypt, especially if they intend to shorten the certificate validity further.

If this is already possible, documentation would help in avoiding similar questions. ;)
Currently, there doesn't seem to be a way to limit the negotiated ciphers and friends to TLS 1.2 and above. 
It'd be great if there was some way to pass this configuration option to websockify (I'm referring mainly to the Python implementation, but surely all can benefit from it).
When running behind a reverse proxy, websockify doesn't currently read and log anything that could provide information on the originating client.

This code adds a startup flag (`--log-proxied-client`) to enable logging of originating client plus intermediate proxies. Information is retrieved from the "X-Forwarded-For" header (if present). The immediate client would be logged too at the end of the content of the header, separated by a comma.

Eg:
* default message: `127.0.0.1: Token 'abcd' not found`
* using the `--log-proxied-client` option: `192.168.0.51,127.0.0.1: Token 'abcd' not found`

See also https://github.com/novnc/websockify/issues/334
Hi,
I'm running websockify behind Apache configured as reverse proxy. websockify listens on the loopback interface and connects to the VNC servers using a custom token plugin.

Everything works nicely but I'd like to get info regarding the original client in the logs of websockify for each relevant entry.

I made some changes to the request handler and to `WebSockifyServer` to accomodate this. I'm sharing them in case anybody is interested (using websockify behind a reverse proxy seems to be quite common), and I would greatly appreciate some feedback.

The change to the request handler is quite straightforward (just get the info from the `X-Forwarded-For` header, if present). 

I also wanted to show this in the logs produced by `WebSockifyServer`, for example when no token is found. When this happens an exception gets raised from the request handler, so I added the information to the exception for `WebSockifyServer` to read. It works but I don't particularly like it, can anybody think of a better way to do it?

Thanks!

The log messages are like the following, when communication is proxied:
```
192.168.0.109 (forwarded by 127.0.0.1) - - [08/Mar/2018 17:38:59] "GET /?token=tokenABC HTTP/1.1" 101 -
```

And here's the diff:
```diff
diff --git a/websockify/websocketserver.py b/websockify/websocketserver.py
index 6d4824a..ef525d9 100644
--- a/websockify/websocketserver.py
+++ b/websockify/websocketserver.py
@@ -35,6 +35,13 @@ class WebSocketRequestHandler(BaseHTTPRequestHandler):
     def __init__(self, request, client_address, server):
         BaseHTTPRequestHandler.__init__(self, request, client_address, server)
 
+    def original_client(self):
+        # Get the originating client if running behind reverse proxies.
+        # Defaults to BaseHTTPRequestHandler.address_string() if request
+        # is not proxied
+        fwd_list = self.headers.get("X-Forwarded-For", None)
+        return fwd_list.split(",")[0] if fwd_list else self.address_string()
+
     def handle_one_request(self):
         """Extended request handler
 
diff --git a/websockify/websockifyserver.py b/websockify/websockifyserver.py
index f6c067c..366556c 100644
--- a/websockify/websockifyserver.py
+++ b/websockify/websockifyserver.py
@@ -99,13 +99,19 @@ class WebSockifyRequestHandler(WebSocketRequestHandler, SimpleHTTPRequestHandler
 
         WebSocketRequestHandler.__init__(self, req, addr, server)
 
-    def log_message(self, format, *args):
-        self.logger.info("%s - - [%s] %s" % (self.address_string(), self.log_date_time_string(), format % args))
-
     #
     # WebSocketRequestHandler logging/output functions
     #
 
+    def log_message(self, format, *args):
+        self.logger.info("%s - - [%s] %s" % (self.print_original_client_ip(), self.log_date_time_string(), format % args))
+
+    def print_original_client_ip(self):
+        client = self.original_client()
+        if client != self.address_string():
+            return "{original_client} (forwarded by {last_proxy})".format(original_client=client, last_proxy=self.address_string())
+        return client
+
     def print_traffic(self, token="."):
         """ Show traffic flow mode. """
         if self.traffic:
@@ -212,7 +218,13 @@ class WebSockifyRequestHandler(WebSocketRequestHandler, SimpleHTTPRequestHandler
 
     def handle_upgrade(self):
         # ensure connection is authorized, and determine the target
-        self.validate_connection()
+        try:
+            self.validate_connection()
+        except Exception as e:
+            if self.original_client() != self.address_string():
+                # Add info on remote client and re-raise
+                e.orig_client = self.print_original_client_ip()
+            raise
 
         WebSocketRequestHandler.handle_upgrade(self)
 
@@ -602,18 +614,20 @@ class WebSockifyServer(object):
     # WebSockifyServer logging/output functions
     #
 
-    def msg(self, *args, **kwargs):
+    def msg(self, msg, *args, **kwargs):
         """ Output message as info """
-        self.logger.log(logging.INFO, *args, **kwargs)
+        self.logger.log(logging.INFO, self.prefix_msg(msg, kwargs.pop("prefix_msg", None)), *args, **kwargs)
 
-    def vmsg(self, *args, **kwargs):
+    def vmsg(self, msg, *args, **kwargs):
         """ Same as msg() but as debug. """
-        self.logger.log(logging.DEBUG, *args, **kwargs)
+        self.logger.log(logging.DEBUG, self.prefix_msg(msg, kwargs.pop("prefix_msg", None)), *args, **kwargs)
 
-    def warn(self, *args, **kwargs):
+    def warn(self, msg, *args, **kwargs):
         """ Same as msg() but as warning. """
-        self.logger.log(logging.WARN, *args, **kwargs)
+        self.logger.log(logging.WARN, self.prefix_msg(msg, kwargs.pop("prefix_msg", None)), *args, **kwargs)
 
+    def prefix_msg(self, msg, prefix=None):
+        return "%s - %s" % (prefix, msg) if prefix else msg
 
     #
     # Events that can/should be overridden in sub-classes
@@ -666,17 +680,25 @@ class WebSockifyServer(object):
         try:
             try:
                 client = self.do_handshake(startsock, address)
-            except self.EClose:
-                _, exc, _ = sys.exc_info()
-                # Connection was not a WebSockets connection
-                if exc.args[0]:
-                    self.msg("%s: %s" % (address[0], exc.args[0]))
-            except WebSockifyServer.Terminate:
-                raise
-            except Exception:
-                _, exc, _ = sys.exc_info()
-                self.msg("handler exception: %s" % str(exc))
-                self.vmsg("exception", exc_info=True)
+            except Exception as e:
+                # Handle the generic exception first so that we get the original client once
+                try:
+                    original_client = e.orig_client
+                except AttributeError:
+                    original_client = None
+                try:
+                    raise
+                except self.EClose as e:
+                    _, exc, _ = sys.exc_info()
+                    # Connection was not a WebSockets connection
+                    if exc.args[0]:
+                        self.msg("%s: %s" % (address[0], exc.args[0]), prefix_msg=original_client)
+                except WebSockifyServer.Terminate:
+                    raise
+                except Exception:
+                    _, exc, _ = sys.exc_info()
+                    self.msg("original client: {} - handler exception: %s".format(original_client) % str(exc), prefix_msg=original_client)
+                    self.vmsg("exception", exc_info=True, prefix_msg=original_client)
         finally:
 
             if client and client != startsock:
```

Issue #276 mentions that passing concatenated certs to websockify can cause issues.  We should investigate and fix this.
First off, thank you for this project! Second, have read [https://github.com/novnc/websockify/wiki/Token-based-target-selection](https://github.com/novnc/websockify/wiki/Token-based-target-selection) and third, have tried + read [wstelnet.js](https://github.com/novnc/websockify/blob/master/include/wstelnet.js) ....

As per issue https://github.com/novnc/websockify/issues/213 is it incumbent upon user to rewrite wstelnet.js to support the token path syntax (as from looking at telnet code and also trying, it seems like the URI is not rebuilt/supported (only host and port lines 147-168 of [wstelnet.js](https://github.com/novnc/websockify/blob/master/include/wstelnet.js), or am I missing something in front of my nose?)

Currently I have noVNC working with tokens/websockify but am confused about whether tokens should work with wstelnet.js?   Please feel free to point me elsewhere and/or close if wrong forum/medium.