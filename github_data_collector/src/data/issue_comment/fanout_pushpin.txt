Currently, SIGHUP only reloads the routes file but not the whole configuration. We should consider a way to reload the whole configuration without having to disconnect clients.
https://pushpin.org/docs/protocols/grip/ states that `prev-id` only works for `response` hold mode

> Grip-Hold: The hold mode, either `response` or `stream`. [...]
> Grip-Channel: [...] The `prev-id` parameter is OPTIONAL and only applies to the `response` mode.

But then https://pushpin.org/docs/advanced/#reliability shows a code example using `prev-id` with `stream` hold mode

> Reliable HTTP streaming
> When creating a stream hold, any channel to be subscribed must include a prev-id value. A next link must also be provided:
> 
> `HTTP/1.1 200 OK`
> `Content-Type: text/plain`
> `Grip-Hold: stream`
> `Grip-Channel: fruit; prev-id=3`
> `Grip-Link: </fruit/?after=3>; rel=next`

Overall, it seems like the GRIP protocol page is obsolete (e.g. no trace of `Grip-Link` in it either)
That should be useful on production env. Or can you support syslog also?
Pushpin supports https for the proxy process, however there is no option on pushin-handler. When push data, It's only supporting http. Can you support https? Or is there any secure socket that I can use?
after fresh installation and test, i try to send msg to channel from php.
here is my code
```
$pub = new GripPubControl(array(
            'control_uri' => 'http://localhost:7779'
        ));

        $pub->publish_http_stream('ws', 'hello there\n');
```
but i got this error even open port in firewall.
```
Failed to publish: Failed to connect to localhost port 7779: Connection refused
```

whats wrong?
Hi! This is an amazing project thanks for building it.

I was wondering if there was any intention of supporting the `gRPC` protocol going forward; or if there is already a way for **pushpin** to reverse proxy to a `gRPC` server?

It would be good to have a kubernetes helm chart for easy deployment inside Kubernetes.
With HTTP streaming, it's possible to set a "next link". Next links are followed without passing along extra headers, such as the original client request headers. This means authenticating a request of a next link requires authentication material to be included in the link itself, for example by include an auth token as a query parameter. It might be nice if there were a way for requests of next links to use headers for auth.

Note that next links are intended to be shared by multiple clients to enable request collapsing, so a headers-based solution should have a way to provide special shared creds generated by the origin server, rather than only simply passing the original client request headers which would likely include client-specific creds.
Would you like to [wrap any pointer data members](https://github.com/fanout/pushpin/blob/9f9b7ff41080701162d68a336da7740f53ca9c59/src/corelib/settings.cpp#L37 "Update candidate") with the template class “[std::unique_ptr](https://en.wikipedia.org/wiki/Smart_pointer#unique_ptr "Description for the usage of smart pointers")”?
It should be possible to enable a reliable mode for WebSocket connections, similar to what can be done with HTTP connections. The server should be able to supply a prev ID when subscriptions are assigned to connections, and Pushpin should be able to query for missed messages per-channel by last known ID. The feature should work for both WebSocket targets and HTTP targets (WebSocket-over-HTTP).

The big question is what protocol to use for the recovery requests. For WebSocket targets, it could be done using WebSocket messages, however there may be value in having it work over HTTP. For HTTP targets, it could be done using WebSocket messages encapsulated in WebSocket-over-HTTP protocol, but it would be nice if requests could use GET and reuse existing constructs like Grip-Link, Grip-Last, etc.

Note that if the protocol will use WebSocket messages, we'll likely need a way for Pushpin to send control messages to the backend which is not yet possible.