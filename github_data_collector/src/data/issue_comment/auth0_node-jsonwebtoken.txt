### Description

The `decode` function already accepts a `json` option, which when set to true will always try and parse the resulting payload as JSON, and throw an error if that fails.

This patch adds the same option to the `verify` function, by passing the `json` option thru to the `decode` function.

### Testing

This can be tested by passing `{ json: true }` to `verify`, with a token that has a string payload. That should throw a JSON parse error.

- [ ] This change adds test coverage for new/changed/fixed functionality

### Checklist

- [ ] I have added documentation for new/changed functionality in this PR or in auth0.com/docs
- [ ] All active GitHub checks for tests, formatting, and security are passing
- [ ] The correct base branch is being used, if not `master`

### Description

> I have a JWT generated by an .NET application and i have the key used to sign they, but the header of this JWT has a w3c url on "alg" property and for this can't be verified with jsonwebtoken

Alg should be HS256, but ...

```json
{
  "$type": "System.IdentityModel.Tokens.Jwt.JwtHeader, System.IdentityModel.Tokens.Jwt",
  "alg": "http://www.w3.org/2001/04/xmldsig-more#hmac-sha256",
  "typ": "JWT"
}
```

### Reproduction

> Generate JWT with .NET
```c#
using System;
using System.IdentityModel.Tokens;
using Thinktecture.IdentityModel.Tokens;
using System.IdentityModel.Tokens.Jwt;

var token = new JwtSecurityToken(issuer, audience, claims, issued, expires, key);
```

> Try to verify with jsonwebtoken
```js
jwt.verify(token, key, (err, decoded) => {});
jwt.verify(token, key, { algorithms: ['HS256'] }, (err, decoded) => {}); // Same result
```

> Results
$ invalid algorithm

### Environment

> Please provide the following:

- **Version of this library used: 8.5.1**
- **Other relevant versions (language, server software, OS, browser): NodeJS on MacOs**

How to verify this JWT without change the .NET application ?



### Description

Expose `timespan` as an utility function so as to be able to expose or return the `expiresIn` from a signed token. Just a simple helper function to not have to decode the token to determine when the token expires. As well as having access to `ms`.

For example, many web based applications only do a silent refresh of the token when receiving a 401. A more better experience is the client to know when the token will expire and proactively refresh. While it is true you can decode the token on the client but that requires another unneeded lib or another step in the flow. Ideally just pass back the expiration date with the token.

I agree there are other ways of doing this but it just seems like a very simple and valid way of ensuring the code cohesiveness.

### References

```javascript
const { sign, timespan } = require("jsonwebtoken")

exports.createAccessToken = ({ id: userId }) => {
    const exp = timespan("15m")

    return {
        token: sign({ userId, exp }, process.env.ACCESS_TOKEN_SECRET),
        expiresIn: exp
    }
}
```

### Testing

None that I am aware of.

### Checklist

- [X] I have added documentation for new/changed functionality in this PR or in auth0.com/docs
- [X] All active GitHub checks for tests, formatting, and security are passing
- [X] The correct base branch is being used, if not `master`

I want to know about that why jsonwebtoken package does not provide destroy method to kill the token. I am getting stuck to find out the solution How to set expire time to 0 or current time while logout in NodeJSapp?
Please give me the proper solution for that.
### Describe the problem you'd like to have solved

When working in a ES6 module project I would like to be able to `import` jsonwebtoken.

### Describe the ideal solution

A specific build for ESM/ES6 Module as other projects have, like this: https://github.com/vuejs/vue/blob/dev/dist/vue.runtime.esm.js . Or entirely switch to ESM/ES6 Modules in a new major release.

## Alternatives and current work-arounds

In a ESM context I know of no workarounds, except rewriting how the project exports.

### Additional context

Great docs on ESM over at Mozilla: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import

### Description

sign and verify works fine in simple test, but not in simple Express APP with SECRET as String. While it work with SECRET as `Buffer`.

### Reproduction

1. clone this repository: [PeichengLiu/track-server](https://github.com/PeichengLiu/track-server.git).
2. install dependencies.
3. run simple test, `node src/test.js`, all fine.
4. run express app, `npm run dev`.
5. send post request to `http://127.0.0.1:1234/signup`, we can get token; and then try to visit `http://127.0.0.1:1234/`, we can get expected response.
6. directly use SECRET as String in file `authRoutes.js` and `requireAuth.js` to sign and verify. You'll find that JWT NOT work as expected.

### Environment

OS Name: Microsoft Windows 10 Pro
OS Version: 10.0.18362 N/A Build 18362
Node.js:  v12.14.0

### Description

Sometime verify throws `SyntaxError` instread of `JsonWebTokenError`

### Reproduction

```js
var jwt = require("jsonwebtoken")
const malformed_token='eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c';

jwt.verify(
        malformed_token,
        'Secret',
        {
          algorithms: [ 'HS256' ],
        }
      );
```

### Environment
**Version of this library used:** 8.5.1


### Description

This PR updates the `jws` dependency, while the dependency upgrade is a major version, since `jsonwebtoken` does its own JWS algorithm check which didn't suffer the flaw of the `jws`/`jwa` one we can release this as a patch release.

Lowercase or match cased algorithm names are also [not listed as supported](https://github.com/auth0/node-jsonwebtoken#algorithms-supported). Ergo, this should be a bug fix.

### References

https://github.com/brianloveswords/node-jws/compare/v3.2.2...v4.0.0
https://github.com/brianloveswords/node-jwa/compare/v1.4.1...v2.0.0
### Description
@hmcfletch and I would find it useful to have `jwt.verify` also accept an array of keys, such that we can rotate our signing key & pass both keys to verify during a grace period. It'd be great to hear your feedback if it's something you're interested in.

We wrapped the existing `secretOrPublicKey` argument into an array rather than adding another `options.algorithms` field, as that seemed a bit more graceful.

It will:
- error if unsigned token given with secretOrPublicKey array containing truthy values
- error if signed token given with secretOrPublicKey array not containing truthy values
- error if token algorithm is unsupported by default algorithms of every key (if options.algorithms is unset)
- then successfully decode if any key verifies the token

### References
[Key rotation previously discussed here](https://github.com/auth0/node-jsonwebtoken/issues/458) (JWK seemed like overkill for our use case)

### Testing

We put the basic functionality tests at the bottom of `verify.tests.js`. We put more extensive tests where we mixed in different algorithms in a separate file.

- [x] This change adds test coverage for new/changed/fixed functionality

### Checklist

- [ ] I have added documentation for new/changed functionality in this PR or in auth0.com/docs
- [x] All active GitHub checks for tests, formatting, and security are passing
- [x] The correct base branch is being used, if not `master`

Docs can be added if there's interest in merging.

### Description
Replaces the mystery way of checking if string contains other string using `~str.indexOf` with `str.includes`.