1.a=$(grep a test)
 echo ${(t)a}
 得到： scalar
 但：echo ${(t)$(grep a test)}
 就什么输出都没有
2.test文件有一行是以$为开头的
echo ${"$(<test)"[(fr)\$*]}
结果输出是没问题的
但当我把$换成单引号
echo ${"$(<test)"[(fr)\‘*]}
结果就是什么输出也没有，明明文件里有这一行，但是却没有匹配成功
3.还有就是那个(r)变量修饰符，我花了老大的劲才试出来它原来是不支持正则的，支持的是通配符
回想一开始学python的时候，根本没有这么多事。。


touch a.txt
file a.txt # 文件为空

print -l *(.^F) 这样才能选中这个空文件
异常处理语句

# 格式
{
    语句 1
} always {
    语句 2
}

如果语句 1 执行出错，则执行语句 2。

---------
```
{ 
true
} always{
echo yyy
}


{ 
false
} always{
echo yyy
}
```
结果都是会输出yyy
假设读者不知道短路求值，增加必要的解释
我的思路是要么读入整体文件转为数组```array=(${(f)"$(<test.txt)"})```，要么用```while {read line}```逐行读取。

但遇到空行都会忽略。我猜测是(f)转换时就会跳过空行，而while方案也会有一样的问题（可能是read返回值问题交给while判断出错，或者read本身就是忽略空行的）。导致单纯通过zsh做逐行处理还原一个文件成了不可能的任务（不想用sed这些指令）。

为此我还试了read的各种参数，搞了整整一个下午，有种条条大路是死路的感觉。。

求教大佬有没有什么方法能在纯shell脚本中解决这类问题？