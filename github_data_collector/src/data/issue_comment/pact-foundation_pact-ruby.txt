Need to subclass the RSpec Progress formatter and modify the output text to match lib/pact/provider/rspec/formatter_rspec_3.rb:71

Formatter is configured here:
lib/pact/provider/pact_spec_runner.rb:130


(This is a copy of [an issue from pact-node](https://github.com/pact-foundation/pact-node/issues/183). I was advised that since `pact-node` is a wrapper around `pact-ruby`, the underlying problem is actually here)


## Software versions

-   **OS**: Windows 10
-   **Library version**: 9.0.4
-   **Node Version**: 10.15.3

## Expected behaviour

Pact mock client during pact provider tests should send HTTP DELETE requests with HTTP body correctly.

## Actual behaviour

It doesn't send HTTP DELETE requests correctly.

I'm using Node.js with Express framework as the server, and I'm running pact provider tests / pact verifications. One of the pact interactions is a DELETE request that has a request body ([The spec](http://www.w3.org/Protocols/rfc2616/rfc2616-sec9.html) does not forbid it). All other requests go through fine, but the delete request seemingly makes the server freeze and not return anything until the timeout, at which it resets the HTTP connection (see the pact provider log attached).

Upon further investigation with Wireshark I found out the underlying problem: the pact mock client doesn't even send all of the TCP packets that make up the HTTP DELETE request - it stops short of sending the body. This makes the server wait for the remaining packet, which never comes, thus hanging the test until it times out.

![image](https://user-images.githubusercontent.com/4726607/65143985-f5d8a200-da1e-11e9-94a2-85af95d38e5b.png)

Interestingly, it does send `Content-Length: 15` in the first packet, indicating that there will be a body in the following packet(s), but it never sends it.

I assume that the issue is in the underlying Ruby HTTP client? As stated in the previous issue thread, many Ruby HTTP clients either don't support DELETE requests with body, or they do, but require a special way of calling them ([stackoverflow thread](https://stackoverflow.com/questions/14704885/how-to-send-delete-request-with-body-using-ruby-gem))

## Steps to reproduce

Try to verify a pact with the following interaction:

```
{
      "description": "A DELETE request to delete one reminder",
      "providerState": "User user1@example.com exists with 2 smart reminders",
      "request": {
        "method": "DELETE",
        "path": "/api/users/22/schedule",
        "headers": {
          "Content-Type": "application/json",
        },
        "body": {
          "items": [
            100
          ]
        }
      },
      "response": {
        "status": 204,
        "headers": {
        }
      }
    }
```
(or any pact that has a HTTP DELETE method with a request body).

## Relevant log files

Log file generated by pact provider test attached.
[pact-provider.log](https://github.com/pact-foundation/pact-node/files/3625986/pact-provider.log)
Hi,

I've got an EmberJS app which generates pacts. Let's say we fetch a list of _articles_ each one with a _title_ we do not want to verify explicitely. The (truncated) generated pact is : 
```
"matchingRules": {
  "$.body.data[*].attributes.title": {
    "match": "type"
  }
},
```

When I `verify` with **pact-ruby** (`v1.41.2`) it seems not to understand the directive as I have the following errors : 
```
* Expected "enim dolores nihil" but got "some text" at $.data[0].attributes.title
* Expected "quasi cupiditate temporibus" but got "some text" at $.data[1].attributes.title
* Expected "repellendus doloribus quis" but got "some text" at $.data[2].attributes.title
* Expected "asperiores non labore" but got "some text" at $.data[3].attributes.title
* Expected "quae quas consequuntur" but got "some text" at $.data[4].attributes.title
```

What did I miss ?
Reverts pact-foundation/pact-ruby#126 â€” after a long time I checked the link again, and apparently the blog owner has updated the dates, so now the old link is working again.
Hi.

I work with an app that has many consumers. We recently upgraded our pact-broker and I am currently setting up webhooks to verify pacts on `contract_content_changed` event. Im wondering is there a way for the provider to verify pacts from a specific consumer? Looking at the docs I see options for passing in a provider state or a specific interaction, but I couldn't find an option where one could specify "verify all interactions of consumer Foo". 
Hello, I'm using pact-js to verify an express-js based provider. Having debugged this issue for a while, I found that `pact-ruby` expects to have multiple provider states, while the pact file only contains one provider state. Here is a verbose log output from the verification, that uses `pact-provider-verifier`, that again uses `pact-ruby` (as a library(?), I'm no ruby expert):

(version: 1.64.0)

`$ pact-provider-verifier --provider myGraphlServer --provider-base-url http://localhost:9999 --pact-broker-base-url https://[my broker] --provider-states-setup-url http://localhost:9999/_pactSetup --verbose`

```
...
INFO: Reading pact at https://[my broker]

Verifying a pact between myFrontend and myGraphqlServer
  Given There is a feed with semanticKey "innsikt-hovedfeed" with one notice
    A request for published notices
      with POST /graphql
        returns a response which
DEBUG: Setting up provider state '' for consumer 'myFrontend' using provider state set up URL http://localhost:9999/_pactSetup
...
```

A quick study of the ruby code reveals that an `interaction` object has a `provider_state`, which is used for the log line with `"Given ${interaction.provider_state}"`. But then `set_up_provider_states` is called with a different property: `interaction.provider_states` (_plural_); this property is somehow not defined in my pact.

Then my node-js based verifier receives a `POST` request to configure its provider state, and the body of that request is `{"consumer":"myFrontend","state":null,"states":[null],"params":{}}` (intercepted with netcat, `nc -l 9999`) and there's no hack that I can currently do to make it work.

If you need more info, I can provide a sample pact file with an exact command line to invoke the ruby verifier.
I believe `ConsumerContractBuilder` is trying to expose `attr_reader :consumer_contract`, but it's incorrectly setting that value to `@consumer_contract_details` instead. `@consumer_contract_details` is never used outside of this class.

This PR populates `@consumer_contract` instead of `@consumer_contract_details`.
Hi

We are coding on ruby (https://github.com/umbrellio) and are looking for the system for testing our decoupled services. In particular we have a number of HTTP APIs. At some point we found Pact and decided to try it out. And we encountered some difficulties using it.

First of all, it's somewhat weird that core ruby implementation doesn't implement 3rd version of pact-specification.

Then we have found some bugs (or we just didn't understand how it works).

For example, when we describe provider state at the provider side and we have an exception in `set_up` block, it doesn't call the `tear_down` block. We are using transaction database cleaner strategy, and we can't rollback the transaction because of this behaviour. We would like to use something like rspec `around` strategy, but it just doesn't exist.

Secondly, we'd like to use an array of regexps in consumer pacts. We tried to use this code:
```
dates: each_like(Pact.term(generate: "2018-08-03", matcher: /\d{4}\-\d{2}\-\d{2}/)),
```
and on the consumer side it sucessfully generates the json with:
```
        "body": {
          "dates": [
            "2018-08-03"
          ]
        },
        "matchingRules": {
          "$.body.dates": {
            "min": 1
          },
          "$.body.dates[*].*": {
            "match": "type"
          },
          "$.body.dates[*]": {
            "match": "regex",
            "regex": "\\d{4}\\-\\d{2}\\-\\d{2}"
          }
        }
```
As we can see, there is a matching rules for `$.body.dates[*]` that is obviously saying that every item of the `dates` array must match a regexp. But `pact:verify` script doesn't respect it saying that
```WARN: Ignoring unsupported matching rules {"match"=>"regex", "regex"=>"\\d{4}\\-\\d{2}\\-\\d{2}"} for path $['body']['dates'][*]```

Then we tried to use a regexp in `Pact.term` with `i` modifier to make it case-insensitive, like
```Pact.term(generate: "AA", matcher: /a+/i)```
but we've got an error
```RuntimeError:
  Value to generate "AA" does not match regular expression /a+\//
```

We like the ideas underlying Pact and it already does a lot. And we'd love to use it in our projects. But obviously, there is some room for improvements at least with specs integration and troubleshooting. We'd like to know if you are interested in collaboration, foreign pull requests to codebase and will you help us to investigate and solve the problems together.
Hello!

Thank you very much for Pact. It's awesome.

This is more of a conceptual question than a bug report, so I'm not providing much code but I would happily arrange it if necessary. Also, I guess this is a common use case but I wasn't able to find examples for it -- that's why I'm filing this issue. Hopefully, it can be addressed by only referring to some examples.

I'm using Pact for testing a services architecture like this:

    service A --consumes--> service B --consumes--> service C

My intended approach is writing tests by hand only for service A and having Pact to verify proper behavior for services B and C based on generated pacts. I was able to generate the pact `a-b.json` from A's tests execution and now I want to use it for verifying B while generating `b-c.json` pact.

My attempt for this looks like this:

```ruby
# ./spec/service_consumers/pact_helper.rb inside B

Pact.service_provider 'B' do
  honours_pact_with 'A' do
    pact_uri 'a-b.json'
  end
end

Pact.service_consumer 'B' do
  has_pact_with 'C' do
    mock_service :c_service do
      port 1234
    end
  end
end

# This is how I accomplished mocking B -> C requests
c_service = Pact.consumer_world.consumer_contract_builders.first
c_service.given('some state')
  .upon_receiving('some request')
  .with(method: :get, path: '/resource')
  .will_respond_with(status: 200, body: [])

# This is for writing `b-c.json` so I can verify C with Pact
RSpec.configure do |config|
  config.after(:suite) do
    Pact.consumer_world.consumer_contract_builders.each { |c| c.write_pact }
  end
end
```

This seems to satisfy my use case but I was expecting a cleaner way for mocking and writing the pact file. Specifically, I feel I'm missing what happens within RSpec specs when we assign `pact: true`: disposal of `c_service` instance on the fly and automatically written pact file.

I wonder if this is a common use case and how to appropriately tackle it. Hope you can guide me in the right direction.

Thanks again,
Matheus
I am trying to write a pact test in Ruby, where consumer makes a post call with 
payload{
    multipart: true,
    file: fileObject,
   name: "name"
  }
where file is some kind of media file.
please, make support for this feature