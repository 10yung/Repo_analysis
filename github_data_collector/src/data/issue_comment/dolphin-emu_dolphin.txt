This solves the issue of booting games locally while connected to NetPlay causing desync.
Fixes: https://bugs.dolphin-emu.org/issues/11917

Unfortunately udev seems to enumerate devices in a seemingly random order.
This is especially problematic for multi-port controller adapters.
Users expect our device list ordering to match the physical ports on their adapter.

This PR sorts evdev devices based on their /dev/ name.
I cannot find any other more reliable means of sorting.
Up and Down inputs are listed first for every other control group: point, tilt, swing, gyro, d-pads and analog-sticks.
This makes `IMUAccelerometer` match.
Otherwise, a line that's too wide for the log widget will cause the horizontal scroll bar to appear, which reduces the vertical height, and causes the most recent line to be off screen.  Since that line is off screen, the log widget no longer scrolls as new lines appear, unless it's manually scrolled to the very bottom again.
This removes some old hack where Gamecube games are marked as running on a devkit; [YAGCD ยง4.2.1.1.2](http://hitmen.c02.at/files/yagcd/yagcd/chap4.html#sec4.2.1.1.2) explains the different values for 0x8000002C.  Note that Wii titles already use the production version (except when actually running development titles):

https://github.com/dolphin-emu/dolphin/blob/1cc7ef356b9a33814efb290368150a1cceb0a3ed/Source/Core/Core/Boot/Boot_BS2Emu.cpp#L330-L331

I don't know too much of the context of the old hack, but blaming does give [some very old comments](https://github.com/dolphin-emu/dolphin/blame/feea7ebed50313e5986a36b1de8baa03158fff7d/Source/Core/Core/Src/Boot/Boot_BS2Emu.cpp#L75-L80) that claim it is related to DSP timing.  Since that's improved a lot in the past decade, I doubt this hack is no longer needed.

I have not tested this myself, as I do not own Ikaruga.
Due to the way the ModRM encoding works on x86, memory addressing combinations involving RBP or R13 need an additional byte for an 8-bit displacement of zero.

However, this was also applied in cases where it is unnecessary, effectively wasting a byte.

This PR adds some tests, fixes the issue, refactors the relevant function, and cleans up some unrelated minor things in the neighborhood.

- MatR with RSP or R12
```
8B 44 24 00          mov         eax,dword ptr [rsp]
8B 04 24             mov         eax,dword ptr [rsp]
```
- MRegSum with base != RBP or R13
```
46 8D 7C 37 00       lea         r15d,[rdi+r14]
46 8D 3C 37          lea         r15d,[rdi+r14]
```
- MComplex without offset
```
8B 4C CA 00          mov         ecx,dword ptr [rdx+rcx*8]
8B 0C CA             mov         ecx,dword ptr [rdx+rcx*8]
```
Hi, I'm Emanuele Iannone, a master student at University of Salerno.
Since my bachelor's thesis I have been working on a **code smell refactoring plugin** called *aDoctor*, which is able to identify and fix energy-related problems in Android apps.
I launched it on your project, finding different instances of code smells. I chose one of them and let the plugin automatically fix it.
In this case I chose Member Ignoring Method, that is present when a non static method does not use at all instance variables and other non static methods. These kind of smell may have a non trivial impact on energy consumption, as shown in this paper: `https://www.sciencedirect.com/science/article/pii/S0950584918301678`.
Besides, this kind of refactoring does not impact on the functionalities of your app, so it is totally safe. Let me know if you are interested in this refactoring proposal.
Currently, we do not display every second frame in 25fps/30fps games which run to vsync. This improves performance as there's less rendering for the GPU to perform, but when combined with vsync, could cause frame pacing issues.

This commit adds an option to force every frame generated by the console to be displayed to the host, which may improve pacing for these games.
Nunchuk and Classic Controller calibration hold values imposed by the stick "gate" on real hardware.
We incorrectly provided the full range beyond the stick gate.

The Classic Controller's trigger calibration is the neutral value to 8 bits of precision, not the maximum value.

These changes are probably mostly unnoticeable. Games seem to mostly ignore the calibration data.
Replaced wide usages of `g_wiimote_sources` with get/set functions.
Made the unnamed enum type an enum class, `WiimoteSource`.

Connected real Wii remotes are now added to a "pool" when no open slot is available.
Wii remotes in the pool have LEDs 1 and 4 lit to make it apparent they are not active.
They are disconnected per normal after 5 seconds.
This allows reassigning sources and reordering remotes without the hassle of Bluetooth re-connections.

This is mainly in preparation for Wii remotes in controller interface.
My plan is an option on the Wii remote dialog, "Connect Wii Remotes for input configuration" (or something with a better name).
Enabling it will first fill any "Real" slots but additional remotes will be sent to controller interface.
Disabling the option will send spurious remotes to the pool.

I think this "pool" will make things less horrible for users that are playing around with options.
Making Wii remote connections can be not-fun, especially on Windows/macOS.
Holding on to a connection for a few seconds when between configurations will give users a better experience

Perhaps someone ambitious might make a UI for the pool.
Remotes could be identified with rumble and sent to a slot or controller interface.

This all of course only affects emulated Bluetooth.