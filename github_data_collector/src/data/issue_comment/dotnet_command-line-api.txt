I love the way DragonFruit works... 

This style will work for 90% of cli work.

Great work. 

Thanks, Chad
This will address #723.
Many interactive programs will match commands by prefix. In GDB for example, `dis`, `disas`, `disassem`, etc are all equivalent to `disassemble`. Having an out-of-the-box option that could enable this command matching behavior would make the experience of using `System.CommandLine` for such scenarios much smoother. I imagine it could be implemented as a middleware function.
Please see the changes I've made so far for #166 to access the return value of a command. I'm not sure if this is the desired approach for accomplishing this but hopefully this helps explain further what I'm trying to accomplish. A lot of the tests fail now though, so there must be something problematic about what I've done. I would appreciate any recommendations for alternate desired implementation approaches to take.

I added a `InvocationContext.ResultObject` to store the return value of a command. I did not try to set the value on the `InvocationContext.InvocationResult` because it seems that property is reserved for storing parsing results and I wasn't sure if that made sense to use, and it has the `IInvocationResult` interface which I couldn't just set to the return value.
It would be nice to use this API with WPF (and future WinUI) apps to parse out arguments.  I have created basic apps that do this, within the App.xaml.cs file, but would probably be better if there was support from here.  

Can we add an option to display the help text if NOTHING is filled out?

## Summary

I'm trying to do something that I'm not sure if there's already a recipe for. 

I'm trying to make an option that works like `dotnet run -p <path to project>`. Basically:

- Finds a project file in the current directory if option is unspecified
- Find a project file in the specified directory if the argument specified is a directory
- Uses the argument specified if the argument is a file
- Validation that we found a single project file and it exists

I'm using this option in multiple places, so it's pretty important to me that these errors are reported by the parameter binding system (not by code that I write **after** getting the option values bound).

## What I Tried

My code is here: https://github.com/rynowak/opulence/blob/master/src/dotnet-opulence/StandardOptions.cs#L50

What I tried is creating an argument bound to `FileInfo` - and then taking control of the conversion process. This doesn't meet all my requirements because it doesn't default to the current directory - conversion delegates don't run unless a value is passed in at the command line.

So I added a default value, however you don't have the chance to report validation errors when setting the default value. The validation error can occur when defaulting if there's 0, or more than one project file in the current directory.

So I added a validator. 

At this point it seems to cover all of my bases, but it's pretty complex and non-obvious. My default value has to no-op when it hits a validation error so that my validator can report it, etc.

## What I'd like

It be nice if there were a way to specify a `Func<(something), FileInfo>` for my option that can:

- Run regardless of whether a the option is specified
- Be responsible for converting the unparsed value to a `FileInfo`
- Add my own validation errors 

All of these capabilities already exist but they're part of three different extensibility points.

Hi

I created an application that targets `netcoreapp3.0` and references the `Azure.Storage.Blobs` package, together with:

```xml
<PackageReference Include="System.CommandLine.DragonFruit" Version="0.3.0-alpha.19577.1" />
<PackageReference Include="System.CommandLine.Experimental" Version="0.3.0-alpha.19577.1" />
```

The application runs as expected with **F5** from Visual Studio, but if I publish it in release mode (`dotnet publish -c Release`) and then try to run it I get the following exception:

```
Unhandled exception. System.Reflection.ReflectionTypeLoadException: Unable to load one or more of the requested types.
Could not load file or assembly 'Azure.Core, Version=1.0.1.0, Culture=neutral, PublicKeyToken=92742159e12e44c8'. The located assembly's manifest definition does not match the assembly reference. (0x80131040)
   at System.Reflection.RuntimeModule.GetTypes(RuntimeModule module)
   at System.Reflection.RuntimeAssembly.get_DefinedTypes()
   at System.CommandLine.DragonFruit.EntryPointDiscoverer.FindStaticEntryMethod(Assembly assembly, String entryPointFullTypeName)
   at System.CommandLine.DragonFruit.CommandLine.ExecuteAssemblyAsync(Assembly entryAssembly, String[] args, String entryPointFullTypeName, String xmlDocsFilePath, IConsole console)
   at AutoGeneratedProgram.Main(String[] args) in
```

I can see that the package `Azure.Core 1.0.1` is referenced by `Azure.Storage.Blobs`. The assembly in the publish directory has the following *FullName*: `Azure.Core, Version=1.0.0.0, Culture=neutral, PublicKeyToken=92742159e12e44c8`
Currently, having to repeat this pattern everywhere:

```cs
internal class changerequestNew
{
    internal static Command command = new Command(
                "new",
                "Create a new change request"
            );

    static changerequestNew() {
        command.AddOption(new Option(new[]{"--param", "--p"})
        {
            Argument = new Argument<string>(),
            Required = true,
        });
        // ...

        // ###########################################################
        // ALWAYS HAVING TO ADD THIS PATTERN
        command.AddOption(new Option(new[]{"--confirm", "--c"}) { Required = false });
        command.Handler = CommandHandler.Create(
            // Always adding confirmation parameter to handlers
            (string param, bool confirm) => handle(
                param:param, confirm:confirm
            )
        );
        // ###########################################################
    }

    internal static void handle(string param, bool confirm) {
        Console.WriteLine($"New change request for {param}");

        // ###########################################################
        // ALWAYS HAVING TO ADD THIS PATTERN
        if (!confirm && !Interactive.confirmation()) {
            Console.WriteLine("Skipping execution.");
            return;
        }
        // ###########################################################

        Console.WriteLine("Creating new change request");
    }
}

internal class Interactive
{
    internal static bool confirmation() {
        bool repeat = true;
        while (repeat) {
            Console.WriteLine($"Are you sure you want to continue? (yes/no)");
            string output = Console.ReadLine();
            if (output == null)
                return false;
            output = output.Trim().ToLower();
            if (output.Length <= 0)
                continue;
            // ###########################################################
            // Can be deceptively more complex than this
            else if (output == "yes" || output == "y")
                return true;
            else
                return false;
        }
        return false;
    }
}
```

Would be nice to have a default "yes/no" confirmation handler in [`src/System.CommandLine/Command.cs`](https://github.com/dotnet/command-line-api/blob/master/src/System.CommandLine/Command.cs) (if a given property `Confirmation = true`)