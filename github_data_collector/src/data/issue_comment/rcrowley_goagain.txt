Every exported function in a program should have a doc comment. The first sentence should be a summary that starts with the name being declared.
From [effective go](https://golang.org/doc/effective_go.html#commentary).


PR generated by [CodeLingo](https://codelingo.io). [Install here](https://github.com/apps/codelingo) to drive Continuous Higher Standards.

In Single strategyï¼ŒsetEnvs error in mac.

### error message
```
panic: reflect: call of reflect.Value.Int on zero Value

goroutine 1 [running]:
reflect.Value.Int(...)
	/usr/local/go/src/reflect/value.go:961
```

### solution
Replace with below code will solve this problems.
```
v := reflect.ValueOf(l).Elem().FieldByName("fd").Elem().FieldByName("pfd")
fd = uintptr(v.FieldByName("Sysfd").Int())
```
Drop resolving listener file descriptor by reflecting private struct fields. Instead we duplicate listener file descriptor, which handles closeOnExec syscalls.

The current implementation uses reflect package, and is prone to break (actually as of go 1.9 it WILL break, because the `netFD` struct fields have been moved around and sysfd field does not exist anymore, and is reachable instead by `pfd poll.FD` field).



Fixes a rogue close() that happens whenever the GC next runs after Listen(). NewFile() takes responsibility for the fd it is passed but Listen() then proceeds to manually syscall.Close() the fd anyway. So when the file object gets finalized it is closed a second time, either causing an EBADF or closing some other random file.

I agree with #2 and #3 that logging should not forced upon users of this library. But I also agree with @rcrowley that the logging is useful and needed. This PR doesn't change the default logging functionality but adds a `Logger` var on the package that can be set to override where log messages go.

This can be useful for applications that already have a logger setup and want the goagain logs to go to the same place. You just set 

``` go
myLogger := log.New(myWriter, "err: ", log.LstdFlags)
goagain.Logger = myLogger
```

Or if you wanted to disable logging altogether, you can set 

``` go
goagain.Logger = nil
```

by default in go, the quit signal is used to print stacktraces of running go programs (type ctrl+\ or use `kill -QUIT <pid>`). this is a very useful feature, but goagain overrides the quit signal.

I'm experiencing an odd issue after issuing a USR2 signal to my process. I've got an OnSIGHUP handler which opens some files and reloads data from them. On the first HUP after USR2 I get

```
read file.txt: bad file descriptor
```

if I HUP the process again it all works fine. I've been able to hack around this by setting a global variable after USR2 and if its the first HUP after a USR2 and doing

``` go
f, err := os.Open(os.DevNull)
if err == nil {
    defer f.Close()
}
```

and then running the code to reload the data from the files. Is this anything you've seen before, is there likely to be anything common I've not done correctly.

My use of goagain effectively matches the examples/simple/main.go example with the addition of the OnSIGHUP handler.

I'll try to replicate the issue with the simple example.

Would it be possible to wrap some of the complexity of the handoff / setup code? With a similar signature as `net.Listen`, it should either resume the previous connection or set up a new one. This could be performed by calling `goagain.Listener()` and depending on whether it succeeds, either kill off the parent  (or other appropriate cleanup) or return a new `net.Listener` by calling `net.Listen(net, laddr)`.

Basically handling all of [example/simple/simple.go#L20-44](https://github.com/rcrowley/goagain/blob/master/example/single/main.go#L20-44) (but just returning the listener). This would make the library a near drop-in replacement of the standard net.Listener.

It could be named `goagain.Listen` akin to `net.Listen`, `goagain.ListenAgain`, or maybe `goagain.ReListen`.

I have multiple listeners (like two listening on port :8080 and 8081 and one listening to https on 443 port). That means I have now three listeners. However the nature of goagain doesn't allow to use it with several listeners. I can split my app that it runs like three binaries but this would be not a good choice.

I've hacked a little on goagain to support for multiple listeners, a sneak code:

```
for addr, l := range listeners {
    a := reflect.ValueOf(l)
    v := a.Elem().FieldByName("fd").Elem()
    fd := uintptr(v.FieldByName("sysfd").Int())
    if err := os.Setenv("GOAGAIN_FD"+addr, fmt.Sprint(fd)); nil != err {
        return err
    }

    if err := os.Setenv("GOAGAIN_NAME"+addr, fmt.Sprintf("tcp:%s->", l.Addr().String())); nil != err {
        return err
    }

    fmt.Println("FD number is", fd)
    files[fd] = os.NewFile(fd, string(v.FieldByName("sysfile").String()))
}

```

However I don't like the way the file descriptors are created. Because I have to create the array earlier to  append the FD's to the `files` arary, like:

```
files := make([]*os.File, 30 )
```

Here, 30 is just an integer that's large enough. I've tried to use `append` on `files` array. However when I use append it's  breaking goagain with this err:

```
 fork/exec ./go/bin/test_goagain: bad file descriptor
```

It seems it is working quite well. Do you have any plans to support multiple listeners?
