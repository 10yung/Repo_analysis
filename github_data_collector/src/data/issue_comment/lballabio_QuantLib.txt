There was a typo in the HullWhite spread data table,
also removed duplicated gaussianCopula test and increased
the relative tolerance so that the test will pass as is.

Fixes #262.
Hi Luigi/Peter,
As discussed over email,  the calculation of OvernightIndexFuture::compoundedSpotValue() needs to include the compound factor between evaluation and reference date.

https://github.com/lballabio/QuantLib/blob/master/ql/experimental/futures/overnightindexfuture.cpp

Best, 

Luis Chion
see the discussion here https://sourceforge.net/p/quantlib/mailman/message/36887679/
No coverage via automated tests (yet?), but verified visually:

<details>
  <summary>Python code to produce following payoff diagrams. (Changes to QuantLib-SWIG to be submitted in a subsequent PR.)</summary>

```python
def make_test_option(payoff, spot_price):
    import QuantLib as ql
    
    calculation_date = ql.Date(15, 3, 2020)
    ql.Settings.instance().evaluationDate = calculation_date

    test_option = ql.VanillaOption(
        payoff,
        ql.AmericanExercise(
            calculation_date,
            ql.Date(15, 3, 2020)
        )
    )

    test_option.setPricingEngine(
        ql.BinomialVanillaEngine(
            process=ql.BlackScholesMertonProcess(
                s0=ql.QuoteHandle(ql.SimpleQuote(spot_price)),
                dividendTS=ql.YieldTermStructureHandle(
                    ql.FlatForward(
                        calculation_date,
                        0, # dividend rate
                        ql.Actual365Fixed(),
                    )
                ),
                riskFreeTS=ql.YieldTermStructureHandle(
                    ql.FlatForward(
                        calculation_date,
                        0.185, # risk-free rate
                        ql.Actual365Fixed(),
                    )
                ),
                volTS=ql.BlackVolTermStructureHandle(
                    ql.BlackConstantVol(
                        calculation_date,
                        ql.UnitedStates(),
                        0.35, # annualized historical volatility
                        ql.Actual365Fixed(),
                    )
                ),
            ),
            type="coxrossrubinstein",
            steps=250
        )
    )
    
    return test_option

from QuantLib import CappedPayoff, Date, Option, PlainVanillaPayoff
vanilla_option = make_test_option(PlainVanillaPayoff(Option.Put, 140), 150)

vanilla_payoffs = []
capped_payoffs = []

eval_price = 0
while eval_price < 300:
    vanilla_put = make_test_option(
        PlainVanillaPayoff(Option.Put, 140), eval_price,
    )
    vanilla_payoffs.append(vanilla_option.payoff()(eval_price))
    
    capped_put = make_test_option(
        CappedPayoff(Option.Put, 140, 50), eval_price,
    )
    capped_payoffs.append(capped_put.payoff()(eval_price))
    eval_price = eval_price + 1
    
from matplotlib import pyplot
pyplot.plot(vanilla_payoffs, label="Vanilla Put", linewidth=5)
pyplot.plot(capped_payoffs, label="Capped Put", linewidth=3)
pyplot.legend()
pyplot.show()
```
</details>

![image](https://user-images.githubusercontent.com/7883777/71565579-e6391280-2a7d-11ea-99da-2fec8463be4c.png)

Hello,

Looking at the new [Escrowed dividend model in FdBlackScholesVanillaEngine](https://github.com/lballabio/QuantLib/blob/8af44999b1ea4119c443138b5839848305ede383/ql/pricingengines/vanilla/fdblackscholesvanillaengine.cpp#L84), it appears that the discount factor used is the risk-free rate factor divided by the dividend yield factor.

That seems unusual. Even assuming there's an income rate on the stock, on top of the discrete dividends, if the dividends are known with certainty they should earn the risk-free rate.

Am I missing something? Thank you!
Today's (Oct 11, 2019) spot date is Oct 15, 2019 for USD 3mL swaps.  The holiday calendar used to bump dates on the swap fixed / float schedules is a joint UK/US calendar.  However, when I pass this joint calendar to the constructor, I get earliestDate= Oct 16, 2019 for the resulting ratehelper, which ties out with the joint calendar that I passed to it, but not with the effective date that should be generated by the index (Oct 15, 2019).  

AFAIK, building the dates consists of the following procedure (for backward generated schedule):
1) determine effective date (in this case equal to index spot date, but for forwards equal to today + forward period)
2) advance by tenor of swap to get unadjusted maturity date (UMD)
3) proceed backward from UMD by schedule frequency to get unadjusted intermediate dates
4) use proper holiday calendar to turn all unadjusted schedule dates to holiday adjusted dates
5) use holiday calendar and payment lag (USD = 2 days) to generate coupon payment dates

Note that this does not seem to be an issue for USD OIS deals, since there is only one calendar being used for everything.  

Also, wasn't sure to put this on the SWIG repo or on the main QL repo, so apologies if this is on the wrong one.

Thoughts?
- Mike
I created an option object with BSM process, BarrierOption model, and setted on AnalyticBarrierEngine. I want to get the simple greeksï¼Œlike Delta. Then I applied delta() to the option object, which returned 'delta not provided.'

I checked the raw code, which says BarrierOption has delta method. Meantime, the AnalyticBarrierEngine should has analytic solutions, which means the greeks can be calculated.

If the  analytic method doesn't work, is there any other easy ways to get the greeks, like difference methods? Thanks a lot !!
hello, 
i found in [here](https://github.com/lballabio/QuantLib/blob/master/ql/experimental/credit/spotlosslatentmodel.hpp#L316), inside `conditionalExpLossRRInv()` implementation, it's calling `conditionalRecoveryInvPinvRR`, but i can't find `conditionalRecoveryInvPinvRR` anywhere, it's not in `SpotRecoveryLatentModel` or it's parent `LatentModel`

is this an issue? i wonder how this could compile through
In the German 30/360 implementation
``` C++
Date::serial_type Thirty360::GER_Impl::dayCount(const Date& d1,
                                                    const Date& d2) const {
        Day dd1 = d1.dayOfMonth(), dd2 = d2.dayOfMonth();
        Month mm1 = d1.month(), mm2 = d2.month();
        Year yy1 = d1.year(), yy2 = d2.year();

        if (mm1 == 2 && dd1 == 28 + (Date::isLeap(yy1) ? 1 : 0))
            dd1 = 30;
        if (!isLastPeriod_ && mm2 == 2 &&
            dd2 == 28 + (Date::isLeap(yy2) ? 1 : 0))
            dd1 = 30; // <--------- Shouldn't this line be dd2 = 30?

        return 360*(yy2-yy1) + 30*(mm2-mm1-1) +
            std::max(Integer(0),30-dd1) + std::min(Integer(30),dd2);
    }
```
I'm wondering if the second dd1 = 30 should be dd2 = 30. 
Thank you.
Hi, more a question than an issue. Looking at some older issues I see there have been attempts to upgrade the code to C++11/14/17 but due to legacy compiler support this has been done in a limited and backwards compatible way. My question is, is there still a need for C++03 support and and if so is there a timeline for deprecation/removal? I'd be happy to help with a C++11 (or higher) overhaul of the library.


