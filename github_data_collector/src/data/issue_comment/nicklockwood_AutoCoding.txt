//deprecated
    SEL deprecatedSelector = NSSelectorFromString(@"codableKeys");
    if ([self respondsToSelector:deprecatedSelector] || [self instancesRespondToSelector:deprecatedSelector])
    {
        NSLog(@"AutoCoding Warning: codableKeys method is no longer supported. Use codableProperties instead.");
    }
    deprecatedSelector = NSSelectorFromString(@"uncodableKeys");
    if ([self respondsToSelector:deprecatedSelector] || [self instancesRespondToSelector:deprecatedSelector])
    {
        NSLog(@"AutoCoding Warning: uncodableKeys method is no longer supported. Use ivars, or synthesize your properties using non-KVC-compliant names to avoid coding them instead.");
    }
    deprecatedSelector = NSSelectorFromString(@"uncodableProperties");

codableKeys   uncodableKeys  uncodableProperties  Where do these methods come from? Why do like This？
Thank you
 


It would be nice to see how to use this, especially objectWithContentsOfFile 
I can't reproduce this on demand but quite frequently when unarchiving an object all its properties are nil (and they shouldn't be). Have you seen this?
…er method

The initWithCoder method is missing a call to [self init], so I modified the initWithCoder function to adhere to the standard initializer template.
Hi, any suggestions to fix crash and swift usage. 

1. Add on 'objectWithContentsOfFile' the 'nullable' flag to Swift optional compatibility.
2. Try|catch on 'unarchiveObjectWithData:'.

Bellow the implementation of suggestions.

```objective-c
+ (nullable instancetype)objectWithContentsOfFile:(NSString *)filePath
{
    //load the file
    NSData *data = [NSData dataWithContentsOfFile:filePath];
    
    //attempt to deserialise data as a plist
    id object = nil;
    if (data)
    {
        NSPropertyListFormat format;
        object = [NSPropertyListSerialization propertyListWithData:data options:NSPropertyListImmutable format:&format error:NULL];
       
		//success?
		if (object)
		{
			//check if object is an NSCoded unarchive
			if ([object respondsToSelector:@selector(objectForKeyedSubscript:)] && ((NSDictionary *)object)[@"$archiver"])
			{
                @try {

                    object = [NSKeyedUnarchiver unarchiveObjectWithData:data];
                }
                @catch (NSException* exception) {
                    NSLog(exception);
                    // delete corrupted archive
                    // initialize libraryDat from scratch
                }
			}
		}
		else
		{
			//return raw data
			object = data;
		}
    }
    
	//return object
	return object;
}

```
please push a version : support for watchos
Not quite sure what's going on here. Unfortunately I can't reproduce the crash, and crashlytics is giving me incorrect line numbers so I can't see exactly where in code this happens. I should note that Countsheet.m implements its own NSCoding / NSCopying - could that be the issue?

> Fatal Exception: NSGenericException
> **\* Collection <__NSArrayM: 0x134b95200> was mutated while being enumerated.
> 0  CoreFoundation                 0x18280edb0 __exceptionPreprocess
> 1  libobjc.A.dylib                0x181e73f80 objc_exception_throw
> 2  CoreFoundation                 0x18280e7e4 -[NSException name]
> 3  Foundation                     0x18315c04c -[NSKeyedArchiver _encodeArrayOfObjects:forKey:]
> 4  Foundation                     0x18315abb0 _encodeObject
> 5  RQMobile                       0x100168db0 -[NSObject(AutoCoding) encodeWithCoder:](AutoCoding.m:280)
> 6  RQMobile                       0x10008bbb4 -[RQMobileObject encodeWithCoder:](RQMobileObject.m:23)
> 7  RQMobile                       0x10007d010 -[Countsheet encodeWithCoder:](Countsheet.m:87)
> 8  Foundation                     0x18315abb0 _encodeObject
> 9  Foundation                     0x18315c064 -[NSKeyedArchiver _encodeArrayOfObjects:forKey:]
> 10 Foundation                     0x18315bc84 -[NSDictionary(NSDictionary) encodeWithCoder:]
> 11 Foundation                     0x18315abb0 _encodeObject
> 12 Foundation                     0x1831b7790 +[NSKeyedArchiver archiveRootObject:toFile:]


Hi, as I can see, you are carefully fill tags and labels for issues in your repo.

For such cases I create a [github_changelog_generator](https://github.com/skywinder/github-changelog-generator), that generate change log file based on **tags**, **issues** and merged **pull requests** from :octocat: Issue Tracker.

This PR add change log file to your repo (generated by this script).
You can check, how it is look like here: [Change Log](https://github.com/skywinder/AutoCoding/blob/add-change-log-file/CHANGELOG.md)

Some essential features, that has this script:
-  it **exclude** not-related to changelog issues (any issue, that has label `question` `duplicate` `invalid` `wontfix` )
- Distinguish issues **according labels**:
  - Merged pull requests (all `merged` pull-requests)
  - Bug fixes (by label `bug` in issue)
  - Enhancements (by label `enhancement` in issue)
  -   Issues (closed issues `w/o any labels`)
- Generate neat Change Log file according basic [change log guidelines](http://keepachangelog.com).

You can easily update this file in future by simply run script: `github_changelog_generator nicklockwood/AutoCoding` in your repo folder and it make your Change Log file up-to-date again!

Hope you find this commit as useful. :wink:

I have a class in swift, with several vars (strings, arrays, ints and bools). Strings and arrays are coded and decoded well. Ints and bools are not.
