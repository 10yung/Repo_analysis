This PR contains the following updates:

| Package | Type | Update | Change |
|---|---|---|---|
| [@graphql-toolkit/schema-merging](https://togithub.com/ardatan/graphql-toolkit) | dependencies | patch | [`0.9.0` -> `0.9.1`](https://renovatebot.com/diffs/npm/@graphql-toolkit%2fschema-merging/0.9.0/0.9.1) |

---

### Release Notes

<details>
<summary>ardatan/graphql-toolkit</summary>

### [`v0.9.1`](https://togithub.com/ardatan/graphql-toolkit/releases/v0.9.1)

[Compare Source](https://togithub.com/ardatan/graphql-toolkit/compare/v0.9.0...v0.9.1)

> Do you want The Guild to keep your codebase up to date and run your build on each GraphQL Toolkit commit so we will make sure not to break your app?
> Contact us here: [the-guild.dev/connected-build](http://bit.ly/connected-toolkit)
> Chat with us [on discord](http://bit.ly/guild-chat)

-   Check for HTTP URI specifically in URL Loader ([#&#8203;401](https://togithub.com/ardatan/graphql-toolkit/issues/401)) 
-   Make toolkit browser friendly (Use nodejs builtin modules dynamically)
-   Use fixed bob
-   GraphQL JS v15 compatibility
-   Keep comments while fetching schema using URL Loader
-   Fix babel typings

</details>

---

### Renovate configuration

:date: **Schedule**: At any time (no schedule defined).

:vertical_traffic_light: **Automerge**: Enabled.

:recycle: **Rebasing**: Whenever PR becomes conflicted, or if you modify the PR title to begin with "`rebase!`".

:no_bell: **Ignore**: Close this PR and you won't be reminded about this update again.

---

 - [ ] <!-- rebase-check -->If you want to rebase/retry this PR, check this box

---

This PR has been generated by [WhiteSource Renovate](https://renovate.whitesourcesoftware.com). View repository job log [here](https://app.renovatebot.com/dashboard#Urigo/graphql-modules).
This PR contains the following updates:

| Package | Type | Update | Change |
|---|---|---|---|
| [@graphql-toolkit/common](https://togithub.com/ardatan/graphql-toolkit) | dependencies | patch | [`0.9.0` -> `0.9.1`](https://renovatebot.com/diffs/npm/@graphql-toolkit%2fcommon/0.9.0/0.9.1) |

---

### Release Notes

<details>
<summary>ardatan/graphql-toolkit</summary>

### [`v0.9.1`](https://togithub.com/ardatan/graphql-toolkit/releases/v0.9.1)

[Compare Source](https://togithub.com/ardatan/graphql-toolkit/compare/v0.9.0...v0.9.1)

> Do you want The Guild to keep your codebase up to date and run your build on each GraphQL Toolkit commit so we will make sure not to break your app?
> Contact us here: [the-guild.dev/connected-build](http://bit.ly/connected-toolkit)
> Chat with us [on discord](http://bit.ly/guild-chat)

-   Check for HTTP URI specifically in URL Loader ([#&#8203;401](https://togithub.com/ardatan/graphql-toolkit/issues/401)) 
-   Make toolkit browser friendly (Use nodejs builtin modules dynamically)
-   Use fixed bob
-   GraphQL JS v15 compatibility
-   Keep comments while fetching schema using URL Loader
-   Fix babel typings

</details>

---

### Renovate configuration

:date: **Schedule**: At any time (no schedule defined).

:vertical_traffic_light: **Automerge**: Enabled.

:recycle: **Rebasing**: Whenever PR becomes conflicted, or if you modify the PR title to begin with "`rebase!`".

:no_bell: **Ignore**: Close this PR and you won't be reminded about this update again.

---

 - [ ] <!-- rebase-check -->If you want to rebase/retry this PR, check this box

---

This PR has been generated by [WhiteSource Renovate](https://renovate.whitesourcesoftware.com). View repository job log [here](https://app.renovatebot.com/dashboard#Urigo/graphql-modules).
As discussed at #850, add more logger method and change log method interface 
I'm experiencing the same symptoms previously reported with [Issue #443](https://github.com/Urigo/graphql-modules/issues/443) that was tagged as being fixed in version 0.7.6. I attempted version 0.7.6 and also explored with version 0.8.0-alpha.82bbc778 that was recommended [here](https://www.bountysource.com/issues/73377523-unable-to-mock-context-in-tests). Both of which were incompatible with our Production running code.

After trying out version 0.7.14 (latest stable per npm), I have reverted back to our Production version 0.7.9. In both cases, my attempt to inject a context mock into a GraphQL module fails to expose the object in my resolver functions.
 
**Expected behavior**: In resolver functions, ```context.currentUser``` should be set to the mocked object via ResearchModule.mock({...})

**Observed behavior**: ```context.currentUser``` is undefined in my resolver functions and the mocked object is nowhere to be found while running unit tests. Without a user, all my downstream authorization and filtering code fails due to the lack of a user context/profile that it relies on. This causes erroneous test results.

My code follows, and is functionally equivalent and very similar to what was outlined in  [Issue #443](https://github.com/Urigo/graphql-modules/issues/443). 

file: package.json
```
{
  "name": "apollo-graphql-gateway-server",
  "private": true,
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "build": "webpack --config webpack.production.js",
    "dev": "nodemon -r graphql-import-node/register",
    "start": "nodemon dist/server.js",
    "lint-graphql": "graphql-schema-linter src/**/*.gql",
  },
  "keywords": [],
```

file: researchModule.ts (this **Research Module imports the Auth Module to gain access to the context that contains the user profile associated with the access token that comes from the HTTP header**)
```
import { GraphQLModule } from '@graphql-modules/core'
import ResearchResolvers from './resolvers'
import { ResearchApi } from '../../providers/researchApi'
import { AuthModule } from '../auth'

export const ResearchModule = new GraphQLModule({
  imports: () => [AuthModule],
  typeDefs: () => require('./schema.gql'),
  resolvers: ResearchResolvers,
  providers: [ResearchApi],
})
```

file: authModule.ts (contains HTTP request header extraction and access token handling code to create a User Profile from the output of createContext function below)
```
import { GraphQLModule } from '@graphql-modules/core'
import { createContext } from './context'

// NOTE!: This GraphQLModule, by design, does not expose any operations or types.
//        It exists as a base module for creating the `currentUser` context so
//        other GraphQLModule instances can import it for authentication & authorization.
export const AuthModule = new GraphQLModule({
  name: 'auth',
  context: createContext,
})
```

file: context.ts
```
import { getUserProfile } from './identity'
import log from '../../logger'

interface PerCallContext {
  [key: string]: any
}

const createContext = async ({req,}: {req: any}): Promise<PerCallContext> => {
  const context: PerCallContext = {
    session: { req },
    currentUser: {},
  }

  if (req.headers.authorization) {
    const [, token] = (req.headers.authorization || '').split('BEARER ')
    const identityProviderProfile = await getUserProfile(token)
    context.currentUser.profile = identityProviderProfile
    context.currentUser.preferredInitials = context.currentUser.profile.sub.substring(
      0,
      context.currentUser.profile.sub.indexOf('@')
    )
    // TODO!!: build an appropriate dictionary of business units|investment group access array
  } else {
    context.currentUser.profile = null
  }

  const identityProfile = Object.freeze(context)
  log.debug({ identityProfile })
  return identityProfile
}

export { PerCallContext, createContext }
```
And alas, my test spec that attempts to inject the mocked context to allow my resolver functions to run with the fabricated hard-coded User Profile.
```
import 'reflect-metadata' // WARN!: required for DI @Injectable decorators to work
import { ResearchModule } from '../../src/domains/research'
import { graphql } from 'graphql'
import { ResearchApi } from '../../src/providers/researchApi'
import {
  ResearchPublication,
} from '../../src/types/types'
import { testResearchEntities } from './fixtures/data'

const { schema: ResearchSchema, injector: ResearchInjector } = ResearchModule

// Add the context mock since we don't have an interactive user that has signed on for the authentication context
ResearchModule.mock({
  contextBuilder: async (_ses: any, _exclude: any) => {
    contextBuilder: async () => {
      return await {x
        currentUser: {
          preferredInitials: 'MGD',
          // NOTE: by design for this set of tests, this user has CII unit level access
          businessUnits: {
            CII: 'RO',
            CRGI: 'NA',
            CWI: 'NA'
          }
        }
      }
    }
  }
})

describe('ResearchModule Queries apply  filtering when requests are made by unauthenticated, unknown or invalid users', () => {
  beforeAll(() => {
    // Setup Provider mock for entire ResearchApi so we can run an isolated test w/o needing to call the real APIs
    ResearchInjector.provide({
      provide: ResearchApi,
      overwrite: true,
      useValue: {
        async getResearchById(_id: any) {
          const research = testResearchEntities[0]
          research.id = _id // TODO: create a factory for this
          return research
        },
        async searchResearch(
          _query = '',
          page = 1,
          pageSize = 20,
          _sortBy: string
        ) {
          return {
            total: testResearchEntities.length,
            page,
            pageSize,
            hits: testResearchEntities.map(r => ({ score: 1.0, entity: r })),
          }
        },
      },
    })
  })

  it('[Research::getResearchById] should include Research Publication intended for CII audience', async () => {
    const query = `
      query {
        getResearchById(id: "inlineMockPub.1") {
          id
          researchType
          audience
        }
      }
    `

    const result = await graphql<{ getResearchById: ResearchPublication }>(
      ResearchSchema,
      query
    )

    console.log('From it by filtering out all Research Publications')
    console.log({result}) 
    expect(result.data!.getResearchById).toBeTruthy()
  })
})
```
file: researchResolver.ts (**these are the resolver functions that at runtime is able to get the access token and derive an actual user profile via **context.currentUser.** While running my tests through Jest; however, my reference **context.currentUser** or **this.currentUser** is undefined and I am unable to see where currentUser is stashed.)
Main callout here is that ***context.currentUser is defined when requests are made by a logged in user but in the course of running unit tests through Jest, context.currentUser is undefined and causes erroneous failed test results.
const disaggregatedResult = applyDisaggregation(publication!, context.currentUser)
```
import { ResearchApi } from '../../providers/researchApi'
import { Resolvers, QueryResolvers, ResearchPublication } from '../../types/types'
import moment from 'moment'
import log from '../../logger'
import { applyDisaggregation } from '../../filters/disaggregation'

const queryResolvers: QueryResolvers = {
  async searchResearch(_parent, args, context) {
    log.debug(
      `[ResearchResolver:searchResearch] invoked at: ${moment().format()}`
    )
    const researchApi = context.injector.get(ResearchApi)
    const searchResult = await researchApi.searchResearch(
      args.query,
      args.page || undefined,
      args.size || undefined,
      ''
    )

    log.debug(
      `[ResearchResolver:searchResearch] exiting at: ${moment().format()}`
    )

    // TODO!!: Ensure Disaggregation rules
    // const disaggregatedResults = applyDisaggregation(searchResult!, context.user)
    //return disaggregatedResults
    return searchResult
  },
  async getResearchById(_parent, args, context) : Promise<ResearchPublication | undefined>{
    log.debug(`[ResearchResolver:getResearchById(${args.id})]`)
    const publication = await context.injector
      .get(ResearchApi)
      .getResearchById(args.id)

    // TODO!!: Ensure Disaggregation rules
    const disaggregatedResult = applyDisaggregation(publication!, context.currentUser)
    return disaggregatedResult
  },
}

const resolvers: Resolvers = {
  Query: queryResolvers,
  Entity: {
    __resolveType(_parent, _context, _info) {
      return 'ResearchPublication'
    },
  },
}

export default resolvers
```
Hi, 
I am using graphQL modules, fastify and apollo-fastify, trying to do something like this:

```
const { AppModule } = require('./graphQL/app-module');

const apolloServer = new ApolloServer({
  modules: [AppModule],
  context: (session) => ({
    ... session,
    customProperty: 'test',
  }),
});
```
While customProperty is some arbitrary data that needs to be available inside the resolvers of all Modules and sub-modules that are imported in my appModule. 

I have absolutely no clue how to achieve this, since it seems that I can't access anything that isn't part of my session. It's not very clear to me on how to pass any global context - and even less what GraphQL modules expects me to do in order to make this work. It seems like the context given to the constructor of the Apollo-Server has zero effect and nothing to do with anything that happens within the modules and their context-builders.

Can somebody make this a bit more clear? All I want to do is making a static value (that exists when the Apollo-Server is created - e.g. a specific connection-string) available through all modules and their resolvers. Thanks in advance!
Instead of providing official logger plugin, graphql-modules give logger interface now.
I see that we could pass logger functions when initiating module. But I have no idea how to call logger in my resolvers or providers. 

https://github.com/Urigo/graphql-modules/blob/eecfc5208f00387b2d6595da98b1510bc137be2b/packages/core/src/graphql-module.ts#L28-L33

Could you give some hints about what's the best practice in your design? 
I have experience with Express, Apollo server and related technologies separately, but have never used graphql-modules or nest.js. Do these two combine? If they don't, how can one decide which one to use?
I have been trying to get a base app up and running using apollo server and graphql-modules.

I have gone through the [development environment setup steps](https://graphql-modules.com/docs/recipes/development-environment) using the ts-node method. This all works fine and I create a super simple Module from the examples:

```typescript
import { GraphQLModule } from '@graphql-modules/core';
import gql from 'graphql-tag';

export const AppModule = new GraphQLModule({
    typeDefs: gql`
        type Query {
            myData: Data
        }

        type Data {
            field: String
        }
    `
});
```

But when I try to follow the [graphql-codegen steps](https://graphql-modules.com/docs/recipes/graphql-code-generator) to generate the typings I get the error
`bad indentation of a sequence entry in "D:\projects\bootstrap\server\codegen.yml" at line 12, column 11:  - @graphql-modules/core#ModuleContext
`

The indentation seems fine and when I change that line to `contextType: '@graphql-modules/core#ModuleContext'` it passes that step but I then get an error saying that it cannot find my schema file.

`Failed to load schema from ./src/schema.ts: Unable to load from file "D:\projects\bootstrap\server\src\schema.ts": Cannot find module 'D:projectootstrapserversrcschema.ts'`

No idea where to go from here. But I have tried starting again a few times with a blank slate each time thinking that I have messed something up in the setup instructions but I keep coming across the same issue.
With resolvers composition, we can easily do query level permission, but how do you add field level permission

For example:

```
resolversComposition: {
    'User.password': [isAuthenticated(), hasRole('EDITOR')]
 }
```

Doesn't seem to work 🤔 
![image](https://user-images.githubusercontent.com/5434970/68558832-c041ab00-0408-11ea-81b1-9e7dfe24c89d.png)

I am following along with this example and TypeDefs keeps giving error 

![image](https://user-images.githubusercontent.com/5434970/68558900-0565dd00-0409-11ea-97cd-f932c28dd46b.png)

Is there a working example some where that shows how to load multiple files for Types and Revolvers for a module?

Thanks,

Brian Davis

