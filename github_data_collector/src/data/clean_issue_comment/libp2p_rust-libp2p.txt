With deriveNetworkBehaviour only no errors rust deriveNetworkBehaviour pub struct BehaviourTSubstream pub floodsub FloodsubTSubstream pub kad KademliaTSubstream MemoryStore pub rpc RPCTSubstream When behaviouroutevent Event pollmethod poll is added then the error occurs rust deriveNetworkBehaviour behaviouroutevent Event pollmethod poll pub struct BehaviourTSubstream pub floodsub FloodsubTSubstream pub kad KademliaTSubstream MemoryStore pub rpc RPCTSubstream error E this function takes parameters but parameter was supplied lp psrcbehaviourrs deriveNetworkBehaviour expected parameters Not sure whats going on I also tried the example exmapleschatrs there is also a similar error diff fn main Result Boxdyn Error envloggerinit fn main Result Boxdyn Error Use the derive to generate delegating NetworkBehaviour impl and require the NetworkBehaviourEventProcess implementations below deriveNetworkBehaviour behaviourpollmethod poll struct MyBehaviourTSubstream AsyncRead AsyncWrite floodsub FloodsubTSubstream mdns MdnsTSubstream fn main Result Boxdyn Error ignoredmember bool xlcxlcpclibp prustlibp p cargo build example chat Compiling libp p v alpha homexlcdatasrcgithubcomlibp prustlibp p error E this function takes parameters but parameters were supplied exampleschatrs deriveNetworkBehaviour expected parameters error aborting due to previous error For more information about this error try rustc explain E error could not compile libp p Any clue Hello Id like to suggest the removal of ring as a dependency alltogether That also includes rustls and webpki rustls is used by the websocket transport Why Because I dont see a point in using that one vs others when it mostly is a wrapper to Assembly code Screenshot Capture The maintainer is problematic and doesnt work in the spirit of Free Software There is no portable fallback for crypto primitives which means it wont compile on less common platforms at the mercy of the problematic maintainer The build system of ring is really a mess I suggest using the openssl crate instead That supports both OpenSSL and LibreSSL and any other library that offers an opensslcompatible interface Or individual crates that implement the primitives needed by libp p such as but I dont think theyre that mature yet I started porting libp p crates to openssl but it seems that ring types are exposed in public interfaces so that would be a breaking change Also usage of ring really doesnt seem contained so its not so trivial to do so either through whatever the application provides as a topic identifier leaving hashing or not hashing up to the application This is just rebased and adapted to latest master It seems that polling from TCP sockets too often might cause issues We could tweak transportupgradeBuilder to optionally do some intermediary buffering Every single time something happens on a connection we memreplace the state with Undefined then put the state back afterwards This is a lot of copies and of Substrates CPU use is here In the past its been tedious to fix because of nonlexical lifetime issues in Rust But Rust has gotten some improvements since then Makes it possible to configure the executor for the background tasks that libp p spawns Related to as it makes it possible to use the tokio executor The publicfacing API is that SwarmBuilder gains an executor method After there are still a lot of things to do Maybe part of but pass Pin mut Self to NetworkBehaviourpollProtocolsHandlerpollNodeHandlerpoll Change all the methods of StreamMuxer to require Pin mut Self In practice the muxer itself is already pinned as it is within an Arc Maybe remove all the Unpin trait requirements that remain everywhere There is one major problematic area when we pass a substream from multistreamselect to the actual handler we move it Im not really sure what to do here Signedoffby koushiro koushirocqxgmailcom Add Blake b and Blake s hash types for multihash Implements private networks This is meant to be interoperable with goipfs private swarms For reference the specification from PL is at the implementation in goipfs is at Tested by checking that two rustipfs nodes pnet example can chat with each other and in addition checking that the pubsub traffic is visible in goipfs For UDPbased transports there is no way to ensure that outstanding data is delivered in the event a transport is dropped