comsuntoolsjdiStringReferenceImpl cannot be cast to comsunjdiArrayReference javalangClassCastException comsuntoolsjdiStringReferenceImpl cannot be cast to comsunjdiArrayReference at orgjfsmalideadebuggingvalueLazyArrayReferencelengthLazyArrayReferencejava at comintellijdebuggeruitreerenderClassRendereraClassRendererjava at comintellijdebuggeruitreerenderClassRendererisExpandableClassRendererjava at comintellijdebuggeruiimplwatchValueDescriptorImplcalcRepresentationValueDescriptorImpljava at comintellijdebuggeruiimplwatchNodeDescriptorImplupdateRepresentationNoNotifyNodeDescriptorImpljava at comintellijdebuggeruiimplwatchNodeDescriptorImplupdateRepresentationNodeDescriptorImpljava at comintellijdebuggerengineJavaValue contextActionJavaValuejava at comintellijdebuggerengineeventsSuspendContextCommandImplactionSuspendContextCommandImpljava at comintellijdebuggerengineeventsDebuggerCommandImplrunDebuggerCommandImpljava at comintellijdebuggerengineDebuggerManagerThreadImplprocessEventDebuggerManagerThreadImpljava at comintellijdebuggerengineDebuggerManagerThreadImplprocessEventDebuggerManagerThreadImpljava at comintellijdebuggerimplInvokeThreadaInvokeThreadjava at comintellijdebuggerimplInvokeThreadaccess InvokeThreadjava at comintellijdebuggerimplInvokeThreadWorkerThreadRequestrunInvokeThreadjava at comintellijopenapiapplicationimplApplicationImpl runApplicationImpljava at javautilconcurrentExecutorsRunnableAdaptercallExecutorsjava at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava To let DexBackedDexFile be able to read in DEX file using MappedByteBuffer there is no reason why this rewriter should be hardcoded in DexRewriter impact if you want to filter or add classes in a RewriterModule you cannot i know you have chosen to hardcode collection rewriters but i can still get to them by rewriting the collection owner object except in the case of DexFile DexFile is a type that owns a collection and still cannot be rewritten this breaks symmetry and makes a RewriterModule not capable of some rewrites the dexlib client then needs to resort to custom code easy fix but breaks backwards compatibility of Rewriters interface if you are tempted to do the change and break compat i say go for it hi JesusFreke im trying to hook existing calls to instance constructors and replace them with calls to static methods that return a newly constructed instance of the right type of object the problem is when newinstance is executed the arguments to the constructor call are not known so i cant call the hook method there and when the call to init is executed the constructor arguments are known and i can call the hook but the pointer to the supposed new object has already been accessible to the rest of the code since newinstance executed can code use it in any way before init it seems i have options replace newinstance v xxx with const v so that if v is used by interleaving code it will trigger a verification error and then replace the call to init with the call to the hook which will return the real value for v or just give up and simply provide an after constructor hook which will get an already constructed object and hopefully can modify it but it cant modify the constructor call itself so my question is would option work what can happen to the pointer returned by newinstance before the constructor is called can anything actually happen to it it seems that even allowing a store of the pointer is unsafe what happens if an exception is thrown after the store but before init succeeds an uninitialized object would be reachable in the heap which is unacceptable what is your opinion on option thank you very much though not a bug i think this line would be more correct like this return RewriterUtilsrewriteListrewritersgetEncodedValueRewriter arrayEncodedValuegetValue the expectation is that rewriters delegate to the module not to themselves just because they happen to match the needed type of rewriter JesusFreke re why backticks are backticks not allowed in dex bytecode names they are certainly valid in jvm type names if backticks are allowed in dex bytecode then this commit is breaking compatibility with old smali files if true this would it be very bad and IMHO should be fixed ASAP before the new format gains any traction the characters that cannot be part of JVM names ever are and see JVM spec class file format names to retain compatibility with old smali they could be put to use and better for escaping than quoting maybe like this comexampleMy Crap or u or u or space or s or even but that complicates some parser implementations and i recommend against it btw backticks are a bit impractical because they are a deadkeys on most international keyboard layouts a thing english users tend to overlook JesusFreke It looks like this sample code does not map arrays of MyBlah is this true or does dexlib dig down array types to get to the base type before invoking the type rewriter thanks It seem that there is no way to inspect v v or p p inside intelij unless the method parameters were explained with param or the locals were explained with local When I key in p into the watch window intelij evaluate to Internal error which is correct because p is not a variable name its the virtual variable understood by smali compiler only Any way to inspect these It seems that even jdb wont show these local variables without local added to the source code this line should really be switch instructiongetReferenceType in case someone overrides getReferenceType javalangNullPointerException at orgjfsmalideadebuggingvalueLazyObjectReferencedisableCollectionLazyObjectReferencejava at comintellijdebuggerimplDebuggerUtilsExdisableCollectionDebuggerUtilsExjava at comintellijdebuggerengineSuspendContextImplkeepSuspendContextImpljava at comintellijdebuggerimplDebuggerUtilsExkeepDebuggerUtilsExjava at comintellijdebuggeruiimplwatchEvaluationDescriptorcalcValueEvaluationDescriptorjava at comintellijdebuggeruiimplwatchValueDescriptorImplsetContextValueDescriptorImpljava at comintellijdebuggerengineJavaDebuggerEvaluator threadActionJavaDebuggerEvaluatorjava at comintellijdebuggerengineeventsDebuggerContextCommandImplcontextActionDebuggerContextCommandImpljava at comintellijdebuggerengineeventsSuspendContextCommandImplactionSuspendContextCommandImpljava at comintellijdebuggerengineeventsDebuggerCommandImplrunDebuggerCommandImpljava at comintellijdebuggerengineDebuggerManagerThreadImplprocessEventDebuggerManagerThreadImpljava at comintellijdebuggerengineDebuggerManagerThreadImplprocessEventDebuggerManagerThreadImpljava at comintellijdebuggerimplInvokeThreadrunInvokeThreadjava at comintellijdebuggerimplInvokeThreadaccess InvokeThreadjava at comintellijdebuggerimplInvokeThreadWorkerThreadRequestrunInvokeThreadjava at comintellijopenapiapplicationimplApplicationImpl runApplicationImpljava at javautilconcurrentExecutorsRunnableAdaptercallExecutorsjava at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava 