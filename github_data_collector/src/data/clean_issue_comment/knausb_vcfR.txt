A different variation on the segfault errors suggested here and here maybe I have an annotated vcf file that I am attempting to convert to a tidy format using vcfR Tidy so that I can filter easily on a number of different fields from that standard format vcf region and from that annotated version When I attempt to convert it I get vcf readvcfR minimalvcf verbose FALSE vcfT vcfR tidyvcf formatfields cGT DP caught segfault address x cause memory not mapped Which then sometimes but not always dumps me completely out of R Ive updated my installation of vcfR from the github master branch using devtoolsinstallgithubrepoknausbvcfR Ill paste my sessionInfo in at the bottom The vcf has been prefiltered using the VariantAnnotation package on one of the annotation fields to reduce it to variants When I try to use it unfiltered with or without annotations it hangs probably because at that stage of the proceedings theres variants In attempting to figure out if it was a size issue I made a minimal example with variants in it It worked so Im guessing its not a formatting thing which made me suspect a memory problem However Im doing this on the doing this on the landing node of a cluster so free h total used free shared buffcache available Mem G G G G G G Swap G B G As I increase the size of the minimal example it falls over on anything over variants On a different machine my laptop it falls over with anything over variants though and that has much less memory free h total used free shared buffcache available Mem G G G G G G Swap G G G So I have no idea what it might be Doesnt appear to be formatting works with minimal example doesnt appear to be memory works better on a smaller machine and doesnt appear to be specific to a particular location within the file can do or on different machines I even checked the page on memory usage and I should easily have sufficient for ish variants Any suggestions would be much appreciated getting vcfs into a tidy format is a bit of a holy grail at the moment Ben sessionInfo R version Platform x pclinuxgnu bit Running under CentOS Linux Core Matrix products default BLASLAPACK scalewlgpersistentfilesetsoptnesiCS centos bdwimkl gimpi bcompilersandlibraries linuxmkllibintel linlibmklgflp so locale LCCTYPEenNZUTF LCNUMERICC LCTIMEenNZUTF LCCOLLATEenNZUTF LCMONETARYenNZUTF LCMESSAGESenNZUTF LCPAPERenNZUTF LCNAMEC LCADDRESSC LCTELEPHONEC LCMEASUREMENTenNZUTF LCIDENTIFICATIONC attached base packages stats parallel stats graphics grDevices utils datasets methods base other attached packages vcfR VariantAnnotation Rsamtools Biostrings XVector SummarizedExperiment DelayedArray BiocParallel matrixStats Biobase GenomicRanges GenomeInfoDb IRanges S Vectors BiocGenerics forcats stringr dplyr purrr readr tidyr tibble ggplot tidyverse Hello Brian Im using SLiM to generate vcf files which I am analysing in R however occasionally readvcfR was causing my R session to encounter a fatal error and abort I followed your advice to determine the problem and it seems it is crashing because the vcf file has two completely blank lines in it I appreciate this may be more of an issue with SLiM but I was hoping it might be possible for vcfR to accommodate this or if you have any other suggestions I have attached two files blankrow vcf contains blank lines before POS and causes R to abort when readvcfR is run and cleanvcf is of a similar size and style but works fine The files are being automatically generated so unfortunately I cant manually edit them Im using the most recent GitHub version of vcfR Blanklineexzip Many thanks Tom I am processing VCF file to split the columns until the INFO field columns into tab separated columns The example input has K variants To do this i am using the below code STEP Reading the VCF file took upto approx min sec systemtimepopvcfinput vcfRreadvcfRpopvcfgz user system elapsed STEP Extracting all the keyvalue pairs in INFO field myINFOs grepINFO queryMETApopvcf value TRUE myINFOs subINFOID myINFOs STEP a Using lapply function to extract the values for all the keys in INFO column This took min sec for the below function systemtimemyINFOm matrixunlistlapplymyINFOs functionx extractinfopopvcf element x ncol lengthmyINFOs byrow FALSE user system elapsed STEP b The same was implemented with mclapply function and this took min sec systemtimemyINFOm matrixunlistmclapplymyINFOs functionx extractinfopopvcf element x ncol lengthmyINFOs byrow FALSE user system elapsed STEP The INFO fields are combined with columns to get the final output colnamesmyINFOm ascharactermyINFOs popcountout cbindgetFIXpopvcf myINFOm The input dataset with K variants is taking min for executing the code in STEP STEP a or STEP STEP b And the run time is increasing with increase in variants in the input VCF file Is it possible to reduce the runtime with some parallel processing methods in R so that it performs better with the size of the input VCF I am not familiar with parallel processing methods in the above code i have used lapply and mclapply for STEP which do not have a significant improvement Any suggestions to improve performance while reading the file in STEP and STEP a b Since this has been a performance issue and not a bug in the package to show a reproducible example i am not able to share any input file Hello I have annotated my VCF files with VEP I love the vcfR tidy function which parses out the vcf file into different data frames for visualization and downstream analysis However I noticed that the CSQ column where all the VEP functional annotation is added separated by does not parse out into the individual columns even though the meta data frame shows the details of all the annotations present in this column Please advice Convert to tidy dataframe test vcfR tidyvcfv infoonly TRUE namestest test extractinfotidyvcfv infofields NULL infotypes TRUE The CSQ column still looks like this downstreamgenevariantMODIFIERPERM ENSG TranscriptENST proteincodingrs deletionHGNCHGNC A ENSP Q SV UPI DAF e e e e e e e gnomADAFRintronvariantMODIFIERPLEKHN ENSG TranscriptENST proteincoding rs deletionHGNCHGNC A CCDS ENSP Q U UPI FF e e e e e e e gnomADAFRintronvariantMODIFIERPLEKHN ENSG TranscriptENST proteincoding rs deletionHGNCHGNC A ENSP Q U UPI D E e e e e e e e gnomADAFRintronvariantMODIFIERPLEKHN ENSG TranscriptENST proteincoding rs deletionHGNCHGNC YES P CCDS ENSP Q U UPI D e e e e e e e gnomADAFRdownstreamgenevariantMODIFIERPERM ENSG TranscriptENST proteincodingrs deletionHGNCHGNC YES P CCDS ENSP Q SV UPI E FA e e e e e e e gnomADAFRdownstreamgenevariantMODIFIERPERM ENSG TranscriptENST retainedintronrs deletionHGNCHGNC e e e e e e e gnomADAFRdownstreamgenevariantMODIFIERPLEKHN ENSG TranscriptENST retainedintronrs deletionHGNCHGNC e e e e e e e gnomADAFRupstreamgenevariantMODIFIERPLEKHN ENSG TranscriptENST proteincodingrs cdsstartNFdeletionHGNCHGNC ENSP J KSM UPI AE F e e e e e e e gnomADAFR Hi Brian When using vcfR genlight with a very small dataset the function may set different ploidy for each sample This behavior comes from the automatic determination of the ploidy when creating an object of genlight class see ploidy section from the genlightclass documentation Below a reproducible example and a solution The reproducible example R libraryadegenet datavcfRtest Conversion gl vcfR genlightvcfRtest Ploidy of each sample all should be ploidygl NA NA NA The genotype data with only biallelic sites vcfRtest grepl vcfRtestfix gt FORMAT NA NA NA GTGQDPHQ GTGQDPHQ GTGQDPHQ When vcfR genlight translates the genotypes in binary code the maximum allele code will be or and for the first second and third sample respectively So genlight will determine that the two first samples are haploid and the second is diploid The solution The ploidy can be indicated when creating a genlight object So the solution is to add this argument in the vcfRconversionR file R Line should be x newgenlight tx ncoresncores ploidy But I think it would be better to have the ploidy as an argument of the vcfR genlight This would allow someone who has diploidized the data to specify the ploidy of the organism this can sometimes be the case when you work on malaria someone who has samples with different ploidy like in yeast If the ploidy is an argument a warning message about mixed ploidy in the resulting genlight object could be a plus Comment A more elegant way could be to determine the ploidy from the data I wonder if it would be worth writing a general function to estimate the ploidy from the VCF because this has been raised several times Fred Hi Brian I found another unexpected behavior when using vcfR DNAbin which is not related to When data have indels with missing data and these indels are kept a DNAbin object of list type is created due to the generation of sequences of different lengths but labels are missing Below a reproducible example and a solution The reproducible example R libraryape datavcfRtest Create an example reference sequence nucs cacgt setseed myRef asDNAbinmatrixnucs roundrunifn min max nrow Recode the POS data for a smaller example setseed vcfRtestfix POS sortsample sizelengthgetPOSvcfRtest Conversion to DNAbin object vcfR DNAbinvcfRtest extractindelsFALSE unphasedasNAFALSE This data has no missing data so sequences of same length can be created and DNAbin of matrix type is generated Introduction of missing data vcfRtestgt Conversion to DNAbin object vcfR DNAbinvcfRtest extractindelsFALSE unphasedasNAFALSE DNAbin of list type is generated Labels are missing The solution The problem comes from the transposition when generating the DNAbin object at the end of vcfR DNAbin But this transposition is only needed when a matrix is converted Here is the modification proposed R Replace line with this block if ismatrixx x tx x apeasDNAbinx Fred This is similar to issue We would like an interface where one can specify chromosome region and obtains only the parts of the VCF that correspond to this query This would most likely mean supporting tabix indexed vcf files Reading the whole VCF is simply not going to happen The current skip and nrows parameters are not useful to us To know those values we would first have to index the vcf somehow exactly the job for Tabix Excellent package I have prototyped a few solutions to use this to apply ML classification of called variants and do filtering This is more of a feature request Just wanted to add that VCFs should block gzippedbgzf and not standard gzip The former is necessary to index the VCF using bcftools and is widely considered a standard Thanks for all your efforts in making vcfR available Hi Brian I found an unexpected behavior of vcfR DNAbin I would not qualify this as a bug per se because it is coming from a particular behavior of a DNAbin object created by one function from the ape package but I dont know if this is a bug in this function as I dont know the specifications of the DNAbin class Anyway I found a solution for vcfR to handle all cases The unexpected behavior I wanted to include my variants in a reference sequence using vcfR DNAbin This reference sequence was extracted from a reference genome imported using readdna from the ape package The result produced by vcfR DNAbin contained a sequence of the right length but with NA for all the invariant bases instead of the expected reference bases When using the example of the vcfR manual everything worked perfectly fine The explanation The behavior occurs only when the sequence is stored as a list in the DNAbin object The list is used when sequences of different lengths are loaded in the same DNAbin object which is the case of my reference genome A sequence extracted from the reference genome will inherit the list type But the behavior also depends on what function is used for creating the list if asDNAbin is used everything works fine with vcfR DNAbin but if readdna is used the behavior occurs Here is a reproducible example inspired from vcfR manual R libraryape datavcfRtest setseed vcfRtestfix POS sortsample sizelengthgetPOSvcfRtest Reference sequence nucs cacgt mySeq nucs roundrunifn min max myRefmat matrixmySeq nrow rownamesmyRefmat test myRefls listmySeq namesmyRefls test Fasta file for readdna cattest pastemySeq collapse file exdnafas sep n Loading reference sequence as matrix myRefdb asDNAbinmyRefmat myRefrd readdnaexdnafas formatfasta Do both methods produce the same object identicalmyRefdb myRefrd TRUE Loading reference sequence as list myRefdb asDNAbinmyRefls myRefrd readdnaexdnafas formatfasta asmatrixFALSE Do both methods produce the same object identicalmyRefdb myRefrd FALSE Results from vcfR DNA myDNAdb vcfR DNAbinvcfRtest refseqmyRefdb myDNArd vcfR DNAbinvcfRtest refseqmyRefrd ascharactermyDNAdb ascharactermyDNArd The problem comes from the way the data is accessible from each object This has a big impact on vcfR DNAbin The data loaded with asDNAbin is never directly accessible myRefdb contrary to the data loaded with readdna myRefrd So when ascharacter is used line of vcfR DNAbin the binary code is translated in nucleotides in the first case but it is kept as is in the second case When vcfR DNAbin recreates a DNAbin object in the first case it translates back the nucleotides into binary code but in the second case as the binary code is already present it translates the binary numbers into NA because they do not correspond to any nucleotides Here is an illustration R ascharactermyRefdb ascharactermyRefrd The remedy As I wrote it might be a bug from readdna but I found a work around to accommodate any cases when a DNAbin object is of list type The first step is is to convert the first item of the list to a sequence without trying to access the item itself so the sequence will still be of list type unlist the sequence and store the vector for later use This implies also to modify the if statement of the ismatrixrefseq to obtain the sequence and to modify the way the matrix of reference sequences is created Here are the modifications proposed R Replace lines with this block if islistrefseq refseq unlistascharacterrefseq usenamesFALSE Replace lines with this block if ismatrixrefseq refseq refseq refseq refseq ncolrefseq refseq ascharacterrefseq Replace line with this line x matrixrefseq nrow lengthrefseq Fred Hello I have an issue related to missing data with the function extracthaps I have diploid data that was processed by different tools before being loaded in R One of the tools seems to recode the filtered out data with a single and not This has some consequences when this coded missing data is the first value of the dataset the ploidy is not recognized and the function returns an unexpected result Here is a reproducible example R datavcfRtest extracthapsvcfRtest unphasedasNAF Variant processed NA NA NA NA NA NA rs G G A G A A T T T A T T rs G T T G T T T T T T T T microsat GTC G GTC GTCT G G Replacing first cell of sample data with missing data coded by a single dot vcfRtestgt extracthapsvcfRtest unphasedasNAF NA NA NA rs NA NA rs microsat Here is the code that leads to this behavior A solution would be to not search for the first non NA value but to actually search for the genotype separator or or if haploid data Here is the piece of code that fixes it R firstgt unliststrsplitxgt grep xgt This is different from which if I am right is the C function that will actually extract the haplotypes Anyway thank you for fixing this Fred