 Proposed Changes As pointed out in the tornado consumer example in the documentation has some bugs and cannot be used as it is right now I introduced named arguments for most of the broken method calls Types of Changes Bugfix nonbreaking change which fixes issue NNNN New feature nonbreaking change which adds functionality Breaking change fix or feature that would cause existing functionality to not work as expected x Documentation correction or otherwise Cosmetics whitespace appearance Checklist x I have read the CONTRIBUTINGmd document All tests pass locally with my changes I have added tests that prove my fix is effective or that my feature works I have added necessary documentation if appropriate Running this example throwed TypeError exchange must be a str or unicode str And this is caused by the sequence of positional arguments python def setupexchangeself exchangename Setup the exchange on RabbitMQ by invoking the ExchangeDeclare RPC command When it is complete the onexchangedeclareok method will be invoked by pika param strunicode exchangename The name of the exchange to declare LOGGERinfoDeclaring exchange s exchangename selfchannelexchangedeclareselfonexchangedeclareok exchangename selfEXCHANGETYPE And this is the source of method Channelexchangedeclare in channelpy python def exchangedeclareself exchange exchangetypedirect passiveFalse durableFalse autodeleteFalse internalFalse argumentsNone callbackNone Passing keyword arguments could simply fix this error python selfchannelexchangedeclarecallbackselfonexchangedeclareok exchangeexchangename exchangetypeselfEXCHANGETYPE It would be useful to have a dedicated enum which spells out all the fixed values available for python consumption much like you find in the net RabbitMQ client This source will likely be something like from enum import Enum class ExchangeTypeEnum direct Exchange type used for AMQP direct exchanges fanout Exchange type used for AMQP fanout exchanges headers Exchange type used for AMQP headers exchanges topic Exchange type used for AMQP topic exchanges This will give folks the option to use enum references in their client code like channel selfconnectionchannel channelexchangedeclareexchangefoo exchangetypeExchangeTypedirectname pika version As a result of interface link flapping a socket underneath pikas connection to RabbitMQ became dead Since this state transition has not been properly processed by client code any subsequent publish to pikas Channel then caused this File optvenvlibpython sitepackagespikaadaptersblockingconnectionpy line in basicpublish mandatorymandatory File optvenvlibpython sitepackagespikachannelpy line in basicpublish selfraiseifnotopen File optvenvlibpython sitepackagespikachannelpy line in raiseifnotopen raise exceptionsChannelWrongStateErrorChannel is closed pikaexceptionsChannelWrongStateError Channel is closed As a result a code like python try selfchannelbasicpublisha k except exceptionsConnectionClosed exceptionsChannelClosed as error logdebugTry to reconnect in seconds timesleep selfreconnect would fail This behaviour was implemented at But I disagree in total with the approach since it brakes the whole typed exception support of python itself Typed exceptions are supported for the user of code can just quickly match the error yielded by runtime despite whats the actual reason The commit mentioned brakes this and offers code users to revert to strings patterns matching Instead of raising the same exception in cases channel is in opening state but is not ready to operate channel is already closed one should provide a special type of an exception for each of the cases if the error recovery is supposed to differ IMO For these two cases error recovery approaches obviously to me differ in total For the channel in opening state its wait a little then try again but dont reconnect since theres no reason for it for the channel is in closed state it could be recover via reconnect Right now the code user differs what approach to use only with the Exceptionargs parsing There is no value in first cancelling all consumers then immediately closing the channel as the consumers will be correctly cleaned up when the channel is closed by RabbitMQ Consider removing the code around this line In RabbitMQ we will ship a feature that may require that basiccancel is not sent before closing the channel for certain guarantees to hold I am opening this issue after a conversation with lukebakken here the thread RabbitMQ test with different libraries I made a few tests with different client libraries Environment Laptop cores gb ram Two rabbitmq nodes in cluster same machine RabbitMQ version Erlang async threads for each server Ubuntu Two Python processes running venv pyamqp gitmaster pip freeze amqp atomicwrites attrs librabbitmq moreitertools pika pluggy py PyAMQP pytest six vine venv pyamqp gitmaster Here is the code python import time import uuid import sys class PyAmqpTest def publishself rm c amqpConnectionhostrm channel cchannel qname struuiduuid message amqpMessage channelchannel bodythe quick brown fox jumps over the lazy dog propertiesdictcontenttypeapplicationjson contentencodingutf channelqueuedeclarequeueqname autodeleteFalse printstart s timectimetimetime for i in range channelbasicpublishmessage routingkeyqname printend s timectimetimetime def threadpublishself rm for i in range threadstartnewthreadselfpublish rm printstarting s sysargv x PyAmqpTest xthreadpublishsysargv inputPress Enter to continue pyamqp import amqp as amqp and then python pyamqppublishpy localhost python pyamqppublishpy localhost around messages per second librabbitmq import librabbitmq as amqp and then python pyamqppublishpy localhost python pyamqppublishpy localhost around messages per second Pika python import thread import pika import time import uuid import sys class PyPikaTest def publishself rm c pikaBlockingConnectionpikaConnectionParametersportrm channel cchannel qname struuiduuid channelqueuedeclarequeueqname autodeleteFalse properties pikaBasicProperties contenttypeapplicationjson contentencodingutf printstart s timectimetimetime for i in range channelbasicpublish exchange routingkeyqname propertiesproperties bodythe quick brown fox jumps over the lazy dog printend s timectimetimetime def threadpublishself rm for i in range threadstartnewthreadselfpublish rm printstarting s sysargv x PyPikaTest xthreadpublishsysargv inputPress Enter to continue So python pypikapublishpy python pypikapublishpy about messages per second Thank you hi were using pika we get the Tried to handle an error where no error existed error log while consuming messages the reason i open this issue is that we studied it a little bit first of all looking at code we see that this line gets called with errorNone and then it leads to this line the event we get is bit is on so its an error but the error log is written because error is None the culprit is this line that calles the handleerror function with no error param making it the default None the weird part is the way we encountered it were using the blockingconnectionconsume generator for some older reason we passed inactivitytimeout which worked fine when we changed it to inactivitytimeout the error log started to appear and when we changed it back it disappeared again i thought you might want to look at it although i noticed that at the master branch the lines i mentioned above are not existent is there a release coming soon with the new code thanks See this commit for more details I recently revisited how Langohr Bunny March Hare and RabbitMQ ObjectiveC clients provision RabbitMQ on CI Id be happy to submit a PR that does the same thing for Pika if theres interest I am not sure why the travisyml is so extensive very likely there are reasons for that The gist of the idea can be found in this DebianUbuntuspecific script Another trick I adopted from the original author of the ObjectiveC client is using lsof i to determine service availability Lastly I migrated to Ubuntu Xenial for all of the above except the ObjectiveC client lukebakken would you agree this would be an improvement for Pika My favorite part is that we will be testing with the latest versions of Erlang and RabbitMQ without the need to manually bump versions We are using BlockingConnection and basicget and no callback function How come we got a lot of Duplicate callback found for ConnectionUnblocked errors We use pika Any idea or thoughts