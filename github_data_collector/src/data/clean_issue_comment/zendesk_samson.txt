In this story Users can add s URL for ENV Groups on their project settings page The s file consists of list of environment variables grouped by deploygroup The S files should be managed by some external service the external service is responsible for syncing files to s and provide relevant s file URL Currently It is not mandated for using only external service env groups adding s files allows the system to read values and merge ENVs along with ENV stored in the database img width altScreen Shot at PM src We have preview options to view the values from the s URL once it is validated and added to the system s URL format Currently AWS widely accepts various s URL format eg s bucketkey etc In this release we have validated only to use which is the most common format and available in AWS s page for all s object it allows users to just copy and use it here File format In this release we support only JSON and YAML file format for the external env groups as it is widely known formats File schema As mentioned above the file should have list of ENV variableskey value and grouped by Deploy group Permalink Eg pod name pod env development pod name pod env test Risks Med Documentation about the kubernetes plugin mentions connecting to EKS clusters I naively tried using the kubeconfig you get using EKS and adding to samson but I just got an error So my question is just How to solve getting samson to talk to an EKS cluster A little background here Im running Samson in Kubernetes and every so often update the version of Samson and usually log into the pod after upgrading to run migrations This has worked for the past few years without much issue All the environment variables are correctly configured and Samson has been working great However after upgrading from v old I know to v I tried running binrake dbmigrate and was met with the following error usersamsonapp binrake dbmigrate rake aborted Database URL cannot be empty usrlocalbundlegemsactiverecord libactiverecordconnectionadaptersconnectionspecificationrb in initialize usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsurlconfigrb in new usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsurlconfigrb in buildurlhash usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsurlconfigrb in buildconfig usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsurlconfigrb in initialize usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in new usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in builddbconfigfromhash usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in builddbconfigfromrawconfig usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in block in buildconfigs usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in each usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in flatmap usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in buildconfigs usrlocalbundlegemsactiverecord libactiverecorddatabaseconfigurationsrb in initialize usrlocalbundlegemsactiverecord libactiverecordtasksdatabasetasksrb in new usrlocalbundlegemsactiverecord libactiverecordtasksdatabasetasksrb in foreach usrlocalbundlegemsactiverecord libactiverecordrailtiesdatabasesrake in block levels in top required usrlocalbundlegemsactiverecord libactiverecordrailtiesdatabasesrake in block in top required usrlocalbundlegemsactiverecord libactiverecordrailtiesdatabasesrake in top required usrlocalbundlegemsactivesupport libactivesupportdependenciesrb in load usrlocalbundlegemsactivesupport libactivesupportdependenciesrb in block in load usrlocalbundlegemsactivesupport libactivesupportdependenciesrb in loaddependency usrlocalbundlegemsactivesupport libactivesupportdependenciesrb in load usrlocalbundlegemsactiverecord libactiverecordrailtierb in block in classRailtie usrlocalbundlegemsrailties librailsrailtierb in instanceexec usrlocalbundlegemsrailties librailsrailtierb in block in runtasksblocks usrlocalbundlegemsrailties librailsrailtierb in each usrlocalbundlegemsrailties librailsrailtierb in eachregisteredblock usrlocalbundlegemsrailties librailsrailtierb in runtasksblocks usrlocalbundlegemsrailties librailsapplicationrb in block in runtasksblocks usrlocalbundlegemsrailties librailsenginerailtiesrb in each usrlocalbundlegemsrailties librailsenginerailtiesrb in each usrlocalbundlegemsrailties librailsapplicationrb in runtasksblocks usrlocalbundlegemsrailties librailsenginerb in loadtasks usrlocalbundlegemsrailties librailsrailtierb in publicsend usrlocalbundlegemsrailties librailsrailtierb in methodmissing appRakefile in top required See full trace by running task with trace Looking through releases I can see that in v rails was updated to v Running the same migrate command in version v the database is migrated all is hunkydory No errors Apologies but I dont really know too much about rails but some Googling brings up this issue could this be related The channel is not desired in our usecase Sometimes were just deploying a branch to staging that doesnt have any PRs in it because we are just directly pushing to the branch Is there a way to disable this channel Could argue that itd be more flexible if it just used some unique word and then users could setup a notification based on that word if they wanted to They should not be eagerloaded since their order is important zeitwerk failed on that previously incorrect setup Moving them from appdecorators to just decorators to avoid loadpath trouble All plugins had to rename their engine too this will break existing plugins but at least it wont be silent they can stay backwards compatible by defining both the Engine and the SamsonPlugin zendeskcompute appdecorators seem to be a problem with that so need some workaround like removing it from autoloadpaths ideally never adding it in the first place with some rails patch or putting them into root directory big git diff test changes but should be harmless annoying part is having to set files for singlecov so might need to add root folder support we need to do discover once per cluster and api version and then reuse that for parallel clients so for example dup a cacheddiscovered client and replace its connection ideally use Railscache for storing the discovered endpoints too and only refresh once per hour Similar to previous contributions id like to be able to perform CRUD operations on environment variable groups via a json api and this PR adds support for this Probably this could also be cleaned up and simplified to inherit from ResourceController but not sure about your stance on sharing code between plugins the main codebase and also wanted to get buyin on the change itself first References Jira link Risks LowMedHigh thing that could happen Restrict namespaces to only those managed by samson Need a way to migrate existing applications which are deploying to other namespaces References Jira link Risks Low breaks deployment of apps outside their namespace potentially breaking some complex use cases Screen Shot at pm Work in progress References Jira link Risks LowMedHigh thing that could happen 