 Repro Heres my repro case Expected Were passing in an object as the input and expected it to denormalize nested objects based on the provided schema Actual The output duplicate the same item for each index in the input array Context This used to work in but no longer works as of Its unclear to me if this is even correct usage of denormalize as the docs just say the normalized result that should be denormalized Usually the same value that was given in the result key of the output of normalize is this expected to only work with IDs as inputs Its also unclear from the tag changelog what exactly caused this change in behavior and if its expected or not fix Problem Project in examplesredux does not run Babel was updated to Refs I think its necessary to upgrade babel in examples too Solution This is work in progress right now I just upgraded modules and copied babel configs But it s still has an issue with module importing redux gitmaster yarn start yarn run v babelnode PATHTOnormalizrsrcindexjs import as ImmutableUtils from schemasImmutableUtils SyntaxError Cannot use import statement outside a module at Modulecompile internalmodulescjsloaderjs TODO Fix import problem described in above Add update tests Ensure CI is passing lint tests Update relevant documentation Maybe its nice to check validity of code in examples using CI Problem When following the instructions in the README in the redux example project a crash occurs Input Heres how Im using normalizr clone this repo run yarn in the root dir run yarn in the examplesredux dir run yarn start Output Heres what I expect to see when I run the above An inquirer prompt Heres what I actually see when I run the above normalizrreduxexample start homedaffodil inpartdevnormalizrexamplesredux babelnode homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabelcorelibtransformationfileindexjs throw err SyntaxError homedaffodil inpartdevnormalizrsrcindexjs Unexpected token if cache schemakey id Ensure we dont mutate it nonimmutable objects const entityCopy ImmutableUtilsisImmutableentity entity entity Need to set this first so that if it is referenced further within the denormalization the reference will already exist at Parserpp raise homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserppunexpected homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseIdentifier homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parsePropertyName homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseObj homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseExprAtom homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseExprSubscripts homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseMaybeUnary homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseExprOps homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs at Parserpp parseMaybeConditional homedaffodil inpartdevnormalizrexamplesreduxnodemodulesbabylonlibindexjs npm ERR code ELIFECYCLE npm ERR errno npm ERR normalizrreduxexample start babelnode npm ERR Exit status npm ERR npm ERR Failed at the normalizrreduxexample start script npm ERR This is probably not a problem with npm There is likely additional logging output above Context Tested on openSUSE Tumbleweed Node yarn MacOS High Sierra node v yarn I need to be able to retrieve the position index of an id item on an normalized array I know I can do this externally but I wanted to know if this library supports it somehow I couldnt find it anything of the sorts in the docs Data In my use case I have the following simplified data javascript id value id value id value id value and I want to achieve the following javascript entities indexes or other similar name items id value id value id value id value result As a note I could not make a value belong to two schemas at the same time but thats fine I think I can achieve this by calling normalize twice with different schemas so this is a non issue If not supported Is there a way to get the index of an item inside its parent during the normalization process I am not familiar with the code base so I am sorry if I misunderstood something Here I think that passing index as key parameter would solve my problem but also introduce some backward incompatible changes Maybe control it via a flag or something So someone could do the following javascript const indexes new schemaEntityindexes processStrategy value parent key key const normalized normalizedata indexes Thank you so much for contributing to open source and the Normalizr project Problem In some cases I would like to denormalize a structure with a list of Ids instead of a list of subobjects reasons could be to limit fetched data When i normalize this structure the normalization works I am left with the entity ids but there is no way to create stubs for the entities itself which I find ok since there could be an instance of the same object somewhere else in the structure But when denormalizing this I will get back an array with undefined items Solution A possible solution to this could be to add a possibility to add a fallbackStrategy option to the EntitySchema where we could write our own fallback method for denormalization TODO x Add update tests x Ensure CI is passing lint tests flow Update relevant documentation When trying to solve more solutions with Normalizr please keep in mind some of the following goals of the package Be lightweight small package size singledigit KiBs gzipped Be easy too many options in an API can become confusing Be clear the intended purpose of every method should be as obvious as possible Is it easy to do this in userland Would it be better off done there Problem In some cases I would like to denormalize a structure with a list of Ids instead of a list of subobjects reasons could be to limit fetched data When i normalize this structure the normalization works I am left with the entity ids but there is no way to create stubs for the entities itself which I find ok since there could be an instance of the same object somewhere else in the structure But when denormalizing this I will get back an array with undefined items Solution A possible solution to this could be to add a possibility to add a fallbackStrategy option to the EntitySchema where we could write our own fallback method for denormalization I would be glad to create a pull request for this Thank you so much for contributing to open source and the Normalizr project Problem Applications using webpack or other libraries using rollup cant take full advantage of es modules when the babel runtime helpers are just copied to every file Including this doesnt change a thing about the nones bundles but potentially saves great bundle sizes Solution This does add babelruntime as a dependency to ensure its on the node path in case they are using es modules For nones builds it will simply be ignored so no problem Most of the time if they are also using babelruntime the packager will hoist them to the same version if they can match Worst case scenario is there are two versions which degrades bundle size to where it was previously TODO Add update tests x Ensure CI is passing lint tests flow x Update relevant documentation Bumps mixindeep from to details summaryCommitssummary f c ee fa ensure keys are valid when mixing in values See full diff in compare view details details summaryMaintainer changessummary This version was pushed to npm by doowb a new releaser for mixindeep since your current version details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details When trying to solve more solutions with Normalizr please keep in mind some of the following goals of the package Be lightweight small package size singledigit KiBs gzipped Be easy too many options in an API can become confusing Be clear the intended purpose of every method should be as obvious as possible Is it easy to do this in userland Would it be better off done there Problem The processStrategy option is available for Entity schemas but not Object schemas I have an Object schema which Id like to do some preprocessing on I can of course do this myself after the normalize function has been ran but ideally this processing would be done everywhere this Object schema is referenced so I want the processing to live with the schema Example ts const userSchema new schemaEntityusers const myObjectSchema new schemaObject user userSchema const denormalized user id const result normalizedenormalized myObjectSchema The normalized value will look like ts const normalized user However I want the normalized value to look like ts const normalized userId That is the user property has been renamed to userId Solution Object should accept a processStrategy option like Entity does ts const myObjectSchema new schemaObject user userSchema processStrategy value parent key const copy value copyuserId copyuserid return copy I can raise a PR for this if you agree Related Thank you so much for contributing to open source and the Normalizr project Problem Reinstates which was unfortunately lost when v was released Fixes Related I will update documentation once the code side of things has been approved cc paularmstrong jgutta fxck joewestcott TODO x Add update tests x Ensure CI is passing lint tests flow Update relevant documentation 