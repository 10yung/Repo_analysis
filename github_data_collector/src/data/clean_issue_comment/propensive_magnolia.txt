We have a simple use case which is similar to the decodescala example We want to decode sth into an instance of a Scala case class given the type of the root sealed trait of all possible case classes the root sealed trait also has many other sealed traits who extends it at different levels on the hierarchy It seems actually the code in decodescala is not valid since actually the subtypes of ctx in dispatch function also contains sealed traits which are CallByNeed so if we do ctxsubtypesfindtypeNamefull nameget and if the case class that we want to find is actually one of the subtype of a sealed trait which is CallByNeed we cannot find the case class since it is not in subtypesArray I think it will be beneficial if we can somehow expose the names of all case class subtypes of a root sealed trait so that ctxsubtypesfindtypeNamefull nameget can be a valid check Would be very useful if we could find out if a subtype is an object when using subtypes in dispatch Eg case class TransientFooa String transient b String c String The annotations array for all params is empty This code which used to compile with Magnolia fails with scala import magnolia trait Eq T def equalvalue T value T Boolean object Eq extends PrimitiveEq with ListEq with OptionEq with EitherEq type Typeclass T Eq T def combine T ctx CaseClass Eq T Eq T value T value T ctxparametersforall param paramtypeclassequalparamdereferencevalue paramdereferencevalue def dispatch T ctx SealedTrait Eq T Eq T value T value T ctxdispatchvalue case sub subcastisDefinedAtvalue subtypeclassequalsubcastvalue subcastvalue implicit def gen T Eq T macro Magnoliagen T trait PrimitiveEq implicit val string Eq String trait ListEq implicit def listEq A implicit eq Eq A Eq List A trait EitherEq implicit def eitherEq A B implicit eqA Eq A eqB Eq B Eq Either A B trait OptionEq implicit def optionEq A implicit eq Eq A Eq Option A case class Guestname String child Option Guest case class Organizername String case class BirthdayPartypeople List Either Guest Organizer object BirthdayParty implicit val eq Eq BirthdayParty Eqgen But compiles if the implicit from EitherEq is moved to Eq companion object Probably this happens because of the low priority of implicits which come with mixed traits I couldnt find how to install magnolia in the documentation I think we should make it more obvious I was trying to make a small change to the default example and wanted to test that my change didnt break anything The compilation error I see looks like its an issue between Mercator and Either my guess is because Either has two type parameters for Left and Right and Monad only has one equivalent to Right but I dont know enough to submit a PR to fix Please let me know if theres any more information I can provide sbtroot test info Compiling Scala sources to homeannedgithubmagnoliaexamplesnativetargetscala classes error homeannedgithubmagnoliaexamplessharedsrcmainscaladefaultscala no type parameters for method constructMonadic makeParam magnoliaParam magnoliaexamplesDefaultT Monad PType implicit monadic mercatorMonadic Monad Monad T exist so that it can be applied to arguments magnoliaParam magnoliaexamplesDefaultT scalautilEither StringmagnoliaParam magnoliaexamplesDefaultT PType error because error argument expressions type is not compatible with formal parameter type error found magnoliaParam magnoliaexamplesDefaultT scalautilEither StringmagnoliaParam magnoliaexamplesDefaultT PType error required magnoliaParam magnoliaexamplesDefaultT Monad PType error def default ctxconstructMonadic param error error homeannedgithubmagnoliaexamplessharedsrcmainscaladefaultscala type mismatch error found magnoliaParam magnoliaexamplesDefaultT scalautilEither StringmagnoliaParam magnoliaexamplesDefaultT PType error required magnoliaParam magnoliaexamplesDefaultT Monad PType error def default ctxconstructMonadic param error error homeannedgithubmagnoliaexamplessharedsrcmainscaladefaultscala could not find implicit value for parameter monadic mercatorMonadic Monad error def default ctxconstructMonadic param error error three errors found In Im seeing this compile error at calls to the Magnoliagen macro where deriving the instance requires some other implicit evidence instances to be materialized which themselves may call some shapeless macros I dont have an easyminimal repro atm but wanted to mention in case its clear what the problem possible fix might be eg is this a hardcoded instancename string that is colliding with other macrogenerated instances from shapeless When we use derivation on a userdefined case class some typeclass instances might be missing Magnolia at the moment may only report on the first missing instance Is it possible to change the way errors are collected so we could see all the missing instances scala testshow error for multiple missing implicits scalac case class AlphadblDouble strString Showgen Alpha assert TypecheckError txtmagnolia could not find ShowTypeclass for type Double in parameter dbl of product type Alpha magnolia could not find ShowTypeclass for type String in paramater str of product type String Magnolia can not derive typeclasses instances for the following class scala class PrivateClass private val value Long extends AnyVal object PrivateClass def applyl Long new PrivateClassl The derived instance will contain something along the line of scala new PrivateClassmakeParamparametersmacro asInstanceOf Long Which will fail to compile with the following error error constructor PrivateClass in class PrivateClass cannot be accessed in anon magnoliaCaseClass MyTypeclassTypeclass PrivateClass error MyTypeclassgen PrivateClass error This happened while calling magnolia to derive a typeclasse instance for comgooglebigtablev MutationMutationCase console error exception during macro expansion scalaScalaReflectionException Java enum DELETEFROMFAMILY is not a type at scalareflectapiSymbolsSymbolApiasTypeSymbolsscala at scalareflectapiSymbolsSymbolApiasTypeSymbolsscala at scalareflectinternalSymbolsSymbolContextApiImplasTypeSymbolsscala at magnoliaMagnoliaanonfungen magnoliascala at scalacollectionimmutableListmapListscala at magnoliaMagnoliadirectInferImplicit magnoliascala at magnoliaMagnoliaanonfungen magnoliascala at scalaOptionorElseOptionscala at magnoliaMagnoliaanonfungen magnoliascala at magnoliaCompileTimeStateStackwithContextmagnoliascala at magnoliaMagnoliagenmagnoliascala at comspotifysciocodersCoderMacroswrappedCoderCoderMacrosscala While magnolia cant possibly derive an typeclasse instance for this type it should still be able to use fallback instead