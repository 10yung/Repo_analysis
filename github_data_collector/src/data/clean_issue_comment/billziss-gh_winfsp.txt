 Bug Report The FspFileSystemResolveReparsePoints function dont handle Junction reparse point also called Mount point IOREPARSETAGMOUNTPOINT is not only used for drive mounting on directory but also for directory to directory redirection A simple work around is to convert an IOREPARSETAGMOUNTPOINT in IOREPARSETAGSYMLINK into the GetReparsePointByName callback How to Reproduce Start memfs with default setting mount as drive and create a directory with subdirectory andor an EXE file then create a Junction mklink j link target to the first directory on mounted drive As result the EXE file cant start and exploring the subdirectory loop to the parent directory Behaviors Expected to work just as Symlink Environment OS version and build WIN x WinFsp version and build B Bug Report When you try to change the owner for the main drive or a file with explorer you get the error ERRORINVALIDOWNER No matter what account you specify Builtin or not neither the proccess account User or System or enable privileges make the operation work The error come from FspSetSecurityDescriptor function that return NTSTATUS C A Probably from SetPrivateObjectSecurity How to Reproduce Launch memfs with default setting drive mapped and try to change the drive owner with the explorer interface Environment OS version and build WIN and WINSERVER All x WinFsp version and build B and B windows version Win Win Win Win VMware version cmd execute C Users Administrator Desktop passthroughx exe p M m X D C Users Administrator Desktop LogFiletxt LogFile is empty google online forum If you know why please help us thank you Enhancement Request As per title Original Google Group post from Keith Kaminski Hello We have code currently running in Windows Docker containers that accesses files on a network file share Wed like to use WinFsp within those containers to install our own user mode file system to handle all those requests to the NFS To test something simple we took the memfsdotnet code and built a C console app that targets NET Framework After verifying that it worked on a local development box we attempted to get it working within a docker container The dockerfile we used is pretty straightforward and I have attached a sample of it here We then navigated to the app folder within our container and executed the following command memfsdotnetexe t n s m Y d D C app driverdebuglog And yes we were just testing a drive letter mount as opposed to an NFS to start with After roughly seconds or so the application simply closes Nothing is written to the configured debug log file We do however see two relevant messages in the Event Log memfsdotnet cannot mount file system memfsdotnet The service MemfsService has failed to start Statuse f d We spent a bit of time trying to debug and we were able to determine that the following line in the FileSystemHost was returning STATUSDRIVERUNABLETOLOAD We then tried to enable mixed mode debugging to step into the C code but it doesnt look like the PDBs included in the WinFsp installer have source maps so we didnt have much success We also tried to start the driver from the command line using sc start winfsp This does not appear to work though and we get the following SERVICENAME winfsp TYPE FILESYSTEMDRIVER STATE STOPPED WIN EXITCODE x SERVICEEXITCODE x CHECKPOINT x WAITHINT x PID FLAGS The error code is just No attempts to start the service have been made since the last boot I cant find anything in the event logs or any other indication of failure We are sort of at a loss about how to continue troubleshooting It may be some limitation of Windows Docker containers that were running into but we are hopeful that we can somehow get this to work For reference I have also attached the results of running diagbat in the container Thanks Keith Kaminski Link to full thread Bug Report The create callback is called also for special files like SIFIFO The special named FIFO file is still not created instead a corresponding lnk file pops up in the same directory mkfifo foobar ls l foobar rwx Hasse None Oct foobarlnk The same happens if create is not implemented which forces a call to mknod instead Possible root cause is that the file type mode bits are not being sent properly in create nor mknod callbacks see issue I however chose to file this as two separate bugs since they are basically two different deviations compared to the legacy FUSE API behavior on eg Linux How to Reproduce This is a bit tricky since you need to mount a user file system that implements the create callback Then try to create a named FIFO mkfifo under some FUSE file system mount point Behaviors According to FUSE documentation create should only be called for regular files SIFREG From fuseh Create a file node This is called for creation of all nondirectory nonsymlink nodes If the filesystem defines a create method then for regular files that will be called instead int mknod const char modet devt Environment OS version and build CYGWINNT xxx x Cygwin WinFsp version and build fuse Bug Report When a new file is created on a mounted FUSE file system either the mknod or create callback is called depending on what the file system implements the mode argument is expected to hold not only the file mode bits but also the file type eg SIFREG This does not seem to be the case on WinFSPFUSE but works as expected on eg Linux How to Reproduce Create a new file using eg touch and watch the mode bits in calls to mknod or create Behaviors Expected the file type bits to be set in the mode argument as is the case on eg Linux Environment OS version and build CYGWINNT xxxx x Cygwin WinFsp version and build fuse Question Hi is WinFsp compatible with FUSE filesystem over Google Drive WinFsp version and build WinFsp B IRQLNOTLESSOREQUAL a An attempt was made to access a pageable or completely invalid address at an interrupt request level IRQL that is too high This is usually caused by drivers using improper addresses If a kernel debugger is available get the stack backtrace Arguments Arg memory referenced Arg IRQL Arg bitfield bit value read operation write operation bit value not an execute operation execute operation only on chips which support this level of status Arg fffff address which referenced memory Debugging Details KEYVALUESSTRING TIMELINEANALYSIS DUMPCLASS DUMPQUALIFIER BUILDVERSIONSTRING amd frewin sp ldrescrow SYSTEMMANUFACTURER TSINGHUA TONGFANG COMPUTER SYSTEMPRODUCTNAME H H CM BIOSVENDOR American Megatrends Inc BIOSVERSION E NP BIOSDATE BASEBOARDMANUFACTURER ECS BASEBOARDPRODUCT H H CM BASEBOARDVERSION DUMPTYPE BUGCHECKP BUGCHECKP BUGCHECKP BUGCHECKP fffff WRITEADDRESS GetPointerFromAddress unable to read from fffff f Unable to get MmSystemRangeStart GetUlongPtrFromAddress unable to read from fffff f f GetUlongPtrFromAddress unable to read from fffff f a CURRENTIRQL FAULTINGIP ntKiDeliverApc a fffff mov qword ptr rdx rax CPUCOUNT CPUMHZ bb CPUVENDOR GenuineIntel CPUFAMILY CPUMODEL a CPUSTEPPING CPUMICROCODE a FMSR SIG cache init CUSTOMERCRASHCOUNT DEFAULTBUCKETID WIN DRIVERFAULT BUGCHECKSTR xA PROCESSNAME System ANALYSISSESSIONHOST XXKPC ANALYSISSESSIONTIME ANALYSISVERSION amd fre TRAPFRAME fffff trap xfffff NOTE The trap frame does not contain all registers Some register values may be zeroed or incorrect raxfffffa d rbx rcx rdx c rsi rdi ripfffff rspfffff b rbp r fffffa bfcb r r fffffa bfcb r fffff bab r r r r iopl nv up ei pl zr na po nc ntKiDeliverApc x a fffff mov qword ptr rdx rax ds Resetting default scope LASTCONTROLTRANSFER from fffff f d to fffff e a STACKTEXT fffff d fffff f d a ntKeBugCheckEx fffff e fffff f b fffffa d ntKiBugCheckDispatch x fffff fffff fffffa d fffff fffffa bb fffff ntKiPageFault x fffff b fffff ee f ntKiDeliverApc x a fffff fffff e a fffffa b b fffffa bfcba fffffa ae ntKiApcInterrupt x b fffff c fffff fffffa ee fffffa bfca fffffa bfcba ntKeReleaseSpinLock x a fffff f fffff ec fffffa ae fffff d fffff a fffffa ae ntIoCsqInsertIrpEx x fffff fffff fffffa bfca fffffa ba fffff a winfspx FspIoqPostIrpEx x b e work docprotect trunk client project winfsp src sys ioqc fffff fffff c f fffffa ae fffffa bfca winfspx FspWrite xf e work docprotect trunk client project winfsp src sys writec fffff c fffff c df fffffa ee fffffa fffffa bfca fffffa bfca FLTMGRFltpLegacyProcessingAfterPreCallbacksCompleted x f fffff a fffff bde b fffffa bfca fffffa ee fffffa fffffa d FLTMGRFltpDispatch xcf fffff ab fffff e a b ntIoAsynchronousPageWrite x b fffff b fffff c f fffffa d fffffa fffff a ntMiGatherMappedPages xeeb fffff c fffff d fffff b dcdd ntMiMappedPageWriter x fffff d fffff ef a fffff b fffffa d fffffa d b ntPspSystemThreadStartup x fffff d fffff fffff fffff b ntKxStartSystemThread x THREADSHA HASHMODFUNC b e cfc f d e d f b d bbf THREADSHA HASHMODFUNCOFFSET c ed ce bf db b e f f THREADSHA HASHMOD de fa c be a f e ebfc a FOLLOWUPIP winfspx FspIoqPostIrpEx b e work docprotect trunk client project winfsp src sys ioqc fffff ec c test eaxeax FAULTINSTRCODE f c FAULTINGSOURCELINE e work docprotect trunk client project winfsp src sys ioqc FAULTINGSOURCEFILE e work docprotect trunk client project winfsp src sys ioqc FAULTINGSOURCELINENUMBER FAULTINGSOURCECODE NTSTATUS Result FspIrpTimestampIrp BestEffort FspIrpTimestampInfinity QueryInterruptTimeInSec IoqIrpTimeout Result IoCsqInsertIrpEx IoqPendingIoCsq Irp PVOIDBestEffort if NTSUCCESSResult if PResult PResult STATUSPENDING return TRUE SYMBOLSTACKINDEX SYMBOLNAME winfspx FspIoqPostIrpEx b FOLLOWUPNAME MachineOwner MODULENAME winfspx IMAGENAME winfspx sys DEBUGFLRIMAGETIMESTAMP c d IMAGEVERSION STACKCOMMAND thread cxr kb FAILUREBUCKETID X xAwinfspx FspIoqPostIrpEx b BUCKETID X xAwinfspx FspIoqPostIrpEx b PRIMARYPROBLEMCLASS X xAwinfspx FspIoqPostIrpEx b TARGETTIME T Z OSBUILD OSSERVICEPACK SERVICEPACKNUMBER OSREVISION SUITEMASK PRODUCTTYPE OSPLATFORMTYPE x OSNAME Windows OSEDITION Windows WinNt Service Pack TerminalServer SingleUserTS OSLOCALE USERLCID OSBUILDTIMESTAMP BUILDDATESTAMPSTR BUILDLABSTR win sp ldrescrow BUILDOSVERSTR amd frewin sp ldrescrow ANALYSISSESSIONELAPSEDTIME d ANALYSISSOURCE KM FAILUREIDHASHSTRING kmx xawinfspx fspioqpostirpex b FAILUREIDHASH a ce c e f d c edb Followup MachineOwner Enhancement Request Fuse api exposes a copyfilerange method since fuse see fuse struct definition would it be possible to add this feature in winfsp ssizet fuseoperationscopyfilerangeconst char pathin struct fusefileinfo fiin offt offsetin const char pathout struct fusefileinfo fiout offt offsetout sizet size int flags Copy a range of data from one file to another Performs an optimized copy between two file descriptors without the additional cost of transferring data through the FUSE kernel module to user space glibc and then back into the FUSE filesystem again In case this method is not implemented glibc falls back to reading data from the source and writing to the destination Effectively doing an inefficient copy of the data Enhancement Request Windows includes the CcSetReadAheadGranularityEx DDI and the older CcSetReadAheadGranularity DDI which can be used to influence the operating system readahead policy for a particular file This functionality should be exposed to user mode file systems in some form This may be implemented on a perfile basis CcSetReadAheadGranularity works on a FILEOBJECT or on a perfilesystem basis eg via FSPFSCTLVOLUMEPARAMS Maximum flexibility might be provided by a mix of the two Consider a ReadAhead field in FSPFSCTLVOLUMEPARAMS which defines a file system default with meaning the operating system default policy ie the current behavior In addition a file system may choose to provide a different readahead for a particular file perhaps encoded as a power of in the bitfields of FSPFSCTLTRANSACTRSPRspCreateOpened since readahead should be a power of in general FUSE readahead support should be added via a commandline option NET support should be added as well See issue billzissghsshfswin which requested such support for SSHFSWin