 Summary of the changes Why this improves CrateDB In a query like SELECT obj x FROM SELECT obj AS t GROUP BY obj x a invalid logical plan was created It looked as follows RootBoundary address postcode GroupBy address postcode Boundary fetchid Boundary fetchid FetchOrEval fetchid Collect docusers fetchid address postcode All Currently the Collect operator is trying to detect columns that are not intermediately used If it finds any it substitutes them with a fetchId This fetchId is later picked up by the FetchOrEval operator and resolved to the actual columns that have been selected In the scenario above the parent was using obj x and the child had obj but several components werent taking the relationship between those into consideration So the Collect operator assumed that obj is unused but it got obj x as used column which it couldnt interpret because the RelationBoundary operator couldnt handle the mapping There was no PARENTRELobj x CHILDRELobj x entry This raises the question why we have a special notation for lookups into objects in the first place We could also always build functions One reason is that weve index structures for the nested columns for an object which we want to utilize A lookup obj extract key x execution would fully load obj and then parse it to extract the key That can be an expensive operation if obj is large Especially compared to the alternative execution Using a column oriented data structure that we have specifically for obj x Note that this fix doesnt yet utilize this Instead weve RootBoundary address postcode GroupBy address postcode Boundary address Boundary address Collect docusers address All We could follow up with optimizer rules to optimize this scenario An alternative approach to fix this was in Which changed the obj x lookup on the subrelation to change the subrelation itself SELECT obj x FROM SELECT obj AS t GROUP BY obj x would become SELECT obj x FROM SELECT obj obj x AS t GROUP BY obj x This approach looks simpler but also seems to break semantics It introduces the notation that a child relation is modifying its outputs due to the actions of a parent relation Checklist User relevant changes are recorded in CHANGEStxt Touched code is covered by tests Documentation has been updated if necessary CLA is signed This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Summary of the changes Why this improves CrateDB Currently the column types in VALUES have to be an exact match which prevents using literals that can be implicitly and null literals Checklist x User relevant changes are recorded in CHANGEStxt x Touched code is covered by tests x Documentation has been updated if necessary x CLA is signed x This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Summary of the changes Why this improves CrateDB This pr adds the plain analyzer to the analyzer documentation and changes the description for the default analyzer for text columns from standard to plain in the fulltext indices documentation It also adds missing ticks to the documentation of the keyword analyzer Checklist x User relevant changes are recorded in CHANGEStxt x Touched code is covered by tests x Documentation has been updated if necessary x CLA is signed x This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Summary of the changes Why this improves CrateDB Implements missing equals and isConvertableTo in the object data type Checklist User relevant changes are recorded in CHANGEStxt x Touched code is covered by tests Documentation has been updated if necessary x CLA is signed This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Summary of the changes Why this improves CrateDB DRAFT It has to be discussed bwc is not addressed yet Checklist User relevant changes are recorded in CHANGEStxt Touched code is covered by tests Documentation has been updated if necessary CLA is signed This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Summary of the changes Why this improves CrateDB To support casts like text which is used by the PostgreSQL JDBC client Checklist x User relevant changes are recorded in CHANGEStxt x Touched code is covered by tests x Documentation has been updated if necessary x CLA is signed x This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI Use case Data in the system have varying degrees of criticality Some data are very crytical some not eq logs But after restart crate starts restoration and replication process in random order I want to replicate critical data first Feature description New property at table level ALTER TABLE xxxx SET restorepriority ALTER TABLE yyyy SET restorepriority When crate select tables to restore it will take first tables with largest restorepriority In sample crate will first start replicate relocate restore table yyyy finish it and only then starts replicaterelocaterestore table xxxx Alternativly it may be property at schema level with same logic The old RamAccountingContext uses a flush buffer to prevent flushing to the circuit breaker on every accounted bytes This leads to a possible underaccounting Additionally the implementation isnt threadsafe but was used from multiple threads which also leads to wrong accounting This implementation is superseeded by new RamAccounting implementations which are either threadsafe ConcurrentRamAccounting or eagerly allocate ondemand a block of bytes BlockBasedRamAccounting this one must be created dedicated per thread The second commit adds a test assertion to ensure that the Query circuit breaker is decreased on every jobstatement additionally to existing breaker assertions CrateDB version Problem description I cant groupby selected data from view when nested column used in GROUP BY statement Steps to reproduce create table test x object as a int Table TEST created create view vtest as select from test View VIEW created select x a from vtest success select x a count from vtest group by x a ERROR SQLParseException Couldnt find FieldAnalyzedViewqualifiedNamedocvtest relationQueriedTableDocTableRelationdoctestx a pointerFieldQueriedTableDocTableRelationdoctestx a pointerFieldDocTableRelationdoctestx a pointerReferenceidentRefIdent doctestx a granularityDOC positionnull default expressionnull typeinteger index typeNOTANALYZED nullabletrue columnstore enabledfalse in SourceSymbolsinputsFieldAnalyzedViewqualifiedNamedocvtest relationQueriedTableDocTableRelationdoctestfetchid pointerFieldQueriedTableDocTableRelationdoctestfetchid pointerReferenceidentRefIdent doctestfetchid granularityDOC positionnull default expressionnull typebigint index typeNOTANALYZED nullablefalse columnstore enabledfalseIC bigint nonDeterministicFunctions Summary of the changes Why this improves CrateDB This change deduplicates the INSERT INTO VALUES and INSERT INTO SELECT analyzer logic Follow up tasks Remove boundAnalysis Session merge Analyzer and UnboundAnalyzer clean up statement analyzers etc Refactor InsertFromSubQueryAnalyzedStatement symbols are created way too early so we have to move some logic to InsertFromSubQueryPlanner Make primary key references nullable so we can handle creation of primary key and partitioned by symbols in InsertInsertFromVlaues plans in a better way Checklist User relevant changes are recorded in CHANGEStxt Touched code is covered by tests Documentation has been updated if necessary CLA is signed This does not contain breaking changes or if it does It is released within a major release It is recorded in CHANGEStxt It was marked as deprecated in an earlier release if possible Youve thought about the consequences and other components are adapted Eg AdminUI 