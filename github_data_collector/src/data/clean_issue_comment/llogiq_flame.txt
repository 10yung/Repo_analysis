Now that inferno is relatively stable and exposes separate APIs for both stack folding and producing flamegraphs I wonder if itd be interesting to see if we could make flame use inferno to generate the flamegraphs That way you wouldnt need to vendor all the JS code and such into this project Youd also get stack folding for free if you wished Right now notes are only in the inmemory data structures they dont get output to stdout or HTML Minimal test case use rayonprelude use flame use std fsFile fn somethingi usize f flamestartSomething stdthreadsleepstdtimeDurationfrommillis flameendSomething fn main let a collectVec pariter mapi somethingi collectVec flamedumphtml mut Filecreateflameshtmlunwrapunwrap println flamethreads Dependencies rayon flame The written file has no graphics The output is Thread id name Somemain spans priv so no data is available I think at least that this is how it works I spent some time trying to figure out why I got an empty graph when all profiling happens in other threads I found that you have a threads function from which I can get a VecSpan for each thread But Span only has a function to write to json not html How can I get HTML output from different threads Or alternatively what can I do with a JSON file to display the flame graph I use flame for a ray tracer which roughly correspond to rust for i in x for j in y let guard flamestartguardcompute color out i j computecolori j The trouble is that I get xy compute color frames each taking of running time Is there a way to combine these in a single frame aside from doing everything manually with flameframes Since your lib requires modifications to the source code its not easy to disable it for a true release I see two ways to fix this Add a compile time feature which prevents data collection Im thinking global const with a compile time value and a if STATICENABLED return in every function Since the condition is known at compile time it should be inlined and removed by rustc Add a runtime switch like flamedisable for example It could set an AtomicBool It would be a bit slower but would allow the activation without recompiling Now that I thing of it it would be a very nice feature to have These two options could be implemented at the same time like if STATICENABLED DYNAMICENABLED I am currently profiling some graphics code and I saw that currently open spans are not plotted in the output and this produces misleading stack plots I wrote a counter for a short number of frames and after that I plot the flamegraph html and I shout down the application This call happens inside of the function that renders the current frame and therefore is being profiled the span is not present in the plot although the nested ones already finished are I know that this is not the most pretty coding style but since it can be written flame should do the right job here the question is how Anyhow great job here It is a very nice tool especially when used with flamer Hi This looks great and easy to use Is there any API planned for folding the results like I want to profile some tight loops and only a few seconds of running my program generates MB html file