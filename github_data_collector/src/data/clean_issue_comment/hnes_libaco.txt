 This PR is definitely nitpicking over user experience Adding build dependencies before build instructions allows the user to build it successfully on the first try There are instructions further on that reveal that those dependencies exist but some people like me are impatient and jump right into building it without reading everything Thoughts This pull request introduces acoyieldto that enables a nonmain co to yield to another co with a single context switch The first patch namely add acoyieldto seems a little complicated because part of the code of acoresume is moved to a new auxiliary function called acoownstack to avoid duplicating code at acoyieldto Ignoring this code movement the additions are straightforward The second patch adds testacotutorial c to test and show how to use acoyieldto This pull request closes In the case Im considering using libaco Ill have less than standalone nonmain coroutines and the cost to switch between the coroutines is critical The current cost of ns for acosw fits my application but having to go through the main coroutine first to switch to another nonmain coroutine puts the cost of switching at ns what becomes too much for what Im trying to accomplish Is it possible to have a version of acoyield that receives the coroutine to where to yield void commonentry callfp call current coroutines acocofuncp acoexit Then the cofuncp can return like a normal function without calling acoexit hi I am reading the code and have done some benchmark I have two questions tcmalloc improves the benchmark results With acoamount and copystacksize B the tcmalloc version achieves ns per acoresume operation but the default takes ns Why In this case acoresume does not allocate memory which is really confusing When copying stack you use xmm registers to optimize small memory copying But according to my benchmark this does not make many differences I guess memcpy already takes advantage of these registers Do you have more benchmark results I will be very grateful to you for answering my questions To avoid being optimized by the compiler the benchmark coroutines cofpstkszxx and cofpalloca use memset However it failed on my machine Ubuntu Linux gcc We can use the following method to correct the stack size void donotoptimizevoid value asm volatile rmvalue memory void cofpstksz int ip donotoptimizeip memsetip sizeofip while acoyield acoexit Hello Im so sorry but Im really interested in this library but I dont quite understand from the diagrams what is going on Do you think we can work together to improve the documentation My naivety might help to improve the documentation as I can point out what I dont understand and perhaps make a PR with improved documentation In the first instance I dont understand how this differs from normal stackful coroutines fibres To me it looks like you are storing the registers in a private area but then sharing a single stack between multiple coroutines Does this mean stack is trashed when switching between coroutines ie local variables cant be used Is this an implementation of stackless coroutine lea ecx esp x esp ecx signal esp esp toco esp signal ecx toco I followed your coding convention but I think that lowercase macros are evil because it confuses newcomers uppercase macros are convention I took the freedom to add a new macro acomemcalloc which you can read more details in the commit Also I want to point out that this commit breaks C support which was already broken by Staticassert because using malloc in C is a really bad habit and there is no support for typeof of something similar in C Issue 