Since recent updates of sbt it started to give this warning hometravisbuildkaitaiiokaitaistructcompilerbuildsbt warning method crossProjectFromBuilder in trait CrossProjectExtra is deprecated since The builtin crossproject feature of sbtscalajs is deprecated Use the separate sbt plugin sbtcrossproject instead lazy val compiler crossProjectinfile It looks like we need to migrate to Hi I would be interesting to have some kind of templated or parametrized type name Some kind of id somefield type templatedtypeparam param then I have a templatedtypeksy something like this imports sometypeselector params id version type str id otherparam type u seq id afield type atype id finalfield type sometypeselectorafieldsomedata Then we could have a bunch of sometypeksy files which could do sometypeone params id someparam sometypetwo params id someparam A switch is what Im using today but it requires modifying templatedtypeksy for ever new selector of sometype on imports and case select The procol Im working have lot of versions as selectors for diferent categories which is also a possible selector File contains some count of fixed size blocks Data entry may consist of n block last block marked with magic signature The objective is step Use array repeatuntil to locate data entries step Create instance and if necessary substream to handle variable size data Is it possible to get array io object Or is there a way to handle structure other way mb pos seq id entries type entryt repeat eos types entryt seq id blocks type blocksimplified size repeat until repeatuntil sign EndMarker instances dataprocessed io blocksio if it would be possible to get io of all array this will work type entryextt size blockssize specify size to create substream blocksimplified simple block description just to find end marker seq id filler size id sign type str size entryextt ext blocks description to handle data seq struct fields data will be handled here Script is mentioned in updated documentation in the Any plans Not having buster packages is a showstopper for me at least the kaitai build toolchain is a bit too esoteric for me to dig into Python is EOL allows to add some type hints They are not enforced without special measures but can be used by linters like mypy REPLs and langservers import typing to the top of a file Output type of a function is shown by an before Types of arguments are shown by adding TypeOfArg right after arg name Union types are typingUnion T T Lists are typingList T or maybe even more generic typingIterable T type of self is usually not marked as a type of an arg If a func returns nothing use None You need to set the types as strings containing their names if the type is not yet defined python def ab A A return b class A def initself asdf typingOptional A None None pass class B def initself asdf A None pass In the financial industry the ISO protocol is widely used This protocol consist of A bitmap several bytes each bit in their determines that fields present in the message Message fields For example first fields of many ISO implementations can be described by the following ksy schema yaml meta id iso endian be types str seq id length type u id value size length type str encoding ASCII seq id bitmap type b repeat expr repeatexpr id secondarybitmap type b repeat expr repeatexpr if bitmap id pan doc n type str if bitmap Protocol itself is not describes how to determine field length So it is not backwardcompatible if you add new field between already defined fields because old clients will not known how to skip unknown field they do not known its length That means that parsers must throws an exception when it comes with unknown field How to express that in ksy Right now if delete secondarybitmap member from definition and try to parse message that contains both secondarybitmap and pan fields ksy will parse bytes from secondarybitmap as pan field In some cases you may want to enhance generated classes with custom stuff The easiest way to do that supply custom base class Expected result for Java yaml meta id format java Generated by ksc public class Format extends MyBaseFormat somewhere in the codebase handwrited class class MyBaseFormat extends KaitaiStruct In you can notice that with different case types in switchon node resulting field type can be reduced to very generic type for example Object in Java In order to improve user experience we can add additional information to field documentation that will contain all types that field can contain For specified example Javadoc can be supplemented with text java Javadoc from doc attribute pField can have values of following classes ul lilink Innerli licode byte li ul Such addition do not required for languages that can express returned type in their types For now that will be useful at least for Java and C When ksc produces error it wont tell in what line it is originated Also most errors are very obscure