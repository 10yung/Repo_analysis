Im using parseback in my project but parsing is very slow due to many whitespaces In practice there is no DSL does not have whitespace I have introduced a lexing phase before the PWD the parsing speed became very fast Here are patterns of benchmark results in my box no optimize parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss no optimizeadd whitespace parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss lexing optimizeadd whitespace parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksgllRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksparsebackRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss parsebackbenchmarksArithmeticBenchmarksspcRunthrpt opss Lexing before PWD is as fast as nonwhitespace input even if the input has whitespaces I suggest you introduce a lexing phase before parse Hi I am new to parseback and this could be completly me running against a wall but I am having trouble getting your example of the arithmetic expression grammar to work This line here val result Eval Either List ParseError List Int exprinput gives me the following Error message Error type mismatch found catsEval List parsebackParseError parsebackutilCatenable Int which expands to catsEval scalautilEither List parsebackParseError parsebackutilCatenable Int required catsEval Either List parsebackParseError List Int val result Eval Either List ParseError List Int exprinput However the example executes when omitting the explicit type declaration of variable result But it will fail to parse and throw the following error message LeftListUnexpectedCharacterLine Set s Moreover when inserting a whitespace before the in the LineStream like this the example parses correctly Am i doing anything wrong And also is there a forum for questions like this I wasnt able to find any so i posted it here Please let me know Cheers Besides here is my SBT File version scalaVersion resolvers bintraydjspiewakmaven at val ParsebackVersion libraryDependencies comcodecommit parsebackcore ParsebackVersion libraryDependencies comcodecommit parsebackcats ParsebackVersion Hi guys It would be nice to see this available on Central It shouldnt be too hard to support publishing to sonatype on travis Executing the Direct Grammar on a worksheet scala import parseback import parsebackcompatcats import catsEval implicit val W Whitespace sr lazy val expr Parser Int expr term e t e t expr term e t e t term lazy val term Parser Int term factor e f e f term factor e f e f factor lazy val factor Parser Int expr expr e e dr str strtoInt among others one input of the README scala exprLineStream Eval value does not parse and generates scala res parsebackutilEitherSyntax List parsebackParseError parsebackutilCatenable Int LeftListUnexpectedCharacterLine Set s instead The expression producing the expected output requires whitespaces at the beginning and the end scala exprLineStream Eval value res parsebackutilEitherSyntax List parsebackParseError parsebackutilCatenable Int RightSingle I suspect this may be due to Note that parsebacks whitespace handling is currently extremely naive The only whitespace regular expressions which will behave appropriately are of the form where is any single character class Thus s is valid as is t but n s is not We hope to lift this restriction soon but it requires some work on the algorithm isnt it Given the following test case Scala import catsEval import parseback import parsebackast import parsebackcompatcats object Testcase extends App sealed trait Expr extends Node case class Identifiername String extends Expr with LeafNode case class Applicationleft Expr right Expr extends Expr with BinaryNode override def assocLeft Boolean true override def sym Symbol app lazy val expr Parser Expr azAZ r name Identifiername expr expr fun arg Applicationfun arg expr filter precApplication Test correct gives the left assoc AST printlnexprLineStream Eval function function argumentvaluemaptoList Test bug gives no error but an empty list of ASTs printlnexprLineStream Eval function function argumentvaluemaptoList where we define a simple grammar with just Identifiers and function Application I intend application to be leftassociative and thus write filter precApplication with BinaryNode and def assocLeft Boolean true The first example works fine only the leftassociative AST is returned However in the second example where we use parentheses an empty list is returned where we would expect the rightassociative AST Am I using filter andor BinaryNode wrong Or is this a bug The original Might Darias and Spiewak paper reported a x speedup when implementing compaction Adams Hollenbeck and Might validated this as well as providing some improvements to the grammar traversals introduced by repeated compaction One of the benchmarks that I think would be particularly interesting is to use the C YACC grammar the Lex specification is here to parse the full stdlib This is the very definition of a realworld test Critically the C grammar makes heavy use of LALR features while simultaneously being entirely unambiguous I would not want to produce any ASTs every parser should be Parser Unit Benchmarking this between parseback gllcombinators and ideally Scala Parser Combinators would be very instructive Straight out of the ASFSDF playbook Identifiers are usually ambiguous with keywords Its important to be able to address this with negation disambiguation Its technically possible to implement this by hand now on top of the filter construct but there may be a nicer algorithmic way At the very least the syntax can be made a lot better This is the current state of the syntax in parseback It is done in this way to achieve two goals The parameter to should be an arityn function where n is the number of chained type parameters within the target Parser of the form A B N The parameter to should be fully type inferred allowing for the use of lambdas without explicit type parameters The reason there is a quadratic number of cases stems from the fact that we need to provide a separate specific syntax class for each possible reassociation of the type constructor Obviously it would be much nicer to just write a linear number of cases one for each arity presumably and then build some implicit machinery which would convince implicit search to generate the quadratic portion but my efforts in that direction have thus far been unsuccessful Paging milessabin and travisbrown for thoughts and assistance if they feel so inclined