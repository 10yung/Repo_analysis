 Actually regarding my suggestion it would also work if you could supply an EqualityComparer for EquivalencyAssertionOptions or is it already possible Im just saying because EqualityComparer is the standard NET way of doing it and often there is already a suitable equality comparer available that could be reused as is At least in our case I like writing EqualityComparers because they nicely encapsulate the equivalency I dont like repeating equivalency rules inline because usually the same rules are needed in many places I guess you could encapsulate them as IEquivalencySteps but why do that if you already have EqualityComparer For example orderDtoShouldBeEquivalentToorder options options UsingDateTimeEqualityComparer or orderDtoShouldBeEquivalentToorder options options UsingDateTimenew DateTimeEqualityComparer Closes Nothing special simple wrapper feels more fluent than existing ToDateTimeOffset Closes See I noticed in the source code that GenericDictionaryAssertions uses intersect to compare the keys from the dictionary and the unexpected keys which does not use the equality comparer of the dictionary The dual ContainKeys implementation as well as the other methods all use the ContainsKey on the dictionary which is correct To illustrate the issue I added two unit tests and changed the implementation in the pull request I also updated the xml documentation of all NotContainKeys to reflect the code The documentation was saying that the keys were compared using objectEquals which is not the case in the code I noticed in the source code that GenericDictionaryAssertions uses intersect to compare the keys from the dictionary and the unexpected keys which does not use the equality comparer of the dictionary The dual ContainKeys implementation as well as the other methods all use the ContainsKey on the dictionary which is correct To illustrate the issue I added two unit tests and changed the implementation in the pull request I also updated the xml documentation of all NotContainKeys to reflect the code The documentation was saying that the keys were compared using objectEquals which is not the case in the code x Keep only NET Core NET Core NET NET Standard and x Remove older test frameworks Make everything under Common that is supposed to be used internally internal Remove IAssertionRule Capitalize CallerIdentifierlogger Remove if NETCOREAPP from all specs Dog feed betas against extension projects like FluentAssertionsJson etc Check that all ifs are necessary in both core and specs projects Remove ncrunch files globaljson per specs project Remove references to Gallio and MbUnit Description The output for failed stringShouldBe shows the incorrect actual value when the value contains JSON strings ending with Complete minimal example reproducing the issue csharp string expect a b string actual a b actualShouldBeexpect Expected behavior FluentAssertionsExecutionAssertionFailedException Expected actual to be ab with a length of but ab has a length of differs near index Actual behavior FluentAssertionsExecutionAssertionFailedException Expected actual to be ab with a length of but ab has a length of differs near index Versions Fluent Assertions Targetting Net Core Fluent Assertions Targetting Net Framework not tried others Description The SatisfyRespectively method is a great way to validate fixed elements in a collection and Ive been using it extensively since it was recently introduced However Ive come across a few cases where I want to perform the checks on all elements on a sequence but I dont care about the order that they are returned as long as they match the exact amount of assertions and only once each Id like to propose the creation of a variation of SatisfyRespectively that ignores the order where the assertions are found in the collection but otherwise work similarly Example csharp Arrange var numbers new Assert numbersShouldSatisfyDistinctly n nShouldBe n nShouldBe I used the name SatisfyDistinctly here as Distinctly was the first logical antonym of Respectively that I found but any fitting name would suffice Description The IAsyncEnumerableT type was introduced in C to allow for async streams of data basically iterator blocks that can await for inner tasks to produce values and can be iterated over using the new await foreach construct Currently FA doesnt provide any support for this generalpurpose iterator type forcing people to create their own or materialize the async stream into a standard collection using SystemLinqAsyncs ToListAsync for example Right after starting to use C more weve already identified several realworld usecases for IAsyncEnumerable and have been struggling to do assertions on them using FA It would be great if most if not all collectionbased assertions were also available for IAsyncEnumerable Versions Missing on the most recent version BeEquivalentTo fails if an internal property has a different value The documentation section Including properties andor fields states Barring other configuration Fluent Assertions will include all public properties and fields However it also seems to take into account all internal properties and fields Who is wrong The documentation or the implementation What is BeEquivalentTo supposed to do In the following code sample PrivateMembersShouldNotBeCompared succeeds but InternalMembersShouldNotBeCompared fails on the compare of property InternalProperty C using FluentAssertions using MicrosoftVisualStudioTestToolsUnitTesting namespace UnitTestProject TestClass public class TestBeEquivalentTo class TestSubject private string PrivateProperty get internal string InternalProperty get public string PublicProperty get public TestSubjectstring privateString string internalString string publicString PrivateProperty privateString InternalProperty internalString PublicProperty publicString TestMethod public void PrivateMembersShouldNotBeCompared TestSubject first new TestSubjectA A A TestSubject second new TestSubjectB A A firstShouldBeEquivalentTosecond TestMethod public void InternalMembersShouldNotBeCompared TestSubject first new TestSubjectA A A TestSubject second new TestSubjectB B A firstShouldBeEquivalentTosecond 