See useRx and useRxTap here ts import useEffect useState from react import Observable Subscription from rxjs import tap from rxjsoperators Reactive Hook that returns a tuple of resolved value and error param ObservableT observable param T defaultValue export function useRxT observable ObservableT defaultValue T T T any const x setX useStatedefaultValue const error setError useState let subscription Subscription useEffect if subscription subscription observablesubscribesetX setError return subscriptionunsubscribe observable return x error Reactive Hook that triggers callbacks on observable updates param ObservableT observable param T defaultValue export function useRxTapT observable ObservableT next x T void error e any void complete void void let subscription Subscription useEffect if subscription subscription observablepipetapnext error completesubscribe return subscriptionunsubscribe observable Example usage ts export default function History last const items error useRxlast return ul itemsmapitem li keyitemiditemidli ul Also related to When passing in many inputs its awkward to remember the indexes inside the input tuple when youre trying to readdestructure a specific input eg ts useObservable input const dispatch inputpipe mapinput input distinctUntilChanged propsshouldDisableInfiniteScroll propsisDoneFetching propsfetchDataParams propsfetchDataAndBuildActions propsdispatch propshistory If the inputs were represented as an object instead they would be much easier to destructure ts useObservable input const dispatch inputpipe map dispatch dispatch distinctUntilChanged pick props shouldDisableInfiniteScroll isDoneFetching fetchDataParams fetchDataAndBuildActions dispatch history Sometimes we want to use an observable not to create state but rather just to perform side effects This is possible using useObservable ts import React from react import EMPTY from rxjs import useObservable from rxjshooks import map mergeMapTo tap from rxjsoperators declare const sideEffect number number void const MyComponent ReactFC foo number props useObservable input inputpipe map foo foo tapsideEffect mergeMapToEMPTY propsfoo propsfoo return divHello Worlddiv but its a bit awkward for a few reasons We are forced to return an Observable of a certain type State when the type doesnt matter to us since the result is not being used outside of the hook We need to do mergeMapToEMPTY at the end of the chain to satisfy the return type We are forced to provide an initial state but again we are not using State here What do you think about another hook which is specifically designed for this use case to avoid the problems above ts useObservableSideEffect input inputpipe map foo foo tapsideEffect propsfoo Im sure we can find a better name Opening mainly to see if this is a good idea or now Happy to clean up the APIexamples if it is Basically I needed a way to restart the observable on dependency changes Ive added another argument to userObservable which allows you to set the dependencies of useEffect Let me know what you think tsx import React from react import ReactDOM from reactdom import useObservable from rxjshooks import from from rxjs import map take from rxjsoperators function Appprops foo number const value useObservable from pipe mapval val propsfoo propsfoo return render four times h valueh ReactDOMrenderApp foo documentquerySelectorapp ReactDOMrenderApp foo documentquerySelectorapp useObservable is never use in useEffect but i wanna calc the dom size without some event Hi thank you for the inspiration and make this awesome libs I have the following RFC proposed Suggestion Remove the overlapping of state management in useEventCallback as we have useObservable useState and useReducer already making this hook just purely for the async event management This hook is best to be treated as an adaptor to convert DOMEvent to DOMEvent stream Why After using it for a while I always think useEventCallback is not so intuitive to use It accepts up to arguments callback initialState and inputs Why we need this initialState if we want to introduce prop dependencies At the current implementation what this hook would returns is not just a memorized event handler as a callback but a tuple of handler the observed state which makes me feel this hook is doing too much IMHO Ideally what I have in mind is to have a similar interface as in the the native useCallback But what can make this hook so useful is to convert the event object to an observable Then we can manage DOMEvent as a stream easily If we need to performance side effects like to update state we should use tap operator instead For example js const deps some dependencies could be state or props const state setState useState const onClick useEventCallback event deps eventpipe filtere etype click map target targetvalue tapv setStatev rerender explicitly requested by the user withLatestFromdeps do something with dependencies deps optional The deps would be any props or local state dependencies that is reactively emitted and passed as the second props to the callback And we can think this like an epic in reduxobservable This way we decouple the state management part out of this hook And this hook is never going to trigger rerender by itself it will have to be introduced by the user Implementation Here is the suggested implementation ts const createEvent T return new SubjectT const createDeps D extends unknown deps D return depslength new BehaviorSubjectdeps undefined export const useEventCallback E any D extends unknown never callback event ObservableE deps ObservableD Observableunknown deps D as never const event useMemo createEventE const deps useMemo createDepsDdeps useEffect const subscriber callbackevent deps as ObservableDsubscribe return subscriberunsubscribe eventcomplete if deps depscomplete useEffect if deps depsnextdeps deps return useCallbacke E eventnexte And perhaps it should be called as useEventCallback to make it more obvious what this hook is doing Hi thank you for creating this amazing library Ive noticed there are some performance improvements can be done by using useMemo in useEventCallback hook The change basically leverage the lazy evaluations and reduce new object creations at runtime Thank you I was trying write something like typescript const callback flag useEventCallback ReactMouseEventHTMLElement boolean boolean events eventspipemapTofalse false callbacktrue And there was type error Argument of type true is not assignable to parameter of type false true MouseEventHTMLElement MouseEvent Type true is not assignable to type falsets Checking the source It seems like for example typescript type Callback VoidableEventCallbackstring boolean will be resolved as typescript type Callback e string void e false void e true void which means e has to be string boolean Is this a bug or am I missing something here Currently Subject state and input are always created How about checking the length of the callback argument and only create the Subjects that are used by the callback One caveat of this approach is the length check does not recognize spread arguments and the use of arguments object But I think it is rare to use callback this way