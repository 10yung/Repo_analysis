Hi I want to implement a native asyncawait API for this crate Since I am not the most experienced rust programmer Im not sure about how to go about it Obviously one could just upgrade to the new tokio version and go with it Because I am contemplating if I should switch my project form tokio to asyncstd Im wondering if an executor agnostic solution if possible should be preferred for this crate Ill do some more digging on this topic but I wanted to leave this issue in case somebody else with more knowledge than me comes by and contributes to this discussion and wants to collaborate Best regards I was trying to use this library without all the tokio stuff and wished there was a mio example I shared back this example although its not fancy and doesnt take args Plus there is something funny happening where the first event is nonsense The PinPoller interface appears to only support edgetriggered interrupts Are there any plans to support leveltriggering Its the same code but without hardcoding the EPOLLET flag Not really blaming this crate but elaborating on pin numbering might be useful to the documentation reader I connected physical pin on my Raspberry Pi and now in hindsight I think that pin really should be accessed via Pin still not sure as SPI CS doesnt work as expected Output of gpio readall Pi BCM wPi Name Mode V Physical V Mode Name wPi BCM v v SDA IN v SCL IN v GPIO IN IN TxD v IN RxD GPIO IN IN GPIO GPIO IN v GPIO IN IN GPIO v OUT GPIO MOSI ALT v MISO ALT IN GPIO SCLK ALT OUT CE v OUT CE SDA IN IN SCL GPIO IN v GPIO IN IN GPIO GPIO IN v GPIO IN IN GPIO GPIO IN IN GPIO v IN GPIO BCM wPi Name Mode V Physical V Mode Name wPi BCM Pi So a clarification on what the Pin number refers to would be nice And it will be removed in See And the new You can also see this talk from the last Embedded Linux Conference Europe posted yesterday by the Linux Foundation Hi many functions eg Pinsetdirection Pinsetvalue Pingetvalue Pinsetedge Pingetpoller take longer than somebody would expect Making them unsuitable for many tasks The reason for the bad performance is that the sysfsgpiofiles directionedge and value are opened on demand and closed afterwards This makes it impossible to read a sensor like the DHT or performing any time critical operation Whereas a CCPython application would be able to do so Code example rust let pin Pinnew pinsetdirectionDirectionOut pinsetvalue pinsetdirectionDirectionIn pinsetedgeEdgeBothEdges let mut poller pingetpollerunwrap At this point I already have lost parts of the sensor reply if I use pingetvalue I only receive of the desired values At the moment I dont see any way to fix this issue without breaking the API Any suggestions Best regards Bernd I believe itd be more logical to take mutable reference to pins I know that memory itself doesnt change however there are good reasons to require mutability anyway Accessing the pin from multiple threads probably isnt what people want to do by accident They still can do it on purpose Requiring mutable reference allows people to write mocks and simulate the pins in tests Its more natural to use mutable references when you change something It clearly shows that some state is being mutated What do you think Hello Ive a problem in Heimdall When I first run it I get permission denied but second time it works I guess this is because export doesnt show up in sys immediately I tried to unexport instead of rebooting and it panics too Did you encounter this problem too Is there any plan to fix it Similar libraries for GPIO support in other languages Python RPiGPIO WiringPi etc provide a background thread for interrupt detection and callback attaching For example in python RPiGPIO runs a second thread for callback functions This means that callback functions can be run at the same time as your main program in immediate response to an edge For example def mycallbackchannel printThis is a edge event callback function printEdge detected on channel schannel printThis is run in a different thread to your main program GPIOaddeventdetectchannel GPIORISING callbackmycallback add rising edge detection I know this is difficult to do in Rust with all the safety ownership and the like but that will be great to have I believe it would be beneficial to add support for mio poll multiple FDs This should be possible with conditional compilation