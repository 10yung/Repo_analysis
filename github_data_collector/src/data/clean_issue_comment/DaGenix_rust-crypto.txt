 Some old versions of rustcrypto have dependencies specified with version requirement rand rustcserialize libc gcc etc Crates with such vague dependency versions became unusable because allows picking toonew semverincompatible dependencies It also breaks Cargos minimalversions feature because requirement allows picking very very old dependencies that arent compatible with Rust Because these old versions of rustcrypto are unusable and cause problems for Cargo I suggest yanking them bash cargo yank vers cargo yank vers Is there a way to use pbkdf and get progress updates while it is deriving the key If not do you know of a nice way to write such a function I guess this is quite a generic question regarding functions that take a lot of time in environment where there is only thread pandapandavirtualmachinerustwasmhello wasmpack build INFO Checking for the Wasm target INFO Compiling to Wasm Compiling autocfg v Compiling rustcserialize v Compiling wasmbindgenmacrosupport v error E not all trait items implemented missing encode homepandacargoregistrysrcmirrorsustceducn ef e cd fb b rustcserialize srcserializers fn encodeS Encoder self s mut S Result SError encode from trait impl Encodable for pathPath missing encode in implementation error E not all trait items implemented missing decode homepandacargoregistrysrcmirrorsustceducn ef e cd fb b rustcserialize srcserializers fn decodeD Decoderd mut D ResultSelf DError decode from trait impl Decodable for pathPathBuf missing decode in implementation Compiling numtraits v Compiling numinteger v error aborting due to previous errors For more information about this error try rustc explain E error could not compile rustcserialize warning build failed waiting for other jobs to finish error build failed Error Compiling your crate to WebAssembly failed Caused by failed to execute cargo build exited with exit code A quick PR to add some extra high level documentation Dependencies toml rand rustcrypto rustcserialize rust use rand use cryptoaessafeAesSafe Encryptor use cryptosymmetriccipherBlockEncryptor fn encryptkey u input u output mut u let encryptor AesSafe Encryptornewkey encryptorencryptblockinput output fn main let mut key u for v in keyitermut v randrandom let mut output Vecu new encrypt key helloasbytes mut output Output console useruserProjectsrustencryptfile cargo run Compiling encryptfile v homeuserProjectsrustencryptfile Finished dev unoptimized debuginfo targets in s Running targetdebugencryptfile thread main panicked at assertion failed dstlen inputlen homeusercargoregistrysrcgithubcom ecc db ec rustcrypto srccryptoutilrs note run with RUSTBACKTRACE environment variable to display a backtrace Fixes the build problem which arises when the host is windows target is x pcwindowsgnu The problem is fixed by setting the compiler to gcc The crate has been deprecated for quite a while now Time to move on I would like to chain into a SymmetricCipherError and noticed that this trait impl was missing reseed should not be a publicfacing API easy to misuse reseed incorrectly implements SHAd Its missing zero blocks as initial input to the inner invocation of SHA I dont believe this has any real security impact its just noncompliant with the spec Similarly Pool incorrectly implements SHAd in the same way I dont believe this has any impact on the security properties of Fortuna its just nonspec The implementation I have worked on also has this bug FWIW Both FortunaGeneratorreseed and Poolresult must explicitly zero the old hasherselfstate iff selfstate Sha new is a pointerassignment rather than overwriteinplace not sure of Rust semantics but if its like Java or C this is broken reseed and addrandomevent APIs must take mut inputs and cryptoutilzero them immediately after use to prevent leakage of RNG state Im making the assumption that cryptoutilzero cannot be optimized out like explicitbzero in C If that can be optimized out well it needs to be fixed If the SeedableRngfromseed interface requires nonmut seed a mut copy of seed can be made and passed in to reseed Repeating RNG state on fork is a pretty bad failure mode I get that Rust stdlib does not expose fork but your library may be used in programs that invoke fork and ideally your library is defensive against that possibility Im not super familiar with Rust is there any way to detect the compilation environment ie POSIX target platform and register an atfork suicide of some kind zeroing the generator state at a minimum Some platforms support minherit with INHERITZERO to automatically zero out sensitive state on fork although this may be difficult to use in Rust It is needlessly inefficient for generateblocks to recreate a new Aes instance every time it is invoked with the same key AES key scheduling is slow you can instead save the key state in the Fortuna object Additionally care must be taken to explicitly zero Encryptor state when it is no longer used maybe there is a destructor which does this I did not look Similarly in generaterandomdata depending on Rusts semantics here not sure if selfkey newkey is a pointer or array copy one of newkey or the previous key array must be explicitly zeroed The assertion in generaterandomdata is incorrect in excluding rem bytes of outlen Just use outlen directly Fortunalastreseedtime being a floating point number is kind of odd and unsuitable for embedded systems use Not a bug per se just a weird design choice The second assertion in fillbytes is redundant or should be a compile time assertion Stylistic in fillbytes the in let mut hash NUMPOOLS and subsequent computations should be length sizeofu sha STATELEN although ideally the constant would be exported from the sha module with a clearer name like SHA DIGESTLENGTH No functional difference nextu should explicitly zero ret to avoid leaking a generated value I read the below example can you show how to use other algorithms usage as simple example thanks rust fn main let message Hello World let mut key u let mut iv u In a real program the key and iv may be determined using some other mechanism If a password is to be used as a key an algorithm like PBKDF Bcrypt or Scrypt all supported by RustCrypto would be a good choice to derive a password For the purposes of this example the key and iv are just random values let mut rng OsRngnewokunwrap rngfillbytes mut key rngfillbytes mut iv let encrypteddata encryptmessageasbytes key ivokunwrap let decrypteddata decrypt encrypteddata key ivokunwrap assertmessageasbytes decrypteddata 