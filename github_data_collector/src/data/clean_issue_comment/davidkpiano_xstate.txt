Description xstatereact typescript state is always never after calling matches twice in the same expression js function App const state useMachinetoggleMachine if statematchesa statematchesb is of type never consolelogdo a thing doesnt work like this either if statematchesa else if statematchesb Is this an antipattern or am I doing something wrong Sadly I dont have enough typescript experience at the moment to understand the following code in detail Expected Result I should be able to check if a state is either one of a state Actual Result I cant check if a type is one of either states Reproduction Simple Reproduction Additional context xstatereact xstate Description I have two machines a parent machine and a child machine The parent machine invokes the child machine on start and the child machine keeps running indefinitely between three states How can I print out the child machine s current value using react Expected Result I expect to be able to subscribe to invoked child machines state transitions somehow so that I can update my react ui with the information Actual Result Accessing the child machine does not return the invoked instance nor an interpreter but instead some metadata Reproduction See a full sample here notice how the child machine state is rendered NA even though the invoked child machine is running see console output CodeSandbox Reproducible Example Additional context Ive extracted this issue from a comment on As far as I can tell may or may not be related issues This is the packagejson versions json typesjest typesnode typesreact typesreactdom xstatereact rc react reactdom reactscripts typescript xstate Im looking into the new Typestates functionality in and Im a bit confused about the distinction between createMachine and Machine It looks like you have to use createMachine to use Typestates as there is no generic for them with Machine But createMachine is missing the generic for the state schema which is something I find helpful It doesnt look like this is an oversight does that mean representing your schema as a type is no longer considered good practice Is there an alternative that makes it unnecessary to use with createMachine Please treat the serialized format as a part of your public API This is more of a pleaheadsupfeature request I just got bitten by an XState machine format change from back in August Im persisting XState x machines in PouchDB This change introduced in XState adds an event property to the state object Use SCXMLEvent wherever possible This caused two issues upon trying to update XState Unfortunately for me PouchDB forbids the storing of objects under a key a leading underscore ie event is an invalid toplevel key so new machines created with the latest version of XState simply wouldnt persist to the db I dont expect XState to change format because of a restriction like this in PouchDB however I do feel like this should not have happened without a major version bump Secondly the new version of XState would crash with Cannot read property data of undefined when trying to deserialize state saved from the old version because this new event property is missing Request Ideally Breaking changes to the serialized format should be done across a major semver version bumps XState should give some consideration explicit testing to identify issues with backwardsforwards compatibility of the serialized format XState could support running something akin to db migrations when the serialized format changes I think this would be appropriate given that serialization and deserialization is stated as one of the key goals My hacky workaround is to wrap all reads and writes to the db with custom serializedeserialize to rename the keys and add the event property by calling toSCXMLEvent on the event property This is inconvenient and a bit haphazard because I need to wrap every location that reads from the db but it seems to work Included my workaround code below in case someone else experiences this issue JS import mapKeys from lodashmapKeys import toSCXMLEvent from xstatelibutils export function serialize state const s JSONparseJSONstringifystate ensures no magic objects return mapKeyss value key swap keys with leading to leading if key return keyslice return key export function deserialize s const r mapKeyss value key if key swap keys with leading to leading reverse of serialise return keyslice return key add missing event if not there if revent revent revent toSCXMLEventrevent return r Bug or feature request Feature request query Description I have a piece of UI that Id like to display when one of multiple states is true At the moment Im writing code like this jsx const displayCustomerBalance currentmatchescustomerdeposit currentmatchescustomerwithdrawal This is okay but gets a bit cumbersome when you add more states It would be nice to be able to write something more like jsx const displayCustomerBalance currentmatches customerdeposit customerwithdrawal It might be that you can actually do something like this and Ive missed or misunderstood something If so sorry Feature Potential implementation I think adding an overload for Statematches with a signature like this would work where TSV is a union of the possible value types instead of a single value type tsx matchesTSVparentStateValues TSV this is TState extends value TSV StateTState context TEvent TStateSchema TState never It would call utilstsmatchesState for each of the state values passed in and return true if any of them were true Description When I try to useService Im finding that the current state isnt being returned correctly Expected Result The state should be available for use on first render of the component Actual Result The state is undefined Reproduction Additional context On my local machine Im on the latest xstatereact The code installed in node modules is clearly only setting current to servicestate and not servicestate serviceinitialState function useServiceservice var a readreact useStateservicestate current a setCurrent a react useEffectfunction Set to current service state as there is a possibility of a transition occurring between the initial useState initialization and useEffect commit setCurrentservicestate var listener function state if statechanged setCurrentstate var sub servicesubscribelistener return function subunsubscribe service return current servicesend service This PR was opened by the Changesets release GitHub action When youre ready to do a release you can merge this and the packages will be published to npm automatically If youre not ready to do a release yet thats fine whenever you add more changesets to master this PR will be updated Releases xstatefsm Minor Changes c A config property got exposed on created machines Its the same object which got passed in as argument Patch Changes a Fixed entry actions defined on an initial state not being executed xstate Patch Changes c db The escalate action can now take in an expression which will be evaluated against the context event and meta to return the error data a fea The typings for the raise action have been fixed to allow any event to be raised This typed behavior will be refined in version to limit raised events to those that the machine accepts xstatereact Patch Changes Updated dependencies a Updated dependencies c db Updated dependencies a fea Updated dependencies c xstatefsm xstate All notable changes to this project will be documented in this file xstatevue Patch Changes Updated dependencies a Updated dependencies c db Updated dependencies a fea Updated dependencies c xstatefsm xstate The original documented way to increment the simulated clock would not work in TypeScript because serviceclock is of type Clock while only SimulatedClock has an increment method At first I thought Id just use a type assertion like serviceclock as SimulatedClockincrement and that may be good enough for the example I dont like unnecessary type assertions so this PR proposes to keep the SimulatedClock instance in a local variable and increment that instead As I said this is just a suggestion What do you think This feature is a quick win that allows developers to define context partially for states and transitions in the same way that they would with the assign action creator This is equivalent to the same assign action as the first action Statelevel context diff context count message hello states foo entry assign count context count bar entry assign count ctx ctxcount context count ctx ctxcount baz entry assignctx ctx count context ctx ctx count Transitionlevel context diff same assignlike behavior as above context count message hello on SOMEEVENT actions assign count ctx ctxcount context count ctx ctxcount This has a few advantages No need to import assign action creator for most usecases its built into context Still need it for exit actions assign is not removed and will still work the same Less verbose plain JS Less painful typing TypeScript since the types dont need to be inferred from the assignTC TE action creator and instead are explicit on the context properties This solves a huge pain point Not a breaking change and still compatible with SCXML since the context is translated to assign actions x Statelevel context x Transitionlevel context x Tests x Docs x Changelog 