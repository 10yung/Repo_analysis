Does anyone have a or know of a concrete example of php code that would reflect Clean Architecture page figure I simply can wrap my head around it the attached code represents examples of what I have written so far but I know this will not work for anything but a SQL database In my example My use case is simple I am trying to have a use log into the system Please ignore my namespace names as I am trying to rework my code from a homemade MVC framework Finally the view component was not included because it is trivial it send a json string Thanks ken Login Codezip Avoid typechecking doesnt address a realistic situation in which one might do type checking If type declaration can be used thats great but often its not the case One major issue that PHP doesnt support union or intersection types php param Traversable Countable iterator return Generator function iteratorchop Traversable iterator Generator piles countiterator Might not be countable Again in the second example php param intfloat val param intfloat val return intfloat function combineval val return val val Are these numbers In the second case its likely for the code to work without an error as first but result in an unexpected error or event worst an unexpected result later No type checking goes against the Fail fast principle which prevents you having to chase bugs through the code While static code analysis does a good job it doesnt capture all issues The argument about it being to verbose isnt that strong as you have many solutions to write it as one line For instance with beberleiassert Could you explain please why you suggest class as a alternative of function in this case Why classes whouldnt conflict between each other like functions in that example And why namespaces and naming convenction wouldnt resolve this sort of issue I guess such kind of a solution would work fine as well use function App Helpers config as myConfig just for instance use function Path To Imported Package config app new Application appsetConfigmyConfig appsetConfigconfig In ISP there are severe design flaws which clearly indicate you have no experience with goverment employees php class Human implements Employee public function work void working instance would likely throw UnknownOperationException public function eat void eating in lunch break entire working hours ISA lunch break it may or may not have anything to do with eating Also in Good Not every worker is an employee but every employee is a worker Again you have not met goverment employees All this makes it confusing to grasp the concept for some instances wink You could really add a good multiinheritance or composition example by mentioning threads Although they may force a developer to jump into polimorphic tables they are a great way to handle this I cant find an example of use of trait anywhere on your cleancodephp guide Balance as a noun is the name of the number representing the amount of money in your account You cannot withdraw or deposit the actual number You can however withdraw money deposit money increase balance by depositing money decrease balance by withdrawing money Id just call the two functions withdraw and deposit Theyre not ambiguous as theres only one thing you can withdrawdeposit money In the comment for Liskov Substitution Principle bad example function renderLargeRectanglesRectangle rectangles void foreach rectangles as rectangle rectanglesetWidth rectanglesetHeight area rectanglegetArea BAD Will return for Square Should be rectanglerenderarea rectangles new Rectangle new Rectangle new Square renderLargeRectanglesrectangles For a square the math is right as getArea should return not I understand that it implies for x but this is only for not square and Square is explicitely used The example and comment Should be are confusing Edit Additionnaly if the heightwidthlength are in constructor as seen in and not defined in a function You then have function renderLargeRectanglesRectangle rectangles void foreach rectangles as rectangle area rectanglegetArea GOOD Will return for Square rectanglerenderarea rectangles new Rectangle new Rectangle new Square renderLargeRectanglesrectangles And the example becomes correct but Im being fussy Maybe we should use spoilers for examples This is just an idea Avoid conditionals This seems like an impossible task Upon first hearing this most people say how am I supposed to do anything without an if statement The answer is that you can use polymorphism to achieve the same task in many cases The second question is usually well thats great but why would I want to do that The answer is a previous clean code concept we learned a function should only do one thing When you have classes and functions that have if statements you are telling your user that your function does more than one thing Remember just do one thing details summaryBadsummary php class Airplane public function getCruisingAltitude switch thistype case return thisgetMaxAltitude thisgetPassengerCount case Air Force One return thisgetMaxAltitude case Cessna return thisgetMaxAltitude thisgetFuelExpenditure details details summaryGoodsummary php interface Airplane public function getCruisingAltitude class Boeing implements Airplane public function getCruisingAltitude return thisgetMaxAltitude thisgetPassengerCount class AirForceOne implements Airplane public function getCruisingAltitude return thisgetMaxAltitude class Cessna implements Airplane public function getCruisingAltitude return thisgetMaxAltitude thisgetFuelExpenditure details I offer this only because the document is very large There is another solution Move sections to separate files READMEmd variables usemeaningfulandpronounceablevariablenamesmd usethesamevocabularyforthesametypeofvariablemd usedefaultargumentsinsteadofshortcircuitingorconditionalsmd solid srpmd ocpmd lspmd ispmd dipmd drymd translationsmd This will make it possible to use a more detailed description for each example Yet again Its just an idea This doesnt provide any useful explanation when and why to use public private and protected access modifiers Consider adding explanation that public methods and properties are most dangerous for changes because some outside code may easily rely on them and you cant control what code relies on them Modifications in class are dangerous for all users of class protected methods are as dangerous as public because they are available in scope of any child class This effectively means that difference between public and protected is only in access mechanism but encapsulation guarantee remains the same Modifications in class are dangerous for all descendant classes private methods are your safe harbor in this doubtful world They guarantee you that code in your methods is dangerous to modify only in boundaries of single class which means that when you have tests for your protectedpublic methods that cover all calls of your private method and as long as you dont do magic like side effects or usage of global state you are safe for modifications and you wont have Jenga effect Therefore use private by default and publicprotected when you need to provide access for external classes There is also one modern trend that I discovered People who practice TDD and cover LOC with tests usually end up with almost private methods because private methods are hard to test Encapsulation is then usually guaranteed by usage of shim classes This leads to good thing implementation can be replaced with more performantmaintainableflexiblebetter class easier but this also leads to bad thing people try to create very thin layers of functionality like classes of LOC which perform single for loop or single call to real class with usually bad names and too thin focus Stop freaking doing it Hide your implementation behind private method first and if it has grown too much eg dependencies for containing class become messy because of that single method or require more flexibility or you start seeing that it is starting to have different focus than original class then extract it to separate class YAGNI and KISS for all Cheers I think your refactoring results in two helperclasses Lexer and Tokenizer These types of classes should not be mocked nor handled by the diframework Uncle Bob suggests to Mock across architecturally significant boundaries but not within those boundaries 