I wanted to use CanvasRenderingContext DgetTransform but noticed that its currently missing Describe the Bug A clear and concise description of what the bug is Following the example in the wasmbindgen referencedocs when I compile part of the example code it throws a compilation error Steps to Reproduce Copy the sample code Compile using wasmpack Check JavaScript console to see error If applicable add a link to a test case as a zip file or link to a repository we can clone Expected Behavior It should print the current time in milliseconds Actual Behavior Failed to compile srcbuildindexjs Line globalThis is not defined noundef Line Unexpected use of self norestrictedglobals If applicable add screenshots to help explain your problem Additional Context I am using this with React and while this changes nothing its just noteworthy Here is the copied code rust wasmbindgenstart pub fn runperf let window websyswindowexpectshould have a window in this context let performance window performance expectperformance should be available consolelogthe current time in ms is performancenow and Cargotoml toml dependencies wasmbindgen image version humantime dependencieswebsys version features Window Performance PerformanceTiming console If theres something I am not doing right Id appreciate some help Given code that looks like this rust use wasmbindgenprelude wasmbindgen pub fn barval JsValue Resultu JsValue foo mut Errval inlinenever pub fn fooa mut u a we can build and run it with wasmpack build target nodejs and run it with js const bar requirepkgwasmreprojs const err new Error for let j j j try barerr catch e if e err continue consolelogiteration j throw e to yield iteration homealexcodewasmmemorytestindexjs throw e RuntimeError memory access out of bounds at bar wasmfunction x at moduleexportsbar homealexcodewasmmemorytestpkgwasmreprojs at Objectanonymous homealexcodewasmmemorytestindexjs at Modulecompile internalmodulescjsloaderjs at ObjectModuleextensionsjs internalmodulescjsloaderjs at Moduleload internalmodulescjsloaderjs at FunctionModuleload internalmodulescjsloaderjs at FunctionModulerunMain internalmodulescjsloaderjs at internalmainrunmainmodulejs The problem here is apparent when we diassemble the wasm output wat module type func param i type func param i i import wasmreprojs wbindgenrethrow func wbindgenrethrow type func bar type param i i local i globalget i const i sub localtee globalset localget i const i store offset localget i const i store localget call wasmreprofooh ba f de e c localget call wasmbindgenthrowvalh d fc bf b unreachable func wasmreprofooh ba f de e c type param i localget i const i store offset localget i const i store func wasmbindgenthrowvalh d fc bf b type param i localget call wbindgenrethrow unreachable memory global mut i i const export memory memory export bar func bar data i const Here the problem we can see is that the export and function bar allocate bytes of stack space but this stack space is never released This means that our global stack pointer is constantly decreasing and will never get bumped back up The tldr is that every time an error is thrownreturn from a Rustwasm function it runs the risk of not reclaiming used stack space and this is clearly a bug we need to fix im passing ArrayBuffer from browser window to worker thread and then to wasm module function compiled with rust and wasmpack but rust always receives buffer of zero length rust function rust wasmbindgen pub fn processarraybufferbuffer u i bufferlen as i generated glue js js function passArray ToWasm arg malloc const ptr mallocarglength getUint Memory setarg ptr WASMVECTORLEN arglength return ptr param Uint Array buffer returns number export function processarraybufferbuffer var ptr passArray ToWasm buffer wasmwbindgenmalloc var len WASMVECTORLEN var ret wasmprocessarraybufferptr len return ret workerjs js if edata instanceof ArrayBuffer const res wasmprocessarraybufferedata consolelogworker res res returns so glue js expects typed array Uint Array but im passing ArrayBuffer which doesnt have length prop but byteLength etc im working with ArrayBuffer because its Transferable and Uint Array is not as a workaround i can receive ArrayBuffer in worker wrap it into Uint Array there and pass to wasm but i believe glue js can check type of argument with instanceof ArrayBuffer and pass it to wasm memory correctly The generated functions are not specialized for all possible variants There is function teximage dwithi andi andi andformatandtypeandoptu array but there are not functions for other array types sure we can do it via the JsObject casting According to MDN docs we can provide much more specialized types here This PR adds support for using wasmbindgencli for Electron apps through the addition of two flags omitimports and preloads See for context the Alternatives section at the end of the OP alexcrichton I think this is a better approach since it doesnt require adding a new target Ive also cleaned up the implementation and included your feedback from the original PR If you think this looks good we could go with this PR and Ill close the old one Im also open to renaming the flags or modifying the documentation if you have thoughts about that Motivation Web IDL now allows to define constructors in such way webidl interface InterfaceWithConstructor Throws constructorlong a spec from geckodev rustwasmweedle is already updated but not released Major difference is that new constructors may or may not be marked as Throws Atm all constructors return ResultSelf JsValue doc Proposed Solution Binding generator should support new constructors and all websyss WebIDLs should be updated And that is going to be a big BCbreak Alternatives Keep backward compatibility with constructors defined as attributes thus not changing any WebIDLs That would not break BC and allow adding new WebIDLs But it seems to me that is not spec compliant that every websyss interface constructor can throw since specs explicitly specify whether constructor can throw and now it is represented in WebIDLs I hope there is a macro that converts currently unsupported types automatically to JsValue For example the following rust wasmbindgenserde pub fn fooarg bool arg Vecusize should be equivalent to rust wasmbindgen pub fn fooarg bool arg JsValue Result serdejsonError let arg Vecusize JsValueintoserdearg This is intended to be a tracking issue to pull together a number of requests from a few different locations The basic problem is that browsers will ship features before fully stabilized Often these features are behind flags or some other gating mechanism but once the gates are all unlocked some pages are able to use these features and Rustwasm often want to use the features as well Currently we are not adding these unstable WebIDL definitions to websys because they are almost guaranteed to change This means that wed have to ship breaking changes which we would prefer not to do We do however want to make it easier to consume these WebIDL files Split across a number of PRs theres two possible solutions I think we have right now for supporting this First we can use cfg flags to support everything in websys itself The general idea is that websys would grow all the unstable WebIDL files but youd have to compile with RUSTFLAGScfgwebsysunstable to actually get anything to show up This sort of explicit opt in would be required by everyone building a crate The pro of this approach is that it centralizes all the WebIDL into this repository taking the maintenance burden away from users The cons of this approach is that its difficult to build for users and it puts more maintenance burden ehre An alternative to putting these WebIDL annotations in websys itself would be to encourage users to publish their own crates synthesized from WebIDL The general idea here is that this repository would publish a stable crate or tool which can be used to synthesize a crate from WebIDL That way users could publish their own webxrsys for example and it would not be maintained in this repository Once the specification stabilizes wed move the WebIDL into websys itself The pro of this approach is that it doesnt have much maintenance burden on us in this repository It also allows anyone to build their own crate with raw WebIDL in the same manner websys is built This approach is also pretty easy for users to consume theyd basically just depend on a crate The cons of this approach are pretty bad though This involves a relatively significant amount of infrastructure which doesnt exists so would be difficult to start out For example these new crates probably want to depend on websys for basic types to start which websys itself doesnt do at all crosscrate dependencies Additionally it puts the maintenance burden on users Im still somewhat tempted to go with myself but weve had enough proposals running around here for awhile that I wanted to get this all written down myself