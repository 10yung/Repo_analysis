The work I am doing for my project deals with decompressing a file like MB to a MB stream and then running those streams through some patch program which in turn may output a MB stream that is then fed once again into a patch program many times In this instance it means I am using like or MB streams with a few seconds Ive found this library significantly reduces memory usage but I cant really figure out what the options do the only documentation specified is a blog post but it doesnt really explain what any of the options actually do I dont deal with a lot of memoryrelated things I have also found that the memory allocated for the pools doesnt seem to be returned or returnable unless Im missing something Eg the app seems to allocate about MB of data on top of idle but after it ends the app still sits at MB used I understand you want to keep these pools around and allocated but is there a way to get rid of them I only use them for a certain task so once that task has finished keeping it around is not beneficial But the documentation has nothing that even looks at this kind of scenario The lack of intellisense makes using this library extremely difficult as I have almost no idea what some of the options do After spending some time reading the code it appears default behavior is to pool everything with no upper limit I wasnt able to find that information in the documentation Can you check my understanding MaximumFreeLargePoolBytes is never set so the buffer gets added to the pool on dispose here The max potential memory usage of the large pool is maximumBufferSizelargeBufferMultiple MaximumFreeLargePoolBytes or stated another way the number of pools MaximumFreeLargePoolBytes If I dont call GetBuffer and I dont call GetStreamasContiguousBuffertrue I will only ever use small blocks So if you rarely call GetBuffer a valid sizing strategy would be to create mediumsized small blocks say of the size of your expected common stream size a large MaximumFreeSmallPoolBytes and a MaximumFreeLargePoolBytes size of byte to force unpooled large buffer allocation in the rare case you need it if it was set to large buffers would be pooled and retained indefinitely This replaces the implementation of the WriteByte method with a manual implementation that doesnt forward calls to Writebyte via a byte field Optimization was identified in issue Benchmark Writing MB using WriteByte via BenchmarkNET using x only Method Job Runtime Toolchain Mean Error StdDev WriteByteNew Net Clr CsProjnet ms ms ms WriteByteOld Net Clr CsProjnet ms ms ms WriteByteNew NetCore Core NET Core ms ms ms WriteByteOld NetCore Core NET Core ms ms ms WriteByteNew NetCore Core NET Core ms ms ms WriteByteOld NetCore Core NET Core ms ms ms BenchmarkDotNetv OSWindows Redstone Fall Creators Update Intel Core i K CPU GHz Skylake CPU logical cores and physical cores Frequency Hz Resolution ns TimerTSC NET Core SDK preview Host NET Core Framework bit RyuJIT Net NET Framework CLR bit RyuJITv NetCore NET Core Framework bit RyuJIT NetCore NET Core Framework bit RyuJIT JitRyuJit PlatformX Issue Hi When installing RMS from NuGet in VS the IntelliSense doesnt show the commentsdocumentation I think this is just a case of enabling the XML Documentation file in the Project Settings Cheers Indy