Ive been working with integrating doctrine with zendexpressiveoauth which officially uses this library I have the auth flow pretty much working whereby user has to login and authorise clients scopes if present During the process due to having a large amount of scopes and readability I wanted to drop the imploded scopes column from the oauthaccesstokens table create related scopes table oauthtokenscopes which consisted of tokenidscopeid Theres one function in the AbstractGrant class which is causing me problems doing this private function convertScopesQueryStringToArrayscopes return arrayfilterexplodeselfSCOPEDELIMITERSTRING trimscopes function scope return emptyscope Throws an exception trim expects parameter to be a string object given understandable as I am no longer using imploded string but array from related table I am able to fix and allow scopes in separate table by modifying the above function to private function convertScopesQueryStringToArrayscopes parse as string as usual if isstringscopes return arrayfilterexplodeselfSCOPEDELIMITERSTRING trimscopes function scope return emptyscope parse array scopes arrayjsondecodejsonencodescopes true return arraymaptrim scopes Any chance I could submit a suggestion or PR to allow this functionality Hello Since I needed the device authorization grant for a project Im working on Ive decided to give a shot at implementing it in a presentable way For the most part I copied other grants code where needed and tried to keep the methods and interfaces as similar to whats already implemented as possible The interval checking between requests for an access token is currently not implemented as I think this could be more easily delegated to a framework middleware than implement the logic right inside the package Pairing a user identifier with the device code is left outside the scope of this implementation as well Ive created a laravel passport implementation based off this code that you can find here Lets make this grant happen Something that was confusing to me about this is the AuthCodeGrant only calls validateCredentials for private clients which made it seem like you no longer needed to check if the client was confidential before attempting to verify the secret However the refresh token grant and password grant both are supposed to support public clients according to the OAuth specification and do not check ClientisConfidential before calling validateClient Wouldnt that mean the isConfidential check in the AuthCodeGrant is unnecessary as you will need to check yourself in validateClient in order to support the other grant types Originally posted by mattallan in Most repos return string for their getIdentifier function However the user repo returns mixed This causes confusion as implementers might think that you can return mixed for a client repository but this is not true We either need to move the getIdentifier calls into their own respective repos or force the user interface getIdentifier call to return a string in version Most error cases in AuthCodeGrantvalidateAuthorizationRequest doesnt redirect back to client even when clientid is specified For example when using Authorization code grant and client sends query with responsetypecode clientidexisting redirecturi I would expect that it would get redirected back with error so client would know theyre doing something wrong But for most errors there are no redirects also even with responsetypeinvalid clientidexisting I would want it to be redirected back See The validateClient method is called for public clients when using the refreshtoken and password grant type and the interface allows passing a null secret so its not necessary to skip calling the method for the authorizationcode grant type When I saw that we skipped calling validateSecret for public clients in the auth code grant and that the mustValidateSecret parameter was removed for I assumed that meant validateClient would no longer be called for public clients I later realizedvalidateClient is called for public clients when using the password or refresh token grant If validateClient is called for public clients for the other grant types you will need to do something like return clientisConfidential hashequalsclientgetSecret clientSecret anyway so it doesnt seem necessary to skip calling it here Hopefully by removing the unnecessary check it will be less misleading to other developers and increase the likelihood that they handle public clients appropriately in validateClient The validateClient method also calls validateRedirectUri which emits a CLIENTAUTHENTICATIONFAILED event if validation fails The validateAuthorizationCode also validates the redirect URI but does not emit an event Calling validateClient regardless will ensure the event is consistently fired for invalid redirect URIs just in case someone is relying on it resolves issue As part of the release for version I removed PHPStans strict rules as it required big changes to a lot of signatures I didnt want this to delay the release of v any further so will aim to add this back in at a later version Adding an issue here to track Were using this package via Laravel Passport to build the API for a mobile app Having mobile clients comes with problems surrounding unstable connections In this case the problem seems to be that the client can successfully send a request to the server but cant receive the servers response For most requests and responses this isnt too much of a problem Except when you cant try again This is the case when trying to exchange a refresh token for a new access token a new access token and refresh token are generated and the old tokens are revoked But if the client hasnt been able to receive the new tokens it cant try again As with many apps most of the users of this app are not registered resulting in being locked out if the token exchanges fails What I think should happen is not immediately revoking the old tokens or at least not revoking the refresh token when the refreshtoken grant is called The old tokens should only be revoked when the new one are successfully used for the first time When the client tries again with the old refresh token the new tokens could be returned again or they could be revoked while returning a new and third set of tokens What do you think about this And whats your take on the way to change this behaviour Im very much willing to make a PR but based on your replies I might find a different path if that leads to a better result The JWT library we use now supports clock leeway We should allow implementations to use this feature in an upcoming version of this library