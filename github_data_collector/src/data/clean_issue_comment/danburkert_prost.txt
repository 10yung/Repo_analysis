 shows that the current intree fuzzing based on cargofuzz has some blindspots Investigate adding aflbased fuzzing to the intree test suite Are the custom options supported I tried options and uninterpretedoption without success Thanks Laurent I have a project where we have receive following proto message proto message Request string requestId googleprotobufAny payload The payload field can contain any proto message for example proto package test message Foo string data googleprotobufTimestamp timestamp The request message with something like Foo packed in it as payload can be received as binary or as JSON The JSON format would look as follows requestId message payload type typegoogleapiscomtestFoo data Hello World timestamp T Z To support this the following needed to be added Support packing and unpacking of messages into an Any Support binary serializing and deserializing of an Any Support JSON serialization and deserialization of an Any The changes in this commit add support for the above by using the typetag and mopa crates To support JSON serialization and deserialization a new includeserde property needs to be set in the prostbuild buildrs configuration rust fn main let mut prostbuild prostbuildConfignew prostbuildincludeserde prostbuildcompileprotos srcfrontendproto srcbackendproto src unwrap This will then add the necessary macro properties for prostderive to use to enable Message serialization and deserialization with the serde framework All Message structs can then be packed into an Any type and correctly serialized to JSON Likewise they can also be deserialized again to an Any struct and the original message can be unpacked to either a generic trait object or the concrete struct This pull request does involve a lot of changes and requires two extra crates as a dependency but so far it works well in our project Perhaps it can be useful for others as well As far as I understand Prost does not store any details about the message itself such as the message name that was used to generate it and the package name that was defined in the proto file This information can be useful though For example when packing a message into an Any type the typeurl usually takes the form of typegoogleapiscompackagenamemessagename For example in one of our java projects we have a proto file as follows protobuf syntax proto import googleprotobufanyproto package myproject message ServerRequest string requestId googleprotobufAny payload message Query string key When using the Java Any API when you pack the Query message into an Any it will generate a typeurl as typegoogleapiscommyprojectQuery To support a similar pack API as the Java C and Python implementations have perhaps each Message struct can implement a MessageMeta trait with the following rust pub trait MessageMeta fn name self static str fn packagename self static str The pack and unpack API could then look something as follows rust test fn testwellknowntypesany let msg Foo null prosttypesNullValueNullValueinto timestamp SomeprosttypesTimestamp seconds nanos let any Anypackmsg println any let unpacked anyunpackFoodefaultunwrap println unpacked I got this working in my cloned repo see branch pbany and so far it seems to work ok Downside of course is that each message now implements a trait called MessageMeta but I suppose this can be turned onoff by defining it as a feature I have a message as follows syntax proto import googleprotobufstructproto message SomeMessage googleprotobufValue arbitraryjson In Go you can then stuff arbitrary json data in the arbitraryjson field as follows import githubcomgolangprotobufptypesstruct import githubcomgolangprotobufjsonpb func examplejson string SomeMessage error msg SomeMessageArbitraryJson structpbValue jsm jsonpbMarshaler if err jsmUnmarshaljson msgArbitraryJson err nil return nil err return msg nil copied from here I understand serializing from JSON is not available for Prost but is something similar like stuffing a HashMapString Value into a StructValue possible I took a look at testssrcwellknowntypesrs but got no closer to a possible solution I saw the related item I agree changing the representation or having two is unneeded However I think ergonomics could be dramatically improved by generating implementations like the one in the title Does that make sense to you If I can find the time itd be something Id be happy to contribute if so For now Ive just been writing these by hand For more clarity on what I mean proto message ContainerMsg oneof containerfield A a B b message A message B Would include these generated impls rust impl FromA for containermsgContainerField fn fromx A Self containermsgContainerFieldAx impl FromB for transactionupdateStatus fn fromx B Self containermsgContainerFieldBx Thanks for prost I use it for a lot of projects and it has served us well Recently my company started using denymissingdocs and I am getting the following error warning missing documentation for a method deriveClone PartialEq prostOneof How can I add a docstring for prostOneof It is not a matter of it being documented in the prost crate itself as denying missing docs ignores docs outside of my project so there must be a way for me to document it within my project right Or if not perhaps there should be Thanks Is it possible to define a fn descriptor self MessageDescriptor function in trait Message in order to get Message name Reference This hopefully resolves This is my first time looking through the prost source so its entirely possible I didnt understand something review with the assumption that Im missing the obvious Trying the example from with denymissingdocs on has some issues The comment for the Shirt message doesnt get applied to the generated shirt module The prostMessage proc macro seems to generate at least one method and that method doesnt have a doc string Ideally Id rather not make an allowmissingdocs exception because I like the idea of forcing my users to document their messages Would you be open to a PR that fixes these things