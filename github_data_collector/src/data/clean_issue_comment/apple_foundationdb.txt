This PR fixes by updating documentation about separate Python bindings installation on Linux systems setretrylimit doesnt work at the database level settransactionretrylimit should be used instead To better utilize resource on each restore process and avoid stalling on a particular step we should pipeline the processing of version batches Format makos code This will mess up gitblame but thats a problem well have to accept merge priority did not need to be raised because we no longer merge shards until they are untrackable maxcommitupdates was too large and could cause proxies to run out of memory When mako is configured to get keys it is only able to get keys that it created with the build command and is not capable of getting keys it inserted with random names as it does when instructed with x g ui Thus gets and updates affect only a certain portion of keys which is undesirable for benchmarking purposes This issue can be closed when makos access pattern is uniformly random across the set of keys in fdb not just those inserted with the build command Proposed Solution Mako should insert keys with a deterministic naming scheme something simple like makoiXXXXXX where X is a number starting at and incremented to the current number of inserts This number can be hashed to ensure the key names are not sequential Then mako can easily access random keys within this range and the range it inserted in the build phase We werent using a retry loop so in the rare cases where we got errors in this transaction the test would fail The data distribution queue currently only keeps queues for the source servers of a relocation This can lead to data distribution issuing a lot of lot of concurrent relocations that all go to the same destination In this scenario those relocations will be queued on the storage server before getting fetched This may take a really long time and during this interval mutations for this range are being written to both the source and the destination It is also possible that we could have made a better decision on where to relocation the shard if we waited to start the relocation If the read version of a transaction is known when the versionstamped operation is performed then the read version can be used as a safe lowerbound of what commit version will be filled into the versionstamped key See for far more contextinformation PR used for the build Will delete later