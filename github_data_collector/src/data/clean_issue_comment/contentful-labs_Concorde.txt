 I want to develop the component in JavaBut I cant find detailed description of ProgressiveJpeg format when searching on GooglePlease guide me where I can get detailed information about ProgressiveJpeg The title of this github repository is Download and decode progressive JPEGs on iOS But it doesnt do the very thing that Progressive JPEG was invented to do Progressively download and decode JPEGs on iOS It misuses NSURLSession to grab ALL the data a process that takes of the total time then decodes it Please rewrite to use NSURLSession in stream mode so that is passed to your CGDataProvider in bursts decoding what you can and writing it to the screen as the data comes in In CCBufferedImageDecoder you create your CGDataProvider with an NSData but by the time you have the NSData of the time of fetching and displaying the image has already elapsed making progressive jpeg decoding pointless When I try to include this in an iOS project I get errors about bitcode support not being available on a certain ARM architecture As a result I have to disable bitcode for my entire app Hello I have been trying to use Concorde in a iOS project with the following code if let url NSURLstring produtoimagemurl let imagem CCBufferedImageViewframe cellimageViewframe imagemloadurl celladdSubviewimagem produtoimagem is a Contentful Asset and url value currently is url NSURL x feba When I execute my code I only get grey placeholders and never an image On the other hand I have tried using ContentfulPersistence with the following code let imagem CCBufferedImageViewframe cellimageViewframe imagemcdasetImageWithPersistedAssetprodutoimagem client sourceclient size imagemframesize placeholderImage nil celladdSubviewimagem Then I get the following error fatal error should never be called file UsersrafaelTrabalhoBier LeverpilsenPodsConcordeCodeCCBufferedImageViewContentfulswift line Any help would be appreciated I have been struggling for a while Currently a new instance of CCBufferedImageDecoder is created for each new chunk of data received Works but we could be more efficient especially considering that itll allocate a new output buffer each time Can be based off this cpp template JCOLORSPACE colorSpace void setPixelImageFrame buffer ImageFramePixelData currentAddress JSAMPARRAY samples int column JSAMPLE jsample samples column colorSpace JCSRGB switch colorSpace case JCSRGB buffersetRGBAcurrentAddress jsample jsample jsample xFF break case JCSCMYK Source is Inverted CMYK output is RGB See Or From CMYK to CMY X X K K for X C M or Y Thus from Inverted CMYK to CMY is X iX iK iK iXiK From CMY to RGB R C iCiK iCiK G and B similar unsigned k jsample buffersetRGBAcurrentAddress jsample k jsample k jsample k xFF break 