I rearranged the locations to build to accomodate a port for micropython However when I build the generated by makemoduledefspy moduledefsh on buildgenhdrmoduledefsh generates this error buildgenhdrmoduledefsh error expected before token define MODULEDEFMPQSTRUARRAY MPROMQSTRMPQSTRuarray MPROMPTR mpmoduleuarray buildgenhdrmoduledefsh note in expansion of macro MODULEDEFMPQSTRUARRAY define MICROPYREGISTEREDMODULES MODULEDEFMPQSTRUARRAY pyobjmodulec note in expansion of macro MICROPYREGISTEREDMODULES MICROPYREGISTEREDMODULES pyobjmodulec note to match this STATIC const mprommapelemt mpbuiltinmoduletable make pymkrulesmk buildpyobjmoduleo Error What am I doing wrong here Thanks On a Pyboard the following works python from pyb import RTC rtcRTC rtccalibration rtccalibration rtccalibration rtccalibration rtccalibration On a Pyboard D SF W and on an SF W I get python from pyb import RTC rtcRTC rtccalibration rtccalibration rtccalibration ve values seem to be negative sign extended rtccalibration It likes ve values rtccalibration Actual RTC behaviour matches the reported values ie passing yields a frequency which is substantially in error This behaviour is odd as the definition of the RTCCALR register appears identical for all three chips While the examples I have show good RTC performance the data for the SiT oscillator indicates that calibration may sometimes be required up to ppm error Im trying to do a board without a USB or switch using the STM F I want to use MBOOT to update the FW only when it is called from within an application so have no need for a USB or switch It will use an external SPI flash chip Ive got this working on the basic pyboard Ive declared the below yet MBOOT gives multiple errors when calling sudo make BOARDNAME USEMBOOT clean all define MICROPYHWHASSWITCH define MICROPYHWENABLEUSB define MICROPYHWUSBFS Is there a way to use MBOOT without a USB or switch In CPython Python default Oct GCC on linux Type help copyright credits or license for more information evalcompile string single In MicroPython MicroPython v g ae dirty on ESP module with ESP Type help for more information evalcompile string single As espidf provides maxconnection field in the wifiapconfigt Ive added a case which lets use such an option when configuring AP on the ESP Note that this is not dependent on MAXSTACOUNT define in espidfs componentswpasupplicantincludewpaapconfigh It is just a default value for the field and can be changed I have successfully tested it and managed to connect clients The th fails as expected But its still more than The code example in the docs fails with a surprising traceback python rtc machineRTC rtcinit Outcome MicroPython v g f eeab on PYBv with STM F RG Type help for more information from machine import RTC rtc RTC rtcinit Traceback most recent call last File stdin line in module TypeError function takes positional arguments but were given This PR proposes to add support for PSK cipher suites to ussl specifically for the esp but it should be supportable for other platforms that use mbedtls as well there is nothing esp specific in this PR except for enabling the cipher suites in the mbedtls config which is portspecific The PSK cipher suites are awesome because they do away with all the cert and key stuff Instead each client can get an id and hexkey and use that for bidirectional auth when connecting to the server Very useful for MQTT for example Docs can be read at SSL handshake fails with error mbedtlssslhandshake error Traceback most recent call last File stdin line in module File libsslreplpy line in start File libsslreplpy line in init File libsslreplpy line in connectSOC OSError Errno EIO The previous build esp idf v g c d abin works well Are there any significant changes in the ssl module in the latest build Is it related to this issue maybe I checked the error code here and I think it points to this but still not sure how to read the error code since x d does not appear anywhere MBEDTLSSSLALERTMSGUNSUPPORTEDCERT x B Maybe the previous build uses modusslaxtlsc by default instead of modusslmbedtlsc and the latest is the other way around From as described by mirko SPI allows word sizes of several bits not necessarily rounded up to a multiple of While I dont now about every platform hardware at least softSPI GPIO bitbanged SPI and the ESP IDF driven ESP SPI hardware support transferring single bits via SPI Looking at the micropython code though the whole SPI abstraction layer HW backed or SW assumes lengths of multiples of bytes meaning I cant just adjust the parts related to esp gpio To provide a use case and I indeed see this being an edge case but keep in mind that it still conforms with the SPI spec abusing SPI to speak SWD Suggestion Feature request Adjust the SPI code so that we can transmit single bits instead of multiples of bytes Happy to do it myself help assist for discussion However at first glance the changeset apparently would be larger than anticipated and Id be glad for opinions input help This adds support for a MICROPYINSPECT environment variable that works exactly like PYTHONINSPECT If this is set to a nonempty string it is equivalent to specifying the i option This variable can also be modified by Python code using osenviron to force inspect mode on program termination