overcommit This commit Changes to be committed use git reset HEAD file to unstage modified rakerakeandroidrb modified rakerakeiosrb modified rakerakemobilewebrb modified sharedraketeamcityrb new file sharedraketesttestselectioniosspecrb deleted sharedraketesttestselectionmapper specrb renamed sharedraketesttestselectionmapperspecrb sharedraketesttestselectionmergerspecrb modified sharedraketestrunrb renamed sharedraketestselectionrb sharedraketestselectioncalrb renamed sharedraketestselectionmapperrb sharedraketestselectioniosrb new file sharedraketestselectionmergerrb fails when running rspec tests because it still sees the moveddeleted files rwrr tim tim Dec sharedraketestselectioncalrb rwrr tim tim Dec sharedraketestselectioniosrb rwrr tim tim Dec sharedraketestselectionmapperrb rwrr tim tim Dec sharedraketestselectionmergerrb rwrr tim tim Dec sharedraketestselectionrb rwrr tim tim Dec sharedraketesttestselectioniosspecrb rwrr tim tim Dec sharedraketesttestselectionmapper specrb rwrr tim tim Dec sharedraketesttestselectionmapperspecrb rwrr tim tim Dec sharedraketesttestselectionmergerspecrb The deletedrenamed files shouldnt be showing up Failures Test selection mapper generates mapping counts FailureError sharedraketesttestselectionmapperspecrb in block levels in top required Finished in seconds files took seconds to load examples failure Failed examples rspec sharedraketesttestselectionmapperspecrb Test selection mapper generates mapping counts Motivation There are a lot of people on a lot of teams who balk at having precommit hooks slow them down on every commit As a compromise they would like the checks to happen on push rather than on commit This is reasonable to me as all I care about is that the end result of the code is correct especially if theyre squashing their commit prior to merge The downside is as the code currently stands the hooks only know how to hook into one type as far as I can tell so for example if I wanted to run rubocop PrePush rather than PreCommit then Id need to add a whole new hook Potential Goals What Id like is the ability to have the hook files understand how they execute in various contexts rather than having completely separate hooks For example Run against the entire project Run against specific files for example files changed between the current commit and the base branch Run against a diff When a new hook is added its required that it either can execute in those contexts or it explicitly fails it must explicitly fail In this way any hook could be placed in any section of the config YAML obviously assuming the hook supports it Thoughts Stumbled upon this when I was implementing a coworkers requested changes within a migration file that the branch in question had moved beyond REPRODUCTION Create a base Rails migration Add something innocuous to this file eg a raise ActiveRecordIrreversibleMigration within down Create another migration Run rails dbmigrate Go back and alter that down to now be a reversible migration EXPECTED Overcommit allows the change to be committed ACTUAL RailsSchemaUpToDate fails sometimes saying the migration youre committing changes to doesnt match the version of the schema sometimes quizzically saying that youre adding a migration but havent updated the schema file Greetings Overcommit team Ive created an additional precommit hook that runs puppetlabs pdk validate and it seems to work quite well Reason for doing this is because Puppetlabs has bundled the toolset of their own and its great It basically replaces the separate toolings like puppetlint yamllint yamlsyntax rubocop However i am a bit struggling with the rspec tests cant get negative testing right Would you be so kind as to nudge me in the right direction to do this the spec test in question can be found here Once i have this right i can squash and make a PR Thank you for your feedback I know we can run precommit hooks on all files with It would be great to be able to do this just on modified files and lines based on the commits ahead of the target branch in a pull request Im working with some legacy code that was never linted and so this would help with incrementally improving the code base without needing to use a service like CodeFactor Initial attempt at solving This works by creating git blobs for each part of the signature and then taking each object id SHA and pairing that with the hash SHA of the contents of that blob Those pairs are then written to another blob delimited by a space and one pair per line When checking if a signature has been verified then we compare the contents of the signature blob and not just the hash We cant just rely on the object id SHA as collision attacks are feasible A malicious repo owner could use such an attack to create an object with the same SHA as the configuration and hook contents I have kept the overcommitconfigurationsignature in the git config for now but I dont think it is necessary Removing it would loose the ability to show the No previously recorded signature for configuration file error but that doesnt seem like a huge loss It may still be useful for change detection which is what the previous signaturechanged method did but nothing actually used it for that purpose it was for signature verification instead I havent tried using this locally yet so it could do with some manual testing before merging There are quite a few tests that fail for me but they also fail on master Will see what the tests do on this PR Let me know what you think Apologies if this is a bit premature but it seems like the LineEndings hook is very slow as it is running on all files in the index I still need to confirm this but I just wanted to create this issue to track anything that I discover The way I am working around this is to run this command instead git status porcelain grep p A M cut f d xargs git lsfiles eol This will show the line endings for any file that has been added or modified Id love to see some sort of check in the CargoTest prepush hook that checked to see if there was a Cargotoml or any rs files in the project before it tried to run it Output of linters especially EsLint is much more prettier than output of overcommit either everything in red or everything in white if no color is specified It would be amazing if we could get unchanged output of linter that would make it easier to spot errors IMO overcommit doesnt need to analyze lines at all just fail if rubocop eslint returns an error Leave it to developer to analyze the errors Ive been looking at adding in a way to make sure that Ive bumped the metadatarb version of my cookbooks and a PrePush hook seemed a good way anyone else think this is a good idea