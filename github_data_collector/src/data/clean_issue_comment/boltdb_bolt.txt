Sometimes after a bunch of deletes Last for new cursor returns nil for nonempty bucket Code to reproduce is here May be its enough to put nrebalance at the end of n node delkey byte to fix this Hi benbjohnson Could you please confirm the solution I am not sure about invariants that should provide cursorDelete Is it ok to get an empty leaf page after delete a key Thank you I use the following code to createopen a bolt database file under the user home directory on mac go curUser err userCurrent if err nil panicerr else dataPath filepathJoincurUserHomeDir dataPath handle err boltOpendataPath defaultBoltOptions if err nil logerr this tells me permission denied error I wonder why this happened and how to fix it I run my go code go run maingo as a mac user githubcomboltdbbolt boltdbboltdbgo error reference to undefined identifier syncPool pagePool syncPool boltdbboltdbgo error reference to undefined identifier syncPool dbpagePool syncPool boltdbboltdbgo error expected or or newline dbpagePool syncPool boltdbboltdbgo error expected or newline after top level declaration New func interface boltdbboltdbgo error expected declaration boltdbboltdbgo error expected declaration if err dbmmapoptionsInitialMmapSize err nil boltdbboltdbgo error expected declaration if err dbmmapoptionsInitialMmapSize err nil boltdbboltdbgo error expected declaration return nil err boltdbboltdbgo error expected declaration boltdbboltdbgo error expected declaration dbfreelist newFreelist boltdbboltdbgo error expected declaration dbfreelistreaddbpagedbmetafreelist boltdbboltdbgo error expected declaration return db nil boltdbboltdbgo error expected declaration boltdbboltdbgo error missing return at end of function New func interface boltdbboltdbgo error too many values in return statement return nil err boltdbboltdbgo error too many values in return statement return nil err boltdbboltdbgo error too many values in return statement return nil err boltdbboltdbgo error too many values in return statement return nil err boltdbboltdbgo error not enough arguments to return return dbbeginRWTx boltdbboltdbgo error not enough arguments to return return dbbeginTx boltdbboltdbgo error argument must be a slice dbtxs appenddbtxs t boltdbboltdbgo error range clause must have array slice string map or channel type for t range dbtxs boltdbboltdbgo error range clause must have array slice string map or channel type for i t range dbtxs boltdbboltdbgo error argument must be a slice dbbatchcalls appenddbbatchcalls callfn fn err errCh boltdbboltdbgo error range clause must have array slice string map or channel type for c range bcalls boltdbboltdbgo error range clause must have array slice string map or channel type for i c range bcalls boltdbboltdbgo error noninteger len argument to make buf make byte countdbpageSize boltdbbolttxgo error return with value in function with no return type return txdb boltdbbolttxgo error not enough arguments to return return txrootCreateBucketname boltdbbolttxgo error not enough arguments to return return txrootCreateBucketIfNotExistsname boltdbbolttxgo error argument must be a slice txcommitHandlers appendtxcommitHandlers fn boltdbbolttxgo error division by zero p err txallocatetxdbfreelistsize txdbpageSize boltdbbolttxgo error expected channel err ok ch boltdbbolttxgo error range clause must have array slice string map or channel type for fn range txcommitHandlers boltdbbolttxgo error range clause must have array slice string map or channel type for p range txpages boltdbbolttxgo error expected map index on right hand side if p ok txpages id ok boltdbbolttxgo error invalid tuple definition boltdbboltdbgo error invalid type for range clause for t range dbtxs boltdbboltdbgo error invalid type for range clause for i t range dbtxs boltdbboltdbgo error invalid type for range clause boltdbboltdbgo error invalid type for range clause for c range bcalls boltdbboltdbgo error invalid type for range clause for i c range bcalls boltdbboltdbgo error invalid type for range clause boltdbbolttxgo error invalid type for range clause for fn range txcommitHandlers boltdbbolttxgo error invalid type for range clause for p range txpages Do not able to create sub bucket inside loop but when creating it outside it gets created Sorry to bring up another issue with this headline I already checked the other two issues and do not have the impression that they match my case Here my error panic page already freed goroutine running vendorgithubcomboltdbboltfreelistfree x f ec x x x extgo srcvendorgithubcomboltdbboltfreelistgo x vendorgithubcomboltdbboltnodespill x d x bc x extgo srcvendorgithubcomboltdbboltnodego x f vendorgithubcomboltdbboltBucketspill x eb c xe x extgo srcvendorgithubcomboltdbboltbucketgo x d vendorgithubcomboltdbboltTxCommit x eb x x extgo srcvendorgithubcomboltdbbolttxgo xff vendorgithubcomboltdbboltDBUpdate x fc x de x x extgo srcvendorgithubcomboltdbboltdbgo xc Here my Code snippet Add adds a value to the db using NextSequence to autoincrement the key func s DB AddtableName string value byte uint error var id uint err sConnUpdatefunctx boltTx error bt err txCreateBucketIfNotExists bytetableName if err nil return err id err btNextSequence if err nil return err return btPutitobid value return id errorsWithStackerr itob returns an byte big endian representation of v func itobi uint byte b make byte binaryBigEndianPutUint b i return b The error occurs the second time this code is executed every time The code runs fine on MacOS amd and Windows without cgo Disabling cgo disables a few packages that use windows dlls When compiling the final version with cgo and dlls using xgo targetswindows the resulting windows executable will show the above issue I added some logs to the boltdb code and checked which pages are being freed On every call the same pages are being freed The nodepgid on nodego is also the same on every call calls are several secods apart Why Since in one of the other issues on this topic there is talk about race conditions I made sure the entire connection is used by a single goroutine using the action pattern This did not resolve the issue either Add adds a value to the db using NextSequence to autoincrement the key func s DB AddtableName string value byte uint error added this to make sure there is no other goroutine using the byte array at the same time var valCopy make byte lenvalue valCopy appendvalCopy value var id uint chErr makechan error sRunsAction sAction func err sConnUpdatefunctx boltTx error bt err txCreateBucketIfNotExists bytetableName if err nil return err id err btNextSequence if err nil return err return btPutitobid valCopy chErr err err chErr return id errorsWithStackerr Anyone any idea on how to solve this issue WriteTransactions update Meta on commit and Meta only be updated at Backup invoke txWriteTo So please consider this case Assume my DBs freelist is stored in Page and I backup it now Then the page id of freelist in meta is now Then I do some writetransactions on the new DB file obviously the Page maybe reallocated as a branch page or a leaf page If meta is written to broken now then meta is used and the Page is regard as a freelist page again Hello guys there is a problem in file size updating in boltdb after reaching GB it occurs during file remapping The problem is still present in the master version The following are the technical details before start I want to say that my OS pageSize on a Windows bit machine is equal to bytes When boltdb needs to allocate new junk to store file this method is called immagine as you can see when is needed to increase the store file is called the method mmap with a minimum size reallocation parameter Inside mmap is called the method mmapSize that calculate the new store file size based on the minimum one passed as parameter immagine as you can see from my red comments there are different calculation methods inside mmapSize The first one calculate the new store size following this rule based on the minimum size parameter bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes bytes and this method works well The problems starts when the second calculation method take control over remap size because the minimum size that is passed as parameter when GB is reached was and not as I was expecting a value greater than So when GB is reached simply the mmapSize return the same minimum size passed as parameter because following codes immagine are never reached Can you please verify Ps I want to reference this bug on gitea project Only one readwrite transaction is allowed at a time From documentation I understand that concurrent writes are not allowed Im not sure if this is correct thus this question to clarify is boltdb designed only for one single writer globally Am I suppose to maintain a lock on any write Use case I want to store access logs of http requests Does this mean that I need to use a global channel to serialise the access bolt writes eg var globalChan makechan string func init const bucketName widgets tx err dbBegintrue if err nil panicerr err txCreateBucketIfNotExists bytebucketName if err nil return err go func for URL range globalCHan tx err dbBegintrue if err nil panicerr bk txBucket bytebucketName Set the value bar for the key foo if err bPut bytetimeNowString bytebar err nil return err func HandleFuncw httpResponseWriter r httpRequest globalChan rURLString every min i will write maybe k pairs but the write so slow I need some thing like dbIsOpen to check is the database open or not bolt database structure has unexported field open but I cant access to that from my code 