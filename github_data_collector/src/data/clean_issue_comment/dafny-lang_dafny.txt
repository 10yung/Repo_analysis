The advantage of dynamically generating elements such as tuple array and arrow types is that theres no maximum arity of such generic types However this interferes with being able to compile packages separately since separate packages may decide to generate the same elements leading to conflicts when loading or linking The easiest fix would be to pregenerate these types up to a maximum arity Scala currently does this with a cap of but it looks like Scala will no longer have this limit It may be possible to have our cake and eat it too if we borrow some of those techniques This fixes issues with compiled module names being contextsensitive and inconsistent when compiled separately into DLLs See Testdafny DafnyLibdfy for the regression test and more details Passes all tests although I suspect it may break untested use of nested modules in target languages other than C It should not be overly difficult to handle fullyqualified names though This is currently off by default and enabled by the optimize flag only because this library was not previously available for some platforms eg Mono However it is an available dependency in all the more modern frameworks and it should be reasonable to make this a hard dependency See which this depends on Dafny assigns sequentially instead of what supposed to be a parallel assignment This is an example of a code that runs just fine with no RunTimeErrors And this is the same code with a change in the order of assignment in line This code has an RTE I get verification timeout on the code snippet var aint x DEADBEEF var testbvbv a as bv var testvalint testbv as int assert testval a Timed out on assertion violation the command I use is Dafnyexe trace errorTrace timeLimit ironDafny allocated induction arith compile test dfy The dafny version I use is the commits on cc b c I fail to compile the latest Dafny source code on windows with VS as I see DafnyPipeline uses MonoCesil and not sure if I need to install Mono alongside with Net Core module List datatype tA Nil ConsA tA module Bug import List function method foox Listtchar y Listtchar Listtchar match x y case Cons ListCons ListNil case Nil ListNil dafny Bug dfy Dafny Bug dfy Error Undeclared toplevel type or type parameter t did you forget to qualify a name or declare a module import opened Bug dfy Error the declared type of the formal t does not agree with the corresponding type in the constructors signature tchar resolutiontype errors detected in Bug dfy module Option datatype tA None SomeA module P datatype t P module Bug import Option import P datatype input Inputz OptiontPt type t input bool const Foo t x input match x case InputSome true dafny Bug dfy Dafny Bug dfy Error command assigns to a global variable that is not in the enclosing procedures modifies clause Heap type checking errors detected in varfolders f tdypl qj hllhy wmd nr qTBug Bugbpl Encountered internal translation error rerunning Boogie to get better debug information varfolders f tdypl qj hllhy wmd nr qTBug Bugbpl Error command assigns to a global variable that is not in the enclosing procedures modifies clause Heap type checking errors detected in varfolders f tdypl qj hllhy wmd nr qTBug Bugbpl The Java compiler produces wrong output regarding constructors for a current test compClassdfy In particular the code below produces a zeroargument constructor that initializes a b c but then produces a method named ctor that is the translation of the given Dafny constructor class MyClass var a int const b int const c static const d int static const e constructor x int a x b x function method F int static function method G int method M returns r int r static method N returns r int return This is a high level feature request with a few different related issuesPRs Stop the dafny CLI from trying to dynamically resolve all dependent DLLs Needed to support extern code properly Dafny runtime nuget package Otherwise compiled module names are not stable across DLLs Make the MSBuild tasks aware of this support and include dependent DLLs when compiling 