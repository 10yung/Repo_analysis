It would appear that I am unable to get the following call to work export const bindClasses firestoreAction bindFirestoreRef bindFirestoreRefclasses fbfirestorecollectionclasses I see the mutation vuexfireARRAYADD being called but there is no data being written to stateclasses is there something I am missing Bumps tsjest from to details summaryRelease notessummary pemSourced from a href releasesaemp blockquote h h h Bug Fixesh ul lia href handle symlinked modules ala pnpm correctly a href lihandle tsBuildInfoFile option a href closes a href listrongperfstrong add cache for fs calls a href a href listrongtypesstrong unforce esModuleInterop in tsconfigjson a href ul blockquote details details summaryChangelogsummary pemSourced from a href changelogaemp blockquote h a href h h Bug Fixesh ul listrongconfigstrong support babel config file path as string a href a href ul pa name ap h a href h h Bug Fixesh ul litypescript serviceHost cache miss on Windows operating systems a href listrongcompilerstrong pass filename to sha function instead of file extension a href listrongtransformersstrong hoist jestenableAutomock and jestdisableAutomock a href ul pa name ap h a href h h Bug Fixesh ul lia href handle symlinked modules ala pnpm correctly a href lihandle tsBuildInfoFile option a href closes a href listrongperfstrong add cache for fs calls a href a href listrongtypesstrong unforce esModuleInterop in tsconfigjson a href ul pa name ap blockquote details details summaryCommitssummary ul lia href chorerelease li lia href chore update packagelockjsonli lia href Merge pull request a href from kulshekhardependabotnpmandyarncommitlintcli lia href builddepsdev bump commitlintcli from to li lia href Merge pull request a href from kulshekhardependabotnpmandyarncommitlintcli lia href builddepsdev bump commitlintcli from to li lia href choree e add enum test adjust imported babel config test a href lia href fixconfig support babel config file path as string a href lia href chore update e e templates a href lia href Merge pull request a href from kulshekhardependabotnpmandyarne etemplali liAdditional commits viewable in a href viewali ul details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart If all status checks pass Dependabot will automatically merge this pull request dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details Hello Im trying to delay the execution of my App until Firebase receives the Auth status before my not logged inredirections take place Afaik this is usually done with authonAuthStateChangeduser new Vue But in my current Vue setup my Vue instance get called in a total different way which gives me a tough time we should return factory for SSR runInNewContext false export default context const store createStorecontext router createRoutercontext syncstore router return new Vue i n store router app I tried encapsulating new Vue to a const and turn this constant inside the onAuthStateChanged function Didnt work Inside the export default neither Around the return new Vue neither Can someone give me a hint I already killed hours on this simple task PS Im working with SSR The problem When using typescript it is not possible to access properties defined in this context It warns that the defined props are not available in the scope with the message Error Property nameOfProp doesnt exist on type Vue Proposed solution I augmented VueConstructor type so it passes default typings around on extend function which doesnt happen in Vue itself and passed a CombinedInstance type as this for the firestore and firebase functions Im not sure if thats a good approach cause it messes up with Vue module definition If you know a better way of implementing this pls share Still not fixed I havent figured out yet how to infer methods data and computed properties types For now it only infers prop types and treats everything else as any fix I am getting typing errors when trying to access propsmethods of Vue instance inside of firestore function In the example below uid is a prop and I get no typing errors when accessing from created lifecycle hook but it is not defined inside firestore function ts export default Vueextend props uid created consolelog uid thisuid thisuid is fine firestore Error Property uid doesnt exist on type Vue const uid thisuid return user dbdocusersuid This can resolve the issue but shouldnt be necessary ts const uid this as anyuid What does this PR contain It just changes the posva packages path to be mapped to the src instead of the declaration files generated by the build in the dist folder Before that when ctrl clicking the package posvavuefirecore inside another package files it redirected to the dist folder Now it goes to the src I also removed one import that was pointing to a dist folder inside the core package idk why it was doing that Motivation It was really frustrating to look after the core files while debugging and end up in a declaration file This should make the code flow easier to understand by ctrl clicking Edit I noticed that should have its problem fixed too Would be great if we could do things like javascript Module export default class Collection extends VuexModule documents FirestoreAction bindCollection context name string contextbindFirestoreRefdocuments dbcollectionname contextunbindFirestoreRefdocuments Would allow actions and state to be more true to how they look in Vanilla Vuex while also making them typesafe Currently if a reference data types depth is not more than maxRefDepth then it is by default binded Instead there should be a way to override default behavior and specify the keys of the fields which should be binded This is a feature request for a convenient way of assigning the result of queryget to a property in the data model Similar to the firestore option or the the vmbind method but without subscribing for updates If I understand correctly currently one has write the following achieve the described outcome javascript async created const querySnapshot dbcollectionmydocsget thismydocs querySnapshotdocsmapdocumentSnapshot ObjectdefinePropertydocumentSnapshotdata id value documentSnapshotid enumerable false It would be useful to be able to use the short firestore notation and still be able to access the promises for usage with vuepromised for instance There are not a lot of situation where data is loaded asynchronously and a loader indicator is not necessary ie vue template Promised promisefirestorepromisedtodos etc Promised Promised promisefirestorepromisedcurrentTodo etc Promised template script new Vue data Usually an array for collection todos and null for documents currentTodo null firestore todos dbcollectiontodos currentTodo dbcollectiontodosdoc script 