Hello Are you going to add iPadOS multiwindow support If so any deadline Thanks a lot for your great framework Best regards Frankai I am using this library everything is normal but when coming to Japanese Romaji keyboard I am selecting the text from dropdown which has Japanese letters and english letters combined I apply attributewhich is a link to that text for the whole range but it splits the word into two which has Japanese letter and English letters and applies the attribute so attributes are applied twice OUITextView scrollTextSelectionToVisibleWithAnimation doesnt account for any contentInset when determining the contentOffset to scroll to This causes issues for example if you use contentOffset adjustments to avoid the keyboard This caused some missing intersections with a line that is very long e g c e inhibitMenuFor is found in OUIEditMenuController and is called by ancestorScrollViewWillBeginScrolling in OUIEditableFrame Likewise uninhibitMenuFor is called by ancestorScrollViewDidEndScrolling The assumption this code makes is that each begin scrolling event will be balanced by an end scrolling event However this is not the case Any time the direction of scrolling is changed before scrolling has finished inhibitMenuFor will be called without a uninhibitMenuFor balancing it out In these cases the OBASSERT will fail in inhibitMenuFor No harm done since the inhibitions set will not add an existing object but likely this assertion should be removed voidinhibitMenuForNSString cause DEBUGMENUs func self DEBUGMENUInhibiting for cause OBASSERT inhibitions membercause nil inhibitions addObjectcause self updateMainMenuVisibility voiduninhibitMenuForNSString cause DEBUGMENUs func self DEBUGMENUOvercoming inhibition for cause OBASSERT inhibitions membercause nil inhibitions removeObjectcause self updateMainMenuVisibility code Ive had an error similar to the following pop up a few times because OUIScalingViewController layoutSubViews doesnt call super Terminating app due to uncaught exception NSInternalInconsistencyException reason Auto Layout still required after executing layoutSubviews needs to call super This is an issue when using an OUIScalingView subclass in a xib or storyboard that has autolayout turned on voidlayoutSubviews if selfwantsShadowEdges self updateShadowEdgeViews In OUIViewController there is an OBPRECONDITION that requires unretainedprospectiveparent to not be nil see below However this will be nil in some cases For example using an OUIScalingViewController subclass in a view controller embedded in a nav controller via storyboard In this case willMoveToParentViewController is never called which is where unretainedprospectiveparent is initially being set voiddidMoveToParentViewControllerUIViewController parent DEBUGPARENTVCIn s with parent func parent OBPRECONDITIONparent unretainedprospectiveparent unretainedparent parent This code sitting on our OUIEditableFrame subclass is working in production to set the background color of the current selection but doesnt work testing it on the latest Omni build Is there a new design pattern that achieves the same result void setTextBackgroundColorForCurrentSelectionToColorUIColor aColor UITextRange selectedRange self selectedTextRange if selectedRangeisEmpty self setValueidaColorCGColor forAttributeOABackgroundColorAttributeName inRangeselectedRange To test I used the TextEditor sample and created a custom menu item that displays when there is a selection Selecting the menu item calls this method with UIColor yellowColor The background color doesnt change however Minor tweak to the TextEditor sample to adjust the contentSize to be the same as textViewviewUsedSize so the user can scroll through the text The AppControllers toolbarItemsForDocument parameter is not being used in the TextEditor sample In addition the following comment appears in it Cache document toolbar items These must only target the given object not the document so that we can reuse them Is the OUIDocument parameter legacy code that wouldnt typically be used or is the TextEditor samle a special case where its not needed 