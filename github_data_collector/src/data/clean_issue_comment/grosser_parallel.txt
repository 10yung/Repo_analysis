I got a expensive calculation and i want to kill all childs once one of them delivers a result ruby results Parallelfind inprocesses do thiscouldtakelong end p results solution Use case is solving a proof of work One of the processes will be the fastest and only one solution is needed There seams to be no way to this or is Thanks in advance for making this Gem Our team has been enjoying it for a long time However as we also use Rspec in our automation systems I found that sometimes our test would fail with a DeadWorker This DeadWorker makes our investigation a little bit difficult By digging into your library code more I found that the fact that our tests would fail with DeadWorker is a consequence of When something like expectato be b fail Rspec will raise a RSpecExpectationsExpectationNotMetError which isnt a StandardError We are using Parallel with inprocesses so many of our code will be executed on a forked process The rescue in doesnt seem to catch the RSpecExpectationsExpectationNotMetError as it isnt a StandardError The process died out and the worker failed to read the file When this happened DeadWorker from will be the final thing recorded I have a small example so you could also have a try ruby require rspecexpectations require parallel This line will fail and the last thing in the rspec report is a ParallelDeadWorker Paralleleach inprocesses x raise RSpecExpectationsExpectationNotMetError This line will leave the correct exception as the exception happens in the main process and kills the process Paralleleach inthreads x raise RSpecExpectationsExpectationNotMetError I tried to make a small change that lets the rescue to catch Exception and after the changes our annoying DeadWorker was resolved As I dont really know the designing details of processincomingjobs this Issue is mainly for asking Are there any concerns so that you guys didnt choose to rescue all the exceptions in processincomingjobs We could patch what we need in our own system But do you think it is worthy to modify the processincomingjobs so it could catch Exception Or is there any other thing that might be better We benefit from the open source community a lot so I would like to submit a PR for this Feels like this could be something that everyone could run into especially when using libraries such as Rspec that raises nonStandardError I am trying to execute two rake tasks in parallel in next way task runparallelregression do Parallelmapi thread thread do task RakeTask task invoke raise ParallelBreak end end If thread will be finished first and the result will fail but thread will succeed Parallelmap exit code will be What I should change in my code to make Parallelmap exit with code if one of the subprocesses failed Cucumber unfortunately utilizes the atexit method as hook The Parallel gem by default uses the Kernelfork method which means that when the forked process exits it will call the parents atexit handler I am not sure if this is intended behaviour for the Parallel gem but it does cause some unexpected bugs to occur in cucumber or any other program that uses atexit in a similiar way Capybara minitest are some others I think use atexit like this Here is the issue I opened with cucumber cucumbercucumberruby I was wondering if there was any interest in making Thread the default or perhaps changing how the fork workers exit I think calling exit will make it not call the parents atexit handlers but calling that from inside the Parallel block in user code ended up with Deadworker exception which makes sense after perusing the code PS I love how this gem is essentially file very nice concise code Hi When building the package for Debian the test suite is run From time to time a test fails because of the presence of a debug trace which causes the output to not match the expected result Here are two examples of such failures Failures Paralleleach does not call the finish hook when a start hook fails with threads FailureError METHODeach WORKERTYPEtype ruby speccaseswithexceptioninstartbeforefinishrb should called expected called got homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelr publicsend n tfrom speccaseswithexceptioninstartbeforefinishrb in main n called using Diff homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in value No live threads left Deadlock fatal threads sleeps current x e f ce c main thread x e f ff Thread x e f b sleepforever rbthreadt x e f ff native x f e e int homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in value homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in map homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in inthreads homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in workinthreads homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in map homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in each speccaseswithexceptioninstartbeforefinishrb in publicsend speccaseswithexceptioninstartbeforefinishrb in main Thread x e f homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb sleepforever rbthreadt x e f ce c native x f e int depended by tbthreadid x e f ff homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in synchronize homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in next homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in block in workinthreads homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in block levels in inthreads from homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in map from homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in inthreads from homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in workinthreads from homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in map from homeboutildebianrubyteamrubyparalleldebianrubyparallelusrlibrubyvendorrubyparallelrb in each from speccaseswithexceptioninstartbeforefinishrb in publicsend from speccaseswithexceptioninstartbeforefinishrb in main called specparallelspecrb in block levels in top required specspechelperrb in block levels in top required Finished in seconds files took seconds to load examples failure pending Failed examples rspec specparallelspecrb Paralleleach does not call the finish hook when a start hook fails with threads or Failures Parallel lambdas runs in threads FailureError ruby speccaseswiththingrb THREADS should result expected ITEM nITEM nITEM n got PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparalusrlibrubyvendorrubyparallelrb in map n tfrom speccaseswithqueuerb in main n using Diff ITEM ITEM ITEM PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in value No live threads left Deadlock fatal threads sleeps current x cf main thread x fd d Thread x b sleepforever rbthreadt x fd d native x efd c int PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in value PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in map PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in inthreads PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in workinthreads PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in map speccaseswithqueuerb in main Thread x e PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb sleepforever rbthreadt x cf native x efd bb int depended by tbthreadid x fd d PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in synchronize PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in next PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in block in workinthreads PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in block levels in inthreads from PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in map from PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in inthreads from PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in workinthreads from PKGBUILDDIRdebianrubyparallelusrlibrubyvendorrubyparallelrb in map from speccaseswithqueuerb in main specparallelspecrb in block levels in top required specspechelperrb in block levels in top required Finished in seconds files took seconds to load examples failure pending Failed examples rspec specparallelspecrb Parallel lambdas runs in threads These traces are certainly not wanted but maybe the tests should use regexp matches instead of strict equality of strings What do you think Anytime I try to run a paralleltest using Ruby v ruby our test fail with error parallelcucumber command not found However running it with ruby works as expected Has anyone else experienced this issue Thanks Parallel provides each and map methods implying it works well with Enumerables but it fails with the following contrived use case ruby require parallel require prime primes Primetoenum privatekey Paralleleachprimes inthreads do prime if privatekey prime puts Found factor prime raise ParallelBreak end end because if the first argument to Paralleleach is not a lambda toa is called and it tries to expand the infinite series Ox is an object serializer which is faster than Marshal I wonder if youd be interested in a pull request that uses Ox in parallel Question is whether its ok to add a dependency which requires compilation or rather use Ox if available and Marshal otherwise Hey grosser heres the changes I made to allow parallel to kill all child processes Let me know what you think Thanks Cloning directly from and updating only to use correct BrowserStack credentials running these tests results in expected behaviour and all tests pass However if I intentionally make the tests fails eg change expectdrivertitleto eqlBrowserStack Google Search to something else like expectdrivertitleto eqlNOTBrowserStack Google Search the test fails as expected but then returns the error rake aborted ParallelDeadWorker ParallelDeadWorker preventing the processes from running any more tests 