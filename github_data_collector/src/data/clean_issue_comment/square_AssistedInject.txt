Why you add this limitation AssistedInjectFactory must be declared as a nested type AssistedInject only works for construction injection Dagger on the other hand is able to inject stuff after construction with MembersInjector for some Inject lateinit var dep Dependency Is it somehow possible to have this for AssistedInject Screen Shot at PM Not sure whats causing it Only happens in one of my projects Hello I want to use lifecycleviewmodelsavedstate in my project so I came across AssistedInject and decided to use it But regardless of all my efforts to mix it with my current project stucture I get compiler errors all the time Everything compiles and works fine if I dont use AssistedInject AssistedInjectFactory and ViewModelAssistedFactoriesModule But as a result I obviously cant use Assisted SavedStateHandle savedStateHandle which was the main goal of all this So is it possible to use AssistedInject with all this ContributesAndroidInjector and AuthScope stuff Here is my simple configuration Singleton Componentmodules AndroidSupportInjectionModuleclass AppModuleclass ActivityBuildersModuleclass ViewModelFactoryModuleclass ViewModelAssistedFactoriesModuleclass interface AppComponent AndroidInjectorApp ComponentBuilder interface Builder BindsInstance fun contextcontext Context Builder fun build AppComponent AppModule provides global Singleton dependencies like for example Context and so on Module internal abstract class ActivityBuildersModule BaseActivityBuildersModule MainScope ContributesAndroidInjectormodules MainFragmentBuildersModuleclass MainViewModelsModuleclass MainModuleclass internal abstract fun contributeMainActivity MainActivity Module public abstract class BaseActivityBuildersModule AuthScope ContributesAndroidInjector modules AuthViewModelsModuleclass AuthModuleclass this is important because AuthModule provides AuthScope scoped dependencies abstract AuthActivity contributeAuthActivity Module public abstract class AuthViewModelsModule Binds IntoMap ViewModelKeyAuthActivityVMclass public abstract ViewModelAssistedFactory extends ViewModel bindAuthActivityViewModelAuthActivityVMFactory viewModelFactory Binds abstract SavedStateRegistryOwner bindSavedStateRegistryOwnerAuthActivity activity Nullable Provides static Bundle provideDefaultArgs return null public interface ViewModelAssistedFactoryT extends ViewModel T createSavedStateHandle savedStateHandle Module public class AuthModule Provides AuthScope static LoginValidator provideLoginValidator return new AuthValidator and other AuthScope things Module abstract class ViewModelFactoryModule Binds abstract fun bindViewModelFactoryviewModelFactory ViewModelProviderFactory ViewModelProviderFactory AssistedModule Moduleincludes AssistedInjectViewModelAssistedFactoriesModuleclass public abstract class ViewModelAssistedFactoriesModule public class AuthActivityVM extends ViewModel AssistedInjectFactory public interface Factory extends ViewModelAssistedFactoryAuthActivityVM AssistedInject Inject AuthActivityVMAssisted SavedStateHandle savedStateHandle NonNull Context context no complier complains other Singleton dependencies also fine NonNull LoginValidator loginValidator loginValidator comes from AuthModule and it is scoped with AuthScpoe oter things In AuthActivity I have this bit of code Inject ViewModelProviderFactory providerFactory But compiler complains comalidibasemodelsauthLoginValidator cannot be provided without an Providesannotated method javaxinjectProvidercomalidibasemodelsauthLoginValidator is injected at comalidibaseuiauthAuthActivityVMAssistedFactory loginValidator Avoids naming requirements in the simple case Addresses AssistedInject fails without explanation when I try to use it with various classes that use generics The simplest case that fails for me with Dagger AssistedInject and Kotlin kotlin class AClassA AssistedInject constructor Assisted dependency String AssistedInjectFactory interface Factory fun createdependency String AClassString The only error that appears is the following error cannot find symbol daggerModuleincludes AssistedInjectPresentationModuleclass symbol class AssistedInjectPresentationModule FAILURE Build failed with an exception This is just a simplified version of what I was trying to do initially which also fails with no meaningful message kotlin abstract class BaseT class WrapperA B class AClassA B AssistedInject constructor Assisted dependency A B BaseWrapperA B AssistedInjectFactory interface Factory fun A B createdependency A B AClassA B Currently the generated AssistedInjectModule contains all the bindings for AssistedInjectFactory annotated factories in one module As a result its impossible to have dependencies that exist only in subcomponents For example I have two ViewModels where one of them takes an argument GithubApi in this case which exists only in one the subcomponent hosting these view models class CommitDetailViewModel AssistedInject constructor Assisted handle SavedStateHandle privatel val githubApi GithubApi Should be provided only in CommitDetailActivitySubcomponent BaseViewModelhandle fun loadDetail TimbervRequest commit detail use githubApi here AssistedInjectFactory interface Factory ViewModelAssistedFactoryCommitDetailViewModel class CommitListViewModel AssistedInject constructor Assisted handle SavedStateHandle BaseViewModelhandle fun loadCommits TimbervRequest commit list AssistedInjectFactory interface Factory ViewModelAssistedFactoryCommitListViewModel interface ViewModelAssistedFactoryT ViewModel fun createhandle SavedStateHandle T AssistedModule Moduleincludes AssistedInjectViewModelAssistedFactoriesModuleclass public abstract class ViewModelAssistedFactoriesModule The generated AssistedInjectViewModelAssistedFactoriesModule contains the bindings for both factories above Due to that I have to include it in the ApplicationComponent so its visible to my subcomponents But then compilation fails since GithubApis binding is only defined in one of the subcomponents Annotating multiple modules with AssistedModule results in error Multiple AssistedModuleannotated modules found After watching your talk from DroidCon UK where you mention that there should be one and only one module that is annotated with AssistedModule in the whole project it all became clear to me and I managed to fix this error eventually At least in the current version of the library this rule isnt mentioned or at least unclear in the READMEmd andor the sample Even though this behavior might change in the future and it would be allowed to annotate multiple modules I think its still worth mentioning it at least for the current behavior of the library Request not to mandate same names for assisted parameters In my case changing params to workerParameters fixed it but would be nice not to force same names InternalWorkerFactoryjava error Factory method parameters do not match constructor Assisted parameters public abstract T createorgjetbrainsannotationsNotNull Missing androidxworkWorkerParameters params Unknown androidxworkWorkerParameters workerParameters Im trying to figure out how to support views with InflationInject annotated constructors whose dependencies are provided by subcomponents or components that only have a component dependency on the component that provides the InflationInjectFactory So basically I need to add view factories to the InflationInjectFactory on the fly but it doesnt seem possible when I also have a single activity app Is there something Im missing