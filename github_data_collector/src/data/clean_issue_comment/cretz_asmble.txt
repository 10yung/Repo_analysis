Ive got clang to compile this to WASM c Filename addc int addint a int b return a b When trying to compile to JVM with asmble it fails Caused by javautilNoSuchElementException List is empty at kotlincollectionsCollectionsKtCollectionsKtlastCollectionskt at asmbleioBinaryToAsttoModuleBinaryToAstkt at asmblecliTranslateinToAstTranslatekt at asmblecliCompilerunCompilekt This was working with version but broke in This is the code that fails where you call customSectionslast if sectionId customSections else If the last section was custom use the last custom sections afterID otherwise just use the last section ID val afterSectionId if index else sections index let prevSectionId if prevSectionId customSectionslastafterSectionId else prevSectionId This code is hard to follow but looks like customSection starts off empty so its likely the last call is going to be called on the empty list as is happening to me Not sure what afterSectionId should be assigned to in that case though hope you can help find a solution Hi cretz hope you dont mind Im creating an issue just to let you know Ive created a Gradle Plugin to compile WASM to JVM class files based on your project It makes it much easier to compile and play with WASM Thanks for making this possible Bump dependencies update ByteBuffer APIs to Java s suppress warning properly This issue fixes but may drop support for JRE Im using JRE I have stumbled with NPD during compilation of this example It seems that this exception caused by generation of stack locals after GOTO operation the field locals sets to null by asm after GOTO and then processing of iconst operation tries to invoke get on null object here java localsReadputvar localsgetvar The stack trace is visitVarInsn SplitterStackAndLocalTrackingAdapter asmblecompilejvmmsplit accept VarInsnNode orgobjectwebasmtree splitPointFromInfo SplitterIter asmblecompilejvmmsplit longestForCurrIndex SplitterIter asmblecompilejvmmsplit nextOrNull SplitterIter asmblecompilejvmmsplit hasNext SplitterIter asmblecompilejvmmsplit split SplitMethod asmblecompilejvmmsplit split SplitMethod asmblecompilejvmmsplit fromClassNode AsmToBinary asmblecompilejvm fromClassNodedefault AsmToBinary asmblecompilejvm run Compile asmblecli run Compile asmblecli runWithArgs Command asmblecli main MainKt asmblecli Also tested with the latest asm the same result gradle examplesrustsimplerun succeed while gradle run argscompile examplesrustsimpletargetwasm unknownunknownreleaserustsimplewasm RustSimple failed why ERROR Error in command compile Invalid section ID of asmbleioIoErrInvalidSectionId Invalid section ID of at asmbleioBinaryToAsttoModuleBinaryToAstkt at asmblecliTranslateinToAstTranslatekt at asmblecliCompilerunCompilekt at asmblecliCompilerunCompilekt at asmblecliCommandrunWithArgsCommandkt at asmblecliMainKtmainMainkt I download release and extract to my computer when I run MacBookProasmble wudream asmblebinasmble compile mainwasm hello Exception in thread main kotlinreflectjvminternalKotlinReflectionInternalError Function limit JVM signature limitILjavanioBuffer not resolved in class javanioByteBuffer public open fun limitarg kotlinInt javanioByteBufferjavanioByteBuffer defined in javanioByteBuffer kotlinreflectjvminternalJvmFunctionSignatureJavaMethodf c d public final fun limit kotlinInt defined in javanioByteBuffer kotlinreflectjvminternalJvmFunctionSignatureJavaMethod ac c at kotlinreflectjvminternalKDeclarationContainerImplfindFunctionDescriptorKDeclarationContainerImplkt at kotlinreflectjvminternalKFunctionImpldescriptor invokeKFunctionImplkt at kotlinreflectjvminternalKFunctionImpldescriptor invokeKFunctionImplkt at kotlinreflectjvminternalReflectPropertiesLazySoftValinvokeReflectPropertiesjava at kotlinreflectjvminternalReflectPropertiesValgetValueReflectPropertiesjava at kotlinreflectjvminternalKFunctionImplgetDescriptorKFunctionImplkt at kotlinreflectjvminternalKFunctionImplcaller invokeKFunctionImplkt at kotlinreflectjvminternalKFunctionImplcaller invokeKFunctionImplkt at kotlinreflectjvminternalReflectPropertiesLazySoftValinvokeReflectPropertiesjava at kotlinreflectjvminternalReflectPropertiesValgetValueReflectPropertiesjava at kotlinreflectjvminternalKFunctionImplgetCallerKFunctionImplkt at kotlinreflectjvmReflectJvmMappinggetJavaMethodReflectJvmMappingkt at asmblecompilejvmAsmExtKtgetDeclarerAsmExtkt at asmblecompilejvmAsmExtKtinvokeVirtualAsmExtkt at asmblecompilejvmByteBufferMeminitByteBufferMemkt at asmblecompilejvmAstToAsmaddMemClassConstructorAstToAsmkt at asmblecompilejvmAstToAsmaddConstructorsAstToAsmkt at asmblecompilejvmAstToAsmfromModuleAstToAsmkt at asmblecliCompilerunCompilekt at asmblecliCompilerunCompilekt at asmblecliCommandrunWithArgsCommandkt at asmblecliMainKtmainMainkt I do quick glance at google search it seems to be javanioByteBuffer incompatibility with JDK pls have a look Well now that V has it I might as well do it I was hoping the spec would get standardized and the waitwake stuff would get test cases and interpreter support in the repo I put an overview of my expected impl approach on HN the other day I have more details in personal notes but should be doable without too much effort Once is done we need to Update README to give more details to programmatic users Add KDoc to more of the lib Publish a dokka javadoc jar to maven central w next release Update README to remove some of the lesscalled CLI stuff If my program uses memcpy in java bytecode I see this implementation java private int memcpyint var int var int var if var int var var do thismemoryputvar byteBytetoUnsignedIntthismemorygetvar var var whilevar return var But it can be implemented in much more efficient way by using ByteBuffer API java private int memcpyint src int dst int len if len ByteBuffer srcBuf memoryduplicate srcBufpositionsrc srcBuflimitsrc len ByteBuffer dstBuf memoryduplicate dstBufpositiondst dstBufputsrcBuf return src With this implementation the real native memcpy will be used if memory is DirectByteBuffer We can detect functions like memcpy by their names signatures and bodies and then replace them with more efficient implementation Its common practice to store gradle wrapper inside git repository It make initial setup much easier for new contributors For example we store gradle wrapper in our repository in intellijrust 