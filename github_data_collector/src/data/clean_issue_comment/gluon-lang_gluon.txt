Running the following example rust use gluonvmprimitive record ExternModule use gluonimport newvm ThreadExt use gluoncodegenGetable VmType deriveGetable VmType gluonvmtype sharedtypeSharedType pub enum SharedType OneBoxSharedType Zero fn funt SharedType pub fn run Result Boxdyn stderrorError let vm newvm vmloadscript sharedtype r type SharedType One SharedType Zero SharedType importaddexternmodule vm nativefun vm ExternModulenew vm record fun primitive fun vmloadscript firstfunimport r let fun import nativefun NOTE This call is required HERE not before the previous loadscript vmruniotrue vmrunexpr secondfunimport r let SharedType import sharedtype let fun import nativefun fun Zero Causes unification error Ok fn main if let Erre run panic e Results in the following error message thread main panicked at error Expected the following types to be equal Expected sharedtypeSharedType Found sharedtypeSharedType errors were found during unification The use of self recursion in type sharedtypeSharedType could not be unified secondfunimport fun Zero srcmainrs note run with RUSTBACKTRACE environment variable to display a backtrace It seems like enabling IO between imports of the native function somehow causes the unification to fail Are the preio and postio Types internally different somehow If anyone else encounters this moving the runio up eg directly after creation seems work around this bug Gluon seems to deadlock when deserializing serialized values in some circumstances Minimal reproduction Utilizes some changes to salsa to perform all module compilation in parallel as long as a parallel future executor is supplied Running gluon fmt over the same file multiple times may yield differing outputs Im aware of two examples gluon fmt inserts an empty line after each line of some multiline type signatures even if an empty line is already present increasing the number of empty lines on every run I havent figured out the exact circumstances that trigger the bug but it only occurs with multiline type signatures and seems to occur more often when the constituent lines are long For example let gectvbzppia alrkvbjaklbvapouhvgtbvvnaipryrbipajlkm vhieurabrlvikbnvliaejnbae vhieurabrlvikbnvliaejnbaeoribfhknjeanhbtbaejnbaetiekjnajkrhblbrfvbrkkajbevels vhieurabrlvikbnvliaejnbaeoribfhknjeanhbtbaejnb vhieurabrlvikbnvliaejn x yields let gectvbzppia alrkvbjaklbvapouhvgtbvvnaipryrbipajlkm vhieurabrlvikbnvliaejnbae vhieurabrlvikbnvliaejnbaeoribfhknjeanhbtbaejnbaetiekjnajkrhblbrfvbrkkajbevels vhieurabrlvikbnvliaejnbaeoribfhknjeanhbtbaejnb vhieurabrlvikbnvliaejn x Applying gluon fmt to let assertsuccess Show e Eff error Error e writer Test r a Eff writer Test r runerror flatmap assertok once yields let assertsuccess Show e Eff error Error e writer Test r a Eff writer Test r runerror flatmap assertok but twice yields let assertsuccess Show e Eff error Error e writer Test r a Eff writer Test r runerror flatmap assertok The interpreter fails to find implicit parameters in the REPL while interpreting files correctly Example below The bug is present in ba b I havent checked earlier commits let map import stdfunctor map map let list functor functorlist import stdlist cut for brevity map x x listof error Implicit parameter with type stdfunctorFunctor stdlistList could not be resolved line map x x listof map functorlist x x listof Cons Cons Cons Cons Nil Since operators also seem to be malfunctioning the issue may be with how the REPL handles attributes The associativity of leftassociative operators is being ignored in the REPL Works properly when run from a file The incorrect behavior occurs in ba b I havent checked any earlier commits target debug gluonexe i gluon h for help q to quit let id flip import stdfunction cut for brevity let map import stdfunctor map map x x x x error Expected the following types to be equal Expected Int Int Found Int errors were found during unification Types do not match Expected Int Int Found Int line x x x x error Implicit parameter with type stdnumNum Int Int could not be resolved line x x x x x x x x Since implicits also seem to be malfunctioning the issue may be with how the REPL handles attributes Description Adds a time module to the standard library which exposes the functionality of Rusts stdtime Status In Development Outstanding design questions x How should stdtime be structured stdtimeInstantnow stdtimeinstantnow stdinstantnow or something else stdtimeInstantnow x Should stdtime be behind a feature Should that feature be default not behind feature To Do x Implement all functionality in stdtime x Implement types x Implement functions x Implement implicit interfaces Eq and Ord Add documentation Generated std lib docs Examples x In Rust code no need x Add tests no need Future Directions Add more fullfeatured dateandtime functionality to the standard library Chrono Is there a reason that vmapiFunctioncall and callasync and callfastasync take a mutable reference to self The code compiles fine if they take immutable references Constructing a type alias inside a record gives an Undefined variable error Example gluon This doesnt work MyInt Int But this does type MyInt Int MyInt Error message error Undefined variable Int Having more than fields in the record macro gives this error error recursion limit reached while expanding the macro stringify help consider adding a recursionlimit attribute to your crate Increasing the recursion limit as suggested by the compiler makes the error go away but I assume the macro can be rewritten in a nonrecursive way to avoid this Im not wellversed in rust macros though so maybe not On one hand though having more than fields is probably a good indication that its time to split up modules so maybe this should just stay as it is Code Example record value value value value value value value value value value value value value value value value value value value value value value value value value value value value value value Having this triggers the error 