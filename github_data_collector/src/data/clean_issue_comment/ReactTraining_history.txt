 Thank you for contributing Have a usage question The issue tracker is meant for bug reports only This isnt the best place for usage questions Questions here dont have as much visibility as they do elsewhere Before you ask a question here are some resources to get help first Read the docs Check out the list of frequently asked questions Explore examples Look forask questions on Stack Overflow Ask in chat Think you found a bug The best bug report is a failing test in the repository as a pull request Otherwise please use the BUG REPORT template below Have a feature request Remove the template from below and provide thoughtful commentary and code samples on what this feature means for your product What will it allow you to do that you cant do today How will it make current workarounds straightforward What potential bugs and edge cases does it help to avoid etc Please keep it productcentric BUG TEMPLATE Version v Test Case Steps to reproduce I have two components in the same tree which are both calling historyreplace on mount ts import React Component from react import render from reactdom import RouteComponentProps BrowserRouter withRouter from reactrouterdom class Inner extends ReactComponentRouteComponentProps componentDidMount const location history thisprops historyreplacebarfoo render return divthispropslocationpathnamediv const InnerEnhanced withRouterInner class App extends ReactComponentRouteComponentProps componentDidMount const location history thisprops historyreplace location state a render return InnerEnhanced const AppEnhanced withRouterApp Note in my real world use case these components are far from each other in the tree and they are completely decoupled from each other I would like to keep it this way Both of the location updates are completely orthogonal to each other one updates the path the other updates the state so I would expect them to combine After App has finished mounting the URL path should be barfoo and locationstate should be a Unfortunately this is not what happens The actual URL path is not the expected barfoo This is because the location spreaded into historyreplace by App is stale ts location does not reflect the current location according to the URL It only reflects the location at the time of the last render ie before Inner mounted and called historyreplace historyreplace location state a locationpathname is locationsearch is locationstate is a We cant omit the location spread because then locationsearch would not be carried across IIUC only the pathname is carried across from the current location ts historyreplace state a locationpathname is bar locationsearch is One workaround is to read from historylocation instead of propslocation but IIUC that is discouraged because it is mutable ts historyreplace historylocation state a locationpathname is bar locationsearch is foo locationstate is a This seems very similar to the problem commonly seen when using Reacts setState setState works around this problem by providing a callback version to which the latest state will always be provided ts thissetStatelatestState deriveNewStatelatestState This makes me wonder whether a similar API might work for location updates ts historyreplacelatestLocation deriveNewLocationlatestLocation This would also provide parity with the Link to prop which does accept a callback Using my example from above this would allow us to do something like ts historyreplacelatestLocation latestLocation state a locationpathname is bar locationsearch is foo locationstate is a What do you think to the idea of adding a callback variant to historypushreplace Perhaps there is a better solution Im not aware of yet If you like the idea I would be happy to contribute a PR for it Hi I noticed a change in the historylisten method The change is on this line historylistenlocation action is now historylisten location action If there is no reason to this change except syntax sugar then I would like to suggest to revert this Reason If you have an application where the history instances are swappable then it would be great to allow v and v instances to be interchangeable That way a developer can elect to use an older version of the package to gain back some removed features like basename support With this change anyone that wants to do that now has to change their code to be compatible Issue and PR is a problem I do not understand why you keep closing and locking PRs without explanations I have hybridlegacy application with server rendering and react reactrouter and the page is merging things even when using BrowserRouter forceRefresh Im not sure if this is the behaviour expected but I think its a bug In this line the state is set with a new property state and the final value of globalHistory state is state state whatever whatever I think when you want to set the state in Link of the reactrouter by example you expected the final state will be to assign with this new properties and not with a state property that has the values What do you think Thanks in advance These options were increasing the build size since the repo uses Babel for transpilation based on presetenv leaving the default options from the closure compiler plugin languageoutNOTRANSPILE etc will net a smaller output I know this issue has come up before The response to that was that The basename should not be considered dynamic its purpose is to identify an applications root on the server However historys documentation states that If all the URLs in your app are relative to some other base URL use the basename option A common use case for the html base tag also seems to put the language in the base url So I think using the basename to hold a language identifier or any other possible dynamic information can be a warranted use case if every other URL is relative to that I also dont see that much of a technical difficulty to implement this It would require another public function to change the basename Downstream consumers of history such as reactrouter could also then allow to update the basename but would require to somehow notify usages of createHref eg Link to be updated Is there any strong opinion against this would be willing to provide a PR for this if this is not considered too out of scope Just watched the video for the blocking feature in v Looked very good How would it work though when not doing a synchronous windowconfirm to prompt the user I m currently using a reach modal for it Would I have to store the transition object somewhere to be available when I then eventually confirm the dialog I have try edit message of dialog which using to warning user before leave page my code import createBrowserHistory from history const history createBrowserHistory const unblock historyblockAre you sure you want to leave this page But dialog in Chrome Safari not change it still use default message I use version beta img width altpicture src shsession node requirehistorycreateLocation pathname foo pathname foo search hash Expected pathname foo search hash state undefined Actual the state key is omitted I understand that referencing locationstate will return undefined even when the state key has been omitted however it would help to return a consistent type to make the types more predictable For example Objectkeyslocation should always include state in the returned array The TypeScript type says the key will always exist it is not an optional property This is related to and and continues reywright and pshrmn proposed solution Problem When using createBrowserHistory with the forceRefresh prop the methods go goBack and goForward do not behave as expected The location url will update but the page does not refresh Proposed Solution Update the createBrowserHistory behaviour for push and replace methods to not call the History apis pushState and replaceState methods when forceRefresh prop is true Why As stated in the original feature issue Some users need a history that has clean URLs like browser history uses full page refreshes instead of pushState Currently forceRefresh does not always use full page refreshes and is still calling pushState Making this change will ensure the feature adheres to its original purpose 