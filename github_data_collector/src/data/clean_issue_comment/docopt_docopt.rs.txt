The following example rust use docoptDocopt use serdeDeserialize const USAGE static str Test Usage test cachedircachedir Options cachedircachedir enables cache deriveDebug Deserialize struct Args flagcachedir OptionString fn main let args Args DocoptnewUSAGE andthend ddeserialize unwraporelsee eexit println args Gives result cargo run cachedirabc Finished dev unoptimized debuginfo targets in s Running target debug docopttestexe cachedirabc Args flagcachedir None If option name is changed to cachedir then it parses the optional argument correctly Test Usage test cachedircachedir Options cachedircachedir enables cache cargo run cachedirabc Finished dev unoptimized debuginfo targets in s Running target debug docopttestexe cachedirabc Args flagcachedir Someabc When calling a binary some users forget how some arguments work and simply add a h to see the help again without removing all parameters job alongpathgz anotherlongpathgz alongpathagaingz h In some libs like argparse this prints the complete help message as if you used job h With docoptrs it does print the usage message but doesnt actually care about the h It would print the same thing with a nonexisting parameter Invalid arguments Usage job tlrd it would be nice to print the whole help message with h even if there are other args Im trying to write the following doc string to have a form for the s flag and also provide it documentation Usage oursh c options commandstring commandname arguments Options c read commands from the commandstring operand set the value of special parameter see section special parameters from the value of the commandname operand and the positional parameters and so on in sequence from the remaining arguments operands no commands shall be read from the standard input Is this possible The following works in Python python import docopt doc Usage testpy flag another args docoptdocoptdoc printargs testpy flag another False flag True testpy another another True flag False testpy flag another another True flag True The equivalent has trouble in docoptrs rust macrouse extern crate serdederive extern crate docopt const USAGE str Usage test flag another deriveDebug Deserialize struct Args flagflag bool flaganother bool fn main let args Args docoptDocoptnewUSAGE andthend ddeserialize unwraporelsee eexit println args test flag Args flagflag true flaganother false test another Args flagflag false flaganother true test flag another Invalid arguments Usage test flag another It seems like the Rust implementation is interpreting those two lines as two separate argument lists where the second one is allowed to omit the executable name rather than combining them into one Does that sound like the right interpretation Do you know of any workarounds currently besides just avoiding newlines in the docstring Sorry for the title essentially when a longaval the value is only deserialised for the one specified in the struct Contrast b bee as Boolean flags when the value of whichever is given is available as eg flagbee flagb need not be specified Heres a reproduction toml dependencies docopt version log version serde version serdederive version stderrlog version rust extern crate docopt macrouse extern crate log macrouse extern crate serdederive extern crate stderrlog use docoptDocopt const USAGE static str Reproduction Usage repro q quiet v verbosityv Options q quiet Disable stderr logging v verbosityv Verbosity of stderr logging deriveDebug Deserialize struct Args flagquiet bool flagverbosity usize fn main let args Args DocoptnewUSAGE andthend ddeserialize unwraporelsee eexit println args stderrlognew modulemodulepath quietargsflagquiet timestampstderrlogTimestampSecond verbosityargsflagverbosity init unwrap tracetrace message debugdebug message infoinfo message warnwarn message errorerror message Then cargo run verbosity Args flagquiet false flagverbosity T INFO info message T WARN warn message T ERROR error message so far so good cargo run vvv Args flagquiet false flagverbosity T ERROR error message Not so good I thought maybe the issue was using the short while deserialising the long name but cargo run q Args flagquiet true flagverbosity so it does appear to be the interaction between and v Lessthanideal workaround with particular respect to integer flags just in case someone stumbles here with a similar use case separate lines in Options add flagv usize toArgs verbosityargsflagverbosity argsflagv since docopt takes care of at most one being nonzero Im not sure whether this is expected behavior but the following seems a bit strange to me rust static USAGE static str Description Usage prog subcommand arg fn main let d docoptDocoptnewUSAGEunwraphelptrueparseunwrap println d The above program works fine cargo run subcommand arg However if the subcommand is changed to start with the binary name new usage string prog progsubcommand arg running cargo run progsubcommand arg will fail with Invalid arguments But running cargo run subcommand arg will again work The problem does not occurr on When I try to use docoptmacros v I found compile error like that bash cargo run Updating registry Compiling docoptmacros v error E mismatched types UsersKhigashiguchicargoregistrysrcgithubcom ecc db ec docoptmacros srcmacrors mapident ty expected struct stdvecVec found tuple note expected type stdvecVecsyntaxastIdent syntaxptrPsyntaxastTy found type error aborting due to previous error error Could not compile docoptmacros My code is above srcmainrs rust fetureplugin plugindocoptmacros macrouse extern crate serdederive extern crate docopt use docoptDocopt docoptArgs derive Debug Usage cref cref import importrepo cref list cref update updaterepo cref delete deleterepo cref help version Options h help Show this screen v version Show version fn main let args Args Argsdocoptdeserializeunwraporelsee eexit println args Cargotoml package name clisearchproperenglishmessage version authors Khigashiguchi dependencies docopt docoptmacros serde serdederive cargo version cargo nightly bb a rustc version rustc nightly d Please teach me how to solve it Was slightly confusing for me when trying to understand the example but couldnt find the moored flag in the struct When an argument has an in the docopt deserialising it to the Args struct fails as it is looking for an argument with an Example error cargo run Finished dev unoptimized debuginfo targets in secs Running targetdebugbar Could not find argument foopath from struct field argfoopath Note that each struct field must have the right key prefix which must be one of cmd flag or arg Code sample causing error macrouse extern crate serdederive extern crate docopt use docoptDocopt const USAGE static str JSON XPather Usage bar foopath deriveDebug Deserialize struct Args argfoopath String fn main let args Args DocoptnewUSAGE andthend ddeserialize unwraporelsee eexit println args 