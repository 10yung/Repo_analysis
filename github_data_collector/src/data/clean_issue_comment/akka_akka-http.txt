Not entirely sure this is the right place to do it but couldnt figure out where else it would go Updates comgithubbenmanescaffeinecaffeine from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId comgithubbenmanescaffeine artifactId caffeine details labels libraryupdate semverpatch Currently we wrap a failure to unmarshall with Jackson in an IllegalArgumentException with the text Cannot unmarshal JSON as type and then pass the exception with details as a cause however when this ends up in the routing tree only the top level exception message is in the response body and that isnt very useful for figuring out what is wrong with the request JSON I think we should provide the validation error details from Jackson in the exception message or have a specific exception type for the failure and handle that in the ExceptionHandler Refs As promised in its deprecation message None Refs Before merging should be updated not to take a Materializer implicit but instead use either or As surendarchandra noticed our HPACK header tries to encode as many header values as possible into dynamic table entries The effect can be that high entropy headers like Date or ContentLength evict more useful headers from the dynamic table The HPACK implementation from twitter that we use allows to pass the sensitive flag to encodeHeader which prevents that the values are put into the dynamic table We should consider to encode high entropy header using the sensitive flag for better use of the dynamic header table Fixes Im writing an application with the AKKA actors framework and Im sending a message to a child actor which sends two HTTP requests to a unix domain socket to query the Docker socket using guidance from When I send the first round of HTTP requests I do not receive any errors After this first round of HTTP requests is successful there is a checkin message sent to the parent actor Once all child actors check in the parent actor sends a broadcast to all child actors for the second round of HTTP requests After attempting to send the first HTTP POST request I receive the following error ERROR ScoringWorkerakkaactordefaultdispatcher akkaactorActorSystemImplScoringWorker Outgoing request stream error javalangIllegalStateException Substream Source cannot be materialized more than once at akkastreamimplfusingSubSourceanon setCBStreamOfStreamsscala at akkastreamimplfusingSubSourceanon preStartStreamOfStreamsscala at akkastreamimplfusingGraphInterpreterinitGraphInterpreterscala at akkastreamimplfusingGraphInterpreterShellinitActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpretertryInitActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpreterfinishShellRegistrationActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpreterakkastreamimplfusingActorGraphInterpretershortCircuitBatchActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpreteranonfunreceive applyOrElseActorGraphInterpreterscala at akkaactorActoraroundReceiveActorscala at akkaactorActoraroundReceiveActorscala at akkastreamimplfusingActorGraphInterpreteraroundReceiveActorGraphInterpreterscala at akkaactorActorCellreceiveMessageActorCellscala at akkaactorActorCellinvokeActorCellscala at akkadispatchMailboxprocessMailboxMailboxscala at akkadispatchMailboxrunMailboxscala at akkadispatchMailboxexecMailboxscala at akkadispatchforkjoinForkJoinTaskdoExecForkJoinTaskjava at akkadispatchforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava at akkadispatchforkjoinForkJoinPoolrunWorkerForkJoinPooljava at akkadispatchforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava javalangIllegalStateException Substream Source cannot be materialized more than once This is the psuedocode for the WorkerActor class WorkerActor extends Actor object DockerSockTransport extends ClientTransport override def connectTohost String port Int settings ClientConnectionSettingsimplicit system ActorSystem Flow ByteString ByteString Future HttpOutgoingConnection ignore everything for now UnixDomainSocketoutgoingConnectionnew Filevarrundockersock mapMaterializedValue Seems that the UnixDomainSocketOutgoingConnection is never completed It works anyway if we just assume it is completed instantly FuturesuccessfulHttpOutgoingConnectionInetSocketAddresscreateUnresolvedhost port InetSocketAddresscreateUnresolvedhost port implicit val newsystem contextsystem implicit val mat ActorMaterializernewsystem import newsystemdispatcher val settings ConnectionPoolSettingsnewsystemwithTransportDockerSockTransportwithMaxConnections import SprayJsonSupport def handleResponseresponse HttpResponse Future String TODO create docker json model classes and directly marshal to them Unmarshalresponseto String def DockerClienthttpMethod String path String if httpMethod POST HttpsingleRequestHttpRequestmethod HttpMethodsPOST uri path entity HttpEntityContentTypesapplicationjson userData settings settings flatMaphandleResponse onComplete case Successres String printlnReturn res case Failureresp printlnresp else HttpsingleRequestHttpRequestmethod HttpMethodsGET uri path settings settings flatMaphandleResponse onComplete res printlnsGot result res def receive case round DockerClientPOST containersxxxexec These are the dependencies I am using scalaVersion scalacOptions in ThisBuild Sequnchecked deprecation feature resolvers Typesafe Repository at libraryDependencies Seqcomtypesafeakka akkaactor libraryDependencies Seqcomtypesafeakka akkaremote libraryDependencies Seqcomtypesafeakka akkastream libraryDependencies Seqcomtypesafeakka akkahttpsprayjson libraryDependencies Seqcomlightbendakka akkastreamalpakkaunixdomainsocket 