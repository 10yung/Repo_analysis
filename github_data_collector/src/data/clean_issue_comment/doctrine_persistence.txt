 BC Break Report When executing cacheclear after composer update there is PHP fatal error PHP Fatal error Declaration of Doctrine ORM MappingClassMetadataFactorywakeupReflectionDoctrine Common Persistence Mapping ClassMetadata class Doctrine Common Persistence Mapping ReflectionService reflService must be compatible with Doctrine Persistence MappingAbstractClassMetadataFactorywakeupReflectionDoctrine Persistence Mapping ClassMetadata class Doctrine Persistence Mapping ReflectionService reflService in varwwwhtmlvendordoctrineormlibDoctrineORMMappingClassMetadataFactoryphp on line PHP Stack trace main varwwwhtmlbinconsole Symfony Bundle FrameworkBundle Console Applicationrun varwwwhtmlbinconsole Symfony Bundle FrameworkBundle Console ApplicationdoRun varwwwhtmlvendorsymfonyconsoleApplicationphp Symfony Bundle FrameworkBundle Console ApplicationregisterCommands varwwwhtmlvendorsymfonyframeworkbundleConsoleApplicationphp App Kernelboot varwwwhtmlvendorsymfonyframeworkbundleConsoleApplicationphp App KernelinitializeContainer varwwwhtmlvendorsymfonyhttpkernelKernelphp Symfony Component HttpKernel CacheWarmer CacheWarmerAggregatewarmUp varwwwhtmlvendorsymfonyhttpkernelKernelphp ContainerEPFlGxJ srcAppKernelDevDebugContainerclosurevarwwwhtmlvarcachedevContainerEPFlGxJgetCacheWarmerServicephp varwwwhtmlvendorsymfonyhttpkernelCacheWarmerCacheWarmerAggregatephp ContainerEPFlGxJ srcAppKernelDevDebugContainerload varwwwhtmlvarcachedevContainerEPFlGxJgetCacheWarmerServicephp require varwwwhtmlvarcachedevContainerEPFlGxJsrcAppKernelDevDebugContainerphp ContainerEPFlGxJ srcAppKernelDevDebugContainergetValidatorBuilderService varwwwhtmlvarcachedevContainerEPFlGxJgetValidatorMappingCacheWarmerServicephp ContainerEPFlGxJ srcAppKernelDevDebugContainergetDoctrineOrmDefaultEntityManagerService varwwwhtmlvarcachedevContainerEPFlGxJsrcAppKernelDevDebugContainerphp Doctrine ORM EntityManagercreate varwwwhtmlvarcachedevContainerEPFlGxJsrcAppKernelDevDebugContainerphp Doctrine ORM EntityManagerconstruct varwwwhtmlvendordoctrineormlibDoctrineORMEntityManagerphp splautoloadcall varwwwhtmlvendordoctrineormlibDoctrineORMEntityManagerphp Symfony Component Debug DebugClassLoaderloadClass varwwwhtmlvendordoctrineormlibDoctrineORMEntityManagerphp In ClassMetadataFactoryphp line Compile Error Declaration of Doctrine ORM Mapping ClassMetadataFactorywakeupReflectionDoctrine Common Persistence Mapping ClassMetadata class Doctrine Common Persistence Mapping ReflectionService reflService must be compatible with Doctrine Persistence Mapping AbstractClassMetadataFactorywakeupReflectionDoctrine Persistence Mapping ClassMetadata class Doctrine Persistence Mapping ReflectionService reflService Q A BC Break yes Version Package mongodbodm is provided through doctrinemongodbodmbundle Adding fixed doctrinemongodbodm to composer as a temporary fix does the trick As was done in doctrinecollections we should add support for generics using the psalmtemplate annotations for generic classes like Repositories and Registries We should also ensure that generics in PHPStan are supported as well See for the reference implementation in collections TODO Tests have opinions on cache keys We should fix that SymfonyHackday This came to me while reading through In a few of those cases people have the same entity managed by multiple entity managers While Im not sure whether that constitutes a valid usecase the manager registry is equipped to handle this by allowing to specify en entity manager to use when calling AbstractManagerRegistrygetRepository However AbstractManagerRegistrygetManagerForClass handles those cases wrong IMO it simply returns the first entity manager that manages the entity in question In cases like the above this can lead to undesired behaviour as were ignoring the fact that we cant reliably say which entity manager is responsible fora given class Assuming the usecase of having the same entity managed by multiple entity managers is valid we should throw an exception in getManagerForClass if we realise that the same class is managed by more than a single entity manager In this patch I want to discuss the possibility of adding an optional parameter to the findAll method that IMO makes sense to be there orderBy When one needs to fetch the data sorted differently than the default method findAll is of no use and one has to use findBy orderBy which makes it slightly less readable as there are no filters being applied but rather it is used only for sorting Said calls then can be changed to findAllorderBy If the maintainers agree that this is a positive change then I can also send the corresponding PR for doctrineorm and any documentation changes The check seems to be insufficient as a transient class may have an alias defined using ResolveTargetEntityListener Evaluate if we should return iterable instead of array in some cases It may make more sense to add new methods that return iterable instead of changing existing methods eg findAllIterator or something instead of changing findAll to return an array The current AbstractManagerRegistry implementation provides abstract getService and resetService methods to allow subclasses to implement their own logic how to retrieve connection and manager services However with PSR defining a lightweight container interface I believe its best to deprecate AbstractManagerRegistry in favour of a ContainerManagerRegistry that takes a ContainerInterface in the constructor and forwards all calls to the ContainerInterfaceget A basic example implementation for this would be the ManagerRegistry provided in the Symfony DoctrineBridge There is some dark magic going on with resetService where wed have to discuss how to best solve this Not sure why we need resetting services but again this shouldnt be an implementation detail of an abstract registry This new class could be added in with the AbstractManagerRegistry potentially being deprecated in either the same release or in a subsequent x release Ive closed PR and created new one because that PR is targeted on master This PR fixed bugs Using with metadata cache is not working because ResolveTargetEntityListener calls setMetadataFor without any effect on generated cache Fallback metadata is not caching now Based on the idea from itd be nice to have a set of finegrained base exceptions defined in doctrinepersistence that implementationagnostic consumers may rely on Right now theres only MappingException