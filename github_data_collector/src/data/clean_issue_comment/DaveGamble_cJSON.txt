I suppose the function comparedouble was simply used to compare whether the two double value is equal or not but it actually also do the check for NaN implicitly which may not a good practise securely comparison of floatingpoint variables static cJSONbool comparedoubledouble a double b return fabsa b CJSONDOUBLEPRECISION This checks for NaN and Infinity if comparedoubled length sprintfcharnumberbuffer null The reason why the above code works fine is becasue ab return NaN no matter d is NaN or INF the result of d is NAN fabsNaN return NaN NaN with all comparisons with the operators return false thus NaN CJSONDOUBLEPRECISION return false Compare to current implementation Im much prefer the original one its simple and directly and faster This checks for NaN and Infinity if d length sprintfcharnumberbuffer null but since added the compile option Werrorfloatequal this statement d would like to trigger an error error comparing floating point with or is unsafe Why we should add Werrorfloatequal this option is too picky comparing floating point with or sometimes useful This option will shouting everytime even when you know its safe Hi there Would you mind if using the macro DBLEPSILON to perform the comparisons for double value I think its more portable since it was defined in floath After bring in DBLEPSILON we could update the comparisons a more canonical way return fabsa b DBLEPSILON If we dont want include the floath theres a simple way to get the value for different platform double getDBLEPSILON void double d while d d d return d have test for the code above itll get the right value value round getDBLEPSILON is getDBLEPSILON is e Macro DBLEPSILON is Macro DBLEPSILON is e During working with Telegram Bot API with cJSON library for parsing values Ive faced an issue The issue is this I was unable to get identifier value from response obviously according to cJSON parsenumber function such value was never going to be stored in itemvalueint Sure let it go but why not try to store the value anyways but as long Related to and I divided cJSON into several relatively independent code blocks according to the function below cJSONMinify cJSONDuplicate cJSONCompare Parsing Printing Create item In CMakeListstxt I add six options to control whether enable related features or notall options are on by default ENABLECJSONMINIFY ENABLECJSONDUPLICATE ENABLECJSONCOMPARE ENABLECJSONPARSING ENABLECJSONPRINTING ENABLECREATEITEM You can disable any features by cmake DOPTIONOFF Only all the above options are on the tests could build My cJSON fork Any suggestions are welcome Hi I started using cJSON for an ESP project Im working on because it is included by default in Espressifs v of the ESPIDF Unfortunately the version they have is a bit months out of date version I used CC much earlier in my career but switched to C when it came out So my CC is rusty which is why Im asking questions rather than submitting PRs I used the readme examples at first to figure out how to use the API Im confused by a few things that I think might be wrong in the sample but if Im wrong hopefully someone can help clear it up for me cJSONCreateString example name cJSONCreateStringAwesome K The parameter here is a constant string This function is going to duplicate the string and allocate memory Would it be better to use cJSONCreateStringReference so memory is not allocated and this string literal is not going away It might be that because Im developing for a constrained embedded device running RTOS which is known to get memory fragmentation and a best practice is to avoid memory allocations if you can avoid them that Im more sensitive to this So my questions are is cJSONCreateStringReference appropriate to use in this scenario and would it be good to employ it in the readme sample especially since the parameter is a constant cJSONAddItemToObject example cJSONAddItemToObjectmonitor name name This also uses a string literal as a parameter Based on the documentation would it be better to use cJSONAddItemToObjectCS cJSONPrintUnformatted In my own code I chose to use the cJSONCreateStringReference and cJSONAddItemToObjectDS in conjunction with cJSONPrintUnformatted The documentation for print says I am responsible for freeing the memory allocated by it However the call to delete would throw with something about memory reference in the heap that wasnt in the heap Ive temporarily avoided this by using cJSONPrintPreallocated but I dont know what Im doing wrong with my creation calls that is producing cJSON objects that have invalid memory references Note it would be better use PrintPreallocated anyway with a stack buffer to avoid the memory allocation but the json created will vary in size which will eventually result in an error if Ive guessed the wrong max buffer size Note This bit of code parses some input with cJSON and creates a new document based on some of the source material This meant taking strings from the parsed json and using them as parameters for the new json object and I figured I wanted to use the Reference and DS functions to tell cJSON not to try to free that memory when deleting In all I had cJSON objects to delete the original parsed json the response cJSON object and the printed json The failure was happening when deleting which was being deleted first Thanks David Hello I have work with cjson library I create a json using cJSONAddNumberToObjectroot name temp with json number and I convert that to char for transmit but I can not convert have error when convert double to char array as bellow figure But when I create json string and convert to char array it work fine I use to gcc for arm cortex to compile could you help me resolve it Thank you Hello I use cJSON very well but i found cJSON dont have getNumberValue So I add it If cJSON object is not number type I return Nannot a number And i also follow Coding style which is in CONTRIBUTINGmd At last i Add Unit Test to misctestsc and test is successful Check and merge plz thank u Hi I would like to keep code size as small as possible for my project Analyzed my project size with different versions of cJSON build by IAR Here is some data Existing project with some old cJSON bytes cJSON updated to bytes cJSON updated to bytes cJSON updated to bytes cJSON updated to bytes cJSON updated to failed to build cJSON updated to bytes cJSON updated to bytes cJSON updated to latest bytes So the optimal by size for me is v I would like to take the latest but kb increase is huge Could you please optimize the code size of latest release to the minimum possible For example by removing sscanf call from printnumber optimizes bytes because of large sscanf library size I believe there is better method how to check number of nonzero digits before converting it to string instead of scanning string and rework printf by casting results of additemtoobject to void where the public API has no return value yet In any case this PR may not be merged but the API changed to return something if that is reasonable in these places In case you want to deal with integer numbers cJSONCreateNumber seems to be wasteful Theres an int to double cast that just shouldnt be there not to mention potential problems with floating point numbers More specifically to my case Im running the lib on a bits microcontroller with no bit FPU and that seems to be even more wasteful Is there any reason there is no way to natively set an integer directly Would a PR to add it be accepted