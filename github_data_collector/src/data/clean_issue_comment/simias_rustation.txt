Hi Here is the work in progress to port the full emulator from rustcserialize to serde It is still very rough on the edges I had to duplicate the big array trick for the Box T XXX type Im not sure if there is a cleaner and more general solution This does not compile yet what I did is mostly search and replace Dont be in a hurry to check this Remaining cdromAsyncResponse gpuCallback gpuGp Handler mdecCommandHandler At the time the savestate architecture was first implemented Serde was not yet stable Since then its become the defacto serialization library for Rust superseeding the hacky RustcEncodableRustcEncodable While theres no emergency itd be nice to move to Serde now that its stabilized It shouldnt be too difficult but its quite a big change which impacts both rustation and rustationlibretro In particular the current binary serializer would have to be ported or rewritten Im not sure how straightforward that would be Apparently the current GTE flag mask is bogus It should be x ffff I need to write a test to trigger the inaccuracy and fix it I have the Psyq PSXPS SDK installed would those C C headers be useful to help implementing some things in Rust from the actual Playstation I even found the headers that contains information about things like loading saving to from memory cards It could be helpful Also I wonder how quicksaves was done in emulators like ePSXe I always wanted an Open source PSX emulator though funny how the games on the PSX was created using C andor C Although not modern ones C psyq include KERNELH c ifndef KERNELH define KERNELH Filekernelh Rev PSLibId Runtime Library Release ifndef R H include r h endif ifndef ASMH include asmh endif dont change these macros and structures which is refereced in kernel code define DescMask xff define DescTH DescMask define DescHW xf define DescEV xf define DescRC xf define DescUEV xf User event define DescSW xf BIOS define HwVBLANK DescHW x VBLANK define HwGPU DescHW x GPU define HwCdRom DescHW x CDROM Decorder define HwDMAC DescHW x DMA controller define HwRTC DescHW x RTC define HwRTC DescHW x RTC define HwRTC DescHW x RTC define HwCNTL DescHW x Controller define HwSPU DescHW x SPU define HwPIO DescHW x a PIO define HwSIO DescHW x b SIO define HwCPU DescHW x Exception define HwCARD DescHW x memory card define HwCARD DescHW x memory card define HwCARD DescHW x memory card define SwCARD DescSW x memory card define SwMATH DescSW x libmath define RCntCNT DescRC x display pixel define RCntCNT DescRC x horizontal sync define RCntCNT DescRC x oneeighth of system clock define RCntCNT DescRC x vertical sync target value fixed to define RCntMdINTR x define RCntMdNOINTR x define RCntMdSC x define RCntMdSP x define RCntMdFR x define RCntMdGATE x define EvSpCZ x counter becomes zero define EvSpINT x interrupted define EvSpIOE x end of io define EvSpCLOSE x file was closed define EvSpACK x command acknowledged define EvSpCOMP x command completed define EvSpDR x data ready define EvSpDE x data end define EvSpTIMOUT x time out define EvSpUNKNOWN x unknown command define EvSpIOER x end of read buffer define EvSpIOEW x end of write buffer define EvSpTRAP x general interrupt define EvSpNEW x new device define EvSpSYSCALL x system call instruction define EvSpERROR x error happned define EvSpPERROR x previous write error happned define EvSpEDOM x domain error in libmath define EvSpERANGE x range error in libmath define EvMdINTR x define EvMdNOINTR x define EvStUNUSED x define EvStWAIT x define EvStACTIVE x define EvStALREADY x define TcbMdRT x reserved by system define TcbMdPRI x reserved by system define TcbStUNUSED x define TcbStACTIVE x if definedLANGUAGECdefinedLANGUAGECdefinedLANGUAGECPLUSPLUSdefinedcplusplusdefinedcplusplus struct ToT unsigned long head long size struct TCBH struct TCB entry NULL long flag struct TCB long status long mode unsigned long reg NREGS never change the offset of this long system reserved by system struct EvCB unsigned long desc long status long spec long mode long FHandler long system reserved by system struct EXEC unsigned long pc unsigned long gp unsigned long taddr unsigned long tsize unsigned long daddr unsigned long dsize unsigned long baddr unsigned long bsize unsigned long saddr unsigned long ssize unsigned long spfpgpretbase struct XFHDR char key unsigned long text unsigned long data struct EXEC exec char title PlayStationtm Executable A struct DIRENTRY char name long attr long size struct DIRENTRY next long head char system extern struct ToT SysToT extern long SysClearRCnt ifndef NULL define NULL endif if definedLANGUAGECdefinedLANGUAGEC define delete erase endif LANGUAGEC endif LANGUAGECLANGUAGECPLUSPLUScpluspluscplusplus endif KERNELH But yeah maybe the psyq can actually help finish the emulator up to become as good as the original Playstation Compiling gl v Compiling rustationretro v filetmpbuilddlibretrorustation git d srclibretrors error unresolved name panicAssertUnwindSafe E srclibretrors let r paniccatchunwindpanicAssertUnwindSafe srclibretrors help run rustc explain E to see a detailed explanation srclibretrors error unresolved name paniccatchunwind E srclibretrors let r paniccatchunwindpanicAssertUnwindSafe srclibretrors help run rustc explain E to see a detailed explanation srclibretrors error the type of this value must be known in this context srclibretrors if riserr error aborting due to previous error Could not compile rustationretro To learn more run the command again with verbose debianrules recipe for target overridedhautobuild failed build log debian files This a project Ive been thinking about for a while but I have so much stuff on my todo list at the moment that I cant imagine tackling it anytime soon I would like an external tool that could take PlayStation GPU command logs and lets me see what individual commands draw Id also like to be able to navigate the commands go back in time etc That would be a huge time saver when tracking down certain graphical bugs Im posting this here in case somebody else wants to give it a try its a relatively simple well bounded and in my opinion fun project for somebody who likes making user interfaces and wants to try their hands at emulation Its not super performancecritical either so you can really use the language and environment of your choice although portability is strongly encouraged This tool would be useful in the development of Rustation but it need not be tied to it and could be used for other emulators or even a real console as long as youre able to dump incoming GPU command words Context From a high level perspective the PlayStation GPU is fairly simple It has Megabyte of VRAM laid out as a x bitsperpixel video buffer The GPU draws lines triangles and quadrilaterals to this buffer and then sends a portion of it to the video output In order to control it the GPU has two bit registers called GP and GP The CPU andor DMA sends command words through those registers and the GPU executes them Heres the GP decoding function in rustation And heres GP s No is also a good source for understanding the GPU and its commands You can see that GP commands are mainly draw commands like draw a triangle at these coordinates draw a line at these coordinates fill this rectangle in VRAM with this color etc Its relatively straightforward GP on the other hand is more for configuration things like turning the video output on or off or configuring which part of the VRAM is displayed on the screen The problem My current problem is that linking a visual glitch on the output with an actual individual GPU command in the emulator can be very tedious and time consuming without any kind of tool to assist me For instance heres the complete log of GP and GP commands during the first few seconds after boot Thats individual command words making up GP and GP commands And all it does is draw the little animation of the Sony Computer Entertainment logo on boot For instance if you dig into the log youll find the following sequence GP x b GP x f bd GP xca cb GP x GP xca cb GP x e This draws one of the shaded triangles Took me a little while to extract it out The general form of this command is GP x BBGGRR x is the command opcode followed by the bit RGB color of the st vertex GP xYYYYXXXX st vertex X and Y coordinates GP xXXBBGGRR nd vertex bit RGB color high byte is ignored GP xYYYYXXXX st vertex X and Y coordinates GP xXXBBGGRR rd vertex bit RGB color high byte is ignored GP xYYYYXXXX rd vertex X and Y coordinates Now you can go back to the previous command and manually decode it if you want As you can see this is pretty time consuming Now heres an actual bug Im trying to fix right now retroarch Crashs shadow on the ground is made up of two triangles and you can see that one of them has the wrong transparency applied In order to fix this Id like to be able to track the individual draw command responsible for this particular triangle and figure out why I dont interpreted it correctly Isolating a single command from the thousands of calls making up each Crash Bandicoot frame is very tedious Parsing the log I posted above is already nontrivial and its only drawing a dozen triangles in a simple animation What Id like is a visual tool that would take this command stream and show me what they do directly on the screen No seems to have something like that already psxdebug You can see that the Vram Viewer window has a list of commands at the upper right and seems to highlight the selected quadrilateral in the main view Using a tool like this I could track down the bogus command in my Crash Bandicoot screenshot in seconds This looks like a great tool but unfortunately its closed source as far as I know So if somebody wants to give this a try or wants more precisions dont hesitate to ask for my help As far as I know nobody has attempted to LLE the PlayStation CD controller It would be quite performance intensive and an HLE implementation is probably good enough of the time but if somebody wants to give it a try it could be interesting for accuracys sake No managed to dump some of the ROMs of the bit controller He also has many details about how this controller works in his spec That could be a starting point Im developing a prototype in the subpixel branch More details to come Vulkan has been released Vulkan would be great because it has the same compatibility between desktop and mobile PS IOP is PS CPU with GTE and MDEC Right now pcsx devs are fixing IOP emulation in PCSX based on hardware tests and planning to add a recompiler Perhaps you could copy that recompiler from PCSX to rustation in the future Also check hardware tests 