Hi I had problem packing a project that uses Sigil got an error The DateTimeOffset specified cannot be converted into a Zip file timestamp This is a known issue in Nuget that prevents packing files with no modificationcreation timestamps After a little digging I figured that Sigil contains few files with incorrect timestamp After downgrading to previous version the problem solved Repro is to deploy a console application that does an AssemblyLoadSigil and publish it as self contained It will fail stating it cant find the PInvoke assembly It happened for us when benchmarking a change in ASPNET MVC on a scenario that uses Jil While working with Sigil I noticed that LoadConstant is missing a overload that takes a ConstructorInfo I used to do this using the raw ILGenerator and it work So I added the overload and all tests basically they are just copied from the LoadConstantMethodInfo overload I also noticed that the documentation of OpCodesLdtoken here does not mention ConstructorInfo so this might also be outside the specs I was hitting an issue where dynamic methods created with doVerify set to true work while the same emitted instructions throw an InvalidProgramException when doVerify is set to false After checking the generated instructions I noticed that the readonly prefixes are added to the wrong instructions Example C emitLoadLocalmyLocal emitLoadConstant emitLoadElementDateTime CIL ldloc readonlyldci ldelema SystemNullable SystemDateTime or C emitLoadLocalmyLocal emitBranchIfTruemyLabel CIL ldloc readonlybrtrues label or C emitStoreElementDateTime CIL readonlystelem SystemNullable SystemDateTime I will debug further and hopefully will be able to submit a pull request once I have some more time available This fixes The IsAssignableFrom method wasnt accounting for the fact that you can assign a boxed struct to an interface Im not very familiar with the codebase so I dont know if this is the most effective way of fixing the bug although the tests do all pass Have a look at my code feedback very welcome Found this while debugging Jil emits virtual calls to IEnumerableTGetEnumerator csharp public struct MyStruct string ExampleMyStruct s sToString Looking at the above method in dotPeek I see a constrained callvirt on the address of the MyStruct argument IL ldargas s IL constrained MyStruct IL callvirt instance string mscorlib SystemObjectToString IL d ret Heres what I think is the equivalent Sigil csharp var obj typeofobject var myStruct typeofMyStruct var myDelegate EmitFuncMyStruct stringNewDynamicMethod LoadArgumentAddress CallVirtualobjGetMethodToString myStruct Return CreateDelegate This fails with a SigilVerificationException SigilSigilVerificationException CallVirtual expected a SystemObject found MyStruct at SigilEmit UpdateStackAndInstrStreamNullable instr TransitionWrapper transitions Boolean firstParamIsThis at SigilEmit UpdateStateOpCode instr MethodInfo method IEnumerable parameterTypes TransitionWrapper transitions Boolean firstParamIsThis Type arglist at SigilEmit CallVirtualMethodInfo method Type constrained Type arglist at ProgramMainString args in Programcsline Hi The function SigilNonGenericEmitCall ends up calling this overload of EmitNonGenericPlaceholderDelegateCall public EmitDelegateType CallMethodInfo method Type arglist null That overload is for already builded types and in fact the inner MethodBuilder object does not seems to like the call to GetParameters NotSupportedException Type has not beed created Is it possible to fix this calling the other overload of EmitNonGenericPlaceholderDelegateCall Thanks Hi I am using Sigil to generate runtime types initially it was running under CLR but when I started running the code under CLR I started getting IndexOutOfRange exception It seems to be due to an issue with the ToString method in the SignatureHelper class which is being called due to logging in BufferedIlGenerator Can this be fixed in Sigilis there a way to suppress logging so the ToString method on the signature helper is not called at all so that the exception is not thrown thank you Test included below to isolate the behaviour using System using SystemReflection using SystemReflectionEmit using SigilNonGeneric using SystemLinq using NUnitFramework namespace UnitTestProject TestFixture public class UnitTest Test public void WhyThrowOn Parameters for var i i i var failCount intMathPow i AssertDoesNotThrow CreateEmitfailCount CreateMethod AssertThrowsIndexOutOfRangeException CreateEmitfailCountCreateMethod AssertDoesNotThrow CreateEmitfailCount CreateMethod private static Emit CreateEmitint count var asm AppDomainCurrentDomainDefineDynamicAssemblynew AssemblyNameFoo AssemblyBuilderAccessRun var mod asmDefineDynamicModuleBar var t modDefineTypeT var foo tDefineFieldFoo typeofdouble FieldAttributesPublic var types EnumerableRange countSelectXunit typeofdoubleToArray var c EmitBuildConstructortypes t MethodAttributesPublic cLoadArgument cLoadArgument cLoadArgument cAdd for ushort i i count i cLoadArgumenti cAdd cStoreFieldfoo cReturn var cons cCreateConstructor var cp EmitBuildStaticMethodtypeofobject types t Create MethodAttributesPublic MethodAttributesStatic true false cpNewObjectcons types cpReturn return cp These are essential for consumers to know For instance in order to spill the stack Without IsReachable it is impossible for an emitter to know whether to emit instructions such as a return without doing their own redundant reachability tracking