Hi The code in doConnection has try catch on connectFunc and then on toResponse but the method toResponse invokes the parser callback from user so thats very bad Instead of only handling errors during connection it also handles errors in the user code without them being aware consider the following scenario Connection established correctly The parser not the connection function throws an IOException this gets caught and disappears No handling logging or propagation The parser is invoked once again This time the parser is passed the error stream which is null because the status code was the callback sees handles as success and blows up on null pointer exception The developer is very confused generally speaking IMO connectFunc should be wrapped in try catch the user callback should not have any catch but finally and stream cleanup is ok FYI Hi I started using this library to perform oauth with Bitbucket Server previously Stash The code I needed was pretty much the same you have but with some slight changes in the signature to use RSA with SHA Would you be willing to accept my contribution with this code If yes what would it be the best approach to support both signatures In sum it needs the header value to be changed and the signature code You can check the modified version here Once in scala sdk newer versions there is no Json utils anymore and scalajhttp can be a common dependency for those who are looking for a Json parser This change could be helpfull API methods for creating a PUT or POST request with a body from an javaioInputStream This way sending data is supported without loading it into memory first hi i want to connect the api which is secure by client certs and key data but im unable to find any information regrading how to create sslSocketFactory can you guys help Do you have plans for http pool support Propagate response body to RuntimeException to make sure the entire reponse is logged Logging usually revolves around getMessage whereas the current code only overrides toString via Scala case class This is the code I use to connect to a remote server val postUrl val response HttppostUrlheadersSeqXPIN XSensor sfijnstofreportidpostFormSeqP reportpm toString P reportpm toStringoptionHttpOptionsallowUnsafeSSLasString logdebugsLuftdaten response The response I get is a Forbidden with Reason The client software did not provide a hostname using Server Name Indication SNI which is required to access this server I tried setting SystemsetPropertyjsseenableSNIExtension true even though the underlying javanetHttpsURLConnection is said to default to true Is this a bug or am I missing something 