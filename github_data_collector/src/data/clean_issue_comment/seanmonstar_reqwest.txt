Hi Sean thanks for your hard work you build an awesome Http client I have encountered a problem when I used system proxy with reqwest The document claims reqwest doesnt need the explict system proxy setting system proxies are enabled by default System proxies look in environment variables to set HTTP or HTTPS proxies HTTPPROXY or httpproxy provide http proxies for http connections while HTTPSPROXY or httpsproxy provide HTTPS proxies for HTTPS connections What I struggle with is that I have explictly set the system proxy setting with rust export HTTPSPROXYsocks but reqwest still goes without proxy This is my code rust use stdenv extern crate log fn main Result Boxdyn stderrorError envloggerinit match envvarHTTPSPROXY Okproxy printlnproxy proxy Erre printlnCouldnt read HTTPSPROXY e let client reqwestblockingClientbuilder connectionverbosetrue build let mut res clientget copy the response body directly to stdout rescopyto mut stdiostdout Ok This is the output shell RUSTLOGreqwestdebug cargo run Compiling reqwesttest v privatetmpreqwesttest Finished dev unoptimized debuginfo targets in s Running targetdebugreqwesttest proxy socks T Z DEBUG reqwestasyncimplresponse Response OK for origin ip ip this is definitely not the ip of my proxy server Do I do something wrong or miss something I cant figure out why couldnt reqwest work with system proxy Request has a method bodymut which allows you to take the body out of the request but once you have the body you cant do anything with it Im trying to implement a library that computes a hash of the body contents to insert into the request as a header but thats only possible if I can await the aggregation of the body stream before the request is sent and then readd the body I could get around this by implementing my own RequestBuilder type that then produces a reqwest Request or RequestBuilder but Id rather not do that Hello With each sent request reqwest automatically inserts certain headers that are not given when you call requestheaders Expected behavior is that all headers whether automatically inserted or not would be retrieved when one calls requestheaders The reason these headers are not being added is because most of the automatic headers are being attached while the request is in flight approximately while a call of requestheaders happens before a request is sent I believe this is also the case for usergiven default headers Here is the list of potentially automatically inserted headers I found in the source Accept AcceptEncoding Host UserAgent ProxyAuthorization added only in certain cases Referer added only in certain cases Additionally even when you change the set of default headers the above headers can still be automatically inserted when the enduser changes the default set of headers with requestdefaultheaders they presume that they will be changing every default parameter and not have reqwest automatically insert different ones One solution I see would be to have the automatic headers be inserted into the requestheaders as right now the automatic headers are only inserted into ClientBuilderconfigheaders Code to reproduce rust use reqwest fn main let req Clientnew requestMethodGET Urlparse buildunwrap println reqheaders Output json Expected output json headers Accept AcceptEncoding gzip Host httpbinorg UserAgent reqwest from what I understand this isnt in Closes cc bluejekyll Im writing a crate in which I make a client which wraps the native reqwestClient The wrapper handles authentication and host selection so that the user can pass just the API endpoint like this rust async fn getthingclient myClient anyhowResultVecDevice clientgetv devices send await jsonVecDevice await maperranyhowErrorfrom The myClient internally has a base URL and calls join to add the userspecified path onto that base That function can return an error so my wrapper for get post etc has to return a ResultRequestBuilder Id rather just return the RequestBuilder with the error stashed in the request field inside the builder Can that be made public in some capacity I recognize exposing it as new might be a bit prominent for such a niche usecase If a requesttimeout is set creating a future for a request has to be called within a tokio runtime because it calls tokiotimerdelayfor This was surprising to at least one person who tried to build the Client and Request outside of an async context and then use tokioRuntimeblockon on the resulting Future Could it be possible to defer calling delayfor until the request future is first polled to allow the Request to be built outside an async context Is there any plan to support brotli or how to implement my own decoder and apply it Currently it seems as though the internal configuration uses an Arc and I would like to rotate a proxy on existing client and retain the cookiestore however it would require major internal changes Would it be possible to have a reqwestClient function to return the internal cookiestore if it is available and when building a reqwestClient be able to supply an existing cookiestore Added bytes function to blockingResponse akin to asyncimplResponse Rather than repeatedly calling if myerrorissomecase else if myerrorissomeothercase else I would rather just use rusts builtin ergonomic pattern matching on enums reqwest already has Kind so why not expose this to allow match myerrorkind or if let or any of the other pattern matching expressions