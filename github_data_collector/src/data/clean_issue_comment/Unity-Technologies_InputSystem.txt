Joining a PlayerInput through PlayerInputManager destroying it then joining again leaves the manager in a broken state where subsequent join attempts hit an assert and fail This only seems to happen when Join Behaviour is set to Join Players When Join Action Is Triggered and Join Action is set via reference The issue can be reproduced easily Add a PlayerInputManager to a game object set the Join Behaviour to Join Players When Join Action Is Triggered enable Use Reference in Join Action and set any action as the reference Create a prefab containing a PlayerInput and set this as the Player Prefab in the PlayerInputManager Press play trigger the set action to join Destroy the created PlayerInput prefab instance via scene hierarchy or script Attempt to join again by triggering the set action This will fail When adding a binding to an InputActionMap there is a check to make sure the bindings path is not null cs public static BindingSyntax AddBindingthis InputActionMap actionMap InputBinding binding if bindingpath null throw new ArgumentExceptionBinding path cannot be null nameofbinding In order to add a placeholder binding that will be bound later the path can be set to an empty string instead However if the asset or even just the map is cloned through json any empty strings in the bindings are converted to null when they are loaded This results in a map that has a binding with a null path which isnt supposed to be allowed cs Test public void AssetFromJsonHasValidBinding var asset ScriptableObjectCreateInstanceInputActionAsset var map new InputActionMapmap var action map AddActionaction InputActionTypeValue var binding new InputBindingstringEmpty action AddBindingbinding asset AddActionMapmap var asset InputActionAssetFromJsonasset ToJson AssertThatasset actionMapsCount var map asset actionMaps AssertThatmap bindingsCount AssertThatmap bindings path IsNotNull Also note that BindingSyntax will allow changing a binding in a map to have a null path using either the WithPath or To method Most usages of path or effectivepath are checking for null anyway so perhaps the restriction should just be removed from AddBinding This PR intends to address bugs arising from the current focus handling like eg a stuck alt key when alttabbing on Windows case It essentially replaces the previous focus handling with a much more nuanced mechanism When focus is lost in the player devices are reset A reset consists of sending a reset request to the backend like before but regardless of how the backend responds to that the input system will now perform an immediate reset of a devices state back to its default state Noisy controls are not touched and will remain at their current value This preserves sensor readings at their last value instead of snapping them back to default When ApplicationrunInBackground is enabled devices that return true from InputDevicecanRunInBackground will be exempted from resets and will be left alone Working on this I also found a couple bugs with noise masks and associated memory checks We really need mouse wheel to be usable as buttons The team already tagged this as REVIEW is there an easy work around till next release Best Line in Mousecs REVIEW have halfaxis buttons on the scroll axes up down left right c REVIEW have halfaxis buttons on the scroll axes up down left right summary Scrollwheel delta of the mouse summary valueScroll wheel deltavalue seealso crefMousescroll InputControldisplayName Scroll InputControlname scrollx aliases new horizontal usage ScrollHorizontal displayName Scroll LeftRight InputControlname scrolly aliases new vertical usage ScrollVertical displayName Scroll UpDown shortDisplayName Wheel FieldOffset public Vector scroll Hi Thank you very much for your time I know there are probably a lot of good reasons for the editors being defined as internal I would love if the PlayerInputEditor could be inherited from Here is my case There have been a considerable amount of times where Ive made things easier for myself by implementing a class that inherits from PlayerInput even though I had to implement its own editor because it can still be managed by the PlayerInputManager and it still can handle different users and maps Right now though I need to be able to inherit from the editor too to make an idea work Ive been making a package that implements among other things the idea of parameter references as ScriptableObjects proposed in the famous talk by Ryan Hipple Im adding the functionality of directly linking a parameter to an input action It would be awesome if I could add that functionality to a class that inhereits from PlayerInput it would be less clutter and I could make it more performant The thing is I want it to be useful to many users so I need the interface to look the same with some extras at the end as the normal PlayerInput that everyone uses in many different ways Only if I could inherit from the PlayerInputEditor I could guarantee that the interface is going to be consistent in the future plus it would be easier and cleaner So is there anyway it could not be internal Ill understand if its not possible Thank you very much for your time this package is awesome I hope you have a very nice day PS controller cant be detected in playstation Editor f InputSystem preview Project InputDeviceTester the GamePadcurrent is always none Hello Im experimenting with the new input system in making a little tank game To aim hte tank turret I use pointer mouse but I want to also support game pad and for me the best way to do so is to convert the Vector output of the game stick and using a custom processor I convert it to a screen pointer coordinate from the center of the screen using the camera using UnityEditor using UnityEngine using UnityEngineInputSystem if UNITYEDITOR InitializeOnLoad endif public class ToPointerPosition InputProcessorVector if UNITYEDITOR static ToPointerPosition Initialize endif RuntimeInitializeOnLoadMethod static void Initialize InputSystemRegisterProcessorToPointerPosition Camera mCamera public override Vector ProcessVector value InputControl control if mCamera null mCamera Cameramain valuex valuex mCamerascaledPixelWidth valuey valuey mCamerascaledPixelHeight return value This works great as long as I have only one main camera For local multiplayer with split screen I have no idea how to get the players camera from there Any idea on how to solve that use case I either need to access the camera from the processor or have a way when consuming the InputActionCallbackContext to figure out that im not processing a pointer vector but a stick vector When using the Tracked Pose Driver component on the latest package version I am having issues with XR controllers reconnecting Steps to reproduce Enter play mode with XR controllers enabled Disconnect one controller Reconnect that controller fails to receive any input Disable Enable the Tracked Pose Driver component to fix The issue is solved by disablingenabling the component in editor after attempting a reconnect however I have been unable to replicate that fix through code I am also having issues allowing the controller inputs to run in background The InputDevice object will point me to enable the behavior use see crefInputSettingsrunInBackground however the Input Settings so does not have a run in background option Hi I get an exception and a null reference when I press the buttons on a DualShock controller I have connected to my computer on a newempty scene using Player Input Manager Exception NullReferenceException thrown from state change monitor InputActionState on ButtonDualShock GamepadHIDbuttonSouth NullReferenceException Object reference not set to an instance of an object Unity version f InputSystem version preview Steps to reproduce Have a controller connected New scene add an empty gameobject Add Player Input Managerscript to the empty gameobject Change Join behavior to Join players when join action is triggered Check Use Reference Add InputActionReference asset My input asset is setup as Added an Action map Player added action JoinGame Set Action Type on the action to Button add Press Press Only interaction Add binding Button South Gamepad Play game and press the south button on the gamepad Errors occurs unityerrorinputsystem This PR significantly builds out the event recording and replay functionality of the system Rationale for doing this now One problem Im repeatedly having with bugs is that theres always the trickier bug where you need to be on some specific platform have some specific hardware run some specific project and perform some specific input for the problem to show For example we have a bug where key presses are getting lost In my debugging so far everything points to events but with the tools in the input system right now it requires laborious and tedious debugging to dig into problems like this So instead I want to be able to repro a problem once and to simply capture the repro such that I can replay it over and over and dissect it at will Even without being on the specific platform having the specific hardware running a specific project and definitely without trying to get the repro sequence just right which makes debugging no fun A side benefit is that it also addresses the question of how do I record and replay input which has repeatedly come up So two birds one stone kinda deal What can this do You record your input problem you senduploadpost the resulting trace file and I can debug your problem even without having anything else from you You have a BuzzFit Twitchomatic controller with the ChamferEdge Rainbow LED addon running on Linux and I dont No problem I can still repro your input What can this not do Trace back problems to before event generation ie to where the event sequence is already buggy But it can still at least clearly point in the direction What this adds A new InputRecording sample with a new InputRecorder MonoBehaviour in it Some additional controls to event traces in the input debugger A number of additions to the InputEventTrace API Buffers can be made growable now Can now capture frame markers to capture distribution of input over frames Can write traces to streamsfiles and load them from such Traces now capture information about the devices they capture events for including writing out entire device layouts as JSON for devices with autogenerated layouts this allows reproducing problems on HIDs without the original HID data being available Traces now have builtin replay functionality including the ability to replay the original frame distribution or to simulate original event timing