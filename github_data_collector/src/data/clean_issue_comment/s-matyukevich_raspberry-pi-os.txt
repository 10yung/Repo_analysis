Lets pretend timer interrupt occurs and we enter interrupt as one task and we want to exit it as new task created during execution of the first one el irq kernelentry bl handleirq kernelexit kernelentry macro will store registers including elrel and spsrel handleirq will perform task switching but kernelexit macro will try to load registers from stack but they were never written into it werent they And the second question regarding kernelentry and kernelexit macro if we perform task switching inside interrupt it seems we store and restore x x registers twice in cpuswitchto in el irq Or I misunderstand something Hello I would like to start on stuff like this as well but I dont know which IDE to use I used CLion before for my code in C and C but afaik it lacks assembly support Which IDE would you recommend I am using Windows but have a Ubuntu distribution as VM which I could use as well in case Windows isnt the best choice Definitely related to but I didnt want to reopen an older thread Ive completed lesson on my pi b and made the modifications mentioned in the above thread specifically Replaced the contents of configtxt with arm bit and then modified srcminiuartc to change the baud rate put AUXMUBAUDREG Ive verified my code against both this repo and vikash and it appears to match up But using putty I just get gibberish output I tried the serial monitor in my arduino app to see if theres a difference and its a little less muddled But it is still incorrect Everything Im seeing currently indicates this could just be attributed to the mini uart being tied to the GPU clock as compared to the PL uart Would that seem reasonable Im inclined to move forward asis if so I see the same behaviour when I tried to set to baud Is there anything else obvious I might be missing I am working on the second exercise of lesson and not really clear about the order of enabling UART Below is my order of setting different register to enable UART but this is not working to print any character c put UARTCR Disable the UART CR is control register put UARTLCRH Enable FIFO and bit in a frame to transmitreceive put UARTIBRD Set the Integer baud rate divisor put UARTFBRD Set the Fraction baud rate divisor register put UARTCR enable UART and enable UARTs Transmit and Receive Then I try to check the reference solution and all guys did like the following order c put UARTIBRD Set the baud rate divisor register put UARTFBRD put UARTLCRH Enable FIFO and bit in a frame to transmitreceive You will set the baud rate divisor registerIBRD FBRD first and then LCRT register the line control register I checkout the BCM ARM Peripherals manual but I can not find any section talking about the order of setting these register Can anyone share about why the order of enabling UART register is like this or any background knowledge to this order Thank you you mentioned when we enter el entry function the execution should be already at EL mode but int el getel printfException level d r n el the code shows it is exception level seems self contradiction also without calling svc how did you change the exception level from to thanks in advance I was trying to implement printing to real screen using the already made code found on this repo maybe someone can help me with this I just finished lesson and was wondering if the prochang endless loop that all nonprimary cores go into wouldnt put load on these three cores I was looking into the ARM documentation trying to find an instruction that basically disables a core and found wfe wait for event which will completely disable the clock for that core until an interrupt occurs I think that is a bit nicer than a loop So I suggest prochang wfe b prochang In the main while loopwe send char back which receive from host But I find that uart already got some chars before I send Did you think about UART booting to reduce wear of SD card and overall development speedup at least for developmentdebugging period When some new lessons will delight us Im reading lesson I can build the kernel and run it on my PI It works as expected two user task are started and I can get different message from them But I have a question When forking a user process in function copyprocess we need allocate kernel stack for new task and copy current tasks ptregs to new tasks ptregs curregs point to current tasks ptregs and childregs point to new tasks ptregs But why we use curregs childregs rather than childregs curregs Thanks for this tutorial I think it is much interesting than the OS class in college I really control the hardware and make it work rather than talking about many algorithms