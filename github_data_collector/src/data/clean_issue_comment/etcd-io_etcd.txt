A security risk that the private keyeg keyfile used for TLS is stored in plaintext exists in ETCD If an attacker obtains the key he can use the V interface to store some keyvalue data to the ETCD database This affects availability of the V database even though user authentication is enabled for the ETCD V database goetcdioetcdvendorgooglegolangorggrpcbalancerconnwrappersgo use of internal package googlegolangorggrpcinternalbuffer not allowed goetcdioetcdvendorgooglegolangorggrpcclientconngo use of internal package googlegolangorggrpcinternalresolverdns not allowed goetcdioetcdvendorgooglegolangorggrpcclientconngo use of internal package googlegolangorggrpcinternalresolverpassthrough not allowed What happened Load etcd with million B keys B values Using the data in the expected memory usage is MiB Results x worse than expected Actual MiB which stabilizes to MiB after a while Expected MiB After that do a single total range scan console ETCDCTLAPI etcdctl get prefix commandtimeout Memory usage immediately went up to Gi more than double I understand that the response is loaded in memory however the dataset size is only MB Is this expected After that we tried executing the above range scan continuously Memory grew to Gi and then capped there The queries are sequential so I am wondering why the heap memory isnt reused between responses After letting etcd cool off for some minutes the memory usage went back to MiB This seems highly irregular Is this something you would expect Is this behavior explained somehow What I expected to happen I would expect etcd not to consume so much memory Memory usage increased by MiB x times the dataset size for a single range query I would expect it to increase at most as much as the dataset size for the duration of the operation and then go back to normal For multiple sequential queries memory usage increased by GiB x times the dataset size I would expect the memory usage to remain the same as in the single range query scenario Environment Info Command console etcd datadir emptydir snapshotcount etcd version console etcd version etcd Version Git SHA d Go Version go Go OSArch linuxamd cc gyuho xiang This changes have started at etcdctl under authgo and make changes to stub out everything down into the internal raft Made changes to the proto files and regenerated them so that the local version would build successfully fixes changelog and readme are already updated Hello Im exploring raftexample project I cant understand how compactIndex calculates Can someone explain to me what the condition below means What difference between snapshotCatchUpEntriesN and raftNodesnapCount raftNodeappliedIndex is identifier of last applied entry to raft log it isnt Also I have questions about raftNodeentriesToApply method How it works Using go get goetcdioetcdtoolsbenchmark results in gosrcgoetcdioetcdvendorgooglegolangorggrpcbalancerconnwrappersgo use of internal package googlegolangorggrpcinternalbuffer not allowed gosrcgoetcdioetcdvendorgooglegolangorggrpcclientconngo use of internal package googlegolangorggrpcinternalresolverdns not allowed gosrcgoetcdioetcdvendorgooglegolangorggrpcclientconngo use of internal package googlegolangorggrpcinternalresolverpassthrough not allowed This has worked previously and is running on go version go linuxamd Is there any functionality in etcd raft library that allows randomly creation of cluster of nodes for a block that is proposed for block verification from majority of nodes in that particular cluster and canonical chain addition based on the particular type of transaction transaction may be classified on assetcommodity type that a block Here in this context block contains a particular assetcommodity type transactions only and nodes that form a cluster for block verification and canonical chain addition is subscribed for that particular type of assetcommodity type transactions only After this block is processed then the cluster should be dissolved and based on the client requests this process should be getting executed again from scratch By this approach i would like to add randomness in the nodes that are forming a cluster based on the location from where client request is getting initiated and forming cluster in the nearby nodes only rather than getting block verified in some other continent as per the existing raft mechanism and then propagating the verified block across the entire network Any leads to achieve this ideology will be really helpful to me Hoping for a favourable reply Thanks in advance bmizerany technoweenie freeformz when I use go get u goetcdioetcdclientv to install package I got this error goetcdio etcd vendor googlegolangorg grpc balancerconnwrappersgo use of internal package googlegolangorggrpcinternalbuffer not allowed goetcdio etcd vendor googlegolangorg grpc clientconngo use of internal package googlegolangorggrpcinternalresolverdns not allowed goetcdio etcd vendor googlegolangorg grpc clientconngo use of internal package googlegolangorggrpcinternalresolverpassthrough not allowed Signedoffby qupeng qupengpingcapcom Cleanup code about read index extracted from 