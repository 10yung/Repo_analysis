Hello Im using the PYOIDC library which is used to handle OpenID Connect authorization workflow It includes a special session state which stores RSA keys By default the library uses Pythons native dictionary object to store the keys but its not persistent Trying to serialzie the session state raises a PicklingException app state objgetstate app File usrlocallibpython sitepackagesCryptodomePublicKeyRSApy line in getstate app raise PicklingError app picklePicklingError Can you share some insight on why is the public key not serializable To my knowledge public keys are just plain bytearrays or Base encoded strings in which case they could be serialized just fine Using pycryptodomex import CryptodomeSelfTest CryptodomeSelfTestrun Fails with Skipping AESNI tests Skipping test of PCLMULDQD in AES GCM Traceback most recent call last File stdin line in module File projdigig sjc develwakefordcrypotn tbbtrunktbcspythonliblibpython sitepackagesCryptodomeSelfTestinitpy line in run result runnerrunsuite File usroptpmcpythonpython x libpython unittestrunnerpy line in run selfstreamwritelnresultseparator File usroptpmcpythonpython x libpython unittestrunnerpy line in writeln selfwritearg TypeError a byteslike object is required not str import os from CryptoCipher import AES Key osurandom Iv osurandom encryptionsuite AESnewKey AESMODECBC Iv printencryptionsuitedecryptencryptionsuiteencrypta The above code prints a garbage first block python tmpbugpy b xbd x xb xa xb x xf A xe xe l x eLaaaaaaaaaaaaaaaa i believe its because decrypt call is assuming the Initialization vector is not present and creating a new one resulting in a garbage first block import os from CryptoCipher import AES Key osurandom Iv osurandom encryptionsuite AESnewKey AESMODECBC Iv decryptionsuite AESnewKey AESMODECBC Iv printdecryptionsuitedecryptencryptionsuiteencrypta The second code prints the plain text properly After the issue and the merged pullrequest updating the docs the changes have yet to be mirrored online at This will only take the readthedocs account holder a second or two to initialize Example code usrbinpython from hashlib import sha from CryptodomeHash import SHA import time initialdigestbtesttesttesttesttest iterations digestinitialdigest start timetime for counter in rangeiterations digestsha digestdigest end timetime print Time hashlib sha t end start digestinitialdigest start timetime for counter in rangeiterations digestSHA newdatadigestdigest end timetime printTime cryptodome sha t end start digestinitialdigest start timetime MySHA SHA new for counter in rangeiterations digestMySHA datadigestdigest end timetime printTime cryptodome sha t end start Output on my computer valentincomputerpythontest testsha py Time hashlib sha Time cryptodome sha Time cryptodome sha valentincomputerpythontest testsha py Time hashlib sha Time cryptodome sha Time cryptodome sha valentincomputerpythontest testsha py Time hashlib sha Time cryptodome sha Time cryptodome sha valentincomputerpythontest Is this because of Cryptodome using more object oriented approach Or the underlying implementation of the algorithm is somehow inefficient how can i install this without using pip im sure everyone in the python world uses pip but Darwin is being an ass plus it restricts the ability for my code to be portable any advice on how to get past the Traceback most recent call last File UsersandrewDocumentsGitHubLibrepycryptodomesetuppy line in module with openospathjoinlib packageroot initpy as initroot FileNotFoundError Errno No such file or directory libCryptoinitpy error when running as setuppy as sudo Thanks for your help Hello Im try to use Encrypt a large file but try to decrypt this file got a error I tried to encrypt decrypt a byte txt file it working perfectly but tried a mb file get the error text unpadcryptordecryptdata File C Python Python lib sitepackages Crypto Util Paddingpy line in unpad raise ValueErrorPadding is incorrect ValueError Padding is incorrect import os import hashlib import binascii from CryptoCipher import AES from CryptoUtilPadding import pad unpad def aesdecodedata key cryptor AESnewkey AESMODECBC key text unpadcryptordecryptdata return text return textrstripb decodeutf def aesencodedata key cryptor AESnewkey AESMODECBC key text cryptorencryptpaddata return text def encryptbyaesfilepathnewfilepathpassword aespass password aeskey hashlibmd aespassencodeutf hexdigest printaeskey aeskey binasciiunhexlifyaeskey if ospathexistsnewfilepath osremovenewfilepath file openfilepath rb filesize ospathgetsizefilepath CHUNKSIZE while filetell filesize data filereadCHUNKSIZE if data with opennewfilepath ab as f fwriteaesencodedata aeskey else break printencode s OK filepath def decryptbyaesfilepathnewfilepathpassword aespass password aeskey hashlibmd aespassencodeutf hexdigest printaeskey aeskey binasciiunhexlifyaeskey if ospathexistsnewfilepath osremovenewfilepath file openfilepath rb filesize ospathgetsizefilepath CHUNKSIZE while filetell filesize data filereadCHUNKSIZE if data with opennewfilepath ab as f fwriteaesdecodedata aeskey else break printencode s OK filepath encryptbyaesLICENSEtxtLICENSEtxt decryptbyaesLICENSEtxtLICENSEtxt Made the following changes after running into performance issues with Shamir Secret Sharing For split use Horners method which uses only a single multiplication by a small number in our case instead of multiplications including one between two potentially large numbers For largeish k and n this is significant I tested with n and k and split now takes s instead of s on my system There are faster algorithms for evaluating a polynomial on many points at once but that would require a lot more changes and might not be worth it for smaller parameters For combine separately compute numerator and denominator to avoid expensive modular inverse computations Doing it this way requires k times less inversions I also removed the coeff l and inv variables I cant imagine why they were here in the first place since they just cancel each other On my system for n and k this brings down computation time from s to ms and makes it possible to use n I checked that this returns the same shares as before for the same random coefficients in reverse order Hello When loading a privkey using RSAimportkey the exception raised is ValueError either if the content isnt a valid RSA key OR if it is a RSA key but encrypted and wrongno passphrase was provided The only way to programmatically determine which of those situations is happening is to parse the Exception string value which should be avoided at all cost considering internationalization and such It would be great to define and raise custom exceptions when relevant so that it is possible to determine what the problem is without having to parse strings I had a project which imported and used Pycryptodome But I had to make executable for Windows and used PyInstaller to do so PyInstaller generated a very big exe file MB due to the fact that by importing Pycryptodome it also had to import numpy scipy and a lot of big dependencies I switched from Pycryptodome to cryptography which doesnt seem to use so much dependencies and the resulting file is much smaller MB while libraries such as numpy and scipy are not included Are those big dependencies absolutely necessary for Pycryptodome