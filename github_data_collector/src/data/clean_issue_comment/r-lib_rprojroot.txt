I am getting unexpected behavior from hasdirname as a criterion Reproducible example Consider this reprex r if direxiststmp dircreatetmp if direxiststmpfoo dircreatetmpfoo if direxiststmpboohoo dircreatetmpboohoo if direxiststmpfoobar dircreatetmpfoobar crit rprojroothasdirnamefoo p rprojrootfindrootcriterion crit path tmpfoobar p CUsersusernameAppDataLocalTempRtmpmmXvM reprex e tmpfoo crittestfun tmpfoo TRUE pastep is the root because rprojrootgetrootdesccrit p CUsersusernameAppDataLocalTempRtmpmmXvM reprex e tmpfoo is the root because directory name is foo crit rprojroothasdirnameboohoo p rprojrootfindrootcriterion crit path tmpfoobar p CUsersusernameAppDataLocalTempRtmpmmXvM reprex e tmpfoo crittestfun tmpfoo TRUE pastep is the root because rprojrootgetrootdesccrit p CUsersusernameAppDataLocalTempRtmpmmXvM reprex e tmpfoo is the root because directory name is boohoo unlinkctmpfoobar tmpfoo tmpboohoo tmp supCreated on by the reprex package v sup Expected behavior The documentation says The hasdirname function constructs a criterion that checks if the basedirname has a specific name This makes it sound as though the function is checking whether the parent node of the candidate path basedirnamepath has a given name On the other hand getrootdesc says that tmpfoo is a root because directory name is boohoo which makes it sound like the criterion is that the leaf node of the candidate path basebasenamepath has a given name The documentation and the output from getrootdesc are confusing and seem inconsistent with each other But in either case based on the documentation and the output from getrootdesc I would expect findrootcrit tmpfoobar to fail with an error message when crit is hasdirnameboohoo and for crittestfun tmpfoo to return FALSE Actual behavior However the criterion really checks whether the parent node has a child with the given name This means that a directory can fulfill the criterion if it has a sibling with the specified name as in the example above tmpfoo and tmpboohoo are siblings and tmpfoo satisfies the hasdirnameboohoo criterion and findroothasdirnameboohoo tmpfoobar succeeds and returns tmpfoo instead of failing as I would expect and hasdirnameboohootestfun tmpfoo returns TRUE instead of the expected FALSE Possible remedies Update Documentation for hasdirname If this is the desired behavior then it would be good to make the documentation clearer and perhaps provide an example to illustrate the behavior Change behavior of hasdirname If it is not the desired behavior then changing the testfun from functionpath direxistsfilepathdirnamepath boohoo to something like functionpath basenamedirnamepath boohoo With this latter function tmpfoobar would satisfy hasdirnamefoo and tmpfoo and tmpboohoo would both satisfy hasdirnametmp but tmpfoo would not satisfy hasdirnameboohoo and tmpboohoo would not satisfy hasdirnamefoo Alternately another possible interpretation of the intended behavior would be functionpath direxistspath basenamepath boohoo In this case tmpfoo would satisfy hasdirnamefoo and tmpboohoo would satisfy hasdirnameboohoo but tmpfoo would not satisfy hasdirnameboohoo Session Info R version Platform x w mingw x bit Running under Windows x build Matrix products default locale LCCOLLATEEnglishUnited States LCCTYPEEnglishUnited States LCMONETARYEnglishUnited States LCNUMERICC LCTIMEEnglishUnited States attached base packages stats graphics grDevices utils datasets methods base other attached packages rprojroot loaded via a namespace and not attached compiler backports tools packrat Per discussions with krlmlr this functions commit were migrated to whereami for easier discoverability Just realised we have the tidytemplate applied to rprojroot and here packages which are in fact rlib packages I believe the package should import knitr I installed rprojroot on a new machine and tried to run thisfile but had the following error message thisfile Loading required namespace knitr Failed with error there is no package called knitr I installed knitr manually and then thisfile worked I know this is small and happy to provide this as PR bur there are occasions when it would be nice to test for a root without getting the error that findroot throws It could be as simple as findrootsafe function x NULL try x findroot silentTRUE returnx for consistency on Windows like fspathhome does CC jimhester Forward slashes work just fine on Windows in the majority of cases Windows users might be tempted to use backslashes but this might cause problems further down the line Should we warn if a user attempts to create a path with a backslash r hereherea b rprojrootisrpackagea b CC jennybc This turned out to be more involved than I expected as there were some core assumptions in the code about vectors of testfun desc being for or logic I refactored quite a bit such that testfun is always a single function and desc is always a single string and the operators do a bit more work but not much to make that happen I think it makes things more extensible but it also may not be doable without potentially breaking things that others have done If so glad to look at alternate solutions The other downside is that the format output could not be so pretty so easily as nesting of with at multiple levels would not be easy to deal with I opted instead for very simple formatting Root criterion contains a directory src and contains a directory reports Nice use of would love to test with Seems simple enough I can try a PR if it would be reviewed