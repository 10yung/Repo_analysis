 Neat masking demo by jpsarda from an email make two mesh nodes add them next to each other add some triangles do some stuff Later make the second one invisible without changing its data and calling MarkChanged it ignores the isVisible change to false I havent fully traced it through but it might be that the mesh node needs the call to MarkChanged to make it repopulate the render layer and respect the isVisiblevisibleScale change in FNode Without tracing it all some dirty flags somewhere are getting stomped I suppose or the order of all the population stuff doesnt quite work for mesh nodes I can force a MarkChanged on the second meshnode when I want to set it invisible and then it works fine If you stop a delayed while callback are processed it changes the array that is currently browsed and can make weird things or crashes My solution was to postpone the removing of the delayed call back like this public void StopDelayedCallAction func int count delayedCallbacksCount for int d dcount d FDelayedCallback call delayedCallbacks d ifcallfunc func delayedCallbacksToRemoveAddcall private void ProcessDelayedCallbacks foreach FDelayedCallback callToRemove in delayedCallbacksToRemove delayedCallbacksRemovecallToRemove same code after this If I already have an audio listener in the scene I dont need another although this class is very handy to play sounds just writing code could it be possible to avoid the audiolistener creation maybe setting some static variable or in fparams I believe Ive already fixed this in unstable but its worth checking just in case below is from an email The next little problem with buttons is the enabled state I made some buttons and disabled them but they still responded to touches The initial HandleSingleTouchBegan has a check for the enabled state and if the hitrect is valid but the button is disabled the button swallows the touch by returning true but doesnt process the down state etc All good The problem is that because of the return true to swallow that first touch event the following touch events for movement and ended get sent to the button but theres no further checks for the enabled state in the handlers so they just go about their business which means they show a down state and then trigger a pressed event as normal I added a line at the top of HandleSingleTouchMoved and HandleSingleTouchEnded to bail out if the button is disabled if isEnabled return The over handler also breaks if the button is disabled as well Im not using it but I quickly edited UpdateOverState and used the following in the hitrect check if isEnabled hitRectContainsmousePos over stuff ShoeBox saves the space character as a literal space instead of space like every other BMFont tool does which means it breaks the FFont parser because the BMFont format is spacedelimited See this for more info This will allow you full control of a matrix if needed Also note the didSetMatrix flag which could maybe be inverted and renamed to something like shouldCalculateMatrix MattRix thanx for futile it is really awesome simple and powerful I had naming conflits other libraries that declared an FMatrix class also although namespaced Wouldnt be a good idea to namespace the whole lib I did it with FMatrix namespace FutileEngine and added a using FutileEngine line on top of the files that required it and solved the conflict anyway See 