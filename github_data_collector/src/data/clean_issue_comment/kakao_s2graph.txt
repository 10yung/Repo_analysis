Add util class DeferCache T to generalize future cache a little bit and change fetch method and reflect callerAsynchbaseQueryBuilder to use this util class instead of manually mutating guava cache since toEdge is called lots of times we think it is worth to optimize This is what daewon reported based on profile we can notice that toMap on list and on two list takes many cpu time on toEdge we can avoid toMap and by using mutable map and give up functional style here I think code looks uglynot too bad but we can remove unnecessary cpu usage I would be minor tuning but toEdge is called many many timescalled once on every fetched edges PR to master now our master is same with apache master Add feature manually cache update first trial The hbasesitexml of our configuration has the zookeeperznodeparent property becuase we operate the multiple HBase clusters in one zookeeper cluster Can you support zookeeperznodeparent property in referenceconf Thank you Ratio value in their service is common use cases of service analysis Known methods to calculate ratio is that divide values between counting data or aggregating values Already S Graph query supports counting or aggregating values within S Graph storage With S Graphs function you can calculate ratio just dividing values That is an easy way to calculate the ratio However it can be a more simple way to calculate the ratio It is that calculation occurred in S Graph web application with just one RPC one graph query call This is a suggestion of the ratio calculation query If we suppose to have two labelsimpression feedbacks label and click feedbacks label we can get a number of impressions and a number of clicks by a user Using two value we can calculate CTRClick Through Rate with below two count query Impression query srcVertices serviceName someservice columnName userid id usera steps step label impressionfeedbacklabel direction out offset limit Click query srcVertices serviceName someservice columnName userid id usera steps step label clickfeedbacklabel direction out offset limit After fetching each result with upper queries we can get a CTR However we can make a one query with divide operation to scorePropagageOp limit groupBy from duplicate sum srcVertices serviceName someservice columnName userid id usera steps step label impressionfeedbacklabel direction out offset limit groupBy from duplicate countSum transform from step label clickfeedbacklabel direction out offset limit scorePropagateOp divide scorePropagateShrinkage There is another query param option key scorePropagateShrinkage It is used to try normalizing results We use just ratio value to sort the results However ratio value can be nondeterministic Ratio by is larger than by For this reason we can add scorePropagateShrinkage score value which is sufficiently big to the denominator Now we can recalculate by and then the latter is larger value just fixed a typo that I found while reading introduction step to reproduce create service curl XPOST localhost graphscreateService H ContentType Applicationjson d serviceName s graphtest create label curl XPOST alphas graphdaumkakaoio graphscreateLabel H ContentType Applicationjson d label friend srcServiceName s graphtest srcColumnName userid srcColumnType string tgtServiceName s graphtest tgtColumnName userid tgtColumnType string indices props serviceName s graphtest consistencyLevel strong insert test data curl XPOST localhost graphsedgesinsert H ContentType Applicationjson d timestamp from c f to cc ad f label friend delete above relation curl XPOST localhost graphsedgesdelete H ContentType Applicationjson d timestamp from c f to cc ad f label friend select index edges curl XPOST localhost graphsgetEdges H ContentType Applicationjson d srcVertices serviceName s graphtest columnName userid id c f steps step label pathfriend direction out offset limit this gives no edges which is expected with to specified then it gives deleted edge curl XPOST localhost graphsgetEdges H ContentType Applicationjson d srcVertices serviceName s graphtest columnName userid id c f steps step label pathfriend direction out offset limit to cc ad f I think after delete operation finished there should be no edge left even with to option Many duplication code exists QueryExperiment controller and Netty Rest handler So extract common functions to some modulelike RestUtil RestServerPlay Netty should call graph functions through restUtil layer RestUtil layer only return FutureFailure Succesuful for handling exception one way 