Unnamed lists can now be overriden by another config section fix When I use sequences of mappings in YAML format see example on I cant override this array in another config section Sequences of mappings from YAML are represented as unnamed lists in R Here is a simple example section values are not overriden with conf r libraryyaml librarytidyverse Warning package ggplot was built under R version Warning package tidyr was built under R version Warning package dplyr was built under R version conf yamlyamlload param param section param test param params section key value test key value test key value test conf yamlyamlload param section param testoverride param section key value test key value test configmergeconf conf glimpse List of param int section List of params int param chr testoverride param int section List of List of key int value chr test List of key int value chr test List of key int value chr test param int supCreated on by the reprex package v sup The attrconfig always points to the name requested regardless of inheritance or use of the default value If inherited then there is the inherits value in the list but if the name is not found then the default entry is returned with no indication that it is being used Short of using namesyamlyamlloadfile is there a way to determine if the named account is not present r configgetconfig file authfn useparent FALSE inherits localpg attrconfig attrfile C Users r configyml Perhaps something like attrdefaultused TRUE could be a simple start An extreme solution might provide a vector of inherited names yaml default user joe bob user bob def inherits bob def inherits def def inherits def r configgetconfig def file authfn useparent F user bob inherits def attrconfig def attrfile C Users r configyml attrinherited def def bob I realize having the default value is important and that one intent is for it to always return something if the file is present and the file is structured correctly with at least a default entry Im not suggesting changing that My team is successfully using config to stay on top of different client configurations and were loving it Especially the inheritance feature is awesome and saves a lot of typing Now we were wondering if there is any way to specify values that are referencing other values within the same YAML script The use case behind it is to have a single point of truth for all configs as opposed to defining dynamiclinked configs in some other R functions where they might easily be overlooked at some point We thought about something like production trials cores expr configgettrials or ideally production trials cores expr trials Reproduction steps Create a new rmarkdown document or shiny application containing the following r libraryconfig c configget catpastecfoo configisactiveirrelevant Create a new configyml file in the contents folder yaml default foo bar development foo development irrelevant foo expr BRRRskrrrahhsound Run the content Expected Standard output contains bar or development if RCONFIGACTIVE is set to development followed by FALSE Actual Error in loadNamespacename there is no package called BRRR Now install using devtoolsinstallgithubbrookewatsonBRRR Run the content Expected quiet Actual Gucci Mane is played through the speakers irrespective of RCONFIGACTIVEs value bar or development is printed followed by FALSE proving that irrelevant is not the config selected Would you be openinterested in a PR introducing new YAML types for encrypted config values See eg Image source Although that only supports Amazon KMS for now but extending it with new types would be similarly easy This way I could drop the custom functions from my dbr pkg and use config Given that there isnt a global standard for yml file structures this should not be a dependency for reading a config file Id suggest replacing line with defaultconfig configyaml config to have it check for the presence of the specified config in the case that RCONFIGACTIVE is specified as a value other than default or that a user specifies a config in the function call While this would work I think rewriting that block to more specifically check for config as defined in the function call default or otherwise as this step pretty intently looks strictly for default Also the documentation specifies RCONFIGNAME as the environment variable It looks like this feature was not fully implemented in jjallaires branch Happy to attempt to make this change Ive managed to change all function names so I can use them without clash problem with baseget and basemerge functions Im aware that this changes break the package usage but I thought it was a change worth sharing with upstream Even in R studio using this package is problematic in loaded inside an rprofile Ive also found a little bug in directory navigation under Linux and R The fixes is included in this pull request If you prefer I can commit that separately This causes R to produce the error Error during wrapup evaluation nested too deeply infinite recursion optionsexpressions and then get stuck in an infinite error producing loop with the error Error in yamlloadpastereadLinesinput encoding UTF collapse n This is not unexpected but it would be nicer if the get function could handle this situation and return myconfigvalue instead of producing an error Better yet would be special syntax like myconfigvalue to tell expr to look for this value in the same configyaml file This feature might be overkill though Im not sure if this is a good idea but Ill throw it out here What if configget could take named dots arguments and evaluate them in expr expressions in configyml files This would provide a useful way to add context dependence to configuration without using environment variables A practical example sparklyrsparkconnect calls sparklyrsparkconfig which in turn calls configget Say you wanted to specify Spark configuration parameters in configyml but make them dependent on the master argument to sparkconnect If the master argument was passed through in the dots to configget then you could have a configyml file like this yaml default somesetting expr ifelsemaster local foo bar 