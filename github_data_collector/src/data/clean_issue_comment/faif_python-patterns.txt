I think listing antipatterns with some basic reasoning about why not is a good idea Example singleton Although has wont fix label it is in PRs section and people if searching history at all are searching issues first it was misspelled Singelton instead of Singleton therefore impossible to find Listing most popular antipatterns without actual implementation should allow people to find the name from readme immediately assume it wasn just missed by mistake see why it is not welcome for python projects As far as I know almost always coverage is used to see test coverage For unused branchesvariables etc there are linters deadcode finders such as vulture or dead So I dont think code coverage is important to extent of running runallsh script I would like to remove runallsh collect coverage only for tests only for one python branch eg although it is possible to do coverage run p and then coverage combine update on idea of testing outputs as docstrings eg with python m doctest I couldnt find easy way to generate docstrings for def main By testing outputs I mean to compare script output with OUTPUT section at the bottom of the file Structuring scripts like that def main if name main main allows imports of main in tests to evaluate and compare outputs It would also be more convenient to have OUTPUT section as variable or docstring so we do not need to parse file for such comparisons A common pattern is page object model and loadable component I have a source code with them Would you accept PRs about functional programming patterns faif Would probably imply some project restructuring eg putting dirs behavioral and structural into oop I havent checked if any of the examples is simply completely copied from the web when it would need to retain original copyrightlicense notice or all of them could be claimed to be owned by contributors to this repository but the point is that there should some clear statement on copyrightlicenses for the files and possibly for the collection as a whole as well tierpy and mvcpy are almost identical from a high level point of view The only difference is that in tierpy the logic instance and the ui instance may be assigned to the data instance explicitly In mvcpy the model instance and the view instance is assiged to the controller instance statically during its creation 