Upon resizing the X window I get black bars around the rendered scene the scene sometimes snapping to the lower andor bottom window edge sometimes staying exactly where it is Scene renders as expected judging by glFragCoord still saying that pixels are pixels that is Some abbreviated es info EGLVERSION Midgardr p rel EGLVENDOR ARM EGLCLIENTAPIS OpenGLES GLVERSION OpenGL ES v r p rel git ed f c cb d ceb e be e c GLRENDERER MaliT Thats an rk chip running Armbian in particular a NanoPCT and Ubuntu LTS using the media scripts to get at the binary driver blob and thus OpenGL ES via EGL under X Now the hardware can do vulkan but rockchip isnt releasing any drivers for that thats a whole another issue Im calling resize on the context as intended however thats bound to do nothing as the call is blackholed in platformimplunixmodrs for X contexts Quoth Khronos on eglSwapBuffers Native Window Resizing If the native window corresponding to surface has been resized prior to the swap surface must be resized to match surface will normally be resized by the EGL implementation at the time the native window is resized If the implementation cannot do this transparently to the client then eglSwapBuffers must detect the change and resize surface prior to copying its pixels to the native window If surface shrinks as a result of resizing some rendered pixels are lost If surface grows the newly allocated buffer contents are undefined The resizing behavior described here only maintains consistency of EGL surfaces and native windows clients are still responsible for detecting window size changes using platformspecific means and changing their viewport and scissor regions accordingly which if Im reading that correctly makes the behavior ARMs fault They should be resizing the surface on their end in libMaliso where egl lives OTOH other eglbacked apps Im running do resize properly which leads me to believe that context libraries that arent glutin happen to be working around this issue The new releases of winit and glutin use different versions of parkinglot and Can glutin get an update with the new version of parkinglot The pull request prevents Glutin from creating windowed contexts on systems that do not have vsync extensions It fails even if vsync is set to false CreationErrors NoAvailablePixelFormat OsErrorCouldnt find any available vsync extension In my opinion instead of throwing an error at modrsL we shall ignore vsync if there are no available extensions Here is an example of such limited system name of display display screen direct rendering Yes server glx vendor string Parallels Inc server glx version string server glx extensions GLXARBgetprocaddress GLXEXTtexturefrompixmap GLXSGIXfbconfig client glx vendor string Parallels Inc client glx version string client glx extensions GLXARBgetprocaddress GLXEXTtexturefrompixmap GLXSGIXfbconfig GLX version GLX extensions GLXARBgetprocaddress GLXEXTtexturefrompixmap GLXSGIXfbconfig OpenGL vendor string Parallels and ATI Technologies Inc OpenGL renderer string Parallels using AMD Radeon Pro OpenGL Engine OpenGL version string ATI OpenGL shading language version string OpenGL extensions GLARBcolorbufferfloat GLARBdepthbufferfloat GLARBdepthclamp GLARBdepthtexture GLARBdrawbuffers GLARBdrawelementsbasevertex GLARBdrawinstanced GLARBfragmentprogram GLARBfragmentprogramshadow GLARBfragmentshader GLARBframebufferobject GLARBframebuffersRGB GLARBhalffloatpixel GLARBhalffloatvertex GLARBimaging GLARBinstancedarrays GLARBmapbufferrange GLARBmultisample GLARBmultitexture GLARBocclusionquery GLARBpixelbufferobject GLARBpointparameters GLARBpointsprite GLARBprovokingvertex GLARBseamlesscubemap GLARBshaderobjects GLARBshadertexturelod GLARBshadinglanguage GLARBshadow GLARBshadowambient GLARBsync GLARBtextureborderclamp GLARBtexturecompression GLARBtexturecompressionrgtc GLARBtexturecubemap GLARBtextureenvadd GLARBtextureenvcombine GLARBtextureenvcrossbar GLARBtextureenvdot GLARBtexturefloat GLARBtexturemirroredrepeat GLARBtexturenonpoweroftwo GLARBtexturerectangle GLARBtexturerg GLARBtransposematrix GLARBvertexarraybgra GLARBvertexarrayobject GLARBvertexblend GLARBvertexbufferobject GLARBvertexprogram GLARBvertexshader GLARBwindowpos GLATIseparatestencil GLATItextureenvcombine GLATItexturefloat GLATItexturemirroronce GLEXTabgr GLEXTbgra GLEXTbindableuniform GLEXTblendcolor GLEXTblendequationseparate GLEXTblendfuncseparate GLEXTblendminmax GLEXTblendsubtract GLEXTclipvolumehint GLEXTdepthboundstest GLEXTdrawbuffers GLEXTdrawrangeelements GLEXTfogcoord GLEXTframebufferblit GLEXTframebuffermultisample GLEXTframebufferobject GLEXTframebuffersRGB GLEXTgeometryshader GLEXTgpuprogramparameters GLEXTgpushader GLEXTmultidrawarrays GLEXTpackeddepthstencil GLEXTpackedfloat GLEXTprovokingvertex GLEXTrescalenormal GLEXTsecondarycolor GLEXTseparatespecularcolor GLEXTshadowfuncs GLEXTstenciltwoside GLEXTstencilwrap GLEXTtexture D GLEXTtexturearray GLEXTtexturecompressiondxt GLEXTtexturecompressions tc GLEXTtextureedgeclamp GLEXTtextureenvadd GLEXTtextureenvcombine GLEXTtexturefilteranisotropic GLEXTtextureinteger GLEXTtexturelodbias GLEXTtexturemirrorclamp GLEXTtexturerectangle GLEXTtexturesRGB GLEXTtexturesharedexponent GLEXTtransformfeedback GLEXTvertexarraybgra GLNVblendsquare GLNVconditionalrender GLNVdepthclamp GLNVfogdistance GLNVlightmaxexponent GLNVtexgenreflection GLNVtexturerectangle GLSGISgeneratemipmap GLSGIStextureedgeclamp GLSGIStexturelod GLSGIcolormatrix GLX Visuals visual x bf lv rg d st colorbuffer sr ax dp st accumbuffer ms cav id dep cl sp sz l ci b ro r g b a F gb bf th cl r g b a ns b eat x tc r y None x dc r y None x tc r y None x dc r y None GLXFBConfigs visual x bf lv rg d st colorbuffer sr ax dp st accumbuffer ms cav id dep cl sp sz l ci b ro r g b a F gb bf th cl r g b a ns b eat x dc r y None x dc r y None x dc r y None x dc r y None x tc r y None x tc r y None x tc r y None x a tc r y None x b dc r None x c dc r None x d dc r None x e dc r None x f tc r None x tc r None x tc r None x tc r None Its possible to use a single OpenGL context to render to multiple windows on Windows and X at least see this post It would be cool if Glutin supported that usecase although its not entirely clear to me what the API design for that would look like Its been on my mind on and off the past few years now though and I figured itd be useful to officially put down that its a thing we could do The method name and documentation implies that display lists are the only objects that get shared between contexts which very much isnt the case You seem to be able to share most noncontainer objects between contexts so we should rename the function to reflect that and link to that wiki page This adds basic support for android to glutin The android build failure is due a too old version of cargoapk the docker image needs to use Im wondering if it would make sense to have a sample on how to force software rendering using glutin Basically my dream is that glutin does not need to depend on a particular version of winit it just does the OpenGL context setup and winits windowing and event loop and stuff is all independent of it glutin just takes a rawwindowhandle and does its magic Per conversations on Discord this is Tricky cause on some platforms the OpenGL context setup needs to happen at window creation time you cant create a window and then throw an OpenGL context into it later So glutin would need to create a window and then pass its rawwindowhandle to winit for it to do its magic For my purposes this seems fine and apparently bullet point in this issue has similar problems so this may be something we want to do anyway Supersedes as the diff was getting cluttered Examples updated Implemented for Windows EGL Windows WGL x X EGL X GLX x Wayland EGL x OSMesa MacOS iOS Android Waiting on Tested for Windows EGL Windows WGL X EGL X GLX Wayland EGL MacOS iOS OSMesa Android Waiting on will be solved by adding stuff to platattrs for x and windows How the Raw extensions will work I have yet to decide but Ill shoe horn something in once we got it more fleshed out How could I write a array of u values to the frame buffer