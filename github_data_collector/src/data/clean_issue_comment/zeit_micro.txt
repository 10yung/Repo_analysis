The tests in the readme section Testing doesnt seem to work js const http requirehttp const micro requiremicro const test requireava const listen requiretestlisten const request requirerequestpromise testmy endpoint async t const service new httpServermicroasync req res microsendres test woot const url await listenservice const body await requesturl tdeepEqualJSONparsebodytest woot serviceclose Is this still the recommended approach Also time to release a new version Its been ages since Src js const buffer requiremicri moduleexports async req res const body await bufferreq consolelogbody return txh Input bash curl d ewfewfw curl H ContentType applicationjson charsetutf d ewfewfw Output Buffer ewfewfw This seems to be related to how rawbody is used in buffer If processexit is not called explicitly the server is still waiting a kill signal Closes Add nowjson to deploy for Now socketio doesnt works on Now Hello every time i close the my server run with nicro it remains alive in the background even if it prompt gracefully exiting how can i achieve a complete shutdown of the app I can see in the micro bin code that youre juste caching the process exit event and logging a consolelog is this enough function registerShutdownfn let run false const wrapper if run run true fn registerShutdown consolelogmicro Gracefully shutting down Please wait processonSIGINT wrapper processonSIGTERM wrapper processonexit wrapper img width altScreenshot at src img width altScreenshot at src The idea is to introduce an envelopetype construct into micro that would allow us to express a broader range of HTTP responses as a simple return statement It restores a concept absent in the core Nodejs HTTP API a request comes in function argument a response goes out return Summary Introduces a microres return type Discourages imperatively responding specially outofband eg callbacks Deprecates statusCode from thrown errors Deprecates microsend as an imperative wrapper ala resend Adds official support of TypeScript Flow types exports Makes micro even smaller Examples Respond with js const res requiremicrores moduleexports req return resNot Found Respond with js const res requiremicrores moduleexports req return resnull Respond with a JSON body js const res requiremicrores moduleexports req return res hi there Respond with a stream js const res requiremicrores moduleexports req return resfscreateReadStreamphotojpg Respond with JSON and headers js const res requiremicrores moduleexports req return res error notfound AccessAllowControlOrigin Fun Trivia Symmetry If we avoid and it almost looks like were using the imperative res similar to our current send js const res requiremicrores moduleexports req await sideEffect resYour request has been logged Composition The return value from res would return a Response object that works like an immutablejs Record Ive written before about why middleware as a framework construct is a bad idea because functional programming is the ultimate middleware framework Our language already has all the tools we need So lets imagine we want to create middleware that always sends CORS headers to all your responses The end goal would be to use it as follows js moduleexports withCORSreq res Hi there So how do we write withCORS js async function withCORSfn const res await fn return ressetHeaders AccessControlAllowOrigin Which can actually be simplified as js async function withCORSfn return await fnsetHeaders AccessControlAllowOrigin We would have a few methods on Response that just return a new immutable response setHeaders merges headers setStatus sets status code setBody sets the body reference Questions What happens to our other return types Undecided and open for discussion Currently we support returning for JSON serialization and applicationjson String Number for textplain Stream for applicationoctetstream Any of the above wrapped in a Promise null for empty body undefined for deferring and letting the user respond later These cover a wide spectrum and theyre ok if you want to retain the default headers status code we chose Theres a strong case for taking them away and always enforcing a Response type They make composition harder In the withCORS example above since the response can return so many things we would need a method for wrapping and converting into a cohesive type withCORS would not be so simple to write Not a fan of two ways of doing the same thing hence why we are removing statusCode from thrown objects However if we do want to main them we could use a wrapper like resfrom that gives us a Response type from a primitive like Hello World js async function withCorsfn const res resfromfn return ressetHeaders AccessControlAllowOrigin Another counterargument of ditching support for returning the primitives is that it would make testing also harder by requiring wrapping again in your test suites What happens to the throw behavior Deprecated Right now you can throw an Error with a statusCode and we respond with it We will be warning once per process in prod every time in dev if you use it and then remove it The functionality can also easily be retained in userland However if a handler throws we will still continue to respond with and a generic Internal Server Error string with the full stack in developer mode and we will consoleerror as well If the user wishes to override error behavior they can write their own function that performs trycatch What happens to sendres Hi Deprecated We will be warning once per process in prod every time in dev if you use it and then remove it The functionality can also easily be retained in userland Transition plans We should do our best to facilitate access to codemods and utilities maintained in userland that make the transition painless and as automatic as possible Future Directions If Nodejs brings back support for the sendfile kernel syscall we can consider introducing a file return type that makes a reference to a node in the filesystem and it can be streamed back in a very optimized way It has been suggested in the past however that sendfile could become an implementation detail of piping a filesystem stream in which case this wouldnt be necessary Input from the community Please feel free to weigh your opinions on this RFC The more comments we gather the better