Refactor manifest validation diagnostics to emit all of them when parsing manifests from Workspace instead of failing on the first one Also took the opportunity to improve the wording of some of those diagnostics For example the following Package swift let package Package name Foo products libraryname Product targets libraryname Product targets A C dependencies packagepath foo packageurl foo git from packageurl pathtofoo from packageurl foo git from packageurl foo git from packageurl foo git from targets targetname A targetname B targetname A targetname B will now emit the following diagnostics pathtoPackage error duplicate target named B pathtoPackage error duplicate target named A pathtoPackage error product Product doesnt reference any targets pathtoPackage error target C referenced in product Product could not be found pathtoPackage error duplicate dependency foo pathtoPackage error duplicate dependency foo PS To achieve this while continue to have those diagnostics assigned the right DiagnosticLocation I modified DiagnosticsEngine to have a configurable defaultLocation not always UnknownLocation anymore and created a helper function to generate a new DiagnosticsEngine with a specific default location that emits back to a parent DiagnosticsEngine The allows to do the following in Workspace swift return diagnosticswithlocation PackageLocationLocalpackagePath packagePath diagnostics in Use the new inner diagnostics engine Finally to disambiguate this new functionality from the wrap function which also used to provide a default location but only for captured errors I removed the optional location from wrap Now to both capture errors and provide a default location for them we can simply surround them in both closures swift return diagnosticswithlocation PackageLocationLocalpackagePath packagePath diagnostics in diagnosticswrap try something showdependencies emits duplicate lines in dot format in some cases This behavior for example causes wasteful arrows when converted image is drawn This PR will fix the issue Resolves SR Im not extremely happy of this PR This feature introduces a cyclic dependency in the SwiftPM types to generate the host Triple we now need the path to the Swift compiler which is calculated and stored in a Toolchain The UserToolchain used in SwiftPM itself requires the host Destination which requires the host Triple I resolved this cyclic dependency by introducing a getHostTripleusingSwiftCompiler static function on Triple and defining a cached TriplehostTriple extension property in Workspace that uses the bare minimum information in the UserToolchain static functions to get the path to a Swift compiler Please let me know if you think there is a better way Notice that this change requires modifications to bootstrap and ManifestLoader to make sure the compiled manifest can find the dynamic PackageDescription runtime library The process for linking against the XCFrameworks mimics how Xcode does it Copying the correct framework in the build directory Adding a F option to the compiler arguments pointing to the build directory Adding a F option to the linker arguments pointing to the build directory Adding a framework option to the linker arguments with the name of the framework Based on Motivation Modification changed file generation for TestDiscoveryCommand added a basic test and run swift test generatelinuxmain Result swift test Xswiftc warningsaserrors enabletestdiscovery would work without errors on Linuxany environment without Darwins ObjC runtime with tests marked as deprecated fixed issue error cannot find lClibgit This improves performance by decreasing the number of spawned XCTest processes makes the testing results output more convenient Executed tests with failures will be printed instead of Executed tests with failures times This is the next step after There are a few cases in which we are throwing DiagnosticsfatalError but arent actually sure that there were previous diagnostics so we could be failing silently This is not only theoretical I just ran into one such case Hi I added isBelongto ArgumentParser method to ArgumentParserResult I think this method is needed to detect which subcommand is executed with optional PositionalArgument Like this swift let parser ArgumentParser let subParser parseraddsubparser sub let optionalArgument localaddpositional sub arg kind Stringself optional true let subParser parseraddsubparser sub which subparser is given let result try parserparseArrayCommandLineargumentsdropFirst If isBelongto ArgumentParser is implemented We can detect that swift let result try parserparseArrayCommandLineargumentsdropFirst if resultisBelongto subParser this command is executed by subParser Or If you have any idea to detect this without above method Can you let me know