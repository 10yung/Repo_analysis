Xalan has a few METAINFservices files that specify default implementations for its services Rather than require every Xalanusing app to include these files as resources we should use scriptsgenresourcesourcepy to embed them into the iOS library Updates GeneratedMessageLite support I get the following error when I try to compile iOS project to work with Mac Catalyst for macOS Catalina liblibjreemulaErrnoExceptiono building for Mac Catalyst but linking in object file built for iOS Simulator file UsersadminDocumentsWorkspacesj objcliblibjreemula for architecture x Attempt to translate a class that uses the javaniochannelsAsynchronousFileChannel nd javaniochannelsCompletionHandler fails with Mainjava error cannot find symbol import javaniochannelsAsynchronousFileChannel symbol class AsynchronousFileChannel location package javaniochannels Mainjava error cannot find symbol import javaniochannelsCompletionHandler symbol class CompletionHandler location package javaniochannels I have seen J OBJC Reference It seems to be a JRE Emulation limitation Will support for these classes javaniochannelsAsynchronousFileChannel javaniochannelsCompletionHandler be added import javaioIOException import javanetDatagramPacket import javanetInetAddress import javanetMulticastSocket import javanetNetworkInterface import javautilEnumeration public class UDPMulticastClient public static void mainString args throws IOException Systemoutprintlnin main receiveUDPMessage public static void receiveUDPMessageString ip int port throws IOException SystemsetPropertyjavanetpreferIPv Stack true Systemoutprintlnin function byte buffernew byte MulticastSocket socketnew MulticastSocket InetAddress groupInetAddressgetByName EnumerationNetworkInterface networkInterfaces NetworkInterfacegetNetworkInterfaces while networkInterfaceshasMoreElements NetworkInterface networkInterface networkInterfacesnextElement EnumerationInetAddress addressesFromNetworkInterface networkInterfacegetInetAddresses while addressesFromNetworkInterfacehasMoreElements InetAddress inetAddress addressesFromNetworkInterfacenextElement if inetAddressisSiteLocalAddress inetAddressisAnyLocalAddress inetAddressisLinkLocalAddress inetAddressisLoopbackAddress inetAddressisMulticastAddress socketsetNetworkInterfaceNetworkInterfacegetByNamenetworkInterfacegetName Systemoutprintlnbefore joining group socketjoinGroupgroup Systemoutprintlnafter joining group whiletrue SystemoutprintlnWaiting for multicast message DatagramPacket packetnew DatagramPacketbuffer bufferlength socketreceivepacket String msgnew StringpacketgetData packetgetOffsetpacketgetLength Systemoutprintln Multicast UDP message received msg ifOKequalsmsg SystemoutprintlnNo more message Exiting msg break socketleaveGroupgroup socketclose By Compiling and Running through javac it is working fine But by using j objcc g o UDPMulticastClient UDPMulticastClientm UDPMulticastClient UDPMulticastClient It got terminated at socketsetNetworkInterface With Xcode xcodebuild provides the createxcframework command This packages multiple framework architectures into one distributable This feature replaces fatframeworks and Xcode is able to provide the correct framework file based on the architecture being ran A xcframework of the JREframework would allow all the architectures iOS iOS Simulator tvOS tvOS Simulator MacOS and one day iOS UIKitForMac to be released as one xcframework file See the discussion here When the outputStyle is set to SOURCE it should still generate full path for the included header files as the files are generated hierarchically Currently it only generates the full path when the option is PACKAGE I fixed the issue in HeaderMapoutpDirFromPackage by simply adding the case SOURCE private String outputDirFromPackagePackageElement pkg if pkg null pkgisUnnamed return String pkgName ElementUtilgetNamepkg OutputStyleOption style outputStyle if isPlatformPackagepkgName Use package directories for platform classes if they do not have an entry in the header mapping style OutputStyleOptionPACKAGE switch style case SOURCE case PACKAGE return ElementUtilgetNamepkgreplace FileseparatorChar FileseparatorChar default return The request is for a new command line argument for j objc to optionally consider all outer references weak In this mode all outer references are week and a new annotation StrongOuter can be used to make a specific inner class reference outer object strongly yegork wrote on j objcdiscuss With the existing ObjectiveCName annotation it is easy for a Java class to implement UIKit protocols but its impossible to mark the class as conforming to a given protocol My suggestion is to use an annotation to specify the list of protocols the translated ObjC class is confirming to for example ObjectiveCConformsUITextFieldDelegate public class MyClass ObjectiveCNametextFieldDidBeginEditing void textFieldDidBeginEditingtextField Object Do Something Now as in the previous case this is mostly see below optional one can skip protocol specification and cast in assignment but as with the previous case this would remove the need for a cast and add ObjC type checking which is always good Also with such a new annotation the ObjC conformsToProtocol function will actually work correctly for Java classes granted most libraries dont actually check the protocol itself only checking respondsToSelector but some do for example Google Maps SDK is checking for conformance to GMSMapViewDelegate and the delegate wont work if conformity is not declared yegork wrote on j objcdiscuss Consider the following code example public class MyClass Object view public native void setAlphafloat alpha UIViewview setAlphaalpha Obviously this works But my suggestion is to use an annotation to specify the type to use in ObjC code for example public class MyClass ObjectiveCTypeUIView Object view public native void setNativeAlphafloat alpha int animate view setAlphaalpha This way there is no need to cast in the native code so the code looks cleaner and there is now type safety on the ObjC side A winwin