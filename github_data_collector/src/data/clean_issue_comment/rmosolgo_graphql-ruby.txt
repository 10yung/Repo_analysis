This is a WIP PR currently There are a few checks that I put in place where there is some odd behaviour around some methods not existing However the idea behind the implementation is there and I would like to make sure I am on the right track and also get some assistance in fixing these problems as I have gotten a bit stuck I also need to implement more tests to check to make sure inheritance is working correctly between interfaces as well as querying for fields on hidden interfaces rather than just the introspection query I have decided to go about this in a similar way to which sets a typemembership on an interface and any types that implement that interface can pass in some params for when it should be visible For example ruby class PrivateMembership GraphQLSchemaTypeMembership def initializeargs visibility nil kwargs visiblity visibility superargs kwargs end def visiblectx return true if visibilitynil visibility private context private end end class MyInterface include GraphQLSchemaInterface typemembershipclass PrivateMembership field secretfield String null false end class MyObject GraphQLSchemaObject implements MyInterface visibility private true field publicfield String null false end In this case if context private is true then the secretfield will show up when Querying for MyObject Schematodefinition doesnt include enum using in directive Directory ruby file ruby class DirectivesLocale GraphQLSchemaDirective class LangEnum GraphQLSchemaEnum I navailablelocaleseach do locale value localetos end end locations GraphQLSchemaDirectiveFIELD argument lang LangEnum required true end Schematodefinition generates graphql directive localelang LangEnum on FIELD And It should generate definition for LangEnum graphql enum LangEnum en ru But it doesnt happen Gem version Below gem versions work fine Thank you for making this library add GraphQLTracingAppOpticsTracing including documentation and tests I had a mutation with an interface as the return type but forgot to add the implements MyInterface declaration to any types As a result when I tried to call the mutation I got back an error that there was no such field My bad for forgetting to add the declarations but I wish that there would have been some kind of a warning or error instead of silently ignoring the mutation type Fix a few issues with the previous code It only supported one chunk I havent heard of this being an issue but it could be It didnt log the response with verbose fixed loads on nested input objects but if your Schemaobjectfromid function returns a lazy value it wont be resolved by the time the mutations resolve function is called I hope this is no dumb question maybe I misunderstood the use case of directives In my API a user can have multiple roles like admin or manager Depending on this roles Im using CanCans accessibleby to scope results to the users abilities Now the use case popped up that I want results for a specific role eg a manager My first solution was to include an argument which I can use to create the right ability for this role query articlesrole manager title The problem is when I query multiple resources I have to include the role argument multiple times query articlesrole manager title commentsrole manager id My idea was to use a custom directive for this that is defined for the whole query query abilityrole manager articles title comments id class Ability SchemaDirective locationsGraphQLSchemaDirectiveQUERY argument role String required true def selfresolveobject arguments context end end But this does not seem to work The resolve method is never called only when I use locationsGraphQLSchemaDirectiveFIELD From the arguments of the resolve method I guess that it is too late to scope the result as the objects are already loaded am I right Is a directive the right tool for such an use case Or are there any other ways to manipulate a context eg contextfetchcurrentability for a whole query Were trying to add some custom behavior to the default execution strategy The strategy itself is working fine except execute now returns a Hash instead of a QueryResult for some reason Issue When calling Schemaexecute in the default ActionCable GraphQLChannel from the documentation the standard return looks like this ruby result GraphQLQueryResult query tohdatanil When doing the same thing after customizing the execution strategies ruby class CustomExecutionStrategy GraphQLExecutionExecute or GraphQLSchemadefaultexecutionstrategy This is not snipped just simply subclassing it breaks end class MySchema GraphQLSchema queryexecutionstrategy CustomExecutionStrategy mutationexecutionstrategy CustomExecutionStrategy subscriptionexecutionstrategy CustomExecutionStrategy end The result of execute is a hash which breaks a bunch of things because resultsubscription and resultcontext no longer exist ruby result data nil Note just subclassing the execution strategy without any other code causes this issue Expected Simply subclassing the default execution strategy should not modify the return result type We need some way to handle a situation like this graphql on Something items id things stuff Where things can be optimized if items has exactly one selection id This can kind of be hacked by injecting a lookahead into every field that returns Something and passing it down with scopedcontext but thats errorprone 