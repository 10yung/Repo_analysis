Im trying to deserialize an enum but with no luck Following a simple example of what is going wrong const string incomingStringFromMicroservice NameGregfruitApple var newtonsoftFruit NewtonsoftJsonJsonConvertDeserializeObjectFruitPickerincomingStringFromMicroservice var utf Fruit Utf JsonJsonSerializerDeserializeFruitPickerincomingStringFromMicroservice where public class FruitPicker public string Name get set public Fruit Fruit get set public enum Fruit Orange Apple In the case of utf json the Fruit is set to the default value What Im I doing wrong Why is my enum not set correctly Thanks Unable to Deserialize a class that inherits a dictionary when using int as its key ie Dictionaryint T The use case for this is pulling info from a database and storing the identity in the key and its object data in the value Below Im using a string as the value for a simple demonstration Instances which do serialize and deserialize are Variable defined as Dictionaryint string demonstrated below Class that inherits a dictionary using a string class Foo Dictionarystring string Output json Item data Item data Exception thrown SystemArgumentException in SystemPrivateCoreLibdll An exception of type SystemArgumentException occurred in SystemPrivateCoreLibdll but was not handled in user code The value is not of type SystemInt and cannot be used in this generic collection Test Class cs using SystemCollectionsGeneric namespace TestJsonEngines public class DictIntKey Dictionaryint string No properties here just helper methods Unit Test Fails cs TestMethod public void Utf DictIntKeyQuickTest Assign var obj new DictIntKey StringA Helo IntB obj Add Item data obj Add Item data Object to string string json Utf JsonJsonSerializerToJsonStringobj DebugWriteLineUtf Before Output r njson Throws exception when converting string to object var obj Utf JsonJsonSerializerDeserializeDictIntKeyjson string json Utf JsonJsonSerializerToJsonStringobj DebugWriteLineUtf After Output r njson AssertAreEqualjson json Output before exception Utf Before Output Item data Item data Unit Test Passes This snip below shows that you can use a Dictionaryint T cs TestMethod public void Utf DictIntKeySimpleTest Assign var obj new Dictionaryint string obj Add Item data obj Add Item data string json Utf JsonJsonSerializerToJsonStringobj var obj Utf JsonJsonSerializerDeserializeDictionaryint stringjson string json Utf JsonJsonSerializerToJsonStringobj DebugWriteLineUtf Before Output r njson DebugWriteLineUtf After Output r njson AssertAreEqualjson json Output json Utf Before Output Item data Item data Utf After Output Item data Item data Is it possible to use for net framework I am getting deserialization error given below any fix for the below json provided JsonParsingException expected actualo at offset Utf JsonJsonReaderReadStringSegmentRaw Utf JsonJsonReaderReadPropertyNameSegmentRaw DeserializeObject JsonReader IJsonFormatterResolver Utf JsonResolversInternalDynamicMethodAnonymousFormatter DeserializeJsonReader reader IJsonFormatterResolver formatterResolver Utf JsonJsonSerializerDeserializeByte bytes Int offset IJsonFormatterResolver resolver Utf JsonJsonSerializerDeserializeByte bytes IJsonFormatterResolver resolver Utf JsonJsonSerializerDeserializeString json IJsonFormatterResolver resolver Utf JsonJsonSerializerDeserializeString json And Below is the sample json trying to deserialize this is getting deserialize using newtonsoft Com Test The nuget package shouldnt include ValueTuple as a dependency for netstandard see You can put in a conditional check in the project file to fix this When I deserialize json that contains addressan addressamountnull to a target Type like public class Recipient public string Address get set public long Amount get set I get an Exception expectedNumber Token actualnull at offset My expectation would be that the long gets initialized to its default value of Afaik in json or javascript it is not wrong to have a number be null Its just a falsy value And I think the least surprise would be if this would not throw and just set the number to Is there maybe any option I can use to achieve this This is not so easy to fix if you dont have control of the production of the json you are getting Does Utf json support converting strings to Enums case insensitive So far it looks like it doesnt but Im not entirely sure public enum Pet Cat I would like to be able to deserialize cat CAT caT to PetCat enum I know in Enums Cat and cat are different however its not in my usecase and would like whatever case that comes in the payload to match the only Cat in the enum Basically I would like to accomplish something similar to this Id really appreciate any guidance if this is possible This did come somewhat unexpected Did serialize with JsonNET in s Did serialize with UTF Json in s Code to Test using System using SystemDiagnostics using SystemIO using SystemLinq using SystemText namespace MemoryAllocatedCore public class BinaryDataWrapper public byte Data get set public class Program static void Mainstring args BinaryDataWrapper wrapper new BinaryDataWrapper wrapperData EnumerableRange Selectx bytexToArray const int N var sw StopwatchStartNew for int i i N i byte newtonSoftBytes EncodingUTF GetBytesNewtonsoftJsonJsonConvertSerializeObjectwrapper NewtonsoftJsonFormattingIndented swStop GCCollect ConsoleWriteLineDid serialize with JsonNET in swElapsedTotalSecondsF s sw StopwatchStartNew for int i i N i byte bytes Utf JsonJsonSerializerSerializewrapper swStop ConsoleWriteLineDid serialize with UTF Json in swElapsedTotalSecondsF s The main issue is that JsonNET does not try to escape characters in its JsonWriter But Utf Json will call in its Json Writer Utf JsonJsonWriterWriteStringstring value for an already Base encoded string JsonNET on the other hand does no checking and directly writes the contents to the output Is this a known issue and would it easy to solve The Utf JsonJsonSerializerToJsonString method is throwing an error when I try to serialize an object of type SystemType under specific circumstances As follows The SystemType object must be passed to a method in a different project to complete the serialization The method that will serialize the object accepts it as type object An example signature public string SerializeObjectobject anObject Example project Utf JsonErrorsln Utf JsonErrorcsproj Build Project Programcs Dependencies ProjectsUtf JsonErrorClassProject Utf JsonErrorClassProjectcsproj Programcs Utf JsonErrorProgramcs Contents using System using Utf JsonErrorClassProject namespace Utf JsonError class Program static void Mainstring args var serializeClass new Utf JsonSerializeClass var typifiedString This is a stringGetType var serializedData serializeClassSerializeObjecttypifiedString ConsoleWriteLineserializedData Utf JsonErrorClassProjectProgramcs Contents using Utf Json namespace Utf JsonErrorClassProject class Program static void Mainstring args public class Utf JsonSerializeClass public string SerializeObjectobject anObject return JsonSerializerToJsonStringanObject The result is that the line return JsonSerializerToJsonStringanObject in Utf JsonErrorClassProjectProgramcs will throw an exception when the program is run Making some minor modifications to the test situation will result in the code not throwing an exception For example changing the signature of the SerializeObject method to public string SerializeObjectSystemType anObject will resolve the issue and return the expected result but Id like to know why the original set up is throwing an exception Exception Details SystemReflectionTargetInvocationException HResult x MessageException has been thrown by the target of an invocation SourceSystemPrivateCoreLib StackTrace at SystemRuntimeMethodHandleInvokeMethodObject target Object arguments Signature sig Boolean constructor Boolean wrapExceptions at SystemReflectionRuntimeMethodInfoInvokeObject obj BindingFlags invokeAttr Binder binder Object parameters CultureInfo culture at SystemReflectionMethodBaseInvokeObject obj Object parameters at Utf JsonJsonFormatterResolverExtensionsGetFormatterDynamicIJsonFormatterResolver resolver Type type at Utf JsonFormattersDynamicObjectTypeFallbackFormatterSerializeJsonWriter writer Object value IJsonFormatterResolver formatterResolver at Utf JsonJsonSerializerToJsonString T T value IJsonFormatterResolver resolver at Utf JsonJsonSerializerToJsonString T T value at Utf JsonErrorClassProjectUtf JsonSerializeClassSerializeObjectObject anObject in C Project Utf JsonError Utf JsonError Utf JsonErrorClassProject Programcsline at Utf JsonErrorProgramMainString args in C Project Utf JsonError Utf JsonError Utf JsonError Programcsline Inner Exception TypeInitializationException The type initializer for FormatterCache threw an exception Inner Exception TypeInitializationException The type initializer for FormatterCache threw an exception Inner Exception TypeLoadException Type Utf JsonFormattersSystemRuntimeTypeFormatter from assembly Utf JsonResolversDynamicObjectResolverAllowPrivateFalseExcludeNullFalseNameMutateOriginal Version Cultureneutral PublicKeyTokennull is attempting to implement an inaccessible interface Thanks