Consider renaming PI to FPI since clients often want to do import kotlinmath which defines PI as a double First of all thank you for making this library opensource it helps me a great amount writing some dmath related works I think this library is a great source but my implementation will differ in a couple aspects This is more like something I would like to get feedback on rather than having implemented in this library I am interested in your opinions if the differences below would actually make sense Immutability and mutability The Kotlin library shows a great example how immutability and mutability can be separated to different classes thus reducing the possible errors The classes I think should be implemented in the ListT MutableListT pattern Kotlin sealed class Float Create the MFloat type instead every time They are the same private constructor open val x Float open val y Float Functions always create a new object fun normalized MFloat val l f thislength return MFloat thisx l thisy l class MFloat override var x Float override var y Float Float x y Set operators etc Functions can mutate in place inline fun normalize Unit val l f thislength x l y l Kotlin standards As a sidenote I think that the function below is confusing Kotlin package comcuriouscreaturekotlinmath operator fun inc Float x f y f return this From kotlinlang The inc and dec functions must return a value which will be assigned to the variable on which the or operation was used They shouldnt mutate the object on which the inc or dec was invoked I dont understand the intention behind the current version of kotlinmath In other functions div times a new object is created even distance calculates by creating a new object so why not returning a new object here too Less object allocation I am writing my classes to be used on Android maybe even doing a couple calculations for each frame so I assume the object allocations should be kept at a minimum I noticed that the transpose is recalculated each time for the matrix if it is used inside a multiplication Kotlin Mat class operator fun timesv Float Float val t transposethis return Float dottx v dotty v This actually makes sense because the class itself is mutable A different approach would be to have a Mat class which is immutable and have an MMat class that is mutable The transpose would be cached and invalidated when the data changes A possible approach would look like this Kotlin sealed class Mat private constructor protected val x MFloat protected val y MFloat inline val x Float get x inline val y Float get y protected val invalidatorObserver InvlazyObservable val transpose by invLazyinvalidatorObserver transposethis class MMat x MFloat y MFloat Mat x y private fun contentChanged invalidatorObserverinvalidate operator fun setcolumn Int v Float when column xsetv ysetv else throw IllegalArgumentExceptioncolumn must be in also contentChanged It could be further improved to change the data inplace instead of creating a new transpose matrix but the code written above might already be some improvement over the current solution in terms of performance TLDR IMHO allocating new objects is bad based on my experience and there could be a solution that offers usage with lowmemory footprint and more efficient calculation Thanks for reading and any feedback is appreciated Vectors could be implemented as views over float arrays This would allow the client to control the allocations This would be the closest thing to a linear allocator 