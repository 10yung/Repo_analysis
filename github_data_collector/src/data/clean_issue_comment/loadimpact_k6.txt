This is a proposal for adding a new standard metric to k called httpreqerrors that records the number of failed HTTP requests Some of this functionality can be achieved today with a custom metric but its so basic that I suggest it should be included by default Feature Description Successful requests often have longer httpreqduration than failed requests This metric would allow k to display a separate httpreqduration for successful requests and separate httpreqdurationerrors for failed requests Its not possible to define which HTTP status codes should be considered errors because these codes are contextspecific For example HTTP is not an error if someone is testing for s This problem can be solved by adding additional configuration options as described below The biggest advantage of this functionality is the UX improvement Currently k doesnt distinguish between failed and successful requests therefore the terminal output for a test that has only failed requests is not distinguishable from a successful test With this change one could see at first glance that the test waswasnt successful without adding checks and thresholds Suggested Solution optional javascript let options httperrors status default setting httperrorsexclude k terminal output could look similar to this httpreqs s httpreqserrors s httpreqduration avg s min s med s max s p s p s httpreqdurationerrors avg s min s med s max s p s p s This implements a couple of features discussed in General cleanup of the rightside progress bar text shorter split into two columns correct alignment Initially I experimented with tabwriter to achieve this simply with tabs but there would always be an edge case that would unexpectedly cause columns to shift further right so tabs werent reliable The alignments done manually here with fmt padding unfortunately complicate the render code quite a bit so let me know if it can be simplified I still think its worth it as columns make the progress much easier to follow even though they dont strictly contain homogeneous elements Adding a status column and field to ProgressBar to indicate when the executor is stopping done etc This is shown after the executor name for lack of a better place and takes up a fixed chars Theres a minor bug in that the interrupted status is sometimes not rendered when pressing C Some kind of race condition Related to this should we wait for maxgracefulStop before exiting and forceexit with another C I think that would be better UX Heres what it looks like currently x scrot The discussions surrounding and made me realize that we might have an issue with work partitioning Some of the executors have different attributes that have to be distributed when we partition them with execution segments the number of VUs they have at any given moment and the work they have to do The pervuiterations constantloopingvus and variableloopingvus dont have this problem since for them the only important thing we need to segmentpartition is the number of VUs the work each VU has to do isnt affected its constant But for sharediterations constantarrivalrate and variablearrivalrate things are a bit different Say that we have the following configuration js export let options executionSegment execution sharediters type sharediterations vus iterations maxDuration s This is the execution segment that has no VUs but a single iteration Similarly with the arrivalrate executors it will probably be even easier to end up having a segment with work but no VUs So I think we may need to have a tier partitioning for these executors Partition the workers ie VUs first Based on the number of allotted workers for that segment partition the actual work iterations or iterationss respectively So in the above example this is how the iterations and VUs are currently partitioned if we split the work into thirds and also how I think they should InstID Segment VUs Iterations now Iterations after fix For the arrivalrate executors things like this would probably happen even more often since iterss are practically infinitely divisible Say that we have iters with VUs and we again want to split that execution into thirds js export let options executionSegment execution constantarrrate type constantarrivalrate rate duration s preAllocatedVUs maxVUs Wed have something like this InstID Segment VUs Iterss now Iterss after fix These changes should be fairly easy and efficient to achieve with the execution segments though of course serious testing would be required to validate it Server using SocketIO SocketIO is not a WebSocket implementation Although SocketIO indeed uses WebSocket as a transport when possible it adds some metadata to each packet the packet type the namespace and the ack id when a message acknowledgement is needed That is why a WebSocket client will not be able to successfully connect to a SocketIO server and a SocketIO client will not be able to connect to a WebSocket server like wsechowebsocketorg either Please see the protocol specification here Useing k ws module connect will throw an error ERRO GoError websocket bad handshake This seemingly normal script wont work as most people expect js import http from k http export let options duration s thresholds iterations count httpreqs count export default function let response httpget timeout s Because the request timeout doesnt understand stringy durations s would be converted to because JavaScript manfacepalming so k would understand it as milliseconds So its going to start to make a ton of requests instead of just However this script also doesnt work like how youd expect either js import http from k http export let options duration thresholds iterations count httpreqs count export default function let response httpget timeout k runs doesnt abort with a configuration error or something like that but it interprets the value for duration as nanoseconds ie milliseconds so it just immediately aborts manfacepalming This is just a consequence of the way weve wrapped Gos timeDuration which is nanosecondbased in our typesDuration custom type that parses things like s Only when it doesnt get a string it falls back to the nanosecond code So I think we should unify and make everything saner To do that with minimal breaking changes I propose that we use the same duration type typesDuration typesNullDuration everywhere we accept userspecified duration modify it so it either accepts valid string durations or integer durations in milliseconds everything else should be an error So the only breaking change is that users wont be able to specify the global options in nanoseconds which wont be a big loss and I hope nobody has done I noted that when I use an powerful machines to stress another two servers the requesting rate fluctuates periodically with two cpu cores pinned in cpu in high position of period cpu in low position of period This discussion is a nice starting point for whats currently suboptimal I also noticed that the lib package depends on the jscompiler package go list f join Imports n githubcomloadimpactk lib sort produces githubcomloadimpactk jscompiler githubcomloadimpactk libfsext githubcomloadimpactk libtypes githubcomloadimpactk loader githubcomloadimpactk stats githubcomloadimpactk uipb its not related to the new executors but this shouldnt be the case The usage report in is currently broken and disabled Because we want to maximally preserve user privacy and not send any potentially sensitive data we cant just package the new execution option and send that since it could contain sensitive data we dont want to know Instead we need to move the sending of the usage report from before the start of the script to the end of the execution and send only a rough summary of what was actually executed So the k version goos and goarch JSON fields remain unchanged vusmax iterations and duration would get their values from the ExecutionState stduration will be removed since it doesnt make a lot of sense we might want to also add a field for the used executor types but only their types and number no names or any other details Users should be able to inject environment variables and metric tags perexecutor as well as be able to specify a custom function to be executed instead of the default one Something like this js export let options execution someKey type constantloopingvus vus duration s Injectoverwrite environment variable keyvalue pairs env blah whatever key value key value Allow users to execute some other exported function besides the default one exec someExportedFunctionThatsNotTheDefault The ability to inject additional metric tags tags tag value tag value These things would allow us to relatively gracefully support multiple scenarios in the same script a very frequently requested feature This comment describes how execution segments dont work correctly with the arrivalrate executors And the other known bug is specifically with the variablearrivalrate executor described and somewhat fixed in and demonstrated in this screencast 