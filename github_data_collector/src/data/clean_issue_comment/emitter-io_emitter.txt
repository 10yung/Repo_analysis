Im confused to run emitter quickly when I know how to start I update the docker run part I hope I can be helpful Problem shell githubcomemitterioemitterconfig gopkgmodgithubcomemitterioemitterv incompatibleconfigconfiggo undefined configVaultConfig environment shell go env GO MODULEon GOARCHamd GOBIN GOCACHEUsersabserLibraryCachesgobuild GOENVUsersabserLibraryApplication Supportgoenv GOEXE GOFLAGS GOHOSTARCHamd GOHOSTOSdarwin GONOPROXY GONOSUMDB GOOSdarwin GOPATHUsersabsergo GOPRIVATE GOPROXY GOROOTusrlocalgo GOSUMDBsumgolangorg GOTMPDIR GOTOOLDIRusrlocalgopkgtooldarwinamd GCCGOgccgo ARar CCclang CXXclang CGOENABLED GOMODdevnull CGOCFLAGSg O CGOCPPFLAGS CGOCXXFLAGSg O CGOFFLAGSg O CGOLDFLAGSg O PKGCONFIGpkgconfig GOGCCFLAGSfPIC m pthread fnocaretdiagnostics Qunusedarguments fmessagelength fdebugprefixmapvarfoldersm q qpd x r p qxs k mw gnTgobuild tmpgobuild gnorecordgccswitches fnocommon Complete log shell ArideMacBookAir abser go get u githubcomemitterioemitter emitter go finding githubcomemitterioemitter v incompatible go downloading githubcomemitterioemitter v incompatible go extracting githubcomemitterioemitter v incompatible go finding githubcomemitterioconfig v go downloading githubcomemitterioconfig v go finding githubcomhashicorpgosockaddr v go finding golangorgxcrypto latest go downloading githubcomhashicorpgosockaddr v go finding githubcomkarlseguinccache v incompatible go finding githubcomweaveworksmesh latest go finding githubcomaxiomhqhyperloglog latest go finding githubcomkelindartcp v go extracting githubcomemitterioconfig v go downloading githubcomkarlseguinccache v incompatible go downloading githubcomkelindartcp v go downloading golangorgxcrypto v a db go extracting githubcomkelindartcp v go extracting githubcomhashicorpgosockaddr v go finding githubcomkelindarbinary v go downloading githubcomweaveworksmesh v dbcc e e go downloading githubcomaxiomhqhyperloglog v a c c bc f go extracting githubcomkarlseguinccache v incompatible go downloading githubcomkelindarbinary v go finding githubcomkelindarprocess latest go finding githubcomvalyalafasthttp v go downloading githubcomvalyalafasthttp v go extracting githubcomaxiomhqhyperloglog v a c c bc f go extracting githubcomweaveworksmesh v dbcc e e go downloading githubcomkelindarprocess v a e ec go extracting githubcomkelindarbinary v go extracting golangorgxcrypto v a db go extracting githubcomkelindarprocess v a e ec go extracting githubcomvalyalafasthttp v go downloading githubcomdgryskigometro v f b bc go downloading githubcomstretchrobjx v go extracting githubcomdgryskigometro v f b bc go extracting githubcomstretchrobjx v go downloading githubcomklauspostcompress v go downloading githubcomvalyalabytebufferpool v go downloading golangorgxnet v ba fcec b go extracting githubcomvalyalabytebufferpool v go extracting golangorgxnet v ba fcec b go extracting githubcomklauspostcompress v go downloading githubcomklauspostcpuid v go extracting githubcomklauspostcpuid v go finding githubcomklauspostcompress v go finding githubcomklauspostcpuid v go finding githubcomdavecghgospew v d f af cc go finding githubcomdgryskigometro latest go finding gopkginyamlv v go finding golangorgxnet latest go finding githubcomvalyalabytebufferpool v go finding golangorgxsys latest go downloading golangorgxnet v c dbc a go downloading gopkginyamlv v go downloading golangorgxsys v cf de go downloading githubcomklauspostcompress v go extracting gopkginyamlv v go extracting golangorgxnet v c dbc a go extracting golangorgxsys v cf de go extracting githubcomklauspostcompress v githubcomemitterioemitterconfig gopkgmodgithubcomemitterioemitterv incompatibleconfigconfiggo undefined configVaultConfig Hi I run emitter in a G container when the connection grows to emitter will restart because of memory leak My question is why one connection cost so large memory Is that true I can only add connection in one broker G memory I have been trying to use SSL in EKS by using a certificate from AWS however I cant reach the broker at MQTTS but I can in It would be great to see a demo of this if possible There are no errors in the brokers logs tcpmqttdomainio works sslmqttdomainio does not work it hangs In broker yaml I have ports containers env name EMITTERLISTEN value name EMITTERTLSLISTEN value name EMITTERTLSHOST value domainio name EMITTERTLSEMAIL value emaildomainio ports containerPort containerPort containerPort containerPort containerPort containerPort and in the load balancer yaml metadata name brokerloadbalancer annotations servicebetakubernetesioawsloadbalancersslcert certificateArn servicebetakubernetesioawsloadbalancersslnegotiationpolicy ELBSecurityPolicy servicebetakubernetesioawsloadbalancersslports ports port targetPort name mqtt port targetPort name mqtts port targetPort name http Am I missing something I am not sure if the load balancer requieres the annotations part but I also removed them to see if it works but it didnt Emitter logs service starting the listener service starting the listener tls setting up certificates with dircache cache service exposing autocert TLS validation on service starting the listener service service started Running netstat in the pods broker kubectl exec it broker sh netstat Active Internet connections wo servers Proto RecvQ SendQ Local Address Foreign Address State tcp broker brokerdefaultsvcclusterlocal broker brokerdefaultsvcclusterlocal ESTABLISHED tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT Active UNIX domain sockets wo servers Proto RefCnt Flags Type State INode Path broker kubectl exec it broker sh netstat Active Internet connections wo servers Proto RecvQ SendQ Local Address Foreign Address State tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internalafs prserver TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internalafs kaserver TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal broker brokerdefaultsvcclusterlocal ESTABLISHED tcp broker brokerdefaultsvcclusterlocal ip ec internalafs update TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT tcp broker brokerdefaultsvcclusterlocal ip ec internal TIMEWAIT Active UNIX domain sockets wo servers Proto RefCnt Flags Type State INode Path add HTTPJson method to generate channel key with http post add onHTTPPublishJson method to publish message with http post These codes provide http api for other language for example delphi php first question I created a chat topic like go ga cGenerateKey xmchatgroupa rwlsp err cPresencega xmchatgroupa true true if err nil panicerr I created several client to connect emitterserver like go err cPresence xmchatgroupa true true if err nil panicerr err cSubscribe xmchatgroupa nil if err nil panicerr then seonds ago i unsubscribe it go err cUnsubscribekey channel if err nil fmtPrintlnerr i cannot receive subscribeunsubscribe but i can receive status from each client i want to receive every client when they subscribe or unsubscribes message second question go func getOpts funcemitterClient return funcemitterClient emitterWithAutoReconnecttrue emitterWithBrokerstcp emitterWithClientIDsys emitterWithPassword emitterWithUsernamesysuser I create client with clientid and passwordusername but when i publish message like this go cPublishkey channel hello a emitterWithTTL emitterWithoutEcho emitterWithLast emitterWithAtLeastOnce then one client disconnect when its online it can also receive the old messages but i want is receive the message that the client never received before See title Hi I cant seem to get presence changes working I tried it different ways and all I get is the initial status but not the changes change value is true In the demopresence after clicking onlineoffline repeatedly the Now Online remains empty the entire time and here is the console output emitter connected appjs time event status channel presencedemod ea e who Array I also tested it with sdkintegrationtest in go by setting the changes parameter to true in the Presence call and swapping the order of clientA and clientB again no presence changes I am wondering about something you need a key to publish a message and subscribe You dont seem to need a key to actually connect So what happens to a subscription when the key times out Example I create a key with a TTL of I then subscribe to a channel and wait for messages What happens to that subscription once the seconds times out Obviously I could not publish a message because I would need to provide a valid key in order to publish But what happens to that subscription that is using my connection and waiting on messages Does it just stop receiving messages The reason I ask is I want to an app to know when it needs to go get a new key An easy thing to do is to check for TTL expiration anytime the app is about to publish a message This way we dont have to periodically check the keys TTL The problem I see is for subscriptions Since we are simply waiting for messages we dont have an opportunity to check We have to assume that the subscription is still valid and receiving events If the key expires will an event be raised on the connection or the channel Hi Team I am exploring the use of emitter for one of our use cases which involves pub sub Things that I did Cloned the repository Built it locally At first run License and Secret was generated Added the license in emitterconf Browse to keygen Added the secret gave the channel name as mqtt and set the ttl to Got the channel key Connected to using PAHO MQTT Subscribe to channel via channelkeymqtt Publish a message to channelkeymqtt After doing all this I do not receive message on the subscribed channel I tried a few things What worked for me is this Is this an ideal scenario Channel Details channel testchannel key bBSJoEcSt rbI Bew QZti tT sok First Case Subscribe to channel as bBSJoEcSt rbI Bew QZti tT sok testchannel Publish a message to channel bBSJoEcSt rbI Bew QZti tT sok testchannel I did not receive the message Second Case Subscribe to channel as testchannel Publish a message to channel bBSJoEcSt rbI Bew QZti tT sok testchannel I did not receive the message Third Case C Subscribe to channel as bBSJoEcSt rbI Bew QZti tT sok testchannel C Subscribe to channel as testchannel Publish a message to channel bBSJoEcSt rbI Bew QZti tT sok testchannel I received the message only on C ie testchannel No message received on C Disconnect C ie bBSJoEcSt rbI Bew QZti tT sok testchannel Publish a message to channel bBSJoEcSt rbI Bew QZti tT sok testchannel I do not receive any message on either of the channels I have seen this video as well to check how channels and keys work 