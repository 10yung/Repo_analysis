This library is currently the bloatiest part of my application according to cargo bloat release KiB waylandsys waylandsysclientWaylandClientopen KiB is a lot of data this data is included when using gfxhal Is there any way to cut this down By default cargo only uses the lwaylandclient flag for the client and assume that ld will find it It is not the case with the nix package manager where the library cannot be found without using pkgbuild One way to solve this problem is to use the pkgconfig crate in the buildrs script like this for waylandclient extern crate pkgconfig fn main pkgconfigConfignewatleastversion probewaylandclientunwrap Ive tried it and that allowed me to use the client crate on nixos however I dont know how to write a proper fix that will interact well with all the other crates and their features in particular dlopen etc There is interest for an effort to properly port wayland to the BSD systems In this direction it would be nice to manage to effectively test waylandrs on them OpenBSD and FreeBSD at least Currently EventQueueprepareread is partially mocked in the purerust backend of waylandclient The proper behavior matching the C library is that prepareread increases an internal counter of threads getting ready to read when readevents is called the threads are blocked on a fence until all threads either are currently blocked or have cancelled their read at that point one threads is unlocked and proceeds to the actual read and then all other threads are released with nothing to read yet return value Right now readevents just acquires an exclusive lock on the socket and reads from it meaning if several threads try to read at the same time will read and then the other will also try to read the syscall will be sent and processed to discover that there is nothing to read This is not a safety issue but a performance one Though it should likely only be an issue in applications trying to read events from different threads concurrently and are quite performance sensitive wrt to that There is no hard dependency on the libwaylandcursorso system library and we can reimplement this in rust the main blocker is having a tool for findingparsingloading the cursor system theme files If the compositor destroys a global at the same time as a client tries to bind it we can end up with a situation where the client is killed for trying to bind a nonexisting global because its request just arrived a little late There should be some grace period after the destruction of a global The C libs do it Im not clear about the reasons but I think it should help with races and reusing leftover sockets from a dead server that did not properly cleanup