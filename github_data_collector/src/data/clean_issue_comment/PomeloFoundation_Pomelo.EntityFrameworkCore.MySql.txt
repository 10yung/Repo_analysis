Fixes Steps to reproduce Im not sure if this is an error on my part or on the librarys part Im attempting to force a collation of utf mb unicodeci on a string column Im doing something similar to this builderPropertyp pValueHasCollationutf mb unicodeci However when I make a migration from the Package Manager Console using AddMigration like so AddMigration MigrationName Project NetStandardProject StartupProject NetCoreProject The generated Migration class does not contain an annotation on the field Ill see only the following in the migration under the tables columns Value tableColumnstringnullable true Also when I look at the debugging of the create table command for one of the above when I use the Migrate command from a NET Core project Ill see Value longtext CHARACTER SET utf mb NULL It doesnt seem to matter if the column in question is a key or not the result is the same Because of the lack of collation I end up getting all my stringbased columns as utf mb generalci instead Ive also tried to turn off character set appending in the configuration using optionsBuilderUseMySqlconnection b bCharSetBehaviorCharSetBehaviorNeverAppend This also seems to be having no effect as I am still getting the character set appended The issue I expected that doing the above would set the collation of the column properly but instead it is being ignored completely Further technical details MySQL version MariaDB Operating system Windows bit client FreeBSD RELEASEp server PomeloEntityFrameworkCoreMySql version MicrosoftAspNetCoreApp version Not ASPNET NET Standard NET Core Other details about my project setup Ive got my DbContext and entities in a NET Standard project and I create the migration by using a separate NET Core project that stores the connection details The migration is saved to the NET Standard project As far as on the server end Ive got the following in my mycnf file client defaultcharactersetutf mb server collationserverutf mb unicodeci initconnectSET CHARACTER SET utf mb charactersetserverutf mb charactersetclienthandshakeOFF innodbcompressiondefaultON innodbcompressionlevel Steps to reproduce Ideally include a complete code listing that we can run to reproduce the issue Alternatively you can provide a projectsolution that we can run public class TestModel public int Id set get public Guid TestId set get To be added in next migration public string Name set get In Package manager console type addmigration TestModelAddedName removemigration addmigration TestModelAddedName Unable to cast object of type SystemGuid to type SystemString The issue Describe what is not working as expected ApplicationDbContextModelSnapshotcs have been reverted but the guid is now a string If you are seeing an exception include the full exceptions details message and stack trace Exception message Stack trace SystemInvalidCastException Unable to cast object of type SystemGuid to type SystemString at lambdamethodClosure ValueBuffer at MicrosoftEntityFrameworkCoreChangeTrackingInternalInternalShadowEntityEntryctorIStateManager stateManager IEntityType entityType ValueBuffer valueBuffer at MicrosoftEntityFrameworkCoreChangeTrackingInternalInternalEntityEntryFactoryNewInternalEntityEntryIStateManager stateManager IEntityType entityType Object entity ValueBuffer valueBuffer at MicrosoftEntityFrameworkCoreChangeTrackingInternalInternalEntityEntryFactoryCreateIStateManager stateManager IEntityType entityType Object entity ValueBuffer valueBuffer at MicrosoftEntityFrameworkCoreChangeTrackingInternalStateManagerCreateEntryIDictionary values IEntityType entityType at MicrosoftEntityFrameworkCoreUpdateInternalUpdateAdapterCreateEntryIDictionary values IEntityType entityType at MicrosoftEntityFrameworkCoreMigrationsInternalMigrationsModelDifferTrackDataIModel source IModel target at MicrosoftEntityFrameworkCoreMigrationsInternalMigrationsModelDifferDiffIModel source IModel target DiffContext diffContext at MicrosoftEntityFrameworkCoreMigrationsInternalMigrationsModelDifferGetDifferencesIModel source IModel target at MicrosoftEntityFrameworkCoreMigrationsDesignMigrationsScaffolderScaffoldMigrationString migrationName String rootNamespace String subNamespace String language at MicrosoftEntityFrameworkCoreDesignInternalMigrationsOperationsAddMigrationString name String outputDir String contextType at MicrosoftEntityFrameworkCoreDesignOperationExecutorAddMigrationImplString name String outputDir String contextType at MicrosoftEntityFrameworkCoreDesignOperationExecutorAddMigrationcDisplayClass ctorb at MicrosoftEntityFrameworkCoreDesignOperationExecutorOperationBasecDisplayClass Executeb at MicrosoftEntityFrameworkCoreDesignOperationExecutorOperationBaseExecuteAction action Workaround If using GIT you can just revert changes on ApplicationDbContextModelSnapshotcs or manualy edit it Further technical details MySQL version new Version ServerTypeMariaDb Operating system Windows PomeloEntityFrameworkCoreMySql version MicrosoftAspNetCoreApp version Other details about my project setup Migration Assembly in a different project See for further details See for further details The issue Using the provider with a LINQ query with a Where and a StartsWith filter generates the following SQL SELECT bbibid AS Id bfastadd AS FastAdd bstaffonly AS StaffOnly bcreatedby AS CreationUserName bdatecreated AS CreationTime bupdatedby AS LastWriteUserName bdateupdated AS LastWriteTime bstatus bstatusupdatedby AS StatusLastWriteUserName bstatusupdateddate AS StatusLastWriteTime bBibExttitle AS BibExt FROM oledsbibt AS b LEFT JOIN ucbibext AS bBibExt ON bbibid bBibExtid WHERE bBibExttitle LIKE CONCATdeath AND LEFTbBibExttitle CHARLENGTHdeath death ORDER BY LastWriteTime DESC LIMIT OFFSET The same query using the provider generates the following SQL SELECT obibid AS Id ofastadd AS FastAdd ostaffonly AS StaffOnly ocreatedby AS CreationUserName odatecreated AS CreationTime oupdatedby AS LastWriteUserName odateupdated AS LastWriteTime ostatus AS Status ostatusupdatedby AS StatusLastWriteUserName ostatusupdateddate AS StatusLastWriteTime utitle AS BibExt FROM oledsbibt AS o LEFT JOIN ucbibext AS u ON obibid uid WHERE utitle IS NOT NULL AND utitle LIKE CONCATdeath AND LEFTutitle CHARLENGTHCONVERTdeath USING utf mb COLLATE utf mb bin CONVERTdeath USING utf mb COLLATE utf mb bin ORDER BY odateupdated DESC LIMIT OFFSET Note the extra calls to CONVERT and the COLLATE clause This is causing the query to not return any results when it should be Why is it doing this Is there a way to turn it off Further technical details MySQL version Operating system RedHat Linux PomeloEntityFrameworkCoreMySql version Other details about my project setup The servers default character set is set to utf mb using the following settings client defaultcharacterset utf mb mysql defaultcharacterset utf mb Steps to reproduce Ideally include a complete code listing that we can run to reproduce the issue Alternatively you can provide a projectsolution that we can run The issue I get using adonet but using ef linq to SQL Further technical details MySQL version Operating system PomeloEntityFrameworkCoreMySql version MicrosoftAspNetCoreApp version Other details about my project setup Threre are currently options to choose from c Throw an exception if a schema is being used This is the default optionsUseMySqlmyConnectionString b bSchemaBehaviorMySqlSchemaBehaviorThrow Silently ignore any schema definitions optionsUseMySqlmyConnectionString b bSchemaBehaviorMySqlSchemaBehaviorIgnore Use the specified translator delegate to translate from an input schema and object name to an output object name whenever a schema is being used optionsUseMySqlmyConnectionString b bSchemaBehaviorMySqlSchemaBehaviorTranslate schema entity schema dboentity This still needs some testing Fixes This is a continuation of the discussion from about alternatives to throwing in case Pomelo is being used as one of many providers in conjunction with the single migration for multiple providers approach and other providers must use schemas To make this very clear This is not a discussion about reimplementing the previously dropped version where schemas were misused as a way to access objects from multiple databases by a single DbContext It is about alternatives that are compliant with EF Cores understanding of schemas Proposed alternative options have been to either just ignore schemas but not throw or allow users to define their own translation function that translates an input schema and an input object name to an output object name within the same database Any option implemented here is going to be optin because MySQL does not support the EF Core concept of schemas and therefore should throw by default if a schema is being used anyway The exception should hint at the alternative options The simplest way to fill out the application is probably just do it together here in the PR before copying it over to Feel free to edit or review the file This is related to 