 tested by using samsung tv v api When my WebSocket client try to reconnect it is set to closing the original connection first Howerver the target WebSocket server is in a proxied environment behind nginx It might times out after few hour Then the close hangs the whole program for mins From the observation based on following code it probably hangs in frame selfrecvframe So no matter how many timeout I set it didnt work I wonder if this is a bug or something I should change Please give me some advises thank you websocketcorepy close try selfconnected False selfsendstructpackH status reason ABNFOPCODECLOSE socktimeout selfsockgettimeout selfsocksettimeouttimeout starttime timetime printfwebsocketclose entering timeout loop gettimeoutselfsockgettimeout while timeout is None or timetime starttime timeout try frame selfrecvframe if frameopcode ABNFOPCODECLOSE continue if isEnabledForError recvstatus structunpackH framedata if recvstatus STATUSNORMAL errorclose status reprrecvstatus break except Exception as e printfwebsocketclose timeout loop exceptione break selfsocksettimeoutsocktimeout printfwebsocketclose entering sockshutdown gettimeoutselfsockgettimeout selfsockshutdownsocketSHUTRDWR except Exception as e printfwebsocketclose exceptione pass selfshutdown Why not always be thread safe The following issue was a real head scratcher until we realized that this library has to be told that you are using threads We are seeing the following error occasionally It happens on multiple connections to the same server at the same time making me think this is actually a snapped connection in disguise Is this something that the websocket client can catch and raise as a more obvious error ERROR root SSL BADLENGTH bad length sslc Traceback most recent call last File our code line in checkforconnectionalive selfsendwsping File our code line in sendwsping selfwspingkeepalive File homeubuntuvenv libpython sitepackageswebsocketcorepy line in ping selfsendpayload ABNFOPCODEPING File homeubuntuvenv libpython sitepackageswebsocketcorepy line in send return selfsendframeframe File homeubuntuvenv libpython sitepackageswebsocketcorepy line in sendframe l selfsenddata File homeubuntuvenv libpython sitepackageswebsocketcorepy line in send return sendselfsock data File homeubuntuvenv libpython sitepackageswebsocketsocketpy line in send return send File homeubuntuvenv libpython sitepackageswebsocketsocketpy line in send return socksenddata File usrlibpython sslpy line in send return selfsslobjwritedata sslSSLError SSL BADLENGTH bad length sslc Im using websocketclient to communicate with Chrome devtools protocol Some of the messages that come back from Chrome are large they contain the whole DOM While I was testing my software I found a lot of issues which I initially associated with the socket and how it was read but they were actually generated by validateutf Im not using wsaccel All my issues were fixed when I started using skiputf validation in the WebSocket class Not really sure how you guys can reproduce this but the basics are Capture websocket packets using wireshark Send websocket messages to Chrome or any other server Receive large message Verify that in wireshark the server sent the message at timestamp X Verify that the socket returned the message to the upper layers at X Verify that the websocket returned the message to the upper layers at X where the extra three seconds could be more in some cases are associated with validateutf Then run the same test with skiputf validation and youll find that there is no delay In my opinion when the user makes a read but the opcode is unknown not binary nor text instead of returning an empty string an exception should be raised The semantics of an empty string is unknown for client code and we should not use return values for unknown situations I can submit a pull request if this is agreed I am having issues getting this library to ignore the proxy In my example I have a target running on a private network interface I do not want it to use the proxy in this case When I try this from websocket import createconnection selfconn createconnectionws timeout I receive a due to the proxy Very frustrating is there a way to tell it to just completely ignore the proxy Sadly even this does not work from websocket import createconnection selfconn createconnectionws timeout httpnoproxy I need to specify all to get it to work from websocket import createconnection selfconn createconnectionws timeout httpproxyhostproxysitecom httpproxyport httpnoproxy I do not want to do this How do I avoid it Im writing a clientside script and use a provided server that I have no power over As far as I can tell it sends the wrong opcodes when it sends several continuous frames it sends them with the opcode ABNF OPCODETEXT and a flag fin indicating that the message is not done which results in an Illegal frame error the client receives a message validates the first frame expects to receive a second one with OPCODECONT instead receives a new frame with OPCODETEXT and throws an exception I found two ways to work around it both include modifying the websocketclient files Comment out the validation case in abnfpy file lines if selfrecvingframes and frameopcode in ABNFOPCODETEXT ABNFOPCODEBINARY raise WebSocketProtocolExceptionIllegal frame Or adding a flag to recvdataframe method in corepy to indicate if the script is encountering the issue described above If so replace the opcode from the server to OPCODECONT for all the messages after st one There are obvious downsides for both approaches and I was wondering if anyone might have some advice on how to go about this without hacking existing libraries Since our own project has its own log output I want to integrate the websocket log output into our own log module Can i do that