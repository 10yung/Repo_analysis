AFAIK right now its not possible to used docid in Query logic Id like to retrieve any document where docid but neither where nor Query objects support this logic python dbcountQuerydocid dbcountwheredocid dbcountQuerydocid Am I missing something When having a huge amount of data the process of reading that file every time the readmethod is called takes time My idea is to keep track if the file has been modified and if so read it again If not read from cache This improves performance a lot and helps keep disk IO down Ive forked TinyDB and tried to come up with a solution myself but it turns out its harder than it looks When storing dictionaries to cache them it keeps a reference So whenever data is modified by the enduser after requesting the readmethod the changes are reflected in the cache One way to solve this is returning the cached data with copydeepcopy but that takes a long time on bigger databases which ends up being longer than straight up reading the whole file again making the cache meaningless Ive looked online and found that jsonloadsjsondumps in fact does the same thing but faster and it turns out its doing its job but still find that its making the overall experience slow I was wondering if anyone got any ideas on how to make TinyDB perform faster without compromising being able to modify the read data Here is a behaviour that I wasnt expecting Python default Nov Type copyright credits or license for more information IPython An enhanced Interactive Python Type for help PyDev console using IPython Python default Nov GCC on linux In from tinydb import TinyDB Query In db TinyDBtmptestingjson In name Query In dbinsertname myitem Out In dbsearchnamename myitem Out name myitem Note the key being implicitely stringified to After this code cat tmptestingjson default name myitem Is that expected What should I do if I want to be able to have more than strings as dictionary key Hello I am looking for some thoughts on a Tinydb extension that i am mulling over how to implement Considering there is an active discussion about ideas for a I thought this might be a good time to bring it up To start off with here is a quick description of what I am doing in my application that I am interested in integrating directly into a TinyDB extension Currently I have a DB of a size that is on the upper end of what TinyDB is recommended for In that DB i have a particular field that is used very often in DB queries The values of that field are not guaranteed to be unique however the number of entries that share that same value will always be small relative to the number of entries in the DB Additionally the values associated with the field are sortable To speed up my application i have been pulling the entries out of the DB and creating a SortedCollection sorted by that particular field and I maintain the state of that collection along with every database modification kind of like smartcache Then when I get to a point where i would normally perform a query on that field or a combination of that field and something else i use the sorted collection for faster lookup What I am trying to figure out is what would be the best way to integrate this behavior into TinyDB so that it can be done transparently with the query interface To start i know i would need to create a TableClass to implement the management and usage of the sorted Indexs There also must be some way of specifying which fields should be indexed either statically at the creation of the database object or dynamically based on the query being used I am considering whether or not it makes sense to subclass the Query class so that the index is only used for a specific type of query Finally I need a way to determine within each query consuming call whether the query can be performed on an index or must be done on the database directly I am imagining that I would need to do something like decomposing the query path to determine if it is a direct query of an indexed field or if it is a top level AND of a query on that field and something else I think those are the only cases that would work a top level OR definitely wouldnt I am interested to here any thoughts anyone might have on the feasibility of this kind of extension how i might go about implementing it or anything i may have missed Despite having gotten this far and created a few simple customization to TinyDB I am still very new to this library and python in general Any assistance would be greatly appriciated Lately Ive been thinking about how to move TinyDB forward and what the next steps are And the more I thought about it the more I became convinced that TinyDB needs a v Motivation Why would we want a TinyDB v Why introducing a backwardsincompatible releases In my view the reasons to publish a new major release is threefold Remove deprecated functionality thats been waiting to be removed for more than two years now Fix design issues that have been introduced by a lack of vision for extension mechanisms in TinyDB Simplify the architecture in order to fix other issues that cannot be solved without breaking backwards compatibility To elaborate on these reasons Deprecations TinyDB is years old now The first stable release v was published in July A year later in September there has been a major release v that changed the data format and improved the API Again a year later in November the next major release v cleaned up the query language architecture and started moving noncore functionality to external packages Version is now almost years old In the meantime TinyDB continued to evolve including shifting the terminology from elements to documents in v and the deprecation of ujson support Both of these changes have been major cleanups but there hasnt been a major release of TinyDB that would actually get rid of the deprecated features This results in cluttered code which makes it harder to understand the TinyDB software designarchitecture In addition Python which TinyDB supports will reach its end of life at the end of As TinyDB has quite a few places where it has to do extra work to support both Python and from the same code base dropping Python support would simplify the code even further TinyDB v would simplify the source code by removing deprecated features and in turn make it easier to understand the source and to develop ones own extensions In addition only Python would be supported Extension Mechanisms Right from the start there have been two ways to extend TinyDB Custom Storages and Custom Middlewares As the popularity and usage of TinyDB increased so did requests to make it possible to extend other parts of TinyDB Thus Custom Table Classes and Custom Storage Proxy Classes have been added In addition mechanisms to modify the default table class name and parameters as well as the default storage class have been introduced As as result there are no less than seven places where TinyDBs behaviour can be modified Except for the first two all extension mechanisms have been introduced as a result of user requests At the time of each request it seemed to be the best option to follow the path of least resistance when adding a new extension mechanism refraining from any soft of breaking changes But looking back it is apparent that there was no real concept of how extending TinyDB should work in general TinyDB v would remove all extension mechanisms except for Custom Storages All other extension mechanisms would be replaced by a unified extension concept as detailed below Architecture API To be honest Im not particularly proud about TinyDBs internal software architecture As TinyDB evolved gradually often simplicity of the software architecture was neglected Now were in a state where theres a lot of unneeded indirection Data access uses up to classes two of which are some form of proxy class TinyDB Table StorageProxy DocumentProxy Storage This makes TinyDBs source code complicated and also impacts performance see Fixing these design issues requires rearchitecting TinyDB But this in turn requires breaking backwards compatibility as some extension mechanisms rely on the old software architecture Additionally theres been discussion about inconsistencies in TinyDBs API regarding purging data see Removing these inconsistencies would break backwards compatibility TinyDB v would simplify the internal software architecture and remove inconsistencies from its API making it easier to understand how TinyDB works and thus making it easier to extend Proposals Deprecations For the reasons outlined above I propose to Put TinyDB v into maintenance mode implementing only bug fixes but not adding new features Remove all deprecated features Remove ElementElement ID APIs following Fix Two test failures when ujson installed and Drop Python support Extension Mechanisms I propose to replace all existing extension mechanisms with Custom Storages and Inheritance Custom Storages continue to be a useful extension mechanism that is difficult to replicate by other means In addition to Custom Storages the main way to extend TinyDB and to modify its behaviour would be inheritance to create subclasses of TinyDB A famous example of this approach is Flask The Flask class has many methods designed for subclassing You can quickly add or customize behavior by subclassing Flask see the linked method docs and using that subclass wherever you instantiate an application class In addition the Flask docs state As you grow your codebase don t just use Flask understand it Read the source Flask s code is written to be read its documentation is published so you can use its internal APIs Flask sticks to documented APIs in upstream libraries and documents its internal utilities so that you can find the hook points needed for your project With the new extension approach TinyDB would aim to follow the same path Instead of adding new extension mechanisms endlessly users would be encouraged to subclass TinyDB and other classes in order to modify how TinyDB fetches the last ID how it calculates the next ID how the default table name is determined and other behaviours Implementing this requires making useful internal TinyDB methods part of the public API and documenting them in a way that makes it easy to overload them with custom behaviour The documentation should provide examples of what types of extensions are possible by subclassing Also the source code itself should have its code comments reworked to make it easy to understand how TinyDB works from the first reading of the source code based on ideas like literate programming The main challenge of implementing this approach is to find the right balance of how much of TinyDBs internal methods should become part of the public API Making too few methods part of the public API makes it difficult to modify all aspects of TinyDBs behaviour But making too many methods part of the public API makes it difficult to continue to evolve TinyDB without breaking the existing API and existing extensions and in addition cluttering the public API too much My approach regarding which methods to include in the public API would be to be conservative and at first include too few methods rather than too many The reason behind this is that its possible to move more methods to the public API after the fact without breaking the existing API whereas the opposite would break existing usage Architecture API Changes I propose to simplify to rearchitect TinyDB to use the following classes TinyDB class Create and manage tables Forward calls to the default table Table class Receive a storage instance from the TinyDB class Modify table data Cache query results to avoid unneeded IO Storage class Read and write data to a storage Query class Provide searching and filtering Document class Provide a thin wrapper around stored data that remembers the documents ID There may be additional internal classes such as the QueryImp and LRUCache classes we currently have the classes outlined above should do the lion share of the work for TinyDB All in all the new architecture should provide a clear separation of concerns and responsibilities Simplifying the architecture in this way would allow to fix issue StorageProxy read performance is abysmal Also a simple architecture makes it easy to understand how TinyDB works which in turn would impact how easy it is to extend TinyDB using inheritance see above In other words Having a simpler architecture should make it easier to extend TinyDB In addition to architecture changes I propose to also simplify TinyDBs API For one thing we could fix issue Inconsistency with purge functions by making function names consistent between the TinyDB and Table classes For another thing I would propose to remove the writeback method as it complicates the API probably is rarely used and can be implemented by subclassing if needed Also I would like to make processelements part of the internal API again as its a core method of how data is manipulated and probably should not be modified by subclassing Feedback Requested If you have thoughts questions comments or ideas regarding a possible TinyDB v especially regarding the proposals outlined above feel free to comment and discuss on this issue When ujson is installed there are two errors in the test suite s FAILURES s testjsonkwargs s s tmpdir localtmppytestofabuildpytest testjsonkwargs s s def testjsonkwargstmpdir s dbfile tmpdirjointestdb s db TinyDBstrdbfile sortkeysTrue indent separators s s teststeststoragespy s s tinydbdatabasepy in init s selftable selftabledefaulttable s tinydbdatabasepy in table s table tableclassselfclsstorageproxyselfstorage name name options s tinydbdatabasepy in init s data selfread s tinydbdatabasepy in read s return selfstorageread s tinydbdatabasepy in read s selfstoragewriterawdata s s s self tinydbstoragesJSONStorage object at x f e b s data default s s def writeself data s selfhandleseek s serialized jsondumpsdata selfkwargs s E TypeError separators is an invalid keyword argument for this function s s tinydbstoragespy TypeError s testinsertinvaliddict s s tmpdir localtmppytestofabuildpytest testinsertinvaliddict s s def testinsertinvaliddicttmpdir s path strtmpdirjoindbjson s s with TinyDBpath as db s data int int s dbinsertmultipledata s s with pytestraisesTypeError s dbinsertint bark Fails s E Failed DID NOT RAISE type exceptionsTypeError s Builds at 