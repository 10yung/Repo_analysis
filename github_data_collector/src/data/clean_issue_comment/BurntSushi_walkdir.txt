I am using this library and have run into the need to capture a potential error inside of the filterentry predicate I asked in a forum topic about my problem and the response was that the best way to accomplish it would be with a tryfilterentry iterator so that I could return a result inside of the filter predicate I did a quick check of the source code to see how I might be able to implement that but I was wondering if you might have any guidance on how you would want that implemented I havent ever written an iterator before but it looks like if I wanted to create a FilterEntry iterator that it would be nearly identical to the existing TryFilterEntry iterator but not quite the same Is there any way to share most of the implementation without duplicating code or is it better just to create a copy of FilterEntry and the make the changes necessary rust implP FilterEntryIntoIter P where P FnMut DirEntry bool pub fn filterentryself predicate P FilterEntrySelf P FilterEntry it self predicate predicate This requires the P for the filterentry to be the same as the one already applied So this requires a second application of filterentry to use the same type as the first This means its not possible to call filterentry on a WalkDir twice with two different closures instead function pointers or boxed closures need to be used instead I find it amusing it took so long to find this I guess of use cases only need one filter My workaround is to combine the two filters I was applying though readability suffers for it detailssummaryThe snippet in questionsummary rust let dir WalkDirnewmanifestdirjoinattrdirvalue let tests ResultVecDirEntry dir contentsfirsttrue intoiter filterentryentry DirEntry entryfiletypeisfile filterentryentry DirEntry extisnone entrypathextensionunwraporOsStrnew extasrefunwrap collect details The better impl would give FilterEntryfilterentry the same signature as IntoIterfilterentry rust implP FilterEntryIntoIter P where P FnMut DirEntry bool pub fn filterentryQself predicate Q FilterEntrySelf Q where Q FnMut DirEntry bool FilterEntry it self predicate predicate IIUC this is a major breaking change as someone could have used an empty turbofish eg let fn fn walkdirFilterEntryfilterentry to observe the lack of generic arguments When iterating over the WalkDir dictionary in Windows rust stable if the user does not have permission to read a directory an error is given but not the actual path When hitting an error with files the path in the error is displayed but not with directories for some reason Error on entry ErrError depth inner Io path None err Os code kind PermissionDenied message Access is denied Error depth inner Io path None err Os code kind PermissionDenied message Access is denied for entry in WalkDirnewsomepath prepath match entry Okpath path Errerr printlnError on entry entry err continue I recently wrote a short test program using walkdir to count M files in a single directory I then wrote the same test program using stdfsreaddir and found a surprisingly large performance difference To create the test data mkdir testdir cd testdir seq xargs touch Using walkdir rust fn main let dir stdenvargsnth expectUsage countdir dirname println files dir walkdirWalkDirnewdirmindepth maxdepth intoitercount Performance time targetreleasecountdir testdir testdir files real m s user m s sys m s Using stdfsreaddir rust fn main let dir stdenvargsnth expectUsage countdir dirname println files dir stdfsreaddirdirexpectreaddircount time targetreleasecountdir testdir testdir files real m s user m s sys m s Note that the two programs use almost the same system time and strace shows them making almost exactly the same syscalls other than an extra lstat which makes sense as walkdir uses stdfsreaddir underneath However walkdir uses a lot more user time This seems worth investigating to try to reduce the overhead WalkDir cannot handle long paths that find handles fine rust extern crate walkdir use stdfscreatedir use stdenvcurrentdir setcurrentdir fn main let dir currentdirunwrap let name a for i in if i printlnCreate dir at level i currentdirunwrap this line shows that rust can handle it createdirnameunwrap setcurrentdirnameunwrap for r in walkdirWalkDirnewdir let entry runwrap this gives an error for long paths let len entrypathtostringlossylen if len println len Create dir at level thread main panicked at called Resultunwrap on an Err value Error depth inner Io path Somehomewalkdiraaaaa err Error repr Os code message File name too long srclibcoreresultrs note Run with RUSTBACKTRACE for a backtrace 