If I call an interactor like so ruby MyInteractorcallsomething rather than the correct ruby MyInteractorcallsomething something Then I get a semicryptic error like NoMethodError undefined method eachpair for MyInteractor x fa fc Its pretty easy to see that I just called the interactor incorrectly but it seems like it would be easy to check the provided parameters and raise a helpful error I want to log when my Interactor fails is there a way to do it from inside of the class Thanks Whats the reason for this feature Sometimes we may have a situation where our interactors should fail in case there is an exception raised Currently we have to rescue exceptions in order to fail the context consider the following example ruby class MyInteractor include Interactor def call methodraisinganexception rescue NameError e ExceptionLoggerloge contextfailerror e end end This example above is simple but it may get more complex when you have to rescue multiple different exceptions in the same interactor class in different places However what you actually want is to fail the context on those exceptions And perhaps log them so that they dont halt your program but dont go unnoticed either My proposal define what kinds of exceptions must be rescued and provide a proc if necessary with custom behaviour for rescued exceptions handling ruby class MyInteractor include Interactor failonexeption NameError exceptionhandler e ExceptionLoggerloge def call methodraisinganexception end end NameError is silly I only use it to make my example obvious In real life you would probably rescue from some other errors or your own custom error Mostly everyone knows ActiveRecord and their callbacks Why do you use different order It creates some misunderstanding This allows to have more control on how the context works For example which attributes are required its default values or validation Heres a short sample for illustration ruby class MyInteractor include Interactor selfcontextclass Classnew do include ContextMixin attrreader foo attraccessor myexport def initializefoo nil foo foo end end def call if contextfoo contextmyexport Got contextfootos else contextfailmyexport Error end end end puts MyInteractorcallfoo Himyexport Got Hi puts MyInteractorcallmyexport Error MyInteractorcallunexpected information ArgumentError unknown keyword unexpected This PR probably lacks quite some documentation etc I just wanted to get your input if this is something youd consider Obviously Im happy to put more work into this if you do Where would organizers go Context Ive noticed in our code base that we had cases where Interactor was encapsulating more interactors and calling them via call One of the interactors was raising InteractorFailure exception but because parent interactor was invoked via call context success was still reporting true I believe that is wrong behavior and since call is not raising exception it at least should return false when success is invoked Steps to reproduce ruby class ParentInteractor include Interactor def call InteractorWithErrorcall end end class InteractorWithError include Interactor def call raise InteractorFailurenewtest end end test interactor still reports success after it failed do context ParentInteractorcall assert contextfailure assertnot contextsuccess end Fixes Hey I saw therere closed issues asking about how to test organizers and I also found this If you agree that this is the way could you include an example in the readme or would you accept a pr about it Per the documentation This works because the call class method swallows exceptions Unless Im missing something any errors should be swallowed by call but theyre being raised for me unless I manually catch the error inside call and throw it with fail