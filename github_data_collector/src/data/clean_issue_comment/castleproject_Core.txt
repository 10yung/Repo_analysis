When using facility NLogFactory for inject loggers into aspnet core project like that IocContainerAddFacilityLoggingFacility f fLogUsingNLogFactoryWithConfigNLogconfig The layout renders releated to aspnet is always empty Is there any way to walkaround this and inject proper NLog The layout render for aspnet is inside of library NLogWebAspNetCore TLDR May I submit a PR to remove all applications of CAS security transparencyrelated attributes ie SecurityCritical and SecuritySafeCritical and assembly SecurityRulesSecurityRuleSetLevel Reasons The attributes in question have zero effect without assembly AllowPartiallyTrustedCallers which got removed back in see also and Microsoft has obsoleted large parts of CAS and NET Core no longer supports it at all Theres simply no more future for CAS The attributes are applied only sporadically and as far as I can tell in a haphazard nonsystematic manner Some of these attributes are applied in apparently pointless places making me suspect we never really cared enough about CAS to think it through get it right It is often private methods that are marked SecurityCritical but who could call these methods except other methods in the very same class Does it make sense that some sibling methods may call them and others may not Security auditing at such a finegrained level doesnt make much sense IMHO In one instance a type static constructor is marked with one of these attributes According to MS documentation this wont have any effect at all as type constructors are called by the runtime which is always fullytrusted and therefore not constrained by these attributes By removing these we could get rid of a lot of conditional code guards if FEATURESECURITYPERMISSIONS DOTNET Id like to especially see usage of DOTNET minimized for the reason given below Some further background re DOTNET Id love to see the next minor version of the CastleCore NuGet package acquire two framework targets netcoreapp and netstandard sup sup This could greatly simplify the transitive dependency graphs of NET projects relying directly or indirectly on CastleCore Our existing netstandard x targets will bring in a lot of dependencies even when downstream libraries such as Moq FakeItEasy NSubstitute etc already target netstandard x To support these new targets wed need to adjust some of our conditional compilation symbols if FEATURE as the APIs of these target frameworks are once again different from all of the target frameworks we currently support NET Framework x and NET Standard x Ive been trying to determine the set of conditional compilation symbols that would work for these two new targets Many of the existing symbols can be used without any changes some will require changes One symbol thats especially problematic is DOTNET it is a kitchen sink for several different things It would be good to minimize usages of DOTNET and replace it with more specific symbols wherever possible so that these can be cleanly mapped to the various target frameworks One of the things that falls under the DOTNET umbrella is Code Access Security transparency level look for code guarded by if FEATURESECURITYPERMISSIONS DOTNET Since the code thus guarded doesnt really make sense anymore see reasons given above I believe it would be easiest to just remove it rather than introducing a new FEATURESECURITYTRANSPARENCYLEVEL symbol sup sup Id also like to see some existing target frameworks dropped mdashnet netstandard x netstandard for reasons Ill happily lay out if requested mdash but that would be a breaking change and cannot be done in a minor version Interfaces are ordered in a case insensitive way while fields for ctor are order in case sensitive way and cause problems when creating class proxy Test and fix for In MixinData interfaces are sorted as sortedMixedInterfaceTypesSortx y xFullNameCompareToyFullName instead of sortedMixedInterfaceTypesSortx y StringCompareOrdinalxFullName yFullName or even better via sortedMixedInterfaceTypesSortnew FieldReferenceComparer where FieldReferenceComparer could be renamed to TypeNameComparer This causes wrong ctor order and fails to create an instance with strange message due to bad internal order I fixed my immediate problem by changing names but it would be nice if this is fixed eventually NET Core introduces support for unloading assemblies after loading them into a custom AssemblyLoadContext via the new Unload method and constructor with isCollectible parameter The custom AssemblyLoadContext is set up to only contain the assemblies you want with everything else being in the default context Obviously this is a NET Core feature and NET Framework will never support it NET Standard also does not define SystemRuntimeLoader classes Unfortunately it looks like dynamic assemblies were missed and support for them wont make the cut for NET Core NET Framework introduced AssemblyBuilderAccessRunAndCollect which allows dynamic assemblies to be garbage collected when no reference is held RunAndCollect has a whole heap of restrictions on what can be emitted into the assembly eg no COM interop but I think we could fairly trivially add optin for this per ModuleScope to make it disposable I dont know how useful this feature would actually be since we dont get any requests for it but logging this as an enhancement to raise the topic since it is possible It sounds like it RunAndCollect could be helpful for This is in response to It complements construction and does the fun bit Image of Trogdor the Burninator Some things that need to be done outside of this PR Update this repos summary diff Castle Core including Castle DynamicProxy Logging Services and DictionaryAdapter Castle Core including Castle DynamicProxy and Logging Services X subUpdate the DictionaryAdapter link on the Castle Project homepage to no longer point at this reposub Update Created a separate PR for this Fixes I didnt and still dont quite trust this bug fix mainly because it seems far too easy for DP standards LoC However it makes good sense to match generic type parameters by position instead of by name in IL for instance generic type parameters are referred to by position eg The execution environment doesnt really care about the names To give us some added safety I ran a few additional checks X I ran the Moq unit test suite approx additional tests against the updated version of DP to see whether this might cause regressions further downstream Doesnt look like it X I verified that the original Moq issue which led to is fixed by this It is This should resolve At least as far as is possible noninterceptable methods such as nonvirtual sealed or private methods of course still cannot be forwarded to the proxy Migrating from StackOverflow as per jonorossis suggestion The offending thirdparty interface is IDebugProperty provided by Microsoft And more specifically its the ref Guid guidFilter arg of the EnumChildren method that fails to be assigned to I have confirmed that my implementation of EnumChildren see below that is not wrapped in a proxy will also throw an AccessViolationException public int EnumChildren enumDEBUGPROPINFOFLAGS dwFields uint dwRadix ref Guid guidFilter uint dwAttribFilter string pszNameFilter uint dwTimeout out IEnumDebugPropertyInfo ppEnum guidFilter GuidNewGuid StackOverflowDescription Im hitting an AccessViolationException when trying to use an interface proxy that is wrapping a thirdparty interface The exception is being thrown when the emitted code writes the invocation arg array back to the original arg for a ref type arg Presumably this is because the thirdparty component has given an in only parameter and it should not be written to So I was wondering if DynamicProxy could be configured or enhancedhacked to not write back some args Maybe by configuring a custom code emitter or something Or thinking outside of the box would it work to apply an InAttribute at runtime to the thirdparty interface assuming DynamicProxy can be configured to adhere to this attribute Other maybe useful information The thirdparty interface doesnt use the in keyword or InAttribute on the offending ref arg Im trying to use interface proxies created with a target Example code namespace thirdparty public class IService public int DoSomethingref Guid guid namespace domainns public class ServiceImpl IService public int DoSomethingref Guid guid return public static void mainstring args var proxy proxyGenCreateInterfaceProxyWithTarget new ServiceImpl thirdpartyAddServiceproxy Indirectly causes proxyDoSomething to be called Throws an AccessViolationException thirdpartyGo StackOverflowDescription It is very useful that open generic types can be supported 