Hi thank you for this crate I love the combo of declarative performant infrastructure Was wondering if youd be open to a PR for line and column info To do this Id like to add a method to Lexer that returns a Span representing the extent of the token This would probably be a pair of Pos structures where a Pos is a linecolumn tuple Tracking this information isnt a big deal but there may be some performance implications involved when scanning each token for newlines What do you think To be specific Im getting this issue with a ef a d cbf ccd cf ac e cc but not with efc dd e f ab a d d fe b e f a The ones inbetween causes me compilation errors so its hard to say which of them introduced the code that leads to this problem This is my configuration details summaryToken typesummary rust deriveDebug PartialEq Clone Copy Logos pub enum Token end EndOfProgram regex Text regex x afAF ntr Char regex Float regex xX afAF Hex regex Integer regex structboolcharintfloatstringcolort Type regex azAZ Identifier regex afAF afAF afAF afAF afAF afAF Color token BraceOpen token BraceClose token Assign token Comma token BracketOpen token BracketClose regex n token callback ignorecomments error UnexpectedToken UnexpectedEndOfProgram details details summarySufficient amount of document causing lexing issues in summary tileset Default Tileset tileWidth tileHeight descriptionFoobar authorBazQuux version texture terrainpng terrainsprite sprites terrainsprite grass sprites Height Height Height Height Height Height Height Height Height heightSplits snowSprites edgeSprites snowEdgeSprites details snowedDetails detailsChance burntOverlay corruption details details summaryRelevant part of token stream on summary Comma Integer BracketClose Identifier corruption Assign BracketOpen Integer details details summaryRelevant part of token stream on summary Comma Integer BracketClose Identifier c Identifier orruption Assign BracketOpen Integer details As you can see in I get a single Identifier token with the value corruption from while in I get two Identifier tokens one with the value c from and one with the value orruption from This is obviously a bug the lexer should do as in and consume the whole identifier at once not divide it like it does in By chance after experimenting trying to figure out what differentiated identifiers that stayed whole from those that got divided like this before submitting this issue I discovered that the cause is when an identifier has a twoormore character overlap with any of the keywords in the Type token corruption gets well corrupted because of the color and if you change burntOverlay to borntOverlay overlaps with bool you get the same behavior there It seems like a partial match from one token doesnt get correctly dealt with when another token matches fully later By removingcommenting out the Type token the behavior ceases Look at the picture If I didnt cancel it the rustc will be stuck for a long time and then tell a error Sometimes it even make my system crash deriveLogos Debug PartialEq enum Token end End error Error tokenfast Fast regexlexer Lexer regex az Word fn main let mut lexer Tokenlexerfast lexer asserteqlexertoken TokenFast lexeradvance asserteqlexertoken TokenLexer Are there any guarantees of these two tokens in the code to be TokenFast and TokenLexer rather than TokenWord This lexer rust deriveLogos Debug PartialEq enum Token end End error Error regex aa Aaa incorrectly matches a single a Changing the regex to aa makes it work correctly Not sure if this is related to the previous issues with the regex macro but this code results in stack overflow in the compiler rust extern crate logos use logosLogos deriveLogos Debug PartialEq enum Token end End error Error regex Text fn main Given this token rule Rust regex r pXIDStart pXIDContinue LiteralIdentifier logos will spin up a single CPU core to then receive a SIGKILL if the core overheats Otherwise when my laptop manages to keep the core from overheating compilation seems to take a billion years Well at least min I CtrlCd out of impatience RAM usage is pretty low though So things that might help Find opportunities to parallelise the work Figure out when work takes too long and maybe sleep for a little or be nice Whatever else helps getting this beast to work Until then Ill have to use ASCII identifiers Edit Using v from Edit Compilation never seems to finish With successful cooling the core still overheats And logos starts using a lot of RAM so might also be related to So Im realizing that what I actually need is a parserlexer However I dont know if that relates to chewing up all the memory or not so I figured Id submit this anyway just in case it helps solve a problem This is the lexer Im working with Rust deriveLogos Debug PartialEq enum Token end End error Error regex rs BlockCommentStart regex r n LineComment regex r s RootNode regex r s digit alpha s digit alpha s Node regex r s NodeEnd regex rm s digit alpha s s alpha digit Property regex r s alpha s alpha digit n Directive regex r sinclude alpha digit hdtsi Include regex r s alpha digit n NonStdProperty The problem is that in addition to taking forever to finish it will use up all GB of RAM on my machine and then die when it tries to grab another MB at some point If this is doing more than what Logos is supposed to go ahead and close this out Hi there I am trying out your library but am having trouble with compiler errors use logosLogos previous import of the macro Logos here use logosderiveLogos Logos reimported here I am trying to to the InnerOuter lexer switch as in the test example code If I DONT specify use logosderiveLogos then the compiler says it cannot find advanceas and if I ONLY specify use logosderiveLogos then compiler complains about not finding Outerlexer Kind regards Calvin Hi while playing with Logos I noticed that for similar regexs which share the same start for example the longest match is not necessarily chosen I dont know if this is the same issue as because in this case two regexs create the problem rust use logosLogos deriveLogos Debug PartialEq enum Token end End error Error regex azAZ Text regex r azAZ Base fn main let lexer TokenlexerSGVsbG gV ybGQ asserteqlexertoken TokenBase I tried the code with version and version rc but both versions behave the same