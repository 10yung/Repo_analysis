The Elastic Support Matrix shows that Java OracleOpenJDK is supported for Logstash version and newer but does not mention AdoptOpenJDK For Elasticsearch the support matrix clearly shows AdoptOpenJDK is compatible with multiple versions However the Logstash section does not include AdoptOpenJDK specifically This enhancement request is to either Clarify and document if AdoptOpenJDK is supported for Logstash or Open the floor to discussion on if AdoptOpenJDK canwill be supported for Logstash I have created this image for testing own logstash filters It works well so far and I am using it quite a while successfully I have described my problem with image size in the readme of the image The image is currently quite huge what might be a burden on a CI server I am more a logstash user than a developer So if anybody has more insights about what is really necessary and whats not to run rspec tests Using a multistage docker build to decrease image size would be a very nice PR In the github repo there is also a variant using an alpinejdk base image But that one doesnt work so far and I dont have the time right now to investigate Can anybody of the Logstash contributors help with that Or just give me a hint what could be removed from the image for running the tests This PR simply use deprecation logger to write a warn message once the internal monitoring collector is used because its going do be removed in version Solves NB must be included in LS the underlying Java exceptions leak out thus its hard to rescue an invalid URI sample spec ruby consider config proxy validate uri with parameter set to smt invalid proxy one can not simply expect subjectregister to raiseerrorArgumentError URI is not validi but needs to know the specific Java exceptions begin subjectregister rescue ArgumentError e expectemessageto match URI is not validi rescue javanetURISyntaxException e expectemessageto match scheme namei else fail exception not raised end The Module is broken with the current version The Type needs to be changed from syslog to doc to fix the issue Because our source files for java pipeline execution are independent of each other SPOILER they are we do not need to share a single instance of SimpleCompiler nor chain our ClassLoaders sequentially with ISimpleCompilersetParentClassLoader ERGO we do Discovered while reviewing Additionally I think this gives us the benefit of not having indefinitely chained classloaders meaning pipelines that have been stopped may be able to reclaim more of their memory once their classes are dereferenced A middleground implementation allowing us to continue the hacked reuse of SimpleCompiler would be to have a static final ThreadLocalISimpleCompiler COMPILER ThreadLocalwithInitialSimpleCompilernew which would ensure that we dont interleave calls to ISimpleCompilercook and ISimpleCompilergetClassLoader Per discussion in per yaauie observation Note that WorkerLoopTHREADCONTEXT is a ThreadLocal so each java thread can pull its own ruby thread context out The trouble arises if and when a java thread ever runs multiple ruby threads in the course of its lifetime which I do not know since we only populate it with ThreadLocalwithInitial and then use WorkerLoopTHREADCONTEXT in to pass a ThreadContext to various ruby internals that then use it to determine interrupt state This is the code in question We should investigate further into this Version SNAPSHOT Operating System any Config File input stdin codec json charset UTF filter sleep time output stdout codec rubydebug Steps to Reproduce run logstash binlogstash f path to config file javaexecutiontrue With breakpoint on the execution pass twice for same plugin definition because invoked by CompiledPipelineconvertArgs and CompiledPipelineconvertJavaArgs from The convert invocations are one for Ruby plugin and the other for Java plugin but at the end the pipeline use only one of the two Then there is also different behaviour for Java part because invokes the expandConfigVariables to substitute the variables while the other no About this eventual case look at 