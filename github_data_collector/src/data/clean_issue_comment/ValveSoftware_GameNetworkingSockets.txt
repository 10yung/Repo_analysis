Great work on the open source side of things I forked and created a gateway example specific to the Syscoin cryptocurrency network for UDP propogation of mempool transaction packets to help with the realtime doublespend detection of ZDAG our pointofsale crypto currency algorithm I needed a high throughput UDP propogation for messages without verification just hash dedups was enough You can find my work here I noticed that if I used the global interface that you created in GNS library I get call backs on the client as a server it seems that the callbacks get confused and then the GatewayServer incoming messages dont pick up the actual request and times out I get the AssertMsg false Application didnt accept or close incoming connection in a reasonable amount of time This is probably a bug message leading me to believe either Im not setting up the callbacks properly or that the interface is incompatible with incoming and outgoing at the same time being the same IP doesnt matter I created a network to illustrate the error From gateway A I set outgoing to gateway B and from B I set outgoign to gateway C and from C I set outgoing back to A and A throws up soon as C tries to connect because the client poller gets the message instead of the server for some reason This led me to believe that each outgoing client and server needed its own ISteamNetworkingSockets interface which handles its own message queue on the server it handles child connections but incoming and outgoing connections dont confuse the interface So I actually return the new interface from GameNetworkingSocketsInit and take care of deleting the object had to add virtual Destroy to the base class so Destroy can be called on the interface as well this way my outgoing GatewayClients all have their own interface and the server creates one GatewayServer to manage incoming connections which does work so question is is it a bug in the internal guts which causes confusion between interface reuse between listeningoutgoing connections or is the pattern Im using wrong or is the right way to have the application manage their own interface and take care of destroying it when they are done If having your own interface makes sense I can PR that in Thanks For the visual studio building instructions for protobuf this cmake command is used C dev protobuf cmakebuild cmake G Ninja DCMAKEBUILDTYPERelease DprotobufBUILDTESTSOFF DprotobufBUILDSHAREDLIBSON DCMAKEINSTALLPREFIXc sdk protobufamd cmake And for GameNetworkingSockets cmake this command is used cmake G Ninja Not sure if this is just an issue with my setup but this caused a whole bunch of errors and had to use this command for the GameNetworkingSockets cmake to get it working cmake G Ninja DCMAKEBUILDTYPERelease So not sure if this is an issue for anyone else but if it is it might be good to update the building instructions Added compiletime option for using libsodium for crypto as well as setup for the CI to build and test it Main caveat is that AES is only supported in libsodium if the CPU has instructions for it Probably could do with some cleanup especially around formatting is there a style guide andor a clangformat file for the house style Ive overlooked Change to abstract Protobuf ByteSize ByteSizeLong is there because one of the Travis builds broke without changing to ByteSizeLong and other builds broke if everything was changed to ByteSizeLong An alternative solution would be to ignore the deprecation warning While this library has shown to scale up to larger server based use cases and crosscontinent P P connections the lack of a LAN discovery tool for quick and dirty LAN play makes it hard to scale down Im working on direct v games that will largely benefit from avoiding a hop to the nearest relayauthoritative server to establish a game over the same subnet This PR improves the global locking mechanism to prevent a thread from being starved out of execution due to the inability to acquire a lock in favor of other threads It also eliminates the hacky MSVC workaround Proposed mutex is based on firstin firstout scheduling which guarantees fairness This implementation tested and compatible with Linux G Linux Clang macOS Clang Xcode Windows MSVC Visual Studio Windows G MinGW Improves Hello When running the library without OpenSSLs implementation and using valves implementation will result in an error when connecting server side in bool CECSigningPublicKeyVerifySignature const void pData sizet cbData const CryptoSignaturet signature const To reproduce simply build the examples in bits with the defines to toggle Valves implementation Are there any plans to expose flattened interface for IGameNetworkingSockets in the Steamworks SDK like it has been done in opensource version Is there any ETA for this I was about to integrate the library into NetDynamics for tests but unreliable orderedsequenced message delivery is not supported unlike in other modern network transports It solves a vector of design and gameplay problems in practice where a developer doesnt need a manual frame buffering and sequence tracking but still needs a properly sequenced logic so from my point of view this delivery type should be available Hello Ive been excitedly watching this project for a while Id love to switch to it as the primary transport protocol for my project Since we dont have dedicated servers yet multiplayer sessions are userhosted so NAT piercing and relay servers are crucial I just wanted to ask if you have any rough estimate when this might be implemented Thanks for your time and hard work on this Hi there Im just trying to build the sampleCS demo in GameNetworkingSockets examples but it turns out a access error when Im trying to connect to server Access exception when try to write into x bool CCryptoKeyBaseGetRawDataAsStdString stdstring pString const pStringclear uint cbSize GetRawDatanullptr IDE VS Community Codebase Latest commit on master Thanks