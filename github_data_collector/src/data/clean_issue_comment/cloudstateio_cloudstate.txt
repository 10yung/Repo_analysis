Here What did you see img width altScreenshot at src What did you expect to see more emojions Additional Information might have introduced that Consider adding support in the Cloudstate protocol for propagating request and response metadata think for instance headers so that it is possible to inspect and return things like HTTP or HTTP headers for a given request Open questions Should this apply to ALL requestsresponses Should they be preserved no matter what Do we only allow standard headers Do we only allow custom headers Do we only allow specific headers Do we exclude specific headers Can we achieve most of the usecases without changing user code or the protocol Do we only allow it for some specific types think HttpBody requests Discuss Currently theres no simple way to run the proxy locally which means theres no way to run a stateful service locally and talk to it using its gRPC interface Of course you can run minikube or something like that locally but for development you may want to run your function with a debugger for example so you want to run it on your host machine not in a container For a development environment I think the basic idea would be to run the proxy in docker and have it call into the function running on the host container Theres a few challenges with this the biggest one is that theres no standard cross platform way for a docker container to know the IP address of the host see So well probably need some tooling to facilitate this Lets say we had a cloudstate command I would imagine something like this cloudstate runproxy httpport userfunctionport This would roughly translate to running docker run rm e USERFUNCTIONPORT e USERFUNCTIONHOSThostipaddress p cloudstateiocloudstateproxynativedevmodelatest Where hostipaddress was hostdockerinternal on OSX and Windows and the output of ip addr show docker grep Po inet K d on Linux Right now the USERFUNCTIONHOST environment variable isnt read so wed need to add support for that could be the defaults so if you were just testing one function you could use cloudstate runproxy but then if you wanted to run multiple youd specify ports Having run the above you could now instantiate a client for your gRPC interface and connect to it on localhost Easy We might also consider whether we want to support bootstrapping a cluster this would be a lot more involved of course It may make more sense to simply say if you want to test with a cluster use minikube ref As CRDs have become v stable now in K s they will require a schema going forward Having a schema means we can generate API documentation and users know exactly what fields are available in the CR This has some further implications to the current CRD structure We cant use a common config for StatefulStore for example It needs to be split up into structured schemas for each type like a postgresConfig and so on The current CRD is defined like this yaml apiVersion apiextensionsk siov beta kind CustomResourceDefinition metadata name statefulstorescloudstateio spec group cloudstateio This seems to break convention of defining a CRD group as a subdomain of the owned domain Examples are Istio which uses configistioio Prometheus which uses monitoringcoreoscom I ran into this because kubebuilder expects the API group to be a subdomain of the CRDs domain So it thinks this CRDs domain is io One common subdomain used for group is crd so we could consider changing it to crdcloudstateio I think technically this is allowed but as convention seems to indicate using a subdomain we should consider changing it to prevent future incompatibilities with tools and changes to k s itself No one knows what CRDTs are and they just introduce a layer of unfamiliarity We should rename them eg call the replicated entities This would mean updating all of the APIs to use this terminology as well as all the docs implement it as a pure langsupport alternative Related to 