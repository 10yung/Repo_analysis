With Xcode If I change Show checkbox on scheme management window Xcode make a little diff on xccheme files I use this library by gitsubmodule carthage and add xcodeproj to xcworkspace for application development So this diff makes work repository state dirty Please merge this This PR includes my other PR My environment macOS High Sierra Xcode Problem I just cloned master and got compile error below UsersomochigithubomochiRandomKitSourcesRandomKitExtensionsSwiftCollectionRandomKitswift Invalid redeclaration of uncheckedRandominusing UsersomochigithubomochiRandomKitSourcesRandomKitExtensionsSwiftCollectionRandomKitswift uncheckedRandominusing previously declared here UsersomochigithubomochiRandomKitSourcesRandomKitExtensionsSwiftCollectionRandomKitswift Type CollectionIndexDistance aka Int in conformance requirement does not refer to a generic parameter or associated type The lines with error is in macro section for Swift less than And a xcodeproj set swift version to Solution This PR changes Swift version from to and avoid this error When using the latest Xcode I get this error RandomKitSourcesRandomKitExtensionsSwiftCollectionRandomKitswift Type CollectionIndexDistance aka Int in conformance requirement does not refer to a generic parameter or associated type in extension Collection where Self RandomRetrievableInRange IndexDistance RandomToValue Returns a random element of self or nil if self is empty public func uncheckedRandomR RandomGeneratorin range RangeIndex using randomGenerator inout R IteratorElement let upper rangeupperBound let lower rangelowerBound let elementIndex IndexDistancerandomto distancefrom lower to upper using randomGenerator return self indexlower offsetBy elementIndex When using the latest Xcode I get this error RandomKitSourcesRandomKitExtensionsSwiftCollectionRandomKitswift Invalid redeclaration of uncheckedRandominusing in extension RandomRetrievableInRange where Self Collection SelfIndex RandomInRange SelfIndexDistance RandomToValue Returns a random element in range without checking whether self or range is empty public func uncheckedRandomR RandomGeneratorin range RangeIndex using randomGenerator inout R IteratorElement return self IndexuncheckedRandomin range using randomGenerator Currently master will not build via Carthage as the Xcode projects contain reference to a version of Swift pre Im waiting for a new version on the podspec for migration to Swift if possible Thank you From the docs Its recommended to not call withThreadLocal or get the threadLocal pointer each individual time its needed Retrieving the threadlocal instance incurs avoidable overhead That means right now Im passing the let threadLocal XoroshirothreadLocal From the thread into my functions eg init theadLocalRandom UnsafeMutablePointerXoroshiro Is there a better way Could RandomKit cache the UnsafeMutablePointer for each thread so that the application programmer didnt have to think about passing the thread owned pointer to each function called by the thread Thanks for the awesome repository and software Sometimes it might be helpful to be able to log seed that was used to create generator So we can reproduce same random sequence using that seed we know For example it can be logged for test suit session whose data is generated randomly And if some tests fail we can fix them and rerun test suit using that seed to verify it on the same random data Hi Im about to use RandomKit for unittesting Is there any way to save current seed and be able to create generator with the same seed next time in order to reproduce tests with same generated values Something like this but not to do whole thing every time swift let x UInt randomusing Xoroshirodefault let y UInt randomusing Xoroshirodefault var r Xoroshiroseed x y let z UInt randomusing r So basically for Xoroshiro it would be exposing state variable for readonly purposes This turns all RandomBytesGenerator into infinite Sequences of their Bytes type This type allows for consuming and iterating over a RandomBytesGenerator without having to call randomBytes directly This mainly serves as a convenience This is different than Randoms types because it doesnt take a mutable pointer to the source RandomGenerator So unless the iterator is shared there is unique access to the generator