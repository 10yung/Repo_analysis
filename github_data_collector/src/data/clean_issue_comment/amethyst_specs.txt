Fixes API changes This changes three things UnprotectedStorage has its item type as an associated type rather than as a generic type parameter The type parameter of MaskedStorage is now the inner storage rather than the item type This allows any item to be stored in a MaskedStorage rather than only Components MaskedStorage now has contains get and getmut methods Id like to create some components and then have a function that takes an entity and figures out what components it has and call the appropriate function Id also like to write systems but thats not the main focus Edit Missing a selection for questions At the moment MaskedStorage requires a Component bound on its type parameter and its missing two of the methods that UnprotectedStorage offers I think it would make the type more flexible with relatively little work if the following changes were made Remove the T Component bound instead adding a second type parameter S for the storage with a S UnprotectedStorageT bound Add the missing methods get and getmut that forward to the corresponding UnprotectedStorage methods With these changes the MaskedStorage type could be used for any T anything that needs an ID for lookup would work not just components It would make it simply a safe wrapper around UnprotectedStorage An example is Amethyst which currently uses UnprotectedStorage for asset storage but which has had to build its own safety wrappers If MaskedStorage were changed in this way users could use that type instead without safety concerns Description The ConvertSaveload doc references deriveSaveload which should be deriveConvertSaveload see Meta Rust version cargo c ec d Specs version commit master commit c a cdd dc ab ef f e c Operating system linux Reproduction Steps to reproduce the behavior Go to the specs project root directory Run grep rnw e deriveSaveload See places using the wrong name Expected behavior The documentation should show deriveConvertSaveload instead Description Im getting a runtime panic with Tried to fetch data but it was already borrowed Meta Rust version Specs version commit Operating system Arch Linux Reproduction Steps to reproduce the behavior Issue seems to only happen if I call dispatch on two different Dispatchers under specific conditions when in between I modify a resource inside a separate code block I suspect this forces the mut reference to that resource to be dropped but somehow the second dispatcher run panics with this error Execution quasiexample let mut state worldfetchmutState statedosomethingmutably dispatcher dispatch world worldmaintain let mut state worldfetchmutState expecting a modified state from dispatcher run statedosomethingelsemutably dispatcher dispatch world panics within here Expected behavior Both dispatchers shouldve executed fine Backtrace thread unnamed panicked at Tried to fetch data but it was already borrowed You can get the type name of the incorrectly borrowed data by enabling shreds nightly feature cargoregistrysrcgithubcom ecc db ec shred srccellrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingcontinuepanicfmt at srclibstdpanickingrs stdpanickingbeginpanicfmt at srclibstdpanickingrs shredcellTrustCellTborrowmutclosure at cargoregistrysrcgithubcom ecc db ec specs stdmacrospanic macros coreresultResultTEunwraporelse at rustc ea cb f a c e f srclibcoreresultrs shredcellTrustCellTborrowmut at cargoregistrysrcgithubcom ecc db ec shred srccellrs shredworldWorldtryfetchmutclosure at cargoregistrysrcgithubcom ecc db ec shred srcworldmodrs coreoptionOptionTmap at rustc ea cb f a c e f srclibcoreoptionrs shredworldWorldtryfetchmut at cargoregistrysrcgithubcom ecc db ec shred srcworldmodrs shredworldWorldfetchmut at cargoregistrysrcgithubcom ecc db ec shred srcworldmodrs shredworlddataWriteTF as shredsystemSystemDatafetch at cargoregistrysrcgithubcom ecc db ec shred srcworlddatars shredsystemimpldataimpl shredsystemSystemData for A B C D Efetch at cargoregistrysrcgithubcom ecc db ec shred srcsystemrs T as shredsystemDynamicSystemDatafetch at cargoregistrysrcgithubcom ecc db ec shred srcsystemrs T as shredsystemRunNowrunnow at cargoregistrysrcgithubcom ecc db ec shred srcsystemrs shreddispatchstageStageexecuteclosure at cargoregistrysrcgithubcom ecc db ec shred srcdispatchstagers coreopsfunctionimplsimpl coreopsfunctionFnMutA for Fcallmut at rustc ea cb f a c e f srclibcoreopsfunctionrs coreitertraitsiteratorIteratorforeachcallclosure at rustc ea cb f a c e f srclibcoreitertraitsiteratorrs coresliceIterMutT as coreitertraitsiteratorIteratorfold at rustc ea cb f a c e f srclibcoreslicemodrs coreitertraitsiteratorIteratorforeach at rustc ea cb f a c e f srclibcoreitertraitsiteratorrs rayoniterforeachForEachConsumerF as rayoniterplumbingFolderTconsumeiter at cargoregistrysrcgithubcom ecc db ec rayon srciterforeachrs rayoniterplumbingProducerfoldwith at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayoniterplumbingbridgeproducerconsumerhelper at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayoniterplumbingbridgeproducerconsumerhelperclosure at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayoncorejoinjoincontextcallaclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcjoinmodrs stdpanicAssertUnwindSafeF as coreopsfunctionFnOncecallonce at rustc ea cb f a c e f srclibstdpanicrs stdpanickingtrydocall at rustc ea cb f a c e f srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at rustc ea cb f a c e f srclibstdpanickingrs stdpaniccatchunwind at rustc ea cb f a c e f srclibstdpanicrs rayoncoreunwindhaltunwinding at cargoregistrysrcgithubcom ecc db ec rayoncore srcunwindrs rayoncorejoinjoincontextclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcjoinmodrs rayoncoreregistryinworker at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncorejoinjoincontext at cargoregistrysrcgithubcom ecc db ec rayoncore srcjoinmodrs rayoniterplumbingbridgeproducerconsumerhelper at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayoniterplumbingbridgeproducerconsumer at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayoniterplumbingbridgeCallbackC as rayoniterplumbingProducerCallbackIcallback at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayonsliceIterMutT as rayoniterIndexedParallelIteratorwithproducer at cargoregistrysrcgithubcom ecc db ec rayon srcslicemodrs rayoniterplumbingbridge at cargoregistrysrcgithubcom ecc db ec rayon srciterplumbingmodrs rayonsliceIterMutT as rayoniterParallelIteratordriveunindexed at cargoregistrysrcgithubcom ecc db ec rayon srcslicemodrs rayoniterforeachforeach at cargoregistrysrcgithubcom ecc db ec rayon srciterforeachrs rayoniterParallelIteratorforeach at cargoregistrysrcgithubcom ecc db ec rayon srcitermodrs shreddispatchstageStageexecute at cargoregistrysrcgithubcom ecc db ec shred srcdispatchstagers shreddispatchdispatcherDispatcherdispatchparclosure at cargoregistrysrcgithubcom ecc db ec shred srcdispatchdispatcherrs rayoncorethreadpoolThreadPoolinstallclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcthreadpoolmodrs rayoncoreregistryRegistryinworkercoldclosureclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncorejobStackJobLFR as rayoncorejobJobexecutecallclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcjobrs stdpanicAssertUnwindSafeF as coreopsfunctionFnOncecallonce at rustc ea cb f a c e f srclibstdpanicrs stdpanickingtrydocall at rustc ea cb f a c e f srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at rustc ea cb f a c e f srclibstdpanickingrs stdpaniccatchunwind at rustc ea cb f a c e f srclibstdpanicrs rayoncoreunwindhaltunwinding at cargoregistrysrcgithubcom ecc db ec rayoncore srcunwindrs rayoncorejobStackJobLFR as rayoncorejobJobexecute at cargoregistrysrcgithubcom ecc db ec rayoncore srcjobrs rayoncorejobJobRefexecute at cargoregistrysrcgithubcom ecc db ec rayoncore srcjobrs rayoncoreregistryWorkerThreadexecute at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncoreregistryWorkerThreadwaituntilcold at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncoreregistryWorkerThreadwaituntil at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncoreregistrymainloop at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncoreregistryThreadBuilderrun at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs rayoncoreregistryDefaultSpawn as rayoncoreregistryThreadSpawnspawnclosure at cargoregistrysrcgithubcom ecc db ec rayoncore srcregistryrs Is the order in which entities appear in a join deterministic at all As in is it predictable based on the current world state and thus replicable If not does Specs offer any tools to achieve this Ive been going through the specs guide as Im consider porting my WIP game to use specs instead of my own ECS The guide has been excellent and has set me up to be able to port with relative ease One thing that feels missing is advice and guidance around writing tests for systems It would be awesome if there was a dedicated chapter on the subject with a few examples of good system tests Im sure that Ill be able to dig around the API and figure out my own best practices for writing my tests since specs has such an intuitive API but itd be nice if instead of spending somewhere between mins thinking through that the guide just gave me guidance from the start like it it did for everything else Thanks for the consideration cheers Updates the requirements on uuid to permit the latest version details summaryCommitssummary See full diff in compare view details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details Description Using the JoinIterget method it is possible for a user of specs to create two mutable references to the same component data without the user writing any unsafe code Here is a simple program that illustrates the issue rust use specsBuilder Component DenseVecStorage Join World WorldExt WriteStorage deriveDefault struct TestComponent value u impl Component for TestComponent type Storage DenseVecStorageTestComponent fn main let mut world Worldnew worldregisterTestComponent let entity worldcreateentitywithTestComponentdefaultbuild worldmaintain let mut storage WriteStorageTestComponent worldwritestorage let entities worldentities let mut joiniter mut storagejoin let aliasedref joinitergetentity entitiesunwrap let aliasedref joinitergetentity entitiesunwrap printlnaliasedref is initially aliasedref value aliasedref value println After change to aliasedref aliasedref is now aliasedref value When I run this program I get the following output aliasedref is initially After change to aliasedref aliasedref is now The issue doesnt seem too hard to avoid as long as I only use JoinIter for its intended purpose as an iterator but even so the fact that I can violate Rusts aliasing rules without writing unsafe seems like an issue Perhaps JoinIterget needs to be made private to the specs crate or maybe it just needs to be marked unsafe I imagine the same issue can occur with JoinItergetunchecked though I havent tested it Meta Rust version edition Specs version commit Operating system Ubuntu LTS bit Reproduction Steps to reproduce the behavior Compile the Rust program given above Run the program See in the output that the value at aliasedref changed even though aliasedref wasnt mutated directly Expected behavior I would expect the above code not to compile at least not without modifying it to include an unsafe block Hi all DenseVecStorage The problem is located in this function Having uninitialized data inside a slice is instaUB in this function dataid has uninitialized u thanks to the contract of setlen not being respected Then getuncheckedmut will create a slice and trigger UB This slice is created in every function accessing data inside the storage too This could be fixed by replacing uninitialized value by or stdu MAX for example its never accessed anyway VecStorage The problem is in insert too and spread to any function accessing data in the storage This is basically the same thing a call to setlen not respecting the contract followed by a call to getuncheckedmut but this time its a VecT I think the solution would be VecStorageTVecMaybeUninitT An other way would be to index inside the Vec using raw pointer only but thats dangerous since any classic access would still trigger UB Also creating a reference to uninitialized data is not currently ok but might change in the future for some types like u so it might be a good thing to replace them with raw pointer arithmetic