I am trying to mount a choo application in an application shell that is provided by a static site generator I would expect the routing behavior to be limited to the scope of choos application host yet nanohref will try to handle all anchors being clicked Looking at the nanohref docs this behavior seems to be supported by passing a second rootNode argument to the nanohref function Looking at how choo itself is using nanohref it looks like passing a second argument is not intended This leads me to two questions Is it possible to achieve this behavior in some other way In case no would you accept a PR that enables passing the application root to nanohref as well In this case I have to admit I am slightly unsure how the API for this could even look like considering how there is basically zero surface area for options in choo Expected behavior choo should accept valid JS code in the emitter callback Actual behavior choo throws Unexpected token punc while parsing file appindexjs when an ES arrow function is used the emitter callback Steps to reproduce behavior This is working code adapted from the intro tutorial running on glitch const choo requirechoo const html requirechoohtml const main requiretemplatesmainjs const app choo appusefunction state emitter stateanimals type lion x y type crocodile x y emitteronaddAnimal function const obj type lion x y stateanimalspushobj emitteremitrender approute main appmountdiv When I replace function with emitteronaddAnimal const obj type lion x y stateanimalspushobj emitteremitrender choo throws the above error Some kind of magic going on This is more of a help wanted issue The problem that I am having is that I am attempting to put a choojs app that is not on the root path of site ie mysitecomuserid Instead I am attempting to run the site on mysitecombizbazmyappuserid What do I need to do assuming I dont have server control to get my hash routes to work on an arbitrary root location on the path Ive tried the following and this didnt work for me const prefix bizbazmyapp approuteprefix welcome approuteprefixuserid user Is there a trick that I need to do in order to stick my choo app on a subregion of mysite Thanks Expected behavior Ive written some routes that are not behaving as expected I initially started off with the createchooapp scaffolding however that required turned out to only be a good idea for development When it came to deployment my dynamic routes were all broken when I tried to push up my dist folder to s where I am going to eventually host my choo site So rather than use the fancy bankai package I thought I would use browserify to get everything working Again this caused all my routes to break Am I missing something or do you have to run something like budo or bankai in order to serve the page up Here is basically what I am doing indexhtml html head script srcbundlejs script head body body html indexjs var html requirechoohtml var choo requirechoo var app choo approute placeholder approuteuser placeholder approuteuserrepo placeholder approuteusersettings placeholder approute placeholder function placeholder state consolelogstateparams return htmlbodyplaceholderbody appmountbody browserify command browserify indexjs o bundlejs When I run a simple http server like python m simpleHttpServer my initial route comes up fine But then if I attempt to type localhost homer into the address bar I get a error I would expect that I should get placeholder I guess ultimately my question is how do I get everything nice and packaged in the browser so that I can manually type routes in the address bar and get the results I am anticipating Thanks Itd be rad to be able to use choo in a nobuild environment Thanks Porting to be a firstclass citizen in Choo Should allow loading routes async directly Right now the API is prefixed with experimental as it probably requires some discussion on how to stabilize But feel its worthwhile adding a nonhacky way to allow this in the meantime If anything so we can iterate on the functionality while keeping clear that this isnt ready for prime time yet Thanks Expected behavior moduleexports appmountbody should work on the browser with browsers APIs Actual behavior Using fetch ends up in fetch is not defined error which dissappears when I change moduleexports appmountbody with appmountbody Steps to reproduce behavior Run npx createchooapp someapp and replace the main view with js var html requirechoohtml moduleexports view var readme function view state emit if readme fetchREADMEmd thenresponse responsetext thentext readme text emitrender return html body classsansserif pa readme htmlh Loadingh body Then run npm start and it will throw something like txt ReferenceError fetch is not defined at Chooview as handler homeyerkoDevchootalkviewsmainjs at Chooprerender homeyerkoDevchootalknodemoduleschooindexjs at ChootoString homeyerkoDevchootalknodemoduleschooindexjs at Objectmoduleexportsrender homeyerkoDevchootalknodemodulesbankaissrchoojs at ServerRenderrender homeyerkoDevchootalknodemodulesbankaissrindexjs at ArrayrenderApp homeyerkoDevchootalknodemodulesbankailibgraphdocumentjs at moduleexports homeyerkoDevchootalknodemodulesrunwaterfallindexjs at documentifyRoute homeyerkoDevchootalknodemodulesbankailibgraphdocumentjs at push homeyerkoDevchootalknodemodulesmaplimitindexjs at flush homeyerkoDevchootalknodemodulesmaplimitindexjs Fixes Rendering in Choo is a completely synchronous process thought this makes things way simpler there are a few downsides from perspectives CPU Rendering complex components might block the main loop affecting the overall experience IO Its not possible to make the render wait for asynchronous IO events such as data loading I believe the later is the most relevant when it comes to SSR One of the biggest issues of sync SSR is related to data loading and codesplitting There are several workaround strategies to deal with async IO on a sync rendering process most of them require a firstpass render to load or collect something you can wait on and signal when the data is available to read synchronously Besides being a waste of CPU cycles its also not very elegant and adds unnecessary complexity to the code One could just not have SSR but being able to have truly isomorphic or universal app is a requirement for most contentdriven apps When I think of async rendering I think of composing the view using sync or async components and then one of two things can happen Wait until all the components are resolved and then apply node diffing Apply node diffing as components resolve Ideally both scenarios should be allowed giving that choice to the developer but I believe the first one is easier to start with given the current Choo architecture Overall it should look somehow like this js const h requirechoohtml const syncComponent state emit h pstatelabelp const asyncComponent async state emit const data await asyncDataFetchstateid return h pdatap const view state emit h div syncComponentstate emit asyncComponentstate emit div Given that there are a few necessary steps Make prerender function on Choo await for the promise returned by the render to resolve Make belnanohtml also accept promises Make mount start toString methods on Choo async since they rely on prerender There are a few openended questions at the moment Error handling in general What should happen when a render event is triggered within a render call Possibly others and I would like to open that discussion to the community 