I created a separate stratis filesystem for my virtualbox disks I created tree vmdk for a vm in the root of the mounted stratis fs In the vm I create a zfs pool from that tree disks After the reboot of my Fedore host cant mount he stratis fs for the virtualbox by UUID I tested the device of this stratis fs and get this result blkid p devmapperstratis ac c b ca a a ca d thinfs fef d b c ffd blkid devmapperstratis ac c b ca a a ca d thinfs fef d b c ffd ambivalent result probably more filesystems on the device use wipefs to see more details So what other filesystems wipefs devmapperstratis ac c b ca a a ca d thinfs fef d b c ffd DEVICE OFFSET TYPE UUID LABEL stratis ac c b ca a a ca d thinfs fef d b c ffd x xfs fef d b c ffd stratis ac c b ca a a ca d thinfs fef d b c ffd x f zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x e zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x c zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x b zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x c zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x b zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember stratis ac c b ca a a ca d thinfs fef d b c ffd x zfsmember Somehow the zfs membership is written into the stratis fs How If the vmdk is not in the root of the stratis fs but in a folder there is no problem My environment OS Fedora Stratis yum list installed grep stratis stratisclix modulef bf c fedoramodular stratisdx modulef bf c fedoramodular When should the filesystem extend I have a filesystem with comes to the limit of TB df tells me im on of usage and GB left stratis fs list stratispool fsarchiv GiB Mar stratisstratispool fsarchiv fa f f a fbb d a df devmapperstratis eb dac cb dac a daethinfs fa f f a fbb d a mntarchiv Would it be if it goes to or before Im currently on latest which provided by fedory stratisd modulef bf c x stratiscli modulef bf c x As seen below the debug log is expressing the uuid as a decimal bytebybyte representation on multiple lines rather than the standard hex singleline representation This is inefficient to read or for any sort of uuid comparison since a conversion to hex would be required INFO stratisd Dump timer expired dumping state DEBUG stratisd Engine state SimEngine pools testpool SimpleRef Uuid SimPool blockdevs Uuid SimDev devnode junk rdm RefCell value Randomizer userinfo None hardwareinfo None initializationtime dbuspath MaybeDbusPath Some Path orgstoragestratis We need to extend our existing device discovery framework to identify encrypted devices If we think purely of the organization of the data structures returned by findall or an analogous function which is specific to encrypted devices There must be an enumeration for encrypted block devices not Stratis ones because that will not be visible We expect that IDFSTYPE will have value luks I believe Each device presented by the udev enumeration must be examined using libcryptsetup to take a peak at the correct token which must identify the Stratis pool and device UUID This information is enough to group the devices by pool UUID As with the existing code we ignore the possibility of duplicate Stratis device UUIDs An important consideration is that we must handle correctly a situation where some pools are encrypted and some pools are not What might conceivably make this trickier is that some devices might be already opened by some outside agencies and thus available as Stratis devices and some belonging to the same pool might be still unopened If we group it together we can keep track of its invariants better metadata management for a single device has already been grouped into the metadata module What were talking about here is metadata discovery when given a group of devices or metadata update on all the devices belonging to a pool Ideally this would be checked for on both the initial startup path and on the udevevent drive part For the udevevent driven part this should be checked both for presence in existing pools ie when a new device shows up but its doppelganger has already been incorporated into the pool and also that it does not introduce duplicate devices into the list of devices for incomplete pools Note that and this issue intersect although the scenario actually described in does not mention duplicate Stratis UUIDs the problem would be the same We need a bunch of checks not just on individual blockdev members of a pool but also on the consistency of the pool as a whole One of those checks is the check for duplicate block devices ie two distinct block devices ie able to be distinguished because they correspond to different device nodes but having the same Stratis pool and device UUID Another such is the verification that all block devices are openable by the same encryption key Where is it best to be doing this check We dont really do either of them yet this first is in an implementation that only partially handles the problem in StratEngineblockevaluate and the second is still in development The development places the check for the second in Backstoresetup see PR There is a pretty strong argument for placing the second in the same place Even if that decision is made however findall must be modified so that it returns data structures that at least allow this problem to be visible The argument is that these checks are about whole properties of the pool and may at some time require access to the pool internals For example blockevaluate could be simplified to drop its checks for duplicate UUIDs then if a new block device is found it will be added to a group in the incompletepools list and setup will be attempted At that point setup will fail due to the duplicate pool UUIDs that it discovers Similarly setup must fail if the block devices are discovered to be variously encrypted If that is the problem though should we perhaps blacklist the pool involved just as we would blacklist a pool discovered to have duplicate devices Supersedes 