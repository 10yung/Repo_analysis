Custom legends are sensitive to whether its a fill or colour aes Switching between one and the other with essentially the same data is common Currently if you forget to change eg colour to fill for your custom legend colour scheme ggplot ignores your colour scale custom legend since the colour aes is not specified and uses the default for the colours legend since no information is provided for the fill aes Below p uses colour p uses fill but the user forgot to update scalecolour libraryggplot libraryRColorBrewer p ggplotiris aesx Species y SepalLength colour Species geomboxplot scalecolourbrewer name Dude which plant palette Set p ggplotiris aesx Species y SepalLength fill Species geomboxplot scalecolourbrewer name Dude which plant palette Set p uses default legend and colour scheme without telling the user For p it might be useful to have a warning saying you used scalecolour but didnt specify a colour aesthetic or something like that May be related to Two missing backticks and a several missing newlines were causing incorrect or inconsistent rendering of markdown In case a transformation is applied the geomhline function takes the intercept in the initial scale contrary to the other geoms r examplePlot p ggplotmpg aesdispl hwy geompoint scaleylog The line is created if the intercept is specified in the original nontransformed scale in geomhline r hlineinterceptraw p geomhlineyintercept ggplothlineinterceptraw Contrary to the geomabline behaviour r ablineinterceptlog p geomablineintercept log slope ggplotablineinterceptlog This PR addresses an issue in scales If a label function converts an NA break to a character label we will get an error later on when we enlist the label list This is fixed here in the ScaleContinuousgetlabels function by converting such list elements to empty strings instead It can be argued that this should get fixed in scaleslabelnumberauto and perhaps it should as well but I think it makes sense to have a guard in ggplot as well since otherwise this problem will be carried all the way to guideaxis and create an unintelligible error there Since there are now divergent continuous color palettes available in different packages it would be nice to be able to specify a midpoint without manually having to calculate the limits related issue Fix Not all variables in a facet spec are available on all the layers A solution suggested on is bind the same symbols inside each panel and when the symbols are undefined use an active binding to throw a typed error And then youd only catch these particular errors in the tryCatch This PR injects such an active bindings on the column names of all the plot data so that we can let evalfacet fail gracefully Note that this PR removes env argument of evalfacet to avoid confusion I believe all facet specs are converted to quosures and bare expressions are not allowed which means env is always ignored on evaltidy r devtoolsloadallrepoggplot Loading ggplot works fine with expressions ggplotmtcars aesmpg cyl geompoint geomvlinexintercept facetwrapvars am r works fine with external variables two ggplotmtcars aesmpg cyl geompoint geomvlinexintercept facetwrapvarstwo am r raises an error when the expression refers to some nonexistent variable ggplotmtcars aesmpg cyl geompoint geomvlinexintercept facetwrapvarsnosuchvariable am Error in evaltidyfacet data object nosuchvariable not found special case raises a friendlier error when the expression is a symbol ggplotmtcars aesmpg cyl geompoint geomvlinexintercept facetwrapvarsnosuchvariable Error At least one layer must contain all faceting variables nosuchvariable Plot is missing nosuchvariable Layer is missing nosuchvariable Layer is missing nosuchvariable supCreated on by the reprex package v sup TODO Add a NEWS bullet Consider using warnforaesextractusage here as well Consider if its really OK to add a param to Facet I bet its OK Updating ggplot from v to v I encountered the problem within a previously working programme that the grammar of specifying colors apparently has changed the expression geomtextaesxx yy labeltext color simply suppressed the text completely without error message After changing the color attribute to colorblack the label reappeared again in black as before A few though not exhaustive tests with other numbers showed the same behavior Originally commented at Currently legends reflect the value of afterscale But its not always possible because the expression of afterscale might refer to the variable unavailable at the stage of drawing legends For example I think it is a proper usage of stage to modify scaled colours by combining other aesthetics But the following example has two problems x is not available on drawing legends even if we manage to make x available its not clear what legends should be drawn because the scaled colours are discrete but the afterscaleed values are continuous Especially because of the problem I think legends should use the raw scaled values not the afterscaleed ones r libraryggplot setseed d dataframex runif y runif g repca b c each p ggplotd geompointaesx y colour stageg afterscale alphacolour x size fail p Error in alphacolour x object x not found ok p themelegendposition none supCreated on by the reprex package v sup In previous ggplot versions the following was valid r libraryggplot df dataframex y ggplotdf aesx y col factorx geompoint scalecolourmanualvalues cred green blue teal breaks factor In the release candidate it errors revdep failures on at least auditor ezplot GDCRNATools ggmuller obAnalytics RAM r libraryggplot df dataframex y ggplotdf aesx y col factorx geompoint scalecolourmanualvalues cred green blue teal breaks factor Error Differing number of values and breaks in manual scale values provided compared to breaks Shouldnt the number of values line up with the number limits instead of the breaks Otherwise how would you map colours and not include them on the guide niche behaviour but its possible with other colour scales There is no help page for scalecolordiscrete and it doesnt appear on ggplot tidyverseorg 