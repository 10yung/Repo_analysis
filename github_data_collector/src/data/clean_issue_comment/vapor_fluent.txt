I need to be able to model this in Fluent sql DELETE FROM devices d WHERE NOT EXISTS SELECT FROM registrations r WHERE did rdeviceid LIMIT Thats the PostgreSQL version of Delete all rows from the devices table where the device ID doesnt appear in the registrations table under the deviceid foreign key Ive come across a few places where it makes ergonomic sense to use a Set in my Swift code I understand that none of the database backends support storing of native sets however arrays do seem to be supported I would love to be able to have my Fluent models expose a Set property but save to whatever the native database field type is and transparently serialisedeserialise as required I give devs option which DB to use in which case I have to do something like fieldid uuid identifierauto WebugDbIdTypeself Intself please note the uuid will be dynamic as well This could be useful when having a database structure that uses subclassing Think of the scenario where only the id of the superclass is know but you need the extra information form the subclasses that also contain the same id By using optional decoding you would be able to left join the different types on the ids and from there derive what type it is The alternative would to do a find on the different models but this would lead to more requests and possibly a lower performance Add the SQL MERGE aka UPSERT capability to fluent Related And the whole app crashes on the next request System info macOS E Xcode E Apple Swift version swiftlang clang From Packageswift packageurl from packageurl from Im trying to run this reversion static func revert on connection MySQLConnection FutureVoid return Databaseupdate Userself on connection builder in builderdeleteFieldfor shareToken This is the output I get with databasesenableLoggingon mysql INFO Reverting migration AddShareTokenToUser UsersnickservidioDevelopervaporFoobuildcheckoutsfluentSourcesFluentMigrationMigrationsswift mysql ALTER TABLE User mysql DELETE FROM fluent WHERE fluentname stringAddShareTokenToUser INFO Succesfully reverted last batch of migrations Examining the database using DataGrip shows that the shareToken column still exists swift Nodequeryon db filter Noderunning Nodeexecutors first Add autoMigrate Bool to FluentProvider to allow for migrations to run automatically on boot This is useful for things like inmemory SQLite dbs Fluent will now compile on the master branch