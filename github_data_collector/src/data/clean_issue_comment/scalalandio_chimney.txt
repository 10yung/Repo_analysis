This PR reduces object allocations in TransformerPatcher DSLs in methods that refers only to typelevel info In such cases instead of new object allocation we can use thisasInstanceOf and lift to correct type Proposed by MateuszKubuszok This PR brings flag ignoreNoneInPatch for patching requested in This PR introduces support for patches with redundant fields scala case class Fooa A b B case class Patchb B c C so far it led to compile error no accessor named c in source type Foo FoopatchUsingBar now we have an option to ignore redundant fields in patch FoousingBarignoreRedundantPatcherFieldspatch it patches only value of b B of Foo It addresses and partially This PR provides new way to define transformer instances Motivation So far it was only possible to implement Transformer A B type class by hand A common use case for such definitions was to use Chimneys DSL to derive such transformation with less boilerplate But it has few drawbacks assigning an instance immediately to implicit valdev which is common practice may lead to stack overflows at runtime or wrong forward reference errors at compile time as reported in a programmer was forced to work with additional variable which usually was not really important from the point of transformer definition like scala implicit val aToBtransformer Transformer A B aValue A aValueinto B withFieldConst withFieldRenamed other modifiers transform In such examples aValue is not really used in other way than to begin work with Chimney DSL Indeed its a little additional boilerplate Proposal This PR intoruces new way of defining implicit instances scala implicit val aToBtransformer Transformer A B Transformerdefine A B withFieldConst withFieldRenamed other modifiers buildTransformer Note that all DSL modifiers like withFieldConst withFieldComputed etc are supported in definition DSL in fact code was reorganized in such way that their actual implementation is shared between those two DSLs with using Transformerdefine we are able to specify definition scope when doing type class derivation which allows us to avoid looking up for local implicit instance and fix in more compatible way few tests were added to verify that recursive data structures are supported including mutually recursive data types as long as their instances are derived and put into implicit def this PR also addresses issue with Transformerderive A B as commented here It doesnt automatically fix problems with old style definitions so manual intervention will be required in order to fix the code but at least we will have one blessed way of defining transformers which I believe solve of use cases in elegant way object Test import ioscalalandchimneydsl case class Booi Int s String def d Double case class Fooi Int s String d Double Boo into Foo transform This compiles on version but doesnt feel like it should Should we only consider case class constructor fields for automatic field mapping Derivation fails when the target contains a mixed in trait scala import ioscalalandchimneydsl trait B val b Int case class Aa Boolean Atrue into A with B withFieldConstb transform results in Chimney cant derive transformation Hi First of all thanks for all the great work Recently I came across use case that I believe is not covered by chimney I have case class Aint Int stringOpt Option String doesntChange Boolean and then Id like to do a PUTlike update with a case class case class PatchAint Int stringOpt Option String which is a subset of A Using patchWith would result in checking if stringOpt is defined in PatchA and appling change only if its Some However Id expect a direct assignment so if stringOpt in PatchA is None stringOpt in patched version of A should be None as well Use case its very useful if youre working on some REST service and you support both PATCH partial update and PUT This PR adds chimneyvalidated module with VTransformer which can use unsafe transformations like Option unwrapping can be usefull with proto generated case classes int from string parsing etc but unlike enableUnsafeOption all errors are aggregated to chain and contains full path to failed fields In my code I use catsdataValidated but it can be rewritten by own errorchaining semigroup implementations Also now its limited by fields in single case class Id be thankful for review and feedback Its ok to patch a subset of fields on the top level but not on deeper levels scala import ioscalalandchimneydsl case class Foox Int y String case class FooPatchx Int case class Barfoo Foo z Long case class BarPatchfoo FooPatch val foo Foo val bar Barfoo val fooPatch FooPatch val barPatch BarPatchfooPatch foopatchWithfooPatch ok barpatchWithbarPatch y javalangString no accessor named y in source type FooPatch Awesome library btw Would it be possible to have a slightly different variant of TransformerIntoenableUnsafeOption which instead of throwing exceptions would return a value like catsdataValidated or something analogous like Either Our use case is that we would like to convert ScalaPB generated case classes where everything is Optional to our domain case classes where some fields are mandatory It would help us a lot if the convertor method returned just a plain value Validated Either instead of throwing and us having to catch the exceptions It would behave similar to henkan which also has validate method to return catsdataValidated 