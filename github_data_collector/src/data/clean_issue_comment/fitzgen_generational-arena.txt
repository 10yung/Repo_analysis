The following code fails but it shouldnt When the arena is built by calling Arenanew and insert everything is ok rust use stditerFromIterator use generationalarenaArena use serdeSerialize Deserialize deriveSerialize Deserialize pub struct Struct arena Arenausize pub fn main let mut vec vec let arena Arenafromitervecdrain let struc Struct arena let ser serdeyamltostring strucunwrap let struc Struct serdeyamlfromstr serunwrap link was dead imo makes more sense to point to the actual presentation at rather than which would be the updated link equivalent to the previous Im interested in using this crate in a microcontroller context its for a DSP engine which Ive found fits the whole ECS pattern extremely well It seems the extant nostd support needs alloc for the purposes of allocating a Vec Would it be possible to use a heaplessVec instead heaplessVec Hi It would be nice to have methods like shrinkto and shrinktofit implemented As I understand it is not difficult at all to implement such methods since the under lying data structure is a Vec Best regards Tage From the docs A NonZeroU is an integer that is known not to equal zero This enables some memory layout optimization For example OptionNonZeroU is the same size as u I replaced generation u with NonZeroU initializing it to rather than This example shows that Index takes bytes of memory and OptionIndex currently takes bytes but with this optimization it would take bytes like a plain Index I run the benchmarks and the results are almost the same There may be a small regression but it could also just be a random fluctation caused by the fact that incrementing a NonZeroU by requires converting it to a u and back If NonZeroU gets better support in the standard library that may be optimized further Still memory optimization is significative I myself may need to store a large amount of OptionIndex and I belive its a rather common usecase so I think it would be worth it Is there any reason to use the generationalarena over the slotmap crate AFAICT the latter existed first and is a superset featuring a compact hoprepresentation for faster iteration in the presence of large holes in the collection and secondary maps to implement ECSstyle associated data The only benefit I see is that generationalarena uses zero unsafe code However slotmaps usage of unsafe code is justified to use a more compact representation The LSB of the slotmap generation is the tag indicating the state of the slot instead of a full byte or bytes if it gets padded for the enum discriminate crate size max reuse per slot slotmap maxsizeofT generational arena or sizeofT Im pretty sure it is safe to say that a bit generation tag is overkill But if someone needs more than bits it would be trivial to tweak slotmap to use a type parameter such that its consumers can opt for bits instead However this might not be necessary as the slotmap author wants to avoid hot slots Hi Thanks a lot for putting this crate up this is quite a clever idea thanks kyren I have a question would you be interested in adding variants where Index would be smaller in size Im thinking of games where you might have an upper bound in the number of objects that would ever be in your Arena or how many generation you would get In those case its preferable to have Index with a smaller size For instance rust struct Index index u generation u I guess depending on the use case indexorgeneration could be made even smaller We would also need some additional checks to detect whether the maximum generation or sized was reached What do you think