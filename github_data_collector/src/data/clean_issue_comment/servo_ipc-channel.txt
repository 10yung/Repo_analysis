 bincodeError is a Box Any API in ipcchannel that returns a bincodeError as part of a result ie lots of APIs in ipcrs can therefore allocate when theres a failure result For APIs like tryrecv where they can be called frequently and often this can lead to performance surprises particularly in code like if let Okmsg receivertryrecv where the error case is completely discarded For the inprocess backend its actually even worse means that we first create a stdError which is a Box then box that inside a bincode error This shows up really high in some profiles that rely on tryrecv being called every frame This is one of our longestexisting and most distributed intermittent failures in Servos automated tests Currently addroute is defined as rust pub fn addroute self receiver OpaqueIpcReceiver callback RouterHandler pub type RouterHandler BoxFnMutOpaqueIpcMessage Send It is up to the user to remember and properly turn the OpaqueIpcMessage into the correct type This leads to wrong types being used as in Instead I recommend adding a typed version as rust pub fn addrouteT self receiver IpcReceiverT mut callback RouterHandlerT The user no longer has to learn about OpaqueIpcReceiver and it is compiletime checked so the type can never be used wrong Internally the implementation converts the OpaqueIpcMessage into T so it can never be misused rust msg OpaqueIpcMessage callbackmsgtoTunwrap Eventually the existing addroute could be deprecated in favor of the typed one I couldnt find a way to mutate the contents of shared memory using the existing API For example DerefMut is not implemented Is this intended or am I missing something on how to actually do the mutation I would like to send some shared memory across process then mutate it and have the other process see the mutation Ive tried to do this with unsafe code and Im actually not sure if that is working or notI can see the mutation in the process doing it however Im still testing if the other process sees it as well See When ipc channels are sent over ipc oin unix their fds are sent using sendmsg and the matching recvmsg creates a new fd This means that even programs which use a fixed number of channels can end up using an unbounded number of fds For example rust fn main let send recv ipcchannelIpcSenderboolunwrap let send recv ipcchannelboolunwrap threadspawnmove let mut senders vec while let Oksend recv recv let send sendtrue The fd is private but this transmute lets us get at it let fd stdsyncArcu unsafe stdmemtransmute send printlnfd fd Stop the ipc channel from being dropped senderspushsend for in let send sendsend clone let recv recv runs out of fds even though it only uses two ipc channels The following minimal example reproduces the error Im using the latest cratesio version of ipcchannel but I bet it works with latest commit on master as well rust use ipcchannelipc use ipcchannelrouterROUTER fn main Result stdioError let sender receiver ipcchanneli i Use this second channel to force main thread to block until child thread is done let sender receiver ipcchannel ROUTERaddroutereceivertoopaque Boxnewmove msg match msgtoi Okval printlnVal val Erre printlnError e sender send sendersend unwrap receiver recvunwrap Ok Which happily outputs Val Basically Im able to convert the i i to a i through toi I only tried it for numerical types but it seems we have observed this behavior for less trivial types Im planning to abuse this behavior but it seems a little undefinedbehaviory to me asajeffrey With the latest ipcchannel commit the following code panics when ran rust mainrs use serdeSerialize Deserialize use ipcchannelipc deriveSerialize Deserialize Debug struct IpcWrapperT s ipcIpcSenderT fn main let sender receiver ipcchanneli unwrap let wrapper IpcWrapper s sender let ser serdejsontostring wrapperunwrap let deser IpcWrapperi serdejsonfromstr serunwrap Error thread main panicked at index out of bounds the len is but the index is Cargotoml dependencies ipcchannel git serde version features derive serdejson All you need is to wrap IpcSenderT in your own type and derive SerializeDeserialize The error happens during deserialization From the backtrace The error is happening here rust fn deserializeosipcsenderde Ddeserializer D ResultOsIpcSender DError where D Deserializerde let index usize Deserializedeserializedeserializer OSIPCCHANNELSFORDESERIALIZATIONwithosipcchannelsfordeserialization FIXMEpcwalton This could panic if the data was corrupt and the index was out of bounds We should return an Err result instead Okosipcchannelsfordeserializationborrowmut index tosender Im not sure why though Preliminary IPCChannel modifications based on rust It is also a rebase of This avoids having to compile tempfile for Windows arm where it has an unsupported dependency