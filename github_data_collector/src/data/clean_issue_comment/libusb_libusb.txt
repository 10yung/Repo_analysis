The LIBUSBTRANSFERADDZEROPACKET flag does not work properly because the maximum packet size is determined incorrectly The maximum packet size should be bytes for USB and bytes for USB Without the suggested patch a maximum packet size of bytes was determined on my test machine and therefore no zero length packets were sent How can I run libusb applications under Mac OS X if there is already a kernel extension installed for the device On Catalina Because under Catalina AppleUSBFTDIkext doesnt exist anymore I have this Problem Platform does not support kernel detachment Unable to claim USB device interface Hi The Control Transfer function sync libusbcontroltransfer not returning the actual length returned by the DATA packet but instead returning the size of the assigned buffer The issue appears to be the result of the ControlTransfer returning True at which point the overlapped structure has the overlappedInternalHigh set with the correct number of data bytes The windowsforcesynccompletion function is called with the buffer size which is then used to set the overlappedInternalHigh to the buffer size overriding the actual received byte count I used Wireshark to sniff the packets to verify the actual data count returned by the Overlapped structure when returning from the ControlTransfer function is correct and not the buffer size Example My application is expecting bytes but the libusbcontroltransfer returns bytes which is the size of the buffer passed into the libusbcontroltransfer OS Windows I tried to run the libusb sample code on macOS Majave only to find that the callbacks are not fired up when hotplugging in my iPhone to my Mac Is this a known issue The initialization and registration are all fine and the program was in the while loop waiting for events Its just that the callbacks dont fire up I use libusb binary version in my windos qt project l also use Zadig to install WinUSB driver Now the problem is the first libusbopen operation can successbut the second time the libusbopen operation return LIBUSBERRORACCESS I need to claim two interface so i must open the device twicehow to solve this problem Below is my code int r int i ssizet cnt libusbgetdevicelistcontext devs if cnt qDebug failed to get device list return while dev devs i nullptr struct libusbdevicedescriptor desc r libusbgetdevicedescriptordev desc if r qDebug failed to get device descriptor fail to get device descriptor return struct libusbconfigdescriptor config r libusbgetconfigdescriptordev config qDebug interface number configbNumInterfaces qDebug vid descidVendor pid descidProduct if descidVendor MYVID descidProduct MYPID r libusbopendev CDCDATADEV if r qDebug failed to open CDCDATADEV fail to open device qDebug libusberrornamer r return r libusbopendev VIDEODEV if r qDebug failed to open VIDEODEV qDebug libusberrornamer r return else qDebug success open VIDEODEV break if COMMONDEV NULL if r libusbclaiminterfaceCOMMONDEV CDCCOMMOMINTF r libusbdetachkerneldriverCOMMONDEVCDCCOMMOMINTF ifr qDebug libusbdetachkerneldriver failed r r r libusbclaiminterfaceCOMMONDEVCDCCOMMOMINTF ifr qDebug libusbclaiminterface failed r r libusbcloseCOMMONDEV COMMONDEV NULL if CDCDATADEV NULL if r libusbclaiminterfaceCDCDATADEV CDCDATAINTF r libusbdetachkerneldriverCDCDATADEVCDCDATAINTF ifr qDebug libusbdetachkerneldriver failed r r r libusbclaiminterfaceCDCDATADEVCDCDATAINTF ifr qDebug libusbclaiminterface failed r r libusbcloseCDCDATADEV CDCDATADEV NULL if VIDEODEV NULL if r libusbsetconfigurationVIDEODEV MYCONFIG usb qDebugerror setting config s libusberrornamer libusbcloseVIDEODEV VIDEODEV NULL if r libusbclaiminterfaceVIDEODEV CDCVIDEOINTF r libusbdetachkerneldriverVIDEODEVCDCVIDEOINTF ifr qDebug libusbdetachkerneldriver failed r r r libusbclaiminterfaceVIDEODEVCDCVIDEOINTF ifr qDebug libusbclaiminterface failed r r libusbcloseVIDEODEV VIDEODEV NULL I use a simple program to test libusb with clang on macOS But LeakSanitizer report error like this ASANOPTIONSdetectleaks clangtest start timestamp threadID facility level function call message libusb debug libusbgetdevicelist libusb debug libusbexit libusb debug libusbexit destroying default context libusb debug libusbgetnexttimeout no URBs no timeout libusb debug libusbhandleeventstimeoutcompleted doing our own event handling libusb debug handleevents poll fds modified reallocating libusb debug handleevents poll fds with timeout in ms libusb debug handleevents poll returned libusb debug libusbunrefdevice destroy device libusb debug libusbunrefdevice destroy device libusb debug libusbunrefdevice destroy device libusb debug usbiremovepollfd remove fd libusb debug darwineventthreadmain darwin event thread exiting end ERROR LeakSanitizer detected memory leaks Direct leak of bytes in objects allocated from x b in wrapcalloc libclangrtasanosxdynamicdylibx h x x fff d f ce in classcreateInstance libobjcAdylibx h x ce x fff e e c in osobjectallocrealized libdispatchdylibx x c x fff e e f in dispatchsourcecreate libdispatchdylibx x f x fff e ade in dispatchkqpoll libdispatchdylibx x fade x fff e in dispatchkqdrain libdispatchdylibx x f x fff e dd in dispatcheventlooppoke libdispatchdylibx x f dd x fff e f f in dispatchqueueresumefinalizeactivation libdispatchdylibx x f x fff ae a in CFRunLoopFindMode CoreFoundationx h x a x fff adec in CFRunLoopCreate CoreFoundationx h x ec x fff adbc in CFRunLoopGet CoreFoundationx h x bc x b e in darwineventthreadmain darwinusbc x fff e in pthreadbody libsystempthreaddylibx x x fff e c in pthreadstart libsystempthreaddylibx x c x fff e bf in threadstart libsystempthreaddylibx x bf Direct leak of bytes in objects allocated from x b d in wrapmalloc libclangrtasanosxdynamicdylibx h x d x fff e c b in Blockcopy libsystemblocksdylibx x b x fff e e b in dispatchBlockcopy libdispatchdylibx x b x fff e e d in dispatchsourceseteventhandler libdispatchdylibx x d x b in wrapdispatchsourceseteventhandler libclangrtasanosxdynamicdylibx h x x fff ae d in CFRunLoopFindMode CoreFoundationx h x d x fff adec in CFRunLoopCreate CoreFoundationx h x ec x fff adbc in CFRunLoopGet CoreFoundationx h x bc x b e in darwineventthreadmain darwinusbc x fff e in pthreadbody libsystempthreaddylibx x x fff e c in pthreadstart libsystempthreaddylibx x c x fff e bf in threadstart libsystempthreaddylibx x bf Indirect leak of bytes in objects allocated from x b in wrapcalloc libclangrtasanosxdynamicdylibx h x x fff e e ad in dispatchcalloc libdispatchdylibx x ad x fff e c in dispatchunotecreate libdispatchdylibx x e c x fff e e f in dispatchsourcecreate libdispatchdylibx x f x fff e ade in dispatchkqpoll libdispatchdylibx x fade x fff e in dispatchkqdrain libdispatchdylibx x f x fff e dd in dispatcheventlooppoke libdispatchdylibx x f dd x fff e f f in dispatchqueueresumefinalizeactivation libdispatchdylibx x f x fff ae a in CFRunLoopFindMode CoreFoundationx h x a x fff adec in CFRunLoopCreate CoreFoundationx h x ec x fff adbc in CFRunLoopGet CoreFoundationx h x bc x b e in darwineventthreadmain darwinusbc x fff e in pthreadbody libsystempthreaddylibx x x fff e c in pthreadstart libsystempthreaddylibx x c x fff e bf in threadstart libsystempthreaddylibx x bf Indirect leak of bytes in objects allocated from x b d in wrapmalloc libclangrtasanosxdynamicdylibx h x d x fff e c b in Blockcopy libsystemblocksdylibx x b x fff e cb d in Blockobjectassign libsystemblocksdylibx xb d x fff e c ef in Blockcopy libsystemblocksdylibx x ef x fff e e b in dispatchBlockcopy libdispatchdylibx x b x fff e e d in dispatchsourceseteventhandler libdispatchdylibx x d x b in wrapdispatchsourceseteventhandler libclangrtasanosxdynamicdylibx h x x fff ae d in CFRunLoopFindMode CoreFoundationx h x d x fff adec in CFRunLoopCreate CoreFoundationx h x ec x fff adbc in CFRunLoopGet CoreFoundationx h x bc x b e in darwineventthreadmain darwinusbc x fff e in pthreadbody libsystempthreaddylibx x x fff e c in pthreadstart libsystempthreaddylibx x c x fff e bf in threadstart libsystempthreaddylibx x bf Indirect leak of bytes in objects allocated from x b d in wrapmalloc libclangrtasanosxdynamicdylibx h x d x fff e cbbb in Blockobjectassign libsystemblocksdylibx xbbb x fff e c ef in Blockcopy libsystemblocksdylibx x ef x fff e cb d in Blockobjectassign libsystemblocksdylibx xb d x fff e c ef in Blockcopy libsystemblocksdylibx x ef x fff e e b in dispatchBlockcopy libdispatchdylibx x b x fff e e d in dispatchsourceseteventhandler libdispatchdylibx x d x b in wrapdispatchsourceseteventhandler libclangrtasanosxdynamicdylibx h x x fff ae d in CFRunLoopFindMode CoreFoundationx h x d x fff adec in CFRunLoopCreate CoreFoundationx h x ec x fff adbc in CFRunLoopGet CoreFoundationx h x bc x b e in darwineventthreadmain darwinusbc x fff e in pthreadbody libsystempthreaddylibx x x fff e c in pthreadstart libsystempthreaddylibx x c x fff e bf in threadstart libsystempthreaddylibx x bf SUMMARY AddressSanitizer bytes leaked in allocations my code like this extern C include libusbh include cstdio include cstdlib int main printfstart n libusbdevice devs ssizet cnt libusbinitnullptr cnt libusbgetdevicelistnullptr devs if cnt return intcnt libusbfreedevicelistdevs libusbexitnullptr printfend n return The compilation parameter that I am using is fnoomitframepointer fsanitizeleak g Hello My program uses your library v Recently Ive noticed that a lot of users have problems with it Some of usb devices dont get recognized by the program on some computers When I started looking for a reason of errors Ive found out that for devices which contain symbols a backslash is replaced by a sharp It happens in sanitizepath function For example device path hidvid a pid ad edf d e b f f cf cb kbd was format as HIDVID A PID ad edf d e b f f cf cb KBD last backslash was replaced by sharp I didnt find any reason for this behaviour and made a patch for my version of library Everything works after this patch You can find it here in last commit Can you say if my patch is right And if not can you please explain the reason for this replacement I replaced libusb so from to on my Android studio But libusbgetdevicelist always reports no device is OK linuxdefaultscandevices is not called because of compiler switch I think UDEV option have to be ON when compiling Do you know how to turn it on I compile libusb so using ndkbuild command on Windows I have an issue with libusb failing to open the composite device on Windows if one of the interfaces is HID keyboard automatically claimed by the system HID driver The issue is somehow systemdependent since calling CreateFileA without generic RW on the KBD interface succeeds on most systems I have a device that has these interfaces HID Joystick HID generic HID Keyboard Bulk endpoint WinUSB driver installed hidopen in windowswinusbc tries to open file handles to each interface and if it fails in at least one in my case the interface the libusbopen returns the error Commenting the lines to results in perfectly functioning library for my device interface is claimed by the HID driver and I can claim interfaces and in my own application I am not sure whether such behavior is really necessary the error should be thrown not before the locked interface is accesssed