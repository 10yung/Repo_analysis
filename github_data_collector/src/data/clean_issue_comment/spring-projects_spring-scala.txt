This commit updates URLs to prefer the https protocol Redirects are not followed to avoid accidentally expanding intentionally shortened URLs ie if using a URL shortener Fixed URLs Fixed Success These URLs were switched to an https URL with a xx status While the status was successful your review is still recommended with occurrences migrated to https result This commit updates URLs to prefer the https protocol Redirects are not followed to avoid accidentally expanding intentionally shortened URLs ie if using a URL shortener Fixed URLs Fixed Success These URLs were switched to an https URL with a xx status While the status was successful your review is still recommended with occurrences migrated to https result with occurrences migrated to https result with occurrences migrated to https result Ignored These URLs were intentionally ignored with occurrences with occurrences with occurrences with occurrences with occurrences This commit updates URLs to prefer the https protocol Redirects are not followed to avoid accidentally expanding intentionally shortened URLs ie if using a URL shortener Fixed URLs Fixed But Review Recommended These URLs were fixed but the https status was not OK However the https status was the same as the http request or http redirected to an https URL so they were migrated Your review is recommended with occurrences migrated to https result Fixed Success These URLs were switched to an https URL with a xx status While the status was successful your review is still recommended with occurrences migrated to https result with occurrences migrated to https result Ignored These URLs were intentionally ignored with occurrences with occurrences with occurrences with occurrences Hi I have thought about creating some mechanism to simplify access to application properties inside classes extending FunctionalConfiguration Therefore I have created PropertiesResolver trait that introduces variable which can be used to access them in two ways mypropertyname or mypropertyname This does not define properties source in any way but just creates simple mechanism of accessing them Sample usage class Config extends FunctionalConfiguration with PropertiesResolver beanpropertiesConfig new PropertyPlaceholderConfigurer val dataSource beandataSource val dataSource new BasicDataSource dataSourcesetDriverClassNamedatabasedriverclass dataSourcesetUrldatabaseurl dataSourcesetUsernamedatabaseusername dataSource destroy close I have also created another trait PropertiesAware that when extended by any bean gives it access to properties the same way class SomeBean extends PropertiesAware lazy val versionString appversion lazy val revisionInt apprevisiontoInt lazy val debugModeBoolean debugtoBoolean For those more used to referencing properties by String appversion is also available and of course good old Valueappversion works too Let me know what do you think Hi Arjen I created wrapper over Spring Data MongoDB template together with some useful implicit conversions for template callbacks I created the tests to cover the most important template methods I will submit the full test coverage in the near future I use excellent EmbedMongo library for testing EmbedMongo is available in Maven central I would really appreciating peer review and possible merge of this feature I would like to include it in a bleedingedge project for a customer of mine Early adoption FTW Cheers Hi I was thinking about two stack overflow bugs Ive fixed lately And I came to conclusion that we could had easily spotted them earlier with test coverage checks From my experience Cobertura works pretty good as Scala test coverage tool Unfortunately in Gradle you cannot use Cobertura out of the box as in Maven so I created a dedicated Gradle task to generate Cubertura report Now if you want to generate test coverage report you just execute gradle cobertura After the execution of the latter command you will see brand new coverage report in HTML format located under springscalabuildreportscoberturaindexhtml Keep in mind that I added Maven Central repository to the buildgradle because the Cobertura task needs to resolve netsourceforgecoberturacobertura dependency If you add mentioned dependency to the Spring Source repository you can safely remove Maven Central from buildgradle Armed with Cobertura I could improve our test coverage with some further contributions Best regards Hi Some people complain that using typescafe Scala with typeunsafe Spring dependency injection makes no sense I personally disgaree with such statements although I think that we could add some optional typesafe checking to the project to laverage the pros of Scala I therefore created the Cake support for Spring Scala Cake support for Spring Scala allows to create typesafe cake view over the entire or part of the functional application context I would like to elaborate a little bit on some concrete example Imagine the part of the typical Spring application ie Service and Dao trait Dao class ProductionDao extends Dao case class Servicedao Dao We want to wire these two guys into Spring application context On the same time we want to take the advantage of the cake pattern in order to a get global access to the application components b verify at the compile time that we have provided all necessary dependencies For this purpose we create typical cake components but instead of specifying dependencies as T we specify them as T trait DataAccessComponent extends CakeSupport val dao Dao trait ServiceComponent extends CakeSupport this DataAccessComponent val service singletonnew Servicedao Then we wire the dependencies into the global application context object MyApp extends Cake extends ServiceComponent with DataAccessComponent val dao singletonnew ProductionDao val dao singletonmock Dao for tests We can use the CakeObject as regular Scala cake val dao MyAppdao val service MyAppservice dao servicedao Under the hood our cake hides regular Spring functional application context val context MyAppcontext context Service MyAppservice The magic here is the singleton method from the CakeSupport trait which registers the function defined as Cake dependency in the application context The nice thing in cake for Spring Scala is that you dont have to cover all your Spring dependencies with caked components object CakeObject extends Cake with FunctionalConfigurationSupport with ServiceComponent with DataAccessComponent Beans from this configuration will be available only for the Spring application context and will not be a subject of the compile time typesafe checks def configurationClass classOf ComponentScanConfiguration val dao singletonnew ProductionDao class ComponentScanConfiguration extends FunctionalConfiguration with ContextSupport componentScanorgmoredynamiccomponents Using this approach you can combine the best of both worlds typesafe cake dependencies and dynamic Spring configuration What do you think PS Scaladoc available on demand as usually Hi Spring comes with a pretty support for AOP configuration via XML DSL Since Scala provides amazing DSL capabilities it will be a true shame not to create Scala DSL for AOP as well I created simple AOP DSL enclosed within the AopSupport trait Under the hood it creates ProxyFactoryBean configured with the DefaultPointcutAdvisors class TestConfiguration extends FunctionalConfiguration with AopSupport Define some pointcuts and advices val pointcut m Method c Class mgetName toString val beforeAdvice m Method args Array AnyRef target Any printlnBefore You can wrap existing bean into AOP proxy beanmyServicenew MyService advice targetRef myService on pointcut using beforeAdvice Or create proxy over embedded POJO advice target new MyService on pointcut using beforeAdvice You can name the proxy and apply multiple advises to it as well advicebeanName myServicetargetnew MyService onpointcatusingbeforeAdvice onsomeOtherPointcutusingafterAdvice Actually many interesting things can be done in the area of Scala DSL for Spring AOP This is the minimal usable part of it Of course if you like this pull request I can create Scaladoc for it as well Best regards 