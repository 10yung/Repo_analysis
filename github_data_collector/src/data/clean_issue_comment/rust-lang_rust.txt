In todays MIR an indirect assignment like p q is similar to but not exactly the same as rust tmp q p tmp The differences are performance they only produce the same codegen for primitives this is assuming tmp isnt used elsewhere allowing codegen to treat it like an SSA value resulting in storep loadq which is also what p q codegens to for nonprimitives the amount of data being copied doubles as tmp must be in memory correctness only p q is UB AFAIK if ppsize overlaps qqsize this also likely only affects nonprimitives which have to copy data in memory but we could decide to ignore the type and always make it UB when they overlap hr For the purposes of this discussion a primitive is scalar bool char integer float or pointerreference vector SIMDenabled array of scalars Scalar pairs likely also need to be included due to how easy they are to support in any code that already handles scalars and also due to their use in wide pointersreferences hr Whats interesting about primitives though is that some kinds of Rvalues the RHS of the assignment always produce primitive values because theyre primitive operations The Rvalue variants which are always primitive today are Ref T mut T may become dependent on custom DSTs in the future AddressOf const T mut T may become dependent on custom DSTs in the future Len usize Cast other than unsizing scalar BinaryOp UnaryOp scalar or maybe also vector CheckedBinaryOp pair of integer and bool only if we consider scalar pairs to be primitive NullaryOpSizeOf usize NullaryOpBox BoxT Discriminant integer Which leaves these variants as potentially relying on memory operations to write the result Use any type one copy Repeat T N N copies Cast specifically unsizing any type implementing CoerceUnsized perfield copies Aggregate any ADT perfield copies If we want to remain conservative we could ignore types for the latter and just assume that the destination of the assignment cannot overlap any memory read in the Operands of the Rvalue We could even cement the distinction by moving the alwaysprimitive operations into a new PrimOp enum andor move the other Rvalues to their own statements eg introduce Copyp q but thats more aesthetic than anything for the time being At the very least we should probably document these differences and make sure that miri only allows overlaps in the cases we dont consider UB either abstractly or due to our choice of codegen hr Another interesting aspect of the alwaysprimitive ops is that theyre pure functions of their operands other than NullaryOpBox I suppose but that could be replaced with a call to a lang item returning a BoxMaybeUninitT instead This means that if we wanted to we could replace some of the intermediary locals with an PrimOp DAG a bit like SSA but without phi nodes or a strict instruction stream All of the necessary ordering would still happen at the statement level so this is nowhere near as complex as VSDG but we might see some benefits in scalarheavy code hr Asides aside cc RalfJung rustlangcompiler is there no miropt team Successful merges constprop Remove useless typedef Clean up err codes Make iterEmptyT Send and Sync for any T Failed merges r ghost Closes r ghost cc Aaron Add Wlznotext to default linker flags to link with lld on FreeBSD CURRENT i where rustnightly has been failing to link since with variations of note ld error relocation R PC cannot be used against symbol rustprobestack recompile with fPIC defined in wrkdirsusrportslangrustnightlyworkrustcnightlysrcbuildi unknownfreebsdstage librustlibi unknownfreebsdliblibcompilerbuiltins a fe f e arlibcompilerbuiltins a fe f e acompilerbuiltins i eqicgu rcguo referenced by std xivr ccgu std bd afd e b std xivr ccgu rcguoLTallocboxedBoxLTFGTu asu coreopsfunctionFnOnceLTAGTGTcallonceh c ed e a bfc llvm in archive wrkdirsusrportslangrustnightlyworkrustcnightlysrcbuildi unknownfreebsdstage librustlibi unknownfreebsdliblibstd bd afd e b rlib ld error relocation R PC cannot be used against symbol rustprobestack recompile with fPIC defined in wrkdirsusrportslangrustnightlyworkrustcnightlysrcbuildi unknownfreebsdstage librustlibi unknownfreebsdliblibcompilerbuiltins a fe f e arlibcompilerbuiltins a fe f e acompilerbuiltins i eqicgu rcguo referenced by std xivr ccgu std bd afd e b std xivr ccgu rcguostdioutilcopyh f f in archive wrkdirsusrportslangrustnightlyworkrustcnightlysrcbuildi unknownfreebsdstage librustlibi unknownfreebsdliblibstd bd afd e b rlib clangcpp error linker command failed with exit code use v to see invocation error aborting due to previous error error could not compile rustcmacros Full log AFAICT it stopped building after bumping compilerbuiltins to in Successful merges constprop Remove useless typedef Slimmer syntax Add more BTreeMapBTreeSet benchmarks regarding iteration Clean up err codes Make iterEmptyT Send and Sync for any T Failed merges Remove rustcerrorcodes deps except in rustcdriver r ghost Ive been working on restricting specialization in the standard library to prevent issues like This is the fallout of those changes The PartialEq and Hash implementations for RangeInclusive are changed to avoid specialization The PartialOrd specialization for slices now specializes on a limited set of concrete types Some impls of TrustedRandomAccess a trait used to improve iterZip performance have been removed Added some tests for the soundness problems Call abortiferrors so all errors actually stop rustdoc Dont panic with compiler aborted in rustdoc instead just exit to avoid the ugly panic message Use rlib as the crate type when searching for doctests matching what is used for doc generation so nostd crates dont create no global memory allocator errors Fixes Fixes r GuillaumeGomez This improves the diagonisticsfixes ICEs when generic parameters appear within some constants For example of the new errors rust use stdmemsizeof fn fooT let sizeofT now errors with type parameters cant appear within an array length expression reprusize enum EnumT V sizeofT now errors with type parameters cant appear within an enum discriminant Previously emitted confusing errors like error E the size for values of type T cannot be known at compilation time srcmainrs fn fooT help consider restricting this bound T stdmarkerSized let sizeofT doesnt have a size known at compiletime help the trait stdmarkerSized is not implemented for T Note doesnt disallow referring to Self in either enum discriminants or array length expressions as there are cases where it can currently be sucessfully used ie rust struct Foo impl Foo const A usize fn bar u SelfA SelfA I dont think that this disallows any more code that didnt either produce a compiler error before or caused an ICE cc cc doesnt actually fully fix it see PLACEHOLDER cc Remove dependencies on rustcerrorcodes in all crates except for rustcdriver This has some benefits Adding a new error code when hacking on the compiler only requires rebuilding at most rustcerrorcodes rustcdriver and the reflexive transitive closure of the crate where the new error code is being added and its reverse dependencies This improves timetoUItests TTUT Adding an error description to an error code only requires rebuilding rustcerrorcodes and rustcdriver This should substantially improve TTUT r petrochenkov cc rustlangwgdiagnostics 