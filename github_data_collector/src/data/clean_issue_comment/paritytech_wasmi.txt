Ref Hello thanks for the great project We are using it in a demo for a new rust based runtime for our product and needed to be able to do asynchronous host functions Use case being running multiple wasm modules on the same thread when someall have asynchronous io so we dont want to prevent other work from occurring I first tried to make it work with the unstable asyncawait rust api and wasnt happy with all the added workarounds that were required mostly closurestraits and we are currently using tokio for our demoso i just reworked some of the functions to return futures Currently missing good docs tests and a lot of finesse to be clear Im new to rust as a language so if this is just plain bad code i apologize ahead of time but comments gladly accepted Some of the work in the interpreter loop seems like it could be done better and I would like a few things to be more compatible with the current api RuntimeArgs are passed as vecs instead of slices so they can be owned Rc around externals doesnt work with imports builder Only other thought would be the use of the term xasync in the methods with the upcoming asyncawait these methods might be better called xfuture so they dont get confused with the new rust async api Not sure if this would be of any use to the project but would appreciate comments either way This is to allow building and running wasmi on constrained target such as microcontroller This requires the ability to build without std wasmi uses numrationalBigRational for float conversion since fe ef e faac c a ea e eccb e BigRational needs the bigint or bigintstd but the nostd version does not work at the moment from numrational releasenotes In the future it may be possible to use the bigint feature with nostd this way numrational forces std since thes is no bigint for nostd WHAT THE PR DOES Replaces Vecbased LinearMemory management with a more efficient solution using VirtualAlloc and VirtualFree EXPECTATIONS The new implementation using win APIs is expected to result in faster allocation and deallocation ops Here are some rough benchmarks on a Windows virtual machine Operations vecmemory sec VirtualAlloc sec Memory with GiB initial Resizing memory to GiB and load at boundary Multiple incremental resizes and loads up to GiB div aligncenter img width altScreenshot at PM src div TODO x All tests pass on Windows x Manual tests pass x KiB initial x memorygrow x memorysize x writing to uncommitted memory x writing to unreserved memory x writing to memory after release UNTESTED bit Windows FIXES The latest cratesio build no longer works with the core feature numtraits is required by one of the dependent crates or by wasmi itself and the std feature is not turned off causing E cant find crate for std This is how Im including it wasmi version defaultfeaturesfalse features core Long story short Itd be really great if I could step through a WASM functions instructions onebyone instead of having to execute the whole function starttofinish This doesnt seem to be currently possible if Im understanding the documentation and source code right Possible usecases Erlangstyle preemptive concurrency executing a module with a specified number of reductions after which execution forcibly pauses to allow other functions to run Debuggers eg to step through execution opbyop and validate execution state I can think of a couple ways off the top of my head Id go about implementing this Pass in an optional maximum number of instructions to be executed ie into Interpreterruninterpreterloop and Interpreterdorunfunction and in turn into any functions calling it if Somemax keep looping and decrementing until max then throw a resumable trap Define entirely new functions that implement stepping and possibly reimplement the existing functions in eg impl Interpreter to wrap these if we want to avoid code duplication Would yall be open to a PR implementing one or more of the above or perhaps some entirelydifferent strategy I realize the first option is most likely going to be a breaking change unless perhaps combined with the second option At the moment wasmis linear memory is backed by mmap on unix However on Windows it falls back to the vec implementation We could use VirtualAlloc an equivalent of mmap for our purposes to implement the backend for linear memories on Windows Hello Is there a way to identify the module that is triggering a wasmiExternalsinvokeindex call Ive run into an issue with a small PoC Im working on where I have multiple interacting modules and some host functions Some of the host functions require moving strings around or other data that is located in the modules linear memory Unfortunately I havent found a mechanism to determine which modules memory I should be accessing A small example would be modules A B where module A is calling Bfoo and Bfoo is calling envprint I figured if nothing exists currently I can provide unique ImportResolvers for each module I load that encodes the modules index and function index into the index returned by resolvefunc so I can extract it in invokeindex But this feels kind of gross Any pointers would be greatly appreciated Really enjoying the wasmi btw it has been a joy to work with so far It would be nice to have the ability to profile wasm execution I have a terrible hack in this branch didnt wanted to open a PR but I would welcome any review and comments on deciding on a design or whether such a feature is wanted would be accepted Can also open a PR if that is the best way forward