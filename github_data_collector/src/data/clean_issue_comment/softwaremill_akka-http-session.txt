Problem Currently there the API doesnt support different access and refresh tokens transports for example one should be stored in a HTTP only cookie while the other in header Motivation If separate transports were possible one could store refresh token in a HTTP only cookie and access token in headers which would later be saved by the client in localstorage This approach could yield better security if both tokens were required to generate a new access token A rouge JS script XSS attack could only steal access token and use it until its expiry CSRF wouldnt be an issue when access token was stored in localStorage and both refresh and access possibly expired but with valid signature tokens were required to generate a new access token If refresh token was to be somehow stolen via man in the middle attack without HTTPS an attacker would still need to obtain matching access token This would require embedding refresh token selector in JWT to figure out if the two match Current workarounds This can be somewhat mitigated when reading by composing requiredSessiononeOff usingHeaders requiredSessionrefreshable usingCookies however this will result in the latter directive never finding our access token and generating a new one For writing with setSession upon user login with basic credentials one could work around this by composing setSession calls and manually removing excess cookiesheaders I am using refreshable token together with headers and while using Akka Http I have implemented dologin dologout and currentlogin per supplied examples On calling dologin my client application a Vue client receives both setauthorization and setrefreshtoken which are persisted to localstorage Calling currentlogin with GET method and supplying authentication token I get expected response however if I try to refresh by using refreshtoken in header I get internal servererror When calling dologin with debugging enabled I see setting of refreshtoken and when trying to refreshtoken calling currentlogin described above I see debug message Looking up token for selector ldk bj plrdk a found true so assume refresh token is found but then I get exception UTC ERROR bdesignsakkaakkaactordefaultdispatcher ActorSystemImpl Error during processing of request javalangNullPointerException No error message supplied Completing with Internal Server Error response To change default exception handling behavior provide a custom ExceptionHandler javalangNullPointerException null I assume I am using valid process to call refreshtoken using get with refreshtoken in header calling endpoint currentlogin Application made to run in a Java and Dockerizeable Seedited READMEmd about sbt usage Type safe store human readable expiration dates official akkahttp StatusCodes Im using akkahttpsession in scastie I have two threads at cpu usage This the result of jstack Webakkaactordefaultdispatcher prio osprio tid x f fc nid x ba runnable x f bfbf javalangThreadState RUNNABLE at scalacollectionmutableHashTableremoveEntryHashTablescala at scalacollectionmutableHashTableremoveEntryHashTablescala at scalacollectionmutableHashMapremoveEntryHashMapscala at scalacollectionmutableHashMapremoveHashMapscala at comsoftwaremillsessionInMemoryRefreshTokenStorageremoveRefreshTokenStoragescala at comsoftwaremillsessionInMemoryRefreshTokenStorageremoveRefreshTokenStoragescala at comolegychscastieweboauth GithubUserSessionanon removeGithubUserSessionscala at comsoftwaremillsessionRefreshTokenManageranonfunrotateToken SessionManagerscala at comsoftwaremillsessionRefreshTokenManagerLambda applyUnknown Source at comsoftwaremillsessionInMemoryRefreshTokenStoragescheduleRefreshTokenStoragescala at comsoftwaremillsessionInMemoryRefreshTokenStoragescheduleRefreshTokenStoragescala at comolegychscastieweboauth GithubUserSessionanon scheduleGithubUserSessionscala at comsoftwaremillsessionRefreshTokenManageranonfunrotateToken SessionManagerscala at comsoftwaremillsessionRefreshTokenManageranonfunrotateToken adaptedSessionManagerscala at comsoftwaremillsessionRefreshTokenManagerLambda applyUnknown Source at scalaOptionforeachOptionscala at comsoftwaremillsessionRefreshTokenManagerrotateTokenSessionManagerscala at comsoftwaremillsessionRefreshTokenManagerrotateTokenSessionManagerscala at comsoftwaremillsessionSessionManageranon rotateTokenSessionManagerscala at comsoftwaremillsessionRefreshableSessionDirectivesanonfunsetRefreshToken SessionDirectivesscala at comsoftwaremillsessionRefreshableSessionDirectivesLambda applyUnknown Source at akkahttpscaladslserverDirectiveSingleValueModifiersanonfunflatMap Directivescala at akkahttpscaladslserverDirectiveSingleValueModifiersLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfuntflatMap Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfuntmap Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfunmapRouteResult BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverdirectivesOnSuccessMagnetanon anonfundirective FutureDirectivesscala at akkahttpscaladslserverdirectivesOnSuccessMagnetanon Lambda applyUnknown Source at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFutureflatMapextensionFastFuturescala at akkahttpscaladslserverdirectivesOnSuccessMagnetanon anonfundirective FutureDirectivesscala at akkahttpscaladslserverdirectivesOnSuccessMagnetanon Lambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFutureflatMapextensionFastFuturescala at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverDirectiveanonfunrecover Directivescala at akkahttpscaladslserverDirectiveLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFutureflatMapextensionFastFuturescala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfunmapRequestContext BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFutureflatMapextensionFastFuturescala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationanonfuntilde RouteConcatenationscala at akkahttpscaladslserverRouteConcatenationRouteWithConcatenationLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfunmapRouteResultWith BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverdirectivesBasicDirectivesanonfuntextract BasicDirectivesscala at akkahttpscaladslserverdirectivesBasicDirectivesLambda applyUnknown Source at akkahttpscaladslserverdirectivesExecutionDirectivesanonfunhandleExceptions ExecutionDirectivesscala at akkahttpscaladslserverdirectivesExecutionDirectivesLambda applyUnknown Source at akkahttpscaladslserverRouteanonfunasyncHandler Routescala at akkahttpscaladslserverRouteLambda applyUnknown Source at akkastreamimplfusingMapAsyncanon onPushOpsscala at akkastreamimplfusingGraphInterpreterprocessPushGraphInterpreterscala at akkastreamimplfusingGraphInterpreterprocessEventGraphInterpreterscala at akkastreamimplfusingGraphInterpreterexecuteGraphInterpreterscala at akkastreamimplfusingGraphInterpreterShellrunBatchActorGraphInterpreterscala at akkastreamimplfusingGraphInterpreterShellAsyncInputexecuteActorGraphInterpreterscala at akkastreamimplfusingGraphInterpreterShellprocessEventActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpreterakkastreamimplfusingActorGraphInterpreterprocessEventActorGraphInterpreterscala at akkastreamimplfusingActorGraphInterpreteranonfunreceive applyOrElseActorGraphInterpreterscala at akkaactorActoraroundReceiveActorscala at akkaactorActoraroundReceiveActorscala at akkastreamimplfusingActorGraphInterpreteraroundReceiveActorGraphInterpreterscala at akkaactorActorCellreceiveMessageActorCellscala at akkaactorActorCellinvokeActorCellscala at akkadispatchMailboxprocessMailboxMailboxscala at akkadispatchMailboxrunMailboxscala at akkadispatchMailboxexecMailboxscala at akkadispatchforkjoinForkJoinTaskdoExecForkJoinTaskjava at akkadispatchforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava at akkadispatchforkjoinForkJoinPoolrunWorkerForkJoinPooljava at akkadispatchforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava Hello Im interested in using this project but there are still some obscure undocumented aspects The first one is the schedule method in the RefreshTokenStorage Can you please clarify what is this for and how is it intended to be implemented Also the after parameter should probably be a FiniteDuration rather than simply Duration should it not Is there a plan to work on some better documentation in general Many thanks My CORS configuration works perfectly until I use requireSession I have tried many different configurations with no success in getting both CORS and Sessions working together Im guessing that requireSession overwrites headers that I set for CORS but I am uncertain of this Any suggestions Hello Looks like the invalidateSession function doesnt invalidate the session as it should Ill explain below what I mean If you want to look at steps to reproduce without technical details scroll to the end I use comsoftwaremillakkahttpsession core with Scala version I use following configs for session session serversecret YzszrU UkqsMqCNEnuLI DDWs Wqacj z dbtquSjB GbsFpBA GG yk DaIyrB encryptdata true header sendtoclientname SetAuthorization getfromclientname Authorization Here is my session serialization de case class Sessionrole String email String object Session implicit def serializer SessionSerializer Session String new MultiValueSessionSerializer Session session Map role sessionrole email sessionemail map Try Session mapgetroleget mapgetemailget And finally routes val routes pathlogin post entityas Credentials credentials onSuccessuserActor Authenticatecredentials case loggedIn LoggedIn setSessiononeOff usingHeaders SessionloggedInuserrole loggedInuseremail completeHttpResponseStatusCodesOK case noSuchEmail NoUserWithEmail completeHttpResponseStatusCodesBadRequest case InvalidPassword completeHttpResponseStatusCodesBadRequest pathme get requiredSessiononeOff usingHeaders session completesessionrole pathlogout post requiredSessiononeOff usingHeaders session invalidateSessiononeOff usingHeaders completeHttpResponseStatusCodesOK Here is what I do Call POST login and receive back in the header longencryptedtokenA Call GET me with the longencryptedtokenA header and receive back appropriate response with ADMIN value Call POST logout and receive back response here I assume that the session is invalidated Call GET me with the longencryptedtokenA header and receive back appropriate response with ADMIN value So the question Why I can still successfully can use the token after invalidation Thanks I am using touchRequiredSession with refresh tokens and custom headers I am noticing that the refreshtoken is rotated when the access token is expired and the refresh token is not It is my understanding that using touch should not result in a new refresh token only a new access token I verified that the refresh token was being rotated with an extended expiry in the data store I could be wrong but it seems like requiredSession which is called by touch always does the rotation when expired First off Thank you so much for your project time and effort On this moment Im experiencing some errors regarding the JWT header namevalue combination The error throw Illegal request header Illegal authorization header Invalid input expected authparam OWS token EOI or tchar Using the directive optionalSessiononeOff usingHeaders This directive always returns an Option T containing a None Great project thanks Works effortlessly Any interest in Shiro as an authorization provider Other ideas come to mind This being the Scala world it strikes me that someone out there has created the perfect RBAC in five lines with scalaz but alas I dont have those five lines 