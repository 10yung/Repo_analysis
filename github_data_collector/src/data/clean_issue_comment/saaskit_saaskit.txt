Hi all Is there a way to encrypt the configuration for the tenants Regards Use Case Tenant has ValuesController and UsersController registered in its own container Tenant only has UsersController in its own container If I access the ValuesController ex via apivalues route how dow I handle the DI exception so that I can return a response Hi all I have this tenant which is allowed to CRUD other tenants Currently tenantss data can be persisted in a separate database When a new tenant is created the application should create and populate a new database Id like that behaviour to be transparent to all my pertenant entities that are created using Managerlike classes which inject the tenant using DI Id like to have a way of creating a new IServiceScope and override the tenant for that scope only To achieve it I have overriden the provider for TenantContext to return a forced tenant instead of the one in the HttpContext public class CurrentTenantForcer public Tenant ForceTenant get private set public void ForceTenantForCurrentScopeTenant newTenant ForceTenant newTenant servicesAddScopedCurrentTenantForcer Override the provider for TenantContexts in order to be able to override the current tenant being provided servicesAddScopedserviceProvider var resolver serviceProviderGetRequiredServiceCurrentTenantForcer if resolverForceTenant null return new TenantContextCurrentTenantInforesolverForceTenant else return serviceProviderGetServiceIHttpContextAccessorHttpContextGetTenantContextCurrentTenantInfo Which allows me to do using var scope serviceProviderCreateScope var serviceProvider scopeServiceProvider Set the tenant before configuration var tenantForcer serviceProviderGetRequiredServiceCurrentTenantForcer the resolver is scoped so we are modifying a scoped instance tenantForcerForceTenantForCurrentScopecreationInfoTenant var tenantDbContext serviceProviderGetRequiredServiceTenantDbContext await tenantDbContextDatabaseMigrateAsync await SeedTenantDataserviceProvider creationInfo Im also using that method to seed initial databases before calling IWebHostRun for development Is there a better way of doing this If not are there any issues with the provided approach Thank you very much Leo Upgraded SaasKit to netcoreapp I am trying to specify different social accounts per tenant in net core UsePerTenant not working anymore becouse UseGoogleAuthentication obselete appUsePerTenantAppTenantctx builder builderUseGoogleAuthenticationoptions optionsAuthenticationScheme Google optionsSignInScheme Cookies optionsClientId Configuration ctxTenantIdGoogleClientId optionsClientSecret Configuration ctxTenantIdGoogleClientSecret As of MicrosoftAspNetCoreAuthenticationCookies v the method builderUseCookieAuthenticationnew CookieAuthenticationOptions from appUsePerTenantAppTenantctx builder is obsolete Any chance cookie name can be moved into ConfigureServices and keep the same pattern per tenant ITenantResolverResolveAsync is missing support for CancellationTokens TaskTenantContextTTenant ResolveAsync HttpContext context Has anyone implemented multitenancy with a console application Nothing specific just a proof of concept can I use it for net core 