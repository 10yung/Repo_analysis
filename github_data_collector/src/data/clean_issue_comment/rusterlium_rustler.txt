I ve been trying to deploy an Elixir app with a rustler based module Everything works fine in development but when I try to build the docker image on Alpine I have this error Compiling NIF crate niftygraph nativeniftygraph Updating cratesio index Updating git repository Downloading crates Downloaded unreachable v Downloaded quote v Downloaded which v Downloaded petgraph v Downloaded heck v Downloaded lazystatic v Downloaded syn v Downloaded procmacro v Downloaded indexmap v Downloaded failure v Downloaded fixedbitset v Downloaded libc v Downloaded unicodexid v Downloaded unicodesegmentation v Downloaded void v Downloaded autocfg v Downloaded backtrace v Downloaded rustcdemangle v Downloaded cfgif v Downloaded backtracesys v Downloaded cc v error cannot produce dylib for niftygraph v buildnativeniftygraph as the target x unknownlinuxmusl does not support these crate types RuntimeError Rust NIF compile error rustc exit code This seems to be a known issue of Alpine but can you guide me on possible solution on building a docker container with a rust dependency Thank you stdprocessCommand determines the path to an executable using the osspecific PATH variable As we are only interested in calling the erl executable when building but not where the executable is placed within the file system we can attempt to call it directly The dependency was introduced with I implemented Decoder on a type that crashes the VM with a SIGBUS I made a minimal reproducible example in this repo enifsend returns a flag indicating if the send succeeded or not From the documentation Returns true if the message is successfully sent Returns false if the send operation fails that is topid does not refer to an alive local process The currently executing process that is the sender is not alive Functions such as Envsend or OwnedEnvsendandclear could indicate the success with Result Add docs in particular about having to rerun the resource type registration Clarify safety of unload Add test This changes the releasesh script to create releases The release commit is tagged The rustlermix documentation points to that tag If an error occurs during verification by compile the commit is reverted This is not done when publishing is already underway The PR adds two environment variables for the script to simplify testing DRYRUN Do not publish DONTREVERT Do not revert the changes if an error happened or if DRYRUN was used As explained in its not feasible to allow for real module unloading for rustlerbased nifmodules However by automatically versioning the nifmodules we could achieve something similar In my rebar rust update branch I already place crates in versioned directories and generate a headerfile that contains the location of the binaries relative to priv on build We could now go one step further and generate a wrapper nif module that refers to exactly one version and make the rustlercodegen generate its name from the crate version and compile mode A nif crate of name mynifs with a single nif func of version would then generate a module like erlang modulemynifscrate release export func onloadinit init erlangloadnifpathtooutput funcArg erlangniferrornotloaded The actual module to expose this would then be recompiled on version change and look like this where crateshrl is regenerated on build to refer to the respective current generated module erlang modulemynifs includecrateshrl spec funcnumber ok funcMyNumber cratemynifsfuncMyNumber The userdefined mynifs module would then on reload pick up a new generated module which in turn would load the new sodll Since mynifscrate release should be generated on build we could incorporate it into rustlercodegens init implementation and even add autogenerated specs Currently the mix compiler adds additional work for users in order to get started The changes proposed in this PR aims to make this go away completely and allow users to turn off compilation completely in favor of loading a precompiled binary Pros Users no longer need to add the rustler compiler in mixexs Users no longer need to add the rustlercrates option in mixexs Crates are automatically compiled when the associated NIF module is compiled Recompilation only happens when one of Rust files or the NIF module are updated see externalresource Cons Currently when changes are made to the rust files in the project mix compile does not recompile unless the NIF module has been saved This change breaks existing binary compilation but I think this can be fixed pretty easily There might be more cons than I can think of right now TODO x Revamp the docs x Support compiling rust binaries x Support loading precompiled libsbinaries