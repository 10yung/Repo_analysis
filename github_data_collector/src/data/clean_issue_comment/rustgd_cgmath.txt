Im implementing skeletal animation and there were glitches for a very short time After some debugging it seems that a call to slerp gives different results rs use cgmathQuaternion fn main let a Quaternionf new let b Quaternionf new println aslerpb This prints Quaternion s v Vector Ive tried the same quaternions with glmatrix const a quatfromValues const b quatfromValues const r quatcreate quatslerpr a b consolelogr And this prints the scalar part is the last component here Float Array Would it be possible to add a trait to downcast VectorT to T N and T I work with buffers of vectors and I need to pass them to other libraries that are using T for compatibility For now I only copy it element by element but I think that copy could be avoided with a simple reference cast For example something like that rust impl Into T for Vector T fn intoself T unsafe stdslicefromrawpartsselfasptr as const T selflen and maybe also the inverse rust impl Into VectorT for T fn intoself VectorT asserteqselflen unsafe stdslicefromrawpartsselfasptr as const Vector T selflen I think its possible because the Vector struct is marked reprC and its fields are all of the same type so there is no alignment concerns Plus all slices are contiguous data storages This kind of cast would get it much more simple to get from a buffer type to an other slices vec ndarray with grouped components or not This is possibly more of a question Would it be of any interest to the users of cgmath to have more fine grained trait bounds on methods from stdops to eliminate the need to add BaseNum or BaseFloat trait bounds into generic code in libraries that use cgmath The motivation here is that it may perhaps be easier to swap inout cgmath in libraries without modifying the trait bounds on all generic code I know this may be a moot point at this moment but seeing as cgmath aims to be one of the simpler and more lightweight matrix libs this might make sense here Hello The current cgmath version in cratesio depends on rand but I see that the current version in the repository depends in rand since august which would be nice to have to avoid having projects depending on both rand and Its not a breaking change afaik so it would probably be a version right I found that cgmath has optional support for simd which does not compile since Rust and is deprecated in favor of packedsimd see From what I can see packedsimd is significantly different from simd so migrating may be a tremendous effort Has anyone looked into this Is it feasible at all These methods are quite useful whenever you have to make sure that a value stays inside a specified range Although there is f clamp and f clamp these are not stabilized yet so it would be nice to have them inside cgmath wraparound should have a signature like this rust fn wraparoundSx S min S max S S See also Does it make sense to add a zip function to arraylike types Doing so will make it less errorprone to do custom element wise operations rust Compute the element wise minimum If any of the elements are incomparable the element from v is returned fn vec ewminT PartialOrdv Vector T v Vector T Vector T Vector zipv v a b if a b a else b Motivation I tried to write a simple axis aligned bounding box data structure today which requires keeping track of the minx maxx miny etc I figured Id use a Point for the min and max values but couldnt find a nice way to compute the element wise minimum and maximum We could consider adding those to the ElementWise trait but since floatingpoint values arent Ord we would have to make choices that are best left for the library consumers to make Having zip would be fairly natural seeing that map is already there Implementation In its simplest form we would add rust implS Vector S fn zipU Fself v Self f F Vector U where F FnS S U Vector x fselfx v x y fselfy v y z fselfz v z It is possible to have v be a different type but I have a feeling there arent many use cases for that Additionally Id like to see a threewaymerge zipzip and fold foldreduce without initial value implemented Writing other operations like the element sum element product the dot product becomes quite easy However since these methods are generated from macros it would probably introduce unnecessary compiler work rust implS Vector S fn zipzipU Fself v Self v Self f F Vector U where F FnS S S U Vector x fselfx v x v x y fselfy v y v y z fselfz v z v z fn vec ewclampT PartialOrdv Vector T min Vector T max Vector T Vector T Vector zipzipv min max s min max if s min min else if s max max else s It is also possible to generalize these functions into traits which Ive experimented here but perhaps that is going too far If Im treating Matrix as a homogeneous matrix for D coordinates the equivalent of Matrix s fromtranslation is missing Taking the elementwise absolute value of a vector is a pretty common operation in GLSL It would be lovely to have an abselementwise Maybe also a abs added to VectorSpace for consistency with numeric types porting simple function from nalgebra rust let scale isize normal dot self fails with error E no method named dot found for type cgmathvectorVector isize in the current scope srcvelrs let scale isize normal dot self note the method dot exists but the following trait bounds were not satisfied cgmathvectorVector isize cgmathstructureInnerSpace Is there a reason why I cant take the dot product of isize vectors which is defined and mathematically sensible Or am I missing something and need to import something