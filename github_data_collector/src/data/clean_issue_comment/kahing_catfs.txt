Hello guys and thank you for this great package I tried adding pretty much exactly the same command to my etcfstab but it refuses to work with it getting this error The following required arguments were not provided mountpoint USAGE catfs from to mountpoint o option For more information try help v For small files thats fine but for large multigigabyte files its inefficient to download the entire thing on access because certain operations might only require a quick openclose of the file to read the first few megabytes for instance reading media metadata using mediainfo or ffmpeg I consistently get this panic when using catfs with a backing sshfs The accesses that were going on at the time were concurrent reads This is on fedora linux thread unnamed panicked at ino x dc refcnt deref srccatfsinoders stack backtrace x c d stdsysunixbacktracetracingimpunwindbacktraceh ebfb a at srclibstdsysunixbacktracetracinggccsrs x c b stdsyscommonbacktraceprinthc fdae fb b d d at srclibstdsyscommonbacktracers x c stdpanickingdefaulthookclosurehc d a ff at srclibstdsyscommonbacktracers at srclibstdpanickingrs x c a stdpanickingdefaulthookh c a df d at srclibstdpanickingrs x c c f stdpanickingrustpanicwithhookh c a c b f cc at srclibstdpanickingrs x c a stdpanickingcontinuepanicfmth ed bdd b at srclibstdpanickingrs x c ee stdpanickingbeginpanicfmth a fb c b at srclibstdpanickingrs x a f catfscatfsinodeInodederefha f d df at srccatfsinoders x b catfscatfsCatFSforgethe bc a db at srccatfsmodrs x b b catfspcatfsPCatFS as fuseFilesystemforgetheaa df af b at srcpcatfsmodrs x efae fuserequestRequestdispatchh a bca d at homeyidingcargoregistrysrcgithubcom ecc db ec fuse srcrequestrs x a b c fuserequestdispatchh e e d b e at homeyidingcargoregistrysrcgithubcom ecc db ec fuse srcrequestrs x fbb fusesessionSessionFSrunhb d c d at homeyidingcargoregistrysrcgithubcom ecc db ec fuse srcsessionrs x c c catfsmaininternalclosurehe d e ea ec at srcmainrs x stdsyscommonbacktracerustbeginshortbacktraceh e ab c at rustc c d dfe c eeed efad d f esrclibstdsyscommonbacktracers x b f stdthreadBuilderspawnuncheckedclosureclosurehda f acb e b at rustc c d dfe c eeed efad d f esrclibstdthreadmodrs x cd stdpanicAssertUnwindSafeF as coreopsfunctionFnOncecallonceh ddc c ecb at rustc c d dfe c eeed efad d f esrclibstdpanicrs x c stdpanickingtrydocallh ddea f at rustc c d dfe c eeed efad d f esrclibstdpanickingrs x c rustmaybecatchpanic at srclibpanicunwindlibrs x b stdpanickingtryh ebff a c f at rustc c d dfe c eeed efad d f esrclibstdpanickingrs x d stdpaniccatchunwindh fefc ce c cb d at rustc c d dfe c eeed efad d f esrclibstdpanicrs x b db stdthreadBuilderspawnuncheckedclosureh b a a at rustc c d dfe c eeed efad d f esrclibstdthreadmodrs x ab coreopsfunctionFnOncecalloncevtableshimh c bbb fcb at rustc c d dfe c eeed efad d f esrclibcoreopsfunctionrs x b a e allocboxedBoxF as coreopsfunctionFnOnceAcallonceh cac ae a at rustc c d dfe c eeed efad d f esrcliballocboxedrs x c df stdsysunixthreadThreadnewthreadstarth adc b f e at rustc c d dfe c eeed efad d f esrcliballocboxedrs at srclibstdsyscommonthreadrs at srclibstdsysunixthreadrs x fc a startthread x fc clone x unknown I am currently designing a file system agnostic automated tiered storage solution in rust which I plan to release under the same MITApache dual licence rustlang uses I could safe quite a lot of time If I was able to reuse some catfs code but to do so catfs would need to be under the same dual license Do you mind dual licensing catfs as Apache MIT I would highly appreciate it fixes most missing syscalls like fdopendir are fixed by updating libc crate thats why Cargolock is updated to latest some other syscalls are emulated like splice type errors u vs u are fixed by adding castings Scenario a remote file changes Problem While the cache content is good and upto date the view presented at the mountpoint third argument to catfs is truncated The file is there but its only partially present if I display it via cat Other times a bunch of NULL bytes appear at the end So the cache directory content is fine but through the mountpoint I get garbage catfs was actually one of the very first ones I tried I am running ubuntu and here is how I installed catfs sudo aptget install cargo git libfusedev fuse pythonfuse git clone cd catfs sudo cargo install catfs Here is how I tried it out using a sshfs mount mediaremote with catfs sshfs o reconnectnoatimeServerAliveInterval ServerAliveCountMax cachetimeout entrytimeout largereadmaxread cacheyeskernelcacheworkaroundnodelaysrvcachestattimeout admin myremotefs mediaremote cargobincatfs mediaremote mediacache mediavideo and then launched kodi media player which is configured to read from mediavideo kodi just gave me a spinning progress indicator while trying to play a file from the catfs mediavideo mount and I could see monitoring bandwidth that the file was transferring so it seemed to be trying to transfer the entire file before playback I did not have this issue with mcachefs or pcachefs Currently I am using mcachefs because of the ones I tried it performed the fastest Is there anything else I should try maybe I am just missing a small option or setting to get this party going Previously if either splice call failed the function would return without closing pin or pout One way it might fail is if the process reading from the file system closes its fd without consuming the whole file To fix this wrap the pair of fds in a new struct PipeFds with an idempotent close function and a Drop impl that calls it This allows copysplice to propagate errors encountered while closing either pipe fd after an otherwisesuccessful copy while guaranteeing that close will be called on both pipe fds If close fails on both pipe fds return the error from the in side which matches the old behaviour This addresses the fdleak part of I am attempting to use goofys catfs to mount a local readonly view of an S bucket as follows usrlocalbingoofys o allowother cache oallowothervarcachemirror dirmode filemode imagesdlendlessmcom srvimagesdlendlessmcoms Im then pointing mirrorbits at a subtree of this directory It will walk all files in that tree Its configured to never actually read the contents of any of the files I have disabled all hashing but as an implementation detail it will open every file it encounters for reading and then immediately close it The net effect is that every file in the tree is read in quick succession then closed There are files in the subtree in question It looks from the logs like like goofyscatfs to do some readahead on each file as it is opened Unfortunately midway through the scan catfs runs out of file descriptors catfsINFO ERROR read ahead release eosamd amd baseeoseos amd amd baseimgxzasc failed Too many open files os error stack backtrace catfsINFO x ee f bc backtracebacktracetraceh cb c adc catfsINFO x ee f f backtracecaptureBacktracenewh e ca bdded catfsINFO x ee catfscatfserrorRErrorEfromhc f dd f catfsINFO x ee aabf catfscatfsfileHandlecopyhb b d c f catfsINFO x ee f dc F as threadpoolFnBoxcallboxh dacdcfe af catfsINFO x ee bcb stdsyscommonbacktracerustbeginshortbacktraceh ffcb ce e c catfsINFO x ee d e panicunwindrustmaybecatchpanic catfsINFO at checkoutsrclibpanicunwindlibrs catfsINFO x ee c F as allocboxedFnBoxAcallboxhfbaa f fcf f catfsINFO x ee b allocboxedimplcallonce catfsINFO at checkoutsrcliballocboxedrs catfsINFO stdsyscommonthreadstartthread catfsINFO at checkoutsrclibstdsyscommonthreadrs catfsINFO stdsysimpthreadimplnewthreadstart catfsINFO at checkoutsrclibstdsysunixthreadrs catfsINFO x f f startthread catfsINFO x f f dace clone catfsINFO x unknown Even after the scan has finished and mirrorbits is shut down so no files should be open attempting to read most files causes this error Looking at the output of lsof catfs has over FIFO fds open they mostly come in rw pairs with the same NODE sudo lsof grep catfs grep FIFO wc l sudo lsof head n sudo lsof grep catfs grep FIFO head n COMMAND PID TID USER FD TYPE DEVICE SIZEOFF NODE NAME catfs mirror w FIFO t pipe catfs mirror r FIFO t pipe catfs mirror w FIFO t pipe catfs mirror r FIFO t pipe catfs mirror w FIFO t pipe catfs mirror r FIFO t pipe catfs mirror w FIFO t pipe catfs mirror r FIFO t pipe catfs mirror w FIFO t pipe catfs mirror r FIFO t pipe Reading certain files returns EMFILE reading others returns content of the correct length but with the contents of the wrong file For example mountpointrelease eosamd amd baseeoseos amd amd baseisoasc is bytes long correct but those bytes are the first bytes of an adjacent file mountpointrelease eosamd amd baseeoseos amd amd baseiso Any suggestions for how to begin debugging this Im afraid I have never written a line of Go or Rust in my life catfs version catfs sha sum which catfs bea aaa e f fa bab f b e ae c usrlocalbincatfs despite what catfs version says its actually 