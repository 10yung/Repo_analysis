 Issue Description Group middleware use is dependent on order of function calls with respect to registering routes but this is not documented anywhere As mentioned in this is expected behavior This should be documented somewhere but I see nothing mentioning this in the docs about groups routing or middleware Checklist x Dependencies installed x No typos x Searched existing issues and docs Expected behaviour Middleware should be executed on all routes registered for the group regardless of when in the code groupUse is called Actual behaviour Middleware for a group is only executed on routes that are registered after groupUse is called Steps to reproduce Run the program in the section below curl localhost group See that middleware is not executed curl localhost group See that middleware is executed Working code to debug go package main import fmt githubcomlabstackecho func main e echoNew g eGroupgroup gGET funcechoContext error fmtPrintf n return nil gUseloggerMiddleware gGET funcechoContext error fmtPrintf n return nil eLoggerFataleStart func loggerMiddlewarenext echoHandlerFunc echoHandlerFunc return funcc echoContext error fmtPrintfMiddleware executed n return nextc Versioncommit v Issue Description Seems like there is an issue using http without tls for some reason providing JSON data in a PUT or POST will result in the client hanging We can use the curl http priorknowledge but not curl http meaning the http update is having issues We are building microservices and want to be able to switch tls onoff for troubleshooting reasons thus we want to support cleartext http Checklist X Dependencies installed X No typos X Searched existing issues and docs Expected behaviour curl H ContentType applicationjson http XPUT d v http localhost Trying TCPNODELAY set Connected to localhost port PUT HTTP Host localhost UserAgent curl Accept Connection Upgrade HTTP Settings Upgrade h c HTTP Settings AAMAAABkAARAAAAAAAIAAAAA ContentType applicationjson ContentLength HTTP Switching Protocols Connection Upgrade Upgrade h c Received Using HTTP server supports multiuse Connection state changed HTTP confirmed Copying HTTP data in stream buffer to connection buffer after upgrade len Connection state changed MAXCONCURRENTSTREAMS updated HTTP contentlength date Thu Jan GMT Connection to host localhost left intact Actual behaviour curl H ContentType applicationjson http XPUT d v http localhost Trying TCPNODELAY set Connected to localhost port PUT HTTP Host localhost UserAgent curl Accept Connection Upgrade HTTP Settings Upgrade h c HTTP Settings AAMAAABkAARAAAAAAAIAAAAA ContentType applicationjson ContentLength upload completely sent off out of bytes HTTP Switching Protocols Connection Upgrade Upgrade h c Received Using HTTP server supports multiuse Connection state changed HTTP confirmed Copying HTTP data in stream buffer to connection buffer after upgrade len Steps to reproduce Run the application and curl against it Note that providing d works but not d Working code to debug go package main import githubcomlabstackechov golangorgxnethttp golangorgxnethttp h c nethttp log func main mux echoNew muxPOST postFunc muxPUT postFunc muxGET show h s http Server h s httpServer Addr Handler h cNewHandlermux h s logFatalh sListenAndServe eGETusersid getUser func postFuncc echoContext error User ID from path usersid return cNoContenthttpStatusOK func showc echoContext error Get team and member from the query string return cNoContenthttpStatusOK Issue Description When using ctxResponseAfterfunc with ctxFile the After handller is called multiple times with only one request made by the client Checklist x Dependencies installed x No typos x Searched existing issues and docs Expected behaviour To callback the After function one time per request no matter the response Actual behaviour The After callback is called multiple times Steps to reproduce Create a route handler function Create a After callback Respond with a file See the callback being called multiple times Working code to debug go func testctx echoContext error ctxResponseAfterfunc fmtPrintlntest return ctxFiletestfilejpg Versioncommit echo v Had the same issue as in Tested the proposed fix by fvln and it worked perfectly but in the PR the code was not the proposed one All credits should go to fvln Fixes vishr Please take a look at this when you have time This is a followup from and could cause problems Thanks Issue Description The latest release v introduces a bug relat ed to where parameterized routes sometimes return for certain routes Checklist x Dependencies installed x No typos x Searched existing issues and docs Expected behaviour In the code shared below if we access the route userssharewithmeprofile or userssharewithmeuploadself its expected that the route would resolve correctly and not return and the following code would return sharewithme sharewithme and self respectively go for route userssharewithmeprofile username cParamusername should return sharewithme for route userssharewithmeuploadself username cParamusername type cParamtype Actual behaviour The routes mentioned above fail to resolve and instead return a Steps to reproduce Run the code shared with the latest release and try the URLs mentioned above Working code to debug go package main import fmt githubcomlabstackechov githubcomlabstackechov middleware log nethttphttputil strings func main e echoNew RegisterAPIRoutese eLoggerFataleStart func RegisterAPIRoutese echoEcho eUsemiddlewareCORSWithConfigmiddlewareCORSConfig AllowOrigins string AllowMethods stringechoGET echoPUT echoPOST echoDELETE AllowHeaders stringechoHeaderContentType echoHeaderAuthorization ExposeHeaders stringechoHeaderAuthorization ePOSTuserssignup myFunc ePOSTuserssignupbulk myFunc ePOSTuserssignupengcom myFunc ePOSTuserssurveysignup myFunc eGETusersusername myFunc eGETusersusernamelikesprojectsids myFunc eGETusersusernameprofile myFunc eGETusersusernameuploadstype myFunc eGETinterestsnameusers myFunc eGETskillsnameusers myFunc func myFuncc echoContext error var builder stringsBuilder logPrintlncRequest reqDump httputilDumpRequestcRequest true builderWritereqDump for name range cParamNames builderWriteStringfmtSprintfParameter s Value s n name cParamname return cString builderString Versioncommit v Current implementation allow attacker to deceive wrong ip address to user due to careless handling of headers ref This PR fix the problem Todo write testsdocs Issue Description While trying to write a custom HTTP error handler I discovered a relatively new and seemingly incorrect semantic in the DefaultHTTPErrorHandler I am still using echo v and the old semantic seems to be sensible while the new one does not In the old semantic I am on v the code does this if he ok errHTTPError ok code heCode msg heMessage if heInternal nil err fmtErrorfv v err heInternal else if eDebug msg errError else msg httpStatusTextcode if ok msgstring ok msg Mapmessage msg That is to say if the error is an HTTPError then we use its Code and Message If the error is some other type of error then in debug mode we use errError This seems reasonable Its useful to rember that HTTPErrorMessage is of type interface And so it is reasonable to pass it anything that could be marshalled to JSON In the new code I am testing with v introduced by commit the logic is different he ok errHTTPError if ok if heInternal nil if herr ok heInternalHTTPError ok he herr else he HTTPError Code httpStatusInternalServerError Message httpStatusTexthttpStatusInternalServerError Issue code heCode message heMessage if eDebug unconditional overwrite of message message errError else if m ok messagestring ok message Mapmessage m This means that toggling on Debug ALWAYS overwrites message which may be a map full of an arbitrary set of things This seems to run counter to what a developer would reasonably expect Checklist X Dependencies installed X No typos X Searched existing issues and docs Expected behaviour eDebug should not modify the semantics of error messages which have a developersupplied payload Actual behaviour eDebug now wipes out customized error Message payload Steps to reproduce Run server below Hit endpoint with eg curl Working code to debug go package main import githubcomlabstackechov func main Echo instance e echoNew eDebug true Routes eGET hello Start server eLoggerFataleStart Handler func helloc echoContext error myError makemap string string myError error Bad thing happened myError reason no one knows why return echoNewHTTPError myError In the above code if eDebug is set to False then curl against this endpoint produces errorBad thing happenedreasonno one knows why Which seems to be the expected result But when debugTrue it produces code messagemap errorBad thing happened reasonno one knows why internal u cnil u e Which seems like an unexpected result the presence of Debug is changing the error semantics of API This means that the Debug server cant be used with clients which expect to interpret specific fields from API errors Versioncommit Issue Description The commit to allow setting the logger on the context is a breaking change for anyone implementing the context interface Not a huge issue to deal with in my case but something to think about when exposing public interfaces any change to them becomes a breaking change for others implementing them Checklist x Dependencies installed x No typos x Searched existing issues and docs Expected behavior interfaces to not change without a major version bump Actual behavior interface changed in a patch version bump Im trying to compile the code samples for example this one But it seems the documentation only refers to v How can I compile the sample and use v Thanks in advance