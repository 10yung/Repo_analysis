 When a rule transforms the value stack rather than simply pushing values onto it then these transformations are not always rolled back as one would expect when an optional or repetition rules fails further up in the rule structure The tests added with the referenced commit below demonstrate the problem Due to the mutable nature of the value stack which is mutable in order to avoid an allocation with every push fixing this problem is not entirely trivial Switching to an immutable stack implementation would provide an easy immediate solution but come with a quite severe performance penalty One way could be to switch to a hybrid mutableimmutable value stack implementation which mutates in place for the large majority of cases and only allocates when optional zeroOrMore or oneOrMore is applied to rules that actually consume values ie whose I type parameter is not HNil Another solution would be to completely disallow reduction rules for optional zeroOrMore or oneOrMore combinators which would be an unfortunate restriction since they can be quite handy in many cases I would like to suggest the implementation of the parsing elements of this project to include serializable characteristics from scratch this would enable the parsers defined with parboiled to used in distributed environments like Apache Storm There is a bug in the application of the TailSwitch logic which causes certain parsers to compile when they shouldnt scala class Par extends Parser def A Rule Any def B PopRule Int HNil def C rule A B The problem appears only when the nd rule consumes all of the st rules output This parser for example correctly doesnt compile scala class Par extends Parser def A Rule String Any def B PopRule Int HNil def C Rule String rule A B I think the reason for this issue is that we currently use two TailSwitch type logic application for computing the output of the operator whereby no distinction is made between the application for a contravariant type parameter the first and the application for a covariant type parameter the second parboiled type system should catch errors in a grammar as follows scala class SomeParser extends Parser def test rule pushx a b def a rule stra i Int pusha def b rule strb i String pushb Currently it fails in runtime scala scala new orgparboiled examplesSomeParseratestrun res scalautilTry String FailurejavalangClassCastException javalangString cannot be cast to javalangInteger scala new orgparboiled examplesSomeParserbtestrun res scalautilTry String Successb Mail list discussion parboiled s dependency on shapeless means that any application that uses parboiled directly or transitively must pin to that fastmoving dependency This declares a minimal orgparboiled supportHList extracted from shapeless to replace the shapeless dependency shapeless remains in test scope only for illTyped which could be replaced with some more effort More operations could be added to this HList if desired but HList is mostly an implementation detail and and reverse are sufficient to compile all the tests cc There are cases when error collecting is not necessary A user justd like to know if parsing was successful or not In meantime error collecting is time consuming I suggest a patch as follows diff diff git aparboiledcoresrcmainscalaorgparboiled Parserscala bparboiledcoresrcmainscalaorgparboiled Parserscala index b d a d b aparboiledcoresrcmainscalaorgparboiled Parserscala bparboiledcoresrcmainscalaorgparboiled Parserscala import shapeless import orgparboiled support abstract class ParserinitialValueStackSize Int maxValueStackSize Int extends RuleDSL maxValueStackSize Int collectErrors Boolean true extends RuleDSL import Parser requiremaxValueStackSize maxValueStackSize is not supported due to current snapshot design abstract class ParserinitialValueStackSize Int if phase initialRun schemesuccessvalueStacktoHList L else val principalErrorIndex phase establishPrincipalErrorIndex val p phase establishReportedErrorIndexprincipalErrorIndex val reportQuiet phase determineReportQuietprincipalErrorIndex val parseError phase collectRuleTracesp reportedErrorIndex principalErrorIndex reportQuiet schemeparseErrorparseError if collectErrors val principalErrorIndex phase establishPrincipalErrorIndex val p phase establishReportedErrorIndexprincipalErrorIndex val reportQuiet phase determineReportQuietprincipalErrorIndex val parseError phase collectRuleTracesp reportedErrorIndex principalErrorIndex reportQuiet schemeparseErrorparseError else schemefailurenew ExceptionParser is not collecting errors Set collectErrors to true to collect errors catch case e ParserFail object ParserMacros reify ctxExpr RuleX ruleTreespliceasInstanceOf Rule I O No newline at end of file Could you add it to code base Compile fails with message Errorscalac unexpected UnApply collectionthisSequnapplySeq String unapplyselector unapply single scala import orgparboiled Rule CharPredicate ParserInput Parser class SeqMatchval input ParserInput extends Parser def id Rule String rule captureCharPredicatePrintable def root rule id ids Seq String ids match case Seqsingle MATCH case MISMATCH Validation of the following triple with Chel na a Parboiled based Scala Parser for the W C RDF Turtle Language abc results in the following error message which also lists capture as expected rule token Validate TurtleTeststurtlesyntaxbadnum ttl File TurtleTeststurtlesyntaxbadnum ttl Invalid input abc expected capture statement or EOI line column abc rules mismatched at error location object literal numericLiteral DOUBLE atomic capture DigitCharPredicate po objectList object literal numericLiteral DOUBLE atomic capture EXPONENT e tList object literal numericLiteral DECIMAL atomic capture DigitCharPredicate turtleDoc statement directive sparqlPrefix cut atomic prefix p turtleDoc statement directive sparqlBase cut atomic base b turtleDoc statement triples subject iri IRIREF atomic ect iri prefixedName PNAMELN PNAMENS PNPREFIX atomic capture PNCHARSCharPredicate iri prefixedName PNAMELN PNAMENS PNPREFIX atomic capture DOTCharPredicate iri prefixedName PNAMELN PNAMENS PNPREFIX atomic capture isHighSurrogateCharPredicate turtleDoc statement triples subject iri prefixedName PNAMELN PNAMENS es subject iri prefixedName PNAMENS PNPREFIX atomic capture PNCHARSCharPredicate subject iri prefixedName PNAMENS PNPREFIX atomic capture DOTCharPredicate subject iri prefixedName PNAMENS PNPREFIX atomic capture isHighSurrogateCharPredicate turtleDoc statement triples subject iri prefixedName PNAMENS turtleDoc statement triples subject blankNode BLANKNODELABEL atomic turtleDoc EOI The error message is emitted by case Failuree ParseError SystemerrprintlnFile filehead parserformatErrore new ErrorFormattershowTraces true 