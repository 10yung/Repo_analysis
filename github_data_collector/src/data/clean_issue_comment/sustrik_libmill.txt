Encountered the following FTBFS on Debian unstable x In file included from ipc ipc In function millipremote dnsdnsh error lvalue required as unary operand define dnsopts dnsquietinitstruct dnsoptionsDNSOPTSINITVAARGS ipc note in expansion of macro dnsopts milldnshints NULL dnsopts rc I get the following error when running the first code example c define MILLUSEPREFIX include stdioh include libmillh millcoroutine void workerint count char text int i fori i count i printfs n text millmsleepmillnow int main millgoworker a millgoworker b millgoworker c millmsleepmillnow return compiling with clang Wall o main mainc lmill testsip hangs with cpu load in libmillgit dd ae at make check ip addr show lo LOOPBACKUPLOWERUP mtu qdisc noqueue state UNKNOWN group default qlen linkloopback brd inet scope host lo validlft forever preferredlft forever en BROADCASTMULTICAST mtu qdisc noop state DOWN group default qlen linkether xxxxxxxxxxxx brd ffffffffffff wl BROADCASTMULTICASTUPLOWERUP mtu qdisc htb state UP group default qlen linkether xxxxxxxxxxxx brd ffffffffffff inet brd scope global noprefixroute wlp s validlft forever preferredlft forever sysctl a r netipv confdisableipv netipv confalldisableipv netipv confdefaultdisableipv netipv confendisableipv netipv conflodisableipv netipv confwldisableipv tcbash stop did not help stop traffic shaping diff wl BROADCASTMULTICASTUPLOWERUP mtu qdisc htb state UP group default qlen wl BROADCASTMULTICASTUPLOWERUP mtu qdisc mq state UP group default qlen me clueless but at least the tests should be wrapped in timeout k sec sec cmd Missing documentation for multiple data protection between coroutines Im writing a simple TCP proxy Its a pleasure to do that with libmill But there is a corner case The design of proxy is rather straightforward For every proxied connection I run something like this cd connectiontoclient rs connectiontoserver godoproxyhalfduplexcd rs ch godoproxyhalfduplexrs cd ch Where the doproxyhalfduplex is coroutine void doproxyhalfduplexint a int b chan ch int err while char buf BUFSIZE int more sizet nbytes tcprecvpkta buf sizeofbuf more if errno err errno goto out sizet p while p nbytes sizet r tcpsendpktb buf p nbytes p more if errno err errno goto out p r out if err ECONNRESET shutdowna SHUTRDWR shutdownb SHUTRDWR else shutdowna SHUTRD shutdownb SHUTWR chsch int err It really cant be much simpler One coroutine reads from the client and writes to the server Another reads from the server and writes to the client Tadam But there is an issue Imagine a case that server does not do read and client does fill the buffers with write In such case we have first coroutine is stuck on writetotheserver second coroutine is stuck on readfromtheserver The problem Client connection my ECONNRESET and go away and we wont notice Solution I think the right solution is to start another coroutine that would wait on fdwaitFDWERR and force shutdown on both connections in case any ECONNRESETS Sadly libmill doesnt allow me to run coroutine and hang on fdwaitFDWERR only in current implementation If I read this code right int rc connects struct sockaddr addr milliplenaddr ifrc millassertrc iferrno EINPROGRESS return NULL rc fdwaits FDWOUT deadline ifrc errno ETIMEDOUT return NULL On fdwait timeout the s never gets closed Hello Do you know about Conan Conan is modern dependency manager for C And will be great if your library will be available via package manager for other developers Here you can find example how you can create package for the library If you have any questions just ask Hi we write a go example in libmill and seem to consume lot of memory hi i try to create simple actor model with libmill i found a way but im not sure is it right way to do im currently passing response channel as parameter to request listener Is there something wrong with idea i check memory is not groving and no message corruption in response thanks for advice c typesh typedef struct char name chan respch reqtype typedef struct int type union char strval int intval data resptype c mainc include errnoh include stdioh include stdlibh include stringh include unistdh include libmill libmillh include typesh coroutine void doitchan ch while reqtype req chrch reqtype resptype resp resptype respdatastrval malloc char strval strval strcatstrval Hello strcatstrval reqname respdatastrval strval chsreqrespch resptype resp chdonereqrespresptypeNULL resptype sendreqchan chreqreqtype req chan chresp chmakeresptype reqrespch chresp chschreq reqtype req resptype resp chrchresp resptype chclosechresp reqrespch NULL return resp int mainint argc char argv int port if argc port atoiargv chan chreqlisten chmakereqtype godoitchreqlisten for int i i i char name sprintfname d i reqtype req reqname name resptype resp sendreq chreqlisten req printfResponse For s d s n reqname resptype respdatastrval getcstdin When invoke udpsend method the error occurs error code is means invalid argument