This setup follows the spec more is a lot simpler to follow fixes and fixes Closes I manually tested this using nvm Im not sure its worth testing on CI but if we wanted to I think something like this not tested could work yaml nodejs stable ENV TESTSUITEdownlevel script nvm use yarn testapi Basic info Nodejs version jsdom version Seen on Windows Minimal reproduction case js var JSDOM requirejsdomJSDOM JSDOMfromFileloophtml resources usable runScripts dangerously thenfunctiondom setTimeoutfunction domwindowclose html DOCTYPE html html langen head titleJSDOM testtitle head body script setIntervalfunction consolelog script body html This script runs forever Fix for When setting the value of a textarea or input typetext the selection should be set to the end of the new text Also fixed an issue in textarea the selection startend should initially be set to Currently each nbspNodejs nbspversion needs nbspto nbsphave its nbspown nbspneeds node nbspreason added nbspto nbsprun wptsjs This nbspis nbspproblematic as nbspthe nbspcode currently nbspperforms the nbspNumberprocessversionsnodesplit nbspconversion for nbspevery nbspsupported nbspneeds node nbspentry and nbspeach nbspneeds node nbspentry has nbspto nbspbe nbspmanually nbspadded This nbspsimplifies nbspthat to nbsponly nbspneed to nbspperform that nbspconversion nbsponce I ve nbspalso nbspadded a nbspfail nbspreason to nbspcode expected nbspfail code when nbspthe nbspreason is nbspneeds node or nbspfail with canvas Basic info Nodejs version v actually all v versions jsdom version v Minimal reproduction case js const JSDOM requirejsdom const options runScripts dangerously const dom new JSDOM options Then youll see the error since Nodejs doesnt support globalThis but jsglobalsjson includes globalThis and runInContextglobalThis windowInstance is executed in ReferenceError globalThis is not defined at evalmachineanonymous at ScriptrunInContext vmjs at ObjectrunInContext vmjs at setupWindow UsersclarkprojectsnuxtjsnodemodulesjsdomlibjsdombrowserWindowjs at new Window UsersclarkprojectsnuxtjsnodemodulesjsdomlibjsdombrowserWindowjs at new JSDOM Usersclarkprojectsnuxtjsnodemodulesjsdomlibapijs at repl at ScriptrunInThisContext vmjs at REPLServerdefaultEval repljs at bound domainjs Please create a minimal repro Any reports involving third party libraries will be closed as we cannot debug thirdparty library interactions for you Please do not use syntax that is not supported in Nodejs such as JSX or import statements If we cannot run the code in Nodejs we will close the issue as we cannot debug whatever toolchain you are using This PR aims to address the longstanding issues with noscript nodes By setting the scriptingEnabled flag to false we can now query nodes inside noscript I didnt find any places in the code where this feature could have been implemented so I did it I tried at least Hope everything is in the right place and nothing is missing Thx for this awesome library We are currently using both request and requestpromisenative We should replace them both with something better request is in maintenance mode request is already quite bloated requestpromisenative uses stealthyrequire which essentially results in two copies of request see Some alternatives are in Strongest candidate right now is probably nodefetch Originally posted by domenic in That said requiring request twice does suck so I guess we should proceed But can we try to do whatever the right thing is instead of a temporary workaround Its not clear to me what that is should we have independent agents per jsdom window Per XHR instance Currently jsdom uses the global request agent pool for all the requests it issues As discussed in the current request implementation has some bug related to Connection keepalive header when using the global agent pool In order to get around this issue jsdom issued requests should use its own agent pool IMO requests issued by a jsdom instance should share the same agent pool Thoughts This PR aims to address the longstanding issues with reflection Currently we support reflecting content attributes in IDL attributes using the Chromestyle Reflect extended attribute in webidl js However this proved to be inflexible as supporting additional reflection varieties requires putting more jsdomspecific details in webidl js This has resulted in better reflection support being stalled over the past few years This PR introduces a different way to implement reflection Rather than putting annotations in the IDL definition the reflection is implemented using decorator functions for implementation classes much like how event listener IDL attributes are implemented currently For example the reflected IDL attributes of HTMLInputElement are done as js parameters implementation class prototype IDL attribute content attribute default value reflectLimitedToNonNegativeGreaterThanZeroWithFallbackHTMLTextAreaElementImplprototype cols cols reflectLimitedToNonNegativeGreaterThanZeroWithFallbackHTMLTextAreaElementImplprototype rows rows reflectLimitedToNonNegativeHTMLTextAreaElementImplprototype maxLength maxlength reflectLimitedToNonNegativeHTMLTextAreaElementImplprototype minLength minlength Right now I only introduced these very specific reflectors though we could certainly extend it to the cases currently covered by Reflect in the future Even though brevity is on the side of Reflect I see several advantages for implementing reflections in the implementation file Allow reflection to be more closely integrated with the rest of jsdom More metadata about the reflected attribute can be specified in JavaScript than in Web IDL Eg range of clamped attributes allowed values for enumerated attributes Implementation classes can make use of the reflected attributes instead of having to use the clunkier attribute manipulator Smoother path to the automated updating of IDL files if done in the future Better layering between jsdom and webidl js On the other hand a downside for moving reflection to the implementation file is that the implementation class is not aware of the type of the IDL attribute This makes reflection of some IDL attributes that use default behaviors that are currently serviced by Reflect more verbose than before Chrome uses a hybrid behavior using Reflect for some attributes but C for more complex behavior Admittedly the function names are a bit long at the moment as Im pretty much using the spec terminology verbatim Im open to suggestions on better names Another idea is we could introduce a utility function like addReflectedAttributes which we can use as follows js addReflectedAttributesHTMLTextAreaElementImplprototype cols attribute cols kind unsignedpositivewithfallback defaultValue maxLength attribute maxlength kind signednonnegative type attribute type kind enumeratedknownvalues validValues acceptedTypesSet missingValueDefault text invalidValueDefault text where kind is for strings string url enumeratednullable enumeratedknownvalues for boolean boolean for numbers signed signednonnegative unsigned unsignedpositive unsignedpositivewithfallback unsignedclamped float and floatpositive This PR is rebased on top of and also uses one commit from Opening it as a draft for discussion and the Travis CI run