Hi Ive found myself copying StreamReadAsync overloads around lately and Ive tried to look around for some reasoning why its not available but couldnt find anything even mentioning this topic so would it be possible to get this piece of code from SystemIOPipelines built into the SystemMemory package or some new optional netstandard compatibility package Thanks Unify more of CoreLib interop files Replace manual interop with regular managed APIs where possible Delete unused code Contributes to Please read PR and issue first thanks It seems like the test is failing on platforms WindowsNT netfx x Release and WindowsNT x I imagine the reasoning behind the netfx failure is because it must still have the old code but can anyone tell me what the other one is its error messages dont make sense to me Also what should I do to fix the netfx platform Originally posted by hamarb in This adds the Mono runtime sources including the full history and some initial build system integration Were planning to wire up the CI on Monday and then well enable Mono by default as part of the build cc dotnetruntimeinfrastructure jkotas danmosemsft jaredpar Make MicrosoftVisualBasicCompilerServicesUtilsGetResourceString public See Required to build embedded My template code In AesGcmcs the properties NonceByteSizes and TagByteSizes represents the size in Byte But the used type KeySizes represent valid key sizes in Bit xml summarySpecifies the maximum key size in bitssummary valueThe maximum key size in bitsvalue see In the namespace SystemSecurityCryptography properties like Size vary between amount of bit and bytes In this case the documentation is not consistent with the name of the property ByteSizes to Specifies the maximum key size in bits I hope this description meets your quality standards for new issues The last of the CoreFX renames Anything remaining are generally Issue urls for the old repo Is there a simple way to remove these links if the issue is closed already danmosemsft jkotas On Windows if we enumerating file system we should take into account reparse points and reparse point tags too that is symbolic links OneDrive and AppX For example attempting to read OneDrive reparse point causes an unwanted file download from the Internet AppX reparse point would be considered like symbolic link It seems the last does not taken into account in DirectoryDelete FileSystemEntry exposes FileAttributes there we can check reparse point flag But we dont have reparse point tags FileSystem also exposes only FileAttributes without reparse point tags The request comes from PowerShell Core repo I am trying to utilize new FileSystemEnumerable and have to use extra PInvoke to get reparse point tags It will be great to have reparse point tags in FileSystemEntry and FileSystem types or another way to work with the scenarios in a Core standard way cc JeremyKuhne Same type can be loaded by multiple threads in parallel in rare situations Fixes It will be great to add method for setting custom entry resolver when loading native libraries using DllImportAttribute Example csharp NativeLibrarySetDllImportEntryResolverAssemblyGetExecutingAssembly libraryHandle entryPoint if NativeLibraryTryGetExportlibraryHandle entryPoint out IntPtr handle return handle if NativeLibraryTryGetExportlibraryHandle GetProcAddress out IntPtr getProcAddressHandle var getProcAddress MarshalGetDelegateForFunctionPointerGetProcAddressDelegategetProcAddressHandle return getProcAddressInvokeentryPoint return IntPtrZero 