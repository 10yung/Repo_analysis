This is a specific problem Problem isstringpermutabletopalindrome Problem in the book Please classify issues Buggy test or buggy code eg tests for permutation problem have nonpermutation inputs This is a strange issue The test tsv file in the master branch does not seem to match what I can see in the web browser As if the repo is some how corrupt Ive never seen something like this before This test sample is incorrect as it is an odd length of valid characters with character having an odd count acpaa mnn aa alpaaanl man false TODO bryanlozxsjfislx EPIJudge git branch dev master bryanlozxsjfislx EPIJudge head testdataisstringpermutabletopalindrometsv string bool itnrsg false TODO a planaamnnaaa mcpaala n true TODO ibaal b awr lsewesei ea true TODO ya a rrya true TODO c raacrea false TODO true TODO srr sro a ewaieo ssew ie true TODO acpaa mnn aa alpaaanl man false TODO erao tonateff evoorn ev true TODO By better solution we mean something that is more idiomatic faster from a complexity perspective or in practical settings or easier to understand If you have a complete solution that is better solution please consider using a pull request If possible please provide the solution for C Java and Python If the problem is with installation or execution please give system information ie OS and language and build environment including versions Please describe the behavior you see including screenshots you can use Google Drive GitHub or Imgur to upload images and link to them as well as the expected behavior For bugs if possible please provide a reproducible test case that is the bare minimum necessary to generate the problem Because of our build process we cannot directly accept PRs by merging into the master branch Instead please send PRs against the dev branch The reason for this is that we have a single source of truth which is the complete solution that we annotate with markers that are used to generate the solution that goes inline in the book as well as the skeleton for the judge Here is a snippet of a source program note the markers Using maps getOrDefault significantly reduces conditional checks required I have also modified the solution a bit to only require a single pass Further since were adding the results in a single pass we dont care about swappingchanging indexes before the current index which also halves hash table modifications required This is my first pull request so I apologize in advance if I made a mistake You are given two sorted arrays and a positive integer k Design an algorithm for computing the kth smallest element in an array consisting of the elements of the initial two arrays arranged in sorted order Array elements may be duplicated within and across the input arrays The problem statement doesnt specify if it should be kth smallest distinct element or kth element in combined sorted order of two arrays For me the last statement makes it lean more towards kth smallest distinct element by mentioning presence of duplicates across two arrays Updated code to use a list of characters instead of a string to represent an added word for Problem in order to avoid the extra time complexity associated with string concatentations python epijudgepythonsolutionsleftrightjustifytextpy Test PASSED us Average running time us The time complexity for the problem Justify Text is stated to be On where n is the sum of lengths of the string in A But if we take a look at Line We are performing string concatenation by concatenating a space to the string currline i maxlencurrline which will cause a new string to be build for each character which will cause our time complexity to go up to roughly OmaxWidthn since we can create maxWidth no of new strings per character by our concatenations Please notice that this might not be the correct time complexity computation but it will surely not be On The interval covering problem was written in place of The sum problem Fixed Increment b if a crosses it Mab is defined in text to be the minimum possible sum of a subarray beginning at a and extending to b or beyond If a crosses b this gets a little confusing to analyse even though it works and can be proved additionally For the problem NearestRepeatedEntries it is mentioned that the solution provided has a time complexity of On I believe this should be Onm where m is the length of longest string among n entries because updating value of a key in hashmap will need to first check for key equality Please clarify This solution is just more simpler with dfs I am not sure if the bfs solution was given for any specific reason In problem Deadlock there is a code snippet provided and according to the explanation that follows the code snippet causes a deadlock But I am unable to see how a deadlock is happening here The explanation says Suppose U initiates a transfer to U and immediately afterwards U initiates a transfer to U Since each transfer takes place in a separate thread its possible for the first thread to lock U and then the second thread to be scheduled in and take the lock U The program is now deadlockedeach of the two threads is waiting for the lock held by the other thread If U and U have separate locks and the two threads only locks U s and U s lock in move how is there a deadlock being achieved here A similar question was asked on stack overflow but no answer was provided The following might be a deadlock though def moveself accto amount with selflock timesleeprandomrandom with acctolock if amount selfbalance return False acctobalance amount selfbalance amount loggingdebugreturning True return True If we have two accounts a and a and thread t transfers from a to a and thread t transfers from a to a the following might lead to deadlock t locks a and goes to sleep t locks a and goes to sleep After they wake up from sleep t locks a and t locks a which will then cause a deadlock since neither a nor a can be unlocked And this deadlock can surely be resolved by the posted solution as follows def moveself accto amount lock lock selflock acctolock if selfid acctoid else acctolock selflock with lock timesleeprandomrandom with lock if amount selfbalance return False acctobalance amount selfbalance amount loggingdebugreturning True return True since now t and t will always lock a and a in order if a s account id is smaller than a s