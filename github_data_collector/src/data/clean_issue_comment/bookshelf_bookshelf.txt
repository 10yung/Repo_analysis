 Includes a small lint fix and updates packagejsonenginesnode to specify I looks like Bookshelf already dropped support for Node w f ac bfdef a but this config was forgotten Fixes I dont see any open issue already Is there an SOP for supporting new Knex versions Id be happy to open a PR Introduction Attempting to perform queries using the withSchema option to target other databases leads to ERNODBERROR No database selected Issue Description I encountered this issue when attempting to save models on a separate database using the withSchema option This issue arose after an upgrade to bookshelf from an earlier release I believe its related to the automatic refreshes of models after queries Steps to reproduce issue The code being executed is as follows await bookshelfmodelCustomerforgefixturesmodelscustomer savenull method insert withSchema customerSchema The queries being executed from the debug log look as follows knexclient acquired connection from pool knexUid ms knexquery insert into customerdbtestcustomers city country createdat email firstname id lastname mobilephone moveindate nationalid postalcode streetaddress updatedat validnationalid values trx ms knexbindings City knexbindings Country knexbindings T Z knexbindings testtestcom knexbindings Test knexbindings knexbindings Testman knexbindings knexbindings T Z knexbindings knexbindings knexbindings Test St knexbindings T Z knexbindings trx ms knexclient releasing connection to pool knexUid ms knexclient acquired connection from pool knexUid ms knexquery select customers from customers where customersid limit trx ms knexbindings trx ms knexclient releasing connection to pool knexUid ms In the query log i can see that the insert query inserts into the correct database customerdbtest however the following select which i assume refreshes the model does not target the same database I believe this to be the root cause of this issue Issue Description When fetching a collection of models with relations if we only want to edit a related model and save it it crashes This happens at least with hasOnebelongsTo relations on SQLite Steps to reproduce issue Sample code repository javascript const loadedCatsWithTail await CatfetchAll withRelated tail const loadedTail await loadedCatsWithTailat relatedtail Error Undefined bindings detected when compiling SELECT Undefined columns tailidcat query select distinct tail from tail where tailid and tailidcat limit await loadedTailsave color white Reproduced on Bookshelf does not happen anymore when dowgrading to Theres no error either when fetching the parent model through new Cat id fetch withRelated tail Related Issues Adds the ability to disable running the count query on fetchPage Introduction Add an additional option to fetchPage called disableCount which fetches the desired page but does not make the additional count query Issue Description I would like to be able to use fetchPage and not have the second query for getting the count to be run This is desired for performance We use fetchPage in our API and in some cases do not want that additional count query to be run to decrease the loading time of the request Specifically we use another plugin that helps build the API which uses fetchPage to get data Providing a new option to disable this functionality will solve the issues By default this would be set to false and would function as it does today making it backwards compatible I would be happy to work on this and put out a PR Related Issues IssueNumber if necessary Introduction Your front page example references a nonexistent Posts variable Issue Description The front page has this code const User bookshelfmodelUser tableName users posts return thishasManyPosts This line specifically return thishasManyPosts references a variable Posts However that variable is never defined anywhere in that code and indeed the string Posts with a capital P appears nowhere on the front page at all except on that line It seems like an introductory example should be valid Javascript and either declare or import Posts or not reference it and reference Post instead Introduction When I call my belongsToMany I have a correct request but my model response is not correct Issue Description I have got this so I call this on the AlertsConfigs model js tests return thisbelongsToManyMeasure AlertsConfigsMeasures AlertConfigId MeasureId withPivot value comparison queryqb qbdebugtrue the request is sql select distinct MeasuresV AlertsConfigsMeasuresAlertConfigId as pivotAlertConfigId AlertsConfigsMeasuresMeasureId as pivotMeasureId AlertsConfigsMeasuresvalue as pivotvalue AlertsConfigsMeasurescomparison as pivotcomparison from MeasuresV inner join AlertsConfigsMeasures on AlertsConfigsMeasuresMeasureId MeasuresV id where AlertsConfigsMeasuresAlertConfigId in If AlertConfigId is the same and MeasureId is different in the AlertsConfigsMeasures table my belongsToMany works as expected While if AlertConfigId is identical and MeasureId is also identical in the AlertsConfigsMeasures table my belongsToMany my modelfetchOne returns only the element in the relationships But in all case the request works as expected So I suspect that bookshelf is doing a transformation between the response of the model request and the response of my fetchOne Issue Description Lets say that I have Bookshelf models Profiles and Users Here are the simplified versions of them javascript BookshelfmodelUser BookshelfModelextend tableName users hidden password salt hasTimestamps true profile function return thishasOneProfile id id javascript BookshelfmodelProfile BookshelfModelextend tableName profiles hidden name email hasTimestamps true user return thisbelongsToUser id id What I am trying to do in some controller is javascript return new User fetchPage pageSize PageLimit page PageNumber withRelated profile thenresult return resstatus send data resulttoJSON hidden name pagination resultpagination catchnext So I want to return a list of users with their profiles but I also want to show the email values for instance Thats why I override the hidden list in the toJSON call After that all other properties show up in the result including hidden ones from the Users model that I still want to hide My email column that I have to write even without dot notation ie tablecolumn btw is not there though I was able to trace how this argument is passed down with javascript serializeargs consolelogargs return BookshelfModelprototypeserializeapplythis args And its just the array name that I gave to the toJSON call for all nested models I thought that I could gather all hidden members then exclude the needed columns and utilize this new list So I came up with this function javascript function getAllFieldsToHidemodel hidden if model instanceof BookshelfCollection modellength return getAllFieldsToHidemodelat hidden else if model instanceof BookshelfModel hidden hiddenconcatmodelhidden null modelhidden ObjectvaluesmodelrelationsforEachrelation hidden getAllFieldsToHiderelation hidden return hidden else return hidden And then I do javascript const hiddenFieldsToInclude email const newHiddenList getAllFieldsToHideresult exclude column names that we need to show filterfield hiddenFieldsToIncludeindexOffield It retrieves an array of attributes to remove from the output for the given Bookshelf model and its nested relations But name conflict may occur here if models have columns with the same names The function works but maybe there is some more sophisticated way to achieve this Or it can be an issue request Thanks Related Issues IssueNumber if necessary Introduction When trying to retrieve information using withRelated function the function must contain the foreign key in order to work Issue Description For example I noticed that if I have two tables lets say Ranks and Categories rankscategoryid must match categoriesid and when trying to retrieve ranks from each category using withRelated the query function must select the foreign key otherwise it will return nothing Steps to reproduce issue This wont work withRelated ranks qb qbcolumnid ranknamedebug This will withRelated ranks qb qbcolumnid categoryid ranknamedebug Expected behaviour To not repeat or even require the foreign key that the model is trying to get Actual behaviour Foreign Key is required and repeated 