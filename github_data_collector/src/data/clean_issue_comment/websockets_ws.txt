Follow the specification and close the connection when a non masked frame is received on the server or a masked frame is received on the client Refs Closes Recent versions of Node have added getters for some of the internal stream properties and throws this state away when the stream is being ended This commit adds a polyfill for the internal properties that are now exposed through getters and checks for availability of properties that do not have a corresponding getter before using them Is this module by default RFC compliant Or must we do for example the utf and safe buffer checking manually I was reading this section So Im guessing manual checking those two things But are there any other things in the RFC yous are aware of that ws doesnt do outofthebox thats if ws isnt RFC compliant ws outofthebox Handle the breaking change introduced by Replace Travis with GitHub Actions Now that node core has added websocket support over http Its nice to know when it will be added to WS Ive read and followed the zlib memory fragmentation issue down to where people blaming the Linux kernel and glibc and whatnot My two cents There is nothing wrong with the Linux kernel There is nothing wrong with glibc There is nothing wrong with Nodejs The issue is with websocketsws Doing CPUbound tasks async is nothing more than a delusion there is no such thing as an async CPUbound task If it takes second of CPUtime it takes second of CPU time no matter when you perform it Passing a CPU bound task to some thread pool doesnt improve anything in fact it only adds more overhead Threading overhead You need to copy the data one extra time major overhead Youre basically just procrastinating what you need to do right now If you cannot keep up with what you buffer up youre obviously going to blow the process up from too much memory usage since you produce more than you consume You have two solutions Replace all zlib calls with sync calls and all problems go away and you will lower latencies and actually do work you need to do and not just fool yourself youre doing things in the background OR if you really want to try and use multithreading here which goes against how Nodejs is built and deployed Only buffer up NUMBEROFLOGICALCPUCORES with the async version and after this do sync calls until the buffer contains less than NUMBEROFLOGICALCPUCORES tasks Aka you NEED to block sometime because CPU work cannot be async like networking This solution is more complex and goes against what Nodejs is but you get to choose Is there any decent way to support safaris xwebkitdeflateframe extension name for permessagedeflate AFAICT this is more or less an alias for permessagedeflate and Ive just managed to get something working by rewriting incoming headers from SecWebSocketExtensions xwebkitdeflateframe to SecWebSocketExtension permessagedeflate clientmaxwindowbits and then rewriting associated outbound headers from SecWebSocketExtensions permessagedeflate servernocontexttakeover clientnocontexttakeover to SecWebSocketExtensions xwebkitdeflateframe nocontexttakeover which seems to work in fairly limited testing but is very awkward to do properly Ive done this using a horrible combination of httpServeronupgrade verifyClient and socketonheaders to rewrite inbound and outbound headers but if there was any concurrency at all Im pretty sure what Ive done will fail and rewrite outbound headers on the wrong response Of course ideally safari would send the right extension name but even if they were to fix that itll take a while before one could rely on it You have a closecode data method here But you dont expose the callback here The bufferedAmount property doesnt work correctly This code js var WebSocket requirews var socket new WebSocketwssechowebsocketorg socketonopen function socketsendabc consolelogbufferedAmount after send socketbufferedAmount socketonmessage function consolelogbufferedAmount after onmessage socketbufferedAmount setIntervalfunction consolelogbufferedAmount on interval socketbufferedAmount Prints bufferedAmount after send bufferedAmount after onmessage bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval In Chrome and Firefox on the other hand this is what gets output bufferedAmount after send bufferedAmount after onmessage bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval bufferedAmount on interval Without a functioning bufferedAmount property its not possible to use the code Ive written to implement backpressure in the browser on the server as well cc mafintosh maxogden 