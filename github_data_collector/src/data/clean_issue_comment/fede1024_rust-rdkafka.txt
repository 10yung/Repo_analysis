Im having problems building my project that is using release It seems that problems started after the release of rustrdkafka and rdkafkasys Compiling rdkafkasys v Compiling rdkafka v error E cannot find function primitivetordkafkaresperrt in crate rdsys Userstkasucargoregistrysrcgithubcom ecc db ec rdkafka srcclientrs let err rdsysprimitivetordkafkaresperrterr not found in rdsys Release is fetching rdkafkasys from which the function primitivetordkafkaresperrt has been removed When I try to assign a TopicPartitionList to a Consumer I get compilation error in Historygetrange async fn mut rdkafkasysbindingsrdkafkatopicpartitionlists cannot be sent between threads safely The code gets the first and the last message from a singlepartition topic When I remove TopicPartitionListrelated lines its construction and consumerassign the code compiles successfully rust fn getrange schema Schema topic String config ClientConfig timeout Duration ResultRange Error let mut config configclone let groupid i randrandom configsetgroupid groupidtostring let consumer StreamConsumer configcreate logtraceAssigning partition let partition let mut tpl TopicPartitionListnew tpladdpartitionoffset topic partition OffsetBeginning consumerassign tpl logtraceAssignment consumerassignment logtraceconsume first message let stream consumerstartwithtimeout true let firstitem stream consumeone schema streamawait logtraceSeek to end consumerseek topic partition OffsetEnd timeout logtraceGet position let positions consumerpositiontotopicmap let offset positions get topictoowned partition okorelse HistoryErrorTopicNotFoundtopictoowned toraw logtraceOffset offset logtraceSeek to end consumerseek topic partition Offsetfromrawoffset Sometimeout logtraceconsume last message let lastitem consumeone schema streamawait OkRange start firstitem end lastitem async fn consumeonea C ConsumerContext schema Schema stream MessageStreama C ResultItem MessageStreama C Error let item stream streamintofutureawait deserialise item omitted tonicasynctrait impl History for HistoryService async fn getrange self request RequestGetRangeRequest ResultResponseGetRangeResponse Status let mut response GetRangeResponse ranges vec for topic in selftopicsiter let range getrange selfschema symbol selfconfig selfdefaulttimeoutawait responserangepushsymbol OkResponsenewresponse Ive set up rdkafka in my project with Cargotoml like this to use the recently added zstd compression feature toml dependencies rdkafka version features cmakebuild zstd It seems to compile fine on Debian Stretch with zstd from backports libzstddevamd dfsg bpo Connecting to Kafka Cluster version with brokers set to compressiontypezstd in serverproperties and consuming messages fails with the following exception Message consumption error UnsupportedCompressionType Unsupported compression type The binary built and used does have zstd compiled in statically strings pathtobinary grep Fi zstd shows many many lines of the ZSTD function signatures I wonder what I could do to debug this further Does anyone have a successful zstd enabled setup The other processes connecting to the Kafka cluster have no issue using zstd JDK benesch This gets rid of the extra thread and futures executor blockon without introducing a tokio dependency I have a situation where I need to know from when on messages to a topic will be picked up by my consumer so I can trigger another process to start writing to that topic after that ensuring I will receive all its messages Currently I create a BaseConsumer in my main thread and then start polling that BaseConsumer from a bunch of worker threads I install a ConsumerContext to listen for a rebalance and once I receive the first rebalance I assume that all further messages will be received by my consumers That seems to work but takes seconds on startup depending on the weather which I find a bit too long Ive tried to speed things up by using assign immediately after creating the consumer and subscribing like so rust let m consumerfetchmetadataSome topic Durationfromsecs ok let t mtopicsiterfindt tname topic let tpl OptionHashMapString i Offset tpartitionsitermapp Sometopictoowned pid OffsetOffset consumerfetchwatermarks topic pid Durationfrommillis map high highok collect consumerassign tplok Some and then I dont receive any messages at all it seems Can I somehow trigger a rebalanced or force consumption from a certain set of offsets Sorry for the blatant support request If its a not implemented I shall try Hi I recently started looking at this library and going through the examples Im new to Rust but not kafka One thing that was confusing to me right away was understanding what message consists of in the simpleconsumer example rust match message Err warnError while reading from stream OkErre warnKafka error e OkOkm let payload match mpayloadviewstr None SomeOks s SomeErre warnError while deserializing message payload e In particular the level of nesting to unwrap to get to a payload value Ok Ok Some Ok I eventually figured it out but wound up wondering if there was a way to simplify this at the API level As an experiment I tried fiddling around with flattening the result of MessageStreampoll and came up with this diff asrcconsumerstreamconsumerrs bsrcconsumerstreamconsumerrs impla C ConsumerContext static MessageStreama C impla C ConsumerContext a Stream for MessageStreama C type Item KafkaResultBorrowedMessagea type Error fn poll mut self PollOptionSelfItem SelfError selfreceiverpoll mapready readymapoption optionmappolledptropt polledptroptmapor ErrKafkaErrorNoMessageReceived polledptr polledptrintomessageofselfconsumer type Item BorrowedMessagea type Error KafkaError fn poll mut self PollOptionBorrowedMessagea KafkaError match selfreceiverpoll OkAsyncNotReady OkAsyncNotReady OkAsyncReadySomeSomev match vintomessageofselfconsumer Okmessage OkAsyncReadySomemessage Erre Erre OkAsyncReadyNone OkAsyncReadyNone OkAsyncReadySomenone ErrKafkaErrorNoMessageReceived Erre ErrKafkaErrorMessageConsumptionRDKafkaErrorFail Besides reducing the unwrap nesting the flatter structure allows the combinators in futuresstreamStream such as maperr then foreach to work more naturally over the stream messages You can see how this also simplifies many of the examples tests foreach Already defined to unwrap Oks so additional unwrapping isnt needed within the callback In addition errors dont need to be separately filtered since this already happens they are routed to maperr maperr Applies to all errors in the stream not just the outer level then Applies to all Results so this takes the role of foreach if needed in the examples To me this greatly improves the ergonomics of the API As I said Im new to Rust and Im sure there are some considerations Ive missed Id be interested in your thoughts There is a crash in rustrdkafka that panics the program with an Illegal instruction It is not easy to reproduce but it seems to be related to Kafka disconnecting and connecting To reproduce I did Set up Kafka with a topic I set it to partitions not sure that affects the result Set up a process that keeps sending data to the topic continously k msgs Connect the simple consumer to the topic on the system running kafka execute while true do sleep systemctl stop kafka sleep systemctl start kafka done wait fro this to cycle through a few can take a few hours Plugging it in lldb I get the following message thread tid x a a simpleconsumerrdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd err name simpleconsumer stop reason illegal instruction operand frame x a a simpleconsumerrdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd err simpleconsumerrdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd x a a ud x a c movw xff x rsp x a jmpq x a d d rdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd x a movw xff x rsp and the backtrace thread tid x a a simpleconsumerrdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd err name simpleconsumer stop reason illegal instruction operand frame x a a simpleconsumerrdkafkasyshelpersrdkafkaresperrttordkafkaerrorh fde cbd err frame x a f simpleconsumerLTrdkafkasystypesRDKafkaErroru asu coreconvertFromLTrdkafkasysbindingsrdkafkaresperrtGTGTfromh c f f f a e err frame x a f simpleconsumerLTTu asu coreconvertIntoLTUGTGTintohf e de self frame x a bae simpleconsumerrdkafkamessageBorrowedMessagefromconsumerh a c a ptr x f c consumer x ffebeb ab frame x a ba simpleconsumerrdkafkaconsumerstreamconsumerPolledMessagePtrintomessageofhdee f b selfPolledMessagePtr at x ffebeb bb consumer x ffebeb ab frame x a b a a simpleconsumerLTrdkafkaconsumerstreamconsumerMessageStreamLTu aCu CGTu asu futuresstreamStreamGTpollu bu bclosureu du du bu bclosureu du du bu bclosureu du du bu bclosureu du dhbe aba dc dpolledptrPolledMessagePtr at x ffebeb c frame x a b a simpleconsumerLTcoreoptionOptionLTTGTGTmaporh e c e abselfOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb c defaultResultrdkafkamessageBorrowedMessage rdkafkaerrorKafkaError at x ffebeb d fclosure at x ffebeb c frame x a b a simpleconsumerLTrdkafkaconsumerstreamconsumerMessageStreamLTu aCu CGTu asu futuresstreamStreamGTpollu bu bclosureu du du bu bclosureu du du bu bclosureu du dhf f c ab polledptroptOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb cf frame x a b c simpleconsumerLTcoreoptionOptionLTTGTGTmaph f dfd a fdf fselfOptioncoreoptionOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb df fclosure at x ffebeb e frame x a b simpleconsumerLTrdkafkaconsumerstreamconsumerMessageStreamLTu aCu CGTu asu futuresstreamStreamGTpollu bu bclosureu du du bu bclosureu du dh b f c b e optionOptioncoreoptionOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb eb frame x a c f simpleconsumerLTfuturespollAsyncLTTGTGTmaph e e fba ef bselfAsynccoreoptionOptioncoreoptionOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb f fclosure at x ffebeb f frame x a b simpleconsumerLTrdkafkaconsumerstreamconsumerMessageStreamLTu aCu CGTu asu futuresstreamStreamGTpollu bu bclosureu du dhe b e ba cff readyAsynccoreoptionOptioncoreoptionOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb fc frame x a b simpleconsumerLTcoreresultResultLTTCu EGTGTmaph a bef c cfselfResultfuturespollAsynccoreoptionOptioncoreoptionOptionrdkafkaconsumerstreamconsumerPolledMessagePtr at x ffebeb a opclosure at x ffebeb a frame x a b simpleconsumerLTrdkafkaconsumerstreamconsumerMessageStreamLTu aCu CGTu asu futuresstreamStreamGTpollh b a a a bself x ffebeb ad frame x a aa ea simpleconsumerLTfuturestaskimplSpawnLTTGTGTpollstreamnotifyu bu bclosureu du dhfd db e a c dnullclosure at x ffebeb a s x ffebeb ad frame x a aa d simpleconsumerLTfuturestaskimplSpawnLTTGTGTenteru bu bclosureu du dh e a frame x a b c simpleconsumerfuturestaskimplstdsethec adfb cee etask x ffebeb a fclosure at x ffebeb a frame x a aa f simpleconsumerLTfuturestaskimplSpawnLTTGTGTenterh a e self x ffebeb ad unparkunavailable fclosure at x ffebeb a f frame x a aa a simpleconsumerLTfuturestaskimplSpawnLTTGTGTpollfnnotifyhbb ed e cself x ffebeb ad notify x f fec c id fclosure at x ffebeb a c frame x a aa be simpleconsumerLTfuturestaskimplSpawnLTTGTGTpollstreamnotifyhea d d ebaself x ffebeb ad notify x f fec c id frame x a b ae simpleconsumerfuturestaskimplstdLTimplu futurestaskimplSpawnLTSGTGTwaitstreamu bu bclosureu du dh d c fdf notify x f fec c frame x a b f simpleconsumerfuturestaskimplstdThreadNotifywithcurrentu bu bclosureu du dhd b ebf notify x f fec c frame x a aae simpleconsumerLTstdthreadlocalLocalKeyLTTGTGTtrywithh bd a b e self x a f d fclosure at x ffebeb a frame x a aac simpleconsumerLTstdthreadlocalLocalKeyLTTGTGTwithhac e e f f self x a f d fclosure at x ffebeb a frame x a b fe simpleconsumerfuturestaskimplstdThreadNotifywithcurrenth f f a ed afclosure at x ffebeb a frame x a aa simpleconsumerfuturestaskimplstdLTimplu futurestaskimplSpawnLTSGTGTwaitstreamh e fa e d c eself x ffebeb ad frame x a b fbb simpleconsumerLTfuturesstreamwaitWaitLTSGTu asu coreitertraitsiteratorIteratorGTnexth ddfb b c self x ffebeb ad frame x a c e simpleconsumersimpleconsumerconsumeandprinth f bf brokers str at x ffebeb ab groupid str at x ffebeb ab topics str at x ffebeb ab frame x a c simpleconsumersimpleconsumermainh b bf c e frame x a bd simpleconsumerstdrtlangstartu bu bclosureu du dhaa b bdec fda frame x a c aec simpleconsumerdocallclosurei inlined closure frame x a c aeb simpleconsumerdocallclosurei frame x a c e fa simpleconsumerrustmaybecatchpanic frame x a c b cd simpleconsumerlangstartinternal inlined tryi closure frame x a c b f simpleconsumerlangstartinternal inlined catchunwindclosurei frame x a c b f simpleconsumerlangstartinternal frame x a bd d simpleconsumerstdrtlangstarthd f b f dfcaa main x a c d argc argv x ffebeb f f frame x a c ca simpleconsumermain frame x f fd d libcso libcstartmain Note I could no t replicate this behaviour with the librdkafka sampleconsumer I am trying to sendproduce concurrent message I am using tokiospawn to spawn a future producer inside a mpsc receiver with below code let f rxforeachmoveres debugkakfa producer channel input data resinput printlnreceived data startproducer resinput let mut modifiedres resinputclone let tx ressender let pipeoffset modifiedresrfindunwraporresinputlen let key modifiedressplitoffpipeoffset let len modifiedreslen modifiedrestruncatelen producersendcopyString String topicname None Some modifiedres Some key None let t producersendString StringFutureRecordto topicname key key payload modifiedres thenres match res Err errorcould not deliver message to topic as future is canceled match tx Sometxi txisendErr Future canceled can not confirm if message delivered to kafka topic tostring None Okresin match resin Okpartition offset debugsuccessfully sent message to kafka at partition offset partition offset match tx Sometxi txisendOkresult is oktostring None Errerr msg errorfailed to send message error is msg match tx Sometxi txisendErr formaterror occurred while sending message to kafka topic msg Ok tokiospawnt Ok tokiospawnf It only process first message sentout of N concurrent request and does not process other messages Although i can see that DeliveryFutures poll function is getting called for each request I am facing this issue only when i use tokiospawn If instead of using tokiospawnMethod If i chain to to main future f by returning t from foreachMethod it works fine Method makes it sequential that is if one of message takes time to be delivered it does not execute message until current message is sent successfully I dont desire this behavior and want to make it parallel thats why i want to use method Please not that key are same in all the request Does key need to be unique This would give a good idea of the overhead compared to rdkafka itself