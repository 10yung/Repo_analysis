This fixes incorrect flash size in dfu iface string While writing a firmware for the ATSAMD D ASS I failed to implement a workaround for a silicon bug that Atmel describes as Errata Various sources online summarize this errata as the DFLL clock must be requested before being configured otherwise a write access to a DFLL register can freeze the device If bugged firmware attempts to program the DFLL in an incorrect way too soon after reset the BMP will fail to scan it and give Timeout during scan Is target stuck in WFI This will make it impossible to erase the firmware and try to flash a working one As far as I can tell what is happening is that the samdprobe function releases the ARM core from Atmels extended reset state However the BMP does not halt the core at this point and the core can start running the bugged firmware By the time GDB tries to attach to the target the firmware has triggered the errata and frozen the core The BMP then gets very confused As a workaround I wrote the following patch that was able to work around the problem for me by moving the logic that releases the extended reset state to the attach function Im not entirely sure why it works since it seems like the code should still have a race window with the firmware but it worked when I tried it I dont expect this patch to get merged but Im not sure how this should be properly fixed I am filing this issue for now in order to open a discussion for a proper solution to the problem patch diff git asrctargetsamdc bsrctargetsamdc index d ce asrctargetsamdc bsrctargetsamdc include targeth include targetinternalh include cortexmh include gdbpacketh static int samdflasherasestruct targetflash t targetaddr addr sizet len static int samdflashwritestruct targetflash f bool samdprotectedattachtarget t return true bool samdhaxattachtarget t tattach cortexmattach if targetmemread t SAMDDSUCTRLSTAT SAMDSTATUSACRSTEXT gdboutfin hooked attach n Write bit to clear from extended reset targetmemwrite t SAMDDSUCTRLSTAT SAMDSTATUSACRSTEXT return cortexmattacht Use the DSU Device Indentification Register to populate a struct describing the SAM D device static void samdaddflashtarget t uint t addr sizet length char variantstring bool samdprobetarget t gdboutfin samdprobe n uint t cid samdreadcidt uint t pid samdreadpidt bool samdprobetarget t samdaddflasht x x targetaddcommandst samdcmdlist SAMD gdboutfabout to poke reset bullshit n tattach samdhaxattach if If were not in reset here if platformsrstgetval gdboutfin first if statement n Well have to release the target from extended reset to make attach possible if targetmemread t SAMDDSUCTRLSTAT SAMDSTATUSACRSTEXT gdboutfin second if statement n Write bit to clear from extended reset targetmemwrite t SAMDDSUCTRLSTAT SAMDSTATUSACRSTEXT endif gdboutfleaving samdprobe n return true New pull request replacing Fix for On the Arduino Nano BLE the reset signal takes a long time to return to the high state During that time the MCU is stopped and all memory operations in cortexmreset fail This pull request is the result of discussions with UweBonnes New functions platform agnostic platformsrstassert assert SRST for ms platformsrstrelease release SRST and wait until the target is likely responsive again platformsrstreset perform reset assert release Replace the lowlevel functions with the new ones where appropriate Improve timing functions timeouts time measurement delay to a minimum precision of ms relevant for STM based hosts and Launchpad ICDI Removed timing and readback code from platformsrstgetval as it has been moved to the new platform agnostic functions Aside from the cleanup the main addition is platformsrstreset After releasing SRST it waits until reading back the GPIO value shows the desired effect and measures the duration It then waits the same duration again as the target might have different thresholds to distinguish lowhigh and as the target might need a short time to become responsive again This should solve the problem observed on the Arduino Nano BLE which is not immediately responsive after the reset signal is released since it takes about ms to return to the high level Im using the BMP with PlatformIO and an Arduino Nano BLE nRF Debugging works but firmware upload reliably fails every other time In particular it fails after resetting the Arduino by power cycling or pressing the button on the board The executed command is armnoneeabigdb nx batch ex target extendedremote devcuusbmodemC CA EF ex monitor swdpscan ex attach ex load ex comparesections ex kill firmwareelf And the output is Target voltage V Available Targets No Att Driver Nordic nRF M M Nordic nRF Access Port halsleep at mbedostargetsTARGETNORDICTARGETNRF xTARGETNRF sleepc mbedostargetsTARGETNORDICTARGETNRF xTARGETNRF sleepc No such file or directory Error erasing flash with vFlashErase packet The error message on the last line is from the load command With a debug version of BMP I have narrowed down the problem to this line Further investigations showed that the error will always occur on the first targetmem call In fact it looks like its already pending before the function is called It goes away with a call to targetcheckerror before line Ill will further investigate it and come up with a PR So stay tuned im reading samd datasheet on this section i think define SAMDDIDSERIESMASK x F should be x F Ive created initial implementation for Blackmagic firmware and implemented a basic OpenOCD HLA interface driver for blackmagic probe On the probe itself Ive extended the remotec interface with a new class REMOTEHLPACKET Its currently in experimental stage but seems to pass functional tests eg single stepping flashing RTOS threads support openocd built in memory transfer tests Speed and performance feel similar to that of stlink Transfer rate is about KBs Half of that of direct gdb connection but for RTOS support of OpenOCD I think its a reasonable tradeoff It enables this workflow Target SWD Blackmagic on stlink REMOTEHL commands over devttyACM OpenOCD GDB server OpenOCD features RTOS threads OpenOCD commands etc GDB extendedremote TODO srst reset assertion JTAG Trace SWO functionality using libusb Ability to set serial port use TCP connection You can find the code on my github cortexmreset first pulse SRST before the target is released as long as CORTEXMTOPTINHIBITSRST is not set Later CORTEXMAIRCRVECTKEY CORTEXMAIRCRSYSRESETREQ triggers another reset I propose to either remove the reset via srst at all or invert CORTEXMTOPTINHIBITSRST to CORTEXMTOPTENABLESRST so that some device may request this extra reset Any opinions Hi I have the problem when I uses BMP with MCU ATSAMR Target connected with helping SWD interface but so that to see its need send in gdb mon jtagscan And after mon swdpscan And then we see the target If we skip the step jtagscan we dont see the target As per the Discord discussion today I have changed OWNHL to LOWLEVELUNAVAILABLE and also added a comment before the usage of LOWLEVELUNAVAILABLE in gdbpacketc I am not able to test building pcstlinkv on my Windows machine however I do not think this minor change will cause any issue I understand that the relevant code for unlocking NRF chips got copied from by markrages When I took a look at it I wondered why the addresses MDMPOWEREN and MDMSELECTAP are not multiples of four I am sure that part of the code currently writes stuff to invalid addresses and therefore does nothing This line should be cpp adiv dpwriteapdp ADIV DPCTRLSTAT ADIV DPCTRLSTATCDBGPWRUPACK ADIV DPCTRLSTATCDBGPWRUPREQ And that line should be cpp adiv dpwritedp ADIV DPSELECT x 