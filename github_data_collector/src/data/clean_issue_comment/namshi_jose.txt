 The PHP support and php support branches create a conflict as they have the same caseinsensitive name Deleting either one would fix it The current implementation relies on the native php functions for encodingdecoding json The flags provided are JSONUNESCAPEDSLASHES Depending on who creates the access token the json encoding rules might be different I have a case where I am getting an access token from Microsoft and the special characters are not encoded in json strings and hence I have to use JSONUNESCAPEDUNICODE as well This commit supports injecting a custom Json encoder Then main changes are All places that refer to encoder have been renamed to base Encoder Methods setEncoder are renamed to setBase Encoder namespace Namshi JOSE Base is moved to Namshi JOSE Encoder to support json encoders along with other encoders The default JsonEncoder class is added Hi I tried using ES but got the following error Fatal error Uncaught InvalidArgumentException phpseclib LTS even the latest doesnt support PHP yet in vendornamshijosesrcNamshiJOSESignerOpenSSLECDSAphp But phpseclib seems to be alright these days with PHP their builds pass on PHP and see If I comment out the version check blocks in SignerOpenSSLECDSAphp then it seems to be working OK Is the block for PHP still justified If yes could it at least be made more explicit in the README of this project Also would it be possible to emphasize the need to require phpseclib for ECSDA support in the same README Thanks I got message Malformed UTF characters possibly incorrectly encoded when trying to decode a token publickey opensslpkeygetpublicfileDIRkeyspublicpem if signatureisValidpublickey ES return new ResponseUnauthorized Its working fine when a generate the token using your library but when the token came from elsewhere a ruby library I got that error Any idea last version show error phpseclibphpseclib please update version phpseclib fix As mentioned in RFC iat is an optional claim If iat is added in payload token that does not contains iat will never pass signature verification According to JWT standard the iat claim i optional When decoding token without iat using SimpleJWS then verification of the signature fails There is a function generateSigninInput in JWT class that return the input that the signature is verified against php public function generateSigninInput base payload thisencoderencodejsonencodethisgetPayload JSONUNESCAPEDSLASHES base header thisencoderencodejsonencodethisgetHeader JSONUNESCAPEDSLASHES return sprintfss base header base payload But when decoding token without iat claim with SimpleJWS then iat is automatically added to the decoded payload in setPayload method of SimpleJWS so the signinginput is different than was originally in token php public function setPayloadarray payload if issetpayload iat payload iat time return parentsetPayloadpayload Can someone please include a an implementation example of the SimpleJWS script that is not a unit test All the unit tests work flawlessly and arguably very often prove nothing A simple test like the one below is far more useful however this simple test is difficult to configure if you are new to composer and namespaces That is the code below will not work without refinement and ensuring that the autoloader is invoked It would be very helpful if someone could include a working version php use Namshi JOSE SimpleJWS if username correctUsername pass ok user DbloadUserByUsernameusername jws new SimpleJWSarray alg RS jwssetPayloadarray uid usergetid privateKey opensslpkeygetprivatefilepathtoprivatekey selfSSLKEYPASSPHRASE jwssignprivateKey setcookieidentity jwsgetTokenString All changes since are missing in the changelog 