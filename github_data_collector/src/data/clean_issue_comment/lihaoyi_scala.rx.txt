Updates orgscalasbtsbt from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgscalasbt artifactId sbt details labels libraryupdate semverpatch fixes currently blocked by Hi Is there some roadmap for support I was previously working with scalarx Migrating from to is dealing with a lot of API changes Please provide a changelog Maybe travisci will be nice this time Lets say I have a custom Extractor and a Var scala object Extractor def unapplyx Int Option Int Somex val a Var Then the following code raises a comile error scala Rx a match case Extractorx x Error error unexpected UnApply Extractorunapplyunapplyselector unapply x Sorry normally Id submit a pull request for this kind of thing but unfortunately I dont have time Many people new to the project will start by working through the examples in the README so its relatively important that it be mistake free Here are some issues I found I had to change the following code scala intercept ArithmeticException b assertbtoTryisInstanceOf Failure To this scala intercept ArithmeticException bnow Otherwise it complains No implicit CtxData is available here assertbtoTryisInstanceOf Failure Otherwise it complains class Failure takes type parameters assertbtoTryisInstanceOf Failure An unknown function inside is referenced a number of times eg like so scala insidectoTrycase Success I think occurances of inside should be replaced with assertMatch scala assertMatchctoTrycase Success But then its probably necessary to go on and explain that to use assertMatch you have to extend TestSuite from scala import utest object XyzTests extends TestSuite val tests this pqrTest assertMatchbtoTrycase Success In the following code why is a wrapped in another Rx when creating b isnt a already a perfectly acceptable Rx scala val a Var val b Rx Rx a Rx mathrandom Not having standard safe implicits is a barrier to using scalarx with scalajs Below are links to several implementations people have come up with It would be nice to have some standard implicits that we could refer to and that the community could improve over time Observations The Hands on Scalajs book has a recommended implicit that needs to be updated asap Some peoples implicits use toTry and get values safely some do not Some people implicits wrap the rx value in a container node making it easy to remove all child nodes However adding these intermediate nodes doesnt work well when using libraries like bootstrap example Voltirframework I am not sure how to combine safety being sure to removereplace all children and not creating a container node that messes up bootstrap cssjs Implementations I try to avoid adding implicit ctx CtxOwner to each class with following approach class Test implicit val ctx CtxOwner CtxOwnersafe var count val a Var val b Var def mkRxi Intimplicit ctx CtxOwner Rx count i b val c Rx val newRx mkRxa newRx printlncnow count a printlncnow count b printlncnow count to foreach i a i printlncnow count b printlncnow count This seams to work but I dont know if this is really correct or if there is a better way to do this 