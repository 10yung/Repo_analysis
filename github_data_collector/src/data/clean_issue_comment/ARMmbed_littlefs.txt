The characteristics of littlefs are If lfsfileseek is called to write data it will look for a new block to write copy the data from the old block and add new data In this way if an K file increases the last bytes each time through lfsfileseek LFSSEEKEND it needs times which means that the block needs to be erased times Compared to fsopen LFSOAPPEND which only required block erases the number of erases increased by times const struct lfsconfig cfg block device operations read blockread prog blockprog erase blockerase sync blocksync block device configuration readsize progsize blocksize blockcount cachesize lookaheadsize blockcycles i use stm f Internal flash test litterfs when lfsfileopen lfs file bootcount LFSORDWR LFSOCREAT happen lfs error Corrupted dir pair at why I created a user interface that let me make and read directories and make and read files on a PC However when reading a sub directory with one file I got in an infinite loop in the lfsfstraverse function when it was called from lfsfssize after the lfsdirread of the sub directory path This was found to be caused by lfst structure element fnext equal to the current f which caused the for loop in lfsfstraverse iterate over any open files for lfsfilet f lfsfiletlfsmlist f f fnext to never exit there seems to be a couple of f fnext in for loops that may have the same problem My source code case l fl path Directory listing whileptr ptr printfptr size d n strlenptr res lfsdiropen LFSfs Dir ptr ifres putrcres break p s s for res lfsdirread LFSfs Dir Finfo ifres LFSERROK Finfoname break ifFinfotype LFSTYPEDIR s else s p Finfosize xprintfc llu s s n Finfotype LFSTYPEDIR D Finfosize Finfoname printf u Files llu bytes total n u Dirs s p s ss lfsfssize LFSfs infinite loop when path is subdirectory ifss printf d blocks used n ss else putrcss break When adding littlefs to a project that uses Clang static checking that includes clanganalyzercore the littlefsco object throws several errors during compilation Building C object thirdpartyCMakeFileslittlefsdirlittlefslfsco FAILED thirdpartyCMakeFileslittlefsdirlittlefslfsco usrbincmake E runcocompile tidyusrbinclangtidy formatstylefile sourcethirdpartylittlefslfsc usrbingcc DBUILDTEST O DNDEBUG Wall Werror g Wextra Wshadow Wundef Wnooverflow Wnoimplicitfunctiondeclaration Wnomissingfieldinitializers stdgnu MD MT thirdpartyCMakeFileslittlefsdirlittlefslfsco MF thirdpartyCMakeFileslittlefsdirlittlefslfscod o thirdpartyCMakeFileslittlefsdirlittlefslfsco c thirdpartylittlefslfsc plantigabuildthirdpartylittlefslfsc error st function call argument is an uninitialized value clanganalyzercoreCallAndMessagewarningsaserrors atag lfsfromle atag buildthirdpartylittlefslfsc error Call to function strcpy is insecure as it does not provide bounding of the memory buffer Replace unbounded copy functions with analogous functions that support length arguments such as strlcpy CWE clanganalyzersecurityinsecureAPIstrcpywarningsaserrors strcpyinfoname buildthirdpartylittlefslfsc note Call to function strcpy is insecure as it does not provide bounding of the memory buffer Replace unbounded copy functions with analogous functions that support length arguments such as strlcpy CWE buildthirdpartylittlefslfsc error Call to function strcpy is insecure as it does not provide bounding of the memory buffer Replace unbounded copy functions with analogous functions that support length arguments such as strlcpy CWE clanganalyzersecurityinsecureAPIstrcpywarningsaserrors strcpyinfoname Suppressing clang checkingwarningsaserrors on the library allows littlefs to build just fine and indeed I can cross compile with armgcc with no problem I understand the reasons for using strcpy on such single character literals but for the purposes of projects which may use clang or other static analysis would it make sense to change these function calls to be the safer strncpy or strlcpy Here are the resulting lines in my CMakeListstxt that exclude Clang other compilation flags are set elsewhere littlefs setlfstarget littlefs setlfssrc littlefslfsc littlefslfsutilc addlibrarylfstarget lfssrc targetincludedirectorieslfstarget INTERFACE littlefs setpropertyTARGET lfstarget PROPERTY CSTANDARD There are issues with our CLANGTIDY and this library were going to suppress them for now settargetpropertieslfstarget PROPERTIES CCLANGTIDY if fileflags LFSFINLINE lfsmaxfileposnsize filectzsize lfsmin x fe lfsmin lfscfgcachesize lfscfgblocksize inline file doesnt fit anymore int err lfsfileoutlinelfs file during write files when this conditions is occurred then next write data LFSFINLINE is cleared and will erase a new blockbut the LFSFINLINE is not set after this per time writing will erase a new block this will cost a lot of time is there any solutions or the file size is limited How to configure littlefs internal chip flash Chip STM F RCT RET BLOCK SIZE x or x For example there are files each file is bytes path file path file path file path file path file path file path file path file path file path file It takes about K bytes How do I configure readsize progsizeblockcount cachesize blockcycles blockcount lookaheadsize Especially smallest blockcount And why this configuration Hi I am using Winbond QSPI Nand flash with W N GV Gbit MB memory with only block erase KB Is there any size limitation for using higher sizeBlocksize in LittleFs For my flash memory with a page readprogram and block erase interface does it requires a flash translation layer In my first look and up on looking the configuration structures I felt like LittleFs is handling these translation If it not requires the translation layer Can I use it straight in my program which runs in FreeRTOS With minimal mapping ie only configuring lfsconfig If anybody have experience in porting the same and you have a how to doc please share if it is for STM and for FreeRTOS really wonderful Regards Visakh SV lfsnpw returns a value v such that v a and v a but the previous comment incorrectly describes it as less than or equal to a I had a system that was constantly hitting this assert after making this change it recovered immediately Summary It appears that LFS is targeting the C standard as the minimum C standard that is required to compile the library However this is not mentioned in the READMEmd DESIGNmd nor SPECmd documents It would be helpful to explicitly list this requirement in at least one of those documents My vote would be to add it as a goal in the top of the READMEmd as part of the list including Powerloss resilience Dynamic wear leveling and Bounded RAMROM Why c I realized that although I could offer suggestions or perhaps even PRs for issues in LFS I could not do so without knowing at least the minimum C version that it would need to work with Since none of the docs listed above indicated this I dug in to find the minimum version The Travisyml file as part of the CI checks compiles with stdc This leaves only c aka c or ansi iso aka c or c as the earlier versions Neither c nor c support Cstyle comments and therefore the minimum target version must be c 