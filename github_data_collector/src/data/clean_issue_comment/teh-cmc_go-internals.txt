 Its quite possible this is covered in Chapter or elsewhere and I missed it because I am lazy If so apologies Based on my C background I believe I completely understand how Go handles your typeassertion example here It can just as you say compare Efacetype with typeuint But I cannot fathom how the following code works type Craft interface Float type Car struct type Boat struct func c Boat Drive func c Boat Float func c Car Drive var vface interface Drive var cface interface Float func main b Boat vface b cface vfaceCraft On the line cface vfaceCraft all the compiler knows about vface is that it is some kind of Vehicle Incidentally its type compares equal to typeBoat but nobody said anything about Boat on this line so that cant be relevant to anything So how does the runtime know how to convert an arbitrary Vehicle into a Craft If you initialize b Car instead then you get panic interface conversion mainCar is not mainCraft missing method Float at runtime which is exactly what I would expect but I dont understand how the runtime figured that out Does the type structure for Car contain a list of the names and signatures of every one of its methods and then the interfaceconversion code walks through that whole list at runtime to collect the needed methods to populate a Craft itab or panic In C terms your Efaceuint example is simply a stdanycast relatively cheap but the vfaceCraft example seems much wilder much more dynamic and costly so costly that it cant be done at all in C Is that right I actually got surprised that type switches are ON how else could it work I would assume that since the list of hashes is known at compile time the compiler could find a perfect hashing function and just do a few arithmetic ops to get the address on which to jumpsup sup At least if the size of switch exceeds some threshold If finding perfect hash would be too timeconsuming it could at least sort the hashes and do a binary search I guess the answer is that this is one of the optimizations Go is still awaiting EDIT sup sup Actually it would need to get just an index and lookup the target address compiler knows the list of target hashes but not all input hashes bugfix 