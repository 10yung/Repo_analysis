The samples seem to mostly use asyncstd I have no strong feelings about tokio and asyncstd but most of the other libraries Id like to use hyper reqwest trustdns etc mostly use the tokio AsyncReadAsyncWrite and tokiomain macro It would be nice to see capnproto support these without the need of the external unpublished adapter crate This PR adds a new crate called capnpconv allowing for automatic proc macro based code generation for serialization and deserialization Should solve issue Hi All I need to move a Vecu with Capnprotorpc In my capnproto file i have used a List interface Node getCsr csrresponse CsrResponse register certrequest CertRequest install struct CsrResponse csr ListUInt struct CertRequest cert ListUInt caCert ListUInt But when i have to use the cosde generated into the Server RPC for example I have no idea how to translate the Vecu to a List and viceversa thanks in advance for your help Not sure if this is the best place to ask this question however how exactly are we supposed to access the base interface when using interface inheritance Ive looked through the examples and the generated rust code for my interfaces but I dont see an obvious solution Is this actually supported in the rust implementation The current getting started text from would benefit from additional clarity in the following section and you can include the generated code in your project like this pub mod foocapnp includeconcatenvOUTDIR foocapnprs My questions are Where exactly does mod foocapnp belong How is the path for foocapnprs generated Im digging around looking for it in my target directory Ive set up a RPC server using capnprpc following the examples given in the repo The code looks like rust let addr portinto let socket tokionetTcpListenerbind addrunwrap let client simplecapnpsimpleToClientnewselfintoclientcapnprpcServer let done socketincomingforeachmove socket socketsetnodelaytrue let reader writer socketsplit let network twopartyVatNetworknew reader stdioBufWriternewwriter rpctwopartycapnpSideServer Defaultdefault let rpcsystem RpcSystemnewBoxnewnetwork Someclientcloneclient currentthreadspawnrpcsystemmaperre printlnerror e Ok currentthreadblockonalldoneunwrap However when I run the server in a distributed environment with many incoming requests a low cpu usage was observed and the throughput is lower then tarpc Im assuming that the server only uses one thread so I tried to run the server in a tokioruntimeRuntime runtime which support multithreading But as RpcSystem doesnt support Send I got the following errors error E stdrcRcstdcellRefCellstdoptionOptionstdrcRccapnprpcrpcConnectionStatecapnprpcrpctwopartycapnpSide cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e stdrcRcstdcellRefCellstdoptionOptionstdrcRccapnprpcrpcConnectionStatecapnprpcrpctwopartycapnpSide cannot be sent between threads safely error E stdrcRcstdcellRefCellstdboxedBoxdyn capnprpctasksetTaskReaper capnpError static cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e stdrcRcstdcellRefCellstdboxedBoxdyn capnprpctasksetTaskReaper capnpError static cannot be sent between threads safely error E dyn capnprpcVatNetworkcapnprpcrpctwopartycapnpSide static cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e dyn capnprpcVatNetworkcapnprpcrpctwopartycapnpSide static cannot be sent between threads safely error E dyn capnpprivatecapabilityClientHook static cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e dyn capnpprivatecapabilityClientHook static cannot be sent between threads safely error E stdrcWeakstdcellRefCellfuturesunsyncmpscSharedcapnprpctasksetEnqueuedTask capnpError cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e stdrcWeakstdcellRefCellfuturesunsyncmpscSharedcapnprpctasksetEnqueuedTask capnpError cannot be sent between threads safely error E stdrcRcstdcellRefCellfuturesunsyncmpscSharedcapnprpctasksetEnqueuedTask capnpError cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e stdrcRcstdcellRefCellfuturesunsyncmpscSharedcapnprpctasksetEnqueuedTask capnpError cannot be sent between threads safely error E dyn futuresfutureFutureItem Error static cannot be sent between threads safely srcgraphimplrpcgraphserverrs runtimespawnrpcsystemmaperre printlnerror e dyn futuresfutureFutureItem Error static cannot be sent between threads safely error E dyn futuresfutureFutureItem Error capnpError static cannot be sent between threads safely runtimespawnrpcsystemmaperre printlnerror e dyn futuresfutureFutureItem Error capnpError static cannot be sent between threads safely Is there an efficient way to run the server to handle large amount of requests Hey there Ive been wanting to have capnprotorust available on nostd for awhile per and Ive given it a few shots in the past but I think now Im actually pretty close to nailing it I wanted to open up a PR to get some feedback on my approach and ask some questions about things Ive gotten hung up on Things Ive done Added a nostd feature flag to the capnp crate This feature is used in a few cfg conditional compilations around the codebase Included the coreio crate as an optional dependency to be included when the nostd feature flag is set This crate is mostly autogenerated in that it applies patches against stdio to take out all std usages and replace them using the alloc crate Replaced all references to std within the capnp crate to use core instead In capnps librs file there is a conditional import based on cfgfeature nostd If nostd is enabled then the name core references coreio items If nostd is not enabled then core references std items A similar strategy handles deciding between eg stdstring and allocstring and between stdstr and allocstr Problems Im having now It seems that everything in the capnp crate is now building properly both when nostd is enabled and disabled However when I add the capnpcCompilerCommandnewfileschemacapnprununwrap buildscript to a nostd project of mine theres an interesting compilation problem capnp needs to be compiled as nostd in order to comply with my nostd application but since that is the case the stdcompiled capnpc seems to now be linking against the nostdcompiled capnp whereas I think it should build a separate instance of capnp stdcompiled to link against The problem that this creates is that eg in capnpcsrclibrs let mut p commandspawn the spawn call returns a Result in which the error type is stdioError Typically when capnp is stdcompiled it would implement FromstdioError for capnpError However since it is linking against the nostdcompiled version of capnp the implementation that is actually implemented is FromcoreioError for capnpError It seems that I can get around this by simply mapping the error each time capnpc deals with an ioResult eg like this rust let mut p commandspawnmaperrerr capnpErrorfailederrtostring There are only perhaps five or so instances of this problem but I figured I should ask if anybody has any suggestions on a strategy to take I dont think it makes sense to force the nostd requirements to leak up into capnpc but I also dont necessarily want to destroy ergonomics by forcing the client to use maperr everywhere I think Ill probably work on adding a commit that does do that just in order to get a working solution together but any alternative suggestions are certainly welcome Edit I forgot to mention since the coreio crate is built by applying patches against certain builds of stdio youll need a fixed version of nightly rust to build it using the nostd feature You should be able to satisfy it using this override which corresponds to the last patch of the coreio crate rustup override set nightly So I have been working with Capn Proto in Rust for some time by now and although I quite happy with it I find myself writing a lot of boilerplate How viable would it be for we to create abstractions based on Rusts macro system thinking Serde Rokcet etc to make coding experience more fun Is this even the scope of any of the current crates I could help a bit on that After the other end of a unix domain socket or a pipe disconnects calls to readexact will return an UnexpectedEof error I believe that this should be treated as an ErrorKindDisconnect and not a generic ErrorKindFailure Im trying to use capnpfutures with tokio but there arent many examples around Im running into some difficulty when I try to schedule the future to write messages If I create a WriteQueue I cant use tokiospawn because WriteQueue has an RcRefCell in it