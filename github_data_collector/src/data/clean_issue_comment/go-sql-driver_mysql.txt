 Issue description When the query returns multiple result sets if the second query result is wrong it will not return when calling rowsnextresultset and the call will always be blocked Example code go queryMulti package main import databasesql fmt githubcomgosqldrivermysql func queryMulti err error sqlText select ds ds ifnullnull sex select ds ds isnullnull sex connectionString rootgametcp GMDBcharsetutf multiStatementstrue my err sqlOpenmysql connectionString if err nil fmtPrintfOpen v n err return err else fmtPrintfOpen Success v n tStatsv n connectionString myStats defer myClose rows err myQuerysqlText if err nil fmtPrintfQuery v n err return err defer rowsClose var id sex string var ds dsr for rowsNext if err rowsScan id sex err nil fmtPrintfScan Error v n err return err else fmtPrintfDS v Row v id v sex v n ds dsr id sex dsr for rowsNextResultSet blocked ds for rowsNext if err rowsScan id sex err nil fmtPrintfScan v n err return err else fmtPrintfDS v Row v id v sex v n ds dsr id sex dsr return nil func main if err queryMulti err nil fmtPrintfqueryMulti v n err Error log Configuration Driver version or git SHARelease v git ef dd d b acec e ada a Go version Server versionMySQL Server OS ubuntu fix fork Issue description In some cases it might be undesirable to fetch a potentially huge resultset at once MySQL provides cursors for that in the binary protocol prepared statements First a cursor flag has to be set in COMSTMTEXECUTE then the result chunks can be requested with the COMSTMTFETCH command Initially we will probably only support forwardonly and readonly cursors However the question remains trough what interface we make this feature available Issue description Implement a Travis CI job that checks if the driver compiles on all platforms supported by Go Example code See Description updates currently the following code will fails because of type miss match go func doSomething mysqlNullTime var nt sqlNullTime nt doSomething compile error It may prevent migrating from mysqlNullTime to sqlNullTime From Go Go supports type aliases It helps migrating Checklist Code compiles correctly Created tests which fail without the change if possible All tests passing Extended the README documentation if necessary Added myself the copyright holder to the AUTHORS file Description This is a counterproposal to You can create a custom Connector object using this new API go import databasesql databasesqldriver githubcomgosqldrivermysql type CustomConnector struct cfg mysqlConfig func cc CustomConnector Connectctx Context driverConn error cccfgHost getCurrentMySQLHost cfgUser cfgPassword getCurrentMySQLAuth return mysqlConnectctx cccfg func cc CustomConnector Driver driverDriver return nil Checklist Code compiles correctly Created tests which fail without the change if possible All tests passing Extended the README documentation if necessary Added myself the copyright holder to the AUTHORS file Issue description Connecting to a server when the server has blocked the client for too many failed connections returns commands out of sync Did you run multiple statements at once The mysql client returns a much more clearer and easier to repair message ERROR HY Host XXXX is blocked because of many connection errors unblock with mysqladmin flushhosts Is it possible to return better errors or even retrieve the message returned by the server I know this isnt a fix but changing the check in packetsgo to this go if data mcsequence data b if data mcsequence return nil ErrPktSyncMul return nil ErrPktSync mcsequence changes the output of my example to Initial Ping Error snil Final Ping Error Error Host is blocked because of many connection errors unblock with mysqladmin flushhosts which is far more readable Example code mysqlsh to start a mysql server under docker to make the test repeatable go package main import cryptotls cryptox databasesql ioioutil log mysql githubcomgosqldrivermysql func main rootCertPool x NewCertPool pem err ioutilReadFilesslcapem if err nil logFatalerr if ok rootCertPoolAppendCertsFromPEMpem ok logFatalFailed to append PEM if err mysqlRegisterTLSConfigcustom tlsConfigRootCAs rootCertPool err nil panicerr dsn localuserlocalpasstcpmysqllocaltestme localtesttlscustom func db sqlOpenmysql dsn defer dbClose err dbPing logPrintfInitial Ping Error s err dsn localuserlocalpasstcpmysql localtestme localtesttlscustom for i i i func dsn dsn db sqlOpenmysql dsn defer dbClose dbPing dsn localuserlocalpasstcpmysqllocaltestme localtesttlscustom func db sqlOpenmysql dsn defer dbClose err dbPing logPrintfFinal Ping Error s err Error log Initial Ping Error snil Final Ping Error commands out of sync Did you run multiple statements at once Configuration Go version go version go darwinamd Server version MariaDB mariabionic Server OS macOSdocker for repeating test Testing Repository koshatulgomysqlsyncissue There is no support for reading a mysql configuration file as specified in the DSN This is supported in other language bindings as readdefaultfile or mysqlreaddefaultfile See for various examples This is also supported as part of the C client library with its MYSQLREADDEFAULTFILE option This makes it possible to specify for example the user and password and host and port in a central place with tight file permissions instead of having to write these in places that are less desirable In our case we need to write the userpass in the telegrafconf file and restrict the permissions and duplicate the credentials that otherwise would be centralized in a single file Issue description the connection pooling to the database server seems to be broken since golang version or with the latest commit bb c running in version and up to git commit a everything seemed to work I have two servers running each GO applications that held two different connection pools to the same databaseserver one connection is heavily used DB with Requests per second and one is rarely used DB with Request per Minute server runs since round about minutes server runs since round about days broken means that a part of the connections is no longer used and seems to be stale MariaDB none SELECT FROM INFORMATIONSCHEMAPROCESSLIST where HOST like server ID USER HOST DB COMMAND TIME STATE INFO TIMEMS STAGE MAXSTAGE PROGRESS MEMORYUSED EXAMINEDROWS QUERYID dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL I am a little bit confused about those two conenctions at the end While on the other server go runs the old version and commit MariaDB none SELECT FROM INFORMATIONSCHEMAPROCESSLIST where HOST like server ID USER HOST DB COMMAND TIME STATE INFO TIMEMS STAGE MAXSTAGE PROGRESS MEMORYUSED EXAMINEDROWS QUERYID dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL dbuser server DB Sleep NULL The point why Ive been paying attention to this is that all of my connections from server got stale after about hours of running The Connections were not interrupted all connections were stale and new connections ive started another instance of the same application were able to create new connections to the database server Maybe you have an idea how to debug such a situation Example code all of the databases requests look like this while the initial connection is only initiated once and then the pool is used go DB Connection establish database connection var dsn appConfigurationdbuser appConfigurationdbpass tcp appConfigurationdbhostname appConfigurationdbport appConfigurationdbNamename dbName err sqlOpenmysql dsn dbNameSetConnMaxLifetime dbNameSetMaxIdleConns dbNameSetMaxOpenConns if there is an error opening the connection handle it if err nil panicerrError ctxVCspstoredprocedure contextBackground rowsResultsVCspstoredprocedure err dbNameQueryContextctxVCspstoredprocedure CALL storedprocedure version xxx xxx p sqlNullString sqlNullString appConfigurationidentifier if err nil logFatalerr defer rowsResultsVCspstoredprocedureClose for rowsResultsVCspstoredprocedureNext var spstoredprocedureVersion int var spstoredprocedureVar int var spstoredprocedureVar int if err rowsResultsVCspstoredprocedureScan spstoredprocedureVar spstoredprocedureVar spstoredprocedureVersion err nil logFatalerr if spstoredprocedureVersion SPstoredprocedureVERSIONREQUIREMENT printlntimeNowFormattimeRFC START SPstoredprocedure VERSION check ERROR Version does not meet requirements by this version Application requires strconvItoaSPstoredprocedureVERSIONREQUIREMENT but DB seems to be strconvItoaspstoredprocedureVersion osExit else printlntimeNowFormattimeRFC START SPstoredprocedure VERSION check PASSED if err rowsResultsVCspstoredprocedureErr err nil print error when something went wrong printlntimeNowFormattimeRFC START SPstoredprocedure VERSION check GENERAL DB RESULTS ERROR errError printlntimeNowFormattimeRFC START SPstoredprocedure VERSION check Stored Predure andor Table Structure missing EXIT osExit Configuration Server version MariaDB Server OS Debian buster latest updates applied Go Applications running in Docker Container Issue description It is possible to execute statements in a transaction which has been aborted via cancelled context and have those statements commit Basically in response to context cancellation the library calls TxRollback StmtExecContext ConnClose It should not be possible to execute a statement after the transaction has been rolled back and in fact because of mysqls autocommit default the statement will surprisingly commit See While it looks like a databasesql bug I wonder if theres something that can be done to mitigate on the driver side Example code go package main import context databasesql fmt log os time githubcomgosqldrivermysql func main if lenosArgs logFatalfusage s dbname osArgs dbName osArgs db err sqlOpenmysql rootdbName if err nil logFatalerr defer dbClose dbSetMaxOpenConns dbSetMaxIdleConns if err dbExecdrop table if exists t err nil logFatalerr if err dbExeccreate table t id int not null autoincrement primary key err nil logFatalerr ins err dbPrepareinsert into t id values null if err nil logFatalerr sel err dbPrepareselect count from t if err nil logFatalerr for i i i go func for i i runTxdb ins for range timeTicktimeSecond var n int r selQueryRow if err rScan n err nil fmtPrintlnselect err continue fmtPrintfd rows should be n n func runTxdb sqlDB stmt sqlStmt error ctx cancel contextWithCancelcontextBackground quit makechan struct done makechan struct tx err dbBeginTxctx nil if err nil fmtPrintlnbegin err return err defer txRollback stmt txStmtstmt go func timer timeNewTimertimeMicrosecond defer timerStop select case quit case timerC cancel closedone defer func closequit done for i i i if err stmtExec err nil return err txRollback return nil Error log rows should be rows should be rows should be rows should be Configuration Driver version or git SHA bb c fc fc f c adeac f d Go version run go version in your console go version go darwinamd Server version Eg MySQL MariaDB Server version Homebrew Server OS Eg Debian Jessie Windows uname a Darwin dadkinsmbpcorpdropboxcom Darwin Kernel Version Tue Aug PDT rootxnu RELEASEX x I also see the problem on Linux against mysql Description Added a ConfigFlag func It integrates with the standard flag package and reports an invalid DSN as an invalid flag value It can be used as follows go mysqlConfigFlagmysqldsn mysqlConfigDBName test User test Data source name Checklist x Code compiles correctly x Created tests which fail without the change if possible x All tests passing Extended the README documentation if necessary Added myself the copyright holder to the AUTHORS file 