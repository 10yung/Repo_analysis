 itamarhaber this is an idea following the discussion over the DSL in This PR consists of a small js script which parses commandsjson to produce a json file in a slightly different format Each command has the same rootlevel properties except for arguments which is now in the format typescript Array name string optional boolean schema JSONSchema This allows redis to avoid reinventing the wheel for any of the undifferentiated schemadescription parts of the documentation instead relying on jsonschema which is well established widely used unambiguous flexible enough to cover edgecases and a good balance of human and machinereadable Its worth taking a look at the generated jsonschema file since its large so github suppresses the diff Note Each argument is represented by JSONschema but conceptually the schemas are flattened when passed as CLI arguments For example DEL This has one argument key which is of type array meaning it would be valid for inputs like foo bar corresponding to redis del foo bar So to go from arguments valid per the schema to a CLI call clients would have to do something like redis command flattenargumentsjoin I also wrote a simple function that parses the md documentation for each command to extract the return type and convert to jsonschema so that type can be kept alongside the arguments Going forward this json file could become the source of truth for return types so that this repo could document not just basic return types like arrayreply but specify the type of the items in the array too easily and unambiguously with jsonschema eg type array items type string This will make client generation much easier because existing jsonschema tooling can be used rather than each client library having to write a custom parser which reverseengineers the custom DSL currently in commandsjson The library I maintain does exactly this reverseengineering and has a lot of hacks and pieces of difficulttomaintain code I have held off adding it to clientsjson so far because of this My thought was that if this accepted the generated commandsjsonschemajson acts as a starting point and would eventually take the place of commandsjson it would then be manually edited as the source of truth going forwards The js file shouldnt need to hang around its just for generating the starter jsonschema file This will allow taking advantage of jsonschemas API to go further with type specificity For example the problem highlighted in would go away because SET could become using yaml for conciseness yaml summary Set the string value of a key complexity O arguments name key schema type string name value schema type string name expiration optional true schema type array items type enum enum EX PX type integer name condition optional true schema type string enum NX XX since group string return anyOf type string type null Would be great to get your thoughts on this Id also be interested to learn what is currently using commandsjson in the existing format if you think the idea has legs I could see what it would take for whatevers downstream if anything to switch over to jsonschema PR fixed a valid issue namely allowing nonsensical usage of EX and PX together but the fix had a worse sideeffect IMO By setting the type of the expiration argument as type enum with enum values EX seconds PX milliseconds this suggests to clients that the set command can receive an optional argument with literal value EX seconds or PX seconds In a client library I maintain which generates types from commandsjson this produces incorrect types Heres a simplified diff typescript when updating the redisdoc submodule the client uses to latest master diff setkey string value string seconds EX number Promisestring null setkey string value string milliseconds PX number Promisestring null setkey string value string expiration EX seconds PX milliseconds Promisestring null If the library updated to latest master the new client would actually disallow correct usage This was formerly a valid call typescript clientsetafoo EX With latest master of redisdoc that above receives a compiler error and its impossible to use EX or PX without one It only allows clientsetafoo EX seconds A fix for this that didnt allow for set foo bar EX PX type usage would be to allow enum types within tuples something like json name expiry period type enum EX PX integer I would be happy to discuss adding something like that in a followup but itd be introducing a new concept and probably requires more careful thought in order to not create confusion or inconsistency With this PR Id like to just fix a bug which is that enum is being used incorrectly This moves the bitrelated commands from the string to a new category The motivation is giving more exposure for these lesser known capabilities antirez your thoughts Why The redisdocs are supposed to be designed for beginners learning about how to use redis However the incr docs can lead these new developers into implementing nonthreadsafe rate limiters in their modern web applications Here is an explanation of why the current code fails and how the new code improves in concurrency concurrencyexplanation What Made very minor changes to two of the three provided examples to support concurrent rate limiting Fixed minor grammarspelling mistakes throughout the section Elaborated on why the examples are written the way they are concurrency exceptional behavior outcomes etc and what the shortcomings of each example are I believe these changes are simpler easier to follow and more effective than the previous PRs opened to address this problem and Please consider my changes and let me know if anything I wrote needs elaboration Ref 