 Action Consider defining a bean of type javalangString in your configuration As you can see an error is reported if a property of type String is defined Is there any good solutionpleas Problem Given java Builder NoArgsConstructor AllArgsConstructor class Example int a BuilderDefault int x public Exampleint i thisa i The code compiles and if I were to invoke new Example then the value for x ends up being Because the default expression here is moved and only used by lombokgenerated code so the generated noargs constructor uses it as does the builder the common case the field is final Right now if the field is final then the above code example does not compile because the manually written constructor does not definitely assign x If a manually written constructor DOES definitely assign it I dont think we have a problem here So thats easy we need not change anything the uncommon case the field is not final For nonfinal fields with defaults we check if manually written constructors exist If they do we analyse the default value and check if it is either a literal or a field reference such as IntegerMAXVALUE If it is we make the initializing expression of the field an invocation to the defaultgenerating method because we know for sure this is side effect free so any doubleinvoke doesnt matter If it is not for example it is counter or LocalDatenow we generate a warning This warning cannot be removed which effectively means that you cant use lombok at all Lets hope the combination of manually written constructors nonconstant defaults are rare enough that it doesnt matter Even if the nonconstant default is constant after all For example LocalDateof is constant but lombok doesnt know that OPEN QUESTION Should we have a parameter on BuilderDefault to say yeahyeah just generate the invoke Im aware this means any attempt to construct this thing will neccessarily resolve the initializer expression once EVEN IF an explicit value is set I just want to use Delegate on two ListString fields It would allow to have convenient add methods instead of getXaddX java lombokData public static class Data Delegatetypes ElementAddersclass private ListString elements new ArrayListString Delegatetypes ItemAddersclass private ListString items new ArrayListString public interface ElementAdders extends ListString public interface ItemAdders extends ListString The code above produces multiple Duplicate method compiler errors Is there any way to do it with Lombok It seems not support java My compile failed with below message warning You arent using a compiler supported by lombok so lombok will not work and has been disabled Your processor is orggradleapiinternaltaskscompileprocessingIncrementalProcessingEnvironment Lombok supports sunapple javac ECJ warning You arent using a compiler supported by lombok so lombok will not work and has been disabled IDEA Mac OpenJDK Build Errorjava Compilation failed internal java compiler error Configuring IDEA still fails When I try to upgrade lombok from to version after The following code breaks public class OriginFilterForFrontend implements OriginFilter Delegate private final OriginFilterDefault defaultOriginFilter SneakyThrowsMalformedURLExceptionclass public OriginFilterForFrontendNonNull String frontendDomain defaultOriginFilter new OriginFilterDefaultListsnewArrayListnew URL frontendDomain new URL frontendDomain ListsnewArrayList localhost public interface OriginFilter public default boolean isOriginAllowedNonNull String originHeaderField try URL originURL new URLoriginHeaderField return isOriginAllowedoriginURL catch MalformedURLException e return false public boolean isOriginAllowedURL origin EqualsAndHashCode public static class Default implements OriginFilter NonNull private final ListString allowedOrigins NonNull private final ListString allowedOriginHosts Override public boolean isOriginAllowedNonNull URL origin return allowedOriginscontainsorigintoExternalForm allowedOriginHostscontainsorigingetHost public DefaultNonNull ListURL allowedOrigins NonNull ListString allowedOriginHosts thisallowedOrigins allowedOriginsstreammapURLtoExternalFormcollectCollectorstoList thisallowedOriginHosts allowedOriginHosts The code should pass but it throws an error OriginFilterForFrontendjava method isOriginAllowedjavanetURL is already defined in class OriginFilterForFrontend I hope this is not a duplicate but I could not find anything similar It would be great if Lombok could be used to generate different versions of a method with and without optional parameters For this a new annotation optionaldefault could be introduced that can be added to parameters of methods or constructors For example consider the lomboked method public void doSomethingString a optional int b optionalfalse boolean c method body The default value itself could be optional too resulting in defaults like false or null depending on the type of the parameter This would result in different versions of the method in general number of optional versions public void doSomethingString a doSomethinga false public void doSomethingString a int b doSomethinga b false public void doSomethingString a boolean c doSomethinga b public void doSomethingString a int b boolean c method body Whereas the following would result in an error and thus would not be allowed as there are two optional parameters of the same type without a nonoptional parameter in between so the different methods would have the same signature public void doesNotWorkA a optional int b optional int c Optionally optional parameters could also be paired or grouped Eg in the following example there would only be two versions of the method One with all parameters and one with only the required parameters but none with the individual optional parameters This would also allow for multiple optional parameters of the same type in a row public void doSomethingString a optional group int b optionalfalse group boolean c method body Often Java code contains many versions of the same methods or constructors with different parameters some of which are optional Usually there is one full version of the method that gets called by all the others with appropriate default values With the optionaldefaultValue annotation this would not be needed any more Describe the feature We have to provide a no arg constructor and the full constructor needed by Builder if I want to have a no arg constructor and a builder for my class Builder NoArgsConstructor I need also a no arg constructor AllArgsConstructor redundant information because lombok knows I want a Builder public class User But why do I have to explicitly add AllArgsConstructor Lombok should automatically add the appropriate constructor if I annotate the class with Builder even if I also add NoArgsConstructor Please allow this in lombok Builder NoArgsConstructor public class User When Javac tried to parse attr the JCLambda node in the LazyGetter Method Body generated by Getterlazy true it crashed because the cache type at that location did not match what was expected And in addition to crashing it can cause type inference to fail JDK OpenJDK Lombok UTC Reproduced by the following code java import lombokGetter public class TestLombokBugLazyGetter public static String bar return Getterlazy true private final Object field foobar null public static Object foofinal Object arg final Object arg final Runnable arg return null stacktrace An exception has occurred in the compiler Please file a bug against the Java compiler via the Java bug reporting page after checking the Bug Database for duplicates Include your program the following diagnostic and the parameters passed to the Java compiler in your report Thank you javalangClassCastException class comsuntoolsjavactreeJCTreeJCLambda cannot be cast to class comsuntoolsjavactreeJCTreeJCMethodInvocation comsuntoolsjavactreeJCTreeJCLambda and comsuntoolsjavactreeJCTreeJCMethodInvocation are in module jdkcompiler of loader app at jdkcompilercomsuntoolsjavaccompArgumentAttrResolvedMethodTypedupArgumentAttrjava at jdkcompilercomsuntoolsjavaccompArgumentAttrprocessArgArgumentAttrjava at jdkcompilercomsuntoolsjavaccompArgumentAttrvisitLambdaArgumentAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCLambdaacceptJCTreejava at jdkcompilercomsuntoolsjavaccompArgumentAttrattribArgArgumentAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribArgsAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitApplyAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCMethodInvocationacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribExprAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitVarDefAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCVariableDeclacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatsAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitBlockAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCBlockacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitIfAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCIfacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatsAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitBlockAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCBlockacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitSynchronizedAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCSynchronizedacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatsAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitBlockAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCBlockacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitIfAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCIfacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatsAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitBlockAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCBlockacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrvisitMethodDefAttrjava at jdkcompilercomsuntoolsjavactreeJCTreeJCMethodDeclacceptJCTreejava at jdkcompilercomsuntoolsjavaccompAttrattribTreeAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribStatAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribClassBodyAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribClassAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribClassAttrjava at jdkcompilercomsuntoolsjavaccompAttrattribAttrjava at jdkcompilercomsuntoolsjavacmainJavaCompilerattributeJavaCompilerjava at jdkcompilercomsuntoolsjavacmainJavaCompilercompileJavaCompilerjava at jdkcompilercomsuntoolsjavacmainMaincompileMainjava at jdkcompilercomsuntoolsjavacmainMaincompileMainjava at jdkcompilercomsuntoolsjavacMaincompileMainjava at jdkcompilercomsuntoolsjavacMainmainMainjava Cause of error This should not be done here comsuntoolsjavaccompArgumentAttrjava java Process a method argument this method allows the caller to specify a custom speculative attribution logic this is used eg for lambdas SuppressWarningsunchecked T extends JCExpression Z extends ArgumentTypeT void processArgT that SupplierZ argumentTypeFactory UniquePos pos new UniquePosthat in UniquePos init thispos thatpos Z cached ZargumentTypeCachegetpos got comsuntoolsjavaccompArgumentAttrResolvedMethodType extends ResolvedMemberTypeJCMethodInvocation T extends JCExpression T JCMethodInvocation but in arg T that T JCLambda if cached null dup existing speculative type setResultthat cacheddupthat env ArgumentTypeJCMethodInvocation dupJCMethodInvocation tree EnvAttrContext env JCMethodInvocation tree javalangClassCastException class JCTreeJCLambda cannot be cast to class JCTreeJCMethodInvocation else Z res argumentTypeFactoryget argumentTypeCacheputpos res setResultthat res Maybe we should discuss this issue or I send a PR to fix it At the moment version of Slf j is used in lombok In Jun Slf j team released a It adds ability to use supplier as an argument to log API is not so pretty but does it job loggeratDebugaddArgument heavyMethod logmsg Temperature set to Old temperature was oldT 