Running cargo test from root directory results in the following error details summaryoutputsummary warning profiles for the non root package will be ignored specify profiles at the workspace root package homecgmdevelrustenigmaenigmaCargotoml workspace homecgmdevelrustenigmaCargotoml Compiling quickcheck v Compiling instructioncodegen v homecgmdevelrustenigmainstructioncodegen error E failed to resolve use of undeclared type or module trybuild instructioncodegentestsprogressrs let t trybuildTestCasesnew use of undeclared type or module trybuild error aborting due to previous error For more information about this error try rustc explain E error could not compile instructioncodegen warning build failed waiting for other jobs to finish error E unresolved import instruction instructioncodegentests parseheaderrs use instructionins use of undeclared type or module instruction error cannot determine resolution for the macro ins instructioncodegentests parseheaderrs ins note import resolution is stuck try simplifying macro imports error aborting due to previous errors For more information about this error try rustc explain E error could not compile instructioncodegen warning build failed waiting for other jobs to finish error build failed details Seems a similar problem to When I run git submodule update init depth I get the following error Submodule otp registered for path otp Cloning into homecgmdevelrustenigmaotp remote Total delta reused delta packreused error Server does not allow request for unadvertised object c d d ad d f c f fd Fetched in submodule path otp but it did not contain c d d ad d f c f fd Direct fetching of that commit failed Found numbigint provides these conversions already Currently added for integertobinary it seems also relatively easy to support binarytointeger and probably some other cases where converting fromto integer It seems the test on my local doesnt run at all is this expected at the moment Should I add a test anyway Its time to get all these out of the way xtolist X erlangatomtolist X erlangbinarytolist erlangbinarytolist erlangfloattolist erlangfloattolist X erlangintegertolist erlangintegertolist X erlangpidtolist X erlangtupletolist X erlangreftolist erlangporttolist X erlangfuntolist erlangbitstringtolist listtox X erlanglisttoatom X erlanglisttobinary x erlanglisttofloat X erlanglisttointeger erlanglisttopid erlanglisttoport erlanglisttoref X erlanglisttotuple x stringlisttointeger erlanglisttointeger stringlisttofloat erlanglisttoexistingatom erlanglisttobitstring binarytox erlangbinarytofloat X erlangbinarytoterm x erlangbinarytoatom erlangbinarytoexistingatom x erlangbinarytointeger erlangbinarytointeger xtobinary x erlangatomtobinary erlangfloattobinary erlangfloattobinary x erlangintegertobinary erlangintegertobinary x erlangtermtobinary x erlangtermtobinary Special x unicodecharacterstobinary X unicodecharacterstolist X erlangiolisttobinary x erlangiolisttoiovec I think we can trim the testing code with a macro for calling the bif function During my development the following codes were repeatedly entered rust let vm vmMachinenew let module const moduleModule stdptrnull let process processallocate vmstate modulewrap let args vec xxxxxxx let res bifthefunctionIwanttotest vm process args Most of the codes are not used for testing The code duplication is so high that I think it can be replaced by a macro as a high order function like the following one rust macrorules testitfunc func arg expr The code as the above I can do this in Elixir but not sure if it is valid in Rust Does it sound a valid solution to you archseer If it is okay I will do it and refactor the unit tests Some of the unit tests are not implemented yet Required someone to fill them up Math functions List functions Chrono functions Here are the incomplete unit tests without testing the exception case erlang functions x Binary matching opcodes Binary building opcodes NIFs We need to place stubs in the exports registry for modules that arent loaded yet but referenced elsewhere These should call the error handler which in the erlang stdlib will try to load the module or error Search for references to errorhandler inside beamemuc and enigma for a quickstart Update the module registry to store RcModule ArcModule instead of BoxModule and update all const Module to be RcModule Loading the same module into the VM should swap it in the registry meaning all new module registry lookups will return the new module Meanwhile references to the old Module will still work until they all die at which point the module will be dropped Probably either immix or orca Each process gets its own heap consisting of blocks that we independently GC At the moment we just use blocks as a sort of an arena GC they belong to a process and get deallocated when a process drops though no destructors are called and we need to ensure the process unregisters in the process registry Immix Orca Golang GC 