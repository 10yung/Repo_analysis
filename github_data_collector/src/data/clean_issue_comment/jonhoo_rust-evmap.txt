Any plans on making async version of refresh I was implementing my own LRU cache on top of evmap and was having problems decided to reimplement the test with just evmap and I think I may have found a bug where this test usually fails with the len being Occasionally it passes rust test fn evmultithreaded let readhandle mut writehandle evmapnew let readera readhandleclone let readerb readhandleclone let readerc readhandleclone let barrier ArcnewBarriernew let ba barrierclone let bb barrierclone let bc barrierclone The writeside thread the one that does inserts stdthreadspawnmove for i in writehandleinserti itostring writehandlerefresh dbgA bawait Two read sides stdthreadspawnmove while let None readeragetand v v clone while let None readeragetand v v clone dbgB bbwait stdthreadspawnmove while let None readerbgetand v v clone while let None readerbgetand v v clone dbgC bcwait barrierwait dbgDone asserteqreaderclen Am I misusing something here I might be doing dumb things with Barrier From what I can tell this should pass consistently You can even put a long sleep in before the call to len and itll still fail Thanks for your work on this library Hopefully this helps and isnt a fluke This definitely relates to So all that understood Im wondering it theres a particular trick for this usecase that might stay efficient namely I want my value setsvecs to always be N or fewer elements a sort of LRU cache Intuitively it seems this could be implemented in terms of retain and keeping a tiny bit of extra metadata on each item Alternatively I had started implementing this with a getand copy and then update with the new values Only to realize update doesnt swap out the entire value set but rather replaces the new set with a onevalue set Adding a replace method that allows you to provide an entire setvec as the second param would be desirable I think the update method is a bit unintutive in that respect Really like the library Thanks for your work Write some test cases even simple ones are welcome to help increase code coverage Thanks for this great crate Is there a way to work with values inside an evmap mutably I am storing larger records inside an evmap and would like the ability to update them without making copies Something like getand but with a FnMut The desire is for something akin to the Entry API that allows fetching and updating a value with a single operation As I understand it this is a bit more complex since this is a multivalued map and every operation must be encoded as well an Operation But perhaps it could be done by index for instance rust let result Option rhgetandupdate key idx elem elem where similarly to getand None is returned if the key or index didnt lead to an element If Im understanding Operation correctly perhaps this could be encoded as UpdateK Index NewV or simply as a Remove followed by an Add If this sounds at all like a reasonable or possible thing to add I would be happy to try and help with implementation Thanks again Guys is it possible to sort values vector without replacing whole array I mean just make vectorsort or like that to save new values order subj Hi Not an issue but what is the best way to save the content of evmap into a file and load it back at runtime IO BufReader reading line by line with a split Thanks again carllerche recently published loom which does correctness checking for concurrent algorithms Itd be neat to try to get that working for evmaps tests Branching off of Im not sure what the best way to do this is so this issue is inviting ideas A simple start would be a trait such as rust pub trait BackendK V ExtendK V where K Hash Eq V Eq ShallowCopy fn applyfirst mut self ops fn applysecond mut self ops unsafe fn clearnodrop mut self implK V S BackendK V for hashbrownHashMapK V S where K Hash Eq V Eq ShallowCopy S BuildHasher also for stdcollectionsHashMap also for rahashmapHashMap etc Perhaps the S hash builder parameter could be replaced with the above so that rust pub struct WriteHandleK V M S RandomState where K Eq Hash Clone S BuildHasher Clone V Eq ShallowCopy M static Clone becomes rust pub struct WriteHandleK V M B hashbrownHashMapK V RandomState where K Eq Hash Clone V Eq ShallowCopy M static Clone B BackendK V This would allow us to leverage the particular features and algorithms for different libraries If necessary two traits could be used to hide the real implementation rust mod internal pub trait RealTrait fn realoperationwedontwantseen pub trait PublicTrait internalRealTrait implT PublicTrait for T where T internalRealTrait pub struct StructureB where B PublicTrait 