This code works fine on Ubuntu Note that the segfault comes before main I am using cranelift craneliftobject craneliftmodule function u i systemv gv symbol colocated u sig i i systemv fn u sig ebb v globalvaluei gv v loadi v v call fn v v iconsti return v targetdebugrcc int putsconst char s static const char indexpage indexhtml int main putsindexpage aout Segmentation fault gdb gdb break main Breakpoint at x a gdb run Starting program homejoshuasrcrccaout Program received signal SIGSEGV Segmentation fault x ffff fc c in from libldmuslx so gdb where x ffff fc c in from libldmuslx so x in targetdebugrcc c o ao this means compile to object file but dont link int putsconst char s static const char indexpage indexhtml int main putsindexpage objdump rd ao ao file format elf x Disassembly of section text main rex push rbp e mov rsprbp d lea x riprax c main xc RX PC indexpage x c b mov raxrax f c mov raxrdi e callq main x RX PLT puts x b rex mov x eax d d rex pop rbp f c retq cc philipc Now that finalizedefinitions is called by default when finalizing a module since calling it in an application using Cranelift is likely either an unintentional second call to finalizedefinitions or an outright error If the lifecycle of finalization is entirely internal to Module as it seems it ought to be we ought to make this nonpublic and avoid some misuse I happened to trip across this when revisiting some code written before this change was made where this might have more clearly signalled what changed in the mean time x This has been discussed in meetings and chat messages x A short description of what this does why it is needed this implements a rudimentary interpreter for Cranelift IR only a subset of instructions are currently implemented and implementation gaps are marked with TODO or FIXME This PR is a RFC on the interpreter design any feedback is welcome x This PR contains test cases if meaningful x A reviewer from the core maintainer team has been assigned for this PR What is the feature or code improvement you would like to do in Cranelift I would like to implement the SIMD loadextend instructions What is the value of adding this in Cranelift This is necessary for Wasm SIMD spec compliance Do you have an implementation plan andor ideas for data structures or algorithms to use I see that currently sharedinstructionsrs includes instructions such as uload and sload one option is to add the additional instructions us load x us load x and us load x Alternately bnjbvr and I had discussed using the IRIR infrastructure of legalization to implement peephole optimizations if this was in place and at the right level I could translate the Wasm load x s eg to Cranelifts loadi x and uextend and then write a peephole optimization to generate the appropriate x PMOVSXBW to encode both of these instructions perhaps with a new Cranelift x pmovsxb instruction Which approach is better What is the feature or code improvement you would like to do in Cranelift In I added a temporary lowering for Wasms loadsplat to two Cranelift instructions load splat This generates extra instructions that could be removed by a specialized Cranelift loadsplat instruction or by smarter codegen eg complex addressing on splat What is the value of adding this in Cranelift Fewer instructions produced Do you have an implementation plan andor ideas for data structures or algorithms to use Seeking feedback on which way to proceed specialized loadsplat or smarter codegen Have you considered alternative implementations If so how are they better or worse than your proposal See above Ifwhen Cranelift gains a loadsplat instruction the load splat could be replaced with a single Cranelift loadsplat This change allows the simdloadsplatwast spec test to pass x This has been discussed in issue x A short description of what this does why it is needed see above x This PR contains test cases if meaningful see SIMD spec tests run in wasmtime x A reviewer from the core maintainer team has been assigned for this PR x This has not been discussed in an issue x A short description of what this does why it is needed I did not implement the i x shifts previously because there was discussion about whether they should be included in the spec I still feel they should not be included due to the large overhead they impose on x but I am rather unwillingly implementing them here so we can get additional performance measurements This PR contains test cases if meaningful x A reviewer from the core maintainer team has been assigned for this PR This issue will track progress on our new instruction selector machinecode emission work which has been ongoing in design and initial implementation The scope of the work is Build a new instruction selector to replace the recipes and metaDSL system that adds encodings to existing Cranelift IR instructions Develop a lowlevel encoding of machine instructions with virtual registers prior to register allocation an IR of sorts Interface the above to a new register allocator infrastructure minira Develop the binaryencoding pass that emits into a CodeSink from the above representation As discussed among sunfishcode julianseward bnjbvr and others we want to do this work in order to clean up the story for a new machine backend as recipes had become difficult to write and maintain The system will be codeveloped with an initial backend for ARM using the new interfaces This has been discussed in issue or if not please tell us why here This is a really small change A short description of what this does why it is needed if the description becomes long the matter should probably be discussed in an issue first This fixes small bug caused by inaccurate use of parentheses in narrowicmpimm This PR contains test cases if meaningful No tests A reviewer from the core maintainer team has been assigned for this PR If you dont know who could review this please indicate so andor ping bnjbvr The list of suggested reviewers on the right can help you bnjbvr Please ensure all communication adheres to the code of conduct 