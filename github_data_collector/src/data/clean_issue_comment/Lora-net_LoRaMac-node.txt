In srcradiosx xradioc the function RadioRandom is documented to disable all interrupts It does not do that however I compared the implementation with the one from the SX which does seem to disable the radio interrupts before entering reception mode The reason I am asking is that I observed very stange behaviour in my application while debugging an application layer bug that caused repeated join attempts even after a successful join During a Join RadioRandom is used to create a nonce for the join attempt For some reason attempting to join after having already joined causes a strange chain of events The radio is put in reception mode without timeout for random number generation Then a radio interrupt is generated and the IRQ status is read The status is read and it is IRQRXTXTIMEOUT it is not clear why as the radio should have been started without timeout Since the radio is in rxmode the callback for rx timeout is called Now the LoRaWAN stack is not equipped to handle an RX timeout in this state when the RXWindow is None as no RX window was opened yet By default the stack assumes that RX window timed out This RX timeout immediately terminates the join attempt on the next call to LoRaMACProcess and makes it fail with RX timeout I do not understand how a radio interrupt with the timeout flags set is even generated at this moment but the effect is certainly not proper operation The inconsistency with the documentation is making this even more suspicious There seems to be some kind of race condition involved as adding a large number of debug prints over the serial wire viewer seemed to change the behaviour I tried to add the following command to the start of the RadioRandom function SX xSetDioIrqParams IRQRADIONONE IRQRADIONONE IRQRADIONONE IRQRADIONONE Initial experiments suggest that this may fix the problem but without understanding the root cause I cannot be confident about that However I have a few questions Why is a timeout interrupt generated when the radio is put in reception without timeout Why is the radio put in single reception mode in the random function What if some packet is received probably not even intended for the device Wouldnt the reception stop at that point making the RSSI values useless for random number generation Shouldnt the radio be put in Rx Continuous mode for generating random data This might even be a security risk if all an attacker has to do to compromise the random number generator is sending a LoRa packet at the right time The SX also has its own random number register and reading that is implemented in the driver Why is it not used for the RadioRandom function I wanted to update stack to a newer version but multicast channel setup is now changed New procedure needs an encrypted multicast key but its unclear how to generate this key on both stack and lorawan specification Explanation about McKEKey on specification Derived from a new root key GenAppKey provisioned in the enddevice at any time before the deployment of the enddevice in the field LoRaWAN x enddevices SHALL use this scheme McRootKey aes encryptGenAppKey x pad McKEKey aes encryptMcRootKey x pad We are using stack and network server configured for a private v network Is there any way to bypass this key use one of the other multicast keys instead If not can someone further explain how to generate this key Thanks Hi all recentlya problem about Lorawan node retransmission confused me Ive found many issues about it in github and repeated to find some information in Lorawan protocol some useful issue about retransmission and their responding records Ive referred as following uplink failreup Yeah The server ignores retransmitted frames so if the FCnt is the same it does not sent anything to backend Try setting the FCnt check in your device profile to Disabled I tried it in Lora Server but not OK Confirmed retransmission not acknowledged This is by design The networkserver will only confirm an uplink once Retransmissions with the same framecounter are ignored as else this would allow for replay attacks The networkserver cant know if this is a replay attack or retransmission I think in LoRaWAN this is fixed by hashing the uplink channel index so that the networkserver can detect that the framecounter did not increment but that the MIC is unique given that the retransmission was done using a different channel LoRaWAN has better mechanisms to deal with this as I already have pointed out in previous comments adding the channel DR into account when generating the MIC so that the networkserver can distinguish a retransmission from a replayattack LoraWAN protocol Uplink Timing Diagram for Confirmed Data Messages If an enddevice does not receive a frame with the ACK bit set in one of the two receive windows immediately following the uplink transmission it may resend the same frame with the same payload and frame counter again at least ACKTIMEOUT seconds after the second reception window This resend must be done on another channel and must obey the duty cycle limitation as any other normal transmission If this time the enddevice receives the ACK downlink during its first receive window as soon as the ACK frame is demodulated the enddevice is free to transmit a new frame on a new channel does the newest OpenSource LoraWAN Server completely solved the question above anybody have some useful suggestion or good idea to solve node retransmission Environment Endnode opensource LoraMACnode and LoraMACnode Gateway newest Loragateway packetforwarder LoraWANServer newest Lora Server If the request which we wanted is bufferEnd as element is set to bufferStart when we do the judgement of while element bufferEnd the code will execute else until element is equal with bufferEnd When element is equal with bufferEnd actually we have found the request but then do the judgement of while element bufferEnd will fail then return NULL The issue is that there is no condition to judge request is equal with element when request is bufferEnd I think we should add code like if element bufferEnd after executing while If you wanted to force a rejoin from an asynchronous event eg on button press or timer what is the correct way to force a rejoin in the main loop class A mainc from examples One scenario where we need this is to recover from a gateway being down for a long time Hi all I want to use STM device unique ID combination as DeviceEUI and DeviceAddress I have a function to get the words of unique ID and create one vector of bytes for DeviceEUI and one bit variable for DeviceAddress So I run this function at beginning of the program after basics initialization but I dont know how to properly change those parameters Till now Ive been just manually input values in Commissioningh file Does anyone knows best way to do it Thanks a lot Hi this issue was created upon djaeckle request in issue If Rx error occurs during reception of packet in RX the stack stucks in LORAMACTXRUNNING state I actually faced the same problem that Stack stucks in LORAMACTXRUNNINGand function LoRaMacIsBusy will always return busy and cant send data anymore I fix the problem with the code in issue but only in USB charging mode If i switch to battery mode the problem happened againIt seemed that the problem havent solved in low power mode In usb charging mode bool UsbIsConnected truei test it for days no problem In battery modebool UsbIsConnected falsethe problem appears easily especially when cutting off internet access of gateway after node OTAA joined My hardware playform is NucleoL with SX Hello everyone I am going to implement the LoRaMacNode on my project My board combinate the STM L NucleoSX MB DAS and an ADC which ADC is for datasampling and SX will send the data to the PC Now LoRaMac works for my board so I want to add my AD code to the project But when I initialized the SPI in boardc using SpiInit SPI SPI AD MOSI AD MISO AD SCLK AD NSS There is an error show boardc error expression must be an lvalue or a function designator SpiInit PI SPI AD MOSI AD MISO AD SCLK AD NSS The SPI is defined as define SPI SPITypeDef SPI BASE in stm l xxh So whats wrong with me Any help will be appreciated Hi Im trying to get the fuotatest example to work Steps i followed Created a device on the loraserver OTAA Waited for the device to Join via OTAA After joining created a firmware update job using create frimware update job button After this i dont see McGroupSetupReq Ans happening after sometime i get a error message saying The device failed to provision the remote multicast setup attached image Project fuotatest Board BL ZLRWAN Gateway nfuse Mhz IN region Server loraserver I Hi The UART RX is not working only the st char is received Suspect this is because of the way the UART interrupt is being handled The repeated call to HALUARTReceiveIT inside HALUARTRxCpltCallback is doomed to fail because of the way the ST UART HAL code works There are various entries about this on ST forums and Stackoverflow too Can this be reworked to implement a workaround for those shortcomings Or maybe switching to DMA