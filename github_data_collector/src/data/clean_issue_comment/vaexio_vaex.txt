The data in many domains such as scRNA is sparse I would like to summarize each grid element by the mode and the purity fraction of top category in bin My code fails when trying to open a single hdf file into a dataframe df vaexopendatachathistory hdf Heres the rest of the code import re import glob import vaex import numpy as np def tryints try return ints except return s def alphanumkeys Turn a string into a list of string and number chunks z a z a return tryintc for c in resplit s hdf list globglobdatahdf hdf listsortkeyalphanumkey hdf list nparrayhdf list assert lenhdf list Incorrect number of files Check how the single file looks like df vaexopendatachathistory hdf df Heres the whole traceback ERRORMainThreadvaexerror opening datachathistory hdf ValueError Traceback most recent call last in Check how the single file looks like df vaexopendatachathistory hdf df usrlocalanaconda libpython sitepackagesvaexinitpy in openpath convert shuffle copyindex args kwargs ds fromcsvpath copyindexcopyindex kwargs else ds vaexfileopenpath args kwargs if convert and ds dsexporthdf filenamehdf shuffleshuffle usrlocalanaconda libpython sitepackagesvaexfileinitpy in openpath args kwargs break if datasetclass dataset datasetclasspath args kwargs return dataset usrlocalanaconda libpython sitepackagesvaexhdf datasetpy in initself filename write selfh tablerootname None selfversion selfload def writemetaself usrlocalanaconda libpython sitepackagesvaexhdf datasetpy in loadself def loadself if data in selfh file selfloadcolumnsselfh file data selfh tablerootname data if table in selfh file usrlocalanaconda libpython sitepackagesvaexhdf datasetpy in loadcolumnsself h data first selfaddcolumncolumnname selfmaphdf arraydata column mask else selfaddcolumncolumnname selfmaphdf arraydata else transposed shape shape usrlocalanaconda libpython sitepackagesvaexdataframepy in addcolumnself name forarray dtype if lenself lenar raise ValueErrorArray is of length s while the length of the DataFrame is s due to the filtering the unfiltered length is s lenar lenself selflengthunfiltered raise ValueErrorarray is of length s while the length of the DataFrame is s lenar selflengthoriginal assert selflengthunfiltered lendata columns should be of equal length length should be d while it is d selflengthunfiltered lendata validname vaexutilsfindvalidnamename ValueError array is of length while the length of the DataFrame is Any guidance is appreciated Inspired by maartenbreddels this PR adds features property to the vaex Transformers which is list of output feature names The main idea is to simplify the feature combining process during ML pipeline prototyping x Implement a features property to the base Transformer class x Implement a general function and private function getoutputfeatures for populating the features list x Implement custom getoutputfeatures the PCA and OneHotEncoder Transformers since their functionality is different compared to the majority x Update tests so that they test the new element check test for pca Update the Changelog Review Discuss and agree on implementation details issues and changes see text below This change brings some level of awkwardness in the implementation of some of the transformers Currently getoutputfeatures method is called during the fit method of each transformer One idea is to introduce a fit method in the base Transformer class where getoutputfeatures will be called prior to calling a fit method Thus we should rename the fit method of each transformer to fit This will help to reduce code duplication I am not sure how such a change would impact readability and maintainability of the code This is similar to what scikitlearn does but is this the right path for us maartenbreddels Also if we do this the docstrings of all fit methods will be identical maybe we can get away with this unless we redefine fit which is defeating the point of this strategy I am fine leaving things as they are but i thought to mention this just in case PCA our implementation of getoutputfeatures is tricky here since we are not overwriting output columns but just shifting the component identifier see transform method of PCA So do we want the PCA implementation to change in a way that if columns of those names already exist an exception should be raised How often is one expected to recalculate the PCA on the same features without any other changes xdssio Right now the features lists the naive output ie the features that should be there without overwriting during transform time There is some duplicationredundancy when determining the feature names During fit right now we get the list of output features features Then during transform we still determine the output feature names just before calculating the expressions in more or less the same way Do we need to spend time in reducing this redundancy or somehow refactoring the way was not obvious to me Maybe keeping things as they are is fine for now it looked a bit weird to me so I thought to bring it up maartenbreddels I dont plan to actively remove python code but we should not test for it anymore Maybe we should merge this for vaex very appropriate This POC solves several issues ALL operations can be recorded in the dfoperation members opening joining groupby etc a dataframe can be serialized better since it knows completely how it was constructed The state is still useful but how they work together is something I need to think about Example operations serialized to json type transformation name addvirtualcolumn parameters name r expression r y columnposition child type transformation name renamecolumn parameters old r new r child type transformation name addvirtualcolumn parameters name r expression x y columnposition child type source name open parameters path Usersmaartenbreddelssrcvaexdatahelmidezeeuw phdf Which reflects this code python df vaexopenpath executeFalse df r dfx dfy df r dfr dfy Hi Is it currently even possible to evaluate a list comparison on a column of data frame I am looking for something like dfselectcol in I am getting the following error on calling the evaluate function ValueError The truth value of an array with more than one element is ambiguous Use aany or aall Thanks This handles the nonstandard behaviour explained in the behaviour of vaex when on attempts to do the nonpermitted addition between a string and a numeric column x Test for illegal addition between string and numeric type Fix I just made the stupid mistake of writing a frame of virtual columns to a hdf file This results in a file that cant be opened vaexopen throws a TypeError NoneType object cannot be interpreted as an integer Since the original error is a bit obscure to debug from that would it be a good idea for exporthdf to throw a warningerror when a dataframe of only virtual columns is being exported with parameter virtualFalse Ive used conda to install python jupyterlab vaex on a Windows machine I have the following code in a cell From Interactivewidgets import vaex import vaexjupyter import numpy as np import pylab as plt matplotlib inline df vaexexample dfselectdfx vaexjupyterinteractiveselectiondf def plotx y printMean x for the selection is dfmeandfx selectionTrue dfplotdfx dfy whatnplogvaexstatcount selection None True pltshow And when I run the cell the output is Mean x and a warning plus the plot Mean x for the selection is C Users wink Anaconda envs vispy lib sitepackages vaex imagepy FutureWarning Using a nontuple sequence for multidimensional indexing is deprecated use arr tupleseq instead of arr seq In the future this will be interpreted as an array index arr nparrayseq which will result either in an error or a different result rgbadest c mask npclipresult mask As suggested by the message if I change the problem line of code above to use tuple mask there is no warning rgbadest c tuple mask npclipresult tuple mask I may have something installed incorrectly and this solution could be totally wrong Let me know if any other information is needed