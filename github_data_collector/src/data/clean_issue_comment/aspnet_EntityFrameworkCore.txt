Similar to PR we can enable more decimal operations by leveraging UDFs Unlike TimeSpan however there isnt an acceptable type we can convert to to perform the operations so it will require roughly one UDF per operation For example NET SQL m m addm m m m dividem m m m comparem m m m comparem m m m comparem m M m comparem m m m remainderm m m m multiplym m m m addm negatem m negatem Averaget tDecimal mavgtDecimal Maxt tDecimal mmaxtDecimal Mint tDecimal mmintDecimal Sumt tDecimal msumtDecimal I read ajcvickers blog post So I thought I would check my code NB In my base repository class for update I have this public virtual void UpdateT entity dbContextEntryentityState EntityStateModified entityIdString entityGetIdToString dbContextAddCreateAuditEntityU entity dbContextSaveChanges Step I retrieve an entity from the dbContext using this query public RvImport GetOldestPendingRvImport const int pendingStatus intRvImportStatusEnumsPending return dbContextRvImports Wherex xRvImportStatusId pendingStatus OrderByx xId Take FirstOrDefault Step I update properties on the entity rvImportRvImportStatusId intRvImportStatusEnumsProcessing rvImportImportStartDateTime DateTimeUtcNow rvImportModifiedBy WebJob typeofFunctionsAssemblyGetNameVersion Step Call Update on the base repository passing in the modified entity Step I profile the SQL to find that its updating ALL columns regardless of whether they have changed or not See full SQL update below exec spexecutesql N SET NOCOUNT ON UPDATE RvImports SET Body p ConcurrencyStamp p ImportEndDateTime p ImportFileTypeId p ImportFilename p ImportStartDateTime p ProjectId p RecordCount p RequestedImportFileTypeId p RvImportStatusId p UserId p WHERE Id p SELECT ROWCOUNT N p int p nvarchar p nvarchar p datetime p int p nvarchar p datetime p int p int p int p int p nvarchar p p NULL p N F B EC B F E AA p NULL p p NImport csv p p p NULL p p p N f b b e bc a I guess I was expecting that to happen as Im explicitly calling and marking the entire entity as Modified dbContextEntryentityState EntityStateModified Then I thought I would try the update again but would skip over the line that is marking the state of the entire entity as Modified expecting that this time the SQL profile would only show those modified columns in the UPDATE statement But to my shock nothing was updated and the SQL profile was empty except for it adding a new Audit entry which is part of the Update method It seems that even though I have an entity from the dbContext which the dbContext should be tracking the modified properties on the entity are not being updated when calling dbContextSaveChanges without explicitly calling dbContextEntryentityState EntityStateModified but then it updates ALL columns I just want the update statement to ONLY update the columns that have actually changed What am I doing wrong Further technical details EF Core version Database provider Azure MicrosoftEntityFrameworkCoreSqlServer Target framework NET Core Operating system Windows IDE Visual Studio Hi guys I found a situation that can be a performance problem using owned types to modeling value objects from DDD Domain Driven Design If there is something I am doing wrong or some configuration that has to be done I would appreciate to know Entity cs public class UserEntity public UserEntitylong id FullName fullName Roles roles Status status Id id FullName fullName Roles roles Status status public long Id get private set public FullName FullName get private set public Roles Roles get private set public Status Status get private set Value Object cs public sealed class FullName ValueObject public FullNamestring name string surname Name name Surname surname public string Name get public string Surname get protected override IEnumerableobject GetEquals yield return Name yield return Surname Entity Configuration cs public sealed class UserConfiguration IEntityTypeConfigurationUserEntity public void ConfigureEntityTypeBuilderUserEntity builder builderToTableUsers User builderHasKeyx xId builderPropertyx xIdIsRequiredValueGeneratedOnAdd builderPropertyx xRolesIsRequired builderPropertyx xStatusIsRequired builderOwnsOnex xFullName y yPropertyx xNameHasColumnNamenameofUserEntityFullNameNameIsRequiredHasMaxLength yPropertyx xSurnameHasColumnNamenameofUserEntityFullNameSurnameIsRequiredHasMaxLength Executing the following LINQ cs var user contextSetUserLogEntityWherex xId SingleOrDefault Results in the following SQL sql SELECT TOP u Id u Roles u Status t Id t Name t Surname FROM User Users AS u LEFT JOIN SELECT u Id u Name u Surname u Id AS Id FROM User Users AS u INNER JOIN User Users AS u ON u Id u Id WHERE u Surname IS NOT NULL AND u Name IS NOT NULL AS t ON u Id t Id WHERE u Id CAST AS bigint The above SQL is very bad for something so simple it should be the following SQL sql SELECT TOP u Id u Roles u Status u Name u Surname FROM User Users AS u WHERE u Id CAST AS BIGINT The code works normally the entity and the value object are loaded but the generated SQL is not optimized Thank you for your attention and I am available for any information What problem are you trying to solve Hi At work we use a query which uses TimeSpan members Hours Minutes and Seconds but EFCore doesnt translate these members to sql Describe the solution youd like We fix the problem creating SqlServerTimeSpanMemberTranslator like the SqlServerDateTimeMemberTranslator and we override the SqlServerMemberTranslatorProvider to include also our SqlServerTimeSpanMemberTranslator I think SqlServerTimeSpanMemberTranslator can be useful also to other NET developers so if you want I can make a PR to include it to EFCoreSqlServer project ajcvickers recently posted a blog post where it recommends to use two round trip updates Here is an proposal which combines two ways and which should give some perf improvements csharp var userExists await contextUsers Updateuser userEmail email Whereuser userName name AnyAsync The Update method should generate an UPDATE query to a database Other methods should behave as before maybe not all but mostly all Therefore the resulting query should look like this sql UPDATE user SET email email WHERE name name This query can be executed by SQL Server and PostgreSQL and returns number of affected rows The number can be taken from the ExecuteNonQueryAsync method of a data reader If result greater than zero than all things done In case when an user wants to get updated entities back there is the RETURNING clause in PostgreSQL and OUTPUT in SQL Server csharp var users await contextUsers Updateuser userEmail email Whereuser userName name AsAsyncEnumerable sql PostgreSQL UPDATE user SET email email WHERE name name RETURNING name email SQL Server UPDATE user SET email email WHERE name name OUTPUT name email Need something to do with users before returning Easily using PostgreSQL and CTEs In case of SQL Server this could be tricky and require a temporary table While it wont give EF Core the same functionality as raw SQL the feature could make it a bit powerful and extend number of scenarios where it can be used We ignore now when paramters are not initialized in case a EXPLAIN query is used Fixes This issue is related to when using HasConversion convert List to json and use odata select it will throw a error Steps to reproduce git clone dotnet ef migrations add init dotnet ef database update F visit odataProductsselectimages Further technical details EF Core version Database provider eg MicrosoftEntityFrameworkCoreSqlServer Target framework eg NET Core Operating system IDE eg Visual Studio Describe what isnt working as expected After migration of my Azure function project to entity framework cosmos I am using below linq query to get entity from cosmos Steps to reproduceFuction Context class c public class DispatchContext DbContext IUnitOfWork public DispatchContextDbContextOptionsDispatchContext options baseoptions DatabaseEnsureCreated protected DispatchContext DatabaseEnsureCreated public DbSetAppointment Appointments get set public DbSetJob Jobs get set public DbSetContainer Containers get set public DbSetDriver Drivers get set public DbSetDriverDispatch DriverDispatches get set public DbSetMove Moves get set public DbSetGeneratedPlans PlansGeneratedEvents get set public DbSetTerminalTurnTime TerminalTurnTimes get set public DbSetTerminal Terminals get set public DbSetAlternatePlanLeg AlternatePlanLegs get set public CosmosDBsettings CosmosDBsettings get protected override void OnModelCreatingModelBuilder modelBuilder modelBuilderGetInfrastructureMetadataCosmosDefaultContainerName Dispatch modelBuilderHasDefaultContainerDispatch modelBuilderApplyConfigurationnew DriverEntityTypeConfiguration modelBuilderApplyConfigurationnew DriverDispatchEntityTypeConfiguration modelBuilderApplyConfigurationnew JobEntityTypeConfiguration modelBuilderApplyConfigurationnew PlansGeneratedEventConfiguration modelBuilderApplyConfigurationnew MoveEntityTypeConfiguration modelBuilderApplyConfigurationnew TerminalTurnTimesEventTypeConfiguration modelBuilderApplyConfigurationnew TerminalEventTypeConfiguration modelBuilderApplyConfigurationnew AlternatePlanLegEventTypeConfiguration baseOnModelCreatingmodelBuilder public async Taskbool SaveEntitiesAsyncCancellationToken cancellationToken defaultCancellationToken throw new SystemNotImplementedException var result await baseSaveChangesAsynccancellationToken return true C var filteredDispathces from d in contextSetDriver join dd in contextSetDriverDispatch on did equals ddDriverId where ddPlanDate dafaultPlanDate ddStatus ATRISK select dToList Got Exceptions Include both the message and the stack trace The LINQ expression DbSetDriver Join outer DbSetDriverDispatch inner d did outerKeySelector d d DriverId innerKeySelector d d new TransparentIdentifierDriver DriverDispatch Outer d Inner d could not be translated Either rewrite the query in a form that can be translated or switch to client evaluation explicitly by inserting a call to either AsEnumerable AsAsyncEnumerable ToList or ToListAsync See for more information Further technical details EF Core version Database provider eg MicrosoftEntityFrameworkCorecosmos Target framework eg NET Core Operating system IDE eg Visual Studio Id love to be able to provide a namespace for the generated files My project has an src directory at the root where my C source files begin from I detected changes in the release branch which have not been merged yet to master Im a robot and am configured to help you automatically keep master up to date so Ive opened this PR This PR merges commits made on release by the following committers wtgodbe Instructions for merging from UI This PR will not be automerged When pull request checks pass complete this PR by creating a merge commit not a squash or rebase commit img altmerge button instructions src width If this repo does not allow creating merge commits from the GitHub UI use command line instructions Instructions for merging via command line Run these commands to merge this pull request from the command line sh git fetch git checkout release git pull ffonly git checkout master git pull ffonly git merge noff release If there are merge conflicts resolve them and then run git merge continue to complete the merge Pushing the changes to the PR branch will retrigger PR validation git push HEADmergerelease tomaster details summaryor if you are using SSHsummary git push gitgithubcomdotnetmaestrobotEntityFrameworkCore HEADmergerelease tomaster details After PR checks are complete push the branch git push Instructions for resolving conflicts warning If there are merge conflicts you will need to resolve them manually before merging You can do this using GitHub resolvegithub or using the command line resolvecli resolvegithub resolvecli Instructions for updating this pull request Contributors to this repo have permission update this pull request by pushing to the branch mergerelease tomaster This can be done to resolve conflicts or make other changes to this pull request before it is merged git checkout b mergerelease tomaster master git pull mergerelease tomaster make changes git commit m Updated PR with my changes git push HEADmergerelease tomaster details summaryor if you are using SSHsummary git checkout b mergerelease tomaster master git pull gitgithubcomdotnetmaestrobotEntityFrameworkCore mergerelease tomaster make changes git commit m Updated PR with my changes git push gitgithubcomdotnetmaestrobotEntityFrameworkCore HEADmergerelease tomaster details Contact NET Core Engineering if you have questions or issues Also if this PR was generated incorrectly help us fix it See 