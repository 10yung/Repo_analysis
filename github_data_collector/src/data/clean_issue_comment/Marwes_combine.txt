I am trying to create a program that reads files potentially not fitting into memory and folds over items found in the file An item can span over several lines My problem is that I found no example for combine that I could adapt to my usecase examplesasyncrs seems to go into the right direction but it is too complicated for me So consider the simplified assignment Assume we want to implement wc l with the little twist that the program should fail when encountering a nonalphabetic and nonnewline character Effectively this program should recognise the grammar azAz n and then output the number of newlines The program should be able to handle files that do not fit into RAM A naive attempt at handling this assignment is rust extern crate combine use combineparsercharnewline use combineparserrangetakewhile use combinesepby Parser fn main let word takewhilec char cisasciialphabetic let mut lines sepbyword newline let result ResultVec str str linesparsea naa naaa printlnresult result let nlines resultunwrap iterfold acc x acc printlnnumber of lines nlines However the problem here is that We do not read from a file but from a fixed string We need to have the whole string on which we are operating in memory I would love a solution where I could just specify a line parser then run fold acc word acc on repeated parses of line on some file to obtain the number of lines The file should be read lazily eg by using BufRead thanks needs to be at least one implementation of two parsestreams or one parselazy Im not sure what the third option should be or if there are only two options I want to parse a large file to G I wonder if there exists a multithread way to acclerate the parsing work Hello The combination of BufferedStream ReadStream and BufReader is really great to read data from streaming stdin or else eg network input But BufferedStream has a fixed size and its complicated to find the good one when we dont know the content we will receive So I developed a new Stream named ElasticBufferedReadStream Im not good at finding short names combining the features of BufferedStream ReadStream and BufReader and adapting its size according to the checkpoints still owned by the parsers It uses Rc and Weak to track the checkpoints lifetimes You can see my project here Its still under development I will add the RangeStream feature and continue to test everything to be sure its stable What dou you think about it Maybe we can add this stream into your project works well in my experience so should just set that up I experimented with adding a debug combinator This is my draft code rust mod combineext use combineparserParser ParseMode use combinestreamRangeStream StreamOnce use combineerrorConsumedResult FastResult Tracked Info ParseError StreamError Tracked pub trait ParserExt fn debugself tag static str DebugSelf where Self Sized implP ParserExt for P where P Parser fn debugself tag static str DebugSelf Debug tag parser self pub struct DebugP tag static str parser P implP I O Parser for DebugP where I RangeStream P ParserInput I Output O IPosition stdfmtDisplay IError stdfmtDisplay type Input I type Output POutput type PartialState PPartialState inline fn parselazy mut self input mut SelfInput ConsumedResultO I println at selftag inputposition let before inputcheckpoint let result selfparserparselazyinput let consumedlen inputdistance before print finished and consumed bytes now at result selftag consumedlen inputposition let result match result FastResultConsumedOkx printlnok FastResultConsumedOkx FastResultEmptyOkx printlnok nothing consumed FastResultEmptyOkx FastResultConsumedErrerr printlnerr consumed err FastResultConsumedErrerr FastResultEmptyErrerr printlnerr nothing consumed errerror erroffset FastResultEmptyErrerr result fn adderror mut self error mut TrackedSelfInput as StreamOnceError selfparseradderrorerror fn addconsumedexpectederror mut self error mut TrackedSelfInput as StreamOnceError selfparseraddconsumedexpectederrorerror fn parsercount self combineErrorOffset selfparserparsercount Together with this example code rust use cratecombineextParserExt fn p a I impl ParserInput I Output char where I RangeStreamItem char Range a str IPosition stdfmtDisplay IError stdfmtDisplay IError ParseErrorIItem IRange IPosition choicechoice combinatorattemptcharchardebug withcharcharadebug combinatorattemptcharchar debug debug withcharcharbdebug The error will look like this Unexpected c Expected or println asserteqp easyparsea Oka println assertp easyparsebiserr println assertp easyparse aiserr println asserteqp easyparse b Okb println assertp easyparseciserr println println p easyparsecunwraperr assertfalse It generated the following output at x a a at x a a finished and consumed bytes now at x a b result ok finished and consumed bytes now at x a c result ok at x a e at x a e finished and consumed bytes now at x a f result ok finished and consumed bytes now at x a result err consumed Parse error at x a f Unexpected b Expected a at x a e at x a e at x a e finished and consumed bytes now at x a f result err nothing consumed Parse error at x a e ErrorOffset finished and consumed bytes now at x a e result err nothing consumed Parse error at x a e Unexpected Expected ErrorOffset finished and consumed bytes now at x a e result err nothing consumed Parse error at x a e Unexpected Expected ErrorOffset at x a at x a finished and consumed bytes now at x a result err nothing consumed Parse error at x a ErrorOffset finished and consumed bytes now at x a result err nothing consumed Parse error at x a ErrorOffset at x a at x a at x a finished and consumed bytes now at x a result ok finished and consumed bytes now at x a result ok finished and consumed bytes now at x a result err consumed Parse error at x a Unexpected a Expected b at x a d at x a d finished and consumed bytes now at x a d result err nothing consumed Parse error at x a d ErrorOffset finished and consumed bytes now at x a d result err nothing consumed Parse error at x a d ErrorOffset at x a d at x a d at x a d finished and consumed bytes now at x a d result ok finished and consumed bytes now at x a d result ok finished and consumed bytes now at x a d result ok at x a fa at x a fa finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset at x a fa at x a fa at x a fa finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset finished and consumed bytes now at x a fa result err nothing consumed Parse error at x a fa Unexpected c Expected ErrorOffset finished and consumed bytes now at x a fa result err nothing consumed Parse error at x a fa Unexpected c Expected ErrorOffset at x a fa at x a fa finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset at x a fa at x a fa at x a fa finished and consumed bytes now at x a fb result err nothing consumed Parse error at x a fa ErrorOffset finished and consumed bytes now at x a fa result err nothing consumed Parse error at x a fa Unexpected c Expected ErrorOffset finished and consumed bytes now at x a fa result err nothing consumed Parse error at x a fa Unexpected c Expected ErrorOffset Parse error at x a fa Unexpected c Expected or I think the Idea is nice but it requires a lot of additional trait bounds that make it a pain to use By specifying the input type not generically via I but explicit by using a type alias it is possible to mitigate this But the question is what we consider idiomatic parsers type MyInputa combineeasyStreamState a str combinestreamstateSourcePosition If there is no very easy way to implement this this issue can be closed I just wanted to introduce the idea Hi Marwes Im hitting the error part in and I have some questions regarding the overall design Why is the EndOfFile error handled by the Error traitstypes Wouldnt it be better to handle it right with Consumed or so Next is about ConsumedEmpty I think it means that the parser has not consumed any bytes from the input or that he has reset the input to the original position Why is it called Empty and not Nothing or Unchanged or so Am I missing the point FastResult is a flattened ParseResult But why is there a unflattened version when all user facing functions parse easyparse aaa parsestream never asked If I write out ConsumedResult it becomes type ConsumedResultO I FastResultO I as StreamOnceError ConsumedOkO EmptyOkO ConsumedErrIError EmptyErr Tracked error IError offset u Why is EmptyErr Tracked and ConsumedErr not Is ConsumedErr always not recoverable and therefore dont need the Tracking Why ParseMode and ispartial They do the same except that ParseMode monomorphizes I guess because carrying another associated type from StreamOnce would be noisy Thanks a lot Daniel Now that implement Trait is stable could you use it both for code and examples in order to simplify the API Im just starting out with combine and Im having a hard time dealing with what I assume are common errors and mistakes It would help if there were a guide pointing to the right bits in the docs and also some best practice guides