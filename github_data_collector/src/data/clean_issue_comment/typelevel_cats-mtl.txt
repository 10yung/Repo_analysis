Updates orgtypeleveldisciplinescalatest from RC to RC Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgtypelevel artifactId disciplinescalatest details labels libraryupdate semverprerelease Im trying to stack a WriterT and EitherT together ultimately something like IO Writer Log Either Throwable A The idea is that even in the event of an error the log up to that point should be maintained I have created a POC which uses a transformer stack of EitherT WriterT IO Log Throwable and when I materialise the program it works as expected The logs are present even in the event of an error However FunctorListen seems to short circuit in the event of an error Here is the code itself scala object POC extends IOApp import catsinstancesvector import catsmtlimplicits import catssyntaxflatMap import catssyntaxfunctor type Log Vector String override def runargs List String IO ExitCode val name getName EitherT WriterT IO Log Throwable this works even with a raised error so the stack itself is working namevaluewrittenflatTaplogs IOprintlnlogsasExitCodeSuccess this wont work printLognamevaluerunasExitCodeSuccess def printLog F A fa F A implicit F Sync F FL FunctorListen F Log F A this is never called when an error is raised falistenflatMap case a logs Fdelayprintlnlogsasa def getName F implicit F Sync F FT FunctorTell F Log FR FunctorRaise F Throwable F String for FTtellVectorgetting name a Fdelaybob Exception here means FunctorListen cant find any logs FRraisenew Exceptionboom F Unit yield a Im not sure if this is a problem with FunctorListen or FunctorRaise It could be that FunctorRaise is raising an error at the IO level not the EitherEitherT It can be convenient to allow a MonadState F S to serve as an ApplicativeAsk F S We can think of the former constraint as the ability to read and update system state and the latter as simply the ability to read it If all we need is to read the state the least privilege principle suggests that a ApplicativeAsk F S constraint is preferable Traditionally Reader monad is associated with reading outside configuration However IME it also works well to read the domain model of a stateful application or some part thereof eg by the lensing techniques available in meowmtl An example of value can be found in the meowmtl readme use case This is a proposal to consider an optin extra derivation that provides an ApplicativeAsk F S should a MonadState F S instance be available Optin rather than automatic because the Ask and State may be unrelated if Stype is something common like Int Updates com degsbtmicrosites from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId com deg artifactId sbtmicrosites details labels semvermajor You know I consider myself a reasonably advanced user of TravisCI and sbt and it took me a zillion tries just to get a PR to build successfully I still have no idea how to release anything Some of those tries involved running sbt locally having something fail killing it running the same command again and having it work I want to rip out a lot of the madness so that its possible for thirdparties to contribute without having to replicate what I did because Im not sure I can replicate what I did Hi all Bracket typeclass that exists in catseffect doesnt work well with an effect that relies on FunctorRaise I want to implement a cleanup logic in case of any error raised either by MonadError or FunctorRaise Example scala import catsdataEitherT import catseffect import catseffectsyntaxbracket import catsmtl import catsmtlimplicits final case class AppErrorreason String class Service F Sync ApplicativeHandle AppError FunctorRaise AppError def createActive F String createbracketCaseuuid makeActiveuuid case ExitCaseCompleted Sync F unit There can be an error too case uuid ExitCaseErrore destroyuuid case uuid ExitCaseCanceled destroyuuid def makeActiveuuid String F String FunctorRaise F AppError raiseAppErrorOops Something went wrong def create F String Sync F puresome uuid def destroyuuid String F Unit Sync F unit object Service def mainargs Array String Unit type Effect A EitherT IO AppError A val service new Service Effect printlnservicecreateActivevalueunsafeRunSync LeftAppErrorOops Something went wrong For sure this is the correct behavior of a Bracket typeclass and cleanup logic for a specific error can be managed inside the bracket scala createbracketCaseuuid makeActiveuuidhandleError AppError e destroyuuid eraise But should there be an alternative Bracket that manages specific errors raised by FunctorRaise For example extended ADT can be used scala sealed trait ExitCase E E object ExitCase final case object Completed extends ExitCase Nothing Nothing final case class Error E cause E extends ExitCase E Nothing final case class UnhandledError E cause E extends ExitCase Nothing E final case object Canceled extends ExitCase Nothing Nothing It has been mentioned on Gitter that such a function would be useful especially for things like Ref that provide an atomic modify operation that allows returning a value depending on the previous state Here it is It probably needs some laws so Ill think about it and report back when I come up with something reasonable will check what it looks like in Haskell world too I had a need for Functor on ApplicativeAsk so I just went with it and looked at other possible implementations TODO instances for other type classes law tests obviously Let me know if this looks like a nice thing to have I noticed that even thought there is a catsmtl Gitter channel the Travis build notifications are going to the Cats Gitter channel instead I dont have write permissions to this repo so I cant see the right URL to fix it but someone with permissions should be able to go to the catsmtl Gitter channel click the settings knobs on the upper right click Integrations and set up a new webhook URL for Travis If you leave the URL hardcoded in the travisyml then you will still get notifications for builds on forks Also I dont think that theres anything preventing anyone from copying the URL and sending build notifications for unrelated projects though I dont know what their motive would be See for how to easily transition to the preferred way of setting up these notifications Should address for now StateIO uses a Ref to make state updates more performant A simple benchmark included in this PR shows this so far info Benchmark Mode Cnt Score Error Units info StateBenchleftAssociatedBindSpecial thrpt opss info StateBenchleftAssociatedBindStateT thrpt opss next step might be to newtype it to avoid boxing