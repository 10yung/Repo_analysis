Been going through my open source projects which Ive been neglecting and figured I should write something here about where I am with this project Unfortunately Im no longer working on a larger project where I think this might be useful for my current needs wasm is a better fit so Im not going to update this project at least in the near term I still think the core part of this project safe interaction with a garbage collector via a futuresish API was a neat idea and Id still like to explore this in the future when the hopefully the compiler is a bit more ready Before I pick this up again though I think that there needs to be additional support in the Rust compiler for doing this because while it is possible to use a GC safely via combinators it is not at all pleasant What Id like is for it to be possible to have a safe GCd API using async await or generators but AFAICT right now it is not possible I tried for a while recently to see if I could come up with even a very limited version of the sequence API that worked with async await functions and I couldnt find anything that worked You cant autogenerate Collect for closures or generators right now which is certainly a limitiation but it isnt actually the biggest problem currently Right now theres no way I can find to pass a Contextgc with a unique branded gc lifetime through an async function while having that async function not also be of the gc lifetime We need the async function to strictly outlive gc so that it cant hold Gc pointers across await points or we need some other solution Incidentally I cant make this work at all right now but even if I could I know that you cant make the lifetimes work out so that the async function lives for longer than gc Once I find any way of proceeding that enables generatorslike functions instead of combinators I think Ill pick this back up but until then Im not going to update this Ill keep thinking about the problem though If anybody else has any ideas about how to make this work let me know The static string key is frequently written when creating a standard library so I can write it simply zaoqizaoqipc lua lua i langlua Lua Copyright C Luaorg PUCRio zaoqizaoqipc lua lustertargetdebugluster r langlua Error ThreadErrorBadCallTypeError expected function found nil I believe that a sufficiently smart compiler would compile this Stringnew to the same machine code as the existing implementation Pretty sure rustc isnt that compiler though Could retain the existing implementation for performance Hello I have just been pointed to this repository as Im currently investigating scripting languages accessible from rust that would support builtins that return impl FutureOutput TheActualResult and thus have all lua functions when accessed from rust that would implicitly return impl FutureOutput TheActualResult in a way that would be transparent to the scripted language for the configuration file of a server Im writing Until now the only language I had found that matched this property was gluon but going with a brand new scripting language makes me uneasy as users would have to learn it in addition to understanding how my server works So I wonder is async builtins callbacks being transparently asyncd through the lua call stack until the initial rust caller something you are considering for luster Cheers and good luck with this rewrite Leo Ive started to have a play with luster to see how it might fit into another project I was wondering about adding some of the table functions but notice that the next function isnt implemented yet Before I start poking around in Table do you have thoughts on an approach Replacing the FxHashMap with something like IndexMap might work that IndexMap doesnt quite do everything needed as far as I can tell Thanks Chris