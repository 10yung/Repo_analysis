Currently the primary way to load an fst object MapSetRaw from a byte slice is to use fromstaticslice While that solves the use case of loading data that lives for the lifetime of the program it appears to be overlyrestrictive for other use cases For example I have fst data that Ive written into a network buffer I do not want to give ownership of that buffer to fst so using frombytes wont work The fst data is not static so fromstaticslice wont work The fst data is a subslice of a greater slice the network buffer so to make it work with fromsharedbytes I would need to change my internal APIs to use ArcVecu instead of u which may add bugs and performance regressions While I could try to use the existing mmap API I believe I would need to create a filelike object that wraps my byte slice and then memory map it which is unergonomic and errorprone My recommendation is to add a fromslicebytes u constructor to Map Set and Raw My understanding is that this is unfortunately not trivial because the FstData type does not take a lifetime parameter which would be required while it holds a reference to the byte slice Nevertheless is there interest in adding this feature Thanks Similarly to fstlevenshtein inherits the mmap feature which means it cant be used in WebAssembly without forking and modifying locally Hopefully you would consider this addition as well Thanks I got warnings when compiling this example with rustc I fixed them as per the error messages Not sure if these make sense on earlier versions of rust but heres a quick PR in case this is helpful fst has all the necessary infrastructure for FromIterator to work please consider implementing it so that collect works and in particular to make it easy to collect into ResultFst or ResultSet Thank you For some uses it would make sense to statefully walk through the FST stepping forward with input bytes but also popping off the last input and returning to the previous state Id love to have something with roughly the following interface rust impl FstWalker fn newfst Fst FstWalker fn push mut self input u bool false if no transition fn node self Node fn pop mut self fn value self u The FstWalker would internally maintain the bytestring pushed so far which it may want to reserveexact on based on the longest key in the Fst to avoid needing to grow it value would return the current bytestring The node function would allow calling isfinal andor finaloutput I can build this easily enough based on the interfaces already provided by rawFst but Im wondering if this looks like something useful enough to provide in the fst crate itself If I wrote a patch for this would you be interested I also dont know if this would beat the performance of just recursing on the fst but I plan to test that For some uses of an FST before applying a large number of queries to the fst the caller may be able to prune out states and transitions from the FST based on knowledge of valid keys For instance if using an FST to store a dictionary and performing lookups in that dictionary for a game the caller may know that only a subset of letters are available and could start by preprocessing the FST to prune any states or transitions that use unavailable letters Please consider providing ways to efficiently process an FST and prune out states and transitions based on inputs The simplest could be a filter on valid u inputs for transitions Hello The fst can be queried with a specific key or with an automaton The key is optimized by just going forward while the automaton is offered one byte at a time to modify the state Now I have a sparse automaton one that doesnt describe one specific key only but it has only few branching points and is just single possible next byte in most of the states I wonder if its possible to somehow make the querying faster given the above Instead of offering it all the bytes that wont match for sure just going forward on the straight parts I could write a code specific to my use case but is there something that could be done in general Maybe extending the automaton with a fn hint self Option u default to None that would not store the intermediate visited states and just go forward Would it make it faster Would it make sense to have something like that as part fst itself Or is there a better way If so I might try to implement it but I want to ask first before I invest the time Thank you The commandline fst map twocsv twofst does work but the following command fst range o twofst prints only one single line and the command fst dot twofst dot Tpng twopng produces a graph with three nodes ok But only a single final node a wrong output on label a and no output on label b I am currently working on an improvement of the fst library and I am facing a problem I read the Streamer Trait explanation and the whole lifetime nomicon explanations to try to fix this lifetime problem rust struct StreamWithStateOutputSS impla S T Streamera for StreamWithStateOutputS where S Streamera Item a u u T type Item a u rawOutput T fn next a mut self OptionSelfItem self nextmapk v s k rawOutputnewv s This is the current mapping struct that I produced to map a Streamer into another Streamer but that produce rawOutputs rather than u like the StreamOutput struct you already define but Im facing a problem of lifetime like the one you talk about in the Streamer Trait documentation I suppose If I follow the help message that rustc outputs I add a lifetime constraint T a to the StreamWithStateOutput Streamer implementation and the problem comes after the OpWithStateBuilder need a T static constraint So I didnt add this constraint because it blocks everything above the code is less fexible I just want to understand the problem here its hard to work with lifetimes I also think of using IntoStreamer to construct a StreamWithStateOutput like you said in the Streamer explanations but its not possible I fear Note that I successfully defined a rawOpWithStateBuilder without forcing a static bound on T by using the same constraints on the push method than the ones on OpWithStateBuilder not raw the only thing that is different is the StreamWithStateOutput mapping struct used to pass from a u to an Output In some cases it can be useful to know the automaton state as well when intersecting the fst with an automaton using search For instance levenshteins automatons state hold the actual levenshtein distance of the current key It is a very valuable information that could be used for ranking the results for instance 