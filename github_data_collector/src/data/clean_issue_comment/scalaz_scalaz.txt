use byname implicits What happened to docs at scalazgithubio I dont see anything at the moment its just empty img width altScreenshot at src img width altScreenshot at src In Scala scalacollectionimmutableStream is deprecated and scalacollectionimmutableLazyList is recommend for replacement Deprecated Since version Use LazyList which is fully lazy instead of Stream which has a lazy tail only Scalaz doesnt not have LazyListInstance for I was thinking about adding LazyListInstance but its not as simple as adding one typeclass instance since other types and typeclasses use Stream eg scalazZipper scalazFoldable etc Could you please add LazyListInstance Im not sure what can be the best solution for this though Replacing Stream with LazyList in Scalaz would be nontrival work Consistent Foldable and Foldable for scalaz introduces better versions of the standard datatypes such as Map Maybe IList but does not use it itself for instance Map api returns List instead of IList and Option instead of Maybe which makes very cumbersome to utilise them I identified those places DataTypes IList These Ephemeral Stream Typeclasses Enum Foldable I discussed it in gitter and going to link corresponding PRs to this issue I think it makes sense to change Foldable and Enum typeclass as well What do you think Save some boilerplate when creating instances For eg Monad and Traversable which share Functors code Users dont need to import scalazScalaz if they only need less powerful TC for eg Functor This reduces implicit scope and speedup compile time To illustrate console setup note that there is no import scalazScalaz scala scala import scalaztc scala import scalaList scala def ft F implicit F Functor F Functor F F ft F implicit F scalaztcFunctor F scalaztcFunctor F scala def mn F implicit F Monad F Monad F F mn F implicit F scalaztcMonad F scalaztcMonad F Before the change scala scala ft List console error could not find implicit value for parameter F scalaztcFunctor List ft List After the change scala scala mn List res scalaztcMonad List scalaztcinstanceslistanon dacc scala ft List res scalaztcFunctor List scalaztcinstanceslistanon dacc scala mf List res scalaztcFunctor List scalaztcinstanceslistanon dacc In this PR only List has the new scheme of instances but other data types can have the same too Further steps might be to move hierarchical implicits to the respective target Class so that they get resolved without importing With Task gone its now time to look at IO Instead of deleting scalazeffect outright however I thought it best to raise an issue to see if MonadIO or any typeclasses in effect are worth salvaging If they are should should scalazeffect as a module remain and should these typeclasses be moved to core Implementation of Distributive looks like this scala trait Distributive F extends Functor F self def distribute G FunctorAB fa G A f A F B F G B def cosequence G FunctorA fa G F A F G A But in Haskell and Purescript this looks differently haskell collect Functor f a g b f a g f b distribute Functor f f g a g f a So probably in Scala implementation should be more like this scala trait Distributive F extends Functor F def collect G FunctorAB fa G A f A F B F G B def distribute G FunctorA fa G F A F G A well if we want to have coname then maybe scala trait Distributive F extends Functor F def cotraverse G FunctorAB fa G A f A F B F G B def distribute G FunctorA fa G F A F G A Maybe I am missing something I just came across the fact that a Show Throwable exists It is not wired up into import Scalaz one needs to import scalazstdjavathrowable It discards the stack trace entirely Whats going on with this D Is it OK if I fix both of these for and 