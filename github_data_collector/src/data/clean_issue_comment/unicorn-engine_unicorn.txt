Ensure the TCG exit flag is cleared at the end of cpuexec This ensures that subsequent calls are not polluted by the prior call to request an early exit The symptoms of the problem being addressed here are that after a cpuexit call triggered within a hook there may still be a pending tcgexitreq flag set This then causes a block to start its execution and then be aborted from which point itll continue because theres no other condition to service The start of the execution causes the block hook to be called no actual code to be run and then the block started again with another block hook call This change is discussed in ticket Im seeing problem with the block hook being called twice with no intervening code execution when the emulation was stopped in the previous emulation cycle That seems rather difficult to explain so Ill give a sequence that causes it Register a block hook Register an exception hook UCHOOKINTR Start execution of code emustart Our block hook is called to say that were executing our code When an exception instruction is executed the hook issues an emustop to request that the system return We return from emustart and do whatever we need to do to handle the exception Start execution of code again Our block hook is called to say that we execute the instructions after the exception instruction Our block hook is called AGAIN with the same block Execution continues Thats the sequence that happens in the failure case and if we insert hooks for code we see that between the block hook being called at step and step no code is executed or at least no code hook is executed and by constructing the code in known ways it is clear that the code is not executed Actual example code that exhibits this issue python Demonstrate the repeated block hooks being called from capstone import import capstonearmconst from unicorn import import unicornarmconst as arm The bit pattern that is used here is intended to expose execution issues If an instruction is executed twice theres a gap in the bit pattern that will be filled ie odd bits should never be set in normal execution If a block is executed twice multiple bits will be affected armcode E A MOV r E ADD r r E ADD r r C EF SWI E ADD r r E ADD r r EF SWI C E C ADD r r E A F MOV pc md CsCSARCHARM CSMODEARM mddetail True mdsyntax CSOPTSYNTAXNOREGNAME code lines armcodesplitlines for line in lines if line Change the littleendian string to a set of characters inst line chars listinstdecodehex charsreverse codeextendchars code joincode def disscodeword address for i in mddisasmcodeword address print x x s s iaddress imnemonic iopstr def hookblockuc address size userdata printBlock execution at x x x address size def hookcodeuc address size userdata codeword ucmemreadaddress disscodeword address def hookintruc intno userdata printCPU Exception i intno Request that the emulation stops ucemustop regmap armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGR armUCARMREGSP armUCARMREGLR armUCARMREGPC Base for the code ADDRESS x Initialize emulator in ARM mode mu UcUCARCHARM UCMODEARM map K memory for this emulation mumemmapADDRESS Write the code to memory mumemwriteADDRESS code Trace execution with a block code hook and interrupt muhookaddUCHOOKBLOCK hookblock beginADDRESS endADDRESS muhookaddUCHOOKCODE hookcode beginADDRESS endADDRESS muhookaddUCHOOKINTR hookintr beginADDRESS endADDRESS muregwritearmUCARMREGPC ADDRESS while True try pc muregreadarmUCARMREGPC printBegin execution at x x pc muemustartpc ADDRESS lencode except UcError as exc printException s errnoi exc excerrno if excerrno UCERRFETCHUNMAPPED That branch through at the end of the code means that were done break if excerrno UCERREXCEPTION An unhandled exception which never happens because we trap them in the hook printUnhandled CPU exception pass printFinished now print the registers for regnum regcode in enumerateregmap regvalue muregreadregmap regnum print r i x i regnum regvalue regvalue Show the bits to check that we actually have the right ones set printBits in R r muregreadregmap for bit in range value bit state SET if r value else printBit i x s bit value state This displays the following output which shows that the block hook is being called twice although no actual execution occurs Begin execution at x Block execution at x x mov r x x add r r x add r r x c svc CPU Exception Begin execution at x Block execution at x c Block execution at x c x add r r x x add r r x x svc CPU Exception Begin execution at x c Block execution at x c Block execution at x c x c add r r x x mov pc Exception Invalid memory fetch UCERRFETCHUNMAPPED errno Finished now print the registers r r r r r r r r r r r r r r r r Bits in R Bit SET Bit Bit SET Bit Bit SET Bit Bit SET Bit Bit SET Bit Bit Bit Bit Bit Bit Bit SET I suspect that something about the state is causing an abort of the block compile because the emustop had been detected or something hung off it and then it clears that state and reexecutes but because of the hook being present we see two block executions There were TONS of changes since An upcoming Unicorn qemu is unable to emulate the dbf instruction depicted below The result is a UCERREXCEPTION make test disabled for msys MinGW for now I cannot find UCX REGGSBASE UCX REGFSBASE in the master branchwhat is going onHow can i set the kernel gs base When running the simple test harness of afl unicorn without any afl patches using Unicorn rc on the Raspberri PI the following line crashes with segmentation fault The stack is completely bogus when it crashes No clue whats going on sadly It works fine on x Command line bash simple gitmaster python simpletestharnesspy sampleinputssample bin Loading data input from sampleinputssample bin Starting the AFL forkserver by executing instruction segmentation fault python simpletestharnesspy sampleinputssample bin makesh iosarm makesh The build script for unicorn engine USAGE makesh OPTIONS OPTIONS Build the project asan Build for ASan install Install the project uninstall Uninstall the project macosuniversal Build universal binaries on macOS macosuniversalno Build nonuniversal binaries that includes only bit code on macOS crosswin Crosscompile Windows bit binary with MinGW crosswin Crosscompile Windows bit binary with MinGW crossandroidarm Crosscompile for Android Arm crossandroidarm Crosscompile for Android Arm linux Crosscompile Unicorn on bit Linux to target bit binary msvcupdategenfiles Generate files for MSVC projects When unicorn uses the timeout function there are two competing bugs example When timeout is set and an interrupt is triggered there is a certain probability that the UCERREXCEPTION abnormal behavior is triggered poc from unicorn import from unicornarmconst import def hookintruc intno userdata global intrnum lastpc intrnum pc muregreadUCARMREGPC lastpc pc printintr pc is xx pc def hookcodemu addr size data pc muregreadUCARMREGPC printhook pc is xx pc CODEADDRESS x code mov r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r swi code b x x xa xe b x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xef trynumber x while True try trynumber if trynumber break global intrnum global lastpc intrpc x c x x dc x x c x b x fc x x c x d x c x x ac x f x c x x cc x x c x a x ec x x c x c x c x x c x e x c x x bc x x c x x dc x a x a c x ab x afc x b intrnum mu UcUCARCHARM UCMODEARM mumemmapCODEADDRESS mumemwriteCODEADDRESS code muhookaddUCHOOKINTR hookintr muhookaddUCHOOKCODE hookcode printStarting emulation muemustartCODEADDRESS CODEADDRESS lencode timeout printEmulation done pc muregreadUCARMREGPC print pc xx pc printintr number is intrnum del mu except UcError as e printERROR s e pc muregreadUCARMREGPC print pc xx pc printintr number is intrnum break if trynumber printgood job result intr pc is x intr pc is x c intr pc is x d intr pc is x c intr pc is x intr pc is x ac ERROR Unhandled CPU exception UCERREXCEPTION pc x f intr number is Cause AnalysisWhen setting timeout there is a certain probability that emustop will be triggered in the following code snippet bool catched false if definedCONFIGUSERONLY if user mode only we simulate a fake exception which will be handled outside the cpu execution loop if definedTARGETI ccdointerruptcpu endif ret cpuexceptionindex break else if ucstopinterrupt ucstopinterruptcpuexceptionindex Unicorn call registered invalid instruction callbacks HOOKFOREACHVARDECLARE HOOKFOREACHuc hook UCHOOKINSNINVALID catched uccbhookinsninvalidthookcallbackuc hookuserdata if catched break if catched ucinvaliderror UCERRINSNINVALID else Unicorn call registered interrupt callbacks HOOKFOREACHVARDECLARE HOOKFOREACHuc hook UCHOOKINTR uccbhookintrthookcallbackuc cpuexceptionindex hookuserdata catched true if catched ucinvaliderror UCERREXCEPTION After the emustop is triggered the HOOK program will not be executed again which causes catched to fail so the UCERREXCEPTION exception is triggered example After unicorn set timeout there is a probability that the interrupt instruction has been executed but hookinterrupt has not been executed poc from unicorn import from unicornarmconst import def hookintruc intno userdata global intrnum lastpc intrnum pc muregreadUCARMREGPC lastpc pc printintr pc is xx pc def hookcodemu addr size data pc muregreadUCARMREGPC printhook pc is xx pc CODEADDRESS x code mov r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r add r swi code b x x xa xe b x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xe x x x xef trynumber x while True try trynumber if trynumber break global intrnum global lastpc intrpc x c x x dc x x c x b x fc x x c x d x c x x ac x f x c x x cc x x c x a x ec x x c x c x c x x c x e x c x x bc x x c x x dc x a x a c x ab x afc x b intrnum mu UcUCARCHARM UCMODEARM mumemmapCODEADDRESS mumemwriteCODEADDRESS code muhookaddUCHOOKINTR hookintr muhookaddUCHOOKCODE hookcode printStarting emulation muemustartCODEADDRESS CODEADDRESS lencode timeout printEmulation done pc muregreadUCARMREGPC print pc xx pc printintr number is intrnum if pc in intrpc and lastpc pc break del mu except UcError as e printERROR s e pc muregreadUCARMREGPC print pc xx pc printintr number is intrnum break if trynumber printgood job The program returns to the soft interrupt of the hook arm and processes the soft interrupt When unicorn processes the interrupt in the program it will execute the interrupted instruction first and then execute the interrupted processing program after executing the instruction This also causes the pc value obtained in the reinterrupt to be the next instruction of the interrupt instruction The intrpc in the code stores the next instruction of all soft interrupts It ends when the program triggers to the execution of the interrupt instruction but does not capture the interrupt instruction result Starting emulation intr pc is x c intr pc is x intr pc is x dc intr pc is x intr pc is x c intr pc is x b intr pc is x fc intr pc is x intr pc is x c intr pc is x d intr pc is x c intr pc is x intr pc is x ac intr pc is x f intr pc is x c intr pc is x intr pc is x cc intr pc is x intr pc is x c intr pc is x a intr pc is x ec intr pc is x intr pc is x c intr pc is x c intr pc is x c intr pc is x Emulation done pc x c intr number is As can be seen from the results of the program the th interrupt was executed but it was not captured The root cause is that when an interrupt is triggered unicorn will execute cpuloopexit cpu and this will jump to the following code snippet if sigsetjmpcpujmpenv if ucstoprequest ucinvaliderror break If emustop is called before this stoprequest will be set to true which will directly jump out of the large loop here resulting in interrupts that cannot be captured The fix here is that unicorn can be ended only when the cpu exits Therefore a new flag bit timeoutrequest is created When the CPU exits the flag bit will be detected to determine whether to end the simulation Building wheel for unicorn setuppy error ERROR Command errored out with exit status command datadatacomtermuxfilesusrbinpython u c import sys setuptools tokenize sysargv datadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppy filedatadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppyfgetattrtokenize open openfilecodefreadreplace r n nfcloseexeccompilecode file exec bdistwheel d datadatacomtermuxfilesusrtmppipwheeltk khx w pythontag cp cwd datadatacomtermuxfilesusrtmppipinstalls smeqbunicorn Complete output lines running bdistwheel running build Building C extensions cd qemu configure cccc extracflagsDUNICORNHASX DUNICORNHASARM DUNICORNHASARMEB DUNICORNHASM K DUNICORNHASARM DUNICORNHASMIPS DUNICORNHASMIPSEL DUNICORNHASMIPS DUNICORNHASMIPS EL DUNICORNHASSPARC fPIC fvisibilityhidden targetlistx softmmu armsoftmmu armebsoftmmu m ksoftmmu aarch softmmu mipssoftmmu mipselsoftmmu mips softmmu mips elsoftmmu sparcsoftmmusparc softmmu ERROR Cannot use python Python or later is required Note that Python or later is not yet supported Use pythonpathtopython to specify a supported Python make Makefile qemuconfighosthtimestamp Error error Errno No such file or directory libunicornso ERROR Failed building wheel for unicorn Running setuppy clean for unicorn Successfully built pwntools Failed to build unicorn Installing collected packages unicorn pwntools Running setuppy install for unicorn error ERROR Command errored out with exit status command datadatacomtermuxfilesusrbinpython u c import sys setuptools tokenize sysargv datadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppy filedatadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppyfgetattrtokenize open openfilecodefreadreplace r n nfcloseexeccompilecode file exec install record datadatacomtermuxfilesusrtmppiprecord q nzqqinstallrecordtxt singleversionexternallymanaged compile cwd datadatacomtermuxfilesusrtmppipinstalls smeqbunicorn Complete output lines running install running build Building C extensions cd qemu configure cccc extracflagsDUNICORNHASX DUNICORNHASARM DUNICORNHASARMEB DUNICORNHASM K DUNICORNHASARM DUNICORNHASMIPS DUNICORNHASMIPSEL DUNICORNHASMIPS DUNICORNHASMIPS EL DUNICORNHASSPARC fPIC fvisibilityhidden targetlistx softmmu armsoftmmu armebsoftmmu m ksoftmmu aarch softmmu mipssoftmmu mipselsoftmmu mips softmmu mips elsoftmmu sparcsoftmmusparc softmmu ERROR Cannot use python Python or later is required Note that Python or later is not yet supported Use pythonpathtopython to specify a supported Python make Makefile qemuconfighosthtimestamp Error error Errno No such file or directory libunicornso ERROR Command errored out with exit status datadatacomtermuxfilesusrbinpython u c import sys setuptools tokenize sysargv datadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppy filedatadatacomtermuxfilesusrtmppipinstalls smeqbunicornsetuppyfgetattrtokenize open openfilecodefreadreplace r n nfcloseexeccompilecode file exec install record datadatacomtermuxfilesusrtmppiprecord q nzqqinstallrecordtxt singleversionexternallymanaged compile Check the logs for full command output 