In its current implementation the parser works recursively which is fine if you are doing simple expression parsing But once you start parsing a long series of tokens a stack overflow may occur such is the case in What I propose is to start reimplementing the parser in small logical chunks This includes eliminating recursive calls and making the parsing iterative trying to keep the expressions as linear as possible eg binary operators being represented in reverse polish notation instead of a tree As I said the work can be split into small chunks such as var let const return functions blocks new if else if else ternary loops objects arrays switch typeof binary operators unary operators regular expressions Note this list might not be exhaustive Simple assignement with addition does not work when there is no space between first operand and or let a This works though let a Same with binary operator thread main panicked at Could not convert value to f ParseFloatError kind Invalid srclibcoreresultrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingcontinuepanicfmt at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs coreresultunwrapfailed at srclibcoreresultrs coreresultResultTEexpect at rustc ea cb f a c e f srclibcoreresultrs boasyntaxlexerLexerlex at srclibsyntaxlexerrs boaparserexpr at srcliblibrs boaforward at srcliblibrs boaexec at srcliblibrs boamain at srcbinbinrs For example this fails var a consolelog consolelog While these work var a consolelog consolelog var a consolelog something OS Ubuntu uname generic This Pull Request changes the evaluation of Const values Num Bool String to use the specific prototype constructor to set all required properties and methods Resolves The rest operator has been implemented to arrays abc But it is not implemented for objects test case js const b a b c const a a a b b b consoleloga The array implementation exists here inside of execrs Tests for this exist here too will need to do something similar There will need to be changes to the parser so spread can be parsed within an object The above code will currently error in the parser as spread syntax isnt expecting within an object Parsing objects happens here Im getting undefined when I do abcmatchAlllength This is incompatible with Chromes implementation for example where I get Testing with master with the following testsjs js consolelogabcmatchAlllength Heres the output for cargo run cargo run Compiling Boa v databoa Finished dev unoptimized debuginfo targets in s Running targetdebugboa undefined srcbinbinrs exec buffer undefined Related to and The spec describes that new Array should create an array with empty elementsslots Currently it produces This is a question about codebase As far as I get there is parse function to parse a single expression which uses parsenext to look ahead along with several others Currently if parsenext sees semicolon it advances position but does not stop expression parsing Why is so I thought thaat it should denote the end of expression It causes at least one of the reported problem with preincrementpredecrement operator Thanks Part of TODO tests for arrow functions rebase