 This PR adds support for synthesizing freeze instruction Before we forget about it let me file an issue for this case InstFShl auto NewKB concatKnownBitsKB KB if KB isConstant auto Shift KB getConstanturemIWidth NewKB Zero NewKB ZeroshlShift NewKB One NewKB OneshlShift Result NewKB truncIWidth else This code in AbstractInterpretercpp looks incorrect LangRef for fshl and the most significant bits are extracted to produce a result And trunc removes the most significant bits LangRef for trunc says The trunc instruction truncates the high order bits in value The getValue in Passcpp cant tell whether a value comes from existing values from LHS or from the newly synthesized instructions The getValue creates a new LLVM value for each instruction in RHS even when the instruction is harvested as cand from LHS This brings the dup instructions in the result IR When the cand contains phi souper crashes Ill get it fixed soon Hi The getValue function in souperPass libPassPasscpp try to recursively generate corresponding LLVM IR instructions for a fragment of souper IR However in the case where it try to handle twooperand souper Inst it doesnt close the case with a break statement Thus if an operand Inst is not supported ie cannot be handled by the inner switch the control flow will fall through to next case which performs an outofbound operand access and crash the program Hi In SouperPass if a RHS replacement already has Origins ie associated LLVM Values the pass will try to reuse it Before applying the replacement LLVM Instructions it will check if the Instructions dominate our replacement point However if it fails it will just bail out the whole process and return an replacement failure Im wondering if we can simply create another LLVM instruction and attach to the corresponding Souper Inst that dominates the replacement point instead Thank you Hi From implementation of souperSolveCandidateMap which is used by the souper command line tool we know that upon catching error returning from solver the function will just bail out by returning false code However in SouperPass it will bail out the entire process only if the error returning from solver is neither timed out nor value too large code Is there any specific reason behind this difference Do you think its a good idea to make error handling be consistent in these two places We got two ExprBuilders one is and one is This might cause confusion I would suggest renaming the second ExprBuilder to InstBuilder Alive requires re c Alive prerequisites it is installed in the souper Dockerfile too llvm is pulled down via svn Solution add re c and svn to the prerequisites documented in the README