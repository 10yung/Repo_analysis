Fix including unit tests Summary Im using an OIDC Provider that supports OIDC Backchannel Logout Spec However the current version of Spring Security doesnt implement this functionality Actual Behavior Theres no way to have single sign out Expected Behavior Single sign out from all RPs in which the user has authenticated with SSO Configuration Version Summary When using Annotation based method security Spring Boot does not provide a way to whitelist controller methods by default it is blacklist based instead Eg if an annotation for a controller method is omitted then the authorization scheme form HttpSecurity configuration is applied Sample By using the custom MethodSecurityMetadataSource provided by this package all requests to controller methods that are not explicitly annotated will be denied by default This provides better security in situations where developers forget to annotate controller methods For Security Vulnerabilities please use Summary I the new OidcClientInitiatedServerLogoutSuccessHandler in Spring Security The only problem I see with it is you have to set a postLogoutRedirectUri property This will likely vary between development test and production so it seems like kind of a pain to have to maintain a new property that could be calculated By default itd be nice if the postLogoutRedirectUri defaulted to the current context path If people wanted to override it itd be cool if they could use a relative URL that starts with or an absolute URL current behavior Im entering this here as requested by jgrandja on Stack Overflow Actual Behavior You need to set a postLogoutRedirectUri Expected Behavior Id like this value to default to Configuration OIDC with Okta and Keycloak because JHipster Version Spring Security This ticket addresses the Servlet implementation of Summary BasicAuthenticationConverter in BasicAuthenticationFilter ignores given credentials charset Actual Behavior We try to override the credential charset using an ObjectPostProcessor java httpSecurity httpBasic addObjectPostProcessor new ObjectPostProcessorBasicAuthenticationFilter Override public O extends BasicAuthenticationFilter O postProcessO filter filtersetCredentialsCharsetISO try to override default charset return filter Actual implementation of BasicAuthenticationFiltersetCredentialsCharset java public void setCredentialsCharsetString credentialsCharset AsserthasTextcredentialsCharset credentialsCharset cannot be null or empty thiscredentialsCharset credentialsCharset However the given credentialCharset is never used in BasicAuthenticationFilter and especially not in BasicAuthenticationFilterBasicAuthenticationConverter So the token is read with the default charset UTF and not as needed with ISO Expected Behavior Corrected BasicAuthenticationFiltersetCredentialsCharset java public void setCredentialsCharsetString credentialsCharset AsserthasTextcredentialsCharset credentialsCharset cannot be null or empty thiscredentialsCharset credentialsCharset is never used authenticationConvertersetCredentialsCharsetcredentialsCharset bugfix Version v v Currently JwtAuthenticationToken always pass one Jwt instance to super constructor AbstractOAuth TokenAuthenticationToken as token principal and credentials So that implies that all three values must always be a jwt token itself I dont see any reason why principal in JWT token must always be the token itself It already represents both token and credentials But for principal I want more flexibility an ability to also load user represented by JWT sub claim from DB or external service In my application I want to use a JWT token but I also want to create a custom class that will represent a principal like UserDetials implementation or just a new custom class AbstractOAuth TokenAuthenticationToken has a constructor that takes token principal and credentials separately It would be good if JwtAuthenticationToken also have a constructor that at least takes principal separately If this will be added then it will also be good if JwtAuthenticationConverter will have an optional property ConverterJwt Object jwtPrincipalConverter which if set will be used to convert Jwt to principal by loading it from DB external service or just by creating a more applicationfriendly User object from Jwt token before calling new JwtAuthenticationToken constructor Summary When using LDAP if a file matching ldif exists on the classpath then it should be used if no other LDIF file is specified However when using unboundid mode the file on the classpath is not picked up unless explicitly specified Sample This issue can be demonstrated using the LDAP sample with a few modifications Firstly to make the application use unboundid mode replace runtime apachedsDependencies with compile comunboundidunboundidldapsdk in the gradle file Then remove ldifclasspathusersldif from the sldapserver element The integration tests will fail Summary The documentation section ldapserver Attributes describes the default LDIF file resource as classpathldiff and gives the example classpathinitldiff Both have an incorrect extension They should instead be classpathldif and classpathinitldif respectively Related to just the reactive equivalent