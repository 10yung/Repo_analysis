 Version Context Currently you have the choice between callback hell ending with complex business code at tabulation or to rely on complex future headaches In both cases you maywill end up even with best efforts with unreadable andor unmaintainable complex business code RUST and python have support for async await syntax which basically hides this boring level of useless complexity Some JS stuff try to mitigate also this problem I assume vertx java server side critically need this I didnt find any clues about this so i open this bug Feel free to do what you want with it but i assume bypassing this may be a very bad idea for vertx Do you have a reproducer Refer to some samples like Link to github projectgist Steps to reproduce Use vertx Extra Vertx and before Hi Is it possible to extend HttpServerRequestgetParam method so it takes default value for request parameter and returns it if parameter is not there Im happy to create a PR for that Thanks Tim Hello We get rare NPEs on high load in Http xClientConnection Vertx Stacktrace javalangNullPointerException null at iovertxcorehttpimplHttp xClientConnectionStreamImplaccess Http xClientConnectionjava at iovertxcorehttpimplHttp xClientConnectionhandleResponseEndHttp xClientConnectionjava at iovertxcorehttpimplHttp xClientConnectionhandleHttpMessageHttp xClientConnectionjava at iovertxcorehttpimplHttp xClientConnectionhandleMessageHttp xClientConnectionjava at iovertxcoreimplContextImplexecuteTaskContextImpljava at iovertxcoreimplEventLoopContextexecuteEventLoopContextjava at iovertxcoreimplContextImplexecuteFromIOContextImpljava at iovertxcorenetimplVertxHandlerchannelReadVertxHandlerjava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextfireChannelReadAbstractChannelHandlerContextjava at ionettychannelCombinedChannelDuplexHandlerDelegatingChannelHandlerContextfireChannelReadCombinedChannelDuplexHandlerjava at ionettyhandlercodecByteToMessageDecoderfireChannelReadByteToMessageDecoderjava at ionettyhandlercodecByteToMessageDecoderchannelInputClosedByteToMessageDecoderjava at ionettyhandlercodecByteToMessageDecoderchannelInactiveByteToMessageDecoderjava at ionettyhandlercodechttpHttpClientCodecDecoderchannelInactiveHttpClientCodecjava at ionettychannelCombinedChannelDuplexHandlerchannelInactiveCombinedChannelDuplexHandlerjava at ionettychannelAbstractChannelHandlerContextinvokeChannelInactiveAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextinvokeChannelInactiveAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextfireChannelInactiveAbstractChannelHandlerContextjava at ionettychannelDefaultChannelPipelineHeadContextchannelInactiveDefaultChannelPipelinejava at ionettychannelAbstractChannelHandlerContextinvokeChannelInactiveAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextinvokeChannelInactiveAbstractChannelHandlerContextjava at ionettychannelDefaultChannelPipelinefireChannelInactiveDefaultChannelPipelinejava at ionettychannelAbstractChannelAbstractUnsafe runAbstractChanneljava at ionettyutilconcurrentAbstractEventExecutorsafeExecuteAbstractEventExecutorjava at ionettyutilconcurrentSingleThreadEventExecutorrunAllTasksSingleThreadEventExecutorjava at ionettychannelepollEpollEventLooprunEpollEventLoopjava at ionettyutilconcurrentSingleThreadEventExecutor runSingleThreadEventExecutorjava at ionettyutilinternalThreadExecutorMap runThreadExecutorMapjava at ionettyutilconcurrentFastThreadLocalRunnablerunFastThreadLocalRunnablejava at javabasejavalangThreadrunThreadjava Return default value instead of null if query param is not present removed unused imports Improvement based on vertxweb Currently the options to build Vertx provide a clustered boolean with the following behavior calling vertxoptions with clustered set to false builds a non clustered instance calling vertxoptions with clustered set to true throw an IllegalArgumentException calling clusteredVertxoptions with clustered set to true builds a clustered instance calling clusteredVertxoptions with clustered set to false does set clustered to true and then builds a clustered instance Given this behaviour the usefulness of this setting seems very low and instead it could be removed in Vertx with no actual impact other than not throwing an IllegalStateException when clustered is set to true and the vertxoptions method is called When I use CompositeFutureallListFuture futures its really boring to add SuppressWarningsrawtypes How about to change the argument to ListFuture futures just like that of CompositeFutureImpls And same to CompositeFutureany and CompositeFuturejoin Sorry my English is not good enough vertxcore bodyHandler It will be called twice for a sample GET request called twice for a sample submited form called twice As a result this handle will run two thousand times if a thousand people request the page And I did the following is that right var buff Bufferbuffer requesthandlerbuffer buffappendBufferbuffer requestendHandlerTODOusing endHandler inside handler When attempting to bind more than one HTTP server to different UNIX domain sockets only the first socket will be opened and all none of the others will be opened Some sample code to replicate this in Kotlin but this exact code isnt particularly important kotlin val f Filetmpf socket val f Filetmpf socket val opts VertxOptions optspreferNativeTransport true val vertx Vertxvertxopts f delete f delete val sem javautilconcurrentSemaphore semacquire vertxcreateHttpServerapply requestHandler listenSocketAddressdomainSocketAddressf canonicalPath printlnS started itsucceeded semrelease vertxcreateHttpServerapply requestHandler listenSocketAddressdomainSocketAddressf canonicalPath printlnS started itsucceeded semrelease Wait for both servers to start semacquire printlnF exists f exists printlnF exists f exists exitProcess Which outputs S started true S started true F exists true F exists false It seems having run through it with a debugger that the following fragment from HttpServerImpl is at fault java sslHelpersetApplicationProtocolsapplicationProtocols MapServerID HttpServerImpl sharedHttpServers vertxsharedHttpServers synchronized sharedHttpServers thisactualPort port Will be updated on bind for a wildcard port id new ServerIDport host HttpServerImpl shared sharedHttpServersgetid Caching issue here if shared null port serverChannelGroup new DefaultChannelGroupvertxacceptorchannels GlobalEventExecutorINSTANCE ServerBootstrap bootstrap new ServerBootstrap The servers are cached by the unique combination of their port and hostname Since domain sockets always have a host of localhost and a port of only the first socket be created and all subsequent domain sockets will be found in the map Im on Vertx and while I havent tried building from source it appears the relevant code is identical in master iovertxcoreeventbusimplclusteredClusteredEventBus SEVERE Failed to remove sub comhazelcastcoreHazelcastInstanceNotActiveException Hazelcast instance is not active at comhazelcastspiAbstractDistributedObjectthrowNotActiveExceptionAbstractDistributedObjectjava at comhazelcastspiAbstractDistributedObjectlifecycleCheckAbstractDistributedObjectjava at comhazelcastspiAbstractDistributedObjectgetNodeEngineAbstractDistributedObjectjava at comhazelcastmultimapimplObjectMultiMapProxyremoveObjectMultiMapProxyjava at iovertxspiclusterhazelcastimplHazelcastAsyncMultiMaplambdaremove HazelcastAsyncMultiMapjava at iovertxcoreimplContextImpllambdaexecuteBlocking ContextImpljava at iovertxcoreimplTaskQueuerunTaskQueuejava at javabasejavautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javabasejavautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at ionettyutilconcurrentFastThreadLocalRunnablerunFastThreadLocalRunnablejava at javabasejavalangThreadrunThreadjava It seems that the reason is that EventBusImplunregisterAll calls HandlerRegistrationunregister with null doneHandler This leads to the cluster leaving before the EventBus is shutted down Signedoffby Paulo Lopes pmlopesgmailcom This PR is a proposal to support same site policy for cookies server side only There is no parsing involved as that is a feature only applicable to browsers The Same Site policy is supported by all major browsers and a security feature to prevent cross site request forgery Although this isnt present in netty yet discussions seem to show that this will only land on the x branch which means vertx cant offer the current owasp recommendation on cookies As a workaround this PR allows users to build secure cookie based applications and once support lands upstream we can easily drop this and fully support it Also note that the chrome team will be strict with this flag 