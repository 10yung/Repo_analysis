Right now spire has a finer grained distinction of commutative rings namely the availability of gcd and lcm operations the availability of Euclidean division emod equot in the type classes GCDRing and EuclideanRing As the corresponding operations are already part of the JavaScala API for eg integers it would be natural to include them in algebra The corresponding type classes are pretty uncontroversial and map to the mathematical hierarchy Another step in the hierarchy UniqueFactorizationDomain relates to the availability of factorization into prime elements There the API is less clear For various reasons this type class is present outside the ring hierarchy in Spire and I suggest it is not included in algebra There is also the story of Signed for abs and TruncatedDivision but that should be discussed separately Right now theres AdditiveSemigroup and MultiplicativeSemigroup which are then combined into Semiring This is all well and good but unfortunately theres a huge amount of code out there written on the basis of catskernelSemigroup and its a bit of a shame we cant reuse those Especially in Spire where the various numeric types dont have Monoid instances and therefore cant be foldMaped Since in the Cats ecosystem numeric types usually come with an Additive Monoid as default I would personally love to see that convention being expanded in this project but I also understand there are some good reasons not to do that Here is some code I came up with that demonstrates how Id personally like to have it scala trait Semiring A extends CommutativeMonoid A def times A x A y A A def plus A x A y A A combinex y def zero A empty A trait Rig A extends Semiring A def one A A This comment is not about the simpler encoding discussed in I remarked that the laws structure does not follow the typeclass structure exactly For example we have tests for Lattice A with BoundedJoinSemilattice A which simply collect laws of Lattice and BoundedJoinSemilattice however the corresponding combined typeclass does not exist Combinations with DistributiveLattice A do not exist thus we have the quite obtuse fragment scala def generalizedBoolimplicit A GenBool A new LogicProperties name generalized bool parents Seq ll new LatticeProperties name lowerBoundedDistributiveLattice parents SeqboundedJoinSemilattice distributiveLattice join SomeboundedSemilatticeAjoinSemilattice meet SomesemilatticeAmeetSemilattice in the definition of generalizedBool Laws should serve as executable documentation and this goes against the spirit I dont know what is the good solution there Solution the law hierarchy follows the typeclass hierarchy Extra laws that occur when multiple types interact are proposed separately ie lattices with partial orders For this to work we need a way to merge RuleSets Solution close the hierachy by adding all combinations That would double the size of the lattice laws as every instance would have a distributive copy alongside Ill try to come up with something better with my reformulation of laws in case it does not go through Ill let this issue remind us of the problem I think that these typeclasses should go into Algebra Goals Enable use of syntax infix or postfix operators over datatypes for which Algebra typeclasses are defined when using Algera standalone doesnt require Spire or Algebird Lower priority Achieve the above without duplicating syntax code between Algebra and Cats This issue extends and links some recent gitter discussion I chose a new issue over extending because of the introduction of catskernel eg means that much discussion from the earlier issue is out of date As of Jan The most fundamental typeclasses definitions sit in catskernel Algebra builds upon them They have syntax but it lives in catscore and so arent available to Algebra Algebra defines another layer of typeclasses but without syntax Spire dependsupon and definessyntax for Algebra and CatsKernel typeclasses Algebird depends upon Algebra and Cats Kernel typeclasses and AFAICT defines some very limited syntax over them In my possibly overly idealistic view there are three problems here If you want to use catskernel or Algebra standalone you dont have any syntaxinfix operators Syntax isnt defined along with the typeclasses to which it applies ie related concerns are spaced wide apart Theres syntax code duplication between Spire CatsCore and Algebird To catch bugs such as There is a concept called the Annihilator wikipedia which basically defines the multiplicative zero of a set Heres a blog post that shows an example Annihilator Im interested in such a type class included here A sample use case would be set intersection consider the following pieces of code reflecting use of a Monoid Option Hypothetical monoid scala implicit object IntSetIntersectionMonoid extends Monoid Set Int def appenda Set Int b Set Int Set Int a intersect b def identity the universe This is impossible which is why we need the annihilator to exist def zero Set Existing monoid scala val a Set some val b none a b returns Set With annihilation scala val a Set some val b none a b returns empty set There are possibly many other examples other than set intersection that may be useful Also apologies if anything is unclear This is my first time using GitHub issues Thanks info comtwitteralgebirdAdjoinedRingSpecification ABORTED info javalangClassCastException comtwitteralgebirdIntRing cannot be cast to catskernelCommutativeGroup info at comtwitteralgebirdIntRingadditiveRingscala info at comtwitteralgebirdAdjoinedUnitRinginitAdjoinedUnitRingscala info at comtwitteralgebirdAdjoinedUnitringAdjoinedUnitRingscala info at comtwitteralgebirdAdjoinedRingSpecificationinitAdJoinedUnitRingscala info at sunreflectNativeConstructorAccessorImplnewInstance Native Method info at sunreflectNativeConstructorAccessorImplnewInstanceNativeConstructorAccessorImpljava info at sunreflectDelegatingConstructorAccessorImplnewInstanceDelegatingConstructorAccessorImpljava info at javalangreflectConstructornewInstanceConstructorjava info at javalangClassnewInstanceClassjava info at orgscalatesttoolsFrameworkScalaTestTaskexecuteFrameworkscala The code compiled but at runtime it failed This resulted from treating a Ring T as a Rng T Ill try to repro here Copied from johnyneks issue scala Gives the contract that a a a and a a a trait ConicMonoid A extends Semigroup A def ordering Ordering A trait ConicMonoid A extends Monoid A def ordering Ordering A Name from seems fromNonNegInt only needs sumNone n one is from MultiplicativeMonoid and sumN is from AdditiveMonoid so Rig fromPosInt would only need Semiring We dont have Pos or NonNeg types We could add them or add unsafe functions 