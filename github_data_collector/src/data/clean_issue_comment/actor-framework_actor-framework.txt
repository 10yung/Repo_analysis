Closes Sorry to bother you and feel free to close this issue if its not a right place for it While working with I decided that I want to handle workers using go and they use caf for connection of external programs hence I was wondering is it possible to connect to actor framework from other languages at the moment Im interested at go What I need to do this is either minimal API that will handle network layer for me or some info on wire protocol Is there docs somewhere Is it stable Sure full bindings are an option as well but go has its own actor system and it wouldnt be welcomed by community to have some threads being ran by C code and our own pool of goroutines next to it and not very efficient either I think I feel like connecting will be more idiomatic way of doing it cafuri path cafuribuilderschemefilehostlocalhostpathtmptesttest dexrmake stdcout tostringpath stdendl stdcout tostringcafmakeuritostringpath stdendl returns filelocalhosttmptesttest A dexr the second cout segfaults As far as Im aware arent valid url characters and should be escaped I suspect that is the root of the problem Also it doesnt seem to support file prefix which is valid AFAIK cheers The choose policy simply picks the first valid result for a fanout request and ignores all other responses Inbound paths call eraselater when receiving a close message This ultimately removes the queue for incoming stream traffic in WDRR queues cleanup However if this removes the final path a stream manger then the manager wont get removed from the actor This potentially delays scheduledactorcleanup forever causing the actor to never terminate Having an issue with warning C when building in level Build output removed paths with to clarify C Program Files x Microsoft Visual Studio Professional VC Tools MSVC include utility warning C initializing conversion from Ty to Ty possible loss of data with Tyint and Ty uint t include caf detail tuplevalshpp message see reference to function template instantiation stdpairuint tconst typeinfo pairintconst typeinfo Other Other noexcept being compiled with Other int Other const typeinfo include caf detail tuplevalshpp message see reference to function template instantiation stdpairuint tconst typeinfo pairintconst typeinfo Other Other noexcept being compiled with Other int Other const typeinfo include caf detail tuplevalshpp message while compiling class template member function caftypeerasedtuplerttipair cafdetailtuplevalstypehelpermipactorsClientPhysicalId getvoid noexcept include caf detail tuplevalshpp message see reference to function template instantiation caftypeerasedtuplerttipair cafdetailtuplevalstypehelpermipactorsClientPhysicalId getvoid noexcept being compiled include caf detail tuplevalshpp message see reference to class template instantiation cafdetailtuplevalstypehelpermipactorsClientPhysicalId being compiled include caf mailboxelementhpp message see reference to function template instantiation cafdetailtuplevalsimplcaftypeerasedtuplemipactorsClientPhysicalIdtuplevalsimplconst mipactorsClientPhysicalId const mipactorsClientPhysicalId being compiled include caf mailboxelementhpp message see reference to function template instantiation cafdetailtuplevalsimplcaftypeerasedtuplemipactorsClientPhysicalIdtuplevalsimplconst mipactorsClientPhysicalId const mipactorsClientPhysicalId being compiled include caf mailboxelementhpp message see reference to function template instantiation cafmailboxelementvalsmipactorsClientPhysicalIdmailboxelementvalsconst mipactorsClientPhysicalId cafstrongactorptr cafmessageidcafmailboxelementforwardingstack const mipactorsClientPhysicalId being compiled include caf mailboxelementhpp message see reference to function template instantiation cafmailboxelementvalsmipactorsClientPhysicalIdmailboxelementvalsconst mipactorsClientPhysicalId cafstrongactorptr cafmessageidcafmailboxelementforwardingstack const mipactorsClientPhysicalId being compiled include caf abstractactorhpp message see reference to function template instantiation stduniqueptrcafmailboxelementcafdetaildisposer cafmakemailboxelementconst mipactorsClientPhysicalId cafstrongactorptrcafmessageidcafmailboxelementforwardingstackT being compiled with Tconst mipactorsClientPhysicalId include caf mixin senderhpp message see reference to function template instantiation void cafabstractactoreqimplconst mipactorsClientPhysicalId cafmessageidcafstrongactorptrcafexecutionunit const mipactorsClientPhysicalId being compiled message see reference to function template instantiation void cafmixinsenderBDsendcafmessagepriorityhighcafactorconst mipactorsClientPhysicalId const Dest const mipactorsClientPhysicalId being compiled with Bcafmixinrequestercaflocalactorcafblockingactor Dcafblockingactor Destcafactor message see reference to function template instantiation void cafmixinsenderBDsendcafmessagepriorityhighcafactorconst mipactorsClientPhysicalId const Dest const mipactorsClientPhysicalId being compiled with Bcafmixinrequestercaflocalactorcafblockingactor Dcafblockingactor Destcafactor The issue seems caused by returning an int instead of a uint t in tuplevalshpp template class T struct tuplevalstypehelperT static typename messagedatarttipair get noexcept return typeidT and typeerasedvalueimplhpp static rttipair typestdintegralconstantuint t return typeidvaluetype This is phase one of the messaging overhaul see Dropping the custom atom type is the first step for refactoring the pattern matching and ultimately cafmessage Most changes are straightforward only the current iteration of BASPs named receiver feature feels quicke hacky However cafnet already provides a better way for talking to wellknown remote actors via URI path resolution Hence I think this workaround in cafio is OK since the module is going to become deprecated hopefully later this year From our blog Over the course of the last years of developing CAF we came to understand message as a variantlike type able to hold any tuple type used for actor messaging The current design can play that role but the implementation is a highly flexible container that holds arbitrary data offers views and even enables composing messages in treelike structures This flexibility comes at a cost Obvious costs through virtual dispatch but also runtime overhead for matching message handler signatures to the content of incoming messages Further because a message can essentially hold anything CAF has to include a lot of meta data in each message on the wire This increases size overhead on the wire but also makes deserializing messages costly Streamlining the messaging layer in CAF has the potential to improve performance significantly First prototypes for a new messaging layer speed up the matching of messages to handlers as well as deserializing messages by a factor of The downside of that design is that users have to enumerate all allowed types in the system We did not reach full agreement whether we want to go down that route but it would also allow CAF to better target embedded systems as the new messaging layer would no longer require RTTI and stores less meta data We can break down this vision into a series of steps Remove cafatom The concept of atoms is still useful but we can use tag types instead Drop the current iteration of uniformtypeinfomap We are going to care about userdefined type numbers only This means we can get rid of anything related to stdtypeinfo Streamline cafmessage and get rid of typeerased tuples and values Inspecting a cafmessage is costly and requires many virtual function calls All meta information were going to need is a simple list of type numbers After commit a afe b a e db f c c aa b that is related to and cafresult now have the following constructor C clangformat off template class Us class detailenableiftt detailallconstructible detailtypelistTs detailtypelistdetaildecaytUs clangformat on resultUs xs flagrtvalue value makemessageTsstdforwardUsxs Now lets consider that I have a nonserializable tape with similar gready perfectforwarding constructor that later dispatches to a set of private constructors and a serializable tapebox that can be constructed from tape instance C struct tape templatetypename Ts tapeTs ts struct tapebox tapeboxconst tape t Then returning responsepromisetapebox from message handler will fail C int value resulttapebox auto res makeresponsepromisetapebox return res compile error here because compiler tries to check if resulttapebox can be constructed from responsepromise to do that it tries to evaluate constructor taperesponsepromise and that check will succeed because tape has perfectforwarding constructor After that a compile error is produced on line value makemessageTsstdforwardUsxs because tape doesnt expect cafresponsepromise Maybe its better to whitelist predefined types like responsepromise typedresponsepromise delegated in greedy result constructor Once I run addoutboundpath none of my actors behaviors trigger anymore until Ive generated at least one event This includes the exitdown handlers of my actor which means I cannot properly shut down any more I think whats needed here is some sort of yield function for the streamsource that checks if theres anything else to do for the parent actor and then calls advance or returns to the next element handler in some other way While looking at this I also noticed that the done handler is not called when calling advance which might be a bug Relevant source code for reproduction Id like to add a if produced stmgryield below L in the linked snippet to return the control flow to the parent actor in order for it to check its exitdown handler For testing After compiling run echo vast N v debug import zeek and try quitting with SIGINT which hangs indefinitely because the source actor never checks for any exit or down messages