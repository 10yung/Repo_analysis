Closes To be honest I dont like the fact that the flock will be nil when reading databases in readonly mode A fakestub lock would be nicer Anything wanting to use flock will need to do a nil check Let me know if you have any suggestions i want to removes a database entirely removing everything from the filesystem who can tell me what i should do thanks Executing dbGetPropertyleveldbblockpool concurrently with BufferPoolGetPut will lead to data race It is probably not a big deal but definitely an inconvience during testse e simulations The easiest way to reproduce a problem is to run following test multile timeseg go test leveldbutil count runTestConcurrentReads go func TestConcurrentReadst testingT pool NewBufferPool var wg syncWaitGroup wgAdd go func poolGet wgDone go func poolString wgDone wgWait I was able to workaround this race only by coppying buffer pool state atomically including size arrays Will be glad to know if there are better options Proposal Add a Sync method to sync all records written before Sync was called to disk Motivation Currently its possible to synchronously write individual records However synchronously writing a record doesnt guarantee that previously written nonsync records will be synced they could be in a different journal When writing collections of objects its useful to be able to Write a collection of objects Sync the collection of objects Synchronously update an index over those objects Importantly the index shouldnt be updated until the objects have been synced goleveldb currently provides batches and transactions but neither seem to serve this purpose The best external solution I can think of is to write a wrapper with an inmemory write buffer However Id prefer to just write to disk and let the OS decide when to sync andor when the buffer is full Implementation Unfortunately my understanding of leveldb and goleveldb is limited My first attempt was but I didnt realize journals were rotated Given that journals are rotated the only solution I can think of is When closing a journal asynchronously fsync it before closing When the user calls Sync sync the current journal wait for all asynchronously syncing journals to finish syncing then fsync the directory When opening a finished journal for the first time fsync it in the background in the program crashed while data was still being written to disk Does this sound like itll work to optimize compaction process for cases that have frequent key updates and deletions go mod by default likes to pick the latest stable version currently thats the v branch which is missing half a years worth of commits This seems to be related to but I dont think any fix was upstreamed Expected behaviour Since I am opening the database in ReadOnly mode I would expect that a lock doesnt need to be acquired since nothing should be written However Im not sure if this is how it works in LevelDB Actual behaviour When calling OpenFile on a locked database LOCK file present with the ReadOnly database option set to true the database will fail to open On Windows Im getting The process cannot access the file because it is being used by another process Hi syndtr I merge a lot of optimize from bytesBuffer eg name old timeop new timeop delta WriteByte s s p n Alloc s s p n BufferNotEmptyWriteRead s s p n BufferFullSmallReads s s p n name old speed new speed delta WriteByte MBs MBs p n Alloc MBs MBs p n Hi syndtr There are many asynchronous Releaser holding BufferPool thus there is no deterministic chance close BufferPool We can make it is closed by GC when its reference reduce to zore