I am using FusionAuth as my OICD provider I have Angular Apps along with separate APIs call them Tools Accounts and CRM All angular apps need to actually query all APIs If I visit the Tools Angular app use OICD against FusionAuth to get my JWT the JWT that comes back is for Tools only It has the Tools app ID it has the roles in relation to the Tools app When angular hits the Tools API the API sees the proper Tools roles from the JWT all good But when the Angular app hits the Accounts API the JWT that is passed in of course is the Tools JWT with the Tools roles There are ways to handle this on the backend API code For example the Accounts API would recognize the Tools app just tried to hit it therefore go back to FusionAuth to get the roles related to the Accounts app NOT the Tools apps In other words ignore the roles found in the JWT and query FusionAuth for the right roles But there are other issues with this like logging to rd party APIs that are out of my control Those rd party APIs would be passed a JWT with roles for the Tools app not their app How do people handle this Accessing multiple APIs from a single Angular app seems very common What if angularoauth oidc could handle this When the Tools angular app is first loaded couldnt it login to all FusionAuth apps via OICD and store each access token separately in session storage Then Angular would simply inject the proper token stored in session storage based on the endpoint it was calling Now each of the tokens in session storage are for the right endpoint with the right roles for that endpoint Am I way off here I must be missing something Im not sure if this is a bug or a wrong configuration in AuthConfig I have an Angular application that authenticate towards Windows ADFS using Open Id Connect The application retrieves access token and id token via implicit flow and it works fine Problem comes when I try to refresh the token using silentRefresh as described in the documentation This is the configuration typescript const authConfig AuthConfig issuer address to adfs redirectUri windowlocationoriginindexhtml silentRefreshRedirectUri windowlocationorigin silentrefreshhtml clientId clientid scope openid email profile logoutUrl windowlocationoriginlogout tokenEndpoint adfs addressadfsoauth token loginUrl adfs addressadfsoauth authorize strictDiscoveryDocumentValidation false skipIssuerCheck true oidc true OAuthService configuration typescript private configureOauth thisoauthServiceconfigureauthConfig thisoauthServicetokenValidationHandler new JwksValidationHandler thisoauthServicesetStoragesessionStorage thisoauthServicesetupAutomaticSilentRefresh thisoauthServicetryLoginonTokenReceived context tslintdisablenextlinenoconsole consoledebuglogged in tslintdisablenextlinenoconsole consoleinfo thisoauthServicegetAccessToken tslintdisablenextlinenoconsole consoleinfo thisoauthServicegetIdToken Then to refresh the token I call typescript public triggerSilentRefresh this oauthService silentRefresh theninfo consoledebugrefresh ok info catcherr consoleerrorrefresh error err But I get the following error javascript corejs ERROR Error Uncaught in promise TypeError Cannot read property responseType of null TypeError Cannot read property responseType of null at OAuthServiceanonymous angularoauth oidcjs at Generatornext anonymou This is thrown by createLoginUrl because AuthConfig is null Snippet from chrome debugger javascript createLoginUrlstate loginHint customRedirectUri noPrompt false params return awaiterthis void void function type const that this type let redirectUri if customRedirectUri redirectUri customRedirectUri else redirectUri thisredirectUri type const nonce yield thiscreateAndSaveNonce if state state nonce thisconfignonceStateSeparator state else state nonce if thisrequestAccessToken thisoidc throw new ErrorEither requestAccessToken or oidc or both must be true if thisconfigresponseType HERE config is null thisresponseType thisconfigresponseType I do not understand how can be null if it has been initialized and I successfully retrieved my access token Is it something Im doing wrong or I have missed in the configuration OS Windows Browser ChromeFirefox version Hi I have trouble with login by initImplicitFlow call config typescript export const authConfig AuthConfig issuer redirectUri responseType idtoken token clientId clientidjs scope ApiOne silentRefreshRedirectUri postLogoutRedirectUri appcomponentts typescript constructorprivate oauthService OAuthService thisoauthServiceconfigureauthConfig thisoauthServicetokenValidationHandler new JwksValidationHandler thisoauthServiceloadDiscoveryDocumentAndTryLogin Also OAuthModule connected in appmodulets logincomponentts typescript initImplicitFlow call onSubmit void thisoauthServiceinitImplicitFlow VS logs Debug IdentityServer HostingCorsPolicyProvider CORS request made for path wellknownopenidconfiguration from origin Debug IdentityServer EntityFrameworkServicesCorsPolicyService Origin is allowed True Debug IdentityServer HostingCorsPolicyProvider CorsPolicyService allowed origin Debug IdentityServer HostingEndpointRouter Request path wellknownopenidconfiguration matched to endpoint type Discovery Debug IdentityServer HostingEndpointRouter Endpoint enabled Discovery successfully created handler IdentityServer EndpointsDiscoveryEndpoint Information IdentityServer HostingIdentityServerMiddleware Invoking IdentityServer endpoint IdentityServer EndpointsDiscoveryEndpoint for wellknownopenidconfiguration Debug IdentityServer EndpointsDiscoveryEndpoint Start discovery request Debug IdentityServer EntityFrameworkStoresResourceStore Found openid ApiOne as all scopes in database Debug IdentityServer AccessTokenValidationIdentityServerAuthenticationHandler AuthenticationScheme Bearer was not authenticated Debug IdentityServer HostingCorsPolicyProvider CORS request made for path accountlogin from origin but was ignored because path was not for an allowed IdentityServer CORS endpoint Information IdentityauthControllersAccountController User with email evgenijmerchanskygmailcom try to login Debug IdentityServer HostingIdentityServerAuthenticationService Augmenting SignInContext Debug IdentityServer HostingIdentityServerAuthenticationService Adding idp claim with value local Debug IdentityServer HostingIdentityServerAuthenticationService Adding authtime claim with value Information MicrosoftAspNetCoreAuthenticationCookiesCookieAuthenticationHandler AuthenticationScheme IdentityApplication signed in Debug IdentityServer HostingEndpointRouter Request path connectauthorize matched to endpoint type Authorize Debug IdentityServer HostingEndpointRouter Endpoint enabled Authorize successfully created handler IdentityServer EndpointsAuthorizeEndpoint Information IdentityServer HostingIdentityServerMiddleware Invoking IdentityServer endpoint IdentityServer EndpointsAuthorizeEndpoint for connectauthorize Debug IdentityServer EndpointsAuthorizeEndpoint Start authorize request Debug IdentityServer EndpointsAuthorizeEndpoint No user present in authorize request Debug IdentityServer ValidationAuthorizeRequestValidator Start authorize request protocol validation Information IdentityServer EntityFrameworkTokenCleanupService Removing grants Information IdentityServer EntityFrameworkTokenCleanupService Removing device flow codes Debug IdentityServer EntityFrameworkStoresClientStore clientidjs found in database True Debug IdentityServer StoresValidatingClientStore client configuration validation for client clientidjs succeeded Debug IdentityServer EntityFrameworkStoresResourceStore Found openid identity scopes in database Debug IdentityServer EntityFrameworkStoresResourceStore Found ApiOne API scopes in database Debug IdentityServer EntityFrameworkStoresResourceStore Found openid identity scopes in database Debug IdentityServer EntityFrameworkStoresResourceStore Found ApiOne API scopes in database Debug IdentityServer ValidationAuthorizeRequestValidator Calling into custom validator IdentityServer ValidationDefaultCustomAuthorizeRequestValidator Debug IdentityServer EndpointsAuthorizeEndpoint ValidatedAuthorizeRequest ClientId clientidjs ClientName null RedirectUri AllowedRedirectUris SubjectId anonymous ResponseType idtoken token ResponseMode fragment GrantType implicit RequestedScopes openid ApiOne State ILV RG iM u xqojQ rn NLFk LumkeJohqZtizjhd UiLocales null Nonce ILV RG iM u xqojQ rn NLFk LumkeJohqZtizjhd AuthenticationContextReferenceClasses null DisplayMode null PromptMode null MaxAge null LoginHint null SessionId null Raw responsetype idtoken token clientid clientidjs state ILV RG iM u xqojQ rn NLFk LumkeJohqZtizjhd redirecturi scope openid ApiOne nonce ILV RG iM u xqojQ rn NLFk LumkeJohqZtizjhd type AuthorizeRequestValidationLog Information IdentityServer ResponseHandlingAuthorizeInteractionResponseGenerator Showing login User is not authenticated Please can help me Describe the bug Protractor hangs for seconds when using oauthServicesilentRefresh because delay is run inside angular zone It should run outside angular zone Here is the culprit Problem description Every now and then we get errors in our backend when using this library We handle the errors correctly and redirect the user to login page That said the request doesnt make sense in the first place as the token must be expired or not present I think this can happen when the cookie to identity server expires The silent refresh then doesnt work and then we send expired token or no token at all havent verified but doesnt matter Proposed solution Dont send the request to backend when the token is not present Ideally this should come with some way on reacting to this ie redirect to login but Im not sure how this should look like It could be just an error throw inside the interceptor with some specific type so I can create my own interceptor that would catch it and trigger the redirect Or provide a way to inject a function to be executed when this happens in the module config I can look into creating a PR for this if the general idea sounds good Workaround for now Im considering to support this now on my own by providing custom session storage Describe the bug We want to use this lib in angular better in APPINITIALIZER process is there any guide or sample for this many thanks Our idea is when in app initializing process call tryLogin see if there hasValidAccessToken no valid token call the initImplicitFlow call tryLogin again Stackblitz example Provide a minimal stackblitz based example that shows the issue For this you can use the example application of this repo and the identity providers used here To Reproduce Steps to reproduce the behavior Go to Click on Scroll down to See error Expected behavior A clear and concise description of what you expected to happen Desktop please complete the following information OS eg iOS Browser eg chrome safari Version eg Additional context Add any other context about the problem here Bumps handlebars from to details summaryChangelogsummary Sourced from handlebarss changelog v November th Bugfixes fix add noprototypebuiltins eslintrule and fix all occurences f f d fix add more properties required to be enumerable Chores Build fix use instead of c b f add chai and dirtychai and sinon for cleaner testassertions and spies deprecate old assertionmethods e e ba dad a Security The properties proto defineGetter defineSetter and lookupGetter have been added to the list of properties that must be enumerable If a property by that name is found and not enumerable on its parent it will silently evaluate to undefined This is done in both the compiled template and the lookuphelper This will prevent new RemoteCodeExecution exploits that have been published recently Compatibility notes Due to the securityfixes The semantics of the templates using proto defineGetter defineSetter and lookupGetter in the respect that those expression now return undefined rather than their actual value from the proto The semantics have not changed in cases where the properties are enumerable as in js proto some string The change may be breaking in that respect but we still only increase the patchversion because the incompatible usecases are not intended undocumented and far less important than fixing RemoteCodeExecution exploits on existing systems Commits v November th Bugfixes fix use Stringfield in lookup when checking for constructor d test add fluent API for testing Handlebars c ac c Compatibility notes no incompatibility are to be expected trtable truncated details details summaryCommitssummary c c b v c d Update release notes f f d fix add noprototypebuiltins eslintrule and fix all occurences fix add more properties required to be enumerable ba testchore add chaiexpect and sinon to runtimeenvironment dad test add sinon as global variable to eslint in the specs a test add sinonjs for spies deprecate current assertions e e chore add chai and dirtychai for better test assertions c b f fix use instead of de d v Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details Describe the bug Hi Im implementing code flow on angular and is trying to get the check session to work I have set sessionChecksEnabled to true and I get a warning message in the console saying sessionChecksEnabled is activated but there is no sessionstate Ive scanned through initCodeFlow function and found out that storeSessionState were never called does that mean session check is only for implicit flow This is not a bug or an issue on this client side library itself but will still have high impact for many people using the silent token refresh Please read this Chrome will soon February change its default behavior of handling cookies In the future it will require the SameSite flag to be set explicitly to None and the Secure flag to be set too to allow the cookie to be added to certain crosssite requests If you do that common versions of Safari will barf about that To make sure all browsers are happy you set all of the affected cookies to Secure and SameSiteNone and then you add a cookie policy code shown above that can override these settings and remove the SameSite flag again for browsers that dont interpret the None value correctly There will be two options Authentication server vendor will fix this Or the projects have to fix this depending on the used solution This issue serves as an announcement for the period around the changes in Chrome so we can direct any possible duplicate issues here When useHttpBasicAuth is set to true refreshToken doesnt consider this flag and it always appends clientid and clientsecret to params instead of headers in BasicAuth Thanks