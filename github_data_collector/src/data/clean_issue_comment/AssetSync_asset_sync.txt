 needs if awsiam optionsmerge useiamprofile true end optionsmerge awsaccesskeyid awsaccesskeyid awssecretaccesskey awssecretaccesskey There was a hidden character that messed up the formatting for a block of code in the README Also this removes some trailing whitespace my editor does that automatically With Webpacker being builtin and enabled by default in current rails does it make sense to transparently default to supporting Webpacker assets if its being used Would a PR adding this to the default value of addlocalfilepaths be welcome I am deploying a rails app with webpacker on elasticbeanstalk We use assetsync so I followed the instructions in the readme for webpacker setup I added this to the configinitializersassetsync file that was generated automatically and then created the assetsyncrake file as described Now I get an error when I try to deploy rake aborted AssetSyncConfigInvalid Existing remote files is not included in the list varappondecklibtasksassetsyncrake in block in top required optrubiesruby binbundle in load optrubiesruby binbundle in main Tasks TOP assetssync See full trace by running task with trace ExecutorNonZeroExitStatus When I try to async assets with s using command AssetSyncsync or rake assetsprecompile This throw an error ExconErrorForbidden Expected Actual Forbidden exconerrorresponse body xml version encoding UTF nErrorCodeSignatureDoesNotMatchCodeMessageThe request signature we calculated does not match the signature you provided Check your key and signing methodMessage S bucket policy is Id xxx Version Statement Sid xxx Action s ListBucket Effect Allow Resource arnawss staticassets Principal Sid xxx Action s GetObject s GetObjectAcl s PutObject s PutObjectAcl Effect Allow Resource arnawss staticassets Principal How to fix this issue I experimented with the Webpacker configuration and addlocalfiles but our circumstances required a bit of tweaking In particular we have multiple web servers and want to avoid multiple asset compilation jobs and we need to work with an existing CDN configuration that looks for everything under the pathname assets This Capistrano task assumes there is a single server with the assets role and one or more with the web role After asset compilation this task downloads the Sprockets manifest sprocketsfingerprintjson and the Webpacker manifest manifestjson and uploads them to all the web servers configdeployrb set manifestdirsprockets Filejoincurrentpath public assets set manifestdirwebpacker Filejoincurrentpath public packs set manifestlocationsprockets Filejoinfetchmanifestdirsprockets sprocketsjson set manifestlocationwebpacker Filejoinfetchmanifestdirwebpacker manifestjson after compileassets copymanifests desc Download manifest files from asset compilation server and upload them to other web servers task copymanifests do on rolesassets do withinsharedpath do i sprockets webpacker each do type executerm f fetchmanifestpathtype setmanifestpathtype capturels t fetchmanifestlocationtype head n setmanifestfilenametype fetchmanifestpathtypesplitlast downloadfetchmanifestpathtype tmpfetchmanifestfilenametype end end withincurrentpath do rakewebpackerupload end end on rolesall do withinsharedpath do i sprockets webpacker each do type executerm rf Filejoinfetchmanifestdirtype uploadtmpfetchmanifestfilenametype fetchmanifestpathtype end end end end The Rake task we invoke here is used to upload the transpiled asset packs to our desired location on S We also need to modify the manifest itself so that it prepends the assets string to the filename libtaskswebpackerrake namespace webpacker do desc Upload webpacker files to S asset host task upload do s AwsS Clientnew file Railsrootjoinpublic packs manifestjson payload JSONparseFilereadfile payloadeach do key filename filenamegsubr A target assetsfilename payload key target next if s listobjectsbucket S ASSETSBUCKET prefix targetcontentsany body FilereadRailsrootjoinpublic filenamegsub s putobjectacl publicread body body bucket S ASSETSBUCKET key target end Fileopenfile w f fputspayloadtojson end end Its a bit brittle and Id like it to be more configurable and transparent but it does whats required Hi I dont see any proper way to upload files with encryption enabled Cf We monkeypatched our app for now with notice the encryption AES ruby Enable S encryption AES module AssetSync class Storage def uploadfilef TODO output files in debug logs as asset filename only oneyear ext Fileextnamef mime MultiMimelookupext gzipfilehandle nil filehandle Fileopenpathf file key f body filehandle public true contenttype mime encryption AES uncompressedfilename fsub gz z basename Filebasenameuncompressedfilename Fileextnameuncompressedfilename assetstocachecontrol Regexpunion REGEXPASSETSTOCACHECONTROL configcacheassetregexpssource if basenamematchRegexpnewassetstocachecontrolpresent filemerge cachecontrol public maxageoneyear expires CGIrfc dateTimenow oneyear end overwrite headers if applicable you probably shouldnt specific keybody but cachecontrol headers etc if fileswithcustomheadershaskey f filemerge fileswithcustomheaders f log Overwriting f with custom headers fileswithcustomheaders f tos elsif key selfconfigcustomheaderskeysdetect k fmatchRegexpnewk headers selfconfigcustomheaders key each do k value headers ktosym value end filemerge headers log Overwriting matching file f with custom headers headerstos end gzipped pathfgz ignore false if configgzip Fileextnamef gz Dont bother uploading gzipped assets if we are in gzipcompression mode as we will overwrite filecss with filecssgz if it exists log Ignoring f ignore true elsif configgzip Fileexistgzipped originalsize Filesizepathf gzippedsize Filesizegzipped if gzippedsize originalsize percentage gzippedsizetoforiginalsizetof round gzipfilehandle Fileopengzipped filemerge key f body gzipfilehandle contentencoding gzip log Uploading gzipped in place of f saving percentage else percentage originalsizetofgzippedsizetof round log Uploading f instead of gzipped compression increases this file by percentage end else if configgzip Fileextnamef gz set content encoding for gzipped files this allows cloudfront to properly handle requests with AcceptEncoding uncompressedfilename f ext Fileextnameuncompressedfilename mime MultiMimelookupext filemerge contenttype mime contentencoding gzip end log Uploading f end if configaws configawsrrs filemerge storageclass REDUCEDREDUNDANCY end bucketfilescreate file unless ignore filehandleclose gzipfilehandleclose if gzipfilehandle end end end Regards In some environments lookup of mime type fails with one library but succeeds with another library For instance in my Rails app lookup of svg succeeds only when RackMime is used ruby prymain ext svg svg prymain definedMimeTypes nil prymain MimeTypelookupbyextensionext nil prymain RackMimemimetypeext imagesvgxml I think we should check all libraries until lookup succeeds This patch will introduce such a checking Related to I am getting Expected Actual Bad Request error while precompilation I have posted all the details on the stackoverflow Please have a look I have gotten IAM working but the permissions in the example are quite expansive Is there a more restricted list of policies that can be implemented