I have a Django project that use djangoimportexport which in turn uses tablib After some upgrades pipcompile U follow by pipsync I am getting issue with Django managepy runserver Watching for file changes with StatReloader Performing system checks Exception in thread djangomainthread Traceback most recent call last File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplateutilspy line in getitem return selfengines alias KeyError django During handling of the above exception another exception occurred Traceback most recent call last File Usersredactedpyenvversions libpython threadingpy line in bootstrapinner selfrun File Usersredactedpyenvversions libpython threadingpy line in run selftargetselfargs selfkwargs File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangoutilsautoreloadpy line in wrapper fnargs kwargs File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangocoremanagementcommandsrunserverpy line in innerrun selfcheckdisplaynumerrorsTrue File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangocoremanagementbasepy line in check includedeploymentchecksincludedeploymentchecks File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangocoremanagementbasepy line in runchecks return checksruncheckskwargs File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangocorechecksregistrypy line in runchecks newerrors checkappconfigsappconfigs File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangocontribadmincheckspy line in checkdependencies for engine in enginesall File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplateutilspy line in all return self alias for alias in self File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplateutilspy line in listcomp return self alias for alias in self File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplateutilspy line in getitem engine engineclsparams File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplatebackendsdjangopy line in init options libraries selfgettemplatetaglibrarieslibraries File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplatebackendsdjangopy line in gettemplatetaglibraries libraries getinstalledlibraries File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplatebackendsdjangopy line in getinstalledlibraries for name in getpackagelibrariespkg File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotemplatebackendsdjangopy line in getpackagelibraries module importmoduleentry File Usersredactedpyenvversions libpython importlibinitpy line in importmodule return bootstrapgcdimportname level package level File frozen importlibbootstrap line in gcdimport File frozen importlibbootstrap line in findandload File frozen importlibbootstrap line in findandloadunlocked File frozen importlibbootstrap line in loadunlocked File frozen importlibbootstrapexternal line in execmodule File frozen importlibbootstrap line in callwithframesremoved File Usersredactedpyenvversionsredactedlibpython sitepackagesrestframeworktemplatetagsrestframeworkpy line in module from restframeworkrenderers import HTMLFormRenderer File Usersredactedpyenvversionsredactedlibpython sitepackagesrestframeworkrendererspy line in module from djangotestclient import encodemultipart File Usersredactedpyenvversionsredactedlibpython sitepackagesdjangotestclientpy line in module from djangotest import signals File frozen importlibbootstrap line in findandload File frozen importlibbootstrap line in enter File frozen importlibbootstrap line in acquire frozenimportlibDeadlockError deadlock detected by ModuleLockdjangotestsignals at I have managed to narrow down the issue which is due to the missing backportscsv dependency is missing which pipcompile generate dependency for tablib If I manually install the backportscsv then everything is working again I am not sure if the omission of backportscsv was on purpose for tablib or was it a bug Or maybe this bug report should be with djangoimportexport Thank you As part of Ive added disabled calls to flake including a commentedout installation of the flake black and flake isort plugins I would suggest to run black and isort once over the code base and enabling both plugins to have a positive longterm effect on code quality I didnt make this part of since its not a hard requirement for Jazzband projects yet but Ive seen more and more projects move to that strategy Using tablib version The issue is with Control Characters and Surrogates Steps to reproduce py from tablib import Dataset dataDatasetu x f dataexportxlsx Stack Trace IllegalCharacterErrorTraceback most recent call last ipythoninput b f ff in module from tablib import Dataset dataDatasetu x f dataexportxlsx srvjupyterlocallibpython sitepackagestablibcorepyc in exportself format kwargs raise UnsupportedFormatFormat cannot be exportedformatformat return exportsetself kwargs srvjupyterlocallibpython sitepackagestablibformatsxlsxpyc in exportsetdataset freezepanes wstitle datasettitle if datasettitle else Tablib Dataset dsetsheetdataset ws freezepanesfreezepanes stream BytesIO srvjupyterlocallibpython sitepackagestablibformatsxlsxpyc in dsetsheetdataset ws freezepanes cellvalue unicodes col errorsignore except TypeError cellvalue unicodecol srvjupyterlocallibpython sitepackagesopenpyxlcellcellpyc in valueself value def valueself value Set the value and infer type and display options selfbindvaluevalue property srvjupyterlocallibpython sitepackagesopenpyxlcellcellpyc in bindvalueself value elif isinstancevalue STRINGTYPES value selfcheckstringvalue selfdatatype selfTYPESTRING if lenvalue and valuestartswith srvjupyterlocallibpython sitepackagesopenpyxlcellcellpyc in checkstringself value value value if nextILLEGALCHARACTERSREfinditervalue None raise IllegalCharacterError return value IllegalCharacterError It took me quite a while to figure out how to use Datasetsubset The documentation states the interface is subsetrowsNone colsNone so my first assumption was to just pass two ints for the number of requested rows and columns and when that didnt work I passed a list of column indices but also to no avail Only after debugging I finally found out that I first need to define column headers for the Dataset instance and then pass a subset of these headers to cols In my opinion this could be made more clearly in the documentation Also is there a reason why headers are required and we cannot alternatively just pass column indices I would go ahead and try to implement that myself if you dont mind How does the cell width adapt I thought I would open an issue to gauge interest in a terminal plain text formatter This possible formatter would print or read data from space padded plain text python import tablib data tablibDataset dataheaders firstname lastname dataappendJohn Adams dataappendGeorge Washington print dataexporttxt firstname lastname John Adams George Washington If you think this is useful and fits with the philosophy of the project I could put together a PR There are definitely some differences between this and some of the other formatters including how wide should it print by default if the data is wider than the width there will be data truncation this cant really losslessly handle outputting and then reading a dataset will result in differences data with spaces at the beginning or end Readwrite CSVW Read CSVW Write CSVW CSVW Homepage Standard Standard Standard Standard Standard Namespace xmlns prefix csvw context CSVW CSV on the Web is a set of relatively new standards for representing CSV rows and columns as RDF and JSON JSONLD along with metadata URIs for datatypes XSD URIs for columns RDF Document Metadata CSV JSON JSONLD RDF CSV RDF Hi for XLSX format databook sheet title must be below characters If it is longer you get a warning about a corrupted file when trying to open such file in Microsoft Excel the original MS Excel from MS Office package Attached is out file and a minimal nonworking code example python import tablib parentdata tablibDatabook data tablibDataset collection of names names Kenneth Reitz Bessie Monke for name in names split name appropriately fname lname namesplit add names to Dataset dataappend fname lname datatitle parentdataaddsheetdata x opentestxlsx wb xwriteparentdataxlsx xclose This is the out file that I got on Python and tablib testxlsx When I change the dataset title length to below characters everything goes back to normal Part of the code python datatablibDatasetheaders userIduserPhone phone address for item in respdata orderiduserphoneaddressitemgetiditemgetuserPhoneitemgetphoneitemgetcontactgetaddress printdatabaseuserphoneaddress if not address continue dataappend orderiduserphoneaddress with opendata xls wb as f fwritedataxls Part of the print python orderwaimai orderwaimai orderwaimai orderwaimai orderwaimai orderwaimai orderwaimai orderwaimai orderwaimai C orderwaimai orderwaimai Part of the excel tablib summarize I am sure that have carefully checked the print data no empty data lines and empty databug export data to the excel there are a lot of empty lines and empty cells Finally I had to use openpyxl to solve the problem Hello Ive been using tablib indirectly through records to produce some Excel reports from a database and Ive noticed that while I add my content in a specific order when exporting the order of the columns is not the same as I added Looking at the documentation of tablib if the examples are not merely illustrative this should be noticeable as for instance when exporting to JSON YAML and CSV the output columns are reordered differently for each format python print datajson lastname Adams age firstname John lastname Ford age firstname Henry print datayaml age firstname John lastname Adams age firstname Henry lastname Ford print datacsv firstnamelastnameage JohnAdams HenryFord Id appreciate if this could be fixed in such way that output would always have the same structure as what was inputted Thanks 