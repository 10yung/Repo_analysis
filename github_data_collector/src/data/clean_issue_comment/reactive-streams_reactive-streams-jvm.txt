I am sure I must have a problem in my pomxml or similar If I override any number of tests and run them individually every test works When I run them as a suite I get or so failures See the overrides commented out here If I test as follows it passes mvn DtestStreamPublisherCompatibilityTestrequiredspec mustSupportACumulativePendingElementCountUpToLongMaxValue clean test If I test as follows it fails several tests mvn DtestStreamPublisherCompatibilityTest clean test I have attempted to adjust the timeouts to allow potentially slow tests but it makes no difference Any pointers in running TestNG or whatever is much appreciated When the publisher is subscribed to and an onSubscribe signal is to be scheduled the executor can reject the drain task It appears that tryScheduleToExecute anticipates this failure but it assumes that the subscribers onSubscribe has been called and calls onError directly As stated above this might not be the case For example the following tck test fail java Test public class AsyncIterablePubisherTest extends PublisherVerificationLong public AsyncIterablePubisherTest supernew TestEnvironment Override public PublisherLong createPublisherlong elements return new AsyncIterablePublisherLongStreamrange elementsiterator ForkJoinPoolcommonPool Override public PublisherLong createFailedPublisher return new AsyncIterablePublisherListof L L L r throw new RejectedExecutionExceptionSorry but Im really busy The failed tests are optionalspec mustSignalOnErrorWhenFails and requiredspec mayRejectCallsToSubscribeIfPublisherIsUnableOrUnwillingToServeThemRejectionMustTriggerOnErrorAfterOnSubscribe I think simply using a subscribed flag fixes the issue The flag is set to true in doSubscribe and checked in terminateDueToError passing a NOOP subscription downstream if not set But Im interested as to what really should happen on that case when the executor throws Doesnt this mean that the publisher can no longer hold the contract of passing downstream signals on the supplied executor Shouldnt this be considered as fatal and the subscription should indicate that by rethrowing Ive skimmed through Java s SubmissionPublisher and it looks like any RuntimeException or Error thrown from the executor is directly rethrown after cancelling the subscription Im interested to know what is the wisest thing to do as im implementing an async publisher with a similar setup Thanks for any help in advance The examples do not compile Instead of createSubscriber the classes need to implement createFlowSubscriber There are still some issues left The examples in the documentation regarding black box and white box testing for subscribers dont compile I could fix a couple of small issues and we could discuss a bigger change required to have a real example and put it in another ticket There are two tests in SubscriberBlackboxVerification that verify conformance to Rule SubscriberonComplete and SubscriberonErrorThrowable t MUST NOT call any methods on the Subscription or the Publisher I can see that this is done by examining the call stack looking for the specific methods names java final Subscription subs new Subscription Override public void requestlong n Throwable thr new Throwable for StackTraceElement stackElem thrgetStackTrace if stackElemgetMethodNameequalsonError envflopStringformatSubscriptionrequest MUST NOT be called from SubscriberonError Rule Caller ss line d stackElemgetClassName stackElemgetMethodName stackElemgetLineNumber Override public void cancel Throwable thr new Throwable for StackTraceElement stackElem thrgetStackTrace if stackElemgetMethodNameequalsonError envflopStringformatSubscriptioncancel MUST NOT be called from SubscriberonError Rule Caller ss line d stackElemgetClassName stackElemgetMethodName stackElemgetLineNumber It seems to do the job however the approach might be brittle The reason is that approach is not specific enough It might produce false positives as it disregards the objects on which onError and onComplete are called A method can be similarly named but otherwise unrelated Or the method can be called on a different Subscriber ie calling subscription cancel from subscriber onComplete Could a ThreadLocalBoolean flag solution be any better Before calling onError on onComplete on Subscriber the test sets that flag Upon exit from those methods the flag is cleared Inside Subscriptions cancel and requestlong the flag is being checked java Override public void runBlackboxTestStage stage throws InterruptedException triggerRequeststagesubProxysub final long requested stageexpectRequest assuming subscriber wants to consume elements final long signalsToEmit Mathminrequested protecting against Subscriber which sends ridiculously large demand should cope with up to requested number of elements for int i i signalsToEmit sampleIsCancelledstage i i stagesignalNext we complete after signalsToEmit which can be less than requested which is legal under stagesendCompletion In order to allow some skid and not check state on each iteration only check code stageisCancelled every code checkIntervalth iteration private boolean sampleIsCancelledBlackboxTestStage stage int i int checkInterval throws InterruptedException if i checkInterval return stageisCancelled else return false I have a question about the use of the sampleIsCancelled method in the snippet above It seems strange that the for loop uses that methods naked return value rather than a negation thereof As far as I can see in the typical scenario it leads to the loops body being executed at most once Was it by design Question Currently Reactive Streams dependency has a license of CC Issue Due to some reason the place where I work have some legal issue with the license Main concern regarding the license is that patent rights are expressly reserved The license is only for copyright which eventually creates a risk of an IP claim Is there any way if reactivestreams can be offered under Apache license Based on Supplier for the case you dont know the count of elements for example streaming from a file etc Publisher is controlled by the null value enf of stream I think the following tests could be meaningfully implemented untestedspec mustNotEmitFurtherSignalsOnceOnErrorHasBeenSignalled Ask for a error publisher let it fail then request and check for no further events untestedspec possiblyCanceledSubscriptionShouldNotReceiveOnErrorOrOnCompleteSignals Ask for a length Publisher and cancel from within onSubscribe then see if onComplete was emitted or not If not pass the test if it was emitted skip the test Ask for a length Publisher cancel in onNext after the first item etc Ask for an error Publisher and cancel from within onSubscribe etc Also it depends on 