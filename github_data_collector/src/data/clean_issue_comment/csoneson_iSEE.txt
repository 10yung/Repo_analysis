Working with several biological collaborators using iSEE a few things came up as musthaves to make iSEE a part of their regular routine Amongst them one feature that would be a gamechanger would be the ability to generate high quality PNGsPDFs directly from the interface itself Dear all First of all thank you very much for this great app I am trying to save my iSEE session using bookmarking in shiny Although some plots are recovered correctly redim plot and column plot the heatmap is not The values of heatMapColData and heatMapCenterScale are correctly recovered but not so for the heatMapFeatName I was debugging the observeEvent see below and the issue is that when I restore the session my stateinputheatMapPlot FeatName has the right values the ones I saved before but in the observeEvent the input heatMapPlot FeatName has the value the app had at startup and not the saved value However it is even weirder that for heatMapColData and heatMapCenterScale I do get the saved values Do you know why this could happen Is there anything special with the heatMapPlot FeatName widget Saving listbased values for field in cheatMapColData heatMapFeatName heatMapCenterScale local id id mode heatMapPlot field field plotname paste mode id curfield paste plotname field observeEventinput curfield existing pObjectsmemory mode field id incoming asinput curfield typeofexisting if identicalincoming existing returnNULL pObjectsmemory mode updatelistelementpObjectsmemory mode id field incoming rObjects plotname incrementcounterisolaterObjects plotname ignoreInitTRUE ignoreNULLfield heatMapFeatName ignoreNULL necessary for FeatName where updateSelectize generates a temporary NULL this would trigger rerendering of the plot upon rerendering of the UI These are the onBookmark and the onRestore functions I use in the server onBookmarkfunctionstate statevaluesse se when I restore my session all the input values for the widgets are automatically recovered If I print the values of the widget heatMapPlot FeatName it also has the values I saved onRestorefunctionstate printstateinputheatMapPlot FeatName This is a major refactor whereby we will use S classes and methods to define observers and UI elements for each panel type This has a number of obvious benefits Improved reuse of shared methods via inheritance eg reduced dimension plots feature assay plots and column data plots can be implemented as subclasses of column dot plots Exploit S dispatch to provide paneltypespecific behavior while simplifying the code in iSEE this moves simplifies the main app and improves the linking of the logic with the panel type Enable easy extensions to new panel types by subclassing an existing panel type and modifying one or more methods as desired This includes support for custom UI elements a la Careful implementation can resolve a host of issues where the state is fully captured by a list of Panel objects where the construction of a Panel object does its own validity checks if we have a more systematic naming convention based on the class names This PR will be considered complete when All panels are represented by S classes Initial state and memory are represented as a list of instances of those classes There is a welldefined API for extension with a new panel type Description Hinton plots for one category alone are not brushable Reproducing this with allen libraryiSEE exampleiSEE ask FALSE Select any categorical variable eg CoreType with shiny img width altimage src with shiny img width altimage src See how brushing does nothing but drag the image Now trying to hunt down what it could be due to in a related issue at the end it is mentioned a jsonrelated issue Would somewhat fit with the message showing up in the console Input to asJSONkeepvecnamesTRUE is a named vector In a future version of jsonlite this option will not be supported and named vectors will be translated into arrays instead of objects If you want JSON object output please use a named list instead See toJSON Shall we ping one of the main persons in the Shiny team JoeCarson How about wrapping all the settings DataFrames into a single object of class eg iSEEParam Some pros and cons the call to iSEE could be more compact if we separate the configuration of individual panels from more general app arguments we could give users getters and setters more convenient than the current and nested list tricks to set values Setters would also allow us to enforce validity checks to further help users avoid invalid values Maintenance I would really like to avoid the need for updateObject or users saving the configuration object as RDS We need to make sure users are encouraged to continue saving their configuration as R scripts Concept code Separate definition of iSEE parameters isp iSEEParams redDimArgs NULL colDataArgs NULL featAssayArgs NULL rowStatArgs NULL rowDataArgs NULL sampAssayArgs NULL colStatArgs NULL customDataArgs NULL customStatArgs NULL heatMapArgs NULL redDimMax colDataMax featAssayMax rowStatMax rowDataMax sampAssayMax colStatMax customDataMax customStatMax heatMapMax initialPanelsNULL which in our current examples would generally be as short as isp iSEEParamsredDimArgs redDimArgs initialPanels initialPanels Shorter call to iSEE iSEE functionse ISEEParam isp annotFunNULL customDataFunNULL customStatFunNULL customSendAllFALSE colormapExperimentColorMap tourNULL appTitleNULL runLocalTRUE voiceFALSE Getters setters redDimPlotArgsisp DataFrame redDimPlotArgisp index fieldXAxis L colDataPlotArgisp index fieldColorBy Column data Hi Is there a way to make a custom function that does not use an interactive selection but instead uses the row names or column names to select from The DataFrames generated by the panel status dropdown are named like redDimPlotArgs which is all well and good but the iSEE arguments are named redDimArgs We should probably keep consistency with one or the other I would favor redDimPlotArgs in all cases as this is more explicit but it would break existing code that used redDimArgs A question from a presentation I gave Things that immediately pop in mind to be careful about do point selections behave well in the transformed space such checkboxes should be disabledhidden in the presence of negative values on that axis For every parameter we define a triple of parametername defaultvalue validityfunction We then go through this definition to recreate the various Defaults functions as well as some new IsValid functions This means we have to define this triplet exactly once every time we add a new argument avoiding scenarios where we add a new argument but forget to define its validity method Will this run from a remote cluster Two use cases I have a very large dataset and cantdont want to analyse it on my local laptopdesktop Will I be able to access the shiny app locally through ssh port forwarding or similar the rmote pkg by Ryan Hafen is a good examplemotivation there I produce a dataset for my biological collaborator on my institutes cluster The dataset is too big to transferthey dont have the setup to run iSEE locally on this big dataset Can I make the app available for them to access through a browser Could we do the above but from a cloud environment AWSGCP etc This would be great for exploring HCA data which will end up on all of those platforms