 Motivation I needed a way to project camera coordinates to world coordinates to be able to pick tiles using the mouse in a tile based game with a moving camera In order to do so I needed to project the screen space coordinates into the world using the current Transformation Solution Add the following methods to coffeegraphicsTransformation rust pub fn project self point Point Point pub fn unproject self point Point Point Further Work Possible Improvements Get the inverse matrix in an infallible way rust let inversemat self tryinverseunwrap Good morning I have a small question about texture rendering I want to create a fading effect where a texture get more transparent the more you zoom in to it Sadly I cant find a function for that Is it currently possible to draw a texture with a set alpha value Ive also taken a look at some other tickets and I found this one Would it maybe be possible to add a fading effect with the color attribute if it would be implemented Keep up the good work this is an awesome crate For an ui element made out of graphicsCanvas is it better to build a new uiCanvas make it so that uiImage can accept either graphicsImage or graphicsCanvas make it so that theres a Drawable trait that has fn drawQ IntoQuad self quad Q target mut Target so that uiImage accepts a dyn Drawable trait object is the most logical given the way the library is currently laid out but involves duplication But I think uiImage shouldnt care whether its displaying an image or a canvas so sounds better seems like a big departure from the way the lib is currently designed but Im curious on why coffee doesnt provide such trait already Itd be good if we could get access to setcursorvisible and setcursoricon of winitWindow This should be fairly simple to do once is merged in hecrj Id be happy to work on this if you are OK with this addition I was thinking we could just add these two methods in graphicsWindow which would just call the winitWindow methods For the CursorIcon enum I am guessing wed want to have an enum in coffee that maps one to one with the winitwindowCursorIcon since it doesnt look like winit is exposed to the consumers of this crate at all If you have other ideas I am happy to follow them as well just let me know if youre interested For context the reason I am interested in these methods is to be able to show a different icon in specific cases Although setcursoricon would be enough to show the standard cursor icons I believe setcursorvisible is necessary to completely hide it to show a custom icon I dont know which one Ill go with yet but I think someone else might also find use for one or the other Furthermore a lot of games do hide the mouse icon completely so the visibility control would be necessary for that as well I submitted to avoid copying the buffer every time I submit a texture to the gpu but it turns out that each gpu backend receives a imageDynamicImage and performs another copy anyway well one copy is better than two but still on the gfx backend it always performs a copy even if the image already is rgba on the wpu backend it always performs a copy too even if its already gbra also why do the two backends use a different color order for textures For the opengl backend I cant find it Well its unavoidable to perform copies if the image isnt the right format but it can be avoided if it is But copying on some backends and not on others doesnt sound good so Im not sure if theres something that can be done Anyway my point of view is the more optimized coffee is the more people can get away with poorly optimized game code I note that Game has the following methods rust fn interact mut self input mut SelfInput window mut Window fn update mut self window Window But loadTaskrun can only be called if I have mut Window so I can only call it on interact not on update Is this by design Is the rationale on that written somewhere I suppose that since Gameupdate can potentially be called more times than Gameinteract it might not allow calling Taskrun because it would be expensive However what if Im procedurally generating GPU assets on Gameupdate and want to send it to the GPU ASAP Should I store it somewhere and wait for the next Gameinteract this looks ugly Currently we only have a simple Mesh test as an integration test for our graphics module You can find a bit more context about this in and We should write additional graphics tests until we cover a considerable amount of current functionality This will allow us to control regressions ifwhen we change the graphical backends I currently have the following really basic function rust fn rectfromtilemapcoordx u y u tilesize Optionu Rectangleu let tilesize tilesizeunwrapor let x max x let y max y return Rectangle x tilesize x x y tilesize y y width tilesize height tilesize Which is basically a really hacky way to get a Rectangle that represents an area of a spritesheet Im likely to create an enum of all the sprites in the spritesheet but I was wondering if there was some better way to do this in the actual engine A SpriteSheet that wraps an Image and takes grid coords rather than a quad maybe Or some way to load a spritesheet from which you can get the source rectangle for a given sprite It may be that the best way to do it is indeed for me to create myself a tilemap class that the renderer owns and have an enum that the renderer knows how to convert into a rectangle but I thought Id bring this up After was released different folks suggested me to build a standalone crate for the brand new ui module I thought it was a really good idea If folks use it it would allow for cooperation between different game engines and UI applications to build better GUIs using Rust And so Iced is here A D rendereragnostic GUI library focused on simplicity and typesafety There is a long road ahead but it is already usable This PR rewrites the ui module to integrate it with the upcoming first release of Iced while avoiding breaking changes No examples were broken during this process Depends on Changed The Windowwidth and Windowheight methods now return a u This avoids many awkward conversions in user code Pending work Wait until the new ProgressBar and Image widgets are merged into Iced Rewrite documentation Wait for winit to implement RedrawRequested improvements Iced OS Win Version cratesio Just minimized the example project opengl debug feat and it crashed with the following error thread main panicked at The left corner must not be equal to the right corner C Users USER cargo registry src githubcom ecc db ec nalgebra src geometry orthographicrs stack backtrace backtracebacktracetraceunsynchronized at C Users VssAdministrator cargo registry src githubcom ecc db ec backtrace src backtrace modrs stdsyscommonbacktraceprint at rustceae dfe e afdc f a d ddf b src libstd syscommon backtracers stdsyscommonbacktraceprint at rustceae dfe e afdc f a d ddf b src libstd syscommon backtracers stdpanickingdefaulthookclosure at rustceae dfe e afdc f a d ddf b src libstd panickingrs stdpanickingdefaulthook at rustceae dfe e afdc f a d ddf b src libstd panickingrs stdpanickingrustpanicwithhook at rustceae dfe e afdc f a d ddf b src libstd panickingrs stdpanickingbeginpanicstr at rustceae dfe e afdc f a d ddf b src libstd panickingrs nalgebrageometryorthographicOrthographic f new at C Users USER cargo registry src githubcom ecc db ec nalgebra src geometry orthographicrs nalgebrabasematrixMatrixf nalgebrabasedimensionU nalgebrabasedimensionU nalgebrabasearraystorageArrayStoragef nalgebrabasedimensionU nalgebrabasedimensionU neworthographic at C Users USER cargo registry src githubcom ecc db ec nalgebra src base cgrs coffeegraphicstransformationTransformationorthographic at C Users USER cargo registry src githubcom ecc db ec coffee src graphics transformationrs coffeegraphicstargetTargetnew at C Users USER cargo registry src githubcom ecc db ec coffee src graphics targetrs coffeegraphicswindowframeFrameastarget at C Users USER cargo registry src githubcom ecc db ec coffee src graphics window framers coffeegraphicswindowframeFrameclear at C Users USER cargo registry src githubcom ecc db ec coffee src graphics window framers exampleguiimpldraw at client src guirs coffeegameGamerunexampleguiMyGame at C Users USER cargo registry src githubcom ecc db ec coffee src gamers exampleguistart at client src guirs examplemain at client src mainrs stdrtlangstartclosure at rustceae dfe e afdc f a d ddf b src libstd rtrs stdrtlangstartinternalclosure at rustceae dfe e afdc f a d ddf b src libstd rtrs stdpanickingtrydocallclosurei at rustceae dfe e afdc f a d ddf b src libstd panickingrs panicunwindrustmaybecatchpanic at rustceae dfe e afdc f a d ddf b src libpanicunwind librs stdpanickingtry at rustceae dfe e afdc f a d ddf b src libstd panickingrs stdpaniccatchunwind at rustceae dfe e afdc f a d ddf b src libstd panicrs stdrtlangstartinternal at rustceae dfe e afdc f a d ddf b src libstd rtrs main invokemain at d agent work s src vctools crt vcstartup src startup execommoninl scrtcommonmainseh at d agent work s src vctools crt vcstartup src startup execommoninl BaseThreadInitThunk RtlUserThreadStart error process didnt exit successfully target debug exampleexe exit code I guess this can be solved in here 