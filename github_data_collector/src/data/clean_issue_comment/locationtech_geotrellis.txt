I reported this on Gitter thinking it was a data issue but I just ran the included VectorizeSpecscala test with a similar failure The test in question is itshould handle a usersubmitted problem tile Vectorization with EightNeighbors fails for many of our tiles while succeeding for a few There seems to be some connection to the tile size With tile size or greater all tiles fail vectorization With tile size out succeed and the rest fail The included test with a tile size of fails when changing regionConnectivity to EightNeighbors The error from the included test is javalangArrayIndexOutOfBoundsException at geotrellisrasterIntConstantNoDataArrayTileapplyIntArrayTilescala at geotrellisrasterArrayTilegetArrayTilescala at geotrellisrasterregiongroupRegionGroupapplyRegionGroupscala at geotrellisrastervectorizeVectorizeapplyVectorizescala at geotrellisrastervectorizeTileVectorizeMethodstoVectorTileVectorizeMethodsscala at geotrellisrastervectorizeTileVectorizeMethodstoVectorTileVectorizeMethodsscala at geotrellisrastervectorizeImplicitswithSinglebandVectorizeMethodstoVectorImplicitsscala at geotrellisrastervectorizeVectorizeSpecanonfunnew VectorizeSpecscala at orgscalatestOutcomeOfoutcomeOfOutcomeOfscala at orgscalatestOutcomeOfoutcomeOfOutcomeOfscala at orgscalatestOutcomeOfoutcomeOfOutcomeOfscala at orgscalatestTransformerapplyTransformerscala at orgscalatestTransformerapplyTransformerscala at orgscalatestFunSpecLikeanon applyFunSpecLikescala at orgscalatestTestSuitewithFixtureTestSuitescala at orgscalatestTestSuitewithFixtureTestSuitescala at orgscalatestFunSpecwithFixtureFunSpecscala at orgscalatestFunSpecLikeinvokeWithFixture FunSpecLikescala at orgscalatestFunSpecLikeanonfunrunTest FunSpecLikescala at orgscalatestSuperEnginerunTestImplEnginescala at orgscalatestFunSpecLikerunTestFunSpecLikescala at orgscalatestFunSpecLikerunTestFunSpecLikescala at orgscalatestFunSpecrunTestFunSpecscala at orgscalatestFunSpecLikeanonfunrunTests FunSpecLikescala at orgscalatestSuperEngineanonfunrunTestsInBranch Enginescala at scalacollectionimmutableListforeachListscala at orgscalatestSuperEnginetraverseSubNodes Enginescala at orgscalatestSuperEnginerunTestsInBranchEnginescala at orgscalatestSuperEngineanonfunrunTestsInBranch Enginescala at scalacollectionimmutableListforeachListscala at orgscalatestSuperEnginetraverseSubNodes Enginescala at orgscalatestSuperEnginerunTestsInBranchEnginescala at orgscalatestSuperEnginerunTestsImplEnginescala at orgscalatestFunSpecLikerunTestsFunSpecLikescala at orgscalatestFunSpecLikerunTestsFunSpecLikescala at orgscalatestFunSpecrunTestsFunSpecscala at orgscalatestSuiterunSuitescala at orgscalatestSuiterunSuitescala at orgscalatestFunSpecorgscalatestFunSpecLikesuperrunFunSpecscala at orgscalatestFunSpecLikeanonfunrun FunSpecLikescala at orgscalatestSuperEnginerunImplEnginescala at orgscalatestFunSpecLikerunFunSpecLikescala at orgscalatestFunSpecLikerunFunSpecLikescala at orgscalatestFunSpecrunFunSpecscala at orgscalatesttoolsSuiteRunnerrunSuiteRunnerscala at orgscalatesttoolsRunneranonfundoRunRunRunDaDoRunRun Runnerscala at orgscalatesttoolsRunneranonfundoRunRunRunDaDoRunRun adaptedRunnerscala at scalacollectionimmutableListforeachListscala at orgscalatesttoolsRunnerdoRunRunRunDaDoRunRunRunnerscala at orgscalatesttoolsRunneranonfunrunOptionallyWithPassFailReporter Runnerscala at orgscalatesttoolsRunneranonfunrunOptionallyWithPassFailReporter adaptedRunnerscala at orgscalatesttoolsRunnerwithClassLoaderAndDispatchReporterRunnerscala at orgscalatesttoolsRunnerrunOptionallyWithPassFailReporterRunnerscala at orgscalatesttoolsRunnerrunRunnerscala at orgscalatesttoolsRunnerrunRunnerscala at orgjetbrainspluginsscalatestingSupportscalaTestScalaTestRunnerrunScalaTest ScalaTestRunnerjava at orgjetbrainspluginsscalatestingSupportscalaTestScalaTestRunnermainScalaTestRunnerjava Overview Fixes issue described at The original implementation blindly assumed same partition indexing causing empty join when using custom partitioning with one of the RDDs being joined This PR adds tests for this use case and fixes the issue by adding an additional check that same PartitionIndexer is used so that reshuffle is triggered when that is not the case PR also fixed some inactive asserts in same file It also addresses partitioning mismatch in ReorderedSpaceRDD Checklist x docsCHANGELOGrst updated if necessary del Module Hierarcy updated if necessary del deldocs guides update if necessarydel delNew user API has useful Scaladoc stringsdel x Unit tests added for bugfix or new feature Closes GT version When i ingest epsg tif into catalog i found that the crs info is crs projlonglat ellpsGRS nodefs in metadatajson file But in proj epsg config file there are many epsgcodes corresponding to that crs info When reading metadata from attribute it will choose the first epsgcode in the epsg file which is not expected one I suggest to add more crs info in metadata like crs projlonglat ellpsGRS nodefs Related encode code geotrellissparkiojsonImplicits implicit object CRSFormat extends RootJsonFormat CRS Perhaps crstoWKT is better def writecrs CRS JsStringcrstoProj String change to JsStringscrsepsgcodegetOrElsedefaultValue crstoProj String Decode in readTileMetaData should also change based that convention In rows ifc cols doesFlowflowDirrectiongetn n and rows ifc cols r rows doesFlowflowDirrectiongetn n if the grid meets the conditions and is not processed it will be pushed into the stack When the grid in the stack is processed later the grid number here does not move with it because the map set is not updated which can lead to a dead cycle The recommended forms are unified Using lines in the form of direct calculation with C and R ifr rows doesFlowflowDirrectiongetc r After lines and update C and R update the correct map set with the new C and R c t r t map Map Int Int Int c r c r c r c r c r c r c r c r there is a piece of sample code val c aconvertIntCellTypecombineb as a is ShortConstantNoDataArrayTile with bits cellType ShortConstantNoDataCellType b is CroppedTileShortUserDefinedNoDataArrayTile with bits cellType ShortUserDefinedNoDataCellType After convert it will be IntRawArrayTilecombineb which IntRawArrayTile contains bits IntCellType Finally the result cellType of c is ShortUserDefinedNoDataCellType instead of expected IntCellType i think the CroppedTilecombine op should union other tiles cellType Like below code def combineother Tilef Int Int Int Tile this otherassertEqualDimensions val tile ArrayTilealloccellType cols rows cfor rows row cfor cols col tilesetcol row fgetcol row othergetcol row tile should be def combineother Tilef Int Int Int Tile this otherassertEqualDimensions val tile ArrayTilealloccellTypeunionothercellType cols rows cfor rows row cfor cols col tilesetcol row fgetcol row othergetcol row tile same like ArrayTile CompositeTile also has this issue Were doing a spatial join of rdds but have defined a custom partitioner index implicit object SpaceTimeByMonthPartitioner extends PartitionerIndex SpaceTimeKey private def toZkey SpaceTimeKey Z Z keycol keyrow keytimegetYear keytimegetMonthValue def toIndexkey SpaceTimeKey BigInt toZkeyz def indexRangeskeyRange SpaceTimeKey SpaceTimeKey Seq BigInt BigInt Z zrangestoZkeyRange toZkeyRange If one of the RDDs in the join already has a SpacePartitioner with a default partitioner index the resulting rdd is empty This is caused by the fact that geotrellissparkpartitionReorderedSpaceRDD assumes that all space partitioners use the same index Adding a require in ReorderedSpaceRDD to compare the index would help to make the user aware of this assumption The following code val p Point printlnGeometryCollectionmultiPoints SeqMultiPointp ptoGeoJson prints type GeometryCollection geometries type MultiPoint coordinates type GeometryCollection geometries type Point coordinates type Point coordinates The same duplication happens with MultiPolygons and MultiLines when nested into GeometryCollection It appears that this is because a MultiPoint IS a GeometryCollection so the Encoder retrieves it two times first by getAll MultiPoint then by getAll GeometryCollection So that MVTFeature has the same capabilities as geotrellisvectorFeature Investigate would it improve our performance or not Spark tests in the Apache Spark github repo are build around SparkFunSuite and SharedSparkContext Probably it makes sense to adopt their code and use it in our codebase Signedoffby Andrey Tararaksin atararaksingmailcom Overview This PR fixes PolygonRasterizer crash described in Consider a scanline crossing two edges of a polygon in two separate nonvertex points If xcoords of these points are calculated as identical Doubles due to a Doublerelated error the crash occurs This PR fixes this issue by recalculating such coordinates using precise spiremathRational This recalculation is performed for a given row if it contains two or more matching Double xcoords It is a very rare case and for a typical polygon occurs zero to little times so the generalcase performance is not affected Checklist x docsCHANGELOGrst updated if necessary Module Hierarcy updated if necessary docs guides update if necessary New user API has useful Scaladoc strings x Unit tests added for bugfix or new feature Closes 