I tried building this and I got this error Building C object srcCMakeFileslibcmarkstaticdirhoudinihrefeco Building C object srcCMakeFileslibcmarkstaticdirhoudinihtmleco Building C object srcCMakeFileslibcmarkstaticdirhoudinihtmluco Building C object srcCMakeFileslibcmarkstaticdircmarkctypeco Linking C static library libcmarka Built target libcmarkstatic Binaries can be found in buildsrc make yajlsfast C depsyajlbuild noprintdirectory make depsyajlbuild No such file or directory Stop Makefile recipe for target yajl failed make yajl Error Related to we should strive to support all of the different content address formats Our own hash URIs of course RCF ni Algorithmprefixed hashes eg as used by Subresource Integrity There is no reason we cant resolve these hashes and even generate them in our UI Unfortunately supporting the addresses used by BitTorrent Camlistore and IPFS is nearly impossible because each one generates its own unique hashes which cannot even always be consistently derived without outside data As described in this post our hash URI scheme is ambiguous when supporting multiple hash encodings for example hexadecimal and base Examples from the post hashsha f d c d a feaa c ad a bf f b b b cd d c b f a current hex format hashsha n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg base url ambiguous hashsha b n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg base with encoding name prefix hashsha n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg leading underscore for simple disambiguation from hex hashb sha n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg encoding as algorithm s subdomain hashsha b n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg encoding as algorithm s top level domain hashsha b n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCgg encoding as path component hashsha n bQgYhMfWWaLqgxVrQFaOTxsrC Is V sFbDwCggencbase encoding as query parameter probably a terrible idea only included for completeness Since then Ive become more fond of the path compoent version b For hex wed probably use b due to unfortunate connotations of the word hex Unmarked encodings would be treated as hex for backward compatibility and it would continue to be officially supported Unfortunately this labeling makes base encoded URIs slightly longer by characters Hash URIs are already the longest of the various content addressing schemes and this negates some of the advantage of using base in the first place On the other hand I think theres value in being very flexible with user input Related to It should be possible and maybe not even that hard to implement an SQLite virtual table for StrongLinks database schema This would be handy for debugging exploration and who knows what else Related to Test with something like Probably useful for See here for a full overview of plans Depends on Also requires various optimizations to metafiles StrongLink seems to have some overlapping ideasuses with CouchDB and PouchDB The biggest difference is that we also plan to support desynchronization AKA partial mirroring AKA partial replication Given our intended use case Im not sure CouchDB syncing makes sense but it seems worth considering at least Google Query Language supported by CouchDB Our alogf log function prefixes logged messages with a timestamp which is very useful Unfortunately that requires two printf statements which we dont want to get split up by concurrent writes Right now were using flockfile which makes logging even slower than usual Possible approaches Do all logging on a single thread Use fputsunlocked to write without locking Use write or libuvs equivalent to write without locking Not sure what the best simplestfastest solution is Performance does in fact matter for traffic logging 