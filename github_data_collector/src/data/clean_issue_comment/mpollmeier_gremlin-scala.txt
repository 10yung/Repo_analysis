Hi Please see the following SO question This happened when using Seq and List for properties on my CC I was able to step through your code and it appears that for a List type addVertex proceeds to add the whole list as a property which is unsupported Is there a way to make it iterate through and add all said items to the property the Gremlin way ie gaddVpersonpropertyfriend johnpropertyfriendjoe Hi I have neo jcommunity scala and Idea community version and would like to set up gremlin for me to access Neo j database in Scala I have this library dependency in buildsbt libraryDependencies commichaelpollmeier gremlinscala and in my scala console I have import gremlinscala import orgapachetinkerpopgremlintinkergraphstructureTinkerFactory But scala does not recognize tinkergraph What I am missing and is there a link describing how to set it up Thanks I have a use case where I want to look up if a vertex exists based on a property and if it does not create and add relationship to another vertex how do i go about doing it Hi There As per AWS Neptune documentation if you pass id attribute that will be the vertex id If you do not then neptune will generate a uuid I am trying to do local development with gremlin server and trying to create a vertex with uuid as it is id and cannot find any example of that Help would be appreciated We are using gremlinscala v We use JanusGraph and have the following data model wrt case classes For each vertex we have two case classes one for writing to the database and one for reading from the database The only difference is that the case class which is used for writing to the database has the id as Option id whereas in the case class which used for reading from database the Id is not an Option For example we have the user vertex as follows labeluser final case class UserDBid id Option Long name String createdAt Long labeluser final case class UserVertexid id Long name String createdAt Long UserDB is used when the vertex is created val user graph userDB UserVertex is when we convert the vertex in to the case class val userVertex usertoCC UserVertex The reason why we have a different case class during the read is because we are sure that the Id is going to be there when we read from the Database and we can avoid matching on the Option id to get the Id Upgrading to the latest version of gremlinscala is giving the following errors for the all case classes which doesnt have Id as Option error javalangAssertionError assertion failed id parameter must be of type Option A In the context of Marshallable we have to let the graph assign an id error at scalaPredefassertPredefscala error at gremlinscalaMarshallablehandleId Marshallablescala error at gremlinscalaMarshallableanonfunmaterializeMappableImpl Marshallablescala error at scalacollectionTraversableOnceanonfunfoldLeft TraversableOncescala error at scalacollectionTraversableOnceanonfunfoldLeft adaptedTraversableOncescala error at scalareflectinternalScopesScopeforeachScopesscala error at scalacollectionTraversableOncefoldLeftTraversableOncescala error at scalacollectionTraversableOncefoldLeftTraversableOncescala error at scalareflectinternalScopesScopefoldLeftScopesscala error at gremlinscalaMarshallablematerializeMappableImplMarshallablescala error maptoCC UserVertex We understand the error message we have to let the graph assign an id which is only when adding the vertex to the database but why is this enforced on toCC UserVertex Here is the error that I am encountering playapihttpHttpErrorHandlerExceptionsanon Execution exception IllegalStateException Property addition is not supported at playapihttpHttpErrorHandlerExceptionsthrowableToUsefulExceptionHttpErrorHandlerscala at playapihttpDefaultHttpErrorHandleronServerErrorHttpErrorHandlerscala at playcoreserverAkkaHttpServeranonfun applyOrElseAkkaHttpServerscala at playcoreserverAkkaHttpServeranonfun applyOrElseAkkaHttpServerscala at scalaconcurrentFutureanonfunrecoverWith Futurescala at scalaconcurrentimplPromiseanonfuntransformWith Promisescala at scalaconcurrentimplCallbackRunnablerunPromisescala at akkadispatchBatchingExecutorAbstractBatchprocessBatchBatchingExecutorscala at akkadispatchBatchingExecutorBlockableBatchanonfunrun BatchingExecutorscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava Caused by javalangIllegalStateException Property addition is not supported at orgapachetinkerpopgremlinstructureElementExceptionspropertyAdditionNotSupportedElementjava at orgapachetinkerpopgremlinstructureutildetachedDetachedVertexpropertyDetachedVertexjava at orgapachetinkerpopgremlinstructureutildetachedDetachedVertexpropertyDetachedVertexjava at gremlinscalaScalaElementanonfunupdateWith ScalaElementscala at scalacollectionimmutableHashMapHashMap foreachHashMapscala at scalacollectionimmutableHashMapHashTrieMapforeachHashMapscala at gremlinscalaScalaElementupdateWithScalaElementscala at gremlinscalaScalaElementupdateWithScalaElementscala at gremlinscalaScalaVertexupdateWithScalaVertexscala at gremlinscalaScalaElementupdateAsScalaElementscala Here are my models and the way I have defined it import javautil UUID import gremlinscalaElement Marshallable Vertex id label underlying labeltrip case class TripModeltripId Option String None name String createdDate javatimeInstant javatimeInstantnow startDate javatimeInstant duration Int totalAdults Int totalChildrens Int underlying vertex Option Vertex None object TripModel implicit val marshaller new Marshallable TripModel def toCCelement Element TripModel val tripId Someelementvalue UUID tripIdtoString val tripName elementvalue String name val duration elementvalue Int duration val totalAdults elementvalue Short totalAdults val totalChildren elementvalue Short totalChildrens val date elementvalue javatimeInstant createdDate val startDate elementvalue javatimeInstant startDate modelsTripModeltripId tripId name tripName startDate startDate duration duration totalAdults totalAdults totalChildrens totalChildren createdDate date override def fromCCcc TripModel FromCC val values Mapname ccname createdDate cccreatedDate startDate ccstartDate duration ccduration totalAdults cctotalAdults totalChildrens cctotalChildrens tripId UUIDfromStringcctripIdgettoString FromCCNone trip values And here is how I update a certain field def updateTripDetailsidString tripUpdate UpdateTripRequest implicit val g dbg val item dbgVhasKeyValuetripId idhead itemupdateAs TripModel cc cccopyname tripUpdatetripNamegetOrElseccname What I am trying to do is to update a certain vertex property however I always received the aforementioned error is there any workaround for this Heres a snippet of my code labeltrip case class TripModeltripId Option String None name String createdDate Date new Date startDate Date duration Int totalAdults Int totalChildrens Int underlying vertex Option Vertex None I am able to persist a trip model using the following code val trip TripModeltripId SomerandomUUIDtoString name ctrtripName startDate DateUtilconvertStringToDatectrstartTo duration ctrtotalDays totalAdults ctrtotalAdults totalChildrens ctrtotalChildren createdDate new Date val tripVertex graph trip However upon retrieval of the persisted vertex I always receive this error playapihttpHttpErrorHandlerExceptionsanon Execution exception ClassCastException javatimeInstant cannot be cast to javautilDate at playapihttpHttpErrorHandlerExceptionsthrowableToUsefulExceptionHttpErrorHandlerscala at playapihttpDefaultHttpErrorHandleronServerErrorHttpErrorHandlerscala at playcoreserverAkkaHttpServeranonfun applyOrElseAkkaHttpServerscala at playcoreserverAkkaHttpServeranonfun applyOrElseAkkaHttpServerscala at scalaconcurrentFutureanonfunrecoverWith Futurescala at scalaconcurrentimplPromiseanonfuntransformWith Promisescala at scalaconcurrentimplCallbackRunnablerunPromisescala at akkadispatchBatchingExecutorAbstractBatchprocessBatchBatchingExecutorscala at akkadispatchBatchingExecutorBlockableBatchanonfunrun BatchingExecutorscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava Caused by javalangClassCastException javatimeInstant cannot be cast to javautilDate at serviceTripServiceanon toCCTripServicescala at serviceTripServiceanon toCCTripServicescala at gremlinscalaScalaVertextoCCScalaVertexscala at serviceTripServicegetTripTripServicescala at controllerstripTripControlleranonfungetTrip TripControllerscala at playapimvcActionBuilderanonfunapply Actionscala at scalaFunction anonfunandThen Function scala at playapimvcActionBuilderImplinvokeBlockActionscala at playapimvcActionBuilderImplinvokeBlockActionscala at playapimvcActionBuilderanon invokeBlockActionscala Ive added this issue to track a discussion related to adding Edge support to the DSL Im happy to push up a PR but Id like to make sure its in the style you would like to see A few questions Adding edge support will require a new ConverterforDomainEdge implicit I believe this will require me to create a new DomainEdge marker trait that extends DomainRoot for use in the ConverterforDomainEdge context bound implicit def forDomainEdge DomainType ModelEdge implicit marshaller Marshallable DomainType graph Graph ConverterAux DomainType Edge new Converter DomainType type GraphType Edge def toDomaine Edge DomainType marshallertoCCe def toGraphdt DomainType Edge AnonymousEdgedt Im wondering if we should also add a DomainNode marker trait that extends DomainRoot so that the contextbound of ConverterforDomainNode can be more specific That would be a breaking change which is why I bring it up It seems like the right thing to do now though It seems like a lot of the things that are going in to NodeSteps that could be shared between NodeSteps and EdgeSteps so I propose creating an ElementSteps base class and pushing much of whats in NodeSteps into ElementSteps It probably still makes sense to leave NodeSteps there even if it is empty simply to fix the EndGraph typeparameter to Vertex and give ourselves a future location for steps that are truly vertexspecific I think some of the things in NodeSteps should really be in Steps such as filterOnEnd and sideEffect which could apply to any EndDomain such as a selected tuple Some of the new steps youve added to NodeSteps arent using the implicit Constructor pattern that you were using earlier I presume youre expecting that there will be an implicit to lift NodeSteps to its domainspecific subclass Is there a reason why youre moving away from the Constructor pattern Should we rely on the runtime conversion moving forward or should we prefer the Constructor pattern I had to implement a vertex query containing an orCondition and just from reading the documentation it was not obvious for me how the logical operators or and and work In order to find out I went through the LogicalSpec It would be nice to have an overview of the operator usage in READMEmd Heres a cut at adding by modulation for select steps Please take a look at the SelectSpec for usage of the tupled version It accepts a tuple of StepLabel followed by a tuple of By The method signature for selectby could alternately be expressed as a Tuple of StepLabelBy pairs I didnt spend terribly much time with it but during my first pass at the pairwise signature I struggled to unzip the pairs HLists into an HList of StepLabel and an HList of Bys because Im not deep enough into shapeless to provide it with an implicit UnzipAux that the compiler could resolve Before I hop into that rabbit hole I thought Id inquire with you about the method signature you would prefer to see for selectby either one Ive proposed or an alternate Also if you have any advice on how I could augment the following to supply an unzipper please let me know def select StepLabelAndByTuplesAsTuples Product StepLabelsAndBysHList HList StepLabels HList Bys HList H T HList LabelNames HList TupleWithValue Values HList Z ValueTuples stepLabelAndByTuplesAsTuple StepLabelAndByTuplesAsTuples implicit stepLabelAndByTuplesAsTupleToHList ToHListAux StepLabelAndByTuplesAsTuples StepLabelsAndBysHList unzipper UnzipAux StepLabelsAndBysHList StepLabels Bys stepLabelToString MapperAux GetLabelNametype StepLabels LabelNames labelTrav ToTraversableAux LabelNames List String byTrav ToTraversableAux Bys List By resultMapToHListFolder RightFolderAux StepLabelsAndBysHList HNil JMap String Any combineModulatorWithValuetype Values Z tupler TuplerAux Values ValueTuples GremlinScalaAux ValueTuples Labels Select each StepLabel val stepLabelsAndBysHList StepLabelsAndBysHList stepLabelAndByTuplesAsTupleToHListstepLabelAndByTuplesAsTuple val stepLabelsHList bysHList stepLabelsAndBysHListunzip val labels List String stepLabelsHListmapGetLabelNametoList val label labelshead val label labelstailhead val remainder labelstailtail val selectTraversal gremlinScalatraversalselect Any label label remainder Apply By modulators to selected steps val bys List By bysHListtoList var byTraversal selectTraversal bysforeach by byTraversal byapplybyTraversal Extract selected values from the map of labeled values and construct a result tuple typed by Modulated from By Modulated GremlinScalabyTraversalmap selectValues val resultTuple stepLabelsAndBysHListfoldRightHNil HNil selectValuescombineModulatorWithValue val values Values resultTuple tuplervalues That fails to compile with Error could not find implicit value for parameter unzipper shapelessopshlistUnzipAux StepLabelsAndBysHListStepLabels Bys Thank you for your efforts on this library