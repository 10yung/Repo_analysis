For object stores with auto incrementing primary keys we know the primary key will be available on all objects read from the database but not necessarily on all objects written to the database Currently idb does not supply TypeScript with that information though Seems to me that it could be improved to do so if DBSchemaValue also included the keyPath and autoIncrement values passed to createObjectStore Example type Foo id number bar string export interface FooDB extends DBSchema foos key number value Foo const db await openDBFooDBfoo upgradedb oldVersion if oldVersion upgradeDBcreateObjectStoreleagues keyPath id autoIncrement true This works only because we defined Foo with an optional id property const foo Foo bar baz await dbaddfoo foo foo is guaranteed to have a numeric id property but TypeScript doenst know this because it has type Foo const foo await dbgetfoo Ideally foo s type would instead be type Foo Foo id number but that would require encoding in FooDB that id is an autoincrementing primary key I guess a caveat would be that if keyPath is nested like abc Im not sure if TypeScript will be able to handle that But based on pure conjecture and absolutely no data Im going to say that its very rare to use a key path that is both nested and auto incrementing but its pretty common to use a nonnested key path that is autoincrementing Consider the following code ts declare let x IDBPTransactionMyDB table table declare let y IDBPTransactionMyDB table x y Incompatiable type Thats right y x Incompatible type too thats not right A transaction with access to table and table can be a subtype of a transaction with only access to table y x But it seems to be invariant on the IDBPTransaction And the mutatable of the transaction readonly readwrite is not reflected in the type IDBPTransaction so it is possible to pass a readonly transaction to a function that requires a readwrite transaction then cause a runtime error My app works as a PWA but is not installed as one no manifest However I dont think its relevant to this particular problem This is how it goes the user access the page the indexedDB is created User uses the app Then the user decides to no longer authorize ccokies Go to settings and disable cookie Now the app is no longer working so said user goes back to allow cookies again This is when the problem arise openDB is stuck in blocked state forever You can close all the windows you want Close Safari Nothing will do unless the user goes to setting and ask for delete the site data Which means the DB is deleted Tested with Safari iOS Is there a way to get unstuck without resorting to drastic erase of the DB Thanks for any insight BTW thanks for this awesome library When adding a duplicate key the txerror was null but txsrcElementerror wasnt This PR reads it from there if it fails there instead A longterm solution would be to check for srcElementtarget onerror as well as txonerror Im considering adopting IDB or another promisebased IndexedDB wrapper for my project but am concerned about the danger of encouragingallowing awaiting of arbitrary promises that break transactions To mitigate the risk an IndexedDB wrapper library could return a special branded Promise type say TransactionalOperationPromise and also provide an eslinttypescript rule that forbids code within an IndexedDB transaction context from awaiting any type other than TransactionalOperationPromise An IndexedDB transaction context could be defined as a lexical scope that references a value that is only valid for the duration of a transaction for instance an ObjectStore Or it could be any lexical scope that calls a function that returns a TransactionalOperationPromise I havent though through the specifics of this part To allow for async function declarations the wrapper would export an enhancer noop function transactionalI extends any Ounwrapped fnargs I PromiseO fnargs I IDBTransactionalOperationPromiseO recognized by the linter rule as putting the unwrapped function argument in transaction context The linter rule would only allow a function literal to be passed to transactional I dont think its possible to enforce soundness with this tactic but perhaps eslinttypescript rule that makes some soundness tradeoffs could be both reasonable to implement and catch a fair amount of bugs See the awaitthenable rule for an example of an eslinttypescript rule that leverages type information Does this sound like a promising no pun intended track of work to you all Would you accept a PR implementing this concept in IDB Just as iterate is a convenience for openCursor avoids the need for an if cursor check for when the cursor returns no results should there also be an equivalent iterateKeys as a similar convenience for openKeyCursor Currently to asynciterate over the keys of a store or index it seems like the only option is javascript let cursor await storeopenKeyCursor if cursor for await const cursor of cursor use cursorkey here For symmetry it would seem like this may also be useful javascript for await const cursor of storeiterateKeys use cursorkey here Trying to use this package with Angular universal but facing this issue ReferenceError IDBIndex is not defined Probably this is not working on server Can someone provide a possible workaround for this Do I need to import openDb deleteDb from idb conditionally or something else This is something that any IndexedDB user will have to sooner or later consider Hi im trying to use idb in a javascript project without modules so im using the buildidbjs artifact Inside my ts file im trying to use the library but the typescript project system does not find the types Ive tryied imorting the definition by this statement in my ts file reference pathnodemodulesidblibidbdts and by adding the name of the library in the compilerOptions section of the tsconfigjson file types idb Im only able to use the type definitions by using the import syntaxt import openDb from nodemodulesidblibidb but it cant be used with the compile option modulenone Thanks When using idbjs in a worker context on Safari you get TransactionInactiveError Failed to execute get on IDBObjectStore The transaction is inactive or finished However when running the same code in the main context or on chrome or firefox in the main or in a worker context it works as expected js const DBNAME db const STORENAME storename const dbPromise idbopenDBNAME upgradeDB upgradeDBcreateObjectStoreSTORENAME const init async const db await dbPromise const txWrite dbtransactionSTORENAME readwrite await txWriteobjectStoreSTORENAMEputhello foo const txRead dbtransactionSTORENAME consolelogtype got transaction const a await txReadobjectStoreSTORENAMEgetfoo consolelogtype got a a const b await txReadobjectStoreSTORENAMEgetfoo consolelogtype got b b initcatche consoleerrore In Safari this code will output Log MAIN got transaction Log MAIN got a hello Log MAIN got b hello Log WORKER got transaction Log WORKER got a hello TransactionInactiveError Failed to execute get on IDBObjectStore The transaction is inactive or finished Whereas in Chrome or Firefox you dont get the TransactionInactiveError There is a sandbox here 