Im trying to set up cargofuzz for a webbased project For production we deploy to wasm using cargoweb however we run are tests natively as well so the project runs just fine on x In fact we have AFL set up with a regular binary which works for fuzzing however I figured I would try out libfuzzer as well When compiling with cargo fuzz run we get many linker errors such as in function allocvecIntoIterT as coreopsdropDropdrop main d o qxfcgu textZN LTallocvecIntoIterLTTGTu asu coreopsdropDropGT drop h c e a ffE x undefined reference to emscriptenasmconstint Indicating that for some reason LLVM functions are being used even though they shouldnt be I have ensured that we are compiling with LTO however this doesnt seem to help Working bin target fn main onuwfuzzfuzzbinary stdiostdinlock Failing cargofuzz target nomain use libfuzzersysfuzztarget libfuzzersysfuzztargetdata u onuwfuzzfuzzbinary data It would be really nice if this worked This would be particularly useful for folks running cargo fuzz in their CI so they didnt have to wait on cargofuzz itself to build Steps to reproduce cargo new blah Created binary application blah package cd blah cargo fuzz init cargo fuzz run fuzztarget O a Updating git repository Updating cratesio index Compiling cc v Compiling arbitrary v Running rustc edition cratename cc homefitzgencargoregistrysrcgithubcom ecc db ec cc srclibrs errorformatjson jsondiagnosticrenderedansi cratetype lib emitdepinfometadatalink C optlevel C metadatafda a c d d C extrafilenamefda a c d d outdir tmpblahfuzztargetreleasedeps L dependencytmpblahfuzztargetreleasedeps caplints allow Running rustc cratename arbitrary homefitzgencargoregistrysrcgithubcom ecc db ec arbitrary srclibrs errorformatjson jsondiagnosticrenderedansiartifacts cratetype lib emitdepinfometadatalink C optlevel C metadata b a b df d C extrafilename b a b df d outdir tmpblahfuzztargetx unknownlinuxgnureleasedeps target x unknownlinuxgnu L dependencytmpblahfuzztargetx unknownlinuxgnureleasedeps L dependencytmpblahfuzztargetreleasedeps caplints allow cfg fuzzing Cpassessancov Cllvmargssanitizercoveragelevel Cllvmargssanitizercoveragetracecompares Cllvmargssanitizercoverageinline bitcounters Cllvmargssanitizercoveragetracegeps Cllvmargssanitizercoveragepruneblocks Cllvmargssanitizercoveragepctable Zsanitizeraddress Cllvmargssanitizercoveragestackdepth Cdebugassertions Compiling libfuzzersys v Running rustc edition cratename buildscriptbuild homefitzgencargogitcheckoutslibfuzzersyse fde d bc c buildrs errorformatjson jsondiagnosticrenderedansi cratetype bin emitdepinfolink C optlevel C metadataab c d e b d C extrafilenameab c d e b d outdir tmpblahfuzztargetreleasebuildlibfuzzersysab c d e b d L dependencytmpblahfuzztargetreleasedeps extern cctmpblahfuzztargetreleasedepslibccfda a c d d rlib caplints allow Running tmpblahfuzztargetreleasebuildlibfuzzersysab c d e b dbuildscriptbuild Running rustc edition cratename libfuzzersys homefitzgencargogitcheckoutslibfuzzersyse fde d bc c srclibrs errorformatjson jsondiagnosticrenderedansi cratetype lib emitdepinfometadatalink C optlevel C metadata f fb f cb C extrafilename f fb f cb outdir tmpblahfuzztargetx unknownlinuxgnureleasedeps target x unknownlinuxgnu L dependencytmpblahfuzztargetx unknownlinuxgnureleasedeps L dependencytmpblahfuzztargetreleasedeps extern arbitrarytmpblahfuzztargetx unknownlinuxgnureleasedepslibarbitrary b a b df drmeta caplints allow cfg fuzzing Cpassessancov Cllvmargssanitizercoveragelevel Cllvmargssanitizercoveragetracecompares Cllvmargssanitizercoverageinline bitcounters Cllvmargssanitizercoveragetracegeps Cllvmargssanitizercoveragepruneblocks Cllvmargssanitizercoveragepctable Zsanitizeraddress Cllvmargssanitizercoveragestackdepth Cdebugassertions L nativetmpblahfuzztargetx unknownlinuxgnureleasebuildlibfuzzersysc de feout l staticfuzzer l stdc Compiling blahfuzz v tmpblahfuzz Running rustc edition cratename fuzztarget fuzztargetsfuzztarget rs errorformatjson jsondiagnosticrenderedansi cratetype bin emitdepinfolink C optlevel C metadatadd ee c bcc a C extrafilenamedd ee c bcc a outdir tmpblahfuzztargetx unknownlinuxgnureleasedeps target x unknownlinuxgnu L dependencytmpblahfuzztargetx unknownlinuxgnureleasedeps L dependencytmpblahfuzztargetreleasedeps extern libfuzzersystmpblahfuzztargetx unknownlinuxgnureleasedepsliblibfuzzersys f fb f cbrlib cfg fuzzing Cpassessancov Cllvmargssanitizercoveragelevel Cllvmargssanitizercoveragetracecompares Cllvmargssanitizercoverageinline bitcounters Cllvmargssanitizercoveragetracegeps Cllvmargssanitizercoveragepruneblocks Cllvmargssanitizercoveragepctable Zsanitizeraddress Cllvmargssanitizercoveragestackdepth Cdebugassertions L nativetmpblahfuzztargetx unknownlinuxgnureleasebuildlibfuzzersysc de feout warning unused variable data fuzztargetsfuzztarget rs fuzztargetdata u help consider prefixing with an underscore data note warnunusedvariables on by default Finished release optimized targets in s Fresh cc v Fresh arbitrary v Fresh libfuzzersys v Fresh blahfuzz v tmpblahfuzz warning unused variable data fuzztargetsfuzztarget rs fuzztargetdata u help consider prefixing with an underscore data note warnunusedvariables on by default Finished release optimized targets in s Running fuzztargetx unknownlinuxgnureleasefuzztarget artifactprefixtmpblahfuzzartifactsfuzztarget tmpblahfuzzcorpusfuzztarget INFO Seed INFO Loaded modules inline bit counters x a e aae x a e ab INFO Loaded PC tables PCs x a e ab x a e ac ERROR The size of coverage PC tables does not match the number of instrumented PCs This might be a compiler bug please contact the libFuzzer developers Also check for possible workarounds tldr dont use the old GNU ld This is something that hasnt been super clear to me and I havent really seen it discussed anywhere ever The corpus can end up getting sizable see also often isnt human readable Committing it to the projectbeingfuzzeds repo seems like it could add a bunch of git overhead and even make merges difficult But it is needed to pick up where you left off when doing timebudgeted fuzzing Anyone fuzzing the project is going to want that corpus I guess it could be in a git submodule That has its own overhead but seems like maybe a good fit for when only some folks or just CI or something are fuzzing and not every local developer Although maybe Im more concerned about this than I should be Do folks have thoughts on this Hi I am fuzzing the Rust implementation of swfparser with cargo fuzz The fuzzer is helpful and found some issues but it crashes due to OOM out of memory errors about a third of the time When looking into the input that caused this error it seems that the OOM error is caused by the fuzzer itself not the library Here is the fuzz target rust fuzztargetdata u if let Someswfversion data datasplitfirst let swfparsercompleteparsetagdata swfversion You can run it yourself by cloning the repo and then running cd rs cargo fuzz run tag The OOM is caused when the fuzzer generates the following inputs b empty slice Due to how the fuzz target is defined the library shouldnt even be called How is it possible to cause an OOM This input is the most common cause of OOM b x b x x x x this input caused an OOM error once This is a wellformed input that works fine when executed as a unit test it produces a tag marking the SWF file as protected with an empty password Theres no recursion or advanced resource management going on in the lib this just produces a struct and should not exceed the default GiB memory limit Here is a log of one of the execution causing an OOM due to the empty slice details summarySee logsummary homedemurgoscargobincargo fuzz run tag Fresh unicodexid v Fresh semverparser v Fresh cfgif v Fresh buildconst v Fresh versioncheck v Fresh autocfg v Fresh nodrop v Fresh staticassertions v Fresh ucdutil v Fresh lazystatic v Fresh cc v Fresh utf ranges v Fresh hex v Fresh itoa v Fresh adler v Fresh half v Fresh arbitrary v Fresh semver v Fresh log v Fresh regexsyntax v Fresh threadlocal v Fresh inflate v Fresh procmacro v Fresh rustcversion v Fresh memchr v Fresh ryu v Fresh arrayvec v Fresh byteorder v Fresh quote v Fresh crc v Fresh ahocorasick v Fresh syn v Fresh lzmars v Fresh regex v Fresh numtraits v Fresh serdederive v Fresh lexicalcore v Fresh libfuzzersys v Fresh serde v Fresh nom v Fresh swffixed v Fresh serdejson v Fresh swftree v Compiling swfparser v dataprojectsopenflashswfparserrs Running rustc edition cratename swfparser dataprojectsopenflashswfparserrssrclibrs errorformatjson jsondiagnosticrenderedansi cratetype lib emitdepinfometadatalink C debuginfo C metadata e fed cc cf C extrafilename e fed cc cf outdir dataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdeps target x unknownlinuxgnu C incrementaldataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugincremental L dependencydataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdeps L dependencydataprojectsopenflashswfparserrsfuzztargetdebugdeps extern halfdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibhalfedb f d be bfrmeta extern inflatedataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibinflate b d a rmeta extern lazystaticdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepsliblazystaticbaf a eeafrmeta extern lzmarsdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepsliblzmars e db b rmeta extern memchrdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibmemchr ca b rmeta extern nomdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibnom ed ed rmeta extern numtraitsdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibnumtraitsbeec a be db crmeta extern regexdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibregex be ed cc rmeta extern serdejsondataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibserdejsonb a f d eed rmeta extern swffixeddataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibswffixeda f cf dce rmeta extern swftreedataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibswftree a c b df abrmeta cfg fuzzing Cpassessancov Cllvmargssanitizercoveragelevel Cllvmargssanitizercoveragetracecompares Cllvmargssanitizercoverageinline bitcounters Cllvmargssanitizercoveragetracegeps Cllvmargssanitizercoveragepruneblocks Cllvmargssanitizercoveragepctable Zsanitizeraddress Cllvmargssanitizercoveragestackdepth Compiling swfparserfuzz v dataprojectsopenflashswfparserrsfuzz Running rustc edition cratename tag fuzztargetstagrs errorformatjson jsondiagnosticrenderedansi cratetype bin emitdepinfolink C debuginfo C metadata ef a e aad C extrafilename ef a e aad outdir dataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdeps target x unknownlinuxgnu C incrementaldataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugincremental L dependencydataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdeps L dependencydataprojectsopenflashswfparserrsfuzztargetdebugdeps extern libfuzzersysdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepsliblibfuzzersysb f eb c rlib extern swfparserdataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugdepslibswfparser e fed cc cf rlib cfg fuzzing Cpassessancov Cllvmargssanitizercoveragelevel Cllvmargssanitizercoveragetracecompares Cllvmargssanitizercoverageinline bitcounters Cllvmargssanitizercoveragetracegeps Cllvmargssanitizercoveragepruneblocks Cllvmargssanitizercoveragepctable Zsanitizeraddress Cllvmargssanitizercoveragestackdepth L nativedataprojectsopenflashswfparserrsfuzztargetx unknownlinuxgnudebugbuildlibfuzzersysaab c c cc b dout Finished dev unoptimized debuginfo targets in s Fresh unicodexid v Fresh semverparser v Fresh cfgif v Fresh buildconst v Fresh autocfg v Fresh nodrop v Fresh versioncheck v Fresh ucdutil v Fresh cc v Fresh staticassertions v Fresh lazystatic v Fresh adler v Fresh itoa v Fresh utf ranges v Fresh hex v Fresh half v Fresh arbitrary v Fresh semver v Fresh log v Fresh regexsyntax v Fresh threadlocal v Fresh inflate v Fresh procmacro v Fresh rustcversion v Fresh ryu v Fresh memchr v Fresh arrayvec v Fresh byteorder v Fresh quote v Fresh ahocorasick v Fresh crc v Fresh syn v Fresh numtraits v Fresh regex v Fresh lzmars v Fresh libfuzzersys v Fresh serdederive v Fresh lexicalcore v Fresh serde v Fresh nom v Fresh swffixed v Fresh serdejson v Fresh swftree v Fresh swfparser v dataprojectsopenflashswfparserrs Fresh swfparserfuzz v dataprojectsopenflashswfparserrsfuzz Finished dev unoptimized debuginfo targets in s Running fuzztargetx unknownlinuxgnudebugtag artifactprefixdataprojectsopenflashswfparserrsfuzzartifactstag dataprojectsopenflashswfparserrsfuzzcorpustag INFO Seed INFO Loaded modules inline bit counters x aecfc a x aecfc d c INFO Loaded PC tables PCs x aecfc d x aecfd f d INFO files found in dataprojectsopenflashswfparserrsfuzzcorpustag INFO maxlen is not provided libFuzzer will not generate inputs larger than bytes INFO seed corpus files min b max b total b rss Mb INITED cov ft corp b lim execs rss Mb REDUCE cov ft corp b lim execs rss Mb L MS EraseBytes NEWFUNC ERROR libFuzzer outofmemory used Mb limit Mb To change the outofmemory limit use rsslimitmbN MS ChangeByteChangeBinIntChangeBinIntChangeBit base unit a ce e c f fff cd eaede artifactprefixdataprojectsopenflashswfparserrsfuzzartifactstag Test unit written to dataprojectsopenflashswfparserrsfuzzartifactstagoomda a ee e b b d bfef afd Base SUMMARY libFuzzer outofmemory Process finished with exit code details System information OS Linux bit x unknownlinuxgnu Toolchain nightly x unknownlinuxgnu Cargo fuzz version latest The issue may still lie in my lib but I find it very unlikely given the inputs causing the OOM errors rust nomain use libfuzzersysfuzztarget fuzztargetdata u fuzzed code goes here causes the following error console error E cant find crate for arbitrary fuzztargetsfuzztarget rs fuzztargetdata u fuzzed code goes here cant find crate note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info I tried to fix this by adding the missing crate to fuzzCargotoml toml dependenciesarbitrary version but this caused the following error console error E mismatched types fuzztargetsfuzztarget rs fuzztargetdata u fuzzed code goes here expected enum arbitraryBufferError found str note expected type stdresultResult arbitraryBufferError found type stdresultResult str note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info To fix the problem I had to switch back to the version of the arbitrary crate toml dependenciesarbitrary breaks with version I think the dependency should be automatically included instead Itd be easier to get started if cargo fuzz run ran fuzzing instead of failing with notveryhelpful error The following required arguments were not provided ltTARGET It could behave similarly to cargo run which runs binary if theres only one It asks to specify a binary only if theres more than one Im looking into fuzzing parts of Rust standard library to detect bugs such as CVE See also the fix However this is currently impossible with cargofuzz because it passes Cpanicabort during compilation while for this function panic on overflow is the expected behavior I need a way to disable that This surfaces when calling cargo fuzz tmin target crash where crash is a filename with special shell characters honggfuzz produces those by default I dont know how the shell is called it seems that exectmin is using exec gctestcrate on master targetdebugcargofuzz tmin fuzztarget fuzzartifactsfuzztarget crash Fresh cc v Fresh arbitrary v Fresh testcrate v homejohannesgitcargofuzztestcrate Fresh libfuzzersys v Fresh testcratefuzz v homejohannesgitcargofuzztestcratefuzz Finished dev unoptimized debuginfo targets in s Running fuzztargetx unknownlinuxgnudebugfuzztarget artifactprefixhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget minimizecrash runs fuzzartifactsfuzztarget crash INFO Seed INFO Loaded modules guards x e b x e e CRASHMIN minimizing crash input fuzzartifactsfuzztarget crash bytes CRASHMIN executing fuzztargetx unknownlinuxgnudebugfuzztarget artifactprefixhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget runs fuzzartifactsfuzztarget crash tmplibFuzzerTemp txt sh c line syntax error near unexpected token sh c line fuzztargetx unknownlinuxgnudebugfuzztarget artifactprefixhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget runs fuzzartifactsfuzztarget crash tmplibFuzzerTemp txt CRASHMIN fuzzartifactsfuzztarget crash bytes caused a crash Will try to minimize it further CRASHMIN executing fuzztargetx unknownlinuxgnudebugfuzztarget artifactprefixhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget runs fuzzartifactsfuzztarget crash minimizecrashinternalstep exactartifactpathhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget minimizedfroma f b a d b f c fa f b d fd b c f tmplibFuzzerTemp txt sh c line syntax error near unexpected token sh c line fuzztargetx unknownlinuxgnudebugfuzztarget artifactprefixhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget runs fuzzartifactsfuzztarget crash minimizecrashinternalstep exactartifactpathhomejohannesgitcargofuzztestcratefuzzartifactsfuzztarget minimizedfroma f b a d b f c fa f b d fd b c f tmplibFuzzerTemp txt No such directory homejohannesgitcargofuzztestcratefuzzartifactsfuzztarget minimizedfroma f b a d b f c fa f b d fd b c f exiting Libfuzzer supports usersupplied mutators for structureaware fuzzing The user should provide a function cpp extern C sizet LLVMFuzzerCustomMutator uint t Data sizet Size sizet MaxSize unsigned int Seed that mutates the data and it can call LLVMFuzzerMutate to while doing so Would it be possible to support this in cargofuzz