use underscores just to simplify I think the datastructure for tree has been defined wrong sealed trait Tree A case class Leaf A value A extends Tree A case class Branch A left Tree A right Tree A extends Tree A The problem with this current definition is it can have different size depending on how you count the tree Currently the tree can have node without value it is purely node eg BranchBranchLeaf BranchLeaf Leaf Leaf If you draw it on the paper it will have branch without value the first one is the root and it has leaves with values So do you count the tree size as only leaves or leaves and nodes or even using the answer provided in the current master branch ends up with Instead after quick search on the internet the answer on this stackexchange gives better data structure for the tree But of course it does not need to be binary tree so the isValid part is not needed hopefully fixes the build and not G and H The provided solution for exercises and were incorrect this PR attempts to fix them Suspend should be defined as case class Suspend F A f F Free F A extends Free FA but in the book snippet it says case class Suspend F A f F A extends Free FA the correct definition changes the solution Started going through the book today and looking through the exercises for chapter listscala in particular I noticed that the answers are left out for some exercises and for some they are pasted in instead of the unimplemented function signatures I expected the exercises files to be skeleton code for filling in with our answers and then if needed we could look up the answers in the answerkey directory Why are they already in the exercise file Doesnt that spoil the learning experience exercisessrcmainscalafpinscalaparsingParsersscala value drop is not a member of javautilstreamStream String lines method which returns javautilstreamStream was newly added to javalangString in Java so you should use linesIterator method instead if youd like to compile with Java or above cf why scala def modify S f S S State S Unit for s get Gets the current state and assigns it to s setfs Sets the new state to f applied to s yield I think is same scala def modify S f S S State S Unit Statesfs contrary logic eyeseyeseyes 