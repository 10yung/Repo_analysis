On the short list of things the loading process still needs TLS callback initialization Late imports a fork of sRDI already has this just needs merging Environment Win DLL C Windows SysWOW user dll I firstly use command python Python ConvertToShellcodepy user dll convert user dll to user bin Then I change the code in Native Loadercpp to call API MessageBoxA after loading the user dll and compile the Native project using Visual Studio Debug x Only set the first page to RWX This is should sufficiently cover the sRDI shellcode up top if VirtualProtectfinalShellcode sysInfodwPageSize PAGEEXECUTEREADWRITE dwOldProtect RDI rdi RDIfinalShellcode printf Executing RDI n UINTPTR hLoadedDLL rdi Excute DLL freefinalShellcode Free the RDI blob We no longer need it Function exportedFunction FunctionGetProcAddressRhLoadedDLL SayGoodbye if exportedFunction printf Calling exported functon n exportedFunction MyMessageBoxA exportedFunction MyMessageBoxAGetProcAddressRhLoadedDLL MessageBoxA if exportedFunction printf Calling exported functon n exportedFunction Hello user dll message typedef int WINAPI MyMessageBoxAHWND hWnd LPCSTR lpText LPCSTR lpCaption UINT uType Then use command Nativeexe user bin to load the shellcode The exe crashed and report a error x CCC ntdlldll located at Nativeexe Exception xC Access violation reading location x I ensure that the GetProcAddressR return the correct address of MessageBoxA I found that the x CCC belongs to ntdlldllRtlAllocateHeap function Do you have comments that which possible cause this problem My conclusion is that reflective loading a DLL written by ourselves works fine but loading a system dllntdll user will not work It seems that there is something the loader doesnt handle when load the system dll into memory Is it currently possible to execute by ordinal after load This would be a pretty neat feature combined with Cobalt StrikeDanderSpiritz etc UPDATE Just hit me that both of those have export names would still be a nice feature though