This helps in situations where you are creating or updating views from within a Rails engine By adding the rootpath to the statement it will be able to correctly find the file The rootpath DatabaseEngineroot is the part that is manually added I didnt find any method of autodetecting the rails engine so this would have to be manually added after generating the migration Solves the issue I brought up in createview createview productstats version rootpath DatabaseEngineroot updateview updateview productstats version reverttoversion rootpath DatabaseEngineroot replaceview replaceview productstats version reverttoversion rootpath DatabaseEngineroot ff c f aee e ba f b d ed fc f Fixes an issue where the generated migration for a schema qualified view name is not properly camelized rails g scenicview nonpublicsearch create dbviewsnonpublicsearchesv sql create dbmigrate createnonpublicsearchesrb head dbmigrate createnonpublicsearchesrb class CreateNonPublicsearches ActiveRecordMigration def change createview nonpublicsearches end end The generated class name should be CreateNonPublicSearches instead of CreateNonPublicsearches ff c f aee e ba f b d ed fc f Fixes an issue where having generated a scenic view for a schema qualified view and editing its view definition running rake dbmigrate fails to find the view definition rails g scenicview nonpublicsearch create dbviewsnonpublicsearchesv sql create dbmigrate createnonpublicsearchesrb vim dbviewsnonpublicsearchesv sql bundle exec rake dbmigrate CreateNonPublicSearches migrating createviewnonpublicsearches rake aborted StandardError An error has occurred this and all later migrations canceled No such file or directory rbsysopen Usersbrianchhundbviewsnonpublicsearchesv sql Usersbrianchhundbmigrate createnonpublicsearchesrb in change Usersbrianchhunrbenvversions binbundle in load Usersbrianchhunrbenvversions binbundle in main Caused by ErrnoENOENT No such file or directory rbsysopen Usersbrianchhundbviewsnonpublicsearchesv sql Usersbrianchhundbmigrate createnonpublicsearchesrb in change Usersbrianchhunrbenvversions binbundle in load Usersbrianchhunrbenvversions binbundle in main Tasks TOP dbmigrate See full trace by running task with trace Im working on a project where were using Postgres multischema with views which would lead to views that would theoretically be created with a call like this one createview schemanameviewname However because Scenic requires the view name to be the same as the definition files name the dot in the view name when specifying the target schema means that I cant really use schema definition files This PR adds a definedas flag to allow users to override the definition file name Hi concurrentlytrue is not passed down to refreshdependenciesfor which results in depending mat views being refreshed without concurrency def refreshmaterializedviewname concurrently false cascade false raiseunlessmaterializedviewssupported if cascade refreshdependenciesforname end end Hi There is a flaw in the Postgres Adapter DependencyParser class to find out which mat views are dependencies of the mat view that is being refreshed It results in unrelated mat views being refreshed The reason is tsortdependencyhash puts all mat views in the db linearly in an array including ones that have no relation to the mat view being refreshed Take this example A depends on B which depends on C E depends on D which depends on C No matter what you do A will either be before E in the array or after it example CBADE example CDEBA If I refresh cascade true mat view E it will also unnecessarily refresh B then A in example If I refresh cascade true mat view A it will also unnecessarily refresh E then D in example TLDR Forcing all mat views in the db into a single linear dependency array will cause unnecessary and costly refreshes of unrelated mat views EDIT This problem is not only about mat views having a common ancestry It also applies to situations with no common ancestry A depends on B which depends on C F depends on E which depends on D tsortdependencyhash might put all mat views in a single array that will look like the following CBADEF Refreshing F with cascadetrue will result in all mat views being refreshed Im finding that with each migration we do the view definitions get moved around in my schema file This leads to unnecessary schemarb changes that make it pretty difficult to track the actual changes to the file Does anyone else have this issue We would like to use scenic from within a rails engine However the path to the view is not coming up correctly In my example I have this app db components products db views The products is the rails engine that is referenced by the main app by this ruby path components do gem products end and to get rails to recognize regular migrations this is put in the enginerb ruby module Products class Engine RailsEngine isolatenamespace Pipedrive initializer appendmigrations do app unless approottosmatch roottosFileSEPARATOR appconfigpaths dbmigrate concat configpaths dbmigrate expanded end end configgenerators do g end end end Failing in the component directory From inside the componentsproducts directory when I run a rake dbmigrate it seems to be looking for the view in testdummydbviews instead of dbviews details summary CreateExpandedDeals migratingsummary CreateExpandedDeals migrating createviewexpandeddeals rake aborted StandardError An error has occurred this and all later migrations canceled No such file or directory rbsysopen UsersnathanSourcetestappcomponentsproductstestdummydbviewsexpandeddealsv sql Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in read Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in tosql Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in definition Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in createview Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in methodmissing Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in methodmissing UsersnathanSourcetestappcomponentsproductsdbmigrate createexpandeddealsrb in change Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in execmigration Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block levels in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractconnectionpoolrb in withconnection Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in block in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in block in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordtransactionsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in each Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in withadvisorylock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in up Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordtasksdatabasetasksrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordrailtiesdatabasesrake in block levels in top required Usersnathanrvmgemsruby gemsrake exerake in top required Usersnathanrvmgemsruby binrubyexecutablehooks in eval Usersnathanrvmgemsruby binrubyexecutablehooks in main details Failing in the main app And if I try to run the migration from the main app itself its looking for it in dbviews instead of componentsproductsdbviews details summary CreateExpandedDeals migratingsummary CreateExpandedDeals migrating createviewexpandeddeals rake aborted StandardError An error has occurred this and all later migrations canceled No such file or directory rbsysopen UsersnathanSourcetestappdbviewsexpandeddealsv sql Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in read Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in tosql Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in definition Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in createview Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in methodmissing Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in methodmissing UsersnathanSourcetestappcomponentsproductsdbmigrate createexpandeddealsrb in change Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in execmigration Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block levels in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractconnectionpoolrb in withconnection Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in block in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in block in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordtransactionsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in each Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in withadvisorylock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in up Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordtasksdatabasetasksrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordrailtiesdatabasesrake in block levels in top required Usersnathanrvmgemsruby gemsrake exerake in top required Usersnathanrvmgemsruby binrubyexecutablehooks in eval Usersnathanrvmgemsruby binrubyexecutablehooks in main ErrnoENOENT No such file or directory rbsysopen UsersnathanSourcetestappdbviewsexpandeddealsv sql Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in read Usersnathanrvmgemsruby gemsscenic libscenicdefinitionrb in tosql Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in definition Usersnathanrvmgemsruby gemsscenic libscenicstatementsrb in createview Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in methodmissing Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in saywithtime Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in methodmissing UsersnathanSourcetestappcomponentsproductsdbmigrate createexpandeddealsrb in change Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in execmigration Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block levels in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractconnectionpoolrb in withconnection Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in block in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in block in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstracttransactionrb in withinnewtransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordtransactionsrb in transaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in ddltransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in executemigrationintransaction Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in each Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migratewithoutlock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in block in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in withadvisorylock Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in up Usersnathanrvmgemsruby gemsactiverecord libactiverecordmigrationrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordtasksdatabasetasksrb in migrate Usersnathanrvmgemsruby gemsactiverecord libactiverecordrailtiesdatabasesrake in block levels in top required Usersnathanrvmgemsruby gemsrake exerake in top required Usersnathanrvmgemsruby binrubyexecutablehooks in eval Usersnathanrvmgemsruby binrubyexecutablehooks in main Tasks TOP dbmigrate See full trace by running task with trace details Possible fixes From looking around PR might fix this but since that was submitted in February I wasnt sure if it would be merged in any time soon I havent seen any feedback from the original author though calebthompson did comment on it a day or so ago Added a method which return the view is populated or not REFRESH MATERIALIZED VIEW CONCURRENTLY doesnt work for a view which is not populated even it has unique index This method is useful to perform concurrent refresh if its possible Real use case in Rails will be like this Database is loaded from structuresql to run specs but the view isnt populated yet so concurrent refresh is not possible We want to fallback to normalnonconcurrent refresh in this case After initial population views are expected to be refreshed concurrently Its possible because the view is already populated Our team is using a concern below to cope with the case This pull request is extracted from this module MaterializedView extend ActiveSupportConcern included do class self def materializedviewpopulated connectionexecuteSELECT relispopulated FROM pgclass WHERE relname tablenamefirst relispopulated end def refreshmaterializedviewconcurrently true Scenicdatabaserefreshmaterializedviewtablename concurrently materializedviewpopulated concurrently cascade false end end end end I needed to use this in a rails engine and didnt want to have to copy dbviews over for every rails app This makes it so the the definition is searched for in multiple paths when trying to call tosql Generator paths arent affected I leveraged Rails configpaths for configuring additional dbviews paths I could change it so that the paths are apart of ScenicConfiguration I just thought putting it in Railsconfigpaths dbviews would pair nicely with Railsconfigpaths dbmigrations works Im able to make this work with a rails engine by using the following in enginerb ruby initializer appendmigrations do app appconfigpaths dbviews rootjoindbviews unless approottosmatch roottos configpaths dbmigrate expandedeach do expandedpath appconfigpaths dbmigrate expandedpath end end end pixielabs Scenic We use lots of materialized views with dependencies and it can be quite painful to update them in a migration especially remembering to recreate indexes This PR Adds an optional cascade true to dropview and updateview Makes updateview recreate any views that are lost during the view being updated including any indexes on those views Stops the user from rolling back dropview if they use cascade true because you cant tell what mightve been lost Ive made the necessary change in CommandRecorder Things of note bits Im unsure about I dont know how this impacts the sqlite adapter if at all I made tryindexcreate public because Im using it to recreate indexes but Im not using it via the on method This is a new use of IndexReapplication and Im conscious of that perhaps some bigger API changes could be done here but I didnt want to mess around too much If theres anything that needs changing or any questions let me know