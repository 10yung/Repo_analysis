Hello Im experiencing an issue when changing the scope and sending to the first position at the same time for rows inside a transaction and Im suspecting its because Im around MINRANKVALUE I dont know if Im doing something wrong of if this is a legitimate bug heres the information Ive gathered so far My situation Table creation tbigint roworder null false Model rb include RankedModel ranks roworder withsame i scope scope All rows with scope id roworder scope scope What Im doing Inside a transaction Updating with scope and roworderposition first Updating with scope and roworderposition first My Code renamed rb MyClasstransaction do myinstances MyClass MyClass reverseeach do myinstance myinstancelock myinstanceupdatescope Scope id roworderposition first end end The crash The first update for id seems to go through but the second one fails here And then everything gets rolled back in Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrankerrb def rebalanceranks if rank instancepersisted origin currentorderindex item iteminstanceid instanceid destination currentorderindex item rank itemrank destination if origin destination currentorderinsert destination currentorderdeleteatorigin end byebug currentordermap item iteminstanceid byebug instanceid byebug origin nil byebug destination byebug origin destination NoMethodError Exception undefined method for nilNilClass nil StackTrace details summaryClick to Reveal StackTracesummary undefined method for nilNilClass Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrankerrb in rebalanceranks Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrankerrb in rankataverage Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrankerrb in updateindexfromposition Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrankerrb in handleranking Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrb in block in handleranking Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrb in each Usersnaterbenvversions librubygems gemsrankedmodel librankedmodelrb in handleranking Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block in makelambda Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block levels in halting Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block levels in defaultterminator Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in catch Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block in defaultterminator Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block in halting Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in block in invokebefore Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in each Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in invokebefore Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in runcallbacks Usersnaterbenvversions librubygems gemsactivesupport libactivesupportcallbacksrb in runsavecallbacks Usersnaterbenvversions librubygems gemsactiverecord libactiverecordcallbacksrb in createorupdate Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtimestamprb in createorupdate Usersnaterbenvversions librubygems gemsactiverecord libactiverecordpersistencerb in save Usersnaterbenvversions librubygems gemsactiverecord libactiverecordvalidationsrb in save Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in block in save Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in block in withtransactionreturningstatus Usersnaterbenvversions librubygems gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in transaction Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in transaction Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in withtransactionreturningstatus Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in save Usersnaterbenvversions librubygems gemsactiverecord libactiverecordsuppressorrb in save Usersnaterbenvversions librubygems gemsactiverecord libactiverecordpersistencerb in block in update Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in block in withtransactionreturningstatus Usersnaterbenvversions librubygems gemsactiverecord libactiverecordconnectionadaptersabstractdatabasestatementsrb in transaction Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in transaction Usersnaterbenvversions librubygems gemsactiverecord libactiverecordtransactionsrb in withtransactionreturningstatus Usersnaterbenvversions librubygems gemsactiverecord libactiverecordpersistencerb in update details Gut feeling I dont have a good grasp of what the gem is trying to accomplish in that method but it seems like Im only getting in that method because my first update for id must set roworder to be before element id which has roworder so it must end up being or But now my second update for id must do the same thing and would probably need roworder or below which is the MINRANKVALUE which probably triggers the call to rebalanceranks currentorder does not have the current instance so origin is nil and we get the crash at the comparison I feel like the fix might be something along the lines of preadding the current instance to currentorder when the scope is changing at the same time adding a check on originnil casting origintoi to get nil or maybe it should take a higher value than destination then Not quite sure Anyways I hope this is clear enough and helpful let me know if youd like more information or clarification Thank you I took a shot at moving the CI pipeline to Github Actions to see if it adds value to the project Seeing two benefits right now Faster builds Taking less than minutes example so faster than Travis despite running more jobs More flexibility defining services Eg testing on MySQL which isnt available on Travis afaik Notable changes Updated lockfiles and moved them back into version control This is to enable caching in CI based on checksums of these files Added Ruby to the matrix Future work Couldnt make MySQL work with JRuby Since I dont use either of those it would be nice to get help from contributors who do Testing on MySQL breaks due to invalid SQL Again Id like to get eyes on it from some MySQL users Screen Shot at PM Interested in migrating or sticking to Travis Adding an option for preferred gap size between ranked models which is being used when adding items first and last Its also used when rebalancingranks is triggered Doing it because were using the gem together with Ember and some drag n drop Users tend to drag a lot of items to the top first We want to avoid collisions as much as possible cause when were touching other models than the one being updated the data is no longer synced between front and backend Do whatever you want with this PR just throwing it out there Hello when using mobility json backend in combination with ranked model we see that when we update the position ranked model also tries to save the translations columns as null instead of an empty hash which is the default behaviour Following test case shows the issue funny enough if I remove the withsame option it all works fine and placeholder does not get updated You need a database called scratches with postgres to run the file ruby require bundlerinline gemfiletrue do source gitsourcegithub repo Activate the gem you are reporting the issue against gem activerecord gem pg gem rankedmodel gem mobility gem enumerize end require activerecord require minitestautorun require logger Mobilityconfigure do config configdefaultbackend jsonb configaccessormethod translates configquerymethod i n configdefaultoptions localeaccessors true configdefaultoptions fallbacks true configdefaultoptions dirty true end This connection will do for databaseindependent bug reports ActiveRecordBaseestablishconnectionadapter postgresql database scratches ActiveRecordBaselogger LoggernewSTDOUT ActiveRecordSchemadefine do droptable registrationformfields ifexists true droptable registrationforms ifexists true createtable registrationforms force true do t tstring name null false end createtable registrationformfields force true do t tstring name null false tjsonb label default null false tjsonb placeholder default null false tinteger roworder tbelongsto registrationform foreignkey true index true null false end end class RegistrationForm ActiveRecordBase hasmany fields classname RegistrationFormField dependent destroy inverseof registrationform end class RegistrationFormField ActiveRecordBase include RankedModel extend Mobility belongsto registrationform ranks roworder withsame registrationformid translates label type string translates placeholder type string end class BugTest MinitestTest def testassociationstuff registrationfrom RegistrationFormcreatename jefke puts registrationfromfieldscreatename email label email registrationfromfieldsfirstreload registrationfromfieldsfirstupdateroworderposition end end Im evaluating implementing this gem on a project with lots of existing records I couldnt find any info in the docs about how to correctly migrate data Heres my model ruby module Properties class Image ApplicationRecord include RankedModel ranks sortorder withsame propertyid end end there is a unique index on these columns Im using Postgres ruby addcolumn propertiesimages sortorder integer addindex propertiesimages propertyid sortorder unique true Heres the migration script that keeps failing due to a violated uniqueness constraint ruby ActiveRecordBasetransaction do Propertyallfindeach do property PropertiesImagewhereproperty propertyordercreatedat desceachwithindex do image index imageupdatesortorderposition index end end end Whats the recommended way to populate the new column once this gem is installed Adds a general cannot rearrange functionality leverages it to abort save when cannot rearrange Alternate strategy to Extracted from Remove trailing whitespace Make onlyfailures possible Always call super from included Have less activerecordbase envy None A take on first do no harm when seeing the occasional NoMethodError undefined method rank for nilNilClass Most recent call first File appvendorbundleruby gemsrankedmodel librankedmodelrankerrb line in rearrangeranks There are various possible strategies for handling a missing currentx reset cache and retry make a best effort with what we know calculate freshness of the current instance and do something when not fresh have a pluggable strategy when no longer fresh try to lock the rereranking Related Work done just the failing test two commits failing test make it pass strategy skip cannot rearrange this PR strategy abort save unrelated misc Introduced in 