Using the net CLI Im trying to run MSpec tests this works perfectly outside of Docker dotnet test MyMspecTestProjectcsproj No problem there but if I try the same command inside a Docker container I get Test run in progress No test is available in binDebugnetcoreapp MyMspecTestProjectdll Make sure that installed test discoverers executors platform framework version settings are appropriate and try again I figured this was related to it not having an appropriate package but Ive restored it inside the container with all the following MicrosoftNETTestSdk Version MachineSpecificationsRunnerConsole Version MachineSpecificationsRunnerVisualStudio Version MachineSpecifications Version Anything else I might be missing Cloning this repo is around mb which is not overly burdensome but is not ideal either I propose a destructive cleanup with something like BFG to reduce old copies of DLLs that have long since been deleted from the repo but still exist in the git folder This will require any forks to either reclone or rebase somehow so that everything is in sync again In projects Ive worked with weve noticed that we dont deviate from one flavor of MachineFakes in our case Moq For the rare cases where weve needed additional control over the mocking we just reference Moq directly and use it as normal In addition to the above the overhead in supporting multiple frameworks is a bit overbearing and also prevents to varying degrees those frameworks from progressing Also RhinoMocks is basically abandoned and will never support netstandard On a picky note its always irked me that the package and namespace does not line up with MachineSpecifications One benefit of aligning Fakes to Mspec would be that we have verified packages on Nuget for MachineSpecifications To solve the above I propose a new package MachineSpecificationsFakes This would be a single package that depends on CastleCore and would be a homegrown fake library We would still allow extensions points like IFakeEngine so that consumers could implement their own flavor of Fakes for Moq or FakeItEasy etc Im happy to archive the code we have for these implementations or move them to an example project or something but to cease maintaining them Users that for whatever reason insist on using the current MachineFakes can continue to do so under version of MSpec Hi Is there a road map with some timescales for MSpec We want to improve the DevOps VSTS VS adapter eg support tags make the test into a hierarchy record total times etc We dont want to write this if the code base is moving soon Do you have any idea one when will be due we would love to help beta test it Thanks robertcoltheart ivanz xUnit is proposing targeting netstandard as a baseline for the release I propose that we do the same for our release The reason for this is many of the versions we currently support are either already EOL end of life or are tied to versions of Windows that will end support soon This includes net an OS component of Windows which is hitting end of support in Jan This means that we would target netcoreapp net see footnote in first link below uap Sources Please add a runner for Azure DevOps that we can use we are currently using net It would be nice if it also reported the progress in real time Hi You can see my problem in the following screenshot I realize the value that appear in the Resharper Runner for the class Subject doesnt match Ive clean the project deleted all the cache and no luck The Console runner report the test correctly but not Resharper Runner I really dont know if this problem is in the Resharper Plugin or something that is created outside of it because maybe an implementation detail on Resharper But it will be really helpful if this can be addressed Hi First of all thanks for a great testing framework We use it extensively at work and are generally very pleased with it However weve run recently into a weird situation where equality tests seem to be failing when they shouldnt Its easier to explain with an example Consider a Person class which implements both IEquatableT and IComparableT persons are equal if they have the same ID the order between persons is defined by their name alphabetical So a sorted list of persons might look like Amy Ben Ben Beth with no preference for which Ben comes first c class Person IEquatablePerson IComparablePerson private readonly int id private readonly string name public Personint id string name id id name name public bool EqualsPerson other return other null otherid thisid public override int GetHashCode return id public int CompareToPerson other return thisnameCompareToothername And the following test c class Test static Person person person Establish context person new Person John Doe person new Person John Doe Same name different person It shouldhavethesamerank person CompareToperson ShouldEqual assertion passes It shouldnotbethesameperson person ShouldEqualperson assertion passes but should fail It shouldbe differentpersonsv person Equalsperson ShouldBeFalse assertion passes It shouldbe differentpersonsv person ShouldNotEqualperson assertion fails but should pass For some reason of these assertions fail We had a quick look at why that might be and it seems that MSpec uses a number of Comparer strategies as defined here I could be wrong but do these mean that MSpec gives IComparableT preference over IEquatableT If so that seems to me like a misunderstanding I always thought IComparable was about ordering things and IEquatable was about defining what makes things equal So I think I would expect the EquatableComparer to come first in the list and to be the only comparer used for cases which do implement IEquatableT If I have explicitly defined the meaning of equality for a type Id expect this to be the only definition of equality IComparableT to not feature in the list since it is about comparison not about equality To me thats a different use case at least that s how I read the docs IComparable is about ordering and sorting IEquatable is about equality For instance in the example above persons can have the same name and therefore the same order but that doesnt mean they are the same person Am I missing something Is there an underlying reason for using IComparableT when determining equality What is the recommended way to test equality for objects which implement IComparableT We also found this old issue which is somewhat related Thanks for your help Would it be possible to get the Establish and because delegate names in to the reports Establish mycomplexpreconditionsshouldshowasgivenpartinreport Because excersizingmybehaviorshouldshowaswhenpartinreport Hi I am trying to to send the XML output to SonarQube but get the error Missing root element results When I look into the report file it looks a bit strange lots of Enter and Exit tags it seems like a debug output of the parser So my question is is this intentional If yes what is it good for Andor could we get something similar to the NUnit output to send it to a report generator 