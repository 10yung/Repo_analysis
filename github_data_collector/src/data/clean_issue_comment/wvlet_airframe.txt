 Thsi PR is for reproducing sbt clean projectJSfastOptJS error stack trace is suppressed run last airframeJS Compile fastOptJS for the full output error stack trace is suppressed run last metricsJS Compile fastOptJS for the full output error stack trace is suppressed run last codecJS Compile fastOptJS for the full output error airframeJS Compile fastOptJS javalangNoClassDefFoundError jdkinternalreflectMethodAccessorImpl error metricsJS Compile fastOptJS javalangNoClassDefFoundError jdkinternalreflectMethodAccessorImpl error codecJS Compile fastOptJS javalangNoClassDefFoundError jdkinternalreflectMethodAccessorImpl error Total time s completed Jan AM Running the same command again finishes the compilation successfully projectJSfastOptJS info Fast optimizing Usersleoworkgitairframeairframemetricsjstargetscala airframemetricsfastoptjs info Fast optimizing Usersleoworkgitairframeairframejstargetscala airframefastoptjs info Fast optimizing Usersleoworkgitairframeairframecodecjstargetscala airframecodecfastoptjs success Total time s completed Jan AM sbtairframeroot Splitting the project into multiple subprojects works clean projectJSCorefastOptJS projectJSSubfastOptJS When we need to add a new lifecycle hook to an existing design we need to write code like this scala val d newDesign bind X toProvidernew X bind Y toSingleton Currently we need to replicate the binding val d d bind X toProvidernewX onStart x initialize x To reduce the code duplication we need to split the code like this like this scala val xDesign bind X toProvidernew X val d xDesign bind Y toSingleton val d d xDesignonStart x initialize X Can we just add a lifecycle hook like this scala val d newDesign bind X toProvidernew X bind Y toSingleton val d dbind X onStart x initialize X If the return type of a test method is Future we should retrieve the result asynchronously For JVM AwaitresultFuture DurationInf works For Scalajs there is implementing Awaitresult is not straightforward because JavaScript doesnt have the notion of blocking Approaches to support Async testing in Scalajs would be A Wait until the Futurevalue becomes available B Build a tree of Future results and run tests asynchronously A is technically impossible as the waiting context will hold the execution control so Future will never complete while waiting the completion so we need to implement B which is better as we can also use this effort to implement a standalone AirSpec launcher Add a failfast behavior to the http client to protect the target API service This should be able to disable with noCircuitBreaker option Support using a custom circuit breaker with withCircuitBreaker scala val d newDesignbind X toProvider yY new XY dnewSession session sessionwithChildSessionDesignempty childSession val x sesionbuild X x is initialized in parent session but Yclose is registered to the child session Y should be initialized in the parent session as its initialization is hooked at the parent session This ticket is a placeholder for tracking goals for Airframe development Reference Airframe Milestone airframebenchmark Multithread throughput benchmark airframecodec Performance improvement by switching to pureScala msgpack performance improvement can be achieved compared to the current version PackSupportUnpackSupport interface to define custom codec Optimize the packunpack performance when inputoutput types are known Check the presence of nonserializable types airframecontrol x CircuitBreaker RateControl eg leaky bucket Retry throttling copy betwen streams cache like Guavas Cache Probably this is the last resort to be free from Guava library dependency exaple FaultTolerantCache in robustools Multimap airframedi bindConfig D D C Integrating with famous Scala libraries examples Using Airframe with Spark We already have this example in production airframehttp Scala As A Microservice IDL Support separting serverclientside implementations Generate client code from the server definition Create sbtairframehttp sbt plugin Scala client generation Scalajs client generation API doc generation Add http logging under consieration Generate Open API specification Finagle Scala support x Scalajs support backendindependent requestresponse objects Scalajs http client x CORS filter circuit breaker airframehttprecorder Recording snapshots in YAML or JSON local files for humanreadability airframehttpwidget UI widget collection library for Scalajs airframejdbc Support inserting case class instances as table records airframejmx remote method call json output for complex types airframelauncher Allow passing global option objects to child command airframemsgpack Nested cursor support for the better error handling Handle EOF without using EOFException for stream RPC support Guess a schema of msgpack data benchmark to utilize multiplethreads airframesql SQL filter evaluation for msgpack stream SQL support x SQL typer SQL decomposer SQL processing code generator Scala target airframewidget variable virtual dom UI widget collection airspec x test design d d Power assertion for test failures eg show the condition expression and data differences Use function return values to record test results There might be more meaningful usage of function return values eg storing test data to DB sending metrics to fluentd etc Asynchronous tests returning Future type for Scalajs Support contextrun A additional design to support finegrained design customization IntelliJ plugin Create a standalone launcher for running tests Applications to runtime testing smoke testing active monitoring Scala dotty airframelog support Surface support airframedi support AirSpec support airframeconfig support airframehttp support When a type X contains nonserializable types in its parameters MessageCodecof X toXXX will throw a runtime exception For the application safety we should be able to check whether the type is serializable or not when creating a codec scala case class XpY case class YaNonSerializableType val codec MessageCodecof X Throw NonSerializable exception eg Ya is not serializable 