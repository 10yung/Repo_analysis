Code banking Many modern chips cc C F have code memory address extension by banking Ref Ref How can I deal with it Switch jump table Compilers usually emit jump table for switch statement How can i specify switch paradigm for simple test code attached Hello I have an instruction which gets registers reg reg does some logic and puts the result into resultReg The logic is as follows c mask x resultReg LoopStart temp reg mask resultReg if reg temp Branch to next instruction resultReg mask mask Branch LoopStart My problem is that i cant branch to LoopStart because it doesnt have a real address as it is in the middle of a cluster Ive looked at the the NextStatmentRequiresLabel flag but it doesnt seem to do what I need Is there any way to do this During decomping an old Windows Bit Protected Mode Windows executable I need to add required DLLs If i try to add binary nothing happens Sample program LinkIIgs Error occurs during Analyze dataflow ErrorAn internal error occurred Offset must be nonnegative Parameter name bitOffset Using the the analysisdevelopment branch I am seeing the issue where D is being included in the procedure declaration in linkiigs at f INITCURSORCTL It appears that D is pushed onto the stack at the start of the function and restored from the stack at the end of the function It appears that D is only being used after having a value assigned I have included a project file for linkiigs that has all but four of the procedures named and matched against library proceduresfunctions LinkIIGSHqx zip By using the contents of a library file Function names and binary that makes up the function can be utilised to enhance the decompilation process IDA has a tech called FLIRT which does this In the standard compilation process library files are linked into the exe copying the relevant parts into the bin you cannot do a straight search for the library binary as optimisers cut out bits that are not used and the linker process will change some bytes values as they are addresses It will require for an application to create signature files which will in effect scan the library file to produce list of the function names and the binary pattern that makes up the app this will be saved away as a signature file this app will have to process COFF ELF and MACHO but I would recommend that you need to understand instruction sets here Then within Reko as part of the decompilation process after the functions have been identified a search will be required to see if a pattern match exists but it will have to take into account some byte values have changed due to the change of address values It will require that the disassemblers identify which instructs contain a operand which is an address in this case the operand values will be ignored To do this the best way is to load all the signature files into a tree like structure then as a function is check if the operand is identified as an address the process will jump down the size of the operand then check for the next byte match This will continue until either the function being examine has no more bytes to check if at this point the tree has a leaf which contains a function name the function been examined is renamed After selecting a method in the tree view the correct assembly and code are displayed an a split window The problem is that if the number of params is large you cannot scroll to see all the params within the window even if you move the split fully across to the left Yes move again The only reason for suggesting this is that it will remove issues going ahead something that could be done on small blocks does not need a big bang approach and will also provide a UI that WFP that could be used going forward Provide the functionality to all the user to define know data types and structures that will be used in the assemble and decompiled code