 Introduce a DataMap type something to cache values on Node instances Deprecate getUserDatasetUserData from Node Using the DataMap is better since any kinds of frameworks can cache their own data at they like If you dont have the key you cant even touch or even see the data so nobody can mess with someone elses data Cache metrics on Nodes This means we can drop all the stuff about MetricsFacade MetricsMemoizer MetricsComputer QualifiedName QualifiableNode etc We dont need to reset the static cache awkwardly We can also stop constraining metrics framework to only a few kinds of nodes One can define a metric for any node without having to introduce awkward supertypes like MethodLikeNode All the framework is condensed into MetricsUtil in pmdcore Languagespecific fa ades are deprecated The only thing that cannot be made language independent is ResultOption in fact just fetching operation nodes from a type node This is not a big deal as the aggregation logic can still be reused on any Iterable of node This makes the metrics framework pretty trivial and very easy to extend Id like this to be part of since this avoids publishing LanguageMetricsProvider implementations Affects PMD Version Further releases Rule CommentedOutCode Description Commented out code is a nono FYI lintr has a linter that flags commented out code for removal TODO on master Internalize CharStream and its implementations Internalize all classes generated by JavaCC in particular ParserConstants ParserTreeConstants ParserTokenManager TODO on PMD languages to port x Java Modelica VM VF PLSQL JSP CPD languages to port must set the property nojjtree on the target in the pomxml Python ObjectiveC Javascript Matlab TODO once all languages are ported Move CharStream to impljavacc package Rename CharStream methods to match decent naming conventions Cleanup AbstractNode Remove token methods fields and put them on AbstractJjtreeNode Remove text position fields beginLineetc Remove ID field Cleanup Node interface Remove JJTree methods jjtClose jjtGetId etc Should we really consider TokenKinds a published API Since token kinds are compiletime constants adding or removing tokens in the grammar may break binary compatibility implicitly Description Can anyone tell me what role and purpose does SourceForge continue to serve PMD as I signed up at the group and apart from an update email from Oracle wrt to upcoming Java releases there is no activity on the group discussions As far as I can see this list is defunct If its being used its mainly as an referenced archive and a mailing list You can easily create a Google group one for PMD developers and another for users to answer more general questions Existing users can be migrated to these groups with their permission There appears to be some commit activity visible for pmdcore Additionally the site is not mobilefriendly either So I was fiddling with Intellijs profiler and found out that the constructor of ClassNotFoundException slows down classloading by a huge factor In all usages that matter the exception is immediately caught by the caller and ignored With this change we return null instead This speeds up type resolution by a factor of Heres a comparison on the sources of OpenJDK around source files Master java Resolved unresolved Resolved Errors Rule Label Time secs Self Time secs Calls Counter TypeResTest Total Rule Summary Label Time secs Self Time secs Calls Counter Rule Rulechain Rule Collect Files Load Rules Parser Qualified Name Resolution Symbol Table Type Resolution Rulechain Visit Reporting File Processing Unaccounted Total Label Time secs Self Time secs Calls Counter Wall Clock Time Now java Resolved unresolved Resolved Errors Rule Summary Label Time secs Self Time secs Calls Counter TypeResTest Total Rule Summary Label Time secs Self Time secs Calls Counter Rule Rulechain Rule Collect Files Load Rules Parser Qualified Name Resolution Symbol Table Type Resolution Rulechain Visit Reporting File Processing Unaccounted Total Label Time secs Self Time secs Calls Counter Wall Clock Time Bonus I tried the same thing with my prototype for and got these results java Resolved unresolved Resolved Errors Rule Label Time secs Self Time secs Calls Counter TypeResTest Total Rule Language Specific Processing Label Time secs Self Time secs Calls Counter Java Java processing Qualified name resolution Symbol table resolution Total Language Specific Processing Summary Label Time secs Self Time secs Calls Counter Rule Rulechain Rule Collect Files Load Rules Parser Rulechain Ast Indexation Reporting File Processing Unaccounted Total Label Time secs Self Time secs Calls Counter Wall Clock Time So its nearly times faster than current master Note that the time is spent in the rule rather than in the processing stage Thats because its done on demand by the rule This sample rule resolves all TypeNodes in the tree though Qualified name resolution and Symbol table resolution are sub tasks of Java Processing The contract of NodegetChild is to throw when the index is out of bounds Antlr parse trees also happen to have a getChild method whose contract is to return null in this case Should we align ourselves I think its reasonable though this needs to be pointed out in the release notes as its a noticeable departure from the current status quo I think it would be nicer to have a single command pmd with various subcommands instead of shipping a runsh batch scripts Eg pmd designer pmd astdump pmd run or just pmd as the default command We would then only need a pmd script for bash and pmdbat for windows This is probably would make it easier to setup no need to define an alias less risk for conflicts with other programs Having one JCommander that knows about all subcommands would also probably improve the documentation usage text Useful to know that PicoCLI can also generate bash completion scripts and this would be made simpler with a single entry point Wdyt How are you setting up PMD locally with an alias for runsh different aliases for interesting subcommands both I do both but my aliases are ugly which is why Id appreciate the added consistency Please prefix the report title with the language it applies to within brackets such as java or apex If not specific to a language you can use core NB issues about the rule designer should be opened at Rule AvoidFieldNameMatchingMethodName Description The rule seems to be case insensitive and hence reports a violation for the code sample below Code Sample demonstrating the issue java public class Foo implements IdProvider private static final String ID foo Override public String id return ID private void blah Another method that uses ID Running PMD through Gradle If relevant also include your JDK and OS information eg for ClassNotFoundException LinkageError reflection failures etc Follow up on The PR includes Implementations of the symbol tables for import declarations The order these tables are chained in respects the precedence of each kind of import eg import on demands are shadowed by java lang imports This is described on the packageinfo of the internal package Implementation of the symbol table resolver This is a new visitor that runs after qualified name resolution Its role is to create symbol tables chain them in the correct order and set them on the relevant nodes Input to this process is a SymbolResolver abstraction over a ClassLoader and a special logger object used to report missing declarations If an imported type is missing its still resolved as an unresolved class to perform symbolic resolution later instead of dealing with null everywhere For now everything is inside a processing stage Next steps Implement ASTbased symbols related symbol tables eg for blocks Introduce new type representation API The message attribute of a rule should be validated as a correct MessageFormat at the time the ruleset is parsed In the failure happens at the time a violation is reported The use of MessageFormat for messages should also be documented on the website