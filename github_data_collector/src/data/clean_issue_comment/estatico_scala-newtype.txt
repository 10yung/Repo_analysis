I often wrap newtypes in newtypes and then I want to access the basetype Example scala newtype case class Secretvalue String newtype case class Passwordvalue Secret newtype case class AdminPasswordvalue Password val adminPassword AdminPassword Access the basetype printlnadminPasswordvaluevaluevalue Something like adminPasswordcoerce String would be nice or maybe even adminPasswordunderlying As Coercible is a typeclass I think with the correct derivation it should be possible to get something like it Opinions On Scala with Xsource compiler option newtype macro gives the following warning Autoapplication to is deprecated Supply the empty argument list explicitly to invoke method hashCode or remove the empty argument list from its definition Javadefined methods are exempt In Scala an unapplied method like this will be etaexpanded into a function It makes newtypes unusable with both this option and Xfatalwarnings enabled Initial attempt at implementation of I have checked and this seems to work as it should but sadly usage of another value class to introduce allocationless namebased extractor introduces an usage limitation for macro annotations its impossible to declare a value class inside of another class and sadly test suite classes are one of potential use cases like that Frankly I have no idea how and if this can be circumvented but maybe some other soul can find a way to solve this riddle Tests fail obviously as macro annotations now wont compile with unapply true when declared inside of a class Theres a little less known pattern allowing for highperformance noallocation unapply method construction Its described in this blogpost by Heiko Seeberger Do you think it would be possible to actually generate sensible namebased extractors in your macros The READMEmd compares this library to Haskells newtype and to Tagged types However more crucially it doesnt mention how this is any differentbetter than simply using case class Thingvalue String extends AnyVal From my understand this is an alternative to extends AnyVal hence this info is crucial There are use cases when the generation of the Coercible instances is not required One example might be when using newtype annotation in the internal implementation of a library without bringing a runtime dependency on the Coercible type to the users of the latter A possible way could be to add another flag like the ones in here to drive select this behaviour Something like coercible Boolean true Thanks version scala object Test newsubtype case class VectorPointeraddr Long scala new Array TestVectorPointer console error cannot find class tag for element type TestVectorPointer new Array TestVectorPointer The current encoding allows for some unsafe type ascriptions While this would basically never happen in a real world scenario we should still look into improving the encoding Heres an example of the problem Ive abridged the debug output for simplicity scala scala newtypedebug true case class Foox String Expanded newtype Foo type Foo FooType abstract trait FooTypes extends scalaAnyRef type Repr String type Base rootscalaAny type Foonewtype abstract trait Tag extends rootscalaAny type Type Base with Tag object Foo extends scalaAnyRef with FooTypes defined type alias Foo defined trait FooTypes defined object Foo scala Fooa FooTag javalangClassCastException javalangString cannot be cast to FooTypesTag The main reason for the Tag trait is to anchor the companion so its in the implicit search path Ive been experimenting with refinements to see if that could help but so far Ive been unable to get implicit resolution working without it Currently for newtypes we generate a Coercible O N instance where O is the original type and N is the newtype While this is perfectly fine we go a step further and generate a Coercible F O F N instance for any F This is where we get into trouble There are cases where this shouldnt be permitted due to the nature of the data structure were dealing with For example lets look at how this would work with dogsSet which relies on an implicit Order instance for its operations scala import catsinstancesint import catsOrder import ioestaticonewtypeops import ioestaticonewtypemacrosnewtype Like Int except ordered in reverse newtype case class RevIntvalue Int object RevInt implicit val order Order RevInt Orderfromx y Order Int comparexvalue yvalue Build a dogsSet Int printlndogsSet Set Build a dogsSet RevInt printlndogsSetRevInt RevInt RevInt Set Build a dogsSet Int coerce it to dogsSet RevInt and add an element printlndogsSet coerce dogsSet RevInt RevInt Set One quick and dirty way to deal with this would be to introduce type roles via a type class scala trait TypeRole A type Role object TypeRole def mk A R TypeRole A type Role R instanceasInstanceOf TypeRole A type Role R private val instance new TypeRole Nothing type Nominal A TypeRole A type Role typesNominal type Representational A TypeRole A type Role typesRepresentational object types sealed trait Representational sealed trait Nominal Then wed define this Coercible instance based on the type role scala implicit def reprF F A B implicit ev TypeRoleRepresentational F A Coercible F A F B Coercibleunsafe We then need to define type role instances scala implicit def typeRoleScalaSet A TypeRoleRepresentational Set A TypeRolemk implicit def typeRoleDogSet A TypeRoleNominal Set A TypeRolemk Compiles printlnSet coerce Set RevInt Set Does not compile now printlndogsSet coerce dogsSet RevInt See 