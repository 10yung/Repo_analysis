Currently if pollready returns Ready it effectively reserves something for instance a semaphore token This means you must be following up with call next The only other option is to Drop the service which however is not always possible It was mentioned in the tokio repo that it would be useful to be able to disarm a service This would be particularly useful when one wants to implement an HTTP health check for a load balancer by checking pollready without actually calling Example rust pub trait ServiceRequest where SelfFuture as FutureOutput ResultSelfResponse SelfError type Response type Error type Future Future fn pollready mut self cx mut Context PollResult SelfError fn call mut self req Request SelfFuture fn disarmready mut self And then be used like this rust pub trait HealthcheckServiceExtRequest ServiceRequest fn ishealthy mut self bool if selfpollreadyisready selfdisarmready true else false The proposed new flow would be the following pollready must be called If its Ready it must be followed up with either call or disarmready call must not be called without pollready being called before disarmready may always be called and should undo what pollready did Clone is supposed to either internally call disarmready or do the same it does a Clone should always be disarmed The latter is already the logic that exists in some layers Now obviously its a bit suboptimal that it means not all services will be able to disarmed so it might also be possible to indicate if something can actually be disarmed For instance already existing services might just not ever be disarmable until they get retrofitted Rationale Often one wants to quickly whip up a basic service Many basic services will always be ready and the more complex polling dynamics will arise from layers wrapping them This makes PollReadyOk a canonical and reasonable choice for a default implementation Result Less boilerplate Motivation It is often the case that one wishes to take a service and modify its output or input in some way without changing the behavior of pollready For example turning a service returning ResultParts Body into a service returning ResultRequestBody or modifying the error type Currently there is no ergonomic way to apply such changes without a fair amount of boilerplate Proposal Extend ServiceExt trait to add various methods mirroring the combinators from TryFutureExt and various services and layers to accommodate this Requirements Because combinators could be heavily chained together its probably wise to trim all the fat off here and if possible make it zerocost when compared to simply applying the combinators inside of the inner services call Result Having such methods should allow a more expressive algebra of tools to construct and combine services Current Implementation At the time of writing Ive introduced three combinators rust fn mapokF Responseself f F MapOkSelf F where Self Sized F FnOnceSelfResponse Response Clone MapOknewself f fn maperrF Errorself f F MapErrSelf F where Self Sized F FnOnceSelfError Error Clone MapErrnewself f fn withF NewRequestself f F WithSelf F where Self Sized F FnOnceNewRequest Request Clone Withnewself f and an associated Service and Layer for each TODO Which trait constraints are minimally required on the closures to ensure an ergonomic API without any excess overhead Documentation More combinators such as andthen Currently we have an alpha release of tower and its sub crates We never had a release So I woudl like to bring up we consider releasing it as a and move forward I think as long as we keep towerservice as it should be fine to release jonhoo and olix r Id like to know if you both have any reservations about going ahead and publishing those as a Currently in towertest the Mock services error type is fixed to Boxdyn Error Send Sync I guess its possible to work around it at the moment by creating a wrapper Service that does boxingdowncasting of errors but are you open to the idea of having the error type be configurable it could even be a type param that defaults to Boxdyn Error Send Sync if unspecified Currently we have a mix and match of crates that use From bounds over Into bounds This is causing issues when wanting to compose the services together I suggest we move them all to From since that is what Try is based on cc jonhoo seanmonstar carllerche hawkw Fixes These changes reconnect to return the make service failure in the future instead of in pollready This change allows us to reuse the reconnect service on failed reconnects This pushes the error down to the caller of call since technically the makeservice is ready This makes it so you can keep calling call until the service reconnects This service is a bit odd because it doesnt really fit in with the other types of services This is because its an adapter to go from MakeService to Service Thus the pollready contract here doesnt mean the same as a regular Service because it has to bundle connecting This question brings up a big issue with how buffer is implemented because if pollready returns the error then we must throw away the service and buffer will just keep returning the failed connection error even if we can successfully reestablish