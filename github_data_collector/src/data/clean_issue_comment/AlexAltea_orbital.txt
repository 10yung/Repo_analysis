Fixed issues with previous pull request adding the includes include glslangSPIRVSpvBuilderh include glslangSPIRVGLSLstd h instead of include SPIRVSpvBuilderh include SPIRVGLSLstd h seems to fix the issue This PR adds script to rearrange dump files to be stored in several levels of folders so that they are more manageable move into orbital directory after git clone and before git submodule update init The PS kernel creates multiple threads that might output debug information via UART Unfortunately theres no guest locks to prevent multiple threads from interleaving their output which causes unreadable output such as We could prevent that on the host side by obtaining the guest thread ID that is currently being executed by the CPU that made the UART write This can be done by traversing the FreeBSD structures as done in the ProcessThread List the code is already there Then storing the character being send to UART in perthread buffers Finally when a newline n is encountered flushing the thread buffer to the UI Contributors are welcome to solve this issue Difficulty Medium Code Tasks Coding I have Intel i K GB RAM DDR Geforce GTX Ti GB With TCG Accelerator i get to the part on where it shows the syscore crash logs so i know its working properly on that end With Haxm Accelerator i get nothing else besides VCPU shutdown request Im unsure if this is caused by the processor but from what ive googled it seems only th Gen processors cause this issue The haxm driver is installed properly by using the script and ive forked the correct branch orbital from Examples of incorrectly parsed functions Contributors are welcome to solve this issue Difficulty Easy Code Tasks Debugging imported some FreeBSD headers which redefine standard C types and defines The ones conflicting with MSYS were renamed or their declarationsdefinitions removed so that the whole thing would build just for Windows but the correct solution would be to rename them to something else to prevent clashes with the environment For instance they could all be prepended or suffixed with orbis for types and ORBIS for defines Many MMIO registers are just data registers ie whenever you read the register you obtain the last value written to the same register or a default value initialized by the device However theres some registers that trigger a more complex action whenever they are accessed The reason MMIO BARs in emulated devices are never backed by actual memory is to trigger GP faults ie VMexiting back to the hypervisoremulator and thus synchronously react to those action registers However we could take advantage of byte subpages for finegrained action vs data registers dispatching So basically the idea would be in every device we identify such action registers that require immediate attention and we remove RW permissions from the byte range they are in so we get react synchronously in Orbital For everything else we have regular RW permissions and have the underlying KB page mapped to some structure inside our emulator Basically instead of having like k k cycles wasted doing random hypervisor instruction emulation we do a regular memory accesses so around cycles and down to cycles if in L 