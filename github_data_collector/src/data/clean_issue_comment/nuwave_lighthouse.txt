model field is not generated in the definition causing the IDE to raise alerts x Added or updated tests x Added Docs for all relevant versions x Updated CHANGELOGmd Resolves non Changes Added model directive to definition area Breaking changes None What problem does this feature proposal attempt to solve The default naming convention that is used to automatically generate input objects by the orderBy directive and whereConditions directive often results in redundant names Heres a common way to define your schema graphql type Query users where whereConditionscolumns id name orderBy orderBycolumns id name User paginate This schema automatically generates a UsersOrderByOrderByClause input and a UsersWhereWhereConditions input Which possible solutions should be considered I could imagine two possible solutions Recommend a default naming convention for the query arguments eg orderBy and where and if the arguments match that naming convention remove the redundant suffix so that the input names result in UsersOrderByClause and UsersWhereConditions Add an optional argument to the directive which allows the user to specify a custom name for the input that will be generated Both solutions could also be combined Slack thread Describe the bug When using a nested mutation such as update youre required to pass in the related models PK even if the relationship is graphql mutation updateUserinput id username test profile update userid This is the undocumented bit and I wouldnt expect to be allowed to use the wrong PK here email testtestcom id username profile email This seems undocumented since no update example is shown in the docs for the relationship types This allows users to create malformed mutations that at best trigger laravel or db exceptions Not sure if its a valid vector for screwing up the db though Expected behaviorSolution It should at least be documented in the portion of the nested mutation docs that the related models PK is needed That the related model instance isnt using the models relationship method Itd seem natural that relationships shouldnt need to specify all PKs involved If a user model only has one profile relationship that shouldnt need to be manually specified by the client Id expect users of the API to not be allowed to supply malformed mutations that seem to break laravels normal relationship rules I dont have a proofofconcept that this could lead to operating on models that dont actually belong to the root model but I wouldnt be surprised if it did For instance what if a relationship has extra restrictions set in the models method that are ignored by supplying incorrect PKs which Lighthouse seems to be taking at face value If nothing else its a sidechannel attack that leaks which PKs exist in the related models table which could compromise slugbased or multitenant systems Steps to reproduce Create schema per Call a nested update with incorrect PKs graphql mutation updateUserinput id username test profile update userid This is the undocumented bit and I wouldnt expect to be allowed to use the wrong PK here email testtestcom id username profile email OutputLogs detailssummaryClick to expandsummary For PK clashes SQLSTATE Integrity constraint violation Duplicate entry for key PRIMARY SQL update profiles set userid email testtestcom where userid For PKs that dont exist No query results for model App Models Profile detailsbr Environment Lighthouse Version Laravel Version x Added or updated tests Added Docs for all relevant versions Updated CHANGELOGmd Resolves Changes Fetching model inside can directive was reworked so query builder gets extended if forceDelete or restore is used Breaking changes No old behavior still works using softDeletes with passing trashed argument from client The usage of softDeletes is even more granular and overrides these new implementation as query still gets enhanced Should we write something to changelog and docs Please keep in mind that Lighthouse is a community project and features take effort Are you willing to provide a PR for this issue or aid in developing it Is your feature proposal related to a problem Please describe A clear and concise description of what the problem is Ex Im always frustrated when I was trying out whereConditions also before release and it was actually pretty easy to extend Operator enum As I use PostgreSQL I need ILIKE operator for my conditions Currently to extend the list of allowed operators I had to create a class and modify generated enum I solved it like this php class PSQLOperator extends SQLOperator public function enumDefinition string originalDefinition parentenumDefinition additionOperators Simple pattern matching ILIKE ILIKE enumvalue ILIKE pos strrposoriginalDefinition return substrreplaceoriginalDefinition additionOperators pos And then I bound my implementation in a service provider that comes after WhereConditionsServiceProvider like this php thisappbindOperatorclass PSQLOperatorclass I am kinda new to Laravel and this was my first time I came to binding in laravel And as I didnt knew the concept it took me some time to achieve the expected result Possible solutions Id like A clear and concise description of what you want to happen Either let us improve the documentations customoperator section I could create a PR OR maybe lets implement the way where extending enum with new operator like in my case can be made easier Like use a string from config that will be injected into SQLOperatorenumDefinition OR maybe lets include ILIKE by default into enum definition Is your feature proposal related to a problem Please describe When writing root field resolvers i am bothered that the root argument is completely useless it only ever is passed null Describe the solution youd like Utilize root as a way to inject dependencies into a resolver eg php function resolveCache cache array args Context context ResolveInfo resolveInfo This would be a nonbreaking change Describe alternatives youve considered Just remove this argument completely and change the resolver function signature for root fields There is also a proposal for introducing other magic behaviour into the resolver functions We could make such changes in a nonbreaking way by adding some kind of marker to newstyle resolvers such as an interface or a directive Please keep in mind that Lighthouse is a community project and features take effort Are you willing to provide a PR for this issue or aid in developing it Is your feature proposal related to a problem Please describe Currently implementation of updateupsert dont use enchanceBuilder therefore it is not possible to update soft deleted model because without appending eg withTrashed model will not be fetched So it is not possible to do something like this graphql extend type Mutation updateAuthorinput AuthorInput spread Author update softDeletes Well you can use it but if model is soft deleted update is not able to find the entity as user reporter here A clear and concise description of what the problem is Ex Im always frustrated when Describe the solution youd like So here is my question Should we take care of soft deleted models in updateupsert In my application I currently disabled in UI the ability to edit entity if it is soft deleted it is actually in trash What do you think A clear and concise description of what you want to happen Added or updated tests Added Docs for all relevant versions Updated CHANGELOGmd Link to related issues this PR resolves eg Resolves Changes Detail the changes in behaviour this PR introduces Breaking changes If there are any breaking changes list them here Make sure to mention them in UPGRADEmd Is your feature proposal related to a problem Please describe Relates to The execution of certain field middleware directives should always happen in a certain order since some may depend upon others While in principle ordering the definitions in the schema can be used to define this correctly it is not always practical to do so When using directives on a type that are automatically placed on its fields the order cannot be controlled Also it can easily be done wrong by accident Describe the solution youd like Ensure a particular execution order for wellknown directives It would be nice to expose this configuration to the user This idea is inspired by how Laravel handles middleware execution order Describe alternatives youve considered Document the fact that directive order is significant This should be useful regardless Added or updated tests Added Docs for all relevant versions Updated CHANGELOGmd Link to related issues this PR resolves eg Resolves Changes Detail the changes in behaviour this PR introduces Suggests installing xkojimedialaravelaltairgraphql to get the Altair GraphQL Client 