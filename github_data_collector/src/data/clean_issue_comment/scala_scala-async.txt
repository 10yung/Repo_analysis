Just wondering if anybody had taken a look at howif scalaasync might work in Scala given that the Scala macro system as we know it will not survive Is it still too soon to say It would be good to get some vibes about how confident we can be that the library might survive in some form into Scala for deciding whether its worth adopting it in an application None None We tried to upgrade our project to but all compilation now fails with scalaScalaReflectionException object scalareflectinternalannotationsuncheckedBounds in compiler mirror not found at scalareflectinternalMirrorsRootsBasestaticClassMirrorsscala at scalareflectinternalMirrorsRootsBasestaticClassMirrorsscala at scalaasyncinternalTransformUtilsscalaasyncinternalTransformUtilsUncheckedBoundsClassTransformUtilsscala at scalaasyncinternalTransformUtilsscalaasyncinternalTransformUtilsUncheckedBoundsClassTransformUtilsscala at scalaasyncinternalAsyncMacroanon scalaasyncinternalTransformUtilsUncheckedBoundsClasslzycomputeAsyncMacroscala at scalaasyncinternalAsyncMacroanon scalaasyncinternalTransformUtilsUncheckedBoundsClassAsyncMacroscala at scalaasyncinternalTransformUtilsuncheckedBoundsTransformUtilsscala at scalaasyncinternalTransformUtilsuncheckedBoundsTransformUtilsscala at scalaasyncinternalAsyncMacroanon uncheckedBoundsAsyncMacroscala at scalaasyncinternalAsyncTransformasyncTransformAsyncTransformscala at scalaasyncinternalAsyncTransformasyncTransformAsyncTransformscala at scalaasyncinternalAsyncMacroanon asyncTransformAsyncMacroscala at scalaasyncinternalAsyncBaseasyncImplAsyncBasescala at scalaasyncinternalScalaConcurrentAsyncasyncImplScalaConcurrentAsyncscala Scala version is and sbt Suggested versioning scheme for Hi Rather than manually publishing to a maven repository theres an open issue asking for for a while now would it be possible to autopublish on every commit The version for automatically published artifacts could follow a different scheme like datecommit or git revlist HEAD count if you also want to continue having manual releases Similar to scalascalaasyncissues Heres the code snippet import scalaasyncAsync import scalaconcurrentFuture import scalaconcurrentExecutionContextImplicitsglobal def doStuffv Any Any v def main async val s if awaitFuturedoStufftrue awaitFuturedoStuff strue else sfalse printlns main Assigning the futures to a val will not throw the warning Before the master branch was cross built for Scala and which incurred a large number of deprecation warnings in the scalareflect Now that weve dropped support from that branch we can and should heed these warnings Could scalaasync handle some of use cases describe in I think it would be a relatively small modification to our macro to offer a failfast mode The user would need to opt in to this perhaps by importing a different async macro In this flavour of the async wed immediately register the state machine as an onFailure callback on each future that is started The first throwable received would be used to fail the result promise of the async block Some care would be needed to avoid races eg by making the existing and new code that fulfils that Promise obtain a lock when doing so 