 ERROR fixtureclusterakkaactordefaultdispatcher akkatcpcluster usermqconnectionqueueName close comrabbitmqclientAlreadyClosedException chan nel is already closed due to channel error protocol method methodchannelclosereplycode replytextNOTFOUND no queue queueName in vhost vhost classid methodid I have an interesting flow that I am trying to implement Our business requires using one connection per VM to connect to RabbitMQ What I have Implemented is the following flow Call our API GET queueLinkname have a single connection actor shared on the actorsystem spawn an actor in the cluster to handle the data events spawn a MQSubscriber for the data actor Connect the Subscriber which Heartbeats between Data event and Subscriber On connection failure suspend data events and wait for reconnect on reconnect obtain new queueLinkname and use the MQSubscriber to connect The issue I am having is the old channel actor is not dying when the connection drops and I cannot find a way to kill it I do not care about keeping it around since our queueNames are generated dynamically I need a way to kill the channel actor when the connection drops scala class MQSubscriberreceiver ActorRefimplicit val actorSystem ActorSystem extends Actor with ActorSystemLogging private val exchange amqfanout implicit val executionContext ExecutionContextExecutor contextdispatcher import contextbecome private def setupSubscriberchannel Channel self ActorRef queueName String channelqueueBindqueueName exchange def fromBytesx Array Byte new Stringx val consumer new DefaultConsumerchannel override def handleDeliveryconsumerTag String envelope Envelope properties BasicProperties body Array Byte receiver MQMessageenvelopegetDeliveryTagtoString fromBytesbody channelbasicAckenvelopegetDeliveryTag false superhandleDeliveryconsumerTag envelope properties body override def handleCancelconsumerTag String Unit receiver MQEventsUnexpectedDisconnect superhandleCancelconsumerTag override def handleShutdownSignalconsumerTag String sig ShutdownSignalException Unit receiver MQEventsUnexpectedDisconnect superhandleShutdownSignalconsumerTag sig channelbasicConsumequeueName false consumer receiver MQEventsConnected def checkHeartBeatconnection Option ActorRef heartbeatTime Intimplicit ex ExecutionContext Future MQResponse implicit val timeout Timeout Timeout milliseconds scheduleHeartBeatheartbeatTime connection match case None logerrorsNo Connection found yet FuturesuccessfulMQEventsNoConnection case Someconnection connection ConnectionActorGetState map case ConnectionActorDisconnected logerrorsConnection connection is Disconnected MQEventsDisconnected case ConnectionActorConnected MQEventsHeartBeat recover case AskTimeoutException ActorNotFound logerrorsConnection connectionpathname Actor Timeout or not found MQEventsLost def scheduleHeartBeatheartbeatTime Int Cancellable contextsystemschedulerscheduleOnceFiniteDurationheartbeatTime SECONDS self MQEventsCheckHeartBeat override def receive Receive processNone def processconnection Option ActorRef heartbeatTime Int queueName String Receive case MQSubscriberStartqueueName connection connection CreateChannelChannelActorpropschannel actor setupSubscriberchannel actor queueName SomequeueName becomeprocessOptionconnection queueName scheduleHeartBeatheartbeatTime case MQSubscriberStop self PoisonPill case MQEventsCheckHeartBeat checkHeartBeatconnection heartbeatTimemapreceiver case MQEventsStartCircuitBreaker becomeprocessconnection queueName case MQEventsCloseCircuitBreaker becomeprocessconnection queueName case object MQSubscriber case class StartqueueName String connection ActorRef case object Stop I have a problem with the logging implementation on the Connection and Channel Actors As they use the same logger as the ActorSystem I cannot change its level to be different from my ActorSystem Is there a way to set the level for the Actors by themselves Were currently having issues with some of our builds that still rely on fairly old versions of akkarabbitmq sbtResolveException unresolved dependency comthenewmotionakkaakkarabbitmq not found even though we have the resolver configured to use the newmotion Nexus in our buildsbts resolvers New Motion Repository at It looks like the jars are missing from the repository but the folder structure is still intact img width altScreenshot at AM src Hi I am trying to test the following example but it doesnt work object PublishSubscribe extends App implicit val system ActorSystem val factory new ConnectionFactory val connection systemactorOfConnectionActorpropsfactory akkarabbitmq val exchange amqfanout def setupPublisherchannel Channel self ActorRef val queue channelqueueDeclaregetQueue printlnchannel channelqueueBindqueue exchange connection CreateChannelChannelActorpropssetup Somepublisher def setupSubscriberchannel Channel self ActorRef val queue channelqueueDeclaregetQueue printlnchannel channelqueueBindqueue exchange val consumer new DefaultConsumerchannel override def handleDeliveryconsumerTag String envelope Envelope properties BasicProperties body Array Byte printlnreceived fromBytesbody channelbasicConsumequeue true consumer def setupchannel Channel self ActorRef Unit setupPublisherchannel self setupSubscriberchannel self connection CreateChannelChannelActorpropssetup Somesubscriber Future def loopn Long val publisher systemactorSelectionuserrabbitmqpublisher def publishchannel Channel printlnpublish channelbasicPublishexchange null toBytesn publisher ChannelMessagepublish dropIfNoChannel false Threadsleep loopn loop def fromBytesx Array Byte new Stringx UTF def toBytesx Long xtoStringgetBytesUTF The publish method is not called by publisher ChannelMessagepublish dropIfNoChannel false Hi When I send many ChannelMessage with a high rate to ChannelActor with dropIfNoChannel false if I stop rabbitmq and after a duration of time like minute start rabbitmq again the ChannelActor blocked for process many messages and cant process other message and throw heap space error I write this code import akkaactorActorRef ActorSystem import akkapattern import akkautilTimeout import comnewmotionakkarabbitmqChannelActor ChannelCreated ChannelMessage ConnectionActor ConnectionFactory CreateChannel import comrabbitmqclientMessageProperties import scalaannotationtailrec import scalacollectionmutable import scalaconcurrentExecutionContext import scalaconcurrentduration object Exam extends App val system ActorSystem implicit val timeout Timeout Timeout second implicit val executionContext ExecutionContext systemdispatcher val unconfirmed mutableSetempty Long val connFactory new ConnectionFactory connFactorysetHost connFactorysetPort connFactorysetUsernameamqp connFactorysetPasswordpass val pubConnActor systemactorOfConnectionActorpropsconnFactory Threadsleep tailrec def producechActor ActorRef Unit chActor ChannelMessage ch println chbasicPublishamqdirect metopic MessagePropertiesPERSISTENTBASIC messagegetBytesUTF dropIfNoChannel false producechActor pubConnActor CreateChannelChannelActorpropswithMailboxboundedmailboxmapTo ChannelCreated map case ChannelCreatedchActor producechActor When I run my code and after a duration of time stop rabbitmq and after a duration of time start again I get heap space error and stop my program I think this is for loop function in ChannelActor Please fix it and choose another way In cluster environment usually it is possible to specify nodes address in factorynewConnectionListAddress addrs method Is it possible to do the same in Newmotion Im trying to Create channel Bind things Publish a list of messages Close everything and wait for it to close Shut down system Here is my code scala import akkaactorActorRef ActorSystem import comnewmotionakkarabbitmq import scalaconcurrentduration import scalaconcurrentAwait ExecutionContext val queueName myqueue val exchange myqueue val cf ConnectionFactory new ConnectionFactory val sys ActorSystemqueuesystem implicit val ec ExecutionContext sysdispatcher val conn sysactorOfConnectionActorpropscf connection def setupProducerchannel Channel self ActorRef val queue channelqueueDeclarequeueName true false false javautilCollectionsemptyMap String AnyRef getQueue channelexchangeDeclareexchange direct true channelqueueBindqueue exchange val channel conncreateChannelChannelActorpropssetupProducer Somepublisher val events List eventsmapgetBytes map data channel ChannelMessagec Channel cbasicPublishqueueName null data sys stop channel sys stop conn Awaitresultfor c syswhenTerminated yield c seconds Im getting these errors INFO queuesystemakkaactordefaultdispatcher akkaqueuesystemuserconnectionpublisher Message comnewmotionakkarabbitmqChannelMessage from Actor akkaqueuesystemdeadLetters to Actor akkaqueuesystemuserconnectionpublisher was not delivered dead letters encountered This logging can be turned off or adjusted with configuration settings akkalogdeadletters and akkalogdeadlettersduringshutdown INFO queuesystemakkaactordefaultdispatcher akkaqueuesystemuserconnectionpublisher Message comnewmotionakkarabbitmqAmqpShutdownSignal from Actor akkaqueuesystemuserconnectionpublisher to Actor akkaqueuesystemuserconnectionpublisher was not delivered dead letters encountered This logging can be turned off or adjusted with configuration settings akkalogdeadletters and akkalogdeadlettersduringshutdown INFO queuesystemakkaactordefaultdispatcher akkaqueuesystemuserconnection closing connection to amqpuserlocalhost INFO queuesystemakkaactordefaultdispatcher akkaqueuesystemuserconnection Message comnewmotionakkarabbitmqAmqpShutdownSignal from Actor akkaqueuesystemuserconnection to Actor akkaqueuesystemuserconnection was not delivered dead letters encountered This logging can be turned off or adjusted with configuration settings akkalogdeadletters and akkalogdeadlettersduringshutdown What is the best way to accomplish this I guess when I want to shut down the connection hasnt event published the messages is there a way of waiting for it Thanks Hi Is it possible to pauseresume consuming According to documentation of rabbitmq it can be achieved with channelbasicCancel channelbasicConsume but I cant see it available in this lib Cheers See for more context and verification