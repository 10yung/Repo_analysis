If I set a SOCKS proxy with configs ProxyURL I consistently run in to this panic on torrent download With no proxy the download completes fine panic error writing chunk open filenametxt too many open files goroutine running githubcomanacrolixtorrentconnectionreceiveChunk xc c xc b x x Userstomgosrcgithubcomtab torrenttestvendorgithubcomanacrolixtorrentconnectiongo x a githubcomanacrolixtorrentconnectionmainReadLoop xc c x x Userstomgosrcgithubcomtab torrenttestvendorgithubcomanacrolixtorrentconnectiongo x c githubcomanacrolixtorrentClientrunHandshookConn xc xc c xc e Userstomgosrcgithubcomtab torrenttestvendorgithubcomanacrolixtorrentclientgo x githubcomanacrolixtorrentClientoutgoingConnection xc xc e xc b aec x x x f a x f ca x x Userstomgosrcgithubcomtab torrenttestvendorgithubcomanacrolixtorrentclientgo x created by githubcomanacrolixtorrentTorrentinitiateConn Userstomgosrcgithubcomtab torrenttestvendorgithubcomanacrolixtorrenttorrentgo x I also see tons of these errors in the logs clientgo error accepting connection tcp listener disabled due to proxy clientgo error accepting connection utp listener disabled due to proxy The torrent still seems to be downloading data but is interrupted by the panic before the download finishes Are there too many failed connections being opened due to the proxy that are exhausting my systems file descriptors The proxy works fine when directing HTTP browser traffic through it FWIW I see the error messages I am seeing were added here cc sickyoon I think I want to remove TorrentSpec Im not sure how that should look yet See for some background Per remove torrent creation methods from the client there are just want too many of them poorly documented and its unclear which one should be used and when func cl Client AddMagneturi string T Torrent err error func cl Client AddTorrentFromFilefilename string T Torrent err error func cl Client AddTorrentmi metainfoMetaInfo T Torrent err error func cl Client AddTorrentInfoHashinfoHash metainfoHash t Torrent new bool func cl Client AddTorrentInfoHashWithStorageinfoHash metainfoHash specStorage storageClientImpl t Torrent new bool func cl Client AddTorrentSpecspec TorrentSpec t Torrent new bool err error Im using torrentFileReader to read a torrents file as if it was a sequential byte stream Works great However while monitoring the network Ive noticed that Im downloading way more than the file mandates by itself for example an mkv video file with an average bitrate of MBs minutes GB file will consume about MBs from the torrent network while playing it back Is that normal I also tested this with torrentfs exact same behaviour Thanks Addresses During testing I found that passing in a unix domain socket doesnt work because there is an assumption that addresses have port numbers So if that was fixed one could use TmpDir for the test and of course pass in domain sockets in real client code My first approach was to try and make NewClient a wrapper around NewClientWithSockets but the listenAll dependency on clfirewallFunction meant that the client has to be instantiated before socket creation That is why I split it out into initClient and initSockets If in a future API Client was more like httpServer and separated construction from starting then the client would be ready to go before we make the sockets I have been testing this library using an inmemory lru cache with a small readahead time One of the issues I have observed is that when chunks get evicted from the cache and the piece completion state changes if I then seek back to try to redownload those chunks in a lot of cases the peers end up getting banned and the download seems to hang for a long time I see a bunch of messages like this in the logs clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip clientgo banning ip I mentioned this to you over email and your reply you said My theory is that chunks arriving after piece is marked for hashing are added to the dirty list after its already cleared in preparation to be hashed Later when the pieces are evicted from the cache a piece check fails and those peers that sent late overlapping chunks are being banned despite being innocent If your cache was small enough and chunks were redundant and hashes took a while this would occur quite a lot I think the solution is to disallow writing chunks while piece checks are pending or active To maximize download speed Is it possible for slow devices to limit the number of connections and drop lowspeed peers The RC cipher currently part of BitTorrent protocol encryption is considered insecure these days In search for replacement TLS appears the best candidate comprising a modern widely deployed suite of cryptographic protocols Although there is no active or draft BEP specification on TLS it would be a major step forward in the protocol development The proposal here is to develop a notyetstandard extension adding TLS support to BitTorrent protocol with a perspective to have it thoroughly documented and put up as a BEP Any constructive input is welcome Context in issue Work in progress sharing for visibility and early feedback Ive been testing the new functionality in an isolated Dockerbased environment with trackers and DHT functions disabled The swarm consisted ratelimited seeder and downloaders whose peer lists were bootstrapped with the seeders IPport Even with a simple exchange of connected peers following the handshake without the followup PEX updates the swarm has grown visibility of each other and got fairly well crossconnected with chunks download by one peer quickly propagating to the others The existing protocol isnt much affected other than sending an extra message with an ID negotiated according to BEP This may potentially result in interoperability issues with that said if encountered in field the clients can work around by setting DisablePEX configuration option 