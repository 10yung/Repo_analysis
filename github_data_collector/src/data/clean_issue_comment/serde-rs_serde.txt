Trying to compile on nightlies with defaultfeatures false in a nostd project results in error E cant find crate for std note the thumbv emnoneeabihf target may not be installed error aborting due to previous error For more information about this error try rustc explain E error could not compile serde Not sure how long back this is an issue This adds some support for untagged enums as mentioned in But it causes some problems w serdejson and Im not sure how to best handle this Any suggestions Especially for representing GeoJSON the current pretty formatter is not suited ideally In GeoJSON dimensional points are represented as arrays of length In the JS world GeoJSON is often formatted with libraries like jsonstringifyprettycompact which have a smart logic of keeping short arraysobjects in a single line This leads make the output nice and easy to work with details summaryCompact pretty formattersummary json type FeatureCollection features type Feature properties geometry type Polygon coordinates type Feature properties geometry type Polygon coordinates type Feature properties operation intersection geometry type MultiPolygon coordinates type Feature properties operation union geometry type MultiPolygon coordinates details The same GeoJSON formatted with a standard pretty formatter becomes very spacious due to the large number of length arrays details summaryStandard pretty formattersummary json features geometry coordinates type Polygon properties type Feature geometry coordinates type Polygon properties type Feature geometry coordinates type MultiPolygon properties operation intersection type Feature geometry coordinates type MultiPolygon properties operation union type Feature type FeatureCollection details This makes handling the files inconvenient and leads to times larger file sizes which becomes an issue especially when dealing with larger GeoJSON data The Content enum does not include i or u fields this makes it impossible to use those values in untagged enums Ive been unable to determine how to get derived deserialize to handle my use case and am hoping someone can point me in the right direction I have several nontrivial structs to deserialize with a predefined json file format I would like to make use of serdes attributes for fields at the top level of the struct however I am unable due to the file format containing a duplicate key Its used as a header footer at the begining and end of the file and should be validated to be consistent I have a minimized repo demonstrating the manual deseralize pattern Im trying mimic Ive found the following resources suggest writing a deserializer adapter and point to some examples serdeignored Leverages deserializeignoredany which doesnt allow preventing the duplicate key serdestacker Similarly doesnt modify map keys serdewith Modifies the map keys but deserializes into a map instead of a userdefined struct I believe the solution is to write a deserializer adapter wrapping the json deserializer but Ive not yet figured out howwhere in the layers of deseralizers MapAccess objects visitors seeds etc the right place is to catch the second instance of the key and prevent it from being processed Any help or suggestions would be greatly appreciated Thanks in advance I would like to use flatten to group a set of fields within a big bag of fields but when I serialize this back out into JSON I would like it to keep the nested structure Is flatten the correct way to do this Is there a way to limit flatten so that it does not affect serialization Example input JSON json foo bar subfoo subbar Serialization Struct rust deriveDebug Deserialize Serialize pub struct SubThing serderenamedeserialize subfoo foo u serderenamedeserialize subbar bar u deriveDebug Deserialize Serialize pub struct Thing foo u bar u sub SubThing Currently this will output the following JSON when serializing json foo bar foo bar This seems less than ideal Also how would one go about a similar situation where sub was another instance of Thing ie a recursive nesting I couldnt deserialize other variant if message contains content because serde try to match it into unit I suppose Deserialize returns error invalid type object content type here expected unit variant other name here Example rust use serdeDeserialize deriveDeserialize pub struct Foo static str deriveDeserialize pub struct BarFoo error E cannot infer an appropriate lifetime for lifetime parameter de due to conflicting requirements srclibrs pub struct BarFoo note first the lifetime cannot outlive the lifetime de as defined on the impl at srclibrs deriveDeserialize note so that the types are compatible expected IMPLDESERIALIZEFORFooserdeDeserializer found IMPLDESERIALIZEFORFooserdeDeserializerde note but the lifetime must be valid for the static lifetime note so that the types are compatible expected IMPLDESERIALIZEFORFooserdeDeserialize found IMPLDESERIALIZEFORFooserdeDeserializestatic error E cannot infer an appropriate lifetime for lifetime parameter de due to conflicting requirements srclibrs pub struct BarFoo note first the lifetime cannot outlive the lifetime de as defined on the impl at srclibrs deriveDeserialize note so that the types are compatible expected IMPLDESERIALIZEFORFooserdedeSeqAccess found IMPLDESERIALIZEFORFooserdedeSeqAccessde note but the lifetime must be valid for the static lifetime note so that the types are compatible expected IMPLDESERIALIZEFORFooserdeDeserialize found IMPLDESERIALIZEFORFooserdeDeserializestatic Notably serdeborrow as suggested by doesnt work rust use serdeDeserialize deriveDeserialize pub struct Foo static str deriveDeserialize pub struct Bar serdeborrow static Foo error field has no lifetimes to borrow srclibrs pub struct Bar serdeborrow static Foo Related but seemingly different My Tree struct is implemented using the arena technique rust pub struct Node pub children VecPathBuf pub properties HashMapString String pub struct Tree pub nodes HashMapPathBuf ArcMutexNode pub root WeakMutexNode To find the children of a node we need to query the Tree instance rust let node Node let tree Tree find the children for childpath in nodechildren let child treenodesgetchildpathunwrap the child I want to serialize my Tree object like json name myname property value property value children name child name To flatten the properties field I need to add serdeflatten above the properties I didnt find out a way to implement the flatten behavior during the customized serialization as follows rust pub struct Node pub children VecPathBuf serdeflatten pub properties HashMapString String To serialize the children field there is no way if I dont add a tree field to Node struct since the children nodes are achieved by querying Trees nodes map However if I add a tree field to Node struct which I really dont want to I must customize my serialization or add serdeserializewith path attribute rust the latter method pub struct Node serdeserializewith myserialize pub children VecPathBuf serdeflatten pub properties HashMapString String fn myserializeSchildren VecPathBuf serializer S ResultSOk SError where S Serializer For the latter the parameter is VecPathBuf and I still cant get the nodes map so I cant serialize its children Hence the only feasible solution is to customize my serialization But as I said above I didnt find out a way to implement the flatten behavior during the customized serialization Hello I want to deserialize some bytes to enum The first byte describe enum variant and other bytes contains a some structure Is it possible generate this case by serdederive and external tag feature For example enum Packet serdetag xAABBCCDD as u RequsetRequest serdetag xEEFFEEFF as u ResponseResponse struct Request struct Response 