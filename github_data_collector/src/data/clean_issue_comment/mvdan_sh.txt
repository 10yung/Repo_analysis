Copy makes a copy of the given Runner suitable for use in parallel to the original The copy will have the same parameters environment variables etc but they can all be modified without affecting the original Also fixes a tiny typo in a comment in the definition of Runner sub vs Sub type shows words as builtins and functions and so forth but doesnt work with aliases sh gosh type type type is a shell builtin function f date type f f is a function alias f date type f type f not found When invoked with flag su skip files which have not been detected as shell scripts instead of returning an error If scripts in a git repository dont have a sh extension and are spread across various directories its cumbersome to use shfmt in a precommit hook It would be useful if shfmt could skip nonshell files when invoked from a git hook with the list of files being changed as it is the case with precommit This is similar to but different because the desired behavior here would be that not explicit configuration is required Rather shfmt should magically skip nonshell files Even if we can change this with an option it would be great to know why you decide to remove any space between the redirect and the target like you did for caveats A short explanation andor a link on the input would be enough This might help people to decide what is the best for them Docker the org likes to have its containers be consistent and by adding a simple entrypoint script we become compliant This would in the future allow it to be possible to become an official container In any case it also makes the application behave as expected from a users point of view eg running the container only arguments invokes shfmt Adding shfmt as the first argument also still works as expected More importantly it allows for starting the container with a shell by using binsh as an argument The last point is important as it allows CIs such as gitlab to use the container as is and run shfmt inside of it Signedoffby Olliver Schinagl oliverschinaglnl We currently have the option to choose between indentation format tabs vs spaces However it is very common when using tabs to only use tabs for indentation but use spaces to align The most obvious spot is when aligning multiple if terms on multiple lines To give an example console imagesome long string spanning multiple lines if n image docker build hostname hostname rm interactive tty workdir workdir image pwd then fi note that github doesnt use a monospace font for rendered code but not when editingentering text sigh Here we have one indentation level the level of the if and alignment of the arguments The reason why we want to do this is that regardless of the tabstop setting things are always properly aligned Using spaces only fixes this of course but tab users dont want to I tried using kp but that only messes with the arguments hostname and workdir and aligns those When searching for it we get plenty of results I think vim calls it smarttabs Since you probably dont want a new option for this this would either be needed to be autodetected how to know when a space is for alignment vs just a stray whitespace following an indentation tab or i could be changed from uint to sint and would be tabs with alignment This would break if a user insist on having INTMAX UINTMAX number of spaces but since having anything more then spaces shouldnt even be considered I think were good Hi I have added two new printer options for a less compact style knl keyword new line will put keywords like then and do on a new line Example if foo then bar fi bnl brace new line will put braces on new lines Example foo bar It would be great if you would accept the patch Let me know if there is anything I need to change Regards Morgan For loops with a syntax like this are fully supported by bash but shfmt complains about missing dodone statements sh for FMT in jpg png jpeg gif downloadformat FMT SINDEX DOMAIN Could be intentional but looks like a bugmissing feature to me Mimicking ParserInteractive this method implements the basics of a full interactive shell Thats useful for many userfacing use cases and also as a debugging tool The function has zero options because the list of options it could take is neverending We could start with PS and PS but we could also add PS PS a contextContext Parser options et cetera Instead of tripling the amount of code and adding lots to the API suggest that advanced users simply copy the twenty lines to add their own options and logic