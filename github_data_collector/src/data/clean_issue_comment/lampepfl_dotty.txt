Not sure whats going on here but we definitely need to tune our heuristics scala val x scala E Type Mismatch Error tryresscala val x Found Int Required Int Int One of the following imports might make progress towards fixing the problem import Intint double import Intint float import Intint long import mathBigDecimalint bigDecimal import mathBigIntint bigInt import mathNumericIntIsIntegralmkNumericOps import mathNumericBigIntIsIntegralmkNumericOps import mathNumericIntIsIntegralmkOrderingOps import mathOrderingIntmkOrderingOps import Longlong double import Longlong float import mathBigDecimallong bigDecimal import mathBigIntlong bigInt import mathNumericLongIsIntegralmkNumericOps import mathNumericFloatIsFractionalmkNumericOps import mathOrderingLongmkOrderingOps import Floatfloat double import mathBigDecimaldouble bigDecimal import mathNumericDoubleIsFractionalmkNumericOps import mathNumericBigDecimalAsIfIntegralmkNumericOps import mathNumericBigDecimalIsFractionalmkNumericOps import mathNumericLongIsIntegralmkOrderingOps import mathNumericBigDecimalAsIfIntegralmkOrderingOps import mathNumericBigDecimalIsFractionalmkOrderingOps import mathNumericBigIntIsIntegralmkOrderingOps import mathNumericFloatIsFractionalmkOrderingOps import mathNumericDoubleIsFractionalmkOrderingOps import mathOrderingBigDecimalmkOrderingOps import mathOrderingBigIntmkOrderingOps import mathOrderingDeprecatedFloatOrderingmkOrderingOps import mathOrderingFloatIeeeOrderingmkOrderingOps import mathOrderingFloatTotalOrderingmkOrderingOps import mathOrderingDeprecatedDoubleOrderingmkOrderingOps import mathOrderingDoubleIeeeOrderingmkOrderingOps import mathOrderingDoubleTotalOrderingmkOrderingOps import collectionSearchingsearch import mathFractionalImplicitsinfixFractionalOps import mathIntegralImplicitsinfixIntegralOps import mathNumericImplicitsinfixNumericOps import mathOrderedorderingToOrdered import mathOrderingImplicitsinfixOrderingOps import reflectSelectablereflectiveSelectable import utilchainingscalaUtilChainingOps import implicitsNotamb import implicitsNotamb error found by the way the error message doesnt mention the concept of implicitgiven at all so it might be hard for a user to understand why adding an implicit would make a difference at all Following up on we resolved the assertion error but are still seeing some regressions in type inference versus Scala Relatively minimized example below minimized code Scala object Example extends App trait Has A trait ZIO R def provideLayer R R Has layer ZLayer R R implicit ev R R ZIO R trait ZLayer RIn ROut Has def RIn ROut ROut Has ROut Has that ZLayer RIn ROut ZLayer RIn with RIn ROut with ROut trait RandomService trait SizedService type Random Has RandomService type Sized Has SizedService def random ZLayer Random Random def sized ZLayer Any Sized lazy val zio ZIO Random with Sized Okay on Scala does not compile on Dotty lazy val eliminated ZIO Random zioprovideLayerrandom sized Compiles on Dotty with an explicit type annotation lazy val eliminated ZIO Random zioprovideLayer Random Random with Sized random sized printlnIt compiles details summaryCompilation outputsummary scala Cannot prove that ExampleHas ExampleRandomService ExampleSizedService ExampleRandomService ExampleSizedService ExampleRandom ExampleSized I found refl Nothing But method refl in object does not match type ExampleHas ExampleRandomService ExampleSizedService ExampleRandomService ExampleSizedService ExampleRandom ExampleSized details expectation I would have expected this to compile without an explicit type annotation as it does on Scala Copying jdegoes minimized code note that ready to run project is attached Also its situated in dottybreakwhile branch on github let we have next macro definitions Scala package c import scalaquoted import scalaquotedmatching trait CB T object CBF def pure T valueT CB T def map AB faCB A f ABCB B def flatMap AB faCB A f ACB B CB B case class CpsChunk T prev Seq Expr lastExpr CB T def toExprgiven QuoteContext Expr CB T if previsEmpty last else ExprblockprevtoListlast trait CpsChunkBuilder TType def isAsync Boolean def create CpsChunk T def append AType chunk CpsChunk A CpsChunk A protected def fromFExprf Expr CB T CpsChunk T CpsChunkSeqf def flatMap AType t Expr T CB A given QuoteContext CpsChunk A CpsChunk A Seq CBFflatMapcreatetoExprt def flatMapIgnore AType t Expr CB A given QuoteContext CpsChunk A CpsChunk A Seq CBFflatMapcreatetoExpr t def transformedgiven QuoteContext Expr CB T createtoExpr object CpsChunkBuilder def sync TType fExpr T given QuoteContextCpsChunkBuilder T new CpsChunkBuilder T override def isAsync false override def create fromFExpr CBFpuref override def append AType e CpsChunk A CpsChunkf eprev elast def async TType fExpr CB T given QuoteContextCpsChunkBuilder T new CpsChunkBuilder T override def isAsync true override def create fromFExprf override def append AType e CpsChunk A flatMapIgnoreetoExpr erased def await T f CB T T object Async inline def transform T expr T CB T AsynctransformImpl T expr def transformImpl TType f Expr T given qctx QuoteContext Expr CB T rootTransform T ftransformed def rootTransform TType f Expr T given qctx QuoteContext CpsChunkBuilder T import qctxtasty given import util f match case Constc CpsChunkBuildersyncf case rootcawait fType ft val awBuild CpsChunkBuilderasyncft awBuildasInstanceOf CpsChunkBuilder T case while cond repeat val cpsCond AsyncrootTransformcond val cpsRepeat AsyncrootTransformrepeat val isAsync cpsCondisAsync cpsRepeatisAsync CpsChunkBuilderasync def whilefun CB T cpsCondflatMap T c if c cpsRepeatflatMapIgnore whilefun toExpr else CBFpureasInstanceOf CB T toExpr whilefun case val fTree funsealunderlyingArgument fTree match case Applyfunargs CpsChunkBuildersyncf case Blockprevslast val rPrevs prevsmap case d Definition case t Term tseal match case ptp AsyncrootTransformp case other val rLast AsyncrootTransform T lastsealasInstanceOf Expr T val lastChunk rLastcreate val blockResult rPrevsfoldRightlastChunkes eappends val isAsync rLastisAsync rPrevsexistsisAsync CpsChunkBuilderasync T blockResulttoExpr case Identname CpsChunkBuildersyncf case printffTreefTree And try to eval macro in other compilation unit Scala package c import orgjunitTestIgnore import orgjunitAssert class TestBS While def cbBoolbBoolean CB Boolean Dotty crash TODO minimize and submit bug Test def tWhileC Unit val c Asynctransform Unit whileawaitcbBoolfalse awaitcbBoolfalse asserttrue details summaryStack tracesummary scala error Exception occurred while executing macro expansion error javalangAssertionError assertion failed error at dottyDottyPredefassertFailDottyPredefscala error at dottytoolsdotcasttpdApplytpdscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerunpickleTreeUnpicklerscala error at dottytoolsdotccoretastyDottyUnpicklercomputeRootTreesDottyUnpicklerscala error at dottytoolsdotcasttpdTreeProviderrootTreestpdscala error at dottytoolsdotccoretastyDottyUnpicklerrootTreesDottyUnpicklerscala error at dottytoolsdotcasttpdTreeProvidertreetpdscala error at dottytoolsdotccoretastyDottyUnpicklertreeDottyUnpicklerscala error at dottytoolsdotccorequotedPickledQuotesunpicklePickledQuotesscala error at dottytoolsdotccorequotedPickledQuotesunpickleExprPickledQuotesscala error at dottytoolsdotctastyreflectReflectionCompilerInterfaceunpickleExprReflectionCompilerInterfacescala error at scalaruntimequotedUnpicklerunpickleExprdirectUnpicklerscala error at cAsyncrootTransformanonfun anonfun anonfun anonfun Asyncscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadHoleTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadTermTreeUnpicklerscala error at dottytoolsdotccoretastyTreeUnpicklerTreeReaderreadLengthTerm TreeUnpicklerscala details When looking at problem I see that Apply assume RefTree or GenericApply but actual value is Inlined dottycpsminimizedbreakwhile targz Currently in order to unpickle the parents of a template in TASTy you must parse many arbitrary trees including selecting the correct overloaded constructor and performing unification of type variables on the return type of that constructor In Scala all that is required is the types of the parents it is inefficient to traverse expressions to calculate and propagate a type there should be a simple list of types enumerating the parents that can be referenced to from the actual trees that make up the extends clauses fixes a previous PR in this area was by Fnux but it languished because it combined the basic license change with adding copyright headers to all the source files this PR has just the license change the headers stuff could perhaps be revived separately I kept Fnux as author of the commit and bumped the copyright year to This PR adds a simple form of dependent typing by allowing match expressions to be typed as match types when their scrutinee type pattern types and body types align Concretely this means that we can define a value level counterpart to the LeafElem type from the match type documentation and type check that expression with the match type scala type LeafElem X X match case String Char case Array t LeafElem t case Iterable t LeafElem t case AnyVal X def leafElem X x X LeafElem X x match case x String xcharAt case x Array t leafElemx case x Iterable t leafElemxhead case AnyVal x This special mode of typing for match expressions is only used when the following conditions are met that logic is implemented by the isMatchTypeShaped function in Typerscala The match expression patterns do not have guards The match expression scrutinees type is a subtype of the match type scrutinees type The match expression and the match type have the same number of cases The match expression patterns are all Typed Patterns and these types are to their corresponding type patterns in the match type Follow up work could potentially relax some of these conditions for instance to support unapply patterns that are equivalent to typed patterns Currently the phase MoveStatic has two functionality Move static members from the companion object A to the class A Create static constructor for static fields of the class A In an earlier phase CheckStatic checks that static members only locate in the companion object A This restriction is just for semanticcorrectness of userwritten programs to avoid changing the typer For code that is synthesized from compiler phases this restriction is annoying We can make static a general mechanism in the compiler by splitting MoveStatic into two phases one phase that performs the moving can be merged with CheckStatic one phase StaticConstructors that synthesize the static constructor for static fields The phase CompleteJavaEnums will benefit from the refactoring Repeats the changes in for dottytastyconsumer Extract the staging out of the standard library and compiler Create dottytastyconsumer project that depends on dottycompiler Add missing test infrastructure dependencies on the dottytastyconsumer project or jar Move tastyfileConsumeTasty TastyConsumer TastyConsumerPhase andTastyFromClass to dottytastyconsumer Implement ConsumeTastyapply directly instead of as a java reflection call Now projects need to depend on chepfllamp dottytastyconsumer scalaVersionvalue Factored out dottytoolsdotcutilClasspathFromClassloader core logic for dottystaging and dottytastyconsumer Enabled tastdoc tests on CI mostly to check it compiles The idea is to have a library that users can depend on instead of the compiler itself It will be similar to the changes done in when we created the dottystaging library We should probably rename ConsumeTasty to something more meaningful at this point Please update syntax docs To reflect the changes 