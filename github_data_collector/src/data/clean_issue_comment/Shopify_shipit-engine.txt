 was merely a hotfix we need to properly support paginating the results of the commit status query This allows efficiently querying for stacks locked for this reason while retaining a userfriendly presentation This replaces and is a work in progress most of the business logic for this lives in our downstream application and is yet to be extracted Allow users to manage Repository objects Greetings At PowerHRG we desire to implement the ability to automatically deploy a branch as a new review instance of our application to our Kubernetes cluster when a Pull Request for that branch is opened and subsequently clean up the instance when the PR is closed or merged functionality similar to Herokus Review Apps However we maintain a number of projects and do NOT want to expose this functionality for every applicationrepositorypipeline As we understand it Shipit offers no mechanism at the repository level to control which repositories can dynamically provision stacks Wed like to add such a feature to Shipit and are seeking design guidance gauging appetite for possible upstream contribution It seems the Stack is the highest level concept which involves an applicationrepositorypipeline but this remains insufficient since the Stack also marries a particular branch and environment to the applicationrepositorypipeline concept What we think wed like is a higher level concept which represents the applicationrepositorypipeline to which stacks could belong This applicationrepositorypipeline could then contain its own configuration for the projectlevel features we desire As Ive stated earlier we seek guidance Are we alone in this problem What arent we considering How are others achieving this goal already given the existing tools Does this seem like a reasonable feature for Shipit Does the design direction make sense given the goals of Shipit Aside from the workflow guidelines listed in the README whats the least contentious path for upstream adoption of contributions Shipit creates a deployment as soon as the task starts but seems to only set the deployment status when the task is complete img width altScreenshot at src img width altScreenshot at src This means other apps cannot discover the log url of the in flight deploy Shipit should set an inprogress status after creating the deployment We recently updated our Shipit install from v to v and now were seeing new branches being pushed back to the GitHub repos were deploying Theyre named shipitdeployproduction and shipitdeploystaging which match the stack names we have This is unexpected and problematic as it triggers CI runs Weve configured around it for now but a fix or explanation if this is intentional would be appreciated My only idea so far is that it has to do with the branch name config that was changed in A bit of preliminary plumbing to set deploy state refs I subclassed the lastdeployedref job as it was quicker but ideally all three would inherit from a common base or it would be one customizablecomposed job class Currently only doing the additional updating on stacktriggerdeploy and after a status change to success for a deploy The refs would then be utilized by mergequeue shipitnext Still very much WIP Normally it shouldnt be an issue but I think its worth mentioning in case a user doesnt see their tasks This also will help them lean towards thinking something is wrong if they refresh and still dont see their new tasks This line Fails deploys of polarisicons for packages not in packages In this deployment The version in packagesrubypolarisiconspackagejson isnt being detected correctly assertlernaindependentversiontags pid modulejs throw err Error Cannot find module packagespolarisiconspackagejson at FunctionModuleresolveFilename modulejs at FunctionModuleload modulejs at Modulerequire modulejs at require internalmodulejs at eval at ContextifyScriptScriptrunInThisContext vmjs at ObjectrunInThisContext vmjs at Objectanonymous eval wrapper at Modulecompile modulejs at evalScript bootstrapnodejs polarisicons is tagged as but its packagejson version is 