It wasnt clear I needed to use this env var within the view configuration It seems that the documentation for usage with Laravel framework doesnt cover the current Laravel Framwork They are some bootstraping differences and when calling mkdirconfigviewcompiled true in AppServiceProviderphp throws and exception mkdir Invalid path PHP will be released the rd of Januari It contains some bugfixes that allow us to use preloading on an actual project I am super excited to try it out Ive actually already started writing a blog post about it Could we please merge this PR after PHP is released so I can finish my blog post and brag about performance on Lambda It took me a while to understand what was happening so I decided to share here To deploy with bitbucket pipeline it is necessary to split the deploy into steps download composer dependencies run serverless deploy Because the steps are performed separately you must share the vendor and bootstrapcache artifacts So the bitbucketpipelinesyml file looks like this pipelines branches master step name Composer install image php caches composer script aptget update aptget install y unzip curl sS php installdirusrlocalbin filenamecomposer composer install preferdist optimizeautoloader nodev artifacts vendor bootstrapcachephp step name Deploy Lambda deployment production image node alpine trigger manual caches node script apk add python npm install g serverless serverless config credentials stage prod provider aws key AWSDEVLAMBDAKEY secret AWSDEVLAMBDASECRET serverless deploy stage prod I always deploy bitbucket but its the first time with serverless The difference is that on a normal server write permission if not send the bootstrapcache files laravel generates in the first run as in lambda does not have permission in this folder happens the following error productionERROR The vartaskbootstrapcache directory must be present and writable exception object Exceptioncode The vartaskbootstrapcache directory must be present and writable at vartaskvendorlaravelframeworksrcIlluminateFoundationPackageManifestphp I hope this helps others with the same problem save time Thanks FYI mnapoli This PR is a massive one sorry for the diff but everything is finally coming together Typed events and event handlers This concerns the PHP function runtime not the PHPFPM runtime Currently it is possible to define PHP lambda functions via an untyped callable taking an untyped event php lambdafunction event return Hello event name This is in line with JavaScript support in Lambda The goal with Bref is to be like if AWS implemented PHP support natively so I stayed with that approach to mimic JS I recently discovered that in more typed languages Lambda handlers are classes that take typed events Java example C example Since PHP allows both dynamic typing and strict typing I think this makes sense to support both options in Bref To sum up we keep anonymous function handlers we keep untyped events ie arrays we offer the possibility to write typed handlers taking typed events via PHP interfaces Bref will detect what you use and call it accordingly I have currently implemented SqsHandler Psr Handler more details in the next sections The system is in place more events can be supported along the way thanks to contributions Here is an example php class MyHandler implements SqsHandler public function handleSqsSqsEvent event Context context void do something Notice event is typed we can call methods on it eventgetRecords getMessageId if AWS adds a new field to SQS events users can still access the raw event data via array eventtoArray Now we declare that our handler is an instance of our class lambdanew MyHandler As you can see the event parameter is typed as SqsEvent That allows you to skip any kind of validation you are sure that you get the event you expect If not Bref will throw a clear error As a side benefit those handler classes will be easier to test than anonymous functions The removal of the lambda function Still in the spirit of implementing a runtime that would look like an official AWS runtime I think we need to get rid of the lambda function For the moment BC is kept and it will still work Before php lambdafunction event return Hello event name or lambdanew MyHandler After php return function event return Hello event name or return new MyHandler Much simpler and less opinionated Native HTTP functions with PSR and PSR Creating HTTP applications with Bref is easy thanks to the PHPFPM layer It runs your application in the same environment as any server and that lets you run Laravel Symfony or any framework without much changes However sometimes we want to create a small HTTP lambda Using a framework is sometimes overkill especially since we have the PSR standard for HTTP requests and responses now Using the typed handlers introduced above reviving old Bref code building upon the efforts of Nyholm in and marcusirgens in this PR introduces native support for PSR and PSR RequestHandlerInterface php use Psr Http Message ResponseInterface use Psr Http Message ServerRequestInterface use Psr Http Server RequestHandlerInterface use GuzzleHttp Psr Response class MyHandler implements RequestHandlerInterface public function handleServerRequestInterface request ResponseInterface return new Response Hello world return new MyHandler That means you can now write controllers using PSR and skip using a framework Bref will convert HTTP event data API Gateway or ALB into PSR requests and handle the responses as well And yes there is support for form data POST cookies multivalue headers multipart form post file uploads Side note what about supporting Symfony requests I think it would be worth supporting but maybe via a rd party package WDYT But that doesnt stop here since we support PSR handlers we support PSR compliant frameworks natively For example Slim I havent tested yet but we should be able to run Slim like this without needing the FPM layer php php use Psr Http Message ResponseInterface as Response use Psr Http Message ServerRequestInterface as Request use Slim Factory AppFactory require DIR vendorautoloadphp app AppFactorycreate appgethelloname function Request request Response response array args name args name responsegetBodywriteHello name return response Instead of running apprun we return it app is the HTTP handler return app Performances Lets be straight running HTTP applications with the Function runtime as shown above is slower than using the PHPFPM layer The reason for that is that PHPFPM reuses processes in memory as PHP as always done On the other hand the function layer creates a brand new PHP process for every invocationrequest This is slower but this is in line with how PHP has always run and what users will expect a blank slate every time For cases where performances do not matter eg a very small endpoint like a webhook that is fine The benefit we dont need a framework yet we get HTTP requestresponse objects instead of GET and POST But there is one last thing Keepalive layers There is one way we can accelerate PHP and make it faster than the PHP function runtime and even the FPM runtime That involves keeping the PHP process alive between requests just like ReactPHP PHPPM etc We have been playing with this idea since Bref and Nyholm raised that topic again in Thanks to the typed events the PSR handlers the removal of the lambda function we can now implement keepalive layers without introducing separate layers without breaking the default behavior of PHP which is to restart the process by default and apply it to HTTP as well as any other kind of Lambda event How it works The Function runtime is now keeping the PHP process alive between events However by default it will handle only event and then terminate to be started again in the next event That default behavior reproduces Brefs current behavior by default Bref creates a new process for every event But by simply setting the BREFLOOPMAX environment variable to a different value than eg the same layer will now act as a keepalive layer The same process will handle events before terminating That can accelerate performances by a lot in some cases Be careful though just like ReactPHP you need to be careful not keeping state across requests This is an execution mode that I would only recommend for advanced use cases Side note should we allow a value of to allow handling events in a loop without ever restarting TODO x add a truckload of new tests tada x rename SqsHandlerhandleSqs to handle x reorganize the namespaces mark the lambda function as deprecated update the documentation go over and again to make sure we havent forgotten anything x build beta layers tests test performances If you want to help I would really appreciate if you could test the layers as well as test performances and see if its interesting marcusirgens Nyholm I have tried as much as I could to start from your PRs or at least try to include your commits in this branch But I havent managed to do that Im really sorry Since I wanted to build the PSR and keepalive features on top of the typed events I had to change core pieces of Bref first and that made reusing your code impossible I ended up doing a bit of new code code from Bref your code Please explain the motivation behind the changes In other words explain WHY instead of WHAT A lot of modern frameworks communicate using PSR objects instead of dumping data out PSR objects can easily be converted to API Gateway data objects This should make stuff faster as we wont need to initialize the CGI runtime The values of the event and context are passed to the ServerRequestInterface so they can be accessed wherever the request is used Thank you for your great work with this tool bringing the Serverless universe to the PHP community I have added a new documentation page to configure an Antidot Framework application using Bref with the intention of opening more options to the users of this new framework