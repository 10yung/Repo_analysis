stubbee stubbaobject mockowner stubbee stubbee is the thing thats stubbed more specifically the object on which stubs or mocks is called Therefore its also the object that holds a reference to mocha Thats why it was called mockowner earlier stubbaobject is the object through which we get hold of the stubbaclass on which stubbed methods reside In case of AnyInstance that class is the stubbaobject itself while in case of Instance its the singleton class of the stubbaobject This is consistent with the meaning and usage of stubbaobject and stubbaclass methods in ObjectMethods and AnyInstance This is my attempt to fix Although mocha does not claim to be threadsafe this change slowly makes it more resilient to race conditions through use of mocha A method on an objectclass may be stubbed invoked prior to the expectation being added to the list In such a scenario the methodmissing in mockrb would raise an exception for unknown invocation Smply add a ifguard that checks that the expectation list is not empty fixes A common example of using mocha is to stub Time to return a fixed time For instance ruby now Timenow Timestubsnowreturnsnow However if there is a separate thread running which tries to invoke the stubbed method specifically on nonGIL interpreters like JRuby weve encountered a race condition in that the mocha will raise an exception that the expectations have not been met here is a simple example ruby def testmochathreadsafety Threadnew do times do just loop and call Timenow a bunch while the thread above keeps stubbing Timenow end end now Timenow times do the two mechanisms involve different stubbing code wso lets test both Timestubsnowreturnsnow end end Looking through the code the result seems to be due to the mockrb not being protected with a critical section ruby def stubsmethodnameorhash backtrace nil iterator ArgumentIteratornewmethodnameorhash iteratoreach do args methodname argsshift ensuremethodnotalreadydefinedmethodname expectation Expectationnewself methodname backtrace expectationatleast expectationreturnsargsshift unless argsempty expectationsaddexpectation end end Specifically if expectationsaddexpectation is not executed but the method has been stubbed then the methodmissing in mock will raise an exception since there is no expectation to match against stubs methodmissing need to share the same mutex and become a critical section or methodmissing should not raise if expectations is empty Very similar to In fact theres overlap between the two that can be cleaned up onceif we merge both of them The idea behind both of these PRs is to reveal the underlying themes and similaritiesvariations on a number of axes method owner class superclass module etc stubbeestubowner class instance anyinstance and visibility public protected private and configurationtreatment allow warn prevent of various stubbing actions nonexistent method nonpublic method method on nil etc that the purpose of the whole bunch of tests if to really check a small number of things for a larger number of scenarios combining elements of the axes mentioned above Also the two PRs together get rid of all the rubocop LintDuplicateMethod disables Extract StubMethodSharedTests module to check stubbing of public protected and private methods on Module Class Instance and AnyInstance under various conditions The only difference in each case is the methodowner and the callee and sometimes the stubbee or aliasmethod The shared module allows us specify just the varying parts of the fixture and makes the commonality of the checks more apparent and easier to understand and to reason about scenarios across all types of stubbees more easily Rubocop approves too since we could get rid of most of LintDuplicateMethod disables Note that the last two files contain the active record association proxy checks which is inconsistent structurally with the first two Im not sure that these tests are checking anything useful anymore They rely on overridden definitions of publicprotectedprivatemethods but code relying directly on those methods was removed here Not sure if the overrides still indirectly affect the SUT in a meaningful way which is possible if publicprotectedprivatemethoddefined internally rely on them which I doubt and nowhere to catch it Display deprecation warning when adding an expectation if the expectation list already contains any expectations The intent is to change method dispatch behavior to that of jMock v as suggested in in a major version release