nopCommerce version i used this code to retrieve number of products for each category in homepage but always categoryNumberOfProducts return null model TopMenuModel var rootCategories ModelCategoriesWherex xIncludeInTopMenuToList foreach var category in rootCategories var categoryLineModel new TopMenuModelCategoryLineModel Category category var temp categoryNumberOfProducts i checked assigning some products to category why categoryNumberOfProducts return null Theres no need to display this label in most cases when we have only one store Lets hide it in this case Updated to dotnet core Fixes Found the root cause for IQueryables referencing a DBContext were put in the cache and on a next request reused from a different thread This triggers a double dispose free Will create a repro for this for the net core team For now I check in the memory cache whether the type that is going to be cached is the return value of a linq operator Rebased onto upstream develop for an easy merge So the inevitable has happened and there are now remote code execution vulnerabilities that target aspnet core is not fixed as it is not a LTS release We now have NO other choice but to take our nopcommerce site that was in preview down and look for another platform Please not that we have TRIED to upgrade to dotnet core but this was impossible See comment Please AndreiMaz RomanovM You are now exposing your users to remote code execution exploits While testing a payment provider which sends the order to an external administration I came across the following situation This occurs when there is a discount applied to a assigned product which is limited with a maximum discounted quantity nopCommerce version Steps to reproduce the problem Add a new discount Discount type Assigned to products Discount amount Maximum discounted quantity Assign to product Add assigned product to cart with an amount above For example Place order Open PDF invoice of product The unit price is displayed like this When calculating the price manually While the displayed price of is in fact correct the unit price is different for the first and the other items and is not displayed within the order The orderorder item entity should contain the unit price for each item based on the different discounts For example you would be able to add another discount for the first items Maybe these should be extracted to different order lines So you would get x x x Places where this is happening PDF invoice Order history details Admin orders Payment providers Maybe more nopCommerce version all Steps to reproduce the problem when we importexport product with attributes and conditions conditions not support importexport As the Redis cache implementation suffers from major network latency problems due to the single item fetches over the network and the implementation of RemoveWithPrefix as individual item synchronizations see Ive implemented a new Distributed Inmemory Caching service that tackles these problems Note that it does not require Redis or any backend cache server anymore as it simply synchronizes all memory caches It works by queuing all changes to the in memory cache array during a page request for distribution later The queue is emptied at the end of the request to multiple clients that will distribute the changes to the other webservers on a configurable flush interval default seconds This results in two netwerk calls per server pair per seconds IF there is any cache information to sync The network calls are a few kilobytes to ths of kilobytes and contain between and some s of cache messages and take only a few miliseconds to process The sync mechanism uses DotNetty to setup an async gzipped message pipeline over TCP that is fast and low latency It completely bypasses the Http Pipeline The cache is smart enough to code Clear and RemoveWithPrefix into single messages and replay them on the other server The cache also compares the entries on the target server based on a time stamp so it is important that all web servers are synchronized using NTP I dont think it is wise to scale this beyond maybe web frontends as its push based so youll end up with a lot of cache traffic when scaling to dozens of servers I have not tested it with more than nodes so YMMV Performance is roughly identical to the in memory cache Remember that it can take up to seconds the sync interval for changes in the cache to propagate to another server This is not a problem in practice The scheduled tasks need some sort of locking mechanism to prevent multiple web frontends running the same task The distributed cache cannot be used to synchronize the locks as its only synchronized at fixed intervals That is why this change includes a simple ILocker implementation using SQL Server Configuration is done in appSettingsjson The following settings are defined json Enable the distributed Memory Cache DistributedCacheEnabled true Peers to communicate with May include your own IP DistributedCachePeers Port to listen on for cache requests DistributedCachePort second cache sync interval DistributedCacheSyncInterval second cache expiration cleanup interval DistributedExpirationScanInterval Enable the Sql server locker SqlLockerEnabled true Configuration should be the same on all peers Id like some feedback from people running nopcommerce clusters whether this makes a difference and is a good addition to NopCommerce Need improvement As per existing code for all plugin DbContext few methods are the same for all plugins and some of them implementation is not required at all throw NotImplementedException This code id repetitive It is against the DRY principle Possible Solution Create new abstract base class eg BaseDbContext DbContext IDbContext All new PLUGINNAMEObjectContext and NopObjectContext will use BaseDbContext as a base class nopCommerce Version Steps to reproduce the problem Setup a multistore Go to Admin Configuration Setting Catalog setting on the Search section Search page Page size options value is not saved in another store I have checked there is a very small change in the view page nopCommerce version Steps to reproduce the problem Wrong reservation in ProductService in method ReserveInventory when ReservedQuantity bigger than StockQuantity and set postive reservation and set value wrong csharp Action pass foreach var item in productInventory var selectQty MathMinitemStockQuantity itemReservedQuantity qty itemReservedQuantity selectQty qty selectQty if qty break st pass Applying reserved pass if qty rd pass Booking negative stock var pwi productInventory pwiReservedQuantity qty its must change to csharp Action pass foreach var item in productInventory var selectQty MathMinMathMax itemStockQuantity itemReservedQuantity qty itemReservedQuantity selectQty qty selectQty if qty break st pass Applying reserved pass if qty rd pass Booking negative stock var pwi productInventory pwiReservedQuantity qty 