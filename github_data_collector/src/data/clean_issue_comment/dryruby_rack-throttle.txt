Bumps rack from to details summaryChangelogsummary Sourced from racks changelog Changelog All notable changes to this project will be documented in this file For info on how to format all future additions to this file please reference Keep A Changelog Unreleased Note There are many unreleased changes in Rack master is around commits ahead of stable and below is not an exhaustive list If you would like to help out and document some of the unreleased changes PRs are welcome Added Changed Use Timehttpdate format for Expires as proposed by RFC nanaya Make Utilsstatuscode raise an error when the status symbol is invalid instead of Rename RequestSCHEMEWHITELIST to RequestALLOWEDSCHEMES Make MultipartParsergetfilename accept files with in their name Add Falcon to the default handler fallbacks ioquatix Update codebase to avoid string mutations in preparation for frozenstringliterals pat Change MockRequestenvfor to rely on the input optionally responding to size instead of length janko Rename RackFile RackFiles and add deprecation notice postmodern Removed Documentation Update broken example in SessionAbstractID documentation tonytonyjan Add Padrino to the list of frameworks implmenting Rack wikimatze Remove Mongrel from the suggested server options in the help output tricknotes Replace HISTORYmd and NEWSmd with CHANGELOGmd twitnithegirl Backfill CHANGELOGmd from to releases drenmi details details summaryCommitssummary e ee Bumping version f a b Introduce a new base class to avoid breaking when upgrading b cab Add a version prefix to the private id to make easier to migrate old values e e f Fallback to the public id when reading the session in the pool adapter ba d Also drop the session with the public id when destroying sessions a bbf Fallback to the legacy id when the new id is not found dc a Add the private id a f revert conditionals to master e remove NullSession c e b remove raise and get closer to master Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details This is a really large conceptual PR so Im going to let this sit for a while to gather feedback RackAttack has much more active maintenance is more mature I believe we should nudge those looking to do rate limiting in rack apps that way to be the most helpful we can be Hello All I wanted to open discussion to see if RackAttack could serve the wonderful people using this lovely gem a bit better It seems to hame more featuresfunctionalitycommunity than here at rackthrottle Im thinking we may want to give up the throne to help peoples looking for this functionality have come here bendiken brandonhilkert any others thoughts gem rackthrottle when i run i am getting this error can you please provide solution for this dataprojectvendorbundleruby gemsrackthrottle librackthrottletimewindowrb in moduleThrottle uninitialized constant RackThrottleLimiter NameError from dataprojectvendorbundleruby gemsrackthrottle librackthrottletimewindowrb in moduleRack from dataprojectvendorbundleruby gemsrackthrottle librackthrottletimewindowrb in top required from dataprojectvendorbundleruby gemsbackports libbackportsstdlibrb in require from dataprojectvendorbundleruby gemsbackports libbackportsstdlibrb in requirewithbackports from dataprojectlibappratelimiterrequestthrottlerb in top required from dataprojectvendorbundleruby gemsbackports libbackportsstdlibrb in require from dataprojectvendorbundleruby gemsbackports libbackportsstdlibrb in requirewithbackports from configru in block in main from dataprojectvendorbundleruby gemsrack librackbuilderrb in instanceeval from dataprojectvendorbundleruby gemsrack librackbuilderrb in initialize from configru in new from configru in main from dataprojectvendorbundleruby gemsunicorn libunicornrb in eval from dataprojectvendorbundleruby gemsunicorn libunicornrb in block in builder from dataprojectvendorbundleruby gemsunicorn libunicornhttpserverrb in call from dataprojectvendorbundleruby gemsunicorn libunicornhttpserverrb in buildapp from dataprojectvendorbundleruby gemsunicorn libunicornhttpserverrb in start from dataprojectvendorbundleruby gemsunicorn binunicorn in top required from dataprojectvendorbundleruby binunicorn in load from dataprojectvendorbundleruby binunicorn in main It seems like the persecond perminute etc keys that rackthrottle creates in Redis are permanent We run a high traffic site which means that were going to end up with a lot of pollution and wasted space in Redis Ideally there should be some way for these keys to expire When throttling it might be more accurate to return the following status code Too Many Requests The user has sent too many requests in a given amount of time This is apparently intended for use with rate limiting schemes I realise that defaulting to this error code would be a backwards incompatible but I think this should be documented I can provide a PR updating the README Related which changed the default status code rather than simply documenting it Is it possible to change the response to be totally custom JSON for example like it is in redisthrottle Im seeing what looks like a concurrency issue in a custom Limiter based on rackthrottle But Im not sure so thought Id ask issue here Specifically the retrieval and storage of count values in timewindow for example is not atomic so it is possible for two simultaneous increments to occur but one of the increments will not be recorded This is what Im seeing in my logs I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed true I T INFO Rate limiting dcae b d bd f fdcd de db ced b c d f T count allowed false The cache is a remote redis being accessed via Ohm Less than optimal but Im picking up someone elses code Also this is running in JRuby and there are both hourly and daily limits in play The ruby threading model is not my forte so I might be missing something obvious I may be missing something but it seems strange that def allowedrequest t requeststarttimerequest t cachegetkey cachekeyrequest rescue nil allowed t dt t t tof minimuminterval begin cachesetkey t allowed rescue e If an error occurred while trying to update the timestamp stored in the cache we will fall back to allowing the request through This prevents the Rack application blowing up merely due to a backend cache server Memcached Redis etc being offline allowed true end end in intervalrb doesnt call the super implementation in limiterrb def allowedrequest case when whitelistedrequest then true when blacklistedrequest then false else true override in subclasses end end 