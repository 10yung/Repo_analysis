I want to detect file integrity changes from alerts When one some changes detected by ossec it retrieve alerts frequently How can I stop this alarm which was alerted before Capture Hi folks I spent some free time recently auditing OSSEC I was primarily focused on a threat model where an OSSEC agent is compromised eg the agent key and assoc counters are known and used to attack the OSSEC server primarily ossecremoted and ossecanalysisd Given the problem domain of OSSEC and HIDS generally I think this is fair game Since these are postauth bugs and there isnt guidance on vulnerability disclosure in the README I thought it was acceptable to post information fulldisclosure to the repo I found a handful of bugs and have done my best to address the root cause the affected versions the impact and potential fixes in the issues Ive filed I will request CVEs for the security relevant bugs later on In terms of rough risk levels Id categorize the findings as follows Informational osregexemptypcre offbyone rootcheckcheckrcifshellinjectionrisk Low analysisdsyscheckdecodermsglocationpathinjection analysisdOSCleanMSGallowscontrolcharsinmsg analysisdOSCleanMSGbadlocationsegfault analysisdsyscheckdecoderoffbyoneread Edit I made a mistake in my analysis here its not a bug Med analysisdOSCleanMSGoffbyonesyslog analysisdOSReadMSGuseafterfreeossecalert analysisdOSReadMSGuseafterfreesyscheck High analysisdrootcheckdecoderheapoverflow Some caveatscontext to add Im not a professional C coder wrt suggested fixes YMMV I dont write exploits for a living My assessments of exploitabilityrisk should be considered lower bounds This wasnt an extensive audit I followed my nose and used some fuzzing OSSEC seems to be the earliest tag in the Github repo I didnt dig deeper into history to see if any of these bugs affect older releases some likely do If you would be interested in trying to adopt fuzzing as part of your CI or as an integration with ossfuzz etc Id be happy to try and provide some notes but likely dont have the resources to implement it myself to a mergeable standard of work Thanks You can close this toplevel issue as you see appropriate The ossecanalysisds OSReadMSG function calls OSCleanMSG at the start of processing a message read from the ossec queue UNIX domain socket In srcanalysisdcleaneventc the OSCleanMSG function populates the lf struct setting fields like log hostname and programname to substrings of the lffulllog buffer After cleaning any syscheck messages are given to the syscheck decoder for further processing After processing a syscheck msg from a client the syscheck decoder will free the lffulllog pointer in two places One place is if the message indicated a change in an existing tracked file Another place is if the message indicated a new file to track In both cases the syscheck decoder replaces the existing lflog and lffulllog pointers with pointers to new messages after first freeing the old lffulllog Afterwards the DBSearch and DecodeSyscheck functions return to OSReadMSG Since the decoder returned the OSReadMSG function will continue processing the event it will not jump to CLMEM If any subsequent processing rules access the lfhostname or lfprogramname fields set by OSCleanMSG they will be accessing memory of a freed heap chunk previously containing lffulllog I believe the bug was introduced in fa d acd c e bfa e cfd on Nov and affects OSSEC v This code path is triggerable via an authenticated client through the ossecremoted The client needs only write a valid syscheck message that will have the programname or hostname set during OSCleanMSG I dont have a strong sense for the possibility of exploitation I suspect this may be turned into an out of bounds read of heap memory accessing programname or hostname during rule processing if the area pointed to after the syscheck decoder free isnt null terminated One possible fix would be for the syscheck decoder to osstrdup the lfhostname and lfprogramname before freeing fulllog The ossecanalysisds OSReadMSG function calls OSCleanMSG at the start of processing a received message from the ossec queue UNIX domain socket In srcanalysisdcleaneventc the OSCleanMSG function populates the lf struct setting fields like log hostname and programname to substrings of the lffulllog buffer After cleaning any messages that meet the ossecalert decoders criteria are given to that decoder for further processing After processing an ossec alert msg from a client the ossec alert decoder will free the lffulllog pointer at the end of its processing replacing it with a new pointer and populating lfgeneratedrule Though the OSSECAlertDecoderExec function returns NULL and not further rule processing of the lf struct occurs during OSReadMSG because of the lfgeneratedrule set by the decoder before freeing lffulllog If any subsequent processing associated with the generated rule accesses the lfhostname or lfprogramname fields set by OSCleanMSG they will be accessing memory of a freed heap chunk previously containing the lffulllog I believe the bug was introduced in fcca d fa b f cda c d on July and affects OSSEC v This is triggerable via an authenticated client through the ossecremoted The client needs only write a ossecalert message that will have the programname or hostname set during OSCleanMSG I dont have a strong sense for the possibility of exploitation I suspect this may be turned into an out of bounds read of heap memory accessing programname or hostname during rule processing if the area pointed to after the syscheck decoder free isnt null terminated One possible fix would be for the ossecalert decoder to osstrdup the lfhostname and lfprogramname before freeing fulllog The ossecanalysisds OSCleanMSG function doesnt remove or encode terminal control characters or newlines from processed log messages In many cases those control charactersnewline are later logged There have been cases where allowing arbitrary control characters in log messages has led to command execution with specific terminal emulator implementations As a result many pieces of software eg Apache HTTPD have added escaping of control characters in log messages It may also be possible to abuse terminal control characters to hide previous messages in a log tricking system administrators into missing events Similarly because newlines n are permitted in messages processed by ossecanalysisd it may be possible to inject nested events to the ossec log This may result in system administrators being tricked into thinking alerts fired that did not The ossecanalysisds syscheck decoder srcanalysisddecoderssyscheckc performs unsafe path handling using the received agent name when trying to get the agent file The DBFile function uses the agent name unsanitized when building a file name to be used with fopen Processing a syscheck message like aetcsharedtesttxtaaaaaaa aaaa from an agent named test sending from localhost results in an open for queuesyschecktest aetcsharedtesttxt This will fail with ENOTDIR because the part of the path the attacker cant control remotely test a is not a directory Creating it first by sending a message like aaaaaaaa aaaa seems like a potential solution at first but wont work because while the file queuesyschecktest a will be created it wont be created as a directory but a regular file I suspect this means that the bug is only useful to local attackers that can write directly to the ossec queue Writing directly to the queue allows full control of the lflocation used as the agent argument to fopen and can cause the syscheck DB file to be created in an attacker controlled location within the chroot Remote attackers can not control the full lflocation since the ossecremoted ensures the prefix of agent name and source IP is always present Likely the best fix is to use the wrefparentfolder function from srcsharedfileopc on the location field populated by OSCleanMSG and rejecting any values that have a return from that function The rootcheck component of ossecsyscheckd also capable of being run independently has an optional checkif feature enabled by default Because of the nature of the rootcheck requirements this tool is typically run with root privileges unlike many other OSSEC components that drop privileges The code for this feature srcrootcheckcheckrcifc looks for promiscuous interfaces by iterating the ifreq structs returned by the SIGOCGIFCONF ioctl When an interface with the IFFPROMISC flag bits set is found the rootcheck component invokes the libc system function man system to run an ifconfig grep pipeline to try and verify that ifconfig reports the interface as promiscuous matching the IF flags Critically the const char command provided to system includes potentially attacker controlled data without sanitization by way of the interface name used as the s format argument Linux imposes almost no restrictions on interface names except that they be characters long They may include and many other shell metacharacters that will be improperly evaluated by the system call Nonroot users can make Linux interfaces with controlled names if theyre in the docker group or if LXC is configured appropriately While LXC filters the allowed characters Docker does not allowing a nonroot user to make an interface with shell metacharacters Eg creating an interface named echooops on the Docker host via docker network create opt comdockernetworkbridgenameechooops testnet I believe this is presently not a viable local root privilege escalation because the ifconfig call is only made for interfaces found with IFFPROMISC flags and I dont know of a way to set these flags without being root or in group netadm This may be a viable escalation from netadm root I think this code was added with and has been present since v Even though this may not be exploitable today having root code invoke system is very risky It would be better to find an alternative means for double checking promisc interfaces or to rewrite the code to avoid system eg forking and using execve Installation or upgrade to ossechidsagent buster fails for me with an error chown invalid user ossecossec when installing packages from The problem can be fixed with sudo adduser ossec system gid home varossec and installing again Though this PR is some rough points this successfully create a deb package for arm I want to merge this PR but I noticed current generateossecsh doesnt work well now So before I blush up this I ask you how to improve this PR fix Hello I have some custom decoders that work well but there is some problem with the arguments to the activeresponse scripts The srcip is visible in the email and logtest but not in the activeresponse action Normal Decoder ssh to activeresponse Mon Dec UTC varossecactiveresponsebinnotifysh add xxxx varlogsecure Custom decoder to activeresponse Fri Jan UTC varossecactiveresponsebinopenvpnsh add varlogopenvpnlog Only dashes on srcip openvpnsh binsh echo date varosseclogsactiveresponseslog Decoder decoder nameopenvpntlsevent parentopenvpnparent prematchpcre offsetafterparentTLS Initial packet from prematchpcre pcre offsetafterprematch d d d d dpcre ordersrcipsrcportorder decoder Rule rule id level ifsid ifsid matchTLS Initial packet frommatch descriptionTLS initial packet to the VPNdescription groupconnectionestablishedgroup rule Osseclogtest Jan server openvpn TLS Initial packet from AFINET sid c g c Phase Completed predecoding full event Jan server openvpn TLS Initial packet from AFINET sid c g c hostname server programname openvpn log TLS Initial packet from AFINET sid c g c Phase Completed decoding decoder openvpn srcip srcport Phase Completed filtering rules Rule id Level Description TLS initial packet to the VPN Alert to be generated Email OSSEC HIDS Notification Jan Received From servervarlogopenvpnlog Rule fired level TLS initial packet to the VPN Src IP Portion of the logs Jan server openvpn TLS Initial packet from AFINET sid c g c Ossec version ossechidsserver el artx ossechids el artx Any ideas 