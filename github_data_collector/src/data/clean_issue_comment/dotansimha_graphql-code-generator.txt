Describe the bug typescriptresolvers can be used to generate type signatures for field resolvers When all args of a field are optional the type of each arg should be T null undefined as missing args are passed to the resolver as undefined when resolving the query However typescriptresolvers only generates the signature T null which may lead to subtle bugs eg when argsfoo null is used to check if an arg is set If at least one of the args to a field is required the correct signature is generated To Reproduce Steps to reproduce the behavior Use to see the bug in action My GraphQL schema graphql schema query Query type Query allOptionaloptional Int Boolean someRequiredoptional Int required Int Boolean My codegenyml config file yml generates servertypests plugins typescript typescriptresolvers The generated output notice the missing RequireFields wrapper in allOptional typescript export type QueryResolversContextType any ParentType extends ResolversParentTypes Query ResolversParentTypes Query allOptional ResolverMaybeResolversTypes Boolean ParentType ContextType QueryAllOptionalArgs someRequired ResolverMaybeResolversTypes Boolean ParentType ContextType RequireFieldsQuerySomeRequiredArgs required Expected behavior The output should generate a type for allOptionals field resolver that ensures that all args may be undefined RequireFields does this implicitly by marking any fields not listed in its second generic argument as optional the first part in the following definition before typescript export type RequireFieldsT K extends keyof T X in Excludekeyof T K T X P in K NonNullableT P That is why the optional arg in the field someRequired in the example above is correctly typed as T null undefined It seems that RequireFieldsQueryAllOptionalArgs never could achieve this ie instead of dropping RequireFields when no args are required use never for the list of required arg nameskeys Environment OS any graphqlcodegentypescriptresolvers NodeJS any Describe the bug When trying to generate types for schema using an empty Query type then importing another file that includes an extension Query leads to an error saying that Query must define one or more fields To Reproduce Steps to reproduce the behavior GraphQL schema schemagraphql graphql import from usersgraphql type Query Inside usersgraphql graphql extend type Query users User type User name String codegenyml config file yml schema apigraphqlschemagraphql generates commontypesschemats plugins typescript typescriptresolvers Expected behavior Since usersgraphql extends Query I was expecting the type generation to work as expected but its telling me Query needs one or more fields Is this a graphqlimport issue Ive tried different import variants import usersgraphql import User from usersgraphql to no avail Environment OS macOS graphqlcodegen NodeJS Describe the bug While validating query file with connection directive written correctly library throws a type error GraphQLDocumentError Expected type UserFilterInput found filter which is incorrect connection directive should expect String type instead of UserFilterInput While manually editing the generated file the generated document gql my query and firing request it works correctly so no type error should be thrown To Reproduce My GraphQL schema graphql type Query userfilter UserFilterInput page Int perPage Int User input UserFilterInput id ID type User id ID username String email String My GraphQL operations graphql query user userfilter id page perPage connectionkey PaginatedUsers filter filter id username email My codegenyml config file yml schema schemagraphql documents documentgraphql generates typests plugins typescript typescriptoperations typescriptreactapollo typescriptresolvers Expected behavior filter argument inside connection directive should be of type String no matter what query it applies to Environment OS MacOS Mojave graphqlcodegen as well as on my localhost NodeJS v Additional context Error log AggregateError GraphQLDocumentError Expected type UserFilterInput found filter at documentgraphql at ObjectcheckValidationErrors sandboxnodemodulesgraphqltoolkit commonindexcjsjs at Objectcodegen sandboxnodemodulesgraphqlcodegencoreindexcjs js AggregateError GraphQLDocumentError Expected type UserFilterInput found filter at documentgraphql at ObjectcheckValidationErrors sandboxnodemodulesgraphqltoolkit commonindexcjsjs at Objectcodegen sandboxnodemodulesgraphqlcodegencoreindexcjs js Something went wrong validatedocumentsts is probably incorrectly identifying arguments of query argument vs connection directive argument Related Use mergeSchemas instead of mergeTypedefs to add definitions to the schema Use exclusions instead of visitors for patching federated schemas Adds the optional disabled by default FieldWrapper type for wrapping field definitions on objects and interfaces but not input types In addition to returning a value of the actual type for a field objects can also return Promises to that type or functions that do the same It is currently not possible to achieve that by reconfiguring the code generator This adds the ability to wrap field definitions in a FieldWrapper which defaults to FieldWrapperT T thus not changing behavior in any way To get the abovedescribed behavior a user would need to set fieldWrapperValue to T PromiseT T PromiseT or something similar in addition to enabling field wrapping by setting wrapFieldDefinitions to true That may be overkill but I wanted to avoid altering the current existing behavior unexpectedly Closes Allows Resolver to be a value rather than just a function by adding TResult and PromiseTResult as possible types Resolvers are generally functions but they are also allowed to be values Related Is your feature request related to a problem Please describe A clear and concise description of what the problem is Ex Im always frustrated when Now graphql codegen creates Typescript code for enum as a normal enum Its better if we use const enum the compiler can provide more optimization Describe the solution youd like A clear and concise description of what you want to happen In spite of generating enum we should return const enum Describe alternatives youve considered A clear and concise description of any alternative solutions or features youve considered Additional context Add any other context or screenshots about the feature request here Is your feature request related to a problem Please describe A clear and concise description of what the problem is Ex Im always frustrated when graphqltoolkitapolloengineloader depends on apollolanguageserver which is a huge dependency But we are not using Apollo Server and we do not need this feature Describe the solution youd like A clear and concise description of what you want to happen The dependency tree includes a lot of modules of Apollo Server that do not seem to relate to GraphQL code generation such as apollolink It would make more sense to make the loaders into plugins Describe alternatives youve considered A clear and concise description of any alternative solutions or features youve considered It should also be possible to make apolloengineloader more lightweight so it doesnt depend on apollolanguageserver Additional context Add any other context or screenshots about the feature request here yarn why apollolanguageserver yarn why v Why do we have the module apollolanguageserver Initialising dependency graph Finding dependency Calculating file sizes Found apollolanguageserver info Reasons this module exists graphqlcodegencligraphqltoolkitapolloengineloader depends on it Hoisted from graphqlcodegencligraphqltoolkitapolloengineloaderapollolanguageserver info Disk size without dependencies MB info Disk size with unique dependencies MB info Disk size with transitive dependencies MB info Number of shared dependencies Done in s documentModestring is perfect for graphqlrequest but it simply inlines any referenced fragments This means that fragments that are included more than once in a single query for example by being included by another fragment in that query as well as at the top level are thus duplicated in the query and then fail when send to the server This PR parses and stringifies queries ahead of time such that no duplicates occur