I have this list of promises chained by then while current then will dispatch async to main to next runloop while we want the work to be done immediatelyinplace when some condition is met Say user type on keyboard and triggered the list of promises to be chained while we want the the work of then to be called synchronously instead of just return sth like ifIsOnMain promiseisFulfilled workOfThen Is there a way to expose api like a synchronousThenIfPossible Thanks This is to address the issue described in this ticket Hi Im sorry to cross post this with stackoverflow but there was no tag related to googlepromises Im working on a framework that uses promises internally and Id like the framework to work cross platform for iOS macos and tvOS When building my framework for distribution with cocoapods the lint check is failing specifically for macos but not the other platforms Ive described the error in this ticket If I can get some help id very much appreciate it getAllUsersgsuiteName gsuiteNamethenuploadUsersarr currentUsersEMarr currentUsersUSthennewScreen Am trying to use this library for the first time and am running into this error when chaining promises together Cannot convert value of type PromiseAny to expected argument type Any throws Void Error in Swift Here is the code for getAllUsers and uploadUsers func getAllUsersgsuiteName String PromiseAny DatabasedatabasereferencechildMessageschildgsuiteNamechildUSERSobservevalue snapshot in when for child in snapshotchildren selfcurrentUsersEMappendchild as AnyObjectvalue as String selfcurrentUsersUSappendchild as AnyObjectkey as String selfcurrentUsersEMappendAuthauthcurrentUseremail selfcurrentUsersUSappendselfusernametext return Promise return nil func uploadUsersarr ArrayString arr ArrayString PromiseAny for usCount in arr count printUSERNAME arr usCount as String printEMAIL arr usCount as String DatabasedatabasereferencechildMessageschildgsuiteNamechildUSERSsetValue currentUsersUS usCount as String currentUsersEM usCount as String return Promise return nil func newScreen let changeRequest AuthauthcurrentUsercreateProfileChangeRequest changeRequestdisplayName selfusernametext changeRequestcommitChanges error in selfperformSeguewithIdentifier goToChat sender self Overview No type information is persisted when wrapping an ObjectiveC FBLPromise value in a Promise nor when deriving an ObjectiveC value through PromiseasObjCPromise The Value generic type on both init and asObjCPromise is not the same Value type that is on the class and as such they can be freely parameterized to any combination of distinct values Symptoms Erasure when wrapping The following compiles and runs without issue demonstrating the erasure when wrapping ObjectiveC swift let objCPromise FBLPromiseNSStringpending let swiftPromise PromiseIntobjCPromise objCPromiseonQueuemain then value in printvalue return value swiftPromisefulfill Of course doing anything with value that would not be understood by a Swift Int causes a runtime failure Fulfilling in the other direction with incorrect types also compiles and runs swift let objCPromise FBLPromiseNSStringpending let swiftPromise PromiseIntobjCPromise swiftPromisethenon main in objCPromisefulfillA value This snippet fails at runtime regardless of the contents of the then block as the coercion back to Int fails Erasure when unwrapping The following also compiles and runs without issue demonstrating the erasure when moving from Swift to ObjectiveC swift let swiftPromise PromiseIntpending let objCStringPromise FBLPromiseNSString swiftPromiseasObjCPromise let objCPromisePromise FBLPromisePromiseInt swiftPromiseasObjCPromise let objCDateFormatterPromise FBLPromiseDateFormatter swiftPromiseasObjCPromise objCStringPromiseonQueuemain then value in printvalue return value swiftPromisefulfill All derived ObjectiveC Promises can be interacted with as if they are the declared types and again fail at runtime when interacted with in a way that the real underlying type doesnt understand As in the previous section fulfilling in the other direction with incorrect types also compiles and runs swift let swiftPromise PromiseIntpending let objCStringPromise FBLPromiseNSString swiftPromiseasObjCPromise swiftPromisethenon main in objCPromisefulfillA value Again this snippet fails at runtime regardless of the contents of the then block as the coercion back to Int fails Root Cause The concrete type used to populate a generic type parameter in a function is resolved at the call site and functionlevel generic type parameters are unrelated to the type parameters of the enclosing class Within a given Promise instance there is a Value symbol PromiseValue that is usually what is being interacted with In the two critical methods init and asObjCPromise they are being shadowed Concretely those methods look like PromiseValueinitValue and PromiseValueasObjCPromiseValue which to stress the difference in parameters are entirely equivalent to PromiseTinitU and PromiseTasObjCPromiseV U and V intentionally varied from each other As a result the Value on the ObjectiveC FBLPromise is entirely erased from the perspective of the Swift Promise when wrapped in init Likewise the Value on the Swift Promise is entirely erased from the perspective of the ObjectiveC FBLPromise when unwrapping through asObjCPromise Possible Solution The two Value parameters can be unified by way of exposing them in an extension that applies the necessary Value AnyObject constraint on the Swift Promises Value swift extension Promise where Value AnyObject public convenience init objCPromise FBLPromiseValue public func asObjCPromise FBLPromiseValue This has a few immediate drawbacks The nowconvenience init is today the primary designated initializer This would require some reconfiguration Its no longer simple to turn a PromiseString into a FBLPromiseNSString the types must match exactly so the Swift entity would also need to be PromiseNSString Its possible that this can be addressed with some fancier generic constraints The latter issue may break a number of existing clients in cases that were actually fine 