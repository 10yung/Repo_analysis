Ive isolated a rule pattern where Id expect the parser to succeed for a given input but it fails instead The sample grammar RuleA RuleB RuleB IDENTIFIER RuleC IDENTIFIER RuleC RuleB RuleA The implementation scala import scalautilparsingcombinator import scalautilparsingcombinatorsyntacticalStandardTokenParsers object SimpleParser extends StandardTokenParsers with PackratParsers lexicaldelimiters List lazy val ruleA PackratParser String ruleB lazy val ruleB PackratParser String ident ruleC ident lazy val ruleC PackratParser String ruleB ruleA def mainargs Array String printlnruleAnew PackratReadernew lexicalScannerxx It fails for input xx telling me that it expects a instead of the For me this seems to be a problem with how indirect leftrecursion is handled Im not sure if the original algorithm is incapable of handling this pattern or this is an implementation bug Edit Ive accidentally used first matching alt instead of longest matching alt Ive fixed that in the code but doesnt change the outcome ParseResult and its subtype are members of scalautilparsingcombinatorParsers Why This limits the ability to write code using ParseResult without any added benefit as far as I can see Eg I would like to define a scalatest Matcher I have to wrap it now into a scope parameterized by a Parsers instance or I have to redefine the Matcher in every test case This change means revival of lastNoSuccessVardeleted by However in this time a new variablelastFailure in Success class is immutableie this variable does not means revival of side effects That is why probably this change does not break referentially transparent Edit I signed CLA Sorry for not following the procedure This issue may be expected operation but I feel failure msg is inappropriate execute below parser in version and import scalautilparsingcombinator object Parser extends JavaTokenParsers def applystr String ParseResult List Node parseAlltop str private def top Parser List Node repsepnode n private def node Parser Node positionedident ident case v v Nodev v parsed text This text causes failure An appropriate text is for example A B is A A B C In version I got expected but A found This failure message is expected message However in version I got end of input expected This message loses information where is wrong point As a result that I checked difference of code between and lightly I suspect that s change causes this In addition as far as I know this problem occurs when using repsep eg if parseAll uses node method directly parser does not cause this problem Environment scala version sbt version As mentioned in it would be neat to add crosscompilation to Dotty to this library To figure out how to do this it might help to look at where this is done for the scalaxml library It would be nice to add the bits of code from chapter of Programming in Scala as tests to be sure we dont break compatibility too much with the book This overrides err in RegexParser to make it consume whitespace just like regex and literal The original motivation was object parser extends RegexParsers def num dr def twoNums num num errerror succeeds parserparseAlltwoNums fails with a parsing Failure instead of an Error because err doesnt consume the whitespace but the regex does parserparseAlltwoNums foo This may change the output of some parsers that failed to parse input from a Failure to an Error fixes reintroduction of Hi all Ive created a fork which adds completion support to the library which allows providing asyoutype autocomplete or TABcompletion experiences In a nutshell additions are def completionsin Input Completions method which allows querying the list of possible completions for a certain input This returns a structured type which can contain tagged and ranked completions implementations of this method for all the combinators a new set of operators which allows tagging and ranking elements of the grammar I have also implemented fuzzy matching completion parsers which are not present in the fork right now but that I could potentially integrate Would you consider this as a possible PR Its of course extending the traditional functionality of parser combinators so it add extra complexity and testing requirements that are maybe not desirable for the core library At any rate Im creating this issue also to to point out that building completion experiences using parsercombinators is feasible and actually works well with the functional nature of these grammars Hi The parser combinators works wonderfully except for a minor tweak Id like to add I would like to constrain the type of position data structure in my parser pipeline At the moment parsersscala will use the base type Position and leave the specific position type to Readers The downstream operation will need to perform pattern matching to cast the position data into specific type eg OffsetPosition This gets tedious if I already know that my parser will only use one specific Position type I propose to make position a type member in a similar fashion to Elem and Input Existing code base can be kept intact by adding scala type Pos Position If needed a user can constrain the position type to be more specific by overriding the type member eg scala override type Pos OffsetPosition I will send out a pull request on the proposed change Please take a look ParseResulttoString results in javautilNoSuchElementException head of empty list Relevant code scala val ast progParsernew TokenReaderin printlnasttoString Here is where things go wrong printlnastgettoString works fine class TokenReaderinList Token extends Reader Elem def atEndBoolean inisEmpty def firstElem inhead def posPosition inheadpos def rest new TokenReaderintail def progParser Parser List Definition paddedDefParser eofParser class Expression case class Definitionval leftsideDefLhs val rightsideDefRhs extends Expression Error top of stacktrace error runmain javautilNoSuchElementException head of empty list javautilNoSuchElementException head of empty list at scalacollectionimmutableNilheadListscala at scalacollectionimmutableNilheadListscala at fumurtCompilerFumurtParserTokenReaderposParserscala at scalautilparsingcombinatorParsersSuccesstoStringParsersscala 