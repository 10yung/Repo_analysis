Hello I came across an issue where I am getting charged for double the reads when using useFirestoreDocData to subscribe to data I created a custom hook to pass a user object like the below const useUserData const firestore useFirestore const userAuth useUser const user useFirestoreDocDatafirestoredocusersuserAuthuid return user The way I am testing is only having one trigger to useFirestoreDocData throughout the whole app with the expectation to trigger only read on app init refreshing extra times to generate total reads and then checking the firebase Usage tab I have changed the useFirestoreDocData to a none ReactFire snapshot subscription and am only getting charged for read as oppose to useFirestoreDocDatas confirming that it has nothing to do with anything else in the app structure Any ideas on this As a side note I was hoping I could ask on how are ReactFires subscriptions handled on page refresh window close Are they automatically unsubscribed or will they still be running If they are still running are there any plans to implement a feature that would terminate them on such events any suggestions on best practices for that Version info React Firebase ReactFire canary fce b This little example demonstrates an in my opinion unfortunate behavior tsx import React useEffect useState from react import useFirestoreDoc useFirestoreCollection from reactfire import firestore from firebaseapp export default function Test useFirestoreDocvoidfirestoredoctesttest useEffect firestoredoctesttestset const limit setLimit useState const snap useFirestoreCollectionvoid firestore collectiontest limitlimit return div style width spanlimit limit spanbutton onClick setLimitlimit limit Load more button snapdocsmapdoc div keydociddociddiv div style height button onClick firestore collectiontest add Add doc button div Story time I had a component that was supposed to show a list of documents and progressively load more documents as the user scrolls I did the obvious thing and made a limited query and had the limit in a state But when I changed this state the component didnt suspend until the results arrived like I expected rather it switched momentarily to only showing a single document Turns out this was because I had subscribed to that particular document from a different component I understand if you dont want to make it the default behavior to suspend until the first noncache response arrives but there must be some sort of middle ground I have a use case where I want to subscribe to two queries simultaneously ts const aSnap useFirestoreCollectionaQuery const bSnap useFirestoreCollectionbQuery This will result in an unnecessary waterfall where we wait for the first query to unsuspend before sending off the next I resolved this by writing this helper function ts export interface ResourceT read T A higher order function that will call a given function and wrap the return value in a Resource If the callback throws or suspends we catch that and throw or suspend upon Resourceread instead This makes it easier to have more concurrent requests and avoid unnecessary waterfalls by suspending too eagerly export function resourcifyA extends any Tfunc args A T return functionargs A ResourceT try const t funcargs return read return t catch err return read throw err function MyComponent const aSnap bSnap resourcifyuseFirestoreCollectionaQuery resourcifyuseFirestoreCollectionbQuery mapresource resourceread return null But it would be nice if the API nudged us in this direction by default Thank you for contributing to the Firebase community Have a usage question We get lots of those and we love helping you but GitHub is not the best place for them and they will be closed Here are some resources to get help Start with the quickstart Go through the guide Read the full API reference Try out some examples If the official documentation doesnt help try asking through our official support channels Please avoid double posting across multiple channels Think you found a bug Yeah were definitely not perfect Please use the bug report template below and include a minimal repro when opening the issue Have a feature request Great we love hearing how we can improve our products Just remove the template below and provide an explanation of your feature request Provide code samples if applicable Try to think about what it will allow you to do that you cant do today How will it make current workarounds straightforward What potential bugs and edge cases does it help to avoid Version info What versions of the following libraries are you using Note that your issue may already be fixed in the latest versions React Firebase ReactFire canary fce b Test case I want to use role based authentication on documents so when a document is successfully read in the app and then I change the access of that user the listener throws an error instead of a Promise ts const CompanyCheck ReactFC children const companyId setCompany useCompanyContext const firestore Firebase Firestore useFirestore const companyRef useRef firestore collectioncompanies doccompanyId useEffect companyRefcurrent firestore collectioncompanies doccompanyId companyId firestore This wont throw a promise on permission changes after successfull read const companyDoc useFirestoreDocDataCompanycompanyRefcurrent useEffect setCompanycompanyDoc companyDoc setCompany return children Steps to reproduce Use a correct example of read operation with role access then once the data is displayed remove the access to the document and error boundary wont catch any error Expected behavior Throw a promise like when initial read fails so ErrorBoundary can catch the error Actual behavior Dont throw a Promise and error cant be handled Error message is permissiondenied Thank you for contributing to the Firebase community Have a usage question We get lots of those and we love helping you but GitHub is not the best place for them and they will be closed Here are some resources to get help Start with the quickstart Go through the guide Read the full API reference Try out some examples If the official documentation doesnt help try asking through our official support channels Please avoid double posting across multiple channels Think you found a bug Yeah were definitely not perfect Please use the bug report template below and include a minimal repro when opening the issue Have a feature request Great we love hearing how we can improve our products Just remove the template below and provide an explanation of your feature request Provide code samples if applicable Try to think about what it will allow you to do that you cant do today How will it make current workarounds straightforward What potential bugs and edge cases does it help to avoid Version info What versions of the following libraries are you using Note that your issue may already be fixed in the latest versions React Firebase ReactFire canary fce b Other eg Node browser operating system if applicable Issue Provide a minimal complete and verifiable example using either Plunker or JSFiddle When I use useFirestoreDoc it has useState hook somewhere inside I am guessing somewhere inside useObservable and useFirestoreDoc is using onSnapshot method of firebase and returns snapshot result of queried document When I tried to log this snapshot I am getting the result twice fromCache false fromCache true This renders the component times because useState hook is used inside useObservable My Questions Why it is sending results How can I rectify this renders issue fromCache true is only expected when user is offline why it is fetching from cache even when user is online Remote Config now supports web Lets include it in ReactFire Google Analytics for Firebase now supports web Lets include this in ReactFire Have an example usage of ReactFire that youd like to share with the world Post a link to your repositoryStackblitzCodesandbox here It can serve as a learning resource for other ReactFire developers Seems like the type definitions for useFirestoreDoc and useFirestoreCollection are incorrect typescript export declare function useFirestoreDocT unknownref firestoreDocumentReference options ReactFireOptionsT firestoreDocumentSnapshot T In a union unknown absorbs everything so if we dont pass a generic type here the return type will always be unknown I tried to find a way to fix this so I could do a PR myself but Im afraid my TypeScript knowledge is lacking If I understand correctly what we want here is to make the return type be firestoreDocumentSnapshot by default or T if specified I opened a PR with a way to do this but Im really not sure if this is how its supposed to be done Version info React Firebase ReactFire canaryfc be b Typescript on my machine and on CodeSandox both show the same problem Test case Test case on Code Sandbox I didnt try to make the project actually run because the issue is just the type definitions The issue isnt visible right away though because reactfire cant import from firebaseapp on Code Sandbox for some reason Follow these steps to see the problem Steps to reproduce Visit Open the file srcwithoutOptionsts Rightclick useFirestoreDoc and select Go To Definition Check if the firebaseapp import is failing If it is replace with just firebase Dont save the file but leave it open important Go back to srcwithoutOptionsts and check the type of doc by hovering the mouse over it Expected behavior The type should be firestoreDocumentSnapshot by default Actual behavior The type is unknown Right now using the initPerformance flag in FirebaseAppProvider activates Performance Monitoring automatic traces In addition SuspenseWithPerf creates a custom trace Are there other places in Reactfire where it would be useful to include Performance Monitoring traces For example useFirestoreCollection could log a custom trace with a custom attribute logging the number of documents returned any of the use hooks could log a custom trace