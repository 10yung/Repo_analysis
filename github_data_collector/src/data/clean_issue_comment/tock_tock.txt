While reviewing I noticed this rust start comparator regseventsreadyset regstasksstartset wait for comparator to be ready delay is on order of microseconds so spin wait is OK while regseventsreadyget We do stuff like this in a few places but as we start busylooping on more complex peripherals I wonder if we perhaps introduce the possibility for the kernel to hang in a way thats challenging to debug Should we have a kernel primitive of some form that safely spins rust fn waitforhardwareF Frequency fn closure type max s u bool Compute max number of tries given maxus and core speed let maxtries while maxtries if fn return true false wait for comparator to be ready if waitforhardware regseventsreadyget return InitializationError panicuseful error message Or is this the kind of situation where wed never really be able to do anything useful in the case of failure Pull Request Overview This pull adds an implementation for an Analog Comparator for the nrf It doesnt modify the HIL interface It adds the required drivers and interrupts to the nrf I will most likely create a second PR later to modify the analog comparator HIL as well as this implementation and the sam l implementation Testing Strategy This pull request was tested by Langston Nashold I used existing tests for the analog comparator to test both interrupt and pollingbased comparison I placed connecting VIN to the VDD and the VIN to ground I then switched the two connections which created the appropriate changes in the comparators output I havent tested it on the nrf dk yet however Todo Test on nrf chip Rebase commits Documentation Updated Updated the relevant files in docs or no updates are required Formatting X Ran make formatall If there is a panic the kernel does not print out processor state unless there are processes prints CPU state by calling panicprocessinfo which in turn prints its information through Process if procsisempty procs asrefmapprocess processfaultfmtwriter print data about each process let writerwritefmtformatargs r n App Status r n for idx in procslen procs idx asrefmapprocess processprocessdetailfmtwriter Getting debug output for a kernel panic should not require having a user process eg if your entire system is in the kernel It seems like this approach was used mostly so debug doesnt need a reference to chip Eg Processfaultfmt just uses the chip reference unsafe fn faultfmt self writer mut dyn Write selfchipuserspacekernelboundaryfaultfmtwriter Would it make more sense for debug to have a direct reference to a UserspaceKernelBoundary Better yet it seems like this debug output functionality should be in a separate trait Pull Request Overview This pull request adds a new IoWrite trait in the kernel to write arbitrary bytes instead of UTF strings fixes Until now the flush function was using strfromutf unchecked even though the bytes are actually not UTF even with only UTF input the underlying ring buffer may wraparound in the middle on a UTF character In practice the underlying implementations work bytebybyte to send debug output so a more general trait to write byte slices can be plugged in This IoWrite trait is similar to stdioWrite except that the latter doesnt exist in nostd because stdioError isnt compatible see and Testing Strategy This pull request was tested by Travis TODO or Help Wanted This pull request still needs support for bytebybyte writing on the artye board Im not even sure the current debug macro is what we want to do in a panic handler Documentation Updated x Updated the relevant files in docs or no updates are required Formatting x Ran make formatall Pull Request Overview This pull request Updates the arty board to use the DebugWriterComponent Removes the pub static mut buffers from the kernelsrcdebugrs and uses staticinit to create them in the component instead This is less errorprone as discussed in and can be more flexible as it allows to more easily increase the buffer size in a specific board Testing Strategy This pull request was tested by Travis I dont have an arty board to test on I also checked that the code size is the same on all boards beforeafter this change TODO or Help Wanted NA Documentation Updated x Updated the relevant files in docs or no updates are required Formatting x Ran make formatall Pull Request Overview It has been about months so a good time to stay current Also motivated by which should make debugging easier Changes New warning about not needed Update to update script Testing Strategy travis TODO or Help Wanted na Documentation Updated x Updated the relevant files in docs or no updates are required Formatting x Ran make formatall Problem description Despite the existing staticinit macro to initialize static data there are still many uses of raw static mut buffers or other data git grep static mut and git grep pub static mut yield many results across the code base However static mut is fundamentally unsafe because its relatively easy to alias static data from anywhere in the program There are indeed evidence of why it is fundamentally problematic in the Rust language and it may even be deprecated in the future Why is static mut bad Consider deprecation of UBhappy static mut In particular given the pervasive definition of unsafe functions in Tock its quite easy to forget that accessing static mut data is unsafe and why it is unsafe All one needs to do to alias a static mut BUF is to write mut BUF in an unsafe block of code and a large chunk of Tocks code is wrapped in unsafe functions This was one of my concerns in An example is the debugwriter component which eagerly creates mutable references to the kernels INTERNALBUF and OUTPUTBUF static mut objects On the other hand the staticinit macro hides the underlying static buffer its private to the macros block of code and returns a single static mut reference instead The advantage of static mut over plain static mut is that it requires much more effort to alias it Although its still possible to alias in unsafe code one needs to write something like mut buf as mut T to alias the reference and the as mut T part is much more visible as a red flag that unsafe aliasing is happening Here is another toy example showing how much effort is required to alias data in both cases when the code is not globally wrapped in an unsafe block rust static mut FOO u static mut BAR u fn main foo barunsafe mut BAR fn foo let x unsafe mut FOO let y unsafe mut FOO Undefined behavior because x and y both alias FOO concurrentx y fn barbuf static mut u error E cannot use buf because it was mutably borrowed let alias mut buf To alias the static data one needs to cast to a raw mut pointer and then reborrow it let alias unsafe mut buf as mut u Undefined behavior because buf and alias both alias BAR concurrentbuf alias Rusts aliasing rules assume that left and right dont alias fn concurrentleft mut u right mut u left right left right println left Proposal Audit all uses of plain static mut data in Tock and replace them with static mut or a mut references that are initialized with the staticmut macro in boards Understand if there are cases where staticinit isnt enough and why In going through the Rust unstable features being used we noticed use of exclusiverangepattern This is only being used in a handful of places and at least at first blush it feels like its being used incorrectly For example at rust while let Someinterrupt plicnextpending match interrupt interruptsUART uartUART handleinterrupt index interruptsGPIO interruptsGPIO gpioPORT index as usize handleinterrupt debugPidx interrupt It appears that GPIO in this case can indeed be a valid GPIO interrupt but the exclusive range is in this case eliding the handling of it If this code is correct it seems that a better way to phrase it would be with an inclusive pattern to GPIO and then call out the fallthrough of GPIO In the other places that enable exclusiverangepattern it is not in fact used This was in part noticed by the OpenTitan port which copied use exclusiverangepattern and then introduced a bug in UART handling as a result so it is indeed errorprone It seems like use of exclusiverangepattern should be removed happy to open a pull request with this removal if and as needed Pull Request Overview This pull request updates the USB HIL and implements it on the nrf chip There are still unimplemented parts isochronous endpoints handling of USB events but I tested it on the USB echo app for bulk endpoints and some interrupt endpoints example not public yet though the logic in the chip is pretty much the same for interrupt and bulk Notable changes to the HIL in order to support this chip as well as interrupt endpoints The UsbController and Client traits now take a lifetime parameter This is ultimately to use lifetimebound buffers as previously discussed in Unified the endpointenable methods to take the transfer type as parameter This avoids code duplication down the road as interrupt and bulk endpoints are handled very similarly by the nrf chip Similarly bulk methods in the USB client are replaced by packet methods And BulkInOutResult enums are generalized to interrupts as well Added a possibility to enable an endpoint both for IN and OUT directions Some protocols such as USBHID have such bidirectional endpoints Split endpointbulkresume into endpointresumein and endpointresumeout functions to specify which direction should be resumed given that an endpoint can now be both IN and OUT directions Due to the way nrf triggers USB events I had to remove the delayedin check in capsulessrcusbusbcclientrs otherwise the driver never initiates IN transactions from the device to the host I had a look at the sam l code and this doesnt seem problematic superfluous resumes are ignored I propagated these changes on the sam l but not implementing the new combinations there as I dont have a board to test on Code compiles though Isochronous endpoints are left unimplemented Another thing to note some revisions of the nrf chip need many more errata to function properly As I dont have the hardware to test and to keep things simple these extra errata are not implemented If one enables the USB stack on such chip it will panic given that the rest of the code will be unstable on these chips Testing Strategy This pull request was tested by Running the USB bulkecho test app with the host test program Testing a USBinterruptbased HID protocol TODO or Help Wanted This pull request still needs The interrupt service to listen to USB Adding the usbuser driver to the board Its what I added on top of this pullrequest to test bulkecho and I can integrate it to this pullrequest if needed There are still a few things to implement but given how big USB is I dont think a single pullrequest should implement it all similarly to sam l The goal is to give a basis to experiment and iterate on Documentation Updated Updated the relevant files in docs or no updates are required Formatting x Ran make formatall Hi there Is there any ongoing effort in making tock use the TrustZoneM or porting it completely to be executed in the Secure World If not would you consider it a desirable goal for tockos Thanks you