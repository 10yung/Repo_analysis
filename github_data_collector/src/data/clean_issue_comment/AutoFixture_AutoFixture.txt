Today I stumbled about a bug and I am a little confused why it is happening The test code is around some bad legacy code which sadly cannot be changed public interface IValue public interface IItem IValue Value get public interface ISpecialItem IItem new IValue Value get set public interface IFoo IListISpecialItem Items get So basically there is an interface IItem having a readonly property and for some reason the writer of this legacy code wanted to have a setter for an inherited interface ISpecialItem Therefore the new keyword In another interface IFoo is a property with a list of these special items as data type Fact private void Test var customization new AutoNSubstituteCustomization ConfigureMembers true var fixture new Fixture fixtureCustomizecustomization var foo fixtureCreateIFoo Reading the property once fixes it var items fooItems fooItemsReturnsNull In a test the interface IFoo is created with AutoFixture but someone wanted to test a special case where the property returns null For some strange reason an exception is thrown Can not return value of type IList for ISpecialItemsetValue expected type Void Investigating the exception further I found that AutoFixture is trying to set the Value property of the special items to return null by calling NSubstitute And NSubstitute throws an exception not allowing Returns statements on properties having a setter The fixture creates the IFoo proxy with an Items property returning ISpecialItem proxies due to the ConfigureMembers being true in the customization By calling the ReturnsNull extension method I override the proxies return value of the Items property but I dont understand why this results in a call to ISpecialItemValueReturnsNull With my limited understanding of AutoNSubstitute it gets even stranger for me If I read the property at some point before calling the Returns statement everything works fine If needed I can attach a sample solution Thx for any help Gerald The Moq reference version contains a reference to CastleCore which again contains a reference to SystemComponentModelTypeConverter This version SystemComponentModelTypeConverter is not available on NuGetorg and Visual Studio emits a warning CastleCore depends on SystemComponentModelTypeConverter but SystemComponentModelTypeConverter was not found An approximate best match of SystemComponentModelTypeConverter was resolved The first version of Moq that references a newer version of CastleCore with this issue fixed is has upgrading the minimum NSubstitute version to v for version been considered It strikes me that we are two clear versions behind and I wondered what hte rationale for this is Im happy to do the upgrade if it is desired Fixes Also could fix we want to drop support for FakeItEasy x and retain it for Alternatively more versions could be dropped Fixes I was preparing to test AutoFixtureAutoFakeItEasy with an early FakeItEasy candidate and found that many of the unit tests broke with output like X AutoFixtureAutoFakeItEasyUnitTestFixtureIntegrationTestWithConfigureMembersGetOnlyPropertiesReturnValueFromFixture ms Error Message SystemMissingMethodException Method SetReturnValue cannot be found on FakeItEasyCreationCastleDynamicProxyCastleInvocationCallAdapter Stack Trace at AutoFixtureAutoFakeItEasyFakeObjectCallInvokeWrappedMethodString methodName Object parameters in D Sandbox AutoFixture src AutoFakeItEasy FakeObjectCallcsline at AutoFixtureAutoFakeItEasyMethodCallResultApplyToCallFakeObjectCall fakeObjectCall in D Sandbox AutoFixture src AutoFakeItEasy MethodCallResultcsline at FakeItEasyCoreFakeManagerApplyBestRuleIInterceptedFakeObjectCall fakeObjectCall in C projects fakeiteasy src FakeItEasy Core FakeManagercsline at FakeItEasyCoreFakeManagerFakeItEasyCoreIFakeCallProcessorProcessInterceptedFakeObjectCall fakeObjectCall in C projects fakeiteasy src FakeItEasy Core FakeManagercsline at CastleDynamicProxyAbstractInvocationProceed at CastleProxiesObjectProxy getGetOnlyProperty at AutoFixtureAutoFakeItEasyUnitTestFixtureIntegrationTestWithConfigureMembersGetOnlyPropertiesReturnValueFromFixture in D Sandbox AutoFixture src AutoFakeItEasyUnitTest FixtureIntegrationTestcsline In FakeItEasy wed removed the publiclyvisible SetReturnValue member on the internal class CastleInvocationCallAdapter in the release as part of leaving only the explicitlyimplemented interface member I propose partly based on my own reasoning and on comments thomaslevesque made in FakeItEasyFakeItEasy that we work around the problem in FakedObjectCall This would mean that recent AutoFixtureAutoFakeItEasys will work with all FakeItEasys and the next AutoFakeItEasy released would work with all FakeItEasys Specifically we should look methods and properties on interfaces implemented by the type of the object passed to FakedObjectCall in addition to directly on the type PR forthcoming While I totally agree that value types without nondefault constructors are almost always mutable value types there is a corner case when I design a Unit type So maybe we should not must use SupportMutableValueTypesCustomization when there are no properties or fields in the struct Hi Im trying to use MockHttp with AutoFixtures AutoData attribute To test the library Ive created a test repo that contains only two tests csharp public class Tests Test CustomAutoData public async Task BasictestUri testUri string result var handler new MockHttpMessageHandler var sut new TestServicehandlerToHttpClient handlerWhenHttpMethodGet testUriToStringRespondHttpStatusCodeOK new StringContentresult var actual await sutGetStringtestUri AssertThatactual IsEqualToresult Test CustomAutoData public async Task Testwithcustomautodata Frozen MockHttpMessageHandler handler TestService sut Uri testUri string result handlerWhenHttpMethodGet testUriToStringRespondHttpStatusCodeOK new StringContentresult var actual await sutGetStringtestUri AssertThatactual IsEqualToresult public static IFixture CreateFixture var fixture new Fixture fixtureCustomizeHttpCliento oFromFactoryMockHttpMessageHandler handler handlerToHttpClient return fixture This setup is not working as the second test fails due to a CancellationToken being on ThrowIfCancellationRequested Changing the customizations as follow makes the second test working Unfortunately this is not optimal because it makes the setup too dependent on the SUT constructor csharp public static IFixture CreateFixture var fixture new Fixture fixtureCustomizeHttpCliento oFromFactoryMockHttpMessageHandler handler handlerToHttpClient fixtureCustomizeTestServiceo oFromFactoryMockHttpMessageHandler handler var http handlerToHttpClient return new TestServicehttp return fixture This issue is mostly about a clarification about the chain I was expecting TestService default setup to require a HttpClient HttpClient use the provided customization based on FromFactory that requires a MockHttpMessageHandler MockHttpMessageHandler to be newed up using the default setup Thanks for your help I opened an issue on MockHttp here Hi If I try to use something like Range DoublePositiveInfinity ErrorMessage You must provide a budget value for CADS It throws an exception I want to create the base type data for the specified scope What should I do For example the following code csharp no object int afixturecreateintmin max string bfixturecreatestringminLength maxLength object FeedbackIn tt fixtureBuildFeedbackIn Witht tPlatformName minLength maxLength Create I didnt find any APIs If the library doesnt provide it I need to write my own extension method Can you tell me what interface or object to write based on package info AutoFixtureAutoNSubstitute AutoFixtureSeedExtensions env info net core UT xunit Another question How do you just ignore one of the property when creating object data Other property are automatically generated by AutoFixture 