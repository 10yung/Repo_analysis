Bumps handlebars from to details summaryChangelogsummary Sourced from handlebarss changelog v November th Bugfixes fix add noprototypebuiltins eslintrule and fix all occurences f f d fix add more properties required to be enumerable Chores Build fix use instead of c b f add chai and dirtychai and sinon for cleaner testassertions and spies deprecate old assertionmethods e e ba dad a Security The properties proto defineGetter defineSetter and lookupGetter have been added to the list of properties that must be enumerable If a property by that name is found and not enumerable on its parent it will silently evaluate to undefined This is done in both the compiled template and the lookuphelper This will prevent new RemoteCodeExecution exploits that have been published recently Compatibility notes Due to the securityfixes The semantics of the templates using proto defineGetter defineSetter and lookupGetter in the respect that those expression now return undefined rather than their actual value from the proto The semantics have not changed in cases where the properties are enumerable as in js proto some string The change may be breaking in that respect but we still only increase the patchversion because the incompatible usecases are not intended undocumented and far less important than fixing RemoteCodeExecution exploits on existing systems Commits v November th Bugfixes fix use Stringfield in lookup when checking for constructor d test add fluent API for testing Handlebars c ac c Compatibility notes no incompatibility are to be expected trtable truncated details details summaryCommitssummary c c b v c d Update release notes f f d fix add noprototypebuiltins eslintrule and fix all occurences fix add more properties required to be enumerable ba testchore add chaiexpect and sinon to runtimeenvironment dad test add sinon as global variable to eslint in the specs a test add sinonjs for spies deprecate current assertions e e chore add chai and dirtychai for better test assertions c b f fix use instead of de d v Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details I dont like React hooks I understand them and I understand the benefit in some situations but have you written an async componentDidMount type hook Its a mess with nested closures and ending with empty brackets useEffect async The intent of that is not clear at all compared to the very descriptive async componentWillMount One of the problems hooks solve is actually not a problem render props When composed I like this pattern better than hooks To sum up my rant I was curious about the state of this project It seems like the perfect solution I also use Unstated a simple library to share state between components It has a similar way of composing containers Including react as a dependency causes this module to break on certain environments when using react hooks This is because yarnnpm will resolve reactadopts version of react and any local react dependencies and include them both This will happen in some Jest testing environments as well This PR moves react to a peer dependency to avoid multiple versions of react existing in the same applicationenvironment Hello there Im using React Adopt in a GraphqlApollo website The code works great on almost every browser One exception happens with Chrome version Users that have this version cant navigate the site because in the browser console they get the following error message Uncaught TypeError undefined is not a function Clicking on the error I get to the following line in the code js if valuesesomeisValidRenderProp throw ErrorThe render props object mapper just accept valid elements as value I assume that this has to do something with the way I pass children to the queries used for the mapper object and this is one example js const productsQuery render type Query queryPRODUCTQUERY variables type render Query const mapper productsQuery Adopt mappermapper code Adopt Im still investigating the issue to see if it happens on other browsers as well currently using Hotjar to catch the error and Browser Stack to debug it but I can already tell you that most browsers and versions do not have any issue with the code Any helpsuggestion would be very much appreciated Apologies in advance if I didnt include enough details in the description please let me know what you need to see and Ill respond with it right away I would like to use React Adopt with Formik and Apollo Client I am getting initial form data in getUser but first time I am getting empty data object with loading flag and when the result came back from server loading flag turn to false and I get the result Using following snippet Formik always initialised with empty array because rendering Formik doesnt wait for loadingfalse js const Composed adopt getUser render Query queryCURRENTUSERPROFILEQUERY childrenrender updateUser render Mutation mutationCURRENTUSERUPDATEMUTATION childrenrender form render updateUser getUser Formik initialValues formDefaultValue getUserdatame childrenrender Without React Adopt my code looks like this js Query queryCURRENTUSERPROFILEQUERY loading error data if loading return Formik initialValues formDefaultValue datame How can I achieve it with React Adopt I tried to build the package locally yarn install yarn test both passes but yarn buildprod fails yarn buildprod yarn run v yarn run fix runs fix prettier srctstsx write srcindextesttsx ms srcindextsx ms tslint p yarn build compress libundler build ts sourcemap compress Cleaning old files Start compiling Compiling srcindextsx Error srcindextsx error TS Module hoistnonreactstatics resolves to a nonmodule entity and cannot be imported using this construct import as hoistNonReactStatic from hoistnonreactstatics error Command failed with exit code info Visit for documentation about this command error Command failed with exit code info Visit for documentation about this command Hi today I tried to use reactadopt on Codepen served via unpkg I used this link and got following error Uncaught ReferenceError exports is not defined It seems to me that umd bundle is broken but maybe I did miss something Consider the following code import as React from react import adopt Mapper MapProps from reactadopt import Mutation Query from reactapollo import MYQUERY MYMUTATION from graphqlqueries interface AdoptRenderProps myQuery string myMutation void interface AdoptProps render any export default class Search extends ReactComponent token string state token public render JSXElement const mapper MapperAdoptRenderProps AdoptProps myQuery render Query queryMYQUERYrenderQuery myMutation render Mutation mutationMYMUTATION mutation result render mutation result Mutation const mapProps MapPropsAdoptRenderProps myQuery myMutation myQuery myQuerydata myMutation myMutationmutation const Composed adoptmapper mapProps return Composed myQuery myMutation const token thisstate return form input typetext valuetoken onChangethishandleInputChange form Composed private handleInputChange e ReactChangeEventHTMLInputElement thissetState token etargetvalue Input field focus in lost immediately after I type a letter First thing I really like the API of this lib however Ive noticed that for every composed component adopts adds a discrete number of intermediary components that substantially increase the React tree depth js const Composed adopt one render One renderrender two render Two renderrender becomes Composed Adoptonetwo Adoptone Adopt one One two Two children This not only makes debugging the React tree harder but if you start using it extensively to create several dozens of combined components the tree simply explodes and you might start having performance problems too It would be great if adopt could do its magic in just one layer js Composed One Two children 