I cant get the Commands work for the CaseAppparse T method The compiler cant find the implicit Parser What am I missing import caseapp sealed trait DemoCommand case class First extends DemoCommand case class Second extends DemoCommand object MyApp extends App CaseAppparse DemoCommand List could not find implicit value for evidence parameter of type caseappcoreparserParser DemoCommand We need to access the default value of each arg of a CaseApp with version we used to do something like val caseApp CaseApp T for arg appparserargs argdefaultDescription In version M defaultDescription seems removed are there any alternative way to do that please If you run following example without providing any arguments app exits with zero exit code without helpusage scala sealed trait DemoCommand case class Firstfoo Int bar String extends DemoCommand case class Secondbaz Double extends DemoCommand object MyApp extends CommandApp DemoCommand def runcommand DemoCommand args RemainingArgs Unit scala case class Optionslength Option Int Some interval Option Int Some parallelRequests Option Int Some import caseapp val options CaseAppparse Options args This gives a compile time error No implicits found for parameter eveidence Parser Options img width altScreenshot at AM src With version it seems that defaultDescription are always set to None Here is a small example to reproduce the bug ArgiListNameiNoneNonefalsefalseintNone ArgsListNamesNoneNonefalsefalsestringNone ArgbListNamebNoneNonefalsetrueboolNone ArgliListNameliNoneNonefalsefalseintNone And it works with version M ArgiListNameiNoneNonefalsefalseintSome ArgsListNamesNoneNonefalsefalsestringSomedefaultt ArgbListNamebNoneNonefalsetrueboolSomefalse ArgliListNameliNoneNonefalsefalseintSomeList Hi Im trying to abstract over parsing arguments and preparing general class skeleton but this code does not compile and it shows implicits missing import caseapp import caseappcorehelpHelp case class Argumentsfoo Int bar String object MyApp extends AbstractApp Arguments run Arguments trait AbstractApp T extends App def run T Parser Help val parsedArgs CaseAppparse T args printlnparsedArgs How can I make this work Also where does those implicits come from when used in just a single file It seems that caseapp cant find annotations on commands When running the following command in sbt sbtcaseapproot testsJVMtestrunMain caseappdemoCommandAppTest help I expect to see Demo Usage democli options command commandoptions Available commands first second Type democli command help for help on an individual command Actual result Nonetype Usage nonetype options command commandoptions Available commands first second Type nonetype command help for help on an individual command I have the following common options scala case class CommonOptions prod Boolean false dry Boolean false Recurse slack SlackOptions with slack options defined with scala case class SlackOptions slackToken Option String slackChannel Option String I would like to be able to define my case class like this scala case class SlackOptions token Option String channel Option String But I want to keep context informations when I use command line sh slacktoken slackchannel It should be great to have one annotation PrefixRecurse or similar that uses the name used in parent in command line sh slacktoken slackchannel Maybe do you have some tricks to do that Using ExtraName is for the moment the best solution I found but I will have conflict If I have same keys in different context scala case class SlackOptions ExtraNameslacktoken token Option String ExtraNameslackchannel channel Option String It would be great if a bash autocompletion string could be generated from the options adt It could then be called by an sbt task that drops it in the target folder to be included by in a native packager In the Rust world Clap has this built in 