Starting issue Im new to all this xD As ASPNET Core and OWIN work directly with Task it seems worthwhile to try to leverage the TaskBuilderfs at least for the sake of some benchmarks to determine whether this provides a possible simplification to the codebase A first pass is likely to make things harder but I would hope to move in the direction of Giraffe with respect to supporting Taskonly were we to find that it performed better than async and equivalent to Hopac This would also help with should we choose to go that route Steps to reproduce Install FreyaTemplate using dotnet new i FreyaTemplate Generate a new Freya project using Kestrel and Hopac eg mkdir test cd test dotnet new freya n Test o srcTest f kestrel c hopac Run dotnet build srcTest dotnet srcTestbinDebugnetcoreapp Testdll to verify the project builds and runs by navigating to in a browser Download paketbootstrapperexe and rename to paketexe in the paket folder Run mono paketpaketexe convertfromnuget Run dotnet build srcTest dotnet srcTestbinDebugnetcoreapp Testdll to verify the project builds and runs but fails to return results by navigating to in a browser Actual Web app appears to run but returns no response Expected Following the same steps above without specifying the c option uses async and that converts to using paket successfully Known workarounds Dont use paket Essentially doing this and finding that adding the composition affects every request it takes a significant CPU hit response time going from ms to ms Tests indicate that its something in the composition itself as injecting the value into the freya state takes no time at all Sample code fsharp let owin OwinMidFunc OwinMidFuncofFreya Polyfillkestrel withLogger log apiPipeline appUseOwinfun p pInvoke owin Wondering if Im doing it wrong or maybe theres a way to optimize that away Jsonhome is a format for exposing available resources under an entry point domain This could be a useful utility to expose for type generators or REST clients It would need resource metadata from any machines I don t know whether this would be useful outside use of routermachines Should we drop OWIN in favor of the ASPNET types so that we could potentially improve performance and pick up more interop possibilities I don t have any specific things in mind and would love to know what others think When you browse code on GitHub to have a look how it works knowing custom operators is crucial to understand anything Could you describe them in ReadMe so that code can be understand How Swagger generation and versioning can be implemented in Freya as well as with Swashbuckle and ASPNET API Versioning which use MVC ApiExplorer in ASPNET Core As I previously mentioned in Ive had some issues getting to grips being inside outside Freya computations Particularly with regards to passing around partially applied functions that requires arguments from inside a Freya computation and thus themselves get wrapped in a Freya computation after I ended up creating the some custom operators again Btw I really wish F would support named operators rather than just symbolic ones would help readability a lot I do have a lot of holes in my functional vocabulary so I have no idea what to actually call these but here they are f let f v freya let f f return f v let f v freya let v v return f v The first operator will take a function wrapped in a Freya computation dereference it and apply the given argument returning the result wrapped in a Freya computation Example f open FreyaCoreOperators let myFunction with some args let myValueInAFreya freya return some stuff let myValueNotInAFreya some stuff let myPartiallyAppliedOne myFunction myValueInAFreya Above is now Freyaabc I want to add another arg partially applied let myPartiallyAppliedTwo myPartiallyAppliedOne myValueNotInAFreya Above is now Freyaab It is possible I have misunderstood something but adding the new operator helped me quite a bit The scenario for the other operator is a bit more weird I ended up creating it because using the standard map operator ended up giving med nested Freyas FreyaFreyat which I was not what I was looking for Example f let myFunctionNotInAFreya some arg let myFunctionReturningAFreyaWrappedFun freya return fun x xToString this gives me nested Freyas let normalMap myFunctionNotInAFreya myFunctionReturningAFreyaWrappedFun above gives FreyaFreyaab using my operator let asExpected myFunctionNotInAFreya myFunctionReturningAFreyaWrappedFun above gives Freyaabas expected This may or may not be something to include as part of the core operators I find myself combining different Freyabool computation quite frequently and I have made the following custom operators for myself f let Freyamap let Freyamap Might be useful to include as part of the standard operators 