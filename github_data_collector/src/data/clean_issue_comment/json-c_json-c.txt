I found one question about the LENDIRECTSTRINGDATArgerhards hawicz may be a little large and it results in that one jsonobject struct takes up more memory for example value int will cost is pointer length bytes memory additionally compared with no short string optimazation That violates the original intention for saving memory and increasing operating efficiency For verifing this idea I test the different LENDIRECTSTRINGDATA with nativejsonbenchmark The results confirmed this idea The parse memorybyte with setting len as is respectively The parse scenario is relatively fixed but does not affect the conclusion greatly The other properties have little changes bytes bytes bytes bytes in cmmmit log c f c rgerhards marked that This brings a bytes memory overhead but I consider that still useful because the memory allocator usually also has quite some overhead bytes for dyn alloced memory blocks In any case the max buffer size can be tweaked via define I dont understand the memory allocator well Should we consider this in short string optimization In my opinion the LENDIRECTSTRINGDATA should be set according to the data structure and using scenes For example the data structure decide that the length should be set as bytes in rapidjson However in jsonc I think the length could be set as The lengths pros and cons depend on the using scenes If json data have many number or short string bytes like name occupation it will waste many mamory if the json data have longer string bytes the length should be larger We should have a choice between may be not a suitable length In addition I find another Interesting parameter ARRAYLISTDEFAULTSIZE accidentally Same principle as above The value of default array size also depends on the using scenes Usually the array size is not large jsonc jsonc jsonc jsonc Maybe the LENDIRECTSTRINGDATAARRAYLISTDEFAULTSIZE set as will get a good memory performance A kind of followup to I have gimp crashing on startup because it links both libjsonglib so direct dependency and this library libjsoncso and both have jsonobjectgettype function radziecki objdump T usrlocalliblibjsoncso grep jsonobjectgettype g DF text d Base jsonobjectgettype radziecki objdump T usrlocalliblibjsonglib so grep jsonobjectgettype d g DF text b Base jsonobjectgettype Indeed both libraries are linked as shared ones radziecki ldd usrlocalbingimp grep json libjsonglib so usrlocalliblibjsonglib so x c libjsoncso usrlocalliblibjsoncso x e a libjsonglib comes as a direct dependency of GIMP and libjsonc is pulled in via GIMPs dependency on libmypaint which requires this library So I seem to getting a crash in the assertion Loading mypaint brush factory data Loading usrlocalsharemypaintdata brushesclassicblendpaintmyb Assertion failed jsonobjectgettypejso jsontypeobject function jsonobjectobjectaddex file jsonobjectc line Thread received signal SIGABRT Aborted x aea in thrkill from liblibcso gdb bt x aea in thrkill at liblibcso x ab in raise s at usrsrcliblibcgenraisec x a in abort at usrsrcliblibcstdlibabortc x b in assert funcoptimized out fileoptimized out lineoptimized out failedexproptimized out at usrsrcliblibcgenassertc x e fef in jsonobjectobjectaddex jso x c fcc key x d ff comment val x c fcc opts at jsonobjectc Sidestepping through the debugger confirms that jsonobjectgettype may get pulled from the other library gdb bt x d in rtldbindstart at usrsrclibexecrtldelfamd rtldstartS x ca d in jsonobjectgettype at usrlocalliblibjsonglib so x e fec in jsonobjectobjectaddex jso x c key x eb f comment val x c e opts at jsonobjectc We were extremely lucky if the return values from those functions from two libraries would match Not sure anything can be done in this project but I guess people may have unexpected crashes because of this plan validate utf string during parsing string Validate fuction has been added into macro PEEKCHARdest tok validate utf string before parse Fix Increased the test coverage of arraylistc from to Ive enhanced the code with adding uint functions in my local branch This uint type is needed for my project that needs to handling a full data value of a bit register from a hardware module I would like to share my enhancements What are the steps for me to do to make a pullrequest JC Some fixes that would be nicetohave nothing is broken but bit better I would like to propose enabling the fPIC CFLAGS CXXFLAGS option by default in the build system Ill try to explain why Jsonc appears to have some of the same symbol names in common with the jansson jsonglib and perhaps others See for details An application which depends on a shared library that in turn depends on libjsonc may experience occasional crashes if they require a different JSON library for their own needs The specific issue that Im facing is that ClamAVs libclamavso library must link statically with libjsonca in order to mitigate crashes in applications that depend on libclamavso However to link a shared object with a static library the static library must be built with fPIC or else youll get a build failure like this usrbinld usrlibgccx linuxgnu x linuxgnulibjsoncalinkhasho relocation RX PC against symbol stdoutGLIBC can not be used when making a shared object recompile with fPIC usrbinld final link failed Bad value collect error ld returned exit status I cant make static linking with libjsonc default in libclamavso unless the fPIC option is default because it will fail to compile for most people I would however prefer if Linux distributions do not provide a libclamavso to their users which may cause occasional crashes