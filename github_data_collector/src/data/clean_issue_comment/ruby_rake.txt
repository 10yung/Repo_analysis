When a test file path includes nonascii characters rake test task RakeTestTask fails with a message File does not exist testtargetfilename It seems the task cant find a file with nonascii path on Windows Summary page including a procedure for reproducing Rails version bundle exec rake test testsomewherefilerb t Invoke test firsttime Execute test Invoke testsingle firsttime Execute testsingle Running via Spring preloader in process invalid option t minitest options h help Display this help noplugins Bypass minitest plugin autoloading or set MTNOPLUGINS s seed SEED Sets random seed Also via env Eg SEEDn rake v verbose Verbose Show progress processing files n name PATTERN Filter run on regexp or string e exclude PATTERN Exclude regexp or string from run Known extensions pride p pride Pride Show your testing pride Hello First off I want to apologize Im not a ruby whiz but Ill try to document this the best I can I ran into the following error when trying to build a project after a minor code change whitespace padding trimmed NameError uninitialized constant ShouldaInstanceMethods constmissing at orgjrubyRubyModulejava classTestCase at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldaintegrationstestunitrb moduleUnit at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldaintegrationstestunitrb moduleTest at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldaintegrationstestunitrb main at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldaintegrationstestunitrb require at orgjrubyRubyKerneljava main at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldarb require at orgjrubyRubyKerneljava main at usrsharervmgemsjruby PROJECTNAMEgemsshoulda libshouldarb require at orgjrubyRubyKerneljava block in usrsharervmgemsjruby PROJECTNAMEgemsrake librakeraketestloaderrb at usrsharervmgemsjruby PROJECTNAMEgemsrake librakeraketestloaderrb select at orgjrubyRubyArrayjava main at usrsharervmgemsjruby PROJECTNAMEgemsrake librakeraketestloaderrb The code change was in a different section of the repository and not related so I immediately assumed it was breakage caused by a dependency resolution error I pulled up the logs for a previous successful build and compared and found the only difference was in rake diff successdeps failuredeps Using rake Fetching rake Installing rake cat failuredeps Resolving dependencies Fetching rake Installing rake other unchanged libraries Fetching shoulda Installing shoulda Fetching shouldacontext Installing shouldacontext Fetching shouldamatchers Installing shouldamatchers My gemfile calls gemspec my projectgemspec has these relevant pins GemSpecificationnew do s sadddevelopmentdependency rake Can unpin after upgrading to JRuby sadddevelopmentdependency shouldacontext sadddevelopmentdependency shouldamatchers end I was able to resolve the error and build successfully by pinning sadddevelopmentdependency rake Im crossposting here and on Shoulda with all the relevant info in the hopes that the root cause of the bug can be identified and fixed in future versions Let me know if theres any other info I should provide such as a simple PoC to replicate the error Hi Im a fan of Rake and love how it helps to ensure my Ruby projects build more reliably on different platforms One thing I am curious about with Rake is how to write tasks as soft assertions For example what syntax could I use so that a task tree called lint with several child linter shell commands allows the full linter suite to run in the event of any error codes and only reports the error code at the very end of the lint execution taskfoo rake foo wtfthisshouldnotwork on top of that the args argument that is returned to the block does not know about the extra arguments so I cant even add my own argumenterror if I wanted to I can make a PR to fix this just want consensus that that is desired behavior I need before and after hooks for all rake tasks task mybeforehook name environment do t args puts Rake task args name started end task myafterhook name environment do t args puts Rake task args name finished end task mytesttask environment do puts This is test task end Rakeapplicationtaskseach do tsk next if RakeTask mybeforehook RakeTask myafterhook includetsk tskenhance mybeforehook I cant send any params with such code tskenhance do RakeTask myafterhook invoketskname end end Is there any way to send params to prerequisite Its a known fact that ruby function defined in a namespace will be defined in a global scope rather than inside of a hermetized context So ruby function defined in one namespace will be visible in another and it may be unintentionally overridden It would be nice if namespace could be a context for ruby functions as well as rake tasks Given a Rakefile multitask default a b c d e task a target task b target task c target task d target task e target rule target source do t p tname tsource p tactions end file source the target may get executed multiple times like this ruby version ruby p revision x linuxmusl rake version rake version rake trace rules Invoke default firsttime Invoke a firsttime Attempting Rule target source Invoke b firsttime Attempting Rule target source Invoke c firsttime Attempting Rule target source Invoke d firsttime Attempting Rule target source target source EXIST Invoke e firsttime Attempting Rule target source target source EXIST target source EXIST Invoke target firsttime target source EXIST Invoke source firsttime target source EXIST Execute source Execute target target source Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile target source Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile target source Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile target source Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile target source Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Proc x e b c repoRakefile Execute d Invoke target Execute b Invoke target Execute a Invoke target Execute c Invoke target Execute e Execute default The results differ between runs It seems to happen more often with debug output The same action block gets added multiple times to the same task When aborting rake with CtrlC it outputs rake aborted then dumps a long backtrace This seems unnecessary as aborting isnt really an unexpected outcome of pressing CtrlC or sending an INT signal Id like to propose catching the Interrupt exception and exiting cleanly with an exit code of We can still print the backtrace if the trace option is used I can submit a pull request if this seems reasonable I have a usecase in which I need to run a task if and only if at least one of its prerequisite tasks either currently needs to run or needed to run at the time the prerequisite task was defined Here are some attempts at a RakeTask subclass ruby class MyTask RakeTask def needed prerequisitetasksany needed end end This approach does not work since at the time MyTaskneeded is called prerequisite tasks may have run and therefore return false for needed ruby class MyTask RakeTask def needed prerequisitetasksany p pneeded or palreadyinvoked end end This also doesnt work since alreadyinvoked can return true even if the tasks execute method was never called ruby alreadyinvoked true invokeprerequisitestaskargs newchain executetaskargs if needed What ended up working was ruby class MyTask RakeTask def initialize needed false super end def enhance supertap needed prerequisitetasksany needed end def needed needed end end But that just feels wrong Is there something Im missing here Id be more than happy to open a PR implementing what Im looking for maybe an alreadyexecuted method if this functionality doesnt already exist Thanks