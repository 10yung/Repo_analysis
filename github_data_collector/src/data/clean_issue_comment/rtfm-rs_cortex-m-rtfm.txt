 Mainly for use with task callbacks see Following up from the discussion on matrix about the stability of the resources module generated by the app macro what would be the implications of making the app generated resources public Issue that provoked this question Maxtrix discussion japaric so no you cant avoid the generic type in a generic enum or struct but its OK to use the resourcesResourceName type japaric RTFM guarantees that its a stable type name path cc japaric When adding a comment to the app macro as such rust Some text this causes the error appdevice stm f xxhalstm peripherals true const APP init fn initcx initContext Gives the error error expected const error aborting due to previous error I see from that right now you deliberately cant bind to HardFault for soundedness reasons However it would be really useful to have access to Resources during fault handling to force a system into a safe state or emit some terminal diagnostics Right now I instead have to have a separate HardFault handler which uses unsafe access to peripherals directly which is also inconvenient for HALs Is there anything to be done here Or is the fact that the HardFault can occur in the middle of any other task enough to make it always unsound even though its itself divergent The issue Coming from an FreeRTOS background I am used to being able to pass Queue and task handles around such that none of the tasks need to know of the other tasks existance Id like to be able to do the same thing with RTFM An example scenario A Task offloads a HttpRequest to the HttpClient task by enqueing the request onto a queue that the HttpClient Task is listening to The client performs the request but how does it pass the result back The result could be a simple message to say it completed or it could actually have data to return One option is having a queue on the Callee task that the client task can push the result onto but how do we communicate to the client task which queue to send it back to I dont really have any strong thoughts on how to solve this bar hardcoding values which I am doing currently Im guessing there would be some sort of tagging system such that a tag or handle can resolve to a resource in a safe way make book point to the latest release x move repos from japaric to rtfmrs x add CONTRIBUTINGmd to this repo indicating that the rfcs repo is for RFCs and new features should be discussed there before opening a PR here x rtfmrs README needs updating x the README in this repo and thus the book should point to the rfcs repository x the README in this repo and thus the book should point to the matrix channel add issue template indicating that this repo is for bug reports and that features should be discussed in the rfcs repository x get ghpages working again japaric x update Cargotoml metadata in all repos to point to rtfmrs URLs x migrate feature related issues from this repo to the rfcs repo the API semantics are specified in RFCs in and and were implemented in but we are still missing user level documentation This adds Instantwrappingdurationsince for the case that some result is desired but the overhead of managing overflows is too big Especially when handling it seems as complicated as adding bit support to Instant I also added a wrappingelapsed but one could argue that elapsed has a bug and should be replaced with the wrapping version rust pseudocodeish init blocku maxvalue cycles let t Instantnew t i minvalue blocku maxvalue cycles t elapsed Instantnew t t t overflow panic in debug build While writing this i had an idea how to implement a bit timer rust struct BigInstantu static mut lasttick Instant Insantnew static mut totalticks BigInstant BigInstantnew this must be executed before Instant overflows fn BigInstanttick let now Instantnew totalticks nowwrappingsublasttick lasttick now fn BigInstantnow BigInstant totalticks Instantnewwrappingsublasttick while this snippet ignored atomicitylocking the general idea should be workable and avoids the need for a max priority interrupt to increment the high bits on overflow 