Its currently not possible to make custom scalars typesafe since the generated type for fields with a custom scalar type is any an example of this can be seen here Im not sure if this is simply a bug or if the feature hasnt been implemented yet Since prisma does not yet support JSONB columns Im storing my JSON data in Posgres as a string This is fine but Id like to return JSON to my consumers How can I change the return type of a string field to an object in my graphql schema The example below returns this error message String cannot represent value I think I need to tell GraphQL that the field metadata actually returns an object now js tfieldmetadata type String resolveroot args ctx const str root metadata if str return return JSONparsestr Im relatively new to GraphQL and prisma so any help is appreciated Thanks The field authorize plugin is executing authorization on publish rather than on subscribe like on beta versions Expected behavior Authorization should fail on subscribe Actual behavior Subscription fires and only fails if a publish happens Reproduction example here Given the following Nexus object definitions I am able to execute the createMessage mutation without issue typests js export const Mutation mutationType definitiont tfieldcreateMessage type Message args text stringArg resolve r args context i return id messageId text argstext author id authorId name mark export const Message objectType name Message definitiont tfieldid type String tfieldtext type String tfieldauthor type Author nullable true export const Author objectType name Author definitiont tstringid tstringname Screen Shot at PM However if I add a Prisma model backing the Message type the createMessage resolver expects to return an object containing all of the Prisma fields even if that field has not been exposed by the Nexus object schemaprisma prisma model Message id String defaultcuid id messageType String text String author Author Screen Shot at PM Should the resolver return type match the Nexus object definition instead of the Prisma model definition I dont understand why it isnt possible to let object types take a second type parameter that specifies the backing type ie objectTypeFoo Foo Additionally why cant makeSchema become makeSchemaContext I feel as though nexus is reimplementing quite a lot of typelevel logic to support the sources approach when a generic might suffice This is in any case the approach of this module Im running into the same error as however since thats closed Im opening a new issue for visibility Im throwing a type error using the SDL converter I input graphql type CreateDurationUnit DurationUnit DurationUnit input CreateDurationUnitInput durationUnit String sortorder Int type DurationUnit id ID durationUnit String sortorder Int type Mutation CreateDurationUnitinput CreateDurationUnitInput CreateDurationUnit And get back typescript import objectType arg inputObjectType scalarType from nexus const CreateDurationUnit objectType name CreateDurationUnit definitiont tfieldDurationUnit type DurationUnit nullable true const DurationUnit objectType name DurationUnit definitiont tidid tstringdurationUnit nullable true tintsortorder nullable true const Mutation objectType name Mutation definitiont tfieldCreateDurationUnit type CreateDurationUnit nullable true args input arg type CreateDurationUnitInput required true const CreateDurationUnitInput inputObjectType name CreateDurationUnitInput definitiont tstringdurationUnit tintsortorder Which has the error of Screen Shot at packagejson json name script license MIT scripts build yarn run clean yarn run generate tsc clean rm rf dist devgraphql tsnodedev nonotify respawn transpileOnly srcserver devprisma prisma dev generate yarn run generateprisma yarn run generatenexus generatenexus tsnode transpileonly srcschema generateprisma prisma generate postinstall yarn run generate seed tsnode prismaseed start node distserver dependencies prismaphoton preview graphql graphqlyoga nexus rc nexusprisma devDependencies prismasdk typesnode prettier prisma preview tsnode tsnodedev pre typescript tsconfigjson json compilerOptions sourceMap true outDir dist strict true lib esnext esModuleInterop true include src Ive tried running my postinstall script to generate new types but that doesnt fix it Currently my Apollo server runs with the schemafirst approach I want to migrate to the Nexus step by step so that both have to run in parallel for a while This is a follow up to which doesnt seem to be resolved After removing transpilyOnly from my startup script I started getting these errors using tdateTimebirthDate return new TSErrordiagnosticText diagnosticCodes TSError Unable to compile TypeScript srcschemaWorkermutationscreateWorkerts error TS Property dateTime does not exist on type InputDefinitionBlockcreateWorkerInput tdateTimebirthDate using tfieldbirthDate type DateTime return new TSErrordiagnosticText diagnosticCodes TSError Unable to compile TypeScript srcschemaWorkermutationscreateWorkerts error TS Type GraphQLScalarType is not assignable to type string NexusInputObjectTypeDefstring NexusEnumTypeDefstring NexusScalarTypeDefstring Type GraphQLScalarType is missing the following properties from type NexusScalarTypeDefstring config value tfieldbirthDate type DateTime nodemodulesnexusdistdefinitionsdefinitionBlocksdts type AllInputTypes AllNexusInputTypeDefsstring The expected type comes from property type which is declared here on type NexusInputFieldConfigcreateWorkerInput birthDate Ive read other issues talking about how this is a chicken and the egg problem but my types are generated ts declare global interface NexusGenCustomInputMethodsTypeName extends string dateTimeFieldName extends stringfieldName FieldName opts coreScalarInputFieldConfigcoreGetGen inputTypes TypeName FieldName void DateTime declare global interface NexusGenCustomOutputMethodsTypeName extends string dateTimeFieldName extends stringfieldName FieldName opts coreScalarOutSpreadTypeName FieldName void DateTime export type NexusGenScalarNames Boolean DateTime Float ID Int String The only way to make it work is to pass a string to type ts tfieldbirthDate type DateTime Lately Ive been iterating on better ways to test what I call native GraphQL implementations with this I mean a GraphQL backend implementation that isnt just wrapping existing services but instead if built directly on top of GraphQL and thus resolvers that contain up to certain level of logic Ive been going back and forth between code first and schema first approaches one of the main benefits that Ive noticed lately with schema first approaches is that testing logic inside a resolver is insanely simple This is because the resolvers are usually just a simple object of plain old functions This makes them very testable in isolation However going to a code first approach this actually becomes more tedious especially in nexuss case the resolve is part of a config that is warpped in several function calls so that nexus can do its magic but this makes testing a single resolver to be more tedious Ive found that I have to resort to the following workarounds to test them I create the entire schema in my test suite and perform a query against the field I wish to test its resolver for This is quite tedious because I have to spin up a lot of boilerplate just to test a single function I define my resolver separately and attach it in the resolve config This is the better solution but it requires me to always find a good place andor name to put them somewhere I feel like this solution is the better one out of the two but I would prefer to not repeat myself and just create the resolve inline with the type definition it keeps everything colocated nicely and gives all the context at once which is one of the benefits for codefirst approaches imho This got me thinking if it would be possible to create some sort of extra API in nexus allowing the access to a field definition without letting it pass through the internals of nexus The resolve function still remains a simple inline function so Im wondering how hard it could be to just expose it out in some form that doesnt require a makeSchema invocation I was thinking something along the lines of typescript export const UserType objectType name User definitiont tidid tlistfieldposts type Post resolve user args context info getPosts UserTypegetFieldDefinitionpostsresolve resolve being the function here which I can directly invoke This would open up the nexus types to be a lot more testable without ceremony Thoughts I cant understand the documentation about sources doc Automatically finds any interfacetypeclass named similarly to the and infers it the source type of that resolver I think there is an issue in the sentence And what does the source and alias fields