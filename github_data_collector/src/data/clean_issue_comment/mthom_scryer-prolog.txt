Scryer Prolog is now very close to supporting CLP The remaining issues that need to be resolved before I can create a pull request are Goal expansion must work for The most worrying is I need to find out why this fails and it is hard to tell how complex this is and how long it will take I am working on it To debug I need a reliable toplevel that correctly tells us all residual goals This is Algorithms devised by Prof JeanCharles R gin have been a huge motivation for my work in the area of constraints and I would like to spell his name correctly in the CLP source code This is Support for the discontiguous directive would be useful to keep logically connected definitions together in the source file Mark thank you for all the work you have already put in to get this close Please focus on the more urgent things such as and other discussed issues and I am looking forward to filing a pull request that provides CLP for Scryer Prolog as soon as everything above works With clpz pl from and the following program pre usemoduleclpz usemodulelibrarylists tasksTasks Starts End Tasks task maplisttaskstart Tasks Starts Starts ins cumulativeTasks limit foldlmaxend Tasks End taskstarttaskStart Start maxendtaskEnd E E E maxE End pre I get pre b tasksTasks Starts End labelStartsb false pre This is incorrect The following more specific query shows that there is a solution pre b Starts tasksTasks Starts End labelStartsb End Starts Tasks task EndEnd false pre I will try to find a smaller test case that exhibits this issue Here are several interrelated issues resulting from the desire to correctly show residual goals on the toplevel Starting with clpz pl from and the following program pre usemoduleclpz puzzle SEND MORE MONEY Vars SENDMORY Vars ins alldifferentVars S E N D M O R E M O N E Y M S pre I get pre b puzzlePsb Ps false pre However these variables are involved in constraints and I therefore expect to see residual constraints I can obtain them as a list Gs of goals with copyterm pre puzzlePs copytermPs Copy Gs pre In this example Copy is a fresh copy of the term Ps and I therefore expect the following query to succeed although it currently unexpectedly fails pre b puzzlePs copytermPs Copy Gs Ps Copyb false pre In particular the following should succeed and the toplevel should use this to obtain the list Gs of residual goals pre b puzzlePs copytermPs Ps Gsb pre Currently it unexpectedly fails and the toplevel does not show the residual goals at all After this query has failed the earlier query suddenly yields much more output and the output also contains terms that are not residual goals such as pre b puzzlePs copytermPs Copy Gsb clpz u pre Please see for a crash that is also related to this not the expected codeX Ycode or alternatively codeY Xcode The binding appears to be present as shown by the following snippet pre X Y X X Y pre This is for a later moment after is done For UTF files not containing a zerobyte the majority of files to be parsed phrasefromfilePhrase File could avoid incremental copying altogether using mmap The file is mapped at once into a fitting memory area of the heap up to the last page which is written anew with a terminating zerobyte and a nil at the end With clpz pl from I get pre b alldistinct XYZ XY ins b caught errorexistenceerrorproceduregetattr getattr pre However getattr is subject to goal expansion and should not occur anywhere as a goal It should be possible to apply asyncawait execution Initially at least to the simple case of mutually independent conjunctive subgoals For example with clpz pl from I get pre b usemodulelibrarydcgsb true b phraseclpzcisgoalsX Y Lsb caught errorexistenceerrorprocedure call pre Expected X Y Ls Would be great if Scryer can call libraries written in Rust For example with the following definitions pre fa ga fb pre I get pre b fXb X b pre whereas I would also like to get X a as a solution To support discontiguous clauses the standard prescribes the discontiguous directive pre b discontiguous b A directive discontiguousPI where PI is a predicate indicator a predicate indicator sequence or a predicate indicator list specifies that each userdefined procedure indicated by PI may be defined by clauses which are not consecutive readterms of the Prolog text All the clauses for a userdefined procedure P shall be consecutive readterms of a single Prolog text unless there is a directive discontiguousUP directive indicating P in that Prolog text pre Discontiguous predicate definitions are useful for example to put the definitions of different types of goalexpansion at separate positions in source files so that they are logically grouped with related predicates