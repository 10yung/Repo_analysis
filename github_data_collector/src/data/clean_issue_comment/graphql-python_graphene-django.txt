Hi all Ive seen but still have a question about how to add a custom argument thatd enable a more complex filter on a DjangoObjectType Using graphenedjango python class ThingNodeDjangoObjectType class Meta model Thing interfaces graphenerelayNode classmethod def getquerysetcls queryset info How do I access mycustomparam here to enable a custom filter if mycustomparam Heavily modify the queryset here with filter exclude querysetfilterfilterexclude else Something else querysetfilterfilter return queryset class QuerygrapheneObjectType things DjangoFilterConnectionFieldThingNode mycustomparamgrapheneBoolean graphenedjangodebugsqltrackingpy RemovedInDjango Warning forcetext is deprecated in favor of forcestr return s forcetextelementreplace Get rid of more deprecated function calls see which are spamming into my test suite warnings Hi Im struggling to write a mutation that does the following createsupdate a model createsupdates related models In short when I send the following mutation graphql mutation MyMutation createTeam input name Avengers players firstName Iron lastName Man firstName Captain lastName America id I expect to see team and players created Instead I see team created players created I have the following models and DRF serialisers py modelspy from djangodb import models class TeammodelsModel name modelsCharFieldmaxlength class PlayermodelsModel firstname modelsCharFieldmaxlength lastname modelsCharFieldmaxlength team modelsForeignKeyTeam relatednameteam ondeletemodelsCASCADE serializerspy from restframework import serializers from models import Payer Team class PlayerSerializerserializersModelSerializer class Meta model Player fields id firstname lastname team class TeamSerializerserializersModelSerializer players PlayerSerializermanyTrue readonlyTrue class Meta model Team fields id name players I used the DRF serializers to create my createTeam mutation python types class TeamTypeDjangoObjectType class Meta model Team class PlayerTypeDjangoObjectType class Meta model Player mutations class TeamMutationSerializerMutation class Meta serializerclass TeamSerializer modeloperations create update lookupfield id class PlayerMutationSerializerMutation class Meta serializerclass PlayerSerializer modeloperations create update lookupfield id class MutationgrapheneObjectType createteam TeamMutationField createplayer PlayerMutationField What am I not doing right Sorry for the long post Thank you A workaround for Appropriately DjangoObjectType supports a convertchoicestoenum which disables the creation of GraphQL Enum types for every ChoiceField on a model However SerializerMutation similarly a subclass of ObjectType and registered in the GQL schema does not support such a flag and forces creating an Enum for every ChoiceField This behavior can be undesirable because it can trigger a duplicate type registration error Found different types with the same name in the schema For consistencys sake a flag to disable the Enum creation should be added to the SerializerMutation this commit implements such changes Sidenote In my sandbox this error actually triggered even when the ChoiceField was only registered one single time on one single Mutation and not at all present in the DjangoObjectType which leads me to believe that the SerializerMutations Enum definition is colliding with itself Theres actually test coverage for the current existing behavior of creating Enums for SerializerMutation because none of these tests actually implement any Model with a ChoicesField the test coverage stops at ensuring the automatic type conversion returns a proper value and I added a second test for my branching logic I hesitate to suggest it but it seems that in the current implementation of Enums in SerializerMutations simply adding a SerializerMutation with any ChoicesField to a schema might be enough to throw the error I might have time to dig deeper into that but for now heres an effective and reasonable bandaid Related issue GraphiQL by default does not implement a way to pass custom request headers which are still fairly commonly used for example by authentication middleware It would be nice if graphenedjangos builtin GraphiQL view had support for doing authenticated requests with custom HTTP headers Apologies if this is a duplicate If you have an abstract model with a foreign key to self the type of the resulting graphql field in a subclass is always the type of the first one in the schema I think this might be because the django fields hash to the same value so subclasses fields use the existing graphene field in the registry Here is a minimum reproduction of the issue python class AModel class Meta abstract True foreign ForeignKeyself ondeleteCASCADE class BA pass class CA pass class BNodegraphenedjangoDjangoObjectType class Meta model B class CNodegraphenedjangoDjangoObjectType class Meta model C class SchemagrapheneObjectType b grapheneFieldBNode c grapheneFieldCNode And here is an excerpt of the resulting schema note that CNodes foreign field has the type BNode json fields args deprecationReason null description isDeprecated false name foreign type kind NONNULL name null ofType kind OBJECT name BNode ofType null kind OBJECT name CNode The current workaround is something like this python class CNodegraphenedjangoDjangoObjectType class Meta model C foreign grapheneFieldwhateverthismoduleisCNode The restframework offers the ability to use SerializerMethodFields which I also wanted to use in my project together with graphenedjango but this field gets the wrong return value A detailed description can be found here This is my copied comment from which explains the change After further investigation I found the origin of the underlying problem Digging to the method graphenedjangorestframeworkmutationpySerializerMutationperformmutate and applying this modification python from restframework import serializers modified classmethod def performmutatecls serializer info obj serializersave kwargs for f field in serializerfieldsitems if not fieldwriteonly if isinstancefield serializersSerializerMethodField modified kwargs f fieldtorepresentationobj modified else modified kwargs f fieldgetattributeobj return clserrorsNone kwargs it worked The issue is at fieldgetattributeob Inspecting the SerializerMethodField inside of the restframework you can see that there is no getattribute function instead it will use the getattribute from the base class Field which I think not really traced it completely just returns the representation of the obj In my case this is the user object and it will return the users username because str is overridden to do so So I was interested in how the djangorestframework handles the getattribute issue And I have found out that there is a method called torepresentation ON the Serializer class which indeed returns all field names and also the correct values for each field python OrderedDict password f username johndoe email johndoefcom token eyJ eXAiOiJKV QiLCJhbGciOiJIUzI NiJ eyJ c VybmFtZSI ImdkZGRkZHNzZHNkc Nkc Nzc Rhc Nkc RkZGRkcyIsImV cCI MTU NzUxNjc Miwib JpZ lhdCI MTU NzUxNjQ Mn fdiAgROOyqlV S R mbV DImp YqONNVix i sCrs And I am curious why the serializertorepresentation was not used and instead the loop over each field Maybe I will get it after I am using this modification Using the mentioned method above the function could be reduced to python classmethod def performmutatecls serializer info obj serializersave kwargs serializertorepresentationobj return clserrorsNone kwargs Which I will now use as a workaround Any feedback is appreciated I upgraded Django and graphene django but when I make a request I get this error Could not import fieldrecordsschemaschema for Graphene setting SCHEMA ImportError cannot import name six I know this has been submitted a million times and I know there are several solutions BUT despite all things it seems there still isnt a way to actually know where the duplicates come from eg The error message would read AssertionError Found different types with the same name in the schema status status But that doesnt give much information as to where do they come from This is specially frustrating when plugging in projects A suggestion would be to print the canonical name of the class the type is based on something like mymoduletypesProblematicType Anyway this issue arises specifically because I defined a Type based on an Enum on my types module and Im using that everywhere but still graphql complains about different types having the same name I double checked and I dont even use that name anywhere in my project so it must be a conflicting dependency but which one where is that type being defined The only way to know would be unplugging all dependencies and start plugging them one by one to find the offenders but this would be so inefficient and frankly very stupid in case you wonder I also searched in my sitepackages and found nothing so it must be auto generated somewhere Im using these packages django graphenedjango graphene And my types worked just fine with these versions django graphenedjango graphene 