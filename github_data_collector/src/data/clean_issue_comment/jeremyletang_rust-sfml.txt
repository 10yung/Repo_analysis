Borrowing the texture for its entire lifetime renders this method unusable It means the texture can not be updated anymore Even if the texture is created just for the call it can not be discarded anymore because borrow might be used here when shader is dropped and runs the Drop code for type sfmlgraphicsShader Thus the shader needs to be recompiled for every texture update which is not acceptable Hello How do you look about mp support in your project maybe optional feature I know that mp is not officially supported in the sfml project Discussion Possible implementation If I use C I take this implementation But I do not understand what to do if I use rust Id like to know What prevents RcSprite from being published in a new version of rustsfml Ive been struggling for two days over storing a Texture and a Sprite side by side and I think RcSprite is what I need to not go insane in developing using rustsfml Is it safe to copy the implementation of the branch rcsprite in my code or is it still an incomplete prototype What could I do to help develop this feature Since chaining multiple calls to Transformcombine is inconvenient imho the usability of Transform would benefit from having the Mul trait implemented Im guessing the implementation would go something like this rust impl Mul for Transform type Output Transform fn mulmut self rhs Transform Transform selfcombine rhs self However being relatively new to Rust I dont know if there are any caveats preventing this implementation from working correctly Once a release with lands Im running into an issue when loading textures from a thread that Texture isnt Send Is this on purpose or is it possible to make it Send I am unsure how to implement a custom entity using VertexArray and Texture for a tilemap as per the SFML docs but am unable to find an appropriate example My custom entity owns its VertextArray and borrows the Texture from the outer Resources container however when RenderStates borrows the reference the lifetime requirements conflict rust pub struct CustomEntitys array VertexArray texture s Texture impls Drawable for CustomEntitys fn drawa shader texture shader shadertexture a self rendertarget mut RenderTarget states RenderStatestexture shader shadertexture statestexture Some selftexture rendertargetdrawwithrenderstates selfarray states Obviously this wont work because the lifetimes s and texture are distinct error E cannot infer an appropriate lifetime for lifetime parameter in function call due to conflicting requirements statestexture Some selftexture What would the appropriate usage then be Image might be one such type so you could load images on a separate thread and send them to the main thread While attempting to setup a threaded renderinput system I ran across the following rust extern crate sfml extern crate crossbeam use sfmlwindowContextSettings Style Event Key use sfmlgraphicsRenderWindow fn inputscope crossbeamScope mut window RenderWindow while let Someevent windowwaitevent println event match event EventClosed EventKeyPressed code KeyEscape break fn main let mut mainwindow RenderWindownew Test window StyleCLOSE ContextSettings Defaultdefault crossbeamscopescope inputscope mainwindow mainwindowdisplay Which gives the rustc error shell error E use of moved value mainwindow srcmainrs crossbeamscopescope value moved into closure here mainwindowdisplay value used here after move note move occurs because mainwindow has type sfmlgraphicsRenderWindow which does not implement the Copy trait Can you suggest how I could get access to the window for both rendering and input processing I tried Arcnewmainwindow and its giving me the same issue Im using rustsfml and Id like to encapsulate all my rendering into a Renderer struct that has methods like handleevents draw etc so none of the rest of my code needs to worry about rendering shows a minimal example of the issue Im running into Id like the Renderer to do all its resource acquisition on construction but if I create a Font inside new it doesnt live long enough Id like to create it on the heap and give Text an RcFont but Text as currently implemented doesnt support that As it is I can pass a Font into the constructor but that just moves the problem up one level the Renderer cant live outside of the enclosing function Anyway I dont know what the best solution is but that is my use case