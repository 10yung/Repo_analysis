 Bundle See See Note The JIRA lacks QE ACK See The XLS attached to the JIRA now converts correctly and the User can view source Part of an ensemble In SpringBoot application classes and resources are placed into BOOTINFclasses subfolder of the assembled JAR file That is why fileName see updated code starts with BOOTINFclasses folder name And templategetDtable taken from kmodulexml does not contain BOOTINFclasses prefix For this reason ifcondition is changed to fileNameendsWith templategetDtable it will work both for SpringBoot and nonSpringBoot application As well to get a template resource a full path with BOOTINFclasses root subfolder should be specified That is why original code getResource templategetTemplate will not work for SpringBoot application Because of this this code was replaced by getResource fileNamereplacetemplategetDtable templategetTemplate New code will work no matter which root folder is used inside JAR file in SpringBoot application it will always prepend templategetTemplate value with BOOTINFclasses subfolder When a table with any hit policy and multiple output gets executed a RuntimeException is thrown Report the error with HitPolicyViolationEvent as is done for the unique hit policy is a possible a better way The result of the present thrown get swallowed and doesnt return a valuable error for the user add RuleUnitDescription createRuleUnitDescription KiePackage pkg String ruleUnitSimpleName implementation should be a noop because it is only used in Kogito requires API change materialized Lambda during incremental compilation Unit Test only now This is a draft PR to share my idea Please let me know your thoughts Basically it writes BitMask variables into the materialized LambdaConsequence as private final fields so execute method can access them It passed all droolsmodel unit tests but I found that it fails with IncrementalCompilationCepTesttestIncrementalCompilationWithNewEvent in droolstestcoveragetestcompilerintegration The failure is caused by duplication of LambdaConsequence class name during incremental compilation I will look into it further One more point from code design aspect I added ListVariableDeclarator bitMaskVariables to MaterializedLambda Actually bitMaskVariables is required only by MaterializedLambdaConsequence But if I add ListVariableDeclarator bitMaskVariables to MaterializedLambdaConsequence I would need more refactoring eg MaterializedLambdacreate and ExecModelLambdaPostProcessorextractLambdaFromMethodCall If you think its worth refactoring please let me know Thanks 