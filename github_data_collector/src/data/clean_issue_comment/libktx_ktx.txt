Hi I think that there are touchdowntouchup extensions missing in the actor ktx extensions or maybe that is on purpose What I am missing is a way to define a touchDown and touchUp callback for buttons where I want to react when they get pressed and released Eg when you press the JUMP button the player should jump but when you release it he should cancel the jump and fall down again Click and Change did not work for me because click seems to only react when releasing the button and change only reacts on changes which means the first press is a trigger because the button gets checked releasing will not trigger anything and the next press will trigger it again What worked for me is the touchDown and touchUp events of the ClickListener The extension could look like this kotlin inline fun ActoronTouch crossinline touchDownListener Unit crossinline touchUpListener Unit ClickListener val clickListener object ClickListener override fun touchDownevent InputEvent x Float y Float pointer Int button Int Boolean touchDownListener return true override fun touchUpevent InputEvent x Float y Float pointer Int button Int touchUpListener thisaddListenerclickListener return clickListener It could then be used like this kotlin actoronTouch touchDownListener thisgameEventManagerdispatchInputKeyPressEventKeyJUMP touchUpListener thisgameEventManagerdispatchInputKeyReleaseEventKeyJUMP Would this be useful or do you suggest a different approach for such a usecase GitHub release Maven Central upload Range randoms x Tiled extensions The next release will include a new module ktxtiled with Tiled API extensions I make a lot of fromscratch particle effects for my live wallpapers so Im not limited by the GDX particle editors features and have found Kotlin ranges to be very helpful for very quickly tweaking values I think this could be helpful anywhere you have something that spawns something in a game whether its a particle or enemy Or for any procedural generator So I made some functions that make it even faster to tweak ranges Operator functions that let you add or multiply constants by the endpoints of the range Or defining a range by a center and tolerance And then functions that return a random value from within the range For example heres a simple version of something Ive been working on Kotlin class ParticleLayer val xStart ClosedRangeFloat val yStart ClosedRangeFloat val size ClosedRangeFloat private val particles GdxArrayParticle fun update delta Float Updates particles and spawns them when necessary private fun spawnParticle val particle particlePoolobtain initializexStartrandom yStartrandom sizerandomGaussian particlesaddparticle I have multiple layers of particles and the ones in the foreground and background are bigger to look out of focus and move faster but Im omitting that for the example So I first made one particle layer As I tweak the values instead of continually typing in new ranges I can shift them around easily by adding a value Kotlin val layers listOf ParticleLayerxStart f f f My particles needed to have their center shifted to look good yStart f f size f f And after getting that looking good I can copypaste to get a new layer and then tweak the size range with simple multiplication Kotlin val layers listOf ParticleLayerxStart f f f yStart f f size f f ParticleLayerxStart f f f yStart f f size f f f Here are the functions I have in my personal library so far Kotlin fun ClosedRangeIntrandom MathUtilsrandomendInclusive start start infix fun Intamidtolerance Int this tolerancethis tolerance fun ClosedRangeFloatrandom MathUtilsrandom endInclusive start start fun ClosedRangeFloatrandomGaussian comcyphercoveaudioglowcorerandomGaussian endInclusive start start fun ClosedRangeFloatrandomTriangular MathUtilsrandomTriangularstart endInclusive fun ClosedRangeFloatrandomTriangularnormalizedMode Float MathUtilsrandomTriangularstart endInclusive normalizedMode endInclusive start start operator fun ClosedRangeFloattimesmultiplier Float start multiplierendInclusive multiplier operator fun ClosedRangeFloattimesmultiplier Int start multiplierendInclusive multiplier operator fun ClosedRangeFloatplusaddend Float start addendendInclusive addend operator fun ClosedRangeFloatminussubtrahend Float start subtrahendendInclusive subtrahend infix fun Floatamidtolerance Float this tolerancethis tolerance As of writing this issue documentation generation task with Dokka fails with an error so Dokka was reverted to The goal of this task is to update to the latest Dokka version and fix any relevant errors in the documentation LibGDX introduced generic types to TreeNode class Cyberpunk is an opinionated Kotlin LibGDX framework that aims to be on a little higher abstraction level than KTX Some of its utilities are generic enough to make it into KTX In particular we should look into Screenshot utilities Profiling Camera utilities Image and text helpers See ImXico Add ktxassetsasync module AssetStorage rewrite Usage documentation Restore ktxfreetypeasync update to new API x Restore TextAssetLoader move to ktxassets AssetStorage was removed during the ktxasync overhaul in b due to reliance on old coroutines API and threading issues The goal of this task is to rewrite AssetStorage in a fully threadsafe way without reliance on specific coroutines dispatchers for asynchronous tasks Hi great extension to libGDX thank you for that My question how can square brackets be used with libKTX ArrayMaps what I wanted to to kotlin val myMap ArrayMapString Label myMap ArrayMap myMap one new Label But there is no Set operator defined Am I doing something wrong or isnt it just implemented yet Cheers Contracts might improve usability of DSL APIs Possible improvements ensuring that the compiler knows that lambdas in building DSLs are called once ktxscene d actors ktxstyle actor styles ktxbox d bodies fixtures and joints ktxgraphics use utility methods x ImmutableVector ImmutableVector Hi Thank you very much for providing theses utilities for Kotlin I would like to propose to introduce some immutable classes for at least vector and colors could be called KVector or ImmutableVector for instance In order to allow easy usage with LibGDX they could either inherit from their equivalent in LibGDX deprecate all mutation method and throw if a mutation method is called provide adapter like ImmutableVector asVector and Vector toImmutableVector Why Even in Java I find errorprone that classes like vector or color are mutable It is for instance possible to change by mistake Vector ZERO and it is a mistake really easy to do But I think thats even more true in Kotlin where the language provide good support for immutability val is the default data class provides copy to easily get a new object and immutable fields can be smartcasted Mutable vectors cannot be safely shared and one has to do defensive copy each time it gets a vectors which is cumbersome unsafe and inefficient In short Even in Java it should have been immutable In Kotlin immutable data classes are even more idiomatic