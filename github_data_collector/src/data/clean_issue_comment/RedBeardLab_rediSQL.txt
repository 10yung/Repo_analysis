I setup Redis Replication MasterSlave by loading rediSQL so module on bothI have configure redis Master for Write operation and Slave for only Read whenever I write data on master these changes are not reflecting on slave But After restarting master those data are sync with slave I Check Replication WriteRead operation using SET and GET command When i set any key in master using set command this key can read using get command immediately on slave without restart master service For more clear Understanding Master output roottest rediscli REDISQLQUERY xyz select FROM tbltest integer integer integer integer UDP integer IP Slave output roottest rediscli p REDISQLQUERY xyz select FROM tbltest integer integer integer integer UDP integer IP Here value and is different in master and slave Can you help to resolved this issue Hello team At your main site i can see info about PHP examples and link to this repo but here i can find it Can you please share to me example of PHP Thanks This issues will hopefully serve RediSQL is designed to use one thread for each database This simplify a lot the design but it limits the throughput a lot There are several cases where multiple thread for a single database is welcome mostly for read intensive workload Using multiple connection is possible indeed we already have a function to create another connection and thread that point to the original connection Moreover we showed that is possible to have multiple connection acting on the same database with the REDISQLEXEC command enhanced with the USING feature To recap in RediSQL use REDISQLCREATEDB to create a new database and spawn a thread that act on this database REDISQLCREATEDB DB This create a connection to an inmemory database and spawn a thread that manage such connection I added a new command REDISQLADDCONNECTION that allow to create a new connection to the original database REDISQLADDCONNECTION DB READ This spawn a new thread that holds a connection to the same database mentioned above Also the USING features was implemented REDISQLEXEC DB select This one use the original connection associate with DB REDISQLEXEC DB select USING READ This use the new connection just created with REDISQLADDCONNECTION Now we would like to implement the USING features also for REDISQLEXECSTATEMENT REDISQLCREATESTATEMENT REDISQLDELETESTATEMENT and REDISQLUPDATESTATEMENT All the work was done in the removevtab branch STACK TRACE EIP redisserver x ca e RMGetThreadSafeContext Backtrace redisserver x ca c de logStackTrace redisserver x ca ccad sigsegvHandler libsystemplatformdylib x fff ab d sigtramp x fba c e x libredissqldylib x ce ZN redisqllib redistype Context threadsafe h aec fE libredissqldylib x cc ec ZN redisqllib redis returnvalue h eb fcc ed fb E libredissqldylib x cc f d ZN redisqllib redis listenandexecute h c ecfc c d e E libredissqldylib x cc d ea ZN std syscommon backtrace rustbeginshortbacktrace h b ce d c Ellvm libredissqldylib x cc f ZN std panicking try docall h b ada b Ellvm libredissqldylib x d a f rustmaybecatchpanic libredissqldylib x cc cb ZN core ops function FnOnce callonceu bu bvtableshimu du d haec bce e ee E libredissqldylib x d eae ZN LTallocboxedBoxLTFGTu asu coreopsfunctionFnOnceLTAGTGT callonce h c ae E libredissqldylib x d e ZN std syscommon thread startthread hb e ab dd E libredissqldylib x d f ZN std sys unix thread Thread new threadstart h e ebc f d c E libsystempthreaddylib x fff eb pthreadbody libsystempthreaddylib x fff pthreadstart libsystempthreaddylib x fff d threadstart Also reported in the redis project but it is related to inserting data into redis using rediSQL I have a redisserver instance running on a raspberry PI with Gb of memory REDIS was running normally until I started using it today by creating a rediSQL DB create a table then attempting to put data into this table At the attempt to insert data I got an Error Connection reset by peer which is when redis crashed This is my console REDISQLCREATEDB DB OK REDISQLEXEC DB CREATE TABLE ttyRoute column CHAR column CHAR column CHAR column VARCHAR column CHAR column CHAR options TEXT DONE integer REDISQLEXEC DB INSERT INTO ttyRoute VALUESXX YYY ZZ QUE Error Connection reset by peer s Redis error log REDIS BUG REPORT START Cut paste starting from here M Aug Redis crashed by signal M Aug Crashed running the instruction at xb f ef M Aug Accessing address x M Aug Failed assertion STACK TRACE EIP usrlibarmlinuxgnueabihflibarmmemv lso x f xb f ef Backtrace usrbinredisserver logStackTrace x c x ad usrbinredisserver sigsegvHandler x c x b libarmlinuxgnueabihflibcso defaultrtsarestorer x xb c INFO OUTPUT Server redisversion redisgitsha redisgitdirty redisbuildidafa decbb de f redismodestandalone osLinux v l armv l archbits multiplexingapiepoll atomicvarapiatomicbuiltin gccversion processid runid ec a a fba ec e cc tcpport uptimeinseconds uptimeindays hz configuredhz lruclock executableusrbinredisserver configfileetcredisredisconf Clients connectedclients clientrecentmaxinputbuffer clientrecentmaxoutputbuffer blockedclients Memory usedmemory usedmemoryhuman K usedmemoryrss usedmemoryrsshuman M usedmemorypeak usedmemorypeakhuman K usedmemorypeakperc usedmemoryoverhead usedmemorystartup usedmemorydataset usedmemorydatasetperc allocatorallocated allocatoractive allocatorresident totalsystemmemory totalsystemmemoryhuman G usedmemorylua usedmemoryluahuman K usedmemoryscripts usedmemoryscriptshuman B numberofcachedscripts maxmemory maxmemoryhuman M maxmemorypolicyallkeyslru allocatorfragratio allocatorfragbytes allocatorrssratio allocatorrssbytes rssoverheadratio rssoverheadbytes memfragmentationratio memfragmentationbytes memnotcountedforevict memreplicationbacklog memclientsslaves memclientsnormal memaofbuffer memallocatorjemalloc activedefragrunning lazyfreependingobjects Persistence loading rdbchangessincelastsave rdbbgsaveinprogress rdblastsavetime rdblastbgsavestatusok rdblastbgsavetimesec rdbcurrentbgsavetimesec rdblastcowsize aofenabled aofrewriteinprogress aofrewritescheduled aoflastrewritetimesec aofcurrentrewritetimesec aoflastbgrewritestatusok aoflastwritestatusok aoflastcowsize Stats totalconnectionsreceived totalcommandsprocessed instantaneousopspersec totalnetinputbytes totalnetoutputbytes instantaneousinputkbps instantaneousoutputkbps rejectedconnections syncfull syncpartialok syncpartialerr expiredkeys expiredstaleperc expiredtimecapreachedcount evictedkeys keyspacehits keyspacemisses pubsubchannels pubsubpatterns latestforkusec migratecachedsockets slaveexpirestrackedkeys activedefraghits activedefragmisses activedefragkeyhits activedefragkeymisses Replication rolemaster connectedslaves masterreplidaf dcc ece c db e c e e masterreplid masterreploffset secondreploffset replbacklogactive replbacklogsize replbacklogfirstbyteoffset replbackloghistlen CPU usedcpusys usedcpuuser usedcpusyschildren usedcpuuserchildren Commandstats cmdstatREDISQLCREATEDBcalls usec usecpercall cmdstatREDISQLEXECcalls usec usecpercall cmdstatcommandcalls usec usecpercall Cluster clusterenabled Keyspace db keys expires avgttl CLIENT LIST OUTPUT id addr fd name age idle flagsb db sub psub multi qbuf qbuffree obl oll omem eventsr cmdREDISQLEXEC REGISTERS FAST MEMORY TEST M Aug Bio thread for job type terminated M Aug Bio thread for job type terminated M Aug Bio thread for job type terminated Preparing to test memory region ed bytes Preparing to test memory region b ee bytes Preparing to test memory region b bytes Preparing to test memory region b a bytes Preparing to test memory region b f bytes Preparing to test memory region b f bytes Preparing to test memory region b bytes Preparing to test memory region b a bytes Preparing to test memory region b bytes Preparing to test memory region b de bytes Preparing to test memory region b e bytes Preparing to test memory region b bytes Preparing to test memory region b aa bytes Preparing to test memory region b b bytes Preparing to test memory region b f bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b ce bytes Preparing to test memory region b cf bytes Preparing to test memory region b bd bytes Preparing to test memory region b dd bytes Preparing to test memory region b f bytes Preparing to test memory region b fb bytes Preparing to test memory region b d bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b d bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b bytes Preparing to test memory region b a bytes Preparing to test memory region b bytes Preparing to test memory region b bf bytes Preparing to test memory region b ee bytes Preparing to test memory region b fef bytes Preparing to test memory region b f bytes Preparing to test memory region b ff bytes Preparing to test memory region b bytes Preparing to test memory region b a bytes Preparing to test memory region b bf bytes Preparing to test memory region b d bytes Preparing to test memory region b d d bytes Preparing to test memory region b eca bytes Preparing to test memory region b f bytes Preparing to test memory region b f b bytes Preparing to test memory region b fa bytes Preparing to test memory region b fab bytes OOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOOO Fast memory test PASSED however your memory can still be broken Please run a memory test for several hours if possible DUMPING CODE AROUND EIP Symbol null base nil Module usrlibarmlinuxgnueabihflibarmmemv lso base xb f d xxd r p tmpdumphex tmpdumpbin objdump adjustvmanil D b binary m i x tmpdumpbin REDIS BUG REPORT END Make sure to include from START to END Let me know if you need anything else Ron Environmet virtualmachine ubuntu x C G redis cluster modewith master nodesno slave create db and table sql REDISQLREDISQLCREATEDB DBDEVICE REDISQLEXEC DBDEVICE create table devicetab seq TEXTdeviceId TEXTcustomerId TEXTtranName TEXTtime TEXT REDISQLEXEC DBDEVICE create index idxdeviceId on devicetabdeviceId insert shell binbash for var in seq do rediscli c p REDISQLEXEC DBDEVICE insert into devicetab values did MonInfoUdt echo var done after insert into the table REDISQLEXEC mydb select count from devicetab integer info memory Memory usedmemory usedmemoryhuman G usedmemoryrss usedmemoryrsshuman G So i think this cost too many memoryAnd is there something wrong what i did or is there some way to decrease the memory cost By the wayi create the same table and index just use sqlite with disk modeAnd insert about recordseach is same with above redisql insert recordThe disk file is M rootjoffiervirtualmachinedatasqlite sqlite mydbsqlite select count from devicetab rootjoffiervirtualmachinedatasqlite ls lh M rwrr root root batchInsertsh rwrr root root M mydbsqlite Hope your reply sincely Thank you Please provide steps to install rediSQL from source under Centos thanks jaison env redis redisql illegal character caused redisql to shutdown i checked my data they are normal just include null nan i think it is resolved in redisql Hi all I am thinking about dropping the virtual table from RediSQL the one that are created with REDISQLTABLESBRUTEHASH They are quite complex to maintain and they dont bring too many benefits I believe Is somebody using them How Somebody want to really keep them around At the beginning of August weeks from now if nobody complained I will decide to drop those virtual table Up to now redisql accumulate all the results in memory and return all of them together This design is all but ideal but was implemented for simplicity reasons Our good friend from discovered that in some realworld case this can lead to nasty problems Or at least I reproduce a similar issue It should be possible to avoid the accumulation of the whole result in memory and instead return an iterator This is a quite complex piece of code and a very good test bench for Rust Hopefully I will be able to pull also this one The code is complex because we need to pass back and forth an instance of a locked raw pointer it should theorical be possible The piece of code concerned is Before to move to this I would like to move to the rust edition Then on a clean codebase we can work on this 