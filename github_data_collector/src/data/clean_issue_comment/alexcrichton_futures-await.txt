After upgrading to nightly this compiler have following message and stopped error E no method named resume found for type T in the current scope Usersshisoftcargoregistrysrcgithubcom ecc db ec futuresawait srclibrs match unsafe self resume help items from traits can only be used if the trait is implemented and in scope note the following trait defines an item resume perhaps you need to implement it candidate stdopsGenerator error E no method named resume found for type T in the current scope Usersshisoftcargoregistrysrcgithubcom ecc db ec futuresawait srclibrs match unsafe selfgenresume help items from traits can only be used if the trait is implemented and in scope note the following trait defines an item resume perhaps you need to implement it candidate stdopsGenerator error aborting due to previous errors For more information about this error try rustc explain E error Could not compile futuresawait warning build failed waiting for other jobs to finish error build failed I know this crate is under maintaining mode Just asking suggestions for migrate to rust builtin features to move on Thanks This PR upgrades the code to latest Rust nightly Fixed compilation errors in tests Removed stabilized and subsumed feature flags Switched to edition Simplified streamyield macro Formatted the code with rustfmt Fixed breakage caused by move of generators to Pin API This crate has been in maintenance mode and pitifully maintained for several months However at this point I think it might be time to straight deprecate it There are now bridges between the futures version which is used by the asyncawait native syntax and the futures version which is used by libraries like tokio and hyper provided in the tokioasyncawait crate So Im asking are you still using this crate If so what is stopping you from moving to native syntax I realize this crate is legacy but at the moment its the best way to write async software if you depend on anything from cratesio which is basically every useful program one might want to write Also this could be a much bigger issue with proc macros that surely needs reporting so sometimes when developing a new program the compiler spits out error messages like this This happens on rustc nightly c b and ever other version of nightly I tried which believe me is quite a few more than I want to list error E cannot move out of borrowed content error E borrowed value does not live long enough srcprotocolrs async temporary value only lives until here temporary value does not live long enough borrow later used here error aborting due to previous errors This is almost completely useless and I have to say intensely frustrating The horrible thing about this problem is that sometimes the error message is completely reasonable and I have yet to identify a small example that triggers the behaviour it doesnt seem to happen in small projects but once a project crosses some complexity threshold the error context is getting totally clobbered by either async await or proc macro Another example even more frustrating error E match arms have incompatible types note expected type stdresultResultprotocolClient found type stdresultResult error E mismatched types error aborting due to previous errors That was the entire error message It could be anywhere in the crate Or even worse error E mismatched types error aborting due to previous error For more information about this error try rustc explain E This one happened to be a u vs i type mismatch in a function call The function expected i and was being passed a u The function being called wasnt async but the caller was Barring a simple example I can make the code available its only about lines just let me know This crate uses the procmacro APIs which have been going through a lot of churn as they prepare for stabilization As a result its been broken a lot more often than not probably on recent nightlies Now that asyncawait is being implemented in the compiler this is basically a deprecated legacy API As a result my focus and Alexs has not been on getting this crate to build again leaving it broken for too long at a time But of course there are definitely users who depend on this crate and cant upgrade to the builtin feature yet So Im wondering does anyone want to take on responsibility for keeping this code green The proc macro APIs are supposed to stabilize soon so hopefully once that happens it will go back to being fairly stable I can not successfully compile the basic await example on the readme bash rustc version rustc nightly ecf d My first attempt to compile it gave me this compilation error bash error E macro await is unstable see issue checkawait srcmainrs Ok awaitbar help add featureawaitmacro to the crate attributes to enable According to the information in the error message I added featureawaitmacro Later I also added featurecustomattribute to obtain this source file mainrs rust featureprocmacro generators featureawaitmacro featurecustomattribute extern crate futuresawait as futures use futurespreludeawait async async fn foo Resulti i Ok awaitbar async fn bar Resulti i Ok fn main asserteqfoowait Ok Cargotoml toml package name checkawait version authors real dependencies futuresawait Compilation errors bash cargo build Compiling checkawait v filehomerealtempcheckawait error E unresolved import futurespreludeawait checkawait srcmainrs use futurespreludeawait async no await in prelude error E unresolved import futurespreludeasync srcmainrs use futurespreludeawait async no async in prelude Did you mean to use Async warning unused imports async await srcmainrs use futurespreludeawait async note warnunusedimports on by default error E the trait bound stdresultResulti i stdfutureFuture is not satisfied srcmainrs Ok awaitbar the trait stdfutureFuture is not implemented for stdresultResulti i note required by stdfuturepollintaskcx note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info error E the trait bound stdresultResulti i stdfutureFuture is not satisfied srcmainrs Ok awaitbar the trait stdfutureFuture is not implemented for stdresultResulti i note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info error E yield statement outside of generator literal srcmainrs Ok awaitbar note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info error E no method named wait found for type stdresultResulti i in the current scope srcmainrs asserteqfoowait Ok error aborting due to previous errors Some errors occurred E E E E For more information about an error try rustc explain E error Could not compile checkawait To learn more run the command again with verbose Is there anything I can do to resolve these issues I realise that this isnt really about asyncawait itself but using it in surrounding code made me question my instincts so I figured Id open a discussion I want to write some code along the lines of rust fn foo self impl Future if let Someearlyvalue selfcheck Doesnt compile because Ok is a Result but function returns an impl Future Need to return a futuresfutureokearlyvalue instead return Okearlyvalue Doesnt compile because the operator cant be used in a function which returns an impl Future Need to explicitly match and earlyreturn instead let request selfpreparerequest Clone value out because borrows arent allowed in asyncblocks let client selfclientclone asyncblock let response awaitclientmakerequestrequest awaitparseresponse There are three big things that stop me from being able to do this today the two things commented on in the code and that my function returns an impl Future but after making the two changes in the comments Im no longer returning one unique anonymous Future type so I need to Box everything up rather than returning an impl Trait My instinct is that my asyncblock should be as short as possible because minimising the scope where the reader needs to consider asynchrony feels good But if Id moved the lines before the client cloning asis into the asyncblock the code would compile fine modulo theself borrows because the asyncblock itself does effectively return a Result Is my instinct to minimise the size of ayncblocks wrong Is there a more ergonomic way of doing what Im doing without enlarging the asyncblock Thanks Hi It seems like the nightly rust have already built in await macro which conflict with this crate Is there any suggestion to resolve this problem before futures was settled Thanks error E await is ambiguous srcraftclientrs asyncboxed note await could refer to the name imported here srcraftclientrs use futuresprelude note await is also a builtin macro note consider adding an explicit import of await to disambiguate Im a newcomer to rust particularly to futures and asyncawait however Im pretty familiar with coroutines and some of the javascript libraries like asyncparallel Im aiming to call or N longrunning async functions and wait for them both to finish before continuing I did a fair bit of googling and couldnt find any examples in rust of something along these lines in rust Heres how one might do it in javascript js asyncparallel one functioncallback callbacknull done n two functioncallback callbacknull done n functionerr results now we can continue Or in golang go messages makechan int go func timeSleeptimeSecond messages done true go func timeSleeptimeSecond messages done true for i i i done now we can continue Any chance we could add an example of this to the documentation As per the title The only occurrence of asyncstreamblock I can find in the source is in its definition