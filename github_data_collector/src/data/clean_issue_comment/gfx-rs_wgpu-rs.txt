I tried to init wgpu by my hand And I made mistake at Line of the code This code compiles a fragment shader code into vertex shader and passing to createrenderpipeline as a fragment shader Rust extern crate wgpu extern crate glsltospirv fn main let adapter wgpuAdapterrequest wgpuRequestAdapterOptions powerpreference wgpuPowerPreferenceDefault wgpuBackendBitPRIMARY unwrap let device mut queue adapterrequestdevice wgpuDeviceDescriptor extensions wgpuExtensions anisotropicfiltering false limits wgpuLimitsdefault let vs includestrshadervert GLSL vertex shader code from examplehellotriangle let vsmodule devicecreateshadermodule wgpureadspirvglsltospirvcompile vs glsltospirvShaderTypeVertexunwrapunwrap let fs includestrshaderfrag GLSL fragment shader code from examplehellotriangle let fsmodule devicecreateshadermodule wgpureadspirvglsltospirvcompile fs glsltospirvShaderTypeVertex glsltospirvShaderTypeFragment unwrapunwrap let pipelinelayout devicecreatepipelinelayout wgpuPipelineLayoutDescriptor bindgrouplayouts let pipeline devicecreaterenderpipeline wgpuRenderPipelineDescriptor SIGSEGV layout pipelinelayout vertexstage wgpuProgrammableStageDescriptor module vsmodule entrypoint main fragmentstage SomewgpuProgrammableStageDescriptor module fsmodule entrypoint main rasterizationstate SomewgpuRasterizationStateDescriptor frontface wgpuFrontFaceCcw cullmode wgpuCullModeBack depthbias depthbiasslopescale depthbiasclamp primitivetopology wgpuPrimitiveTopologyTriangleList colorstates depthstencilstate None indexformat wgpuIndexFormatUint vertexbuffers samplecount samplemask alphatocoverageenabled false Cargotoml package name wgpurssegv version authors stentol stentol gmailcom edition dependencies wgpu git branch master glsltospirv cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugwgpurssegv Segmentation fault core dumped Yes it is just a my mistake But I thought it is not desired behavior Im just a newbie of Rust Sorry if its wrong Currently wgpurs uses the C API of wgpunative which then uses wgpucore for the gory details This issue raises the question of whether the middle step can be skipped In order to answer the question we need to consider all the possible targets for wgpurs Native execution with wgpu This is the only target supported right now It could easily bypass wgpunative and call into wgpucore Native execution with Dawn see Wed have to use the API calls according to webgpuheaders This would technically work if wgpunative implements the headers and becomes a dropin replacement for Dawn The target is incompatible with using wgpucore directly cc Kangz Browser execution on the Web see The plan is to use websys directly and thus it doesnt depend on wgpu cc grovesNL With that in mind the only blocker for using wgpucore directly is running on Dawn This is somewhat a minor goal for us given that we are trying to make wgpu a batter or comparable solution My proposal would be to turn wgpurs into a multibackend library like gfxrs is enforcing the API with traits The backends are wgpucore for fastest native development no FFI boundary webgpuheaders for generic standardcompatible target with wgpunative dawn and possibly some emscripten dropin libraries implementing the headers websys for web development Hello thanks for working on this It would seem Im having a little trouble running the examples on a Surface Pro Iris Graphics on ClearLinux Vulkan however works I tested the examples from Desktop is GNOMEWayland Running targetdebugexampleshellotriangle T Z ERROR gfxbackendvulkan VALIDATION VUIDVkDescriptorPoolCreateInfopoolSizeCountarraylength vkCreateDescriptorPool parameter pCreateInfopoolSizeCount must be greater than The Vulkan spec states poolSizeCount must be greater than object info type UNKNOWN hndl thread main panicked at called Resultunwrap on an Err value srclibcoreresultrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs coreresultunwrapfailed at srclibcoreresultrs coreresultResultTEunwrap at rustc a f a cbaff b c cc f ce ff f a srclibcoreresultrs smithayclienttoolkitwindowconceptframeConceptFrame as smithayclienttoolkitwindowFrameredraw at homeoleidcargoregistrysrcgithubcom ecc db ec smithayclienttoolkit srcwindowconceptframers smithayclienttoolkitwindowWindowFrefresh at homeoleidcargoregistrysrcgithubcom ecc db ec smithayclienttoolkit srcwindowmodrs winitplatformimplplatformwaylandeventloopEventLoopTpostdispatchtriggersclosure at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxwaylandeventlooprs winitplatformimplplatformwaylandwindowWindowStoreforeach at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxwaylandwindowrs winitplatformimplplatformwaylandeventloopEventLoopTpostdispatchtriggers at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxwaylandeventlooprs winitplatformimplplatformwaylandeventloopEventLoopTrunreturn at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxwaylandeventlooprs winitplatformimplplatformwaylandeventloopEventLoopTrun at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxwaylandeventlooprs winitplatformimplplatformEventLoopTrun at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxmodrs winiteventloopEventLoopTrun at homeoleidcargoregistrysrcgithubcom ecc db ec winit alpha srceventlooprs hellotrianglemain at exampleshellotrianglemainrs stdrtlangstartclosure at rustc a f a cbaff b c cc f ce ff f a srclibstdrtrs stdrtlangstartinternalclosure at srclibstdrtrs stdpanickingtrydocall at srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at srclibstdpanickingrs stdpaniccatchunwind at srclibstdpanicrs stdrtlangstartinternal at srclibstdrtrs stdrtlangstart at rustc a f a cbaff b c cc f ce ff f a srclibstdrtrs main libcstartmain at csulibcstartc start Not sure if related Vulkanos triangle example shows a window and a triangle however panics INTELMESA error srcintelvulkananvqueuec drmsyncobjwait failed No such file or directory VKERRORDEVICELOST Unfortunately ZeroCopy take a really long time to build Its a part of Fuchsia code base and communicating with developers or filing issues seems problematic Perhaps we could make a simpler version of it for ourselves or find an existing alternative Per compressed textures will be included in the WebGPU spec However I cant find much else referencing them Are there plans to add support to wgpurswgpucore in the near term Or even a sense of what form they may take All examples panic with the same error RUSTBACKTRACEfull cargo run example cube Finished dev unoptimized debuginfo targets in s Running targetdebugexamplescube thread main panicked at internal error entered unreachable code homeoskarcargogitcheckoutswgpu e f b dd b dwgpunativesrcdevicers stack backtrace x d b ad backtracebacktracelibunwindtracehda dbcdfba aa at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs x d b ad backtracebacktracetraceunsynchronizedh a d e f cb f d at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x d b ad stdsyscommonbacktraceprintfmth c e da at srclibstdsyscommonbacktracers x d b ad stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmth dc e bd d at srclibstdsyscommonbacktracers x d b fc corefmtwriteh edf dd a c c at srclibcorefmtmodrs x d b stdioWritewritefmthf f f c at srclibstdiomodrs x d b d b stdsyscommonbacktraceprinthd d d a e at srclibstdsyscommonbacktracers x d b d b stdsyscommonbacktraceprinthf a e a at srclibstdsyscommonbacktracers x d b d b stdpanickingdefaulthookclosureh a f beb bb ae at srclibstdpanickingrs x d b d a stdpanickingdefaulthookh f b bc a c at srclibstdpanickingrs x d b dfb stdpanickingrustpanicwithhookh f da at srclibstdpanickingrs x d b ca stdpanickingbeginpanich fb cd b at rustc ea cb f a c e f srclibstdpanickingrs x d b d c be wgpuadapterrequestdevice at homeoskarcargogitcheckoutswgpu e f b dd b dwgpunativesrcdevicers x d b b cbe wgpuAdapterrequestdeviceh edcd d at srclibrs x d b adb cubeframeworkrunhcc ccdd b a d at examplescubeframeworkrs x d b f cubemainh ed a a at examplescubemainrs x d b ea stdrtlangstartclosureh c b d c at rustc ea cb f a c e f srclibstdrtrs x d b d e stdrtlangstartinternalclosureha f d cbe at srclibstdrtrs x d b d e stdpanickingtrydocallh c a f db c at srclibstdpanickingrs x d b a rustmaybecatchpanic at srclibpanicunwindlibrs x d b e ad stdpanickingtryhc a b da d at srclibstdpanickingrs x d b e ad stdpaniccatchunwindhf bf c a at srclibstdpanicrs x d b e ad stdrtlangstartinternalh d f fe b at srclibstdrtrs x d b ea stdrtlangstarth e cfd dbc at rustc ea cb f a c e f srclibstdrtrs x d b f a main x fdfc d b libcstartmain x d b b aa start x unknown OS is Ubuntu using nvidiadriver Hardware HW path Device Class Description system MS To be filled by OEM bus P AGD MS memory KiB BIOS memory KiB L cache memory MiB L cache memory MiB L cache memory GiB System Memory memory GiB DIMM DDR Synchronous MHz ns memory DIMM Synchronous empty memory GiB DIMM DDR Synchronous MHz ns memory DIMM Synchronous empty processor IntelR CoreTM i K CPU GHz bridge nd Generation Core Processor Family DRAM Controller bridge Xeon E nd Generation Core Processor Family PCI Express Root Port display GP GeForce GTX multimedia GP High Definition Audio Controller communication SeriesC Series Chipset Family MEI Controller a bus SeriesC Series Chipset Family USB Enhanced Host Im honestly not sure entirely where I should post this given the different projects that cover what goes into wgpu but I figured I would put it here even if perhaps it needs to be delegated upstream Ive been working with projects that require rendering across multiple windows as well as trying to fit the entire project on an async runtime tokio in my case to parallelize my projects better and make better use of worker threads At this time WGPU has a function that prevents me from rendering to multiple windows efficiently without creating a thread per window or putting WGPU rendering code on the tokio runtime Specifically the function SwapChaingetnexttexture On native platforms this function will block until the next texture is available This means that without using thread per window all rendering and updating of all windows will stall whenever an attempt is made to render to one window without any way to in advance detect if it will block This also means it cant be used on a tokio runtime as multiple windows being rendered to will effectively stall worker threads until its done blocking It would be nice if there was an alternative function or a feature on this function to never block but instead poll At the very least the Vulkan backend supports this behavior on acquiring the next swapchain image This would also make it possible to implement a Future around the SwapChain and use WGPU on a tokio runtime without blocking the worker thread Currently I dont know if theres any other functions in WGPU that have similar issues but if there are it would be nice to where possible have similar nonblocking APIs available I have just pulled master and run cargo update The example with the triangle worked The cube map one still fails cargo run example cube RUSTBACKTRACE Finished dev unoptimized debuginfo targets in s Running targetdebugexamplescube RUSTBACKTRACE cube MTLIGAccelBuffer addDebugMarkerrange unrecognized selector sent to instance x fcf d ebd T Z ERROR relevant Values of this type cant be dropped segmentation fault cargo run example cube RUSTBACKTRACE I have the same error MTLIGAccelBuffer addDebugMarkerrange unrecognized selector sent to instance for the examples mipmap capture shadow msaaline skybox hellocompute hellotriangle and describe are working The examples describe and hellotriangle I am on Mac OS El Capitan MacBook Pro Retina inch Mid GPU Intel Iris MB This is a blocker for gfxrsgfx Its currently not possible to access the AdapterInfodevicetype field from within gfx library code because the compiler tries to use the local version of DeviceType rather than the one used by wgpu causing a version conflict error E mismatched types src backend wgpu src librs info agetinfo expected struct gfxhaladapterAdapterInfo found a different struct gfxhaladapterAdapterInfo note expected type gfxhaladapterAdapterInfo struct gfxhaladapterAdapterInfo found type gfxhaladapterAdapterInfo struct gfxhaladapterAdapterInfo note Perhaps two different versions of crate gfxhal are being used It would probably also be good just for consistency reasons since we already reexport all the other gfx types used in wgpus public interfaces OS Fedora Display Manager Xorg Log thread main panicked at index out of bounds the len is but the index is rustc ea cb f a c e f srclibcoreslicemodrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingcontinuepanicfmt at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs corepanickingpanicboundscheck at srclibcorepanickingrs usize as coresliceSliceIndex T index at rustc ea cb f a c e f srclibcoreslicemodrs coresliceimpl coreopsindexIndexI for T index at rustc ea cb f a c e f srclibcoreslicemodrs allocvecVecT as coreopsindexIndexIindex at rustc ea cb f a c e f srcliballocvecrs gfxbackendvulkanwindowSurface as gfxhalwindowPresentationSurfacegfxbackendvulkanBackendacquireimage at homemastercargoregistrysrcgithubcom ecc db ec gfxbackendvulkan srcwindowrs wgpucoreswapchainimpl wgpucorehubGlobalFswapchaingetnexttexture at homemastercargogitcheckoutswgpu e f b dd b dwgpucoresrcswapchainrs wgpuswapchaingetnexttexture at homemastercargogitcheckoutswgpu e f b dd b dwgpunativesrcdevicers wgpuSwapChaingetnexttexture at srclibrs cubeframeworkrunclosure at examplescubeframeworkrs winitplatformimplplatformstickyexitcallback at homemastercargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxmodrs winitplatformimplplatformx EventLoopTrunreturn at homemastercargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxx modrs winitplatformimplplatformx EventLoopTrun at homemastercargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxx modrs winitplatformimplplatformEventLoopTrun at homemastercargoregistrysrcgithubcom ecc db ec winit alpha srcplatformimpllinuxmodrs winiteventloopEventLoopTrun at homemastercargoregistrysrcgithubcom ecc db ec winit alpha srceventlooprs cubeframeworkrun at examplescubeframeworkrs cubemain at examplescubemainrs stdrtlangstartclosure at rustc ea cb f a c e f srclibstdrtrs stdrtlangstartinternalclosure at srclibstdrtrs stdpanickingtrydocall at srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at srclibstdpanickingrs stdpaniccatchunwind at srclibstdpanicrs stdrtlangstartinternal at srclibstdrtrs stdrtlangstart at rustc ea cb f a c e f srclibstdrtrs main libcstartmain start note Some details are omitted run with RUSTBACKTRACEfull for a verbose backtrace 