Ive recently been fiddling with a multi threaded application using crossbeam channels On threadripper I noticed that performance would degrade rapidly when the sender and receiver were on different CCXs or in other words when cache wasnt shared between sender and receiver With a bit of digging I found that in the array implementation of channels does suffer from the buffer not being cach aligned I wrapped the buffer in a CachePadded and it improved significantly in my tests over x in some cases that said obviously the tests only capture a tiny bit and using a single bit value in them definitely is the extreme case to trigger this edge case Still it looks lice a nice improvement I will keep this as a draft for now as while the benchmarks looks nice real world impact I measured is not as big as I hoped tm so I think I have a bit more digging to do this running tests test bounded create bench nsiter test bounded mpmc bench nsiter test bounded mpsc bench nsiter test bounded spmc bench nsiter test bounded spsc bench nsiter test bounded create bench nsiter test bounded mpmc bench nsiter test bounded mpsc bench nsiter test bounded oneshot bench nsiter test bounded spmc bench nsiter test bounded spsc bench nsiter test boundednmpmc bench nsiter test boundednmpsc bench nsiter test boundednparinout bench nsiter test boundednspmc bench nsiter test boundednspsc bench nsiter test unboundedcreate bench nsiter test unboundedinout bench nsiter test unboundedmpmc bench nsiter test unboundedmpsc bench nsiter test unboundedoneshot bench nsiter test unboundedparinout bench nsiter test unboundedspmc bench nsiter test unboundedspsc bench nsiter master running tests test bounded create bench nsiter test bounded mpmc bench nsiter test bounded mpsc bench nsiter test bounded spmc bench nsiter test bounded spsc bench nsiter test bounded create bench nsiter test bounded mpmc bench nsiter test bounded mpsc bench nsiter test bounded oneshot bench nsiter test bounded spmc bench nsiter test bounded spsc bench nsiter test boundednmpmc bench nsiter test boundednmpsc bench nsiter test boundednparinout bench nsiter test boundednspmc bench nsiter test boundednspsc bench nsiter test unboundedcreate bench nsiter test unboundedinout bench nsiter test unboundedmpmc bench nsiter test unboundedmpsc bench nsiter test unboundedoneshot bench nsiter test unboundedparinout bench nsiter test unboundedspmc bench nsiter test unboundedspsc bench nsiter Im currently working on a project where I have custom allocators that want to perform epoch garbage collection but with special nonstandard allocationdeallocation behavior To accomplish this I intend to use crossbeamepochs Guarddefer method to indicate to these custom allocators when threadtime here meaning intervals after which all threads have released Guards advances allowing them to perform a local epoch garbage collection Unfortunately the weak guarantees of defer mean that I will almost certainly not get called back right when all threads get unpinned in some circumstances causing my allocators to lose time This would be a nonissue if the function passed to defer received the current epoch count as the custom allocators could see how much time they lost and use this information to potentially clean up multiple epochsworth of stale lists at once Would it be possible to add this feature Or is it already possible and Im just not seeing a combo of calls that would make it happen Thanks for this project the crossbeamepoch system is saving me a lot of work and confusion Several libs in crossbeam contain unsound code Blocknew This PR fixes them and requires a MSRV upgrade to Im using a channel to send a message once and then using the channel again Do I want to use a bounded or unbounded channel for this It should probably state so in the readme It supersedes for supporting dynamically sized types DST in Crossbeam Its much cleaner and less intrusive than the previous attempts in that it doesnt introduce another Atomic type AtomicT is still there without significant changes The key idea is instead of requiring the condition on T Sized requiring T Pointable that means an object of type T can be pointed to by a single word For instance Atomic becomes pub struct AtomicT Sized Pointable It is breaking the backward compatibility in that it increases the minimum required Rust version to for MaybeUninit and now const fn Atomicnull is Nightly only isempty is an AtomicBool In function SyncWakernotify load isempty to check lock and notify store new value to isempty The struct implements Sync and notify takes an immutable self so it can be called in two threads To me it seems that the function intends to notify only once when isempty is not true However the following sequence may happen Th WWW Th W Thread load isempty and check then Thread notify and change the isempty Thread executes notify again Now notify is called twice The fix is to lift the lock before the isempty check or check isempty again after the lock Maybe FIX Hi After a cargo update on a large project I started seeing segfaults on in test run on an android arm v a emulator These segfaults seems to come from crossbeamchannel as downgrading to removes the problem I started poking around in order to get a reproduction test case and ended up founding that running a simple cargo test on crossbeamchannel on the emulator ends up in a segfault This seems to happen both on and though but only appears when running the tests on release mode which smells a lot like a race condition somewhere probably exacerbated by the fact that the arm v a emulator is slooow I didnt manage to reproduce it on a real device having it happen on the emulator is problematic though as is is way easier to setup for continuous integration than a device The test selectmacrolinearizabledefault seems to trigger the segfault most of the time when running in release Steps to reproduce get the android ndk get the android sdk tools bottom of page and use sdkmanager to install the packages platformtools tools systemimagesandroid defaultarm v a you need to add adb in androidsdkplatformtools to you path for dinghy do work install dinghy with cargo install cargodinghy cross compilation helper setup an android emulator androidsdktoolsbinavdmanager create avd n foobar k systemimagesandroid defaultarm v a b arm v a c M d f start the emulator androidsdkemulatoremulator avd toto prop emuuuidtoto partitionsize nosnapshot nowindow wipedata cores memory run the tests ANDROIDNDKHOMEpathtondk cargo dinghy platform autoandroidaarch api test p crossbeamchannel test selectmacro release linearizabledefault stjepang said Just so we dont forget in all the other places where we have atomic timestamps we should use AtomicU I believe we cant use wide sequences like in this PR unfortunately epoch representation headtail index in deque channel and queues But that can come later in another PR It will also require Rust minimum The original test has Notably done v ok false which in Rust ought to be donesendvisnone