Im trying to serialize an object to JSON using scalapickling and Scala but am having a very strange issue Ive replicated a minimal example below scala import orgapachehadoopiocompressCompressionCodecFactory import scalapicklingDefaults import scalapicklingjson trait foo var compressionCodecFactory CompressionCodecFactory val compressionCodecFactory CompressionCodecFactory null class blah extends foo object FooFoo def mainargs Array String val k new blah val pkl kpickle compilation fails with error Cannot generate a pickler for blah However if I remove or comment out var compressionCodecFactory CompressionCodecFactory within the trait foo it compiles and pickles perfectly Ive also tried adding the transient notation to this var but it fails with the same error Why could this possibly be happening Have this trait trait TestTrait val createdAt SystemcurrentTimeMillis var finishedAtLong def setAsFinishedUnit finishedAt SystemcurrentTimeMillis override def toString sTestTrait createdAtcreatedAt finishedAtfinishedAt and this case class case class TestCaseClassintInt dblDouble strString millisLong SystemcurrentTimeMillis extends TestTrait instantiating the case class by TestCaseClass String and pickling gives this JSON type pickletestsTestCaseClass int dbl str String millis finishedAt The createdAt field does not appear in the JSON and hence upon unpickling is set to a new different value By contrast the millis field is represented and hence retains the originally assigned value If createdAt is defined as a var instead of a val then it will appear in the JSON and the correct value is preserved Is this a bug or a feature In our actual application createdAt is really an internal uniqueID field so really do want it declared as a val so that it can never be accidentally modified This was run using M Scala java the IDE is IntelliJ The complete test routine and console output is pasted below BTW throws an exception trying to unpickle claiming that the var finishedAt is not represented as a Java variable in the class file Have the same problem in M in our full application but have not been able to reproduce within an isolated test file package pickletests import scalapickling import scalapicklingDefaults import scalapicklingjson Created by JCrowley on trait TestTrait val createdAt SystemcurrentTimeMillis var finishedAtLong def setAsFinishedUnit finishedAt SystemcurrentTimeMillis override def toString sTestTrait createdAtcreatedAt finishedAtfinishedAt case class TestCaseClassintInt dblDouble strString millisLong SystemcurrentTimeMillis extends TestTrait override def toString sTestCaseClass intint dbldbl strstr millismillis supertoString object PickleVarInTraitTests extends App val test TestCaseClass String Threadsleep testsetAsFinished Consoleprintlns nEnvironment Scala scalautilPropertiesversionString Java SystemgetPropertyjavaversion n Consoleprintln nOriginal TestCaseClass testtoString n val testPickled testpickle val testPickledJSON testPickledvalue ConsoleprintlnJSON pickled testPickledJSON n val testUnpickle testPickledJSONunpickle TestCaseClass ConsoleprintlnSuccess for TestCaseClass testUnpickle n val testUnpickle testPickledJSONunpickle AnyRef ConsoleprintlnUnpickle Unpickle testUnpickle testUnpickle Console Output Environment Scala version Java Original TestCaseClass TestCaseClass int dbl strString millis TestTrait createdAt finishedAt JSON pickled type pickletestsTestCaseClass int dbl str String millis finishedAt Success for TestCaseClass TestCaseClass int dbl strString millis TestTrait createdAt finishedAt Unpickle Unpickle true Process finished with exit code Apologies if this is a duplicate but several searches did not turn up this problem Using JSON format With this definition case class PickleNonetestOption String this sequence works OK val test PickleNoneNone val roundTrip testpicklevalueunpickle PickleNone gives test roundTrip but this sequence val test PickleNoneNone val roundTrip testpicklevalueunpickle AnyRef results in test roundTrip It appears in the second case that the unpickle step sees the scalaNonetype and instantiates a new instance for None Unfortunately Scala expects None to be a singleton and any None None test is reduced to object identity which now fails Scala Pickling Full test case follows package pickletests import scalapickling import scalapicklingDefaults import scalapicklingjson case class PickleNonetestOptionOption String object PickleNoneTest extends App val test PickleNoneNone val testPickled testpicklevalue val testUnpickled testPickledunpickle PickleNone val testAnyRef testPickledunpickle AnyRef val testAnyRefAsPickleNone testPickledunpickle AnyRef asInstanceOf PickleNone Consoleprintlntest testUnpickled is test testUnpickled Consoleprintln test testAnyRef is test testAnyRef Consoleprintln test asInstanceOf is test testAnyRefAsPickleNone Consoleprintln Consoleprintln Consoleprintln testtestOption is testtestOptiontoString XformatSystemidentityHashCodetesttestOption Consoleprintln testUnpickledtestOption is testUnpickledtestOptiontoString XformatSystemidentityHashCodetestUnpickledtestOption Consoleprintln testAnyReftestOption is testAnyRefasInstanceOf PickleNone testOptiontoString XformatSystemidentityHashCodetestAnyRefasInstanceOf PickleNone testOption ConsoleprintlntestAnyRefAsPickleNonetestOption is testAnyRefAsPickleNonetestOptiontoString XformatSystemidentityHashCodetestAnyRefAsPickleNonetestOption Are new maintainers sought Regardless of what the situation is it would be good if the README were frank about it removed all the straight deprecations added access to sunmiscUnsafe in Util removed in might be useful if anyone wants to update the library for there are many other macro code deprecations that would take time to remove Compiles except for benchmark and tests If the build projectUtilscala is changed to only everything compiles and the tests run so clearly there are some differences when using that dont work I suspect that there is still a reference to scalaconcurrentutilUnsafeinstance This would work in but not Note I used whitebox macros Is it possible to unpickle a pickled object without specifying the type Example import scalapicklingDefaults import scalapicklingbinary object TestPickling extends App case class Personname String age Int val obj PersonJohn val b objpicklevalue val objAgain bunpickle The example doesnt work error ambiguous implicit values both value datePickler in trait DatePicklers of type scalapicklingPickler javautilDate with scalapicklingUnpickler javautilDate and value javaBigDecimalPickler in trait JavaBigDecimalPicklers of type scalapicklingPickler javamathBigDecimal with scalapicklingUnpickler javamathBigDecimal match expected type scalapicklingUnpickler T bunpickle Am I missing something or is this just not possible Usecase serializing a set of objects of which the types are not known at compile time Hello could you explain me why pickling is able to deserialize in incorrect type without any errorswarning Or Im doing something wrong orgscalalangmodules scalapickling scalaVersion SCALA import scalapicklingDefaults import scalapicklingbinary object TestApp extends App final case class SimpleTypestr String final case class MoreComplexstr String xs Seq Int st SimpleType final case class LessComplexstr String d Double val simple SimpleTypesimple type val mcomplex MoreComplexmore complex Seq simple val lcomplex LessComplexless complex println nMust be OK testsimplepicklevaluesimple SimpleType SimpleTypesimple type testmcomplexpicklevaluemore MoreComplex MoreComplexmore complexList SimpleTypesimple type testlcomplexpicklevalueless LessComplex LessComplexless complex println nMust fail testmcomplexpicklevalueless LessComplex LessComplexmore complex E testmcomplexpicklevaluesimple SimpleType SimpleTypemore complex testlcomplexpicklevaluesimple SimpleType SimpleTypeless complex testsimplepicklevalueless javalangArrayIndexOutOfBoundsException class T str String override def toString String sT str class T str String i Int override def toString String sT stri val t new T Hey val t new T Hello println nNot a case class testt picklevalueT T T Hey testt picklevalueT T T Hey testt picklevalueT T T Hello testt picklevalueT T T Hello def testab Array Byte name String Unit name match case simple printlnSimpleType abunpickle SimpleType case more printlnMoreComplex abunpickle MoreComplex case less printlnLessComplex abunpickle LessComplex case T printlnT abunpickle T case T printlnT abunpickle T Output Must be OK SimpleType SimpleTypesimple type MoreComplex MoreComplexmore complexList SimpleTypesimple type LessComplex LessComplexless complex Must fail LessComplex LessComplexmore complex E SimpleType SimpleTypemore complex SimpleType SimpleTypeless complex Not a case class T T Hey T T Hey T T Hello T T Hello So as you can see it is possible to deserialize MoreComplex or LessComplex into SimpleType but not other way around So how can I be sure that I unpickle it in a proper type Thanks Is it possible to serialize the PicklerUnpickler generated by PicklerUnpicklergenerate T A marco of PicklerUnpickler is not serializable by Java Is this going to be supported or even possible The following code import scalapicklingFastTypeTag Pickler Unpickler import scalapicklingbinary import scalapicklingDefaults class Serializer T Pickler FastTypeTag def serializedata T Array Byte Foobardata object Foo def bar T Pickler FastTypeTag t T Array Byte tpicklevalue def unbar T Unpickler FastTypeTag bytes Array Byte T bytesunpickle T class Messagemessage String implicit object messageSerializer extends Serializer Message def test A Pickler FastTypeTag Serializer message A Array Byte implicitly Serializer A serializemessage val message new Messagemessage testmessage Evaluates to import scalapicklingFastTypeTag Pickler Unpickler import scalapicklingbinary import scalapicklingDefaults defined class Serializer defined module Foo defined class Message defined module messageSerializer test test A val message Aimplicit synthetic val evidence scalapicklingPickler A implicit synthetic val evidence picklingFastTypeTag A implicit synthetic val evidence Serializer A Array Byte message Message comimpresignhubcoreAA AA Message c df javalangVerifyError Bad type on operand stack Exception Details Location comimpresignhubcoreAA AA messageSerializerinitLcomimpresignhubcoreAA AA V invokespecial Reason Type uninitializedThis current frame stack is not assignable to comimpresignhubcoreAA AA messageSerializer Current Frame bci flags flagThisUninit locals uninitializedThis comimpresignhubcoreAA AA scalaruntimeVolatileObjectRef scalaTuple stack uninitializedThis comimpresignhubcoreAA AA scalaPredef uninitializedThis scalaruntimeVolatileObjectRef comimpresignhubcoreAA AA Bytecode x a b b db db b ab x b c bb x b b a b b d f x b b b e b x b b a b b d f x b b b e b x b e dc c db c c e a x d b c e a c x c a b c x a c c x a a b c a a x b a a c c ac e a x c ab d c a b a x d b a c b b a b ba a c x e bb b c b d fb x f b b b b Stackmap Table fullframe UninitializedThisObject Object Object Object Object Object Object Object Object Object UninitializedThisObject Object Object fullframe UninitializedThisObject Object Object Object Object Object Object Object Object Object UninitializedThisObject Object fullframe UninitializedThisObject Object Object UninitializedThisObject Object fullframe UninitializedThisObject Object Object TopTopTopTopTopTopTopObject UninitializedThisObject Object fullframe UninitializedThisObject Object UninitializedThisObject Object fullframe UninitializedThisObject Object UninitializedThisObject Object Object Output exceeds cutoff limit When the Serializer is changed to accept a pregenerated Pickler of a concreted type through the constructor the same problem is encountered For example object messageSerializer extends Serializer Message PicklerUnpicklergenerate Message But if the Serializer is abstract and has an abstract implicit val pickler AbstractPicklerUnpickler that the messageSerializer defined upon extending to PicklerUnpicklergenerate Message it works Is this an issue related to Scala Pickling or a compiler bug