 DynamicConcurrencyLimitzip Is this a bug report Yes Can you also reproduce the problem with the latest version Yes Environment Operating system Windows Visual Studio version Dotnet version dotnet core Steps to Reproduce Configure a consumer with a ConcurrentMessageLimit of Configure the management endpoint and add a RequestClient in order to dyanmically alter the ConcurrentMessageLimit using the SetConcurrencyLimit event public void ConfigureServicesIServiceCollection services servicesAddMassTransitConfigureMassTransit private IBusControl CreateBusIServiceProvider serviceProvider return BusFactoryCreateUsingAzureServiceBuscfg IServiceBusHost host cfgHostConfigurationGetConnectionStringAzureServiceBus hostConfig var managementEndpoint cfgManagementEndpoint cfgReceiveEndpointexamplemessageendpoint ec ecConsumerExampleMessageConsumercc ccUseConcurrentMessageLimit managementEndpoint examplemessageendpoint private void ConfigureMassTransitIServiceCollectionConfigurator serviceCollection serviceCollectionAddBusCreateBus serviceCollectionAddConsumerExampleMessageConsumer serviceCollectionAddRequestClientSetConcurrencyLimit Make a request using the RequestClient to change the concurrency limit to await requestClientGetResponseConcurrencyLimitUpdatednew Id examplemessageendpoint ConcurrencyLimit Timestamp DateTimeUtcNow Make another request using the RequestClient to change the concurrency limit to again Expected Behavior The concurrency limit is unchanged as is being changed from to Actual Behavior MassTransitRequestTimeoutException Timeout waiting for response RequestId xxx I think the issue might be in the ConcurrencyLimiter code The concurrencyLimit field is never updated from its initialised value This means that any time a request is made to update the concurreny limit the previousLimit is always set to the initialised value In the above example the previousLimit is set to though it should be The limitCurrentCount is The first WaitAsync on the limit reduces the limitCurrentCount to The second causes the timeout try var concurrencyLimit contextMessageConcurrencyLimit if concurrencyLimit throw new ArgumentOutOfRangeExceptionnameofconcurrencyLimit The concurrency limit must be var previousLimit concurrencyLimit if concurrencyLimit previousLimit limitReleaseconcurrencyLimit previousLimit else for previousLimit concurrencyLimit previousLimit await limitWaitAsyncConfigureAwaitfalse lastUpdated contextMessageTimestamp await contextRespondAsyncConcurrencyLimitUpdatednew Timestamp DateTimeUtcNow contextMessageId contextMessageConcurrencyLimit ConfigureAwaitfalse LogContextDebugLogSet Consumer Limit ConcurrencyLimit CommandId contextMessageConcurrencyLimit contextMessageId Proposed solution Set the concurrencyLimit after it has been updated eg try var concurrencyLimit contextMessageConcurrencyLimit if concurrencyLimit throw new ArgumentOutOfRangeExceptionnameofconcurrencyLimit The concurrency limit must be var previousLimit concurrencyLimit if concurrencyLimit previousLimit limitReleaseconcurrencyLimit previousLimit else for previousLimit concurrencyLimit previousLimit await limitWaitAsyncConfigureAwaitfalse lastUpdated contextMessageTimestamp concurrencyLimit concurrencyLimit Set the concurrency limit here await contextRespondAsyncConcurrencyLimitUpdatednew Timestamp DateTimeUtcNow contextMessageId contextMessageConcurrencyLimit ConfigureAwaitfalse LogContextDebugLogSet Consumer Limit ConcurrencyLimit CommandId contextMessageConcurrencyLimit contextMessageId Reproducible Demo Run the app Concurrency is initialised to Make a POST request to to update the concurrency to should get a Make the same request again This request will timeout Thanks PLEASE READ THE FIRST SECTION Is this a bug report Yes If you answered Yes Please note that your issue will be fixed much faster if you spend about half an hour preparing it including the exact reproduction steps and a demo If youre in a hurry or dont feel confident its fine to report bugs with less details but this makes it less likely theyll get fixed soon In either case please fill as many fields below as you can If you answered No If this is a question or a discussion please use StackOverflow or MT mailing list for questions Can you also reproduce the problem with the latest version yes Environment Please fill in all the relevant fields Operating system Docker linux centos Visual Studio version Dotnet version Core Steps to Reproduce How would you describe your issue to someone who doesn t know you or your project Try to write a sequence of steps that anybody can repeat to see the issue Create an Interface Data Contract AEvent public interface AEvent Create an Interface Data Contract BEvent inheriting AEvent public interface BEvent AEvent Configure Publish for AEvent and BEvent so that exchange type are topic IRabbitMqBusFactoryConfiguratorPublishAEvent x xExchangeType topic IRabbitMqBusFactoryConfiguratorPublishBEvent x xExchangeType topic Add Consumers for AEvent and BEvent with a routing key Publish a BEvent message with the same routing key BEvent Consumer receives the message but not AEvent Consumer Actual Behavior Did something go wrong Is something broken or not behaving as you expected Please attach screenshots if possible They are extremely helpful for diagnosing issues AEvent Exchange is bound to BEvent Exchange without any routing key Expected Behavior AEvent Exchange should be bound to BEvent Exchange with routing key in case of topic exchange but such things wont help with direct echanges However a warning about this in should be nice Thanks for you time We use servicesAddMassTransit to configure MassTransit To test the behavior if RabbitMQ service is down at startup I stopped the service and ran the net core web api The following is the result It complains about unreachable Broker nothing works during this time service and healthcheck endpoints of the api are unreachable When I start the service Kestrel initializes and service starts to work as desired Question How to initialize and run the api like normal under this situation This means controllers and healthchecks would be running Question Is there a net core sample that demonstrates health check implementation on MassTransit RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp Start RabbitMQ service RabbitMQ Connect Failed Broker unreachable adminlocalhost myapp warn MicrosoftAspNetCoreServerKestrel Overriding addresses Binding to endpoints defined in UseKestrel instead Is this a bug report YES Can you also reproduce the problem with the latest version YES Steps to Reproduce Create a typical message customer throwing exception Add UseScheduledRedelivery filter Send a message It should fail several times and then be moved on the error queue Expected Behavior MT adds a tone of useful headers to the message all starting with the prefix MT They should all appear in messages payload Headers property as well as in SQSs message attributes unless this newly added AllowTransportHeader filter states otherwise Actual Behavior Actual message on the queue has some headers only in message body and some only in message attributes Payload messageId eb f d ceb conversationId eb f ea d ce fd sourceAddress amazonsqseucentral mytmpdurablefalse autodeletetrue destinationAddress amazonsqseucentral devkrzlabplgrdrec messageType urnmessageWebAppMyMsg message payload throw sentTime T Z headers MTSchedulingDeliveredAddress amazonsqseucentral devkrzlabplgrdrec MTRedeliveryCount host Message Attributes ContentType applicationvndmasstransitjson MTFaultMessage EXCEPTION MESSAGE MTReason fault Reproducible Demo langcs cAddBusprovider BusFactoryCreateUsingAmazonSqsbfc bfcUseAmazonSqsMessageScheduler bfcHosteucentral hc hcAccessKey hcSecretKey bfcReceiveEndpointdevkrzlabplgrdrec rec recUseScheduledRedeliveryr rInterval TimeSpanFromSeconds recUseInMemoryOutbox recConsumerMyMsgConsumerprovider public class MyMsgConsumer IConsumerMyMsg public async Task ConsumeConsumeContextMyMsg context throw new ExceptionEXCEPTION MESSAGE Thank you for sending the PR If you changed any code please provide us with clear instructions on how you verified your changes work Bonus points for screenshots Happy contributing Mostly fairly simple Im not that happy with the code for custom queries but I didnt work too hard as it might be a good idea to pull it since the other providers dont support it and there are other ways of loading related data Tests are green Relates to Currently the EntityFrameworkSagaRepository is based on Entity Framework Core and there are a few breaking changes Its not possible to use this in a project based on Entity Framework Core x However it shouldnt be difficult to take this code and update it to x probably since its compatible again with NET Standard Id suggest adding a new project and keeping the project around as Im sure many people are not yet ready to move to Id like to create this issue for any discussion related to this if thats okay Related Create extension methods for the registration configurator invoked via the AddMassTransit container extension method for the supported saga repositories so that they can easily be configured for the configured sagas including state machine sagas This would configure the persistence components in the container so that they are properly resolved as the endpoints are configured Should support an easy way to say for all my sagas use this and let the registration sort it out generics vs explicit registrations etc Storage Engines In Memory NHiberate Entity Framework MongoDB Redis Marten DocumentDb Dapper Azure Session State Repository Changes Migrate the existing implementations to a new set of saga repository interfaces ISagaRepositoryContextFactoryTContext Used to created a SagaRepositoryContextTContext for each received message ISagaConsumeContextFactoryTContext TSaga TMessage Used to create a SagaConsumeContextTSaga TMessage for a saga instance that has been loaded from storage or created by an initiating message ISagaQueryContextFactoryTContext TSaga TMessage Used to create a SagaQueryContextTSaga TMessage for a message to query the repository ISagaRepositoryTSaga Should remain mostly unchanged but would have a standard implementation that uses the above interfaces to manage the repository interaction and focus purely on the saga behavior details and dry up the saga repositories Bonus Features Use a bus observer to connectdisconnect database connections for saga repositories when the bus is startedstopped so that a failing connection might stop the bus from starting Possible syntax may include all within the configuration block cs namespace NewRegistration public static class Program public static void Main builderAddMassTransitcfg see below Configure the saga for an inmemory repository cs cfgAddSagaSimpleSaga InMemoryRepository Configure using entity framework cs cfgAddStateMachineSagaMyMachine MyInstance EntityFrameworkRepositoryef efConnectionlocalhost testdatabase efSomethingElse Updated Changed to shorter syntax Thoughts Is this a bug report Yes Can you also reproduce the problem with the latest version Yes Environment Operating system Windows Core Visual Studio version Dotnet version NET Core Steps to Reproduce Write your steps here Create Turnout endpoint with TurnoutEndpoint extension Set PartitionCount on ServiceConfigurator to Create multiple messages Expected Behavior The total amount of concurrent messages being handled Actual Behavior The actual amount of concurrent messages being handled First I thought this would be my processor count but thats actually Reproducible Demo A demo would require an active Service Bus instance from Azure The code is pretty simple Just add one or more calls to TurnoutEndpoint and add messages to the queue Support simple URNstyle addresses for resolving send endpoints which use the current host rather than requiring it to be specified explicitly Examples include queueinputqueue or topicOrderStatusUpdates Can also include query parameters such as durablefalse autodeletetrue Add extension methods which can be used to build the URI to resolve a send endpoint for the transport RabbitMQ x Support exchangename endpoint name x Support queuename endpoint name public static TaskISendEndpoint GetSendEndpointthis ISendEndpointProvider provider string exchangeName ExchangeType exchangeType default bool durable true bool autoDelete false bool bindQueue false string queueName default Azure Service Bus x Support queuename Support topicname public static TaskISendEndpoint GetSendEndpointthis ISendEndpointProvider provider string queueName default string topicName default x ActiveMQ x Support queuename x Support topicname x Amazon SQS x Support queuename Support topicname 