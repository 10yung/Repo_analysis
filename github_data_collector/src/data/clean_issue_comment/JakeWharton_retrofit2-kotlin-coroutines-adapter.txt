When an error occurs on Deferredawait the thrown error stacktrace is not showing any indication of the urlmethod that was actually called Exception in thread main retrofit HttpException HTTP Not Found at comjakewhartonretrofit adapterkotlincoroutinesCoroutineCallAdapterFactoryBodyCallAdapteradapt onResponseCoroutineCallAdapterFactorykt at retrofit OkHttpCall onResponseOkHttpCalljava at okhttp RealCallAsyncCallexecuteRealCalljava at okhttp internalNamedRunnablerunNamedRunnablejava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava The code that produces it is this kotlin import comjakewhartonretrofit adapterkotlincoroutinesCoroutineCallAdapterFactory import kotlinxcoroutinesDeferred import okhttp OkHttpClient import okhttp ResponseBody import retrofit Retrofit import retrofit httpGET suspend fun main createService MyServiceclassjava run await fun T createServicebaseUrl String clazz ClassT T val httpClient OkHttpClientBuilderbuild val retrofit RetrofitBuilderbaseUrlbaseUrl for coroutines deferred addCallAdapterFactoryCoroutineCallAdapterFactory clienthttpClientbuild return retrofitcreateclazz interface MyService GETblabla fun run DeferredResponseBody I am thinking here of a couple of alternatives attach the call as a field in HttpException create an exception that implements CopyableThrowable as suggested here Any other suggestion CoroutineScopeDispatchersIOjoblaunch request AppredditApigetTopafter en withContextDispatchersMain try val response requestawait if responseisSuccessful val news News responsebody Do something with response eg show to the UI else catch e HttpException catch e Throwable eprintStackTrace buttonsetOnClickListener View requestcancel jobcancel I want to ask I called the url to server side And then called cancelWould the work on server side be cancelled too by cancelling the job Because thats what I want OR should I uncomment requestcancel part Is there a way to handle exceptions from Retrofit We often get these ClassCastExceptions in the await call interface Api GETapiconfig fun getConfigAsync DeferredResponseString launch UI try val response apigetConfigAsyncawait doSomethingresponse catch e Exception Timberee Exception javalangClassCastException kotlinResultFailure cannot be cast to retrofit Response at comexampleSetuploadConfig invokeSuspendSetupkt at kotlincoroutinesjvminternalBaseContinuationImplresumeWithContinuationImplkt at kotlinxcoroutinesDispatchedTaskrunDispatchedkt at kotlinxcoroutinesschedulingCoroutineSchedulerrunSafelyCoroutineSchedulerkt at kotlinxcoroutinesschedulingCoroutineScheduleraccessgetSchedulerNamepCoroutineSchedulerkt at kotlinxcoroutinesschedulingCoroutineSchedulerWorkerrunCoroutineSchedulerkt here is my code class HelloRepositoryapi HelloApi suspend fun getHello Logestart thread id ThreadcurrentThreadid val hello apigetHelloawait Logeend thread id ThreadcurrentThreadid class HelloUseCaserepository HelloRepository fun executeonCompleteHello Unit Job job Job CoroutineScopeDispatchersMain joblaunch onCompleterepositorygetHello return job class ViewModel execute on activity create fun getHello jobs helloUseCaseexecute And then cancel the job on actvitiy destroy class Activity onDestoy jobsforEach itcancelChildren itcancel the log App on launch start thread id end thread id the log app on relaunchpress back key and click app shortcut start thread id end thread id Why the Thread is different first launch and then next launch JakeWharton As I understand callenqueue dispatches request calling to retrofit internal mechanism it works async and we get callbacks But it is a coroutinesadapter and coroutines are an async framework itself It looks like one async framework use another one Can we just use callexecute and return Deferred but of course keep in mind to launch it in BG dispatcher Also there is a problem to handle errors for example occurred in Interceptors And we cannot catch those within coroutines It just crash the application comsampleapp EAndroidRuntime FATAL EXCEPTION OkHttp Dispatcher Process comsampleapp PID javalangError javalangException Token exception at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava Caused by javalangException Token exception at comsampleappinterceptorsTokenInterceptorinterceptTokenInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at comsampleappinterceptorsSentryInterceptorinterceptSentryInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp RealCallgetResponseWithInterceptorChainRealCalljava at okhttp RealCallAsyncCallexecuteRealCalljava at okhttp internalNamedRunnablerunNamedRunnablejava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava The call adapter crashes with an KotlinNullPointerException when a Void response type is used kotlinKotlinNullPointerException at comjakewhartonretrofit adapterkotlincoroutinesCoroutineCallAdapterFactoryBodyCallAdapteradapt onResponseCoroutineCallAdapterFactorykt at retrofit OkHttpCall onResponseOkHttpCalljava at okhttp RealCallAsyncCallexecuteRealCalljava at okhttp internalNamedRunnablerunNamedRunnablejava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava None I configured Retrofit like this object RetrofitFactory fun makeRetrofitService RetrofitDownloadAPIService val okHttpClient OkHttpClientnewBuilder connectTimeout TimeUnitSECONDS build return RetrofitBuilder baseUrlBASEURL addCallAdapterFactoryCoroutineCallAdapterFactory clientokHttpClient buildcreateRetrofitDownloadAPIServiceclassjava and then tried to catch SocketTimeoutException like this try val request retrofitBuildServiceservicedownloadPDFcodeType uuid val response requestawait if responseisSuccessful if responseheadersgetContentTypeequalsPDFCONTENTTYPE return writeToFileresponsebody else val responseText responsebodystring JSONParserjsonErrorParserresponseText else throw ResponseExceptionresponsecode catch steSocketTimeoutException throw NetworkExceptionste but nothing happened May be I did something wrong or there are not way to do timeout Thank you None Without depending on a ridiculously massive library