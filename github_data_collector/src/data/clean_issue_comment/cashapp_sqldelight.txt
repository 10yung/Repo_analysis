 Use absolute paths for database generated source directory I couldnt find relevant docs or example of usage SqlDelight with coroutines and Flow in Android leads to Found similar solution for Room not to use GlobalScope use singlethread scopes for SQLite operations val driver SqlDriver AndroidSqliteDriverDatabaseSchema context testdb val database Databasedriver val userQueries UserQueries databaseuserQueries val dbContext newSingleThreadContextDB CoroutineScopedbContextlaunch userQueriescreateUserTable userQueriesselectAlladdListenerobject QueryListener override fun queryResultsChanged val result userQueriesselectAllexecuteAsListtoString CoroutineScopedbContextlaunch logresult log into TextView on Main Thread Then Ive tried to wrap listener into Flow by coroutinesextensions Listener tries to make a query before table created and therefore crashes Is there an example with Flow Should I pull request note about singlethread scope usage need into docs Thank you for any help sounds as if sqldelight was supposed to deterministically build but we get diffs in every sqldelight generated file between two devs both running linux and equal Dockers In fact using or not the Docker container makes no difference on the respective machines but somehow we have a huge diff between the two machines The code is this commit and the diff is this App is not running after updating version to from Getting this error NoSuchMethodError comsquareupjavapoetClassNamereflectionNameLjavalangString Tried Rebuild project restart studio restart pc Android Studios automated memory analysis reported a leak of MB in the IntelliJ plugin Unfortunately I do not know which version of the plugin had this leak We only know that the leak was from the static field holding a reference to a disposedclosed project ROOT Static field comsquareupsqldelightcoreSqlDelightFileIndexCompanionindexes objects B B MB javautilLinkedHashMap B MB javautilLinkedHashMapEntry B MB comintellijopenapimoduleimplModuleImpl disposed B MB comintellijopenapiprojectimplProjectImpl disposed This is a feature request to improve type inference The below creates a function where the wingsuit parameter is a boolean as defined in the table creation query SELECT FROM exit WHERE wingsuit wingsuit AND wingsuit This however creates a function where the wingsuit parameter is a long SELECT FROM exit WHERE wingsuit AND wingsuit wingsuit If I specify column wingsuit as type Boolean in my table creation query then I expect that all generated functions will expect Boolean The latter query Id expect to be more performant than the former This issue is moot if sqlite recognizes the chance for optimization automatically Both queries are pareddown versions of larger compound queries Steps to reproduce Create an inline class kotlin inline class Idval value String Create a mapper kotlin object IdColumnAdapter ColumnAdapterId String override fun decodedatabaseValue String Id return IddatabaseValue override fun encodevalue Id String return valuevalue Add this sq file sql CREATE TABLE USER id TEXT select SELECT FROM User Insert and run the code kotlin dbUserQueriesselectexecuteAsList Error Log javalangClassCastException comexamplesqldelightcrashId cannot be cast to javalangString at androidappActivityThreadperformLaunchActivityActivityThreadjava at androidappActivityThreadhandleLaunchActivityActivityThreadjava at androidappservertransactionLaunchActivityItemexecuteLaunchActivityItemjava at androidappservertransactionTransactionExecutorexecuteCallbacksTransactionExecutorjava at androidappservertransactionTransactionExecutorexecuteTransactionExecutorjava at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNative Method at comandroidinternalosRuntimeInitMethodAndArgsCallerrunRuntimeInitjava at comandroidinternalosZygoteInitmainZygoteInitjava Caused by javalangClassCastException comexamplesqldelightcrashId cannot be cast to javalangString at comexamplesqldelightcrashappUserQueriesImplselect invokeTestDbImplkt at comexamplesqldelightcrashappUserQueriesImplselect invokeTestDbImplkt at comsquareupsqldelightQueryexecuteAsListQuerykt at comexamplesqldelightcrashMainActivityonCreateMainActivitykt at androidappActivityperformCreateActivityjava at androidappActivityperformCreateActivityjava at androidappInstrumentationcallActivityOnCreateInstrumentationjava at androidappActivityThreadperformLaunchActivityActivityThreadjava at androidappActivityThreadhandleLaunchActivityActivityThreadjava at androidappservertransactionLaunchActivityItemexecuteLaunchActivityItemjava at androidappservertransactionTransactionExecutorexecuteCallbacksTransactionExecutorjava at androidappservertransactionTransactionExecutorexecuteTransactionExecutorjava at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNative Method at comandroidinternalosRuntimeInitMethodAndArgsCallerrunRuntimeInitjava at comandroidinternalosZygoteInitmainZygoteInitjava It might be due to the let check not executed as its just returning directly from cursorgetString I made a reproducible repo to check easily If I have a table CREATE TABLE MigrationTest test INTEGER NOT NULL and run generateSchema db is correctly generated If I then create sqm and put ALTER TABLE MigrationTest ADD COLUMN test INTEGER NOT NULL and run generateSchema db is correctly generated If I then run verifyMigration nothing fails If I delete sqm and run verifyMigration nothing fails I tried a bunch more permutations that I thought would fail but I cant get verifyMigration to actually fail Am I doing something wrong I ran into two problems trying to follow the instructions at First it does not seem to mention the sqldelight closure that is required sqldelight HockeyDb packageName comexamplesqldelighthockey Without this I cannot get any code to generate Also this statement seems misleading From this SQLDelight will generate a Database Kotlin class Given that the file above it is identified as srcmainsqldelightcomexamplesqldelighthockeydataPlayersq it seems like this will generate a Player class not a Database class Once I got past those two hiccups I was able to get SQLDelight rocking in a KotlinJVM project When running a build scan I noticed two API deprecations Property outputDirectory is annotated with PathSensitive that is not allowed for OutputDirectory properties Type SqlDelightTask nonproperty method pluginVersion should not be annotated with Input 