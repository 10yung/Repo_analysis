Is there a nicer way to declare Carousel with MvRx than having override fun epoxyController simpleControllerviewModel state val list listOfa b c d carousel idcarousel numViewsToShowOnScreen f withModelsFromlist BasicRowModel idit titleit Using RedeliverOnStartup all subscriptions are fired again when the activityfragment is resumed regardless of the previous values Thats a waste of CPU if the state wasnt updated in background Id expect subscriptions to fire only if the values changed or if the activityfragment has been recreated I wanna implement the monthly calendar view similar to Google Calendar using MvRx and Epoxy Unfortunately the regular GridLayoutManager doesn t work because I can set there the number of columns VERTICAL or the number of rows HORIZONTAL Whats in your opinion the best way to solve it Shall I write my own LayoutManager Will it work without a problem with Epoxy Shall I use nested RecyclerView in RecyclerView Will it work with MvRx and Epoxy I could also go with a row for the full week days view looking like cells but actually it will be one single view I shouldnt use MvRx and Epoxy for that cause it will be overengineered monthlycalendar facing crash with version alpha You must specify a viewModelConfigFactory in the MvRx object I want to use Koins extension functions for viewmodels injections Is there a way not to write MvRxViewModelFactory and use all the advantages of Koin Its not very convenient to manually inject all of the dependencies into viewmodel through Factory Adding support for the Navigation Graph is a little tricky The issue you run into is cause we need the navigation controller and so this means when restoring from process death the fragments are restored in the activityonCreate super before the activity has inflated its content So the NavigationController is not always accessible in FragmentonCreate When not restoring from process death the existing ViewModel delegates method of creating the ViewModel like fragmentViewModel works fine For now my current workaround is to remove the lifecycle aware lazy and use Lazy I think it should be possible to make navigation ViewModel delegate autosubscribe by delaying the subscription until onStart when the NavigationController is not yet accessible I still need to add some CI tests but I thought I would open the PR now to get some feedback on my current approach and if it makes sense to have navigation as an addon module Testing of Async in viewmodel constructor with synchronous schedulers Hi Id like some pointers on testing From what I can see I can jump start the view model with intial state which is grear However given I call some async rx stuff in the view model constructor and usual recommendation to have synchronous schedulers swapped in for testing wouldnt this mean that I can never assert AsyncLoading Since Loading is emitted synchronously so is then Success now ctor is exited and now I can test the state observable meaning atleast I would miss Loading Unless I can swap out the state store observable somehow to cache everything so I can assert it First of all thanks for making public and maintaining MvRx and now MvRxLauncher Trying to launch MvRxLauncherActivity throws missing class exceptions on the dex path The missing class varies after rebuilding Sample stacktrace javalangClassNotFoundException Didnt find class comjumionvcustomNetverifyCustomFaceScanPresentera on path DexPathList zip file dataappappPackagezHYXyaLpJSqh m NvQzKRwbaseapk nativeLibraryDirectories dataappappPackagezHYXyaLpJSqh m NvQzKRwlibarm dataappappPackagezHYXyaLpJSqh m NvQzKRwbaseapklibarm v a systemlib productlib For more reference this was tested on a multimodule project with a structure like the following app featureA app Depends on mvrx and mvrxlauncher Theres just one MvRxFragment that lives in featureA I was able to fully remove kotlinreflect without changing any functionality annotation processors or separating PersistState to its own module It also doesnt rely on Kotlins Metadata annotation at all These were all trivial except for PersistState I tried a few methods including using the kotlinxmetadatajvm library which is significantly smaller than kotlinreflect I got it to work but was able to remove the need for even that The comments in PersistStatekt should be clear enough to understand what it is doing If it is not let me know and I can add clarifying details rossbacher This seems to work with proguard I added a keystore to the counter app and ran proguard on it and it still worked You are the expert so please let me know if there are any concerns here The only thing this relies on is the copydefault static function and componentN functions to exist and have their original name I think this will also make redundant App Size kb App with AppCompat w RxJava RxAndroid w MvRx kotlinreflect w MvRx kotlinmetadatajvm w MvRx this change Thanks to ZacSweers for pointing me in the direction of copydefault and the property mask Fixes have some production code like below call setState n first then call withState data class TestStateval dummy Int MvRxState class TestViewModel BaseMvRxViewModelTestStateTestStatefalse fun test setState LogwMvRxViewModel setState dummy Threadsleep copydummy dummy setState LogwMvRxViewModel setState dummy Threadsleep copydummy dummy withState Threadsleep LogwMvRxViewModel withState itdummy setState LogwMvRxViewModel setState dummy Threadsleep copydummy dummy output may be any of below WMvRxViewModel setState WMvRxViewModel setState WMvRxViewModel setState WMvRxViewModel withState WMvRxViewModel setState WMvRxViewModel setState WMvRxViewModel withState WMvRxViewModel setState WMvRxViewModel setState WMvRxViewModel withState WMvRxViewModel setState WMvRxViewModel setState so is this the intended behavior