Hi Maik It would be nice to get some instructions to build rlsl from scratch rlsl depends on the nightly compiler and therefore requires a specific version of it I dont want to update the nightly compiler every week or so just to make rlsl build The problem is targeting specific nightlies is a bit difficult with rustup I am currently experimenting with a custom CI and an install script that downloads the artefacts for the user spirv differentiates between runtime arrays and static arrays Slices cant be supported in rlsl at the moment Things like len on a static array currently maps to Slicelen in Rust which cant be expressed Const generics arent a thing yet Because slices are not supported we need to abstract over arrays with generics fn fooarr impl Arrayf Have you given any thought on how the binding model from the CPU part of rust could look like I have been thinking about this and wanted to ask what would you think to have something along the lines of this on the GPU side rust spirvDescriptorLayout struct InputData spirvShaderVisiblePS diffusetextures Texture dynamic unbounded array slice spirvShaderVisibleALL someconstant u spirvInterpolants struct Interpolants color vec uv vec spirvNoInterpolation index u spirvvertex fn vertexshader input InputData Interpolants spirvOutputMerger struct OutputData spirvBlendmodeAdditive color vec spirvfragment fn fragmentshader interp Interpolants input InputData OutputData let color inputdiffusetextures interpindex Sampleinterpuv spirvShaderPipeline struct VSPSPipeline descriptor InputData blendmode OutputData vertex typeofvertexshader pixel typeofpixelshader and some code similar to this on the CPU to create and launch a draw rust fn main let sometextures VecTexture gettextures let someconstant let inputdata InputDatanewsometextures someconstant let rendertarget RenderTargetvec getrendertarget let outputdata OutputDatanewrendertarget let pipeline VSPSPipelinenewinputdata outputdata vertexshader fragmentshader cmdbuffersetpipelinepipeline cmdbufferdrawindexed One reason behind this is that I would like to have a typesafe interface between CPU and GPU maybe even go further down the road of having units of measure and types like NormalMapTexture to bind against And the other reason would be that I am really really sick of writing all that CPU binding code which is super super boring I am not attached to any particular syntax maybe you have another proposal Right now everything inside a bin file is one shader module I think this is relatively convenient but there may be better ways especially since we need to add configuration for each shader module See also What is the best way to tell rlsl which extensions should be enabled We still need to stay compatible with rustccargo Also extensions should be enabled per shader module and not the whole project That means we also need a way to make it easy to share the configuration between different shader modules Most extensions should be trivial to support All features should be enabled by default and a simple pass can check which features are currently used in a shader module and outputs an error if the extension hasnt been enabled but it used Im curious how RLSL handles vulkan extensions For example Im interested in doing some GPGPU stuff with RLSL which means Id probably want to use eg vulkan subgroups for efficient sorts and stuff Is there a way to optin to these extensions in a shader Ive already professed my excitement for RLSL in but here Id like to get a stronger idea about the kind of future you envisage for the project and the ways in which it might be able to interoperate with regular Rust code Also I apologise ahead of time if any of the following questions seem silly Im still new to SPIRV and have a very limited understanding of whats possible and what is not cargo In the README you mention that one of the goals is to support cargo could you elaborate on your plans for this In particular Im curious where the boundaries lie For example could I write a crate that may be depended upon downstream by both RLSL and rust code I can imagine it would be particularly useful to be able to use a math crate something like cgmath both in regular cpu code and in RLSL Further is it necessary to have separate specific files for RLSL code Eg could I one day write my RLSL shaders within my regular rs rust modules perhaps using a decorator of some sort to indicate entryexit points compute shaders I would love to be able to use something like RLSL for doing general compute is this something you would like to see at some point I think one of the things I love about the idea of RLSL is the reduction of friction between programming for the CPU and programming for the GPU Ive had a dream for a little while that one day we might be able to do something like pass a closure to a function which executes the closure in parallel on the GPU returning either a Future or the result directly I realise it is not possible to execute arbitrary Rust code on the GPU but perhaps there would be some way to constrain the kinds of functions that could be executed on the GPU using a trait of some sort that extended Fn I guess a similareasier alternative might be to pass an instance of some type that implements some GpuFn trait RLSL Rust I wonder if at some point down the track yourself and the rustlang team might be interested in including lower tier support for something like RLSL out of the box treating SPIRV as an alternative target to LLVM or something along these lines I realise Im getting way ahead of myself here but it can be fun to theorize and plant seeds Anyway thanks again for all your work on this looking forward to watching and hopefully takingpartin one day RLSL progress Hi Im making updates for Open Collective Either you or a supporter signed this repo up for Open Collective This pull request adds backers and sponsors from your Open Collective It adds two badges at the top to show the latest number of backers and sponsors It also adds placeholders so that the avatarlogo of new backerssponsors can automatically be shown without having to update your READMEmd more info See how it looks on this repo You can also add a Donate button to your website and automatically show your backers and sponsors there with our widgets Have a look here PS As with any pull request feel free to comment or suggest changes The only thing required are the placeholders on the README because we believe its important to acknowledge the people in your community that are contributing financially or with code Thank you for your great contribution to the open source community You are awesome And welcome to the open collective community Come chat with us in the opensource channel on great place to ask questions and share best practices with other open source sustainers 