Unable to call documentation on a huglocal interface because the doc OrderedDict is not initialized pyenvversions libpython sitepackageshuginterfacepy in documentationself addto for requirement in selfrequires doc outputs OrderedDict doc outputs format docselfoutputs doc outputs contenttype selfoutputscontenttype TypeError type object does not support item assignment def documentationself addtoNone Produces general documentation for the interface doc OrderedDict if addto is None else addto usage selfinterfacespecdoc if usage doc usage usage if getattrself requires None doc requires getattrrequirement doc requirementname for requirement in selfrequires doc outputs OrderedDict I have this method huggetdocumentslist def llista Returns whole list of documents docs libDocdocHeaderstoJSON for doc in globiglobmd return documents docs and returns me documentation handlers documentslist GET usage Returns whole list of documents examples outputs format JSON Javascript Serialized Object Notation contenttype applicationjson charsetutf but really the autogenerated documentation should say the port examples from marshmallow import Schema fields class TestingSchemaSchema a fieldsIntegerrequiredTrue b fieldsIntegerrequiredTrue c fieldsInteger apirouteposttest def testvalidationbody TestingSchema return True body when body is None More an edge case than a real issue if a body parameters has the exact same name as a query parameter then the body parameter will override the value For example consider this route definition with MySchema defined elsewhere python import falcon import hug from marshmallow import fields hugpost testparam routeparam statusfalconHTTP def myroute request response param fieldsStrdescriptionA param param fieldsStrdescriptionAnother param body MySchema printparam printparam If I call it like that json POST testfirstvalueroutesecondvalue bodyparam a body param value param overwrittenvalue then the output will be firstvalue overwrittenvalue Even if MySchema does not define param stripping param key from the body the value gets overwritten This may not at all be a hug bug but thought Id mention it Its a super weird behavior and not necessarily hugs but maybe partly Basically Ive had hug going for a while on a few of my APIs Ive been doing stuff like this hugpostendpoint function foobar bazmeh somethingelse return stuff Well using JSON you can pass in extra parameters and it wont bail with unexpected keyword argument I had accidentally been doing that for a while without realizing it Then I thought what if I put timers on my endpoints hugpostendpoint statsdtimerfoo function foobar bazmeh somethingelse return stuff And you do have to get the statsdtimer decorator in that order otherwise it wont work Now with the statsdtimer decorator its suddenly picky about unexpected arguments I ended up breaking a few things this way Oops Now statsdtimer is gone at least for now i have this simple API class python hugobjecthttpmethodsinfosets class InfosetCollection def initself infosetstore selfinfosetstore infosetstore def getself req resp we need to retrieve all the infosets available return selfinfosetstorelist def postself req resp infoset reqdata return selfinfosetstoresaveinfosetinfoset where infosetstore is the real manager of the infoset resource Of course Hug choke on this since it tries to create instances of infosetCollection without any infosetstore Is there a clean way out of this to decorate real classes that are not just a bunch of stateless methods A global is not an option globals lead to premature creation of resources side effects at import time and all manners of evil The current class allows me to inject an infosetstore for tests delay configuration of infosetstore till it is really needed and a lot of other good things I looked into a few examples and saw the use of directive but will this not quick the ball just one step further into the directive that would also need to access a global or eagerly load its configuration Is there a solution for Hug to create its API class instances later than at importinit time pass a factory function that would be called once when the API is used or take control of the instance creation Thanks a lot for your time and the HUG project Hi timothycrosley Ive been discussing the idea of converting python type annotations to marshmallow fields automatically with my colleagues a lot recently and we think it might be quite handy in hug In short this idea consists of two major parts Convert type annotations for builtin types into marshmallow fields automatically Deprecate almost all of the hugs validation logic and delegate that to marshmallow by making it a dependency Why Allow seamless integration with type checkers Reduces the amount of boilerplate Lets look at these two points more closely In Ive introduced args argument to routing decorator that allows writing type annotations for arguments in handlers While that was a step in the right direction it only offers allornothing approach it is possible to either describe marshmallow fields for validation in args and Python type annotations in handler signature or put marshmallow fields directly in handler signature This leads to increased amount of boilerplate for handlers that have complex signature and want to make use of type checkers Consider the following example python import hug from marshmallow import fileds hugget argsfoo fieldsInteger bar fieldsString def handlerfoo int bar str return baz Note how user is forced to write parameters both in args argument for decorator and at the same time in handlers signature And they are seemingly disconnected from each other nothing prevents from putting int type annotation for the bar argument and there is no check against it at this point The other major advantage of automatic conversion is that most of the time users only need simple validation which can be easily described with type annotations In the example above both of the fields and their arguments or the lack thereof can be easily deduced from type annotations and there should be no need for args at all However if user needs some kind of special validation say passvalidateLengthmin to fieldsString then he can easily do so via args argument only for those arguments that need it and fields from args will take precedence over automatically deduced fields How Here are the rules for converting Python type annotations to marshmallow fields most of them are absolutely straightforward Python type Marshmallow field int Integer float Float str String bool Boolean datetimedatetime DateTime datetimetime Time datetimetimedelta TimeDelta datetimedate Date decimalDecimal Decimal Any Raw Collections are converted as follows Python type Marshmallow field list ListRaw List builtintype Listmarshmallowfield dict DictRaw Dict builtintype builtintype Dictkeysmarshmallowfield marshmallowfield Wrapping a type in Optional is equivalent to passing allownone to Field constructor Default value for an argument will be passed as missing to the Field constructor Complex objects described with schemas such as POST body are a little bit more tricky Much of the inspiration for this suggestion comes from a fantastic library marshmallowdataclass so I might go as far as to suggest to ask users to describe their schemas using dataclasses and then convert these dataclasses using marshmallowdataclass But that might be a little bit too much at this point so we can resort to annotating body as Schema as usual either in signature or in args Why deprecate hug validation layer Because it brings nothing to the table There is no need for additional validation logic if marshmallow does a wonderful job and has great API Moreover consistency in validation tools allows for better integration with some tools for autogenerating API documentation such as Swagger Here is how it can go number floatnumber decimal boolean uuid have obvious alternatives in marshmallow text is equivalent to String multiple is roughly equivalent to List It can be a represented as a subclass to List that can also accept a single value and transform it to a list smartboolean is equivalent to Boolean inlinedictionary is equivalent to Dict commaseparatedlist can be created out of List I have a snippet ready And so on The point is not to remove hug validation logic but rather to offer alternatives made with marshmallow Risks One major risk I see is that some bits of validation logic require marshmallow and its not released fully yet Although there is no problem starting development and hopefully when it ends marshmallow will be released There is also a risk of making backwardsincompatible changes At this point I see nothing that can lead to this but the possibility is real This is a lot to process so please tell if you need more details andor clarification I would be glad to hear whether youd be interested in such a feature If a function has an output parameter and it is exposed over a CLI an output option appears but setting it to different values like html or hugoutputformatprettyjson does nothing That option should not be exposed or it should work like a switch with multiple values described from the help maybe Hello Im trying to leverage rapidjsons validator in my application and the validator wants the raw text of the body Within hugtests environment the body is already in an object and I would prefer not to jsondumps this to get it to work in a hugtest call whereas running the server for real I can get the raw body from the request object So my ask is to include a mock request object in the hugtest framework that at least includes the raw text payload body when an http method flake docstrings is going to involve lines of changes Lets make that one a separate issue and PR