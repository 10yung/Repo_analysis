Hi there thanks for the awesome library We are having some issues compressing normal maps heres an example Input normal map original Compressed normal map exampleunpackedrgbBC M RGBA We tried some different parameters but could not manage to make the results significantly better Then we found the following snippet in the readme For tangent space normal maps you should separate X into RGB and Y into Alpha and provide the compressor with bitpixel input images Or use the separatergtocoloralpha command line option which does this for you The internal texture format that Basis Universal uses ETC S doesnt handle tangent space normal maps encoded into RGB well You need to separate the channels and recover Z in the pixel shader using zsqrt x y For reasons beyond our control this is likely not something we are capable of doing in the near future But we thought it might still be worthwhile to ask and get confirmation Is it possible to improve the quality of the compressed normal map without splitting and shader reconstruction ie are we missing some parameter or using the library the wrong way Or do we have to adapt our pipeline to split and reconstruct if using basis for normal maps We are thankful for answers have a pleasant day Reproducing Using latest basisu from git ee ee e built with latest Visual Studio release build Compress the original normal map using basisu originalpng q normalmap complevel mipmap miprenorm Then decompress using basisu originalbasis Heres a snippet of the code case transcodertextureformatcTFRGBA return sizeofuint t case transcodertextureformatcTFRGB case transcodertextureformatcTFBGR case transcodertextureformatcTFRGBA return sizeofuint t The is bogus The reason this is apparently not causing any problems is because lowleveltranscodertranscodeslice ignores its outputblockorpixelstride parameter which was set from the output of the subject function for all of the uncompressed formats using instead sizeofuint t or sizeofuint t We would like to pack normal maps using GGGR which is more standard than the currently supported RRRG using separatergtocoloralpha flag Added a general swizzle operator for maximum happiness The DFS file signature is initialized by const uint t OUTFILEMAGIC TEXC for which gcc flags warning multichar character constant I have no idea in what order the compiler would place the characters when initializing OUTFILEMAGIC which is possibly the point of the warning Whether the T becomes the highorder or loworder byte who knows The value is written out to the file as little endian What byte sequence is meant to appear in a DFS file TEXC or CXET Is there any documentation for this file format This means that we now support all formats supported by stbimage for the purpose of transcoding This is mostly valuable for JPEG data since glTF content can have PNG or JPG images and TGA data since this is a common image interchange format for realtime graphics While it was technically possible to keep lodepng for saving images it didnt seem like theres a strong reason to do so Note that stb libraries are compiled as part of stbimagecpp to reduce compiletime impact on basisuenccpp For projects implementing support for Basis Universal data without relying on a basis wrapper file eg via KTX it will be necessary to expose additional features of the lowlevel transcoder Currently the WASM transcoder only accepts a basis file as input for example In some comparable changes are proposed to enable libktx to access the lowlevel decoder The PR is specific to libktx and doesnt expose anything new on the WASM transcoder yet but is similar in its goals I would like to eventually reach a state where multiple libraries can use the lowlevel transcoder libktx for complete KTX support a lightweight JS implementation for the web and perhaps a lightweight native implementation like tinyktx richgel would you be open to exposing additional APIs Or am I asking for the wrong thing and I should be considering a different highlevel API rather than direct access to the lowlevel transcoder Open to feedback on how to approach this thanks On Windows basisuh does define ITERATORDEBUGLEVEL when compiling for debug Since VCs default level is this leads to a large number of errors from the compiler about an ITERATORDEBUGLEVEL mismatch when you try to use basisu alongside other code The comment where this is set says you need to disable iterator debugging or the encoder is unusable What exactly are the problems it causes I have defined BASISUNOITERATORDEBUGLEVEL to prevent changing the level and in my very limited experiments the encoder seems to be working okay Lines in basisuenccpp use stdmin basisenccpp includes windowsh prepended by a define WINDOWSLEANANDMEAN which somewhere includes minwindefh This defines a macro min with which the c preprocessor helpfully replaces the min in stdmin causing the compile to fail How can you compile it Are you using a different version of Windows Kit Hi In order to compress images in browser we compile the encoder utility wholesale to wasm and invoke the applications main function from Javascript Thanks to emscripten we can write the input files to the wasm inmemory filesystem and then read back results once compression is complete This is surprisingly simple to accomplish write the input file basisuFSwriteFileinputpng new Int Arraybuf perform compression basisucallMain inputpng nomultithreading mipmap yflip read back the compressed data var result basisuFSreadFileinputbasis encoding binary buffer This solution is likely just a stopgap till the planned basisuniversal code reshuffle is released which will expose the compression code as a library Please note the following about this makefile it has only been tested on Macos multithreading should be disabled which doesnt work out of the box and we havent investigated further trap mode clamp was required and we havent investigated potential consequences though resulting compressed files are binary identical to natively compressed files Thanks