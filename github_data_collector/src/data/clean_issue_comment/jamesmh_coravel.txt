Describe the bug In my net core web api project Im using queueQueueBroadcast to publish events Ive added logging to my IListenerMyEvent implementation in HandleAsync method ConsummationDelay was set to Every time if I trigger api call which trigger queueQueueBroadcastnew MyEvent one by one only one of published events will be really consumed and fired Where Coravel can miss others I dont know Any ideas Affected Coravel Feature Queuing Event Broadcasting Expected behaviour HandleAsync should fire for each published events at max ConsummationDelay time Describe the bug Minor issue in docs copywrite instead of copyright in DocsV docsMailingREADMEmd Affected Coravel Feature Documentation Expected behaviour Correct spelling Hi Not sure if this is more of a feature request or a question but anyway With QuartzNET and Hangfire arguments can be passed to jobs How would we achieve something similar to this with Coravel A use case for this would be a daily email report type job except the invocable is registered twice but with a different argument perhaps indicating which mailing list to use and one mailing list is for AM while the other is AM The problem As part of an acceptance test I need a way to determine whether all tasks within the queue have already been consumed or not before moving on to the next step ie checking the sideeffects of what the listener has done given the event in the queue Describe the solution youd like The simplest possible solution expose taskCount as IQueueCount Describe alternatives youve considered Considered making Queue as a component you can attach listeners to so you can listen to events being added and removed etc but seems overkill for this simple use case Since some reason I should use assembly with strong name Describe the bug TypeLoadException Could not load type MicrosoftAspNetCoreHostingInternalHostingEnvironment from assembly MicrosoftAspNetCoreHosting Version Cultureneutral PublicKeyTokenadb ddae when using aspnet core i cant add the email feature Affected Coravel Feature Mail Expected behaviour Add Mail Describe the bug Im using following code public void ConfigureIApplicationBuilder app IHostingEnvironment env IServiceProvider provider if envIsDevelopment appUseDeveloperExceptionPage appUseMvc var cache providerGetServiceICache cacheRememberfoo BigDataLocalFunction TimeSpanFromSeconds providerUseSchedulerscheduler schedulerSchedule cacheRememberfoo BigDataLocalFunction TimeSpanFromSeconds EveryFiveSecondsPreventOverlappingtest private static int Counter private int BigDataLocalFunction return Counter Which means my cache entry is valid for seconds but with a scheduler which runs every seconds the cache entry is updated When accessing the cache via return await cacheGetAsyncintfoo in a Controller method I sometimes receive a NoCacheEntryException anyway Affected Coravel Feature Im using version of Coravel and it affects Scheduling and Caching Expected behaviour When setting expire time of a cache entry higher than a scheduler timespan I would not expect an NoCacheEntryException but I would expect a correct result The GetAsync method should everytime return a valid result seamlessly In general I want to invalidate my cache after a particular timespan But even if it is invalid it should return at least the old value until it is refreshed with a new value by for example the scheduler Global Scheduled tasks This might be a broader question to just using Coravel as a task scheduler How would schedule tasks that need to run once a for the application but the service is actually running on more than one node in a loadbalanced environment Possible solution When the first node gets that Invoke it sets a record in the database that the task was started Subsequent tasks that get invoked todo the same daily job then stops after determining that another process is handling the task Potential issue Race condition if all tasks fire the exact same moment Retry reinvoke if the task did not complete successfully and need to be picked up by another nodeservice I would like to set the max queue size and I would maybe also like to see how long an item has been queued for Is this possible So lets say we have a moderately heavy job that imports something to our db every minutes Occasionally we are asked to run this manually because the minutes wait is just to long using Coravel we could then trigger this using the Queue but if were unlucky this would coincide with the scheduled run every twenty minutes which would cause some issues in legacy exports we have Can this overlap be detected and avoided As an alternative it would be nice if we could schedule a one off run of an invocable like schedulerScheduleMyInvocableOnce That way it could take the overlappingprotection into account and share the same thread as the regular execution 