 x i can be in this case and casting it to usize will give usize max The addition with linestart will cause an arithmetic overflow Wrapping add should be used Also some minor cleanups plus fixes to compound glyph transforms Note that pointmatching is not implemented yet What should I do with the output of cargo build release I only get a libfontrsrlib Parsing the hhea table to get some general information about the font MaxAscent MaxDescent LineGap AdvanceWidthMax As I understand it this is needed to get the distance between two baselines MaxAscent MaxDescent LineGap When the CMap tests are run against RobotoRegularttf from fuchsiagarnetbinfontsthirdparty fails with the following message fontteststestcmapformat stdout thread fontteststestcmapformat panicked at assertion failed left right left right srcfontrs note Run with RUSTBACKTRACE for a backtrace This is the first time Ive messed with conditional nostd so Im sure there are cleaner ways to get some of this stuff Very open to suggestions Id like to try using this myself I only learned after writing this that theres a nostdsafe math crate which provides safe floating point wrappers so it might be worth pulling that in to get rid of all these unsafe intrinsics calls I also changed the font tables structure from a HashMap to a BTreeMap simply because BTreeMap exists in alloc I wonder though if the map structure is needed at all It looks like its not actually used outside of the parse constructor so perhaps that forloop should just be rewritten to find and set aside each table as it goes Stable Rust now has an isx featuredetected macro which should be used to switch between SSE and fallback implementations based on runtime detection of the SSE capability Would you be interested in testing fontrs through Unicode text rendering tests I d volunteer to do the integration into the test suite on the Unicode side if somebody familiar with Rust writes a commandline tool that can be called like this pathtosomecommand fontfontsTestCMAP otf testcaseFoo render writing an SVG file to stdout like this xml xml version encodingUTF svg version xmlns xmlnsxlink viewBox symbol idFoo uni overflowvisiblepath dM L L L L L L Z M L L L Z M L L L Z M L L L Zsymbol use xlinkhrefFoo uni x y use xlinkhrefFoo uni x y svg For test cases on variable fonts your tool would be called with an additional argument for the variation settings such as variationwght wdth Initially you could ignore this The test fonts are here If you write a commandline tool that can be called as described the generated test report will look like this this this or this The Rust code has SIMD and nonSIMD versions of this conversion y as u from an f in the range to a u in the range Due to rounding errors this sometimes means that a pixel well inside a glyph ends up with an xfe value instead of xff since its floating point value is slightly less than In my Go port I embiggened the constant from to or x fffff as a float bit pattern which eliminated these central xfes See the comment at the bottom of I think that the Rust code should do the same For well formed TrueType glyph data the bounding box should contain all of the nodes However malicious data might lead to outofbounds nodes so more bounds checking is necessary for a production quality rasterizer Even with well formed data I suspect based on my Go port that the Rust version will panic at a line like selfa linestart x i as usize when the glyph being rendered has an oncurve point at the bottom right corner of the rasterization buffer You should be able to see this with the capitalI glyph from a sansserif font In my Go port I tightened this up in 