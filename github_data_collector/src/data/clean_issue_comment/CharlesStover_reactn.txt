Hello as I am getting a better understanding of how internals of ReactN works I switched from the UNSAFEcomponentWillUpdate to shouldComponentUpdate only if using React x onwards so the behavior for older Reacts is unchanged The only difference in behavior between componentWillUpdate and shouldComponentUpdate is that the first doesnt return anything while the second must return true if you want to simulate a function not been defined un users class This should ensure compatibility with React x onwards without using UNSAFEs methods Still a NOOB on TypeScript apologizes if I used improper syntax but all checks pass jsx import addReducer setGlobal useDispatch useGlobal getGlobal from reactn Initialize the global state with the value setGlobal value When the increment reducer is called increment the global value by X addReducerincrement global dispatch value globalvalue const Post props const increment useDispatchincrement const global useGlobal return Button onClick increment incrementglobalvalue it works globalvalue Button Im using Expo with a web project and a native project that are both part of the same package project repo Is there any suggested way to structure multiple reactn stores for Typescript one for the web and one for native Using globaldts you cant have multiple store type definitions it seems like The obvious answer seems to be to use Providers instead but just curious if anyone else has come across this use case I dont see documentation in the Providers readme on how to structure the typescript type definitions EDIT I also tried conditionally declaring the module by using a conditional on reactnative Platform but that didnt seem to work either This Issue serves as documentation for anticipated breaking changes in and allows community feedback to drive the development process Breaking Changes Do not reexport React from reactn Have users just import React and ReactN Componenthooks from separate packages This will help with the namespace conflicts with Component in TypeScript Remove support for reactn decorator Typing the decorator is difficult to maintain and the feature is not often if ever used Property reducersdispatchers to be moved to addPropertyReducer and usePropertyDispatch instead of sharing a namespace with addReducer and useDispatch New Features Since the decorator is removed the project can be pure TypeScript with the as MagicType happening in srcindexts Since addPropertyReducer is given its own helper function the property can be tightly coupled at the global level addPropertyReducerproperty reducer would be synonymous with addReducerglobal dispatch args property reducerglobal property args This may make some reducers easier to write useSelectorid as a simplified way to grab globalxyzmutatef Update the docs app to reflect as development occurs Rerendering of multiple subscriptions are batched Undecided Try to officialize type Reducers typeof reducers in reactnglobaldts Use a different helper function for adding reducers that dispatch other actions function reducerglobal args and function reducerglobal dispatch args should both be acceptable ways to write a reducer Forcing users to write the latter is annoying when the majority of reducers do not use the dispatch parameter This would require a verbiage change to describe reducers that dispatch and reducers that dont eg addReducer and addSaga Come up with solid verbiage for actions reducers dispatchers The concept that actions and reducers are tightly coupled is not immediately obvious to users Can the saga pattern be officialized The global state manager has a concept of building up state changes before committing them Should a commitrollback method be exposed to saga reducers to allow them to build state before finalizingcommitting it Is the desired behavior of sagas to finish multiple state changes before rerendering or should the UI rerender as the state changes and the UI rolls back as the saga rolls back Support deepnested listeners Perhaps only for objects that share an immediately prototype with Object or null ie not instances of Error etc useGlobalx y z On state change check all global subscriptions for shallow keys then check all matches for shallow key changes Implementation direction could use fleshing out Ive just started using reactn when I switch to using import React Component from reactn in all my classes where I have class FooBar extends ComponentFooProps FooState constructorprops FooProps superprops Im getting the following for error for the call to superprops Expected arguments but got Im using TypeScript If a component has be instantiated constructor has executed but not yet mounted thisupdater will be undefined If the global state is accessed in the constructor it will subscribe If it changes before mount it will attempt to update throwing an error that thisupdater does not exist Either check that thisupdater exists or prevent subscribing in the constructor if possible to differentiate react reactn When using reactn as import React Component from reactn TypeScript fails with the following Class static side typeof Form incorrectly extends base class static side propTypes WeakValidationMap undefined contextType Contextany undefined contextTypes ValidationMapany undefined childContextTypes ValidationMapany undefined defaultProps Partial undefined displayName string undefined getDerivedStateFromProps GetDerivedStateFromProps Type typeof Form is not assignable to type propTypes WeakValidationMap undefined contextType Contextany undefined contextTypes ValidationMapany undefined childContextTypes ValidationMapany undefined defaultProps Partial undefined displayName string undefined getDerivedStateFromProps GetDerivedStateFromProps Types of property getDerivedStateFromProps are incompatible Type nextProps Props prevState State prevPath string null is not assignable to type GetDerivedStateFromProps Types of parameters nextProps and nextProps are incompatible Type Readonly is not assignable to type Props Type Readonly is missing the following properties from type RouteComponentPropsRouteParams StaticContext any history location match TS class Form extends ComponentProps State constructorprops Props superprops CharlesStover do you have any idea why Any help would be appreciated In srcindexts the ReactN interface should not have Component and PureComponent defined as these are defined in the namespace in order to maintain their generics The existence of this interface property prevents class MyComponent extends ReactComponent from being used with no generics TravisCI fails to build if they are missing in the interface despite the build succeeding locally Investigate potential TypeScript version conflicts delete all node modules and try local build again Also did update and set global callback Async elsewhere 