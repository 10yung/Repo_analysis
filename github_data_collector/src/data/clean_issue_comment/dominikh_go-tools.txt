 Please make sure to include the following information in your issue report The output of staticcheck version The output of staticcheck debugversion it is fine if this command fails The output of go version The output of go env Exactly which command you ran Output of the command and whats wrong with the output Where we can read the code youre running staticcheck on GitHub repo link to playground code embedded in the issue Identifiers claimed unused but explicitly set as used should be treated as if all the things they use are actually used Right now if you have a program where a toplevel entity is falsely flagged unused a great many things will end up unused causing lintignore droppings everywhere This can be worked around with a var bar but thats not as selfdocumenting as a lintignore U on bar would be This came up with that tries to use godoc examples to show how to write unit tests using the helper console ls foogo gomod cat gomod module examplecomm go cat foogo package m import fmt func foo int return var x foo lintignore U this has a real reason func bar fmtPrintlnx staticcheck foogo var x is unused U EXIT staticcheck version staticcheck staticcheck debugversion staticcheck Compiled with Go version go Main module honnefcogotoolsv sum h JgtbtFHMiCmsznwGVTUWbgGovpVqnlf dEJTNAXeM Dependencies githubcomBurntSushitomlv sum h WXkYYl Yr qBf K EBnL mak OimBfB XUf Vl OQ golangorgxtoolsv cc af d b c sum h IGkKhmfzcztjm gYkykvuNiS kaqbCWAEWWAyf J U go version go version go linuxamd go env GO MODULEon GOARCHamd GOBIN GOCACHEhometvcachegobuild GOENVhometvconfiggoenv GOEXE GOFLAGS GOHOSTARCHamd GOHOSTOSlinux GONOPROXYmntnllcgomntnllceagainnet GONOSUMDBmntnllcgomntnllceagainnet GOOSlinux GOPATHhometvgo GOPRIVATEmntnllcgomntnllceagainnet GOPROXY GOROOThometvsdkgo GOSUMDBsumgolangorg GOTMPDIR GOTOOLDIRhometvsdkgo pkgtoollinuxamd GCCGOgccgo ARar CCgcc CXXg CGOENABLED GOMODhometvzgomod CGOCFLAGSg O CGOCPPFLAGS CGOCXXFLAGSg O CGOFFLAGSg O CGOLDFLAGSg O PKGCONFIGpkgconfig GOGCCFLAGSfPIC m pthread fmessagelength fdebugprefixmaphometvtmpgobuild tmpgobuild gnorecordgccswitches Following up from a Slack conversation which itself was a followup from The example cited is go package main import fmt func modifyi int error i return nil func f int error i return i modify i func main i f fmtPrintfi d n i On the subject of order of evaluation the Go spec says when evaluating the operands of an expression assignment or return statement all function calls method calls and communication operations are evaluated in lexical lefttoright order In this example the operands of the return statement are i and modify i The comma after return statement in the above quote is then important because the only function calls method calls and communication operations in that list of operands are is modify i Hence when i as in the first operand is evaluated is not specified And therefore its dangerous to rely on it being one value or another Hence Ians suggestion Personally I think one good approach would be a vet check that complains about statements that both read and write a variable in an unspecified order But its fairly hard to catch all possible cases of this This issue is therefore to capture that suggestion I have a code repo that includes some CGO code Because of a quirk in how we build within docker containers the go cache directory is inside the git repo Staticcheck appears to enter the go build cache and analyze the preprocessed go code in there as well which would be fine except for one file whose cached preprocessed version generates an error The error cachealpinegobegobuild a fbab fd a d b dbbac d b c de ae b dc f d package comment should be of the form Package akasim ST The top lines of the offending file Code generated by cmdcgo DO NOT EDIT line gocodepkgakasimclientgo Package akasim wraps clientside AKA functions to simulate the aka hardware package akasim import cgounsafe unsafe cgo CFLAGS I SRCDIRcgoinclude DOPENSSL cgo LDFLAGS L SRCDIRcgolib laka lcrypto the top of the original source file before cgo processing looks like Package akasim wraps clientside AKA functions to simulate the aka hardware package akasim cgo CFLAGS I SRCDIRcgoinclude DOPENSSL cgo LDFLAGS L SRCDIRcgolib laka lcrypto It appears the ST is being triggered because the package comment returned by fDocText called in stylechecklintgoCheckPackageComment line or so begins with line gocode instead of Package akasim This is admittedly a quirky build setup and I was able to work around it by moving the package comment to another file in the package that does not contain any cgo but I thought you might find it interesting since other false positives might get triggered the same way If this configuration is one you decide you dont care to worry about I totally understand Obviously one option would be to skip any processing of files in the build cache Another would be to try to detect and handle this specific problem Since you have no control over the cgo processing the only thing you could really do here is put in a heuristic to skip comments that match line go or somesuch depending on how finicky you want your regex The output of staticcheck version staticcheck The output of staticcheck debugversion staticcheck Compiled with Go version go Main module honnefcogotoolsv sum h JgtbtFHMiCmsznwGVTUWbgGovpVqnlf dEJTNAXeM Dependencies githubcomBurntSushitomlv sum h WXkYYl Yr qBf K EBnL mak OimBfB XUf Vl OQ golangorgxtoolsv a c sum h ord pqXhKRYcujhzmNg POL yEINk Mj fqWSSNG The output of go version go version go linuxamd The output of go env GO MODULE GOARCHamd GOBIN GOCACHEgocodecachealpinegobegobuild GOENVconfiggoenv GOEXE GOFLAGS GOHOSTARCHamd GOHOSTOSlinux GONOPROXY GONOSUMDB GOOSlinux GOPATHgo GOPRIVATE GOPROXY GOROOTusrlocalgo GOSUMDBsumgolangorg GOTMPDIR GOTOOLDIRusrlocalgopkgtoollinuxamd GCCGOgccgo ARar CCgcc CXXg CGOENABLED GOMODgocodegomod CGOCFLAGSg O CGOCPPFLAGS CGOCXXFLAGSg O CGOFFLAGSg O CGOLDFLAGSg O PKGCONFIGpkgconfig GOGCCFLAGSfPIC m pthread fmessagelength fdebugprefixmaptmpgobuild tmpgobuild gnorecordgccswitches Exactly which command you ran staticcheck from gocode Output of the command and whats wrong with the output see above Where we can read the code youre running staticcheck on GitHub repo link to playground code embedded in the issue see above While looking through stylechecklintgo to try to debug a false positive I came across this As far as I can tell that line just returns a string with no interesting side effects So why does it get called outside the if statement in case the line numbers change Im looking at this if stringsHasPrefixstringsTrimSpacefDocText prefix reportReportpass fDoc fmtSprintfpackage comment should be of the form s prefix fDocText THIS LINE Our analysis runner doesnt load packages from source if it doesnt have to eg because they havent changed In those cases it uses export data and cached problemsfacts However this breaks unused in wholeprogram mode because changing one package may affect the list of unused identifiers in another package have a package A define an exported identifier have package B use the identifier run staticcheck unusedwholeprogram on A and B modify B to remove the use of As identifier rerun staticcheck unusedwholeprogram on A and B observe that we do not flag the identifier in A A similar problem arises where we cache As identifier as being unused then start using it in another package We will not recheck package A Unfortunately this problem even exists when not running in wholeprogram mode because of test variants define an unexported identifier in foogo run staticcheck add a footestgo and use the previously defined identifier rerun staticcheck observe that we still flag the identifier as unused Both of these problems are caused by the fact that we cache the found problems per package It seems that in wholeprogram mode we must reanalyse all reverse dependencies In normal mode it should be enough to reanalyse a package when its tests change I had the following code go ignore flagStringignore Comma separated list of things to avoid changing ignoreMap makemap string bool ignoreSplit stringsSplitignore flagParse The problem is that ignore is not set to a value until flagParse runs It might be good to detect a read of a flag that occurs before flagParse is called p Another one found during a refactoring p go Parameter n used to be int func fn timeDuration Conversion the old one must be removed var d n timeMillisecond fmtPrintlnd Output h m s func main var n Conversion the new one ftimeDurationn timeMillisecond p When a parameter changes type during a refactoring and the conversion is now supposed to be higher upstack the previous conversion can sometimes still be in place adding an erroneous multiplication In this case the duration was supposed to be x Fms but instead was multiplied to be over eight hours long p All the other categories have oneline descriptions on ST does not Currently its quite common to see code with Context select case ctxDone return ctxErr default or where x is some struct containing a Context select case xctxDone return xctxErr default However it would be shorter and easier to understand if err ctxErr err nil return err 