I have a workflow and I want to test that when Im rendering a certain state that no actions were processed when the user submits invalid data Right now RenderTestResult has verifyAction and verifyActionResult methods but there isnt an easy way to verify that there was no action A verifyNoAction method would be helpful for testing this kind of workflow This preserves the WorkflowDiagnosticListener functionality but moves it around a bit Initialization Instead of setting a listener on the WorkflowSession you call WorkflowSessiondebug and pass an initializer function This initializer replaces the WorkflowDiagnosticListeneronRuntimeStarted method and receives one additional parameter a WorkflowDebugger Diagnostic Events The WorkflowDiagnosticListener interface still exists but instead of passing it to the session directly the initializer function registers it on the WorkflowDebugger by calling addDiagnosticListener Scoping Since each WorkflowDiagnosticListener is now associated with a specific workflow runtimes execution it is much more natural to write stateful listeners that need to be specialized to a specific runtime session since the listener can be instantiated at the time the particular runtime session starts Composition It used to be that you could compose multiple WorkflowDiagnosticListeners with the andThen extension function With this proposal composition happens at the initializer level instead of composing listeners together you compose initializers This is more powerful since each initializer can still add its own diagnostic listeners but they can also interact with the debugger An initializer can delegate to other initializer functions as necessary Debugging In addition to accepting diagnostic listeners the WorkflowDebugger lets you actually do interactive debugging Inspecting the Workflow tree It provides a stream of WorkflowHierarchyDebugSnapshot values emitted after every render pass A WorkflowHierarchyDebugSnapshot is an immutable description of an entire tree including every workflows props state and rendering and all its child workflows and workers These are now generated by the WorkflowNodes directly instead of being reconstructed from diagnostic events by DebugSnapshotRecordingListener This emission can be enabled or disabled by setting a property on the debugger Pausing and resuming the runtime It also lets you set a breakpoint after every render pass via another debugger property When this breakpoint is enabled the runtime will pause suspend after emitting every render pass rendering and debug snapshot In order to resume processing the debuggers resume method must be called after pausing clearing the flag does not resume Whenever the breakpoint is enabled debug snapshots are also always emitted so one could implement a debugging UI that displays the tree snapshot and provides a Resume button The breakpoint functionality is implemented by simply suspending the main workflow loop at the breakpoint Workers will still run while the runtime is paused but they will experience backpressure Rendering events will be queued If a LayoutRunner that is being used to render a view inside a WorkflowViewStub calls backPressedHandler on the root view the view passed to the LayoutRunners constructor that view is actually the parent view of the stub so the back handler will be set on the stubs container If another view doesnt replace the back handler in the stubs container that handler will live beyond the lifetime of that screen To repro see This change does a few things Pushes the running of a particular game session load board play game display game over screen into the new GameSessionWorkflow just renamed from DungeonAppWorkflow Uses WorkflowViewStub to display a preview of each board in the list automatically reusing the same code that the actual game screen uses to render the board while playing Screenshot Based on When verifying action result I would like to make assertions against my state kotlin someStatefulWorkflowrenderTesterprops someProps note that initialState is not passed render itdoSomething verifyActionResult newState output newState is of type of Any assertThatnewStatesomeValueisEqualTo This does not work because used renderTester with default initialState is a Workflow extension not StatefulWorkflow extension We could fix this by introducing two renderTester extensions for StatelessWorkflow and StatefulWorkflow instead of one generic function If you have a worker that is incorrectly implemented in that it always returns false from doesSameWorkAs and its Flow completes immediately your workflow will enter an infinite render loop This might seem like a weird thing to do but if your worker is a Mockito mock and you forget to override doesSameWorkAs its exactly what will happen We can detect this situation in the WorkflowTester API by counting render passes and if you hit some extraordinarily high number of passes before even running the test block fail the test with some message about this case cc afollestad Resolves issue originally created from Change summary Adds asWorker extensions to SignalProducer with doc comments Removes AuthorizingEmailPasswordWorker and AuthorizingTwoFactorWorker from TicTacToe sample in favor of demonstrating the asWorker concept Request for comments TODOs Need to determine the best way to do the isEquivalentto Kotlin has extended the runningWorker function to accept a Worker and a Key I have the opinion that we should take the key as an argument to asWorker because that function is a convenience function to create a concrete worker type which already has a mechanism for isEquivalent instead of spreading the equivalency into two places Open questions Why not make Worker conform to Equatable instead of the isEquivalentto method Originally part of 