Equality with accuracy isnt limited to floating point tests Sometimes integer or other numeric types need to be accurate within certain bounds for the purposes of testing This change allows any numeric type that has magnitude and distance to be used with XCTAssertEqualaccuracy and XCTAssertNotEqualaccuracy Ill be honest I dont have a clue where in the Tests directory Im supposed to put a regression test for this Should I create a new test target Seems a bit excessive but Im lost otherwise SR Add support for multilib systems Create a new libdir build option for the parser in buildscriptpy so Linux distributions that uses lib folder instead of lib for bit libraries like Fedora could install Swift without the need for patches After this exchange of ideas my opinion is that for the moment we can add the feature for setting continueAfterFailure and after that write a new task that addresses the fact that all tests stop if a failure occurs and continueAfterFailure is false I was thinking in something like SRXXX Allow remaining tests to continue after a failure instead of stopping the test process Apple XCTest does not throw a fatal error and crash the test process it merely prevents the remainder of a testClosure from expecting after its been determined that it has already failed The following behavior is incorrect And migrating all the conclusions we got to this new task What do you think Motivation Corelibs XCTest already has an mature setup for executing endtoend functional tests against itself which is doing an outstanding job of providing confidence that the library will work as expected when linked into clients test suites Sometimes though it feels more appropriate to write more granular unit tests against particular APIs provided by the library This PR aims to satisfy that missing component by adding a suite of unit tests which can be run from Xcode on OS X or from the build script on other platforms Details The unit test suite is located in the TestsUnit directory as a sibling to the existing functional test suite It uses Corelibs XCTest to test itself building an app whose mainswift invokes XCTMain with the list of XCTestCase subclasses which contain the tests themselves I implemented a simple pair of tests around XCTAssert behavior to act as a seed and example test for the suite Ordinarily when writing unit tests for a library I would prefer to link the library into the test target and restrict the tests to working against the public API so as to prevent them on relying too much on implementation details For this suite however I came to the conclusion that the public API at least in its present form lends itself rather poorly to unit testing because it generally requires calling into XCTMain to set up state and that function cant be called from a unit test without exiting the process altogether Because of this I decided to simply build the library source files together with the unit test sources allowing for judicious use of internal API in unit tests Note that the standard integration of the Corelibs XCTest dynamic library into client executables is thoroughly by the Functional test suite For OS X the Xcode project now has a new SwiftXCTestUnitTests app target which executes the test suite when run For Linux the build scripts test action has been extended to also build and run the unit tests although notably it does not link the unit tests against an alreadybuilt XCTest dynamic library the way that the functional tests do CI To get CI to run the new test suite the overall Swift build script will need to be updated around here to execute the unit test suite on OS X On Linux no additional work is required because it is already taken care of by XCTests own build script 