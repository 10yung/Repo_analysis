 In the past the GNUstep project has used the ability so link a fairly ancient version of libdispatch against a custom libBlocksRuntime in order to ensure interoperability with its ObjectiveC runtime which bundles a BlocksRuntime implementation It seems that this facility was removed in PR in favour of a check on whether its building for Darwin to decide whether the intree version should be built That seems accidental given the stated purpose of that PR so I would very much like to readd that facility I have now done this by readding the elided findpackageBlocksRuntime QUIET statement and deciding whether to build the intree version depending on BlocksRuntimeFOUND also the same as prior to PR I hope this is whats intended here Ive checked that this works on a Linux system both with and without a custom libBlocksRuntime Unfortunately I couldnt convince libdispatch to build on my macOS machine either with or without this change so that is probably due to my lack of expertise But it could very well be possible that building the intree libBlocksRuntime needs to be conditional on NOT CMAKESYSTEMNAME STREQUAL Darwin OR BlocksRuntimeFOUND Additionally yet relatedly there was an extraneous targetincludedirectories directive in the CMakeListstxt for the tests subdirectory The effect of that is already achieved by linking the BlocksRuntimeBlocksRuntime target and it started tripping up things once switching back to findpackage for the runtime lib Please let me know what you think Thanks Niels Hi Apple As a result of my own recent work and a couple of threads on swift evolution Id like to put forward the file in this PR for inclusion in Dispatch and am not at all sure sure the procedure would be It defines a new map method concurentMap on Sequence that distributes work across multiple cores backed up by a wrapper on osunfairlock and a property wrapper that would be of use with such asynchronous code I know there is a longer term full manifesto for concurrency in Swift but this requires changes to the swift compiler and language itself and is probably a longer term goal This PR has a much more limited scope not covered by the manifesto and can be available in the interim Im interested in the thoughts of the dispatch team against this PR or on the evolution forum John Small change but many of these functions have inconsistent structures so I flipped some of the if statements so they better align with the others What this means is that the branch will have a call to the intended function and the second one what happens when the initial check fails I hope this helps In LLVM a new warning is introduced that warns about possible lost in precision when converting some integrals into floating point numbers When the code is compiled with a newer Clang the warning will be emitted for the code branches that use long double and reduce them to uint t To avoid that a couple of static constants are created in both the long double and the uint t which holds the maximum casted in the case of long double to avoid the warning and those constants are used for the comparison In the case at hand UINT MAX is not representable as a long double but UINT MAX is which is the value that the constant will be cc adierking compnerd corrected comment for readonly subscript 