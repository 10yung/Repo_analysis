 same interface use unvariable way use variable way streamID is ID type unvariable way can prompt it is type error is useless value but variable way cant so it will let frontend confuse when use variable way This is primarily a fix for the way an old version of relay will sometimes arrange duplicate fragments in my understanding which may be wrong Ive just cherry picked this back onto master today We myself and bencallaway have run this for almost a year now and are trying to get back onto upstream and port some of our changes back Without this change this is an example of the error we encounter apologies for the very blurry screenshot GraphQL libraries like GraphQL Ruby and GraphQL Java support hiding GraphQL schema fields from certain types of users Im having a hard time finding such a feature in this library Does such a feature exist If not thats totally fine I just dont want to reinvent the wheel Thanks This fixes the error Schema must contain unique named types but contains multiple types named when fields are of type Object See Cheers and the query is Hello First thanks for this great project I ran into the issue when updating a schema For an update I first remove the type then add the new one deleteschemaTypeMap resourceTypeName schemaAppendTyperesourceType It works when the schema doe not contain a field of type object But when using an object it seems that updates have a collision name as it returns the error Schema must contain unique named types but contains multiple types named objectA See code sample Kind regards Im always shocked by the boilerplate I need to write to add simple structs to my schema What I did is I started to write some helper methods to analyze my structs via reflection and generate the gql types from my go structs Looks like this type Model struct Id int gormtypebigserialprimarykey jsonid CreatedAt timeTime sqlDEFAULTNOW jsoncreatedAt UpdatedAt timeTime jsonupdatedAt type IntegrationHttp struct Model App modelAppInstance gormnot nullforeignkeyidassociationforeignkeyAppId jsonapp AppId int gormnot null jsonappId Method string jsonmethod Url string jsonurl Skipped string json func TestNewTypeFromStructt testingT conf schemaNewTypeFromStructIntegrationHttp assertEqualt IntegrationHttp confName confFields confFields assertEqualt lenconfFields Yet it takes the fields names from the json tag could be configurable as well I also added a custom tag gql where you can override the type of a field with eg gqltypeString I can Imagine a bunch of more features Since the code runs only once at startup time I do not see any performance issues but reducing a lot of boilerplate code Now my questions are Is this kind of struct generation interesting for this library Is it interesting in general I could start another repository Or do you see any general issues with that and I should keep it private Else I would love to share the implementation and would be happy to further improve it Fix copypaste error that assigns all Lukes friends to Vaders friends Is there any plan to add pagination support Hey I have a custom type system and i have few constraints I cannot implement Resolve on the object level as I cannot change the type system I dont want to implement a resolver on every low level field just to resolve the custom object Default DefaultResolveFn fails to resolve the custom object Unless theres a better approach I would like to provide a custom DefaultResolveFn Thanks