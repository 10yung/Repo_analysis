Fixed importmeta emits an error dynamic import modulejs also emits an error I tried to avoid the issue with javascriptobfuscatordisable but that didnt help Current Behavior throws Error Unexpected token import Minimal working example that will help to reproduce issue importmeta consolelog importmeta dynamic import import modulejs dynamic import with an attempt to avoid obfuscating javascriptobfuscatordisable import modulejs javascriptobfuscatorenable Is there a way to exclude entire directories instead of files I think that it will be good idea to disable these features when targetnode with throwing exceptions to console debugProtection domainLock sourceMap sourceMapBaseUrl sourceMapFileName sourceMapMode When deadCodeInjection enabled if x abbc x af x a MgV x abbc x af x b TB x abbc x af x c gyn throw new TypeError x c a f x af x d dd else function x x b c x ba ab x c var x b d x c a f x af x e WFsi x af x f VjCx var x f x while switch x b d x f I think that it is caused by use strict statement Love javascriptobfuscator Please consider supporting our collective Provide a general summary of the issue in the Title above When I run the sample code below the result returned is obfuscated code with two instances of new FunctionFUNCTIONSTRINGWILLBEHERE In my use case I obfuscate the code and later on replace FUNCTIONSTRINGWILLBEHERE with other obfuscated code so having instances of that string really blows up my code and makes it too large Expected Behavior Tell us what should happen Only one instance of new FunctionFUNCTIONSTRINGWILLBEHERE should be found in the obfuscated code Current Behavior Tell us what happens instead of the expected behavior Two instances of new FunctionFUNCTIONSTRINGWILLBEHERE are found in the obfuscated code Steps to Reproduce Provide a link to a live example or an unambiguous set of steps to reproduce this bug Include code to reproduce if relevant Just run the sample code below it will obfuscate the code and print out the obfuscated result Your Environment Include as many relevant details about the environment you experienced the bug in Obfuscator version used but the issue reproduced in as well I didnt check earlier versions Node version used v Stack trace Include stack trace Minimal working example that will help to reproduce issue Include code javascript const obfuscatorConfig deadCodeInjection true deadCodeInjectionThreshold reservedStrings FUNCTIONSTRINGWILLBEHERE const javaScriptObfuscator requirejavascriptobfuscator const FUNCTIONSTRINGWILLBEHERE FUNCTIONSTRINGWILLBEHERE const code function foo if true return function boo if true if true new FunctionFUNCTIONSTRINGWILLBEHERE for let i i i consolelogObfuscation i let obfuscatedCode javaScriptObfuscatorobfuscateStringcode obfuscatorConfiggetObfuscatedCode let FUNCTIONSTRINGWILLBEHEREinstanceCount obfuscatedCodematchnew RegExpFUNCTIONSTRINGWILLBEHERE g length if FUNCTIONSTRINGWILLBEHEREinstanceCount consolelogobfuscatedCode processexit Is your feature request related to a problem Please describe Now use this tool to obfuscate bin file will throw a error eg javascript usrbinenv node const process requireprocess const path requirepath const cmd requirecommander const pkgInfo requirepackagejson output bash Error Line Unexpected character usrbinenv n Describe the solution youd like Dont obfuscate this first line for this file will be ok Describe alternatives youve considered None Additional context Obfuscator version used It is pretty easy to circumvent the domainLock Just replace dataelsereturn with returnelsereturn Hi I was thinking if theres an option in JavascriptObfuscator eg Domain Redirect redirect to the selected domain if the code is use in other domain Expire Date the obfuscated code will be valid for a period of time after that the code wont work Wouldnt it be so amazing to have such function Please try to add this kind of function if possible Thanks The RC encoding is incredibly easy to bypass by finding the cache variable From my testing it appears to always be in the second function which is declared as var decoder functioncacheIndexStr key The cache can be identified by going to the bottom in the last if statement and looking for the last line which should be similar to decoder cache index decodedValue If you can identify that line you just have to obtain the first part decoder cache or decodercache and enter it into a debug console to get the decoded string cache from there the index in the cache matches the first parameter of the decoder call After that it is easy to match up all of the strings and function names in the code Identifying the cache is not at all affected by self defending Debug protection also does not affect the ability to print the cache the console will still function when the code has hit a breakpoint Environment Obfuscator version used Node version used 