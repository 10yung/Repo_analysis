tests on my end showed it fixed plz confirm as well Warning If you create a pull request and wish to remain anonymous you are highly advised to use Tails or a fresh git environment We will not be able to help with anonymization after your pull request has been created HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG HAVE YOU UPDATED THE CHANGELOG TShock version v Item frame is invisible after installation That becomes visible after relogin but any items cant decorate on that This PR aims to implement TShocks command subsystem as roughly laid out in This is currently a workinprogress I will provide a writeup once I think its done The new configuration service should use something thats a bit easier to read and edit than JSON Im proposing that we use YAML for this Questions and comments are appreciated Commands are a major pain in the ass to implement Its a pain to have to parse each argument manually Its a pain to have to check the parameter count each time Its a pain to have to use a utility method to lookup item or player names They should thus be as easy to implement as possible even if this makes the command parsing significantly more complex I propose the following all naming is TBD c Plugin uses this to define the command Commandi Commanditem private void ItemCommandHandler ICommandSender sender ItemType itemType int stackSize ItemPrefix prefix ItemPrefixNone Plugin uses this to register the command var itemCommand commandServiceRegisterCommandItemCommandHandler Plugin uses this to unregister the command commandServiceUnregisterCommanditemCommand ICommandSender ICommandSender is an interface which will look like the following c public interface ICommandSender string Name get ILogger Log get void SendMessagestring message void SendMessagestring message Color color void SendObjectobject obj The whole point is to allow multiple types of senders to exist a PlayerCommandSender for players who send the command a ConsoleCommandSender for commands entered through the command line a RestCommandSender for commands sent via the REST API a SignCommandSender for commands sent from a sign etc For special playerrelated behavior you could check if sender is PlayerCommandSender player The Log property will allow a command handler to log various information to the sender This will be extremely useful for plugin developers debugging their commands Overall this should allow our command infrastructure to be more extensible than ever before Argument Parsing Arguments will be parsed according to the argument structure of the method annotated with CommandAttribute Optional arguments can be left out and they will take on their default values Named arguments may or may not be supported params arguments will be parsed repeatedly until failure to parse All basic types int string etc should be parsed properly by default For custom types there will be some sort of mechanism to define parsers This may be done via an attribute on the argument I havent fully decided yet One could for example define an NpcType parser c public class NpcTypeParser ICommandArgParserNpcType public NpcType Parsestring str return and then create the following command c private void SpawnMobHandler ICommandSender sender CommandArgParsertypeofNpcTypeParser npcType and the NpcTypeParser would be constructed and parse the string as appropriate One final feature that needs to be included is to allow a failsafe string capture of the entire input This could be done via an CommandInputCaptureAttribute for example Command Service The command service will expose the following hooks RegisteringCommand which can be handled RegisteredCommand ExecutingCommand which can be handled ExecutedCommand These hooks can be added to set up things such as permissions command ratelimiting etc Additionally I want to explore easy command registration that might scan an object for all methods which have CommandAttribute and register them as necessary Hypothetical Q A How would I define aliases for commands Use the CommandAttribute multiple times on your method Are command names unique No There can be multiple commands with the same name This allows you to provide two different branches of argument parsing However care should be taken to avoid two commands from actually executing Yes they will be unique It is probably not worth the time implementing multibranched parsing Let me know if there are any real use cases of this How would permissions work Via a hook handler on RegisteringCommand which will handle the event if the user is deemed to not have the permissions necessary Note that this enables advanced permissions to take place and even temporary permissions without a temporary group hack A separate PermissionAttribute would need to be placed on the commands What about subcommands Subcommands will differ wildly in parsing rules Therefore spaces should be allowed in the command name You should be able to register region add and region del simultaneously Subcommands will involve passing multiple arguments into the CommandAttribute constructor How exactly is the string parsing going to work As precisely as possible Backslashes will be used as escape characters Assuming you have a command which takes multiple string arguments Input Output command test test test test command a b c d a b c d command a b c d a b c d command command command ERROR command ERROR Questions and comments are appreciated With a renewed effort on Orion underway I wanted to start discussing my ideas on the new version of TShock which would be based on Orion The base TShock plugin or the TShock launcher if applicable should own and provide the following components Commands Configurations REST API Users groups and permissions User management bans etc The following components will be spun off into their own plugins which could be placed under the TShock namespace Anticheating mechanisms Item projectile and tile bans Regions Serverside characters Warps and any other features or commands not explicitly listed above See screenshot below As per ASgoPew similar erros are thrown when defining regions Im not sure if theres any issue has discussed about this If someone continuously and quickly connects and disconnects to server server will enter infinite loop Still viable on newest tshock Though it can be easily defended by checking the frequency of connecting The true reason why it so is We can check it in the loop if it is just break the loop It works as I tested I highly recommend to fix this because I really dont know how can this exploit be used dos attack might not be needed TShock version Reproduction steps Select stack with exactly one SilkVineWeb Rope Coil Throw rope coil at vertical column of blocks Expected SilkVineWeb Rope Coil entity is thrown SilkVineWeb Rope Coil is placed upon collision with solid blocks Excess SilkVineWeb Rope is returned as dropped items Reality SilkVineWeb Rope Coil entity is thrown SilkVineWeb Rope Coil entity disappears upon collision with solid blocks What would have been excess SilkVineWeb Rope had the coil been placed is returned as dropped items Notes group addperm group tshockignore does not appear to change this Issue 