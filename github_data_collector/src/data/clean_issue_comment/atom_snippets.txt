 Have you read Atoms Code of Conduct By filing an Issue you are expected to comply with it including treating everyone with respect Do you want to ask a question Are you looking for support The Atom message board is the best place for getting support Prerequisites X Put an X between the brackets on this line if you have done all of the following Reproduced the problem in Safe Mode Followed all applicable steps in the debugging guide Checked the FAQs on the message board for common solutions Checked that your issue isnt already filed Checked that there is not already an Atom package that provides the described functionality Description Description of the issue Within a snippet pressing shiftTAB to go to the previous tab stop results in the buffer being tabbed back The command palette displays editoroutdentselectedrows as the first event over snippetsprevioustabstop Steps to Reproduce Within a Python file I type ase inserting a snippet Press tab to go to next stop Press shift tab observe that previous stop is highlighted but buffer is moved back as well Expected behavior What you expect to happen Only previous stop gets highlighted buffer remains Actual behavior What actually happens Previous stop is highlighted buffer is shifted back Reproduces how often What percentage of the time does it reproduce Versions You can get this information from copy and pasting the output of atom version and apm version from the command line Also please include the OS and what version of the OS youre running Atom Electron Chrome Node apm npm node x atom python git OS macOS Additional Information Any additional information configuration or data that might be necessary to reproduce the issue Description of the Change This pull request changes a test in spec suite which at the time of writing expects a very specfic indentation logic behavior from core it assumes that when text is selected hitting kbdTabkbd always results in indenting the line The aim of the pull request is somewhat to loosen the test to allow any core behavior within reason to occur while retaining the constraints that make sense for this package Alternate Designs None considered for now Benefits The test is not as tightly coupled to the core allowing core to change behavior without the need to update this spec Possible Drawbacks There could be future developments which may pass with the new test but that did not pass with the old one however this should be unlikely due to the amount of similar tests which possibly catch such cases Applicable Issues atomatom NOTE Ready for review Requirements Filling out the template is required Any pull request that does not include enough information to be reviewed in a timely manner may be closed at the maintainers discretion All new code requires tests to ensure against regressions Description of the Change We must be able to understand the design of your change from this description If we cant get a good idea of what the code will be doing from the description here the pull request may be closed at the maintainers discretion Keep in mind that the maintainer reviewing this PR may not be familiar with or have worked with the code here recently so please walk us through the concepts Redoes a lot of stuff Basic idea is to comply with the VS Code spec based on TextMate spec also used by Sublime Text as much as possible because thats the spec language servers are supposed to use With this well fully support well formed LSP snippets The added features are also useful anyway and following an existing spec means we dont have to define our own though I believe its all based off of TextMate anyway Putting this up now for feedback and trying it out while its still being worked on Added X Support for variables X Support for replacement if else conditionals based on capture group match X Support for choices parses the syntax actual choice popup deferred to later PR X Support for LSP transformation syntax X Service for custom variable resolvers not in the spec but I like this idea a lot X Implicit end tab stops when one was not already defined togglable in settings X Forced undo breaks at each tabstop Changed X Removed implicit g flag from transformation regex If users want it they can add it explicitly And now if they dont want it they have a choice X The parser has been rewritten but still creates a tree compatible with the existing logic when using existing features A notable change is that only escapes the characters and and a few others depending on context X Specs have been updated to add the g flag where the implicit one was relied upon X Snippet bodies and tab stops are now formed on demand and are no longer members of the snippet This is necessary given the dynamic nature of variables and their transformations They are now made in the SnippetExpansion which is a temporary representation for the expanded snippet x Refactoring the existing snippetgetTabStops into something more modular Currently renamed to toString but it will make the insertion string and tab stops X Implicit end tab stops configurable in Settings X End tab stops now break out of the snippet so you will no longer be able to tab backwards from one this is in line with their purpose of marking where to put the cursor when the snippet finishes X Redid a lot of editortransact calls these appeared to only make the undo behaviour fail in strange ways Open Questions Should escape everything It would make it easier to remember what it does but subtly break VS Code compatibility which is slightly different in a few areas anyway It would also simplify the grammar Am going with no in this PR May be possible to make configurable in future especially if users complain by passing an argument to the parser Alternate Designs Would have removed u and co flags entirely but they appear to be supported by TextMate too and so are worth keeping Benefits What benefits will be realized by the code change backwards compatible and adds much more advanced and dynamic capabilities With custom variable resolvers users can do pretty much anything with the provided text editor and any other relevant params Possible Drawbacks Bodies that contained text like onetwothree will now be interpreted instead of being a literal But the fix is to escape the like this onetwothree as the raw CSON value and no onesupsup would be doing that unless they wanted a choice placeholder anyway supmesup Applicable Issues Closes this also contains the decaffeination changes Closes Also closes I think Closes That conversion uses alternate replacement syntax that now has support added here too Description There are a few features of snippets that are missing Eg choices and variables This issue is to request the snippet implmentation be changed improved to implement the rules as described below here While improving Atoms own snippet handling it also makes it easier to use completions provided by language servers directly Technically they should currently be sanitised to remove unsupported features In summary some of this is already implemented Tab stops n for cursor locations Placeholders foo for preselected placeholder values Nested placeholders Support of foo bar is required Choice onetwothree prompts the user to pick a value not sure how prompt should work Variables Allows replacements to use context such as file name selected text etc Variable transforms Regex applied to variables Im not sure how the current u and friends fit in but could potentially be an enhancement if not already supported by the regex Heres the EBNF grammar provided in the link any tabstop placeholder choice variable text tabstop int int placeholder int any choice int text text variable var var var any var regex format text options format int int int upcase downcase capitalize int if int if else int else int else regex JavaScript Regular Expression value ctorstring options JavaScript Regular Expression option ctoroptions var azAZ azAZ int text Have you read Atoms Code of Conduct By filing an Issue you are expected to comply with it including treating everyone with respect Do you want to ask a question Are you looking for support The Atom message board is the best place for getting support Prerequisites x Put an X between the brackets on this line if you have done all of the following Reproduced the problem in Safe Mode Followed all applicable steps in the debugging guide Checked the FAQs on the message board for common solutions Checked that your issue isnt already filed Checked that there is not already an Atom package that provides the described functionality Description Okay so this is weird I have a multiline snippet with a multicursor tab stop begin end prefix begin body begin env n t n end env This works fine and properly inserts the snippet with proper indentation of the last line However if the next character I type is any of c d e m n o t u and no other letters the indentation on the last line gets eaten Heres a little video that I hope will help clarify the actual behavior bug Steps to Reproduce Expected behavior Should preserve the indentation on the last line Actual behavior The weird thing described above Reproduces how often Versions Atom version Mac OS X Fixes Description of the Change The problem Here s a simple example of a snippet that has never quite worked right bar baz I ll quote from my comment in to explain how this goes wrong I ll use parentheses to illustrate the invisible markers After tab expansion you ve got barbaz You type x and now you ve got xbaz The editor knows to put x into the first marker because bar was selected and that removed all ambiguity But right now the cursor is between x and baz so when you type text it could plausibly get added to either marker We want this xyzzbaz but we re getting this instead xyzzbaz The fix All snippet markers are getting created with exclusive false That means that they ll expand to claim text that s typed at their boundaries But when inserted text is right between two adjacent markers the one on the right always wins The only way to force it in the direction you want is to create one marker with exclusive true and one with exclusive false In our example is the active tab stop so we want its marker to claim the characters that we type But when we hit kbdTabkbd and make the active tab stop we want the opposite behavior So we ll have to change the settings on the markers as the active tab stop changes or rather copy them to new markers with the settings we want There s one more edge case to consider and I wasn t sure how to conceptualize it until I peeked at VScode s strategy for avoiding this problem tab stops can reference other tab stops in their placeholder content If has a placeholder that includes a reference to then s marker needs to be inclusive when either or is the active tab stop because we need s marker to grow as we type the value for If you find this hard to wrap your brain around you re not the only one Alternate Designs The marker API though robust is not so rich as to give me lots of options here The fact that this implementation is nearly identical to VScode s is validation of the approach There were a few different ways I could ve used to determine the crossreferences between tab stops their placeholders and any tab stops those placeholders referenced I decided to capture those references just after parsing as we consume the syntax tree Another option would ve been to inspect the markers after creation and infer the relationships based on which markers were completely surrounded by other markers but that felt like an indirect approach Benefits A number of snippets that seemed like they should just work haven t worked or have worked incorrectly for a long time and now they will Possible Drawbacks The fact that we have to destroy and recreate markers as tab stops move is not ideal but I don t think it s a bottleneck If it turns out to be a problem we can make the changes necessary in textbuffer to allow the exclusive setting to be changed after creation on an existing DisplayMarker Applicable Issues is a duplicate of but contains a lot of relevant discussion I am trying to develop a snippet in which i can use in the body the snippets prefix description andor other values For example Snippet x prefix mysnippetprefix description A prototype of a snippet types html inputs input input outputs output output body prefix t inputs t outputs prefix The point is basically to be able to define values like inputs and outputs eg read from a txt file and writen on the json file instead of writting it all down like prefix mysnippetprefix description A prototype of a snippet types html body mysnippetprefix t input input t output output mysnippetprefix I dont think this is supported yet nor the ability to press CtrlSpace in the code and within the selected snipped be able to choose its parametersvalues Is it something doable or am I just missing something Description Atom snippets fail to treat an octal in multiline strings as expected While the specification at proclaims Multiline Strings Without Quote Escaping and gives no warning about octal Atom editor gives an error message while saving a snippet definition containing an octal Escaping a closing brace in a multiline string is in the README for the snippets package Using the same technique to escape the opening backslash of the octal delivers the same error message as with no escaping Steps to Reproduce Open HOMEatomsnippetscson Save the CSON snippet definition described in Actual behavior below Save the file Expected behavior Unlike a closing brace other values do not require escaping in snippetscson using CSON multiline strings OR a means of escaping the octal exists for snippets as that require them OR the README is updated to reflect this limitation in addition to the closing brace limit Actual behavior While running Atom like this atom safe Add this code fragment snippet definition to HOMEatomsnippetscson cson sourcemakefile makefile prefix startmake description Makefile help body DEFAULTGOAL help PHONY help help grep E azAZ MAKEFILELIST sort awk BEGIN FS printf m s m s n Upon saving the file get this error plain Failed to load snippets from atomsnippetscson atomsnippetscson ocatal esccape sequences are not allowed Using the debugger arrive at this error message plain fsjs line Error reading snippets file Usersmarkatomsnippetscson stdin error octal escape sequences are not allowed grep E azAZ MAKEFILELIST sort awk BEGIN FS printf m s m s n Which comes from this linefunction javascript function nullCheckpath callback if pathindexOf u var er new ErrorPath must be a string without null bytes ercode ENOENT if typeof callback function throw er processnextTickcallback er line return false return true Reproduces how often Always Versions plain atom version Atom Electron Chrome Node apm version apm npm node x python git swvers ProductName Mac OS X ProductVersion BuildVersion B Additional Information Not certain to which of these this issue belongs Because snippets are represented as Objects a snippet called proto actually gets assigned as the objects real proto Definitely not intentional Blocked on atomseason which is transmitting the CSON data back to us as an object Have you read Atoms Code of Conduct By filing an Issue you are expected to comply with it including treating everyone with respect Do you want to ask a question Are you looking for support The Atom message board is the best place for getting support Prerequisites x Put an X between the brackets on this line if you have done all of the following Reproduced the problem in Safe Mode Followed all applicable steps in the debugging guide Checked the FAQs on the message board for common solutions Checked that your issue isnt already filed Checked that there is not already an Atom package that provides the described functionality Description Backspacing on second tabstop deletes part of text in first tabstop when tabstops are contiguous Steps to Reproduce Create a simple foo snippet such as cson foo prefix foo body bar baz Open a new file and change the syntax to the one the snippet was placed under Activate the foo snippet Type something of characters or more to replace bar xyzz for this example Tab to baz Expected behavior What you expect to happen Only baz should be selected for replacement Actual behavior What actually happens yzzbaz is selected for replacement Only the first character of the first tabstop replacement x is left unselected Reproduces how often What percentage of the time does it reproduce Versions Atom MacOs Sierra 