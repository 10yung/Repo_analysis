activitiversion procDef xml conver to model event type node execution listener missing I am interested in creating a model using java code and Im wondering where I could look in the codebase to find the code that constructs the model The code that is most usefulnecessary is the actual model types ServiceTask EventHandler Gateway positions etc etc and the code to generate the bpmn xml from this I was looking closely at And I tried digging through different packages activiticloudmodeling activiticloudmodelingservice activitimodelingapp but cannot seem to find the logicdefinitions Unfortunately a lot of the naming schemes are unclear to me and refer to general concepts which I assume have specific meaning in the context of the project version core service rest api apiimpl So it would be super helpful if there was a pointer to where this code lives or some documentation on how things are structuredorganized Where should I look Hello I am trying to upgrade activiti to activiti because I am upgrading my spring boot app to version It seems that the FormService class got removed in activiti are there any workarounds for this problem Thank you in advance When I want to get the result through this method ListDeployment list repositoryServicecreateDeploymentQuerylist And then were ready to turn it into a json string but the method have a javalangNullPointerException error lazy loading public MapString ResourceEntity getResources if resources null id null ListResourceEntity resourcesList ContextgetCommandContextgetResourceEntityManagerfindResourcesByDeploymentIdid resources new HashMapString ResourceEntity for ResourceEntity resource resourcesList resourcesputresourcegetName resource return resources I wonder if there is a good way to resolve this lazy load error thanks VerifyDeserializedObjectCommandContextCloseListener processes serialized data within ProcessVariableInstance So Why that logic processes in CommandContextCloseListenerclosing over CommandContextcloseListeners instead of DbSqlSessiondetermineUpdatedObjects DbSqlSessiondetermineUpdatedObjects looks native place to validate dirty entities Now i have exception in case i touch some variables in CommandContextCloseListener javautilConcurrentModificationException null at javautilArrayListItrcheckForComodificationArrayListjava at javautilArrayListItrnextArrayListjava at orgactivitiengineimplinterceptorCommandContextexecuteCloseListenersClosedCommandContextjava see when start a procinstance set two variable in this procinstance the two variable of the record EXECUTIONID TASKIDPROCINSTID are the same but only the REV value is different case the flow go to wrong who can help me version Mapped as loopDataOutputRef and outputDataItem as defined in the BPMN specification Ref There exists two attributes which can be used in combination with the bpmnmultiInstanceLoopCharacteristics element outputDataItem declares a variable that exists in the scope of the multiinstance activity whereby the value of it should be collected loopDataOutputRef declares a collection which will be available in the process instance as a variable This collection collects the values of the result variables An example could look like this multiInstanceLoopCharacteristics isSequentialfalse loopCardinality loopCardinality loopDataOutputRefmealsloopDataOutputRef outputDataItem namemeal multiInstanceLoopCharacteristics Semantic Whenever an instance of the specific activity completes then the value of the variable meal declared by the attribute outputDataItem will be added to the declared collection meals by the attribute loopDataOutputRef when the table ACTHIVARINST hundreds of thousands of rows the selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql sql execute very slow selectHistoricProcessInstancesWithVariablesByQueryCriteriaSql SELECT DISTINCT RES DEFKEY AS PROCDEFKEY DEFNAME AS PROCDEFNAME DEFVERSION AS PROCDEFVERSION DEFDEPLOYMENTID AS DEPLOYMENTID VARID AS VARID VARNAME AS VARNAME VARVARTYPE AS VARTYPE VARREV AS VARREV VARPROCINSTID AS VARPROCINSTID VAREXECUTIONID AS VAREXECUTIONID VARTASKID AS VARTASKID VARBYTEARRAYID AS VARBYTEARRAYID VARDOUBLE AS VARDOUBLE VARTEXT AS VARTEXT VARTEXT AS VARTEXT VARLASTUPDATEDTIME AS VARLASTUPDATEDTIME VARLONG AS VARLONG FROM ACTHIPROCINST RES LEFT OUTER JOIN ACTREPROCDEF DEF ON RESPROCDEFID DEFID LEFT OUTER JOIN ACTHIVARINST VAR ON RESPROCINSTID VAREXECUTIONID AND VARTASKID IS NULL WHERE RESPROCINSTID ORDER BY VARLASTUPDATEDTIME ASC LIMIT OFFSET then I optimize the sqlreplace LEFT OUTER JOIN with INNER JOINexecution is times faster Show your source code HistoricProcessInstancexml sql idselectHistoricProcessInstancesWithVariablesByQueryCriteriaSql from prefixACTHIPROCINST RES left outer join prefixACTREPROCDEF DEF on RESPROCDEFID DEFID if testincludeProcessVariables left outer join prefixACTHIVARINST VAR ON RESPROCINSTID VAREXECUTIONID and VARTASKID is null if include refidcommonSelectHistoricProcessInstancesByQueryCriteriaSql sql Why LEFT OUTER JOIN is not replaced by INNER JOIN 