the window field of Win has the same name as the variable used in the initialization therefore it doesnt need to specify the field explicitly Just like the model field on the line above Hello Im finding TreeViews a bit unintuitive to use with widget In issue you gave some example code for connecting a childs signals which sounds great but the branch was deleted Is this still a goal or is it already possible I couldnt see any examples or obvious implementation In issue and in the async example the solution for using connect on a TreeSelection is to store a clone of the relm object in the model to use later on but it doesnt feel nice maybe initview could be given a RelmT or the relms stream Is setting up CellRenderers and TreeViewColumns declaratively a future goal or is it a bad approach Thanks Hi Thank you for your hard work on this project Id love to help with making it more approachable for outsiders Where Id like to see changes first is in the initial documentation explaining the frameworkwhy it exists how it makes things good etc and comments in the examples The website is great when making a GUI framework At the very least the examples in there would be great to have At the very most writing some documentation in regards to the current dimensions of evaluation would be very helpful for people choosing a GUI framework and provide a solid foundation for people wanting to contributeexplaining how and what relm does and why makes it easy to consider contributing or finding another project On a side note Id like to note how Im unsure if everything done with relm can be done with the view macro Ive tried to make a treeview and couldnt figure how to initialize the model with the view macro My point being that some explanation of what the view macro actually is and what it inhibits would be great Personally I like the standard method more as its easier to modulate the structure and handle the componentswidgets I have this code based on the widgetlist example except it uses a ListBox and a custom HeaderBar Rust pub struct CounterModel counter i deriveMsg pub enum CounterMsg Decrement Increment widget impl Widget for Counter fn model CounterModel CounterModel counter fn update mut self event CounterMsg match event Decrement selfmodelcounter Increment selfmodelcounter view gtkListBoxRow gtkBox orientation Horizontal gtkButton label name incbutton clicked Increment gtkLabel label name label text selfmodelcountertostring gtkButton label clicked Decrement gtkButton label Remove Remove this widget from the ListBox and destroy it clicked unimplemented deriveMsg pub enum Msg Add Quit Remove pub struct Model counters VecComponentCounter widget impl Widget for Win fn model Model Model counters vec fn initview mut self selfwindowsettitlebar selftitlebar fn update mut self event Msg match event Add let widget selflboxaddwidgetCounter selfmodelcounterspushwidget Quit gtkmainquit Remove if let Somecounter selfmodelcounterspop selflboxremovewidgetcounter view namewindow gtkWindow gtkScrolledWindow propagatenaturalheight true mincontentheight mincontentwidth namelbox gtkListBox selectionmode gtkSelectionModeNone activateonsingleclick true Increment the counter that was activated rowactivated unimplemented nametitlebar gtkHeaderBar title Title showclosebutton true nameaddbutton gtkButton label Add clicked Add nameremovebutton gtkButton label Remove clicked Remove deleteevent Quit Inhibitfalse fn main WinrunexpectWinrun failed I want to make activating clicking on a row of theListBox send a message to the ListBoxRow that was activated and increment its Counter I also want to add a new button to the Counter named Remove I want clicking on this button to send a message to ListBox to remove this specific counter There are examples and tests that show how to achieve similar effect with a fixed amount of children but none that explain how to do it with a dynamically changing children located in a Vec in the Model Lets say I have this view rust view gtkWindow And i want to append a GTK object based on what its in my model how would i do it Id like to do something similar to this rust view gtkWindow modelactivebox where modelactivebox is of type gtkBox that gets swapped at runtime or something like rust view gtkWindow match modelactivebox This gtkBox That gtkBox where modelactivebox is an enum Coming from Elm this would feels like the natural way to do things in declerative style Fix Hey antoyo thanks for this library Do you think it would make sense to add an example showing how to create a gtkDialog using the view macro In particular Im wondering how to replicate the Dialognewwithbuttons function I think the default constructor is kind of deprecated It is very hard to understand how examples work You use widget attribute in your examples and it is very annoying Need to understand all code generation What is hbox in your example How to see where it is created What is Counter What fields included in counter And what type of these fields What is this nameremovebutton Boilerplate code is maybe not needed in real projects but without it it is really hard to understand your code Description Calling DrawHandlerDrawingAreagetcontext seems to trigger an extra draw event Using it in the event handler as in the drawingrs example causes a feedback loop where each draw event triggers a new one An example showing the issue is given below Setup Use nightly Rust cargo init bin relmissue Replace mainrs with the code given below Add dependencies to Cargotoml dependencies gtk relm git rev e dcac abbae cbaa ea c b relmattributes git rev e dcac abbae cbaa ea c b relmderive git rev e dcac abbae cbaa ea c b Running the example cargo run Observed behavior Updating UpdateDrawBuffer is printed many times per second Expected behavior Updating UpdateDrawBuffer should be printed only when the widget needs to be repainted for instance when the window is resized Tweaking the example Change the constant TRIGGERINFINITEEVENTS to false to disable the call to DrawHandlerDrawingAreagetcontext cargo run Observed and expected behavior Updating UpdateDrawBuffer is printed only when the widget needs to be repainted for instance when the window is resized Example code mainrs featureuseexternmacros extern crate gtk macrouse extern crate relm extern crate relmattributes macrouse extern crate relmderive use stdtimeSystemTime use gtk DrawingArea Inhibit WidgetExt use relm DrawHandler Widget use relmattributeswidget use selfMsg const TRIGGERINFINITEEVENTS bool true pub struct Model drawhandler DrawHandlerDrawingArea deriveMsg Debug pub enum Msg UpdateDrawBuffer widget impl Widget for Win fn initview mut self selfmodeldrawhandlerinit selfdrawingarea fn model Model Model drawhandler DrawHandlernewunwrap fn update mut self event Msg println Updating SystemTimenow event ifTRIGGERINFINITEEVENTS let selfmodeldrawhandlergetcontext view gtkWindow namedrawingarea gtkDrawingArea draw UpdateDrawBuffer Inhibitfalse fn main Winrununwrap Reading the http example I was curious about who manages the lifetime of the http component created here and it seems that the component itself is moved into the streams callback and kept there Whos supposed to drop the component when its outlived its purpose Even closing the returned stream does not cause the component to get dropped I managed to drop it by replacing the streams callback httpsetcallback This seems very unergonomic Am I doing it wrong Any input is appreciated