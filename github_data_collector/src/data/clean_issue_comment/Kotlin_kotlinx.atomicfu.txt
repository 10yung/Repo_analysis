Background I tried compiling a multiplatform binary that included kotlin coroutines for Linux ARM build target when I found out that there is no published artifact for that target Then I found that coroutines depend on atomicfu so Im starting from here Ive ran tests with gradlew check but I havent done any deep dive into the code so I might not be aware of all the consequences of including these build targets Summary Add and bit Linux ARM targets so the library can be used on ARM devices running Linux such as Raspberry PI I added the kotlinxatomicfu plugin to my multiplatform project As soon as I did that I get the following error Source set commonMain of project project name is part of several compilations debug release main Here is my entire buildgradlekts Kotlin plugins idcomandroidlibrary idorgjetbrainskotlinmultiplatform idkotlinxatomicfu android compileSdkVersionAndroidConfigcompileSdkVersion defaultConfig minSdkVersionAndroidConfigminSdkVersion targetSdkVersionAndroidConfigtargetSdkVersion versionCode versionName testInstrumentationRunner androidsupporttestrunnerAndroidJUnitRunner dependencies implementationLibskotlinstdlibjvm implementationLibsandroidxannotation implementationLibsandroidxbrowser implementationLibsrallykinjectjvm implementationLibsrallykinjectjvm implementationLibskotlinxcoroutinesandroid kotlin android SuppressUNUSEDVARIABLE sourceSets val commonMain by getting dependencies implementationLibskotlinstdlibcommon implementationLibsrallykinjectcommon implementationLibsrallystorecommon implementationLibsrallydisposablecommon implementationLibskotlinxcoroutinescommon val commonTest by getting dependencies for lib in Libskotlintestcommon implementationlib Stepstoreproduce class Foo private val foo atomic Lalso printlnit Priority low The last working version is Guess something had been broken after updating Gradle to Atomicfu creates synthetic classes to support static toplevel properties They should be packageprivate when possible when theres no access from a different package and their naming scheme shall be similar to innerclass naming using separator As atomic document says to leak atomic values to public use kotlin val pref atomic L var pref Long get prefvalue setvalue prefvalue value so I think its possible to have something like kotlin val pref by atomicVar L val pref by atomicVal L thisprefatomicvalue To be convenient with default Kotlin gradle plugin and Gradles naming conventions for plugins I suggest to add fullqualified name for atomicfu plugin It can be used in the following ways kotlin plugins idorgjetbrainskotlinjvm version kotlinversion idorgjetbrainskotlinpluginatomicfu version atomicfuversion Or via Gradle Kotlin DSL extensions kotlin plugins kotlinjvm version kotlinversion kotlinpluginatomicfu version atomicfuversion I choose the prefix orgjetbrainskotlinplugin similarly to orgjetbrainskotlinpluginserialization from kotlinxserialization Adding common dependency to a native module causes Gradle plugin to complain about it for every module In ktor it generates a huge number of warnings so one wouldnt be able to discover actual problems A compileOnly dependency is used in the KotlinNative target linuxX Compilation main Dependencies orgjetbrainskotlinxatomicfucommon Such dependencies are not applicable for KotlinNative consider changing the dependency type to implementation or api Need to move from regexps to actual tree analysis