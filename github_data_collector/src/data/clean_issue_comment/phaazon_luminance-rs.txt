In some code was added to checktypesmatch to check texture arrays That code looks very very redundant to write and pretty boring Macro macro man eyes The following program instantly crashes on my computer rust use luminanceglfwGlfwSurface Surface as WindowDim WindowOpt fn main let surface GlfwSurfacenewWindowDimWindowed TEST WindowOptdefault match surface Okmut surface loop surfacepollevents surfaceswapbuffers Err The following error message is printed X Error of failed request BadWindow invalid Window parameter Major opcode of failed request XTranslateCoords Resource id in failed request x Serial number of failed request Current serial number in output stream Using waitevents preduces the same result Commenting out the pollevents line causes the program to run with no crashes My window manager is xmonad and its possible there is a bad interaction there Fix This pull request add a new method newmulti to enable the multiple OpenGL contexts creation in one thread See the PoC nikut for a working example The feature multiwin must be explicitly declare to enable the use of this new method Alpha channel can be blended separately on OpenGL We need to change a bit the current blending interface to take an enum that will either allow to set blending for the regular RGBA case or for RGB A That should be pretty easy to do In a first attempt to go multiwin the GraphicsState must be able to be swap from a previously current context to a new current context As its only relevant for the window manager to make the switch and because its a very specific operation only useful in a specific case I think the best way can be one of this two solutions add a feature in the toml to enable the same action of disable std but only for the GraphicsState add a alternative constructor and a swap method to the GraphicsState impl to be able to make it swappable while keeping all the actual code unchanged I currently starting a fork to test the second approach but if you have a different idea of how to do it share it Right now the only way to render with luminance is using the GlfwSurface or GlutinSurface structures which provide events cursor hiding fullscreen support and setting samples Thats about it Any serious gameengine will probably want to code more things with the platform layer but with this system youre forced to use the Surface trait for everything I understand that luminance requires a very specific setup and this system is a good way of abstracting it out so it probably isnt a good idea to change it to something else I think this could be easily solved and without the need to change anything by just making a way to get the window handle So for example luminanceglfw would have a gethandlesurface GlfwSurface glfwWindow function That way if you ever need to use glfwWindow for anything you can just get it instead of having to implement the trait yourself If you like this idea I can make a pull request I couldn t find any good way to pass the number of layers hence the RFC It s also missing D and cubemap array textures but those can come later Otherwise it works Currently the generated wrapper types Vertex have a new static method that is not const We need to turn it const Hi thanks for your work on luminance I was taking a look at the demos on my very old Lenovo X which has a Mobile Series Chipset Integrated Controller from it seems By default mesa reports OpenGL but with some environment variables you can get it to pretend to support OpenGL and GLSL which it does to some degree so running examples becomes MESAGLVERSIONOVERRIDE MESAGLSLVERSIONOVERRIDE cargo run example shaderuniforms One thing failed though uniform type validation Ive dug into the code and it seems luminance uses glGetUniformIndices to retrieve the index of a uniform which it then uses to get its GLTYPE and then theres some mapping going on to a Rust enum and it checks that everything matches Unfortunately on this machine glGetUniformIndices seems to always return rather it doesnt seem to write anything to the output but its kinda hard to tell because it has a void return type At any rate it doesnt write GLINVALIDINDEX maybe GLINVALIDOPERATION is generated though I didnt check Anyway it kept getting the index so there were some type mismatches as soon as you had multiple uniforms I got it working on this computer by switching to glGetUniformLocation instead but Im entirely unsure that this is the right fix In particular the docs seem to indicate that it wouldnt work for structures arrays of structures etc I see UniformBuilder already has some logic to get the indexlocation are those two different concepts of a uniform whether its a uniform block or just a uniform maybe that could be used for type validation Im not submitting a PR right now as unfortunately rustfmt was applied to my local copy and as I said Im not sure this is even a viable fix I think there could be some code reuse opportunity here but heres what my uniformtypematch function looks like rust Check whether a shader program s uniform type matches the type we have chosen fn uniformtypematchprogram GLuint name str ty Type Result UniformWarning let mut size GLint let mut glty GLuint unsafe get the max length of the returned names let mut maxlen glGetProgramivprogram glACTIVEUNIFORMMAXLENGTH mut maxlen get the index of the uniform let index cfgfeature std here are the actual changes let cname CStringnewnameasbytesunwrap let ret glGetUniformLocationprogram cnameasptr as const GLchar index if ret ret as GLuint else not sure how errors should be handled here maybe add a new type of warning or even an error printlnwarning could not get location of uniform name return Ok cfgnotfeature std let r withcstringname cname glGetUniformIndicesprogram cname asptr mut index if let Err r cfgfeature std return Errformatunable to find the index of name cfgnotfeature std let mut reason Stringnew let write mut reason unable to find the index of name return Errreason get its size and type let mut name VecGLcharwithcapacitymaxlen as usize glGetActiveUniform program index maxlen nullmut mut size mut glty nameasmutptr earlyreturn if array we don t support them yet if size return Ok checktypesmatchname ty glty I havent touched the nostd parts as Im not using them but I suspect theyre similarly affected 