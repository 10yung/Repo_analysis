 dotnet tool uninstall dotnetscript g Tool dotnetscript has multiple versions installed and cannot be uninstalled Version installed dotnet tool list g dotnetscript dotnetscript Hello Thanks for your cool project which is very useful It seems that we cannot have a set of scripts that could be instantiated multiple times run concurrently from the same location dotnetscriptissueMultipleScriptSameLocation It seem that dotnetscriptsrcDotnetScriptCoreCommandsExecuteScriptCommandcs GetLibrary method have an hardcoded default single name for all scripts of the same location path which is scriptdll Is there a specific reason for that or are you able to use the scriptFileName or a GUID as unique identifier for example for your next release Thanks a lot Running dotnet script publish maincsx returns the following dotnet script publish maincsx dotnet publish failed with result This command had worked before but for unknown reasons it has stopped working The script itself is the script generated by the dotnet script init command which is simply to print to the console a Hello World message Ive checked permissions of the folder uninstalled and reinstalled the tool but nothing has changed Further attempts on trying to publish the script have been unsuccessful It is however able to publish into a dll oddly enough and is able to execute properly as well as a dll Other commands such as dotnet script maincsx run successfully and return the output message Im getting an error when I run a script in multiple pieces which would obviously be very useful in a REPL scenario The error is error CS Argument cannot convert from SystemNetHttpFormUrlEncodedContent to SystemNetHttpHttpContent I have researched and compared different C scripting options finding that dotnetscript has the most potential for my interests If the following capabilities are possible I would appreciate tips Ive read every article about dotnetscript that I could find If they are not yet possible let me suggest them as enhancements Create a selfcontained dotnetscriptexe that can be Xcopied to any system that has the NET Core runtime installed Support a straightforward mechanism by which custom commands can be added to the repl Post simple examples of how to execute a string of code at runtime execute a string with references passed to objects that will be available within the execution context and host a dotnetscript repl within an app Thanks for the fine work on dotnetscript The implicit output of expression results in the REPL is a great feature that obviates the need for ConsoleWriteLine and even does a better job at creating meaningful output than straight ToString stringification Especially for presumably typically short code passed to dotnetscript eval it would be handy to have automatic result printing as well so that instead of sh dotnetscript eval ConsoleWriteLine you could simply write something like sh dotnetscript eval p and have automatically printed If I use nuget reference I wouldnt be able to run my script with csi r nuget SystemDirectoryServices It will give me error error CS Metadata file nuget SystemDirectoryServices could not be found If I dont use nuget reference my csx file will work with csi but it wont work with dotnetscript r SystemDirectoryServices It will give me error error CS Metadata file SystemDirectoryServicesAccountManagement could not be found Would it be possible to make my references consistent and work for both csi and dotnetscript For example not using nuget with r for System packages like SystemDirectoryServices This may be a fringe use case but is there a way to save all required dependencies locally This is similar to publishing but would allow code changes rebuilds to the CSX files without needing requiring nuget internet access Is sounds like internally this occurs in some way using the dependency cache but the location of where the files are cached are not allowed to be specified Effectively the workflow Id be looking for is something like dotnet script restore deps or dotnet script vendor dotnet script snapshot this would create the projectassetsjson and store all the required dlls under deps dotnet srcipt foocsx norestore or dotnet script foocsx vendored deps this would run the CSX and rebuild if needed but always used the data cached under deps not the current internal location This allows the folder to be easily copied with the scripts to more secured environments that may not have internet access for nuget Is it possible to take advantage of dependency injection with dotnetscript I have some assemblies that utilize it heavily and its going to be quite difficult to arrange a call to any of the code without DI in place This is a really neat project New users may find it useful to see a list REPL commands when the REPL is launched ps PS C Code dotnet script Commands help Show help information load Load a script into the REPL same as load usage in CSX r Invoking help would show the list of REPL commands again 