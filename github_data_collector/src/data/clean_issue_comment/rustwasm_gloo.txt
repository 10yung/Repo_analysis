This carries on from the work in from rylev Ive tried to address the issues in that thread We could add a reexport of chrono here The reason for this is that to use chrono in the browser you must use a feature that isnt very discoverable I spent about mins getting chrono working We could reexport with the feature turned on by default Summary Note Ive written this using futures but this is something that one could change Provide a set of async functions with the following signature rust fn example impl FutureOutput where the futures resolves in the following places on the next tick of the microtask queue Promisethen at the end of the task queue ie after scheduled repaints setTimeout when the browser thinks we should update an animation requestAnimationFrame after a certain amount of time using setTimeout possibly more places This post about Tasks microtasks etc is how I learnt about all this Motivation This library would serve purposes It would make it easy to select the right time to do your operation and it also educates the user of the library about the intricacies of the JavaScript event loop I think grouping all these together because they are all futures that resolve to nothing at some point make them much easier to understand than how they are arranged in JavaScript scattered everywhere Detailed Explanation I would envisage the functions looking like rust This future will resolve after current execution has finished but before the browser does anything else eg screen repaints This is the fastest choice fn nextmicrotask impl FutureOutput This future will resolve after the browser has finished the current execution and after any other scheduled events eg screen repaints fn nexttask impl FutureOutput This future will resolve when the browser determines that another frame of an animation should be drawn This will be in general slower than nexttask as the browser can process events faster than the screen will refresh fn nextanimationframe impl FutureOutput This future will resolve in the future at least ms milliseconds in the future If you set ms to then this future behaves like nexttask Panics This function will panic if ms is greater than the maximum safe JavaScript integer Fortunately this number is so big that waiting for the future to resolve would take thousand years fn nextmsms u impl FutureOutput Drawbacks Rationale and Alternatives The main drawback is that this is different to the way that JavaScript itself handles all these things The alternative is to not do it Unresolved Questions Callbacks are executed before promises so in theory there could be another function nextcallback that executes before nextmicrotask but since they both execute before any browser events are handled I think that would be overkill The setTimeout wrapper could not panic instead using the nearest f That method could also take a Duration EDIT Formatting Summary Add a crate to parse the KeyboardEventkey field Motivation If youre writing a game or similar you may want to handle raw keyboard events The key event is a string meaning that the names of the special keys are not discoverable By parsing it into an enum we make them discoverable while also making the key cheaper to copy except for the Unknown degenerate case It seems like a good candidate for inclusion in gloo since it doesnt make any design decisions its just parsing the ECMAScript spec but its quite a lot of work to implement Detailed Explanation The enum would look like modulo bikeshedding rust enum Key Visiblechar Alt Ctrl Backspace UnknownString and would be parsed like rust impl Key fn fromjsraw str Self match raw Backspace KeyBackspace maybechar let mut maybechariter maybecharchars let first maybechariternext if let Somech first if maybechariternextissome KeyUnknownrawtostring else KeyVisiblech else KeyUnknownrawtostring Drawbacks Rationale and Alternatives Possible drawbacks It could possibly be slower than working directly with strings although it would be cheaper to cloneetc unless you are in the degenerate Unknown case Maybe noone will use it The alternative is to not do this Unresolved Questions Should the name of the Visible case be short eg K to be more concise Which char methods should we implement Should we convert nonvisible characters like Backspace to their char code eg charfromu key Seems to me like spawn a future is something that gloo would aim to solve but the crate already exists under rustwasm wondering if it should be moved here Summary Macro to simplify creating DOM elements Motivation websys often requires multiple steps and type conversions to accomplish the same results as typical html For example a hreffoodivFoodiva currently requires something like this create the div element with text Foo let div HtmlElement documentcreateelementdivdyninto divsettextcontentSomeFoo create the a element and append the div as a child let anchor HtmlElement documentcreateelementadyninto anchorappendchild div set the href on the a element let anchor anchoruncheckedintoHtmlHyperlinkElementUtils anchorsethreffoo Detailed Explanation From a consumers point of view the above could be simplified as el a AnchorOptionshref foo el div None Foo The concept is following the same idea as Reacts createElement wherein the arguments are element type element props optional children optional Children must be another element or raw text or slices of those Macros can be used to allow for shorthand and remove the need for wrapping things in Some in other words all of these are legal and mean the same thing el div None None el div None el div Same with these el div None SomeFoo el div None Foo And multiple children could be wrapped in brackets el div None el div None Hello el div None World Prior Art The concept of the above is exactly the same as React createElement only instead of creating proprietary elements it creates real elements There are a few known projects that use a macro to ultimately create html elements as well either through a vDom or directly Seed Dominator Drawbacks Rationale and Alternatives Not sure Im opening this issue more for discussion than a direct proposal Feel free to shoot it down Unresolved Questions Where does Document come from How to interop with other crates For interop I think as long as the macro returns native HtmlElements Id imagine that will flow organically Specifically how do we attach an event listener to nested children On one foot it seems that this is doable if we break it apart let child el button None Click Me EventListenernewclick child move e let parent el div None child Implementation for rfc This implementation is not complete Left to do Finalize design for errors Implement event based callbacks Tests Documentation Continuing from issue Summary I propose adding a crate that wraps common websys features with a cleaner API Examples Wrap things like Window Document and History in a way that handles failures automatically with expectthrow Provide shims to get or set the value of input etc elements Wrap consolelog and consoleerror with a more flexible API Motivation The websys api can be verbose highlevel crates neednt each provide their own wrappers Detailed Explanation Some common features of websys are verbose when used directly Its likely that many Gloo crates will make use of them lets settle on a general wrapping API higherlevel crates can use Example Examples rust Convenience function to avoid repeating expect logic pub fn window websysWindow websyswindowexpectthrowCant find the global Window Convenience function to access the websys DOM document pub fn document websysDocument windowdocumentexpectthrowCant find document Convenience function to access the websys history pub fn history websysHistory windowhistoryexpectthrowCant find history Simplify getting the value of input elements required due to the need to cast from general nodeselements to HTMLElements pub fn getvaluetarget websysEventTarget String if let Someinput targetdynrefwebsysHtmlInputElement return inputvalue if let Someinput targetdynrefwebsysHtmlTextAreaElement return inputvalue if let Someinput targetdynrefwebsysHtmlSelectElement return inputvalue into Similar to getvalue pub fn setvaluetarget websysEventTarget value str if let Someinput targetdynrefwebsysHtmlInputElement inputsetvaluevalue if let Someinput targetdynrefwebsysHtmlTextAreaElement inputsetvaluevalue if let Someinput targetdynrefwebsysHtmlSelectElement inputsetvaluevalue Drawbacks Rationale and Alternatives The original websys APIs arent that clumsy this might clutter up Gloo without providing much benefit Perhaps we want to use pattern matching to handle failures of websysWindow etc instead of using expectthrow Its easy to create a collection of helper functions that are intended to be general but spread over a wide range of uses some of which may not be common Its possible that they may cover a smaller set of usecases than intended Thin wrappers in general can be seen as obfuscating the original wellknown API Why build a new API that causes confusion with the one it wraps when its not much better Unresolved Questions Its unclear what the scope of this should be There are surely grey areas about whats appropriate here and how cohesivecomprehensive it should be What causes websysWindow etc to fail Im certainly biased by my own usecases Do yall think these are infact useful general wrappers that would see use in manymost Gloo crates Ive only scratched the surface What else should be added This is the first step of 