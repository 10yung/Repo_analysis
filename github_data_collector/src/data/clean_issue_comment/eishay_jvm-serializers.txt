Can someone with a new machine run the benchmarks and update the wiki content Java would be nice Can you add Moshi from Square as one of the serializer and compare it with the others Hi there first of all thank you for the great benchmark It is a very nice resource I wanted to point out that format which support random value access like CapnProto and FlatBuffers are measured a bit unfair The deserialise methods of the test make a copy of every value encoded in the buffer even though it is not necessary The buffers are serialised in a way that make them accessible on demand without the need of actual unmarshaling In this gist you can find a rewritten test for FlatBuffers Which passes and returns following result for decoding average ms deviation ms Formats which invest in supporting random value access do it at cost of size and encoding speed This is why I find it unfair to show the shortcomings of encoding and go around the benefits of the decoding Hi the create time is visible in the performance breakdown but not the deallocation time For applications which huge number of object creation the object deletion might be just as important for the performance this is a scripted migration to a valid maven project structure with things from lib mapped in a repo to srcmainrepo with inferred versions uninferrable packages live in a package called deprecated no commentary or assumptions are made about the source code prior to the mavenized tree im still trying to navigate adding my own serializer which depends upon a maven plugin weighing options its an old script but the assumptions all still work for maven I did not presume to run this for clean checkin sake This is the very first mechanical generated output do not merge to master by all means consider ivy or gradle with the repo however better stats output separate VM for each serializer moved to average measurement median quantile also implemented but just sysouted categorized all serializers tested with cygwin someone check linux preview of stats see Since we seem to have lingering disagreements on whether to reuse ByteArrayOutputStream used for output it would make sense to add one more commandline switch to enabledisable such reuse Hello Eishay Firstly thanks very much for this tool its really useful We use it quite a bit to benchmark new releases of our own code to ensure that there are no regressions I saw that there were the beginnings of providing perserializer classloading To make our testing easier I went ahead and implemented something that works for me Of course it may not be good for every flavor of serializer but it seems to be OK Although Scala doesnt work yet Admittedly its not complete but I thought you might be interested in taking a look and perhaps even using it in the mainline code Thanks Jens Changes Moved various core classes into a core package These classes get loaded by the system classloader Created a libcore directory which contains the cks jars These jars are also loaded by the system classloader As part of the build the serializer specific classes are moved to buildbytecodemainsx in order to easily reference them via a path which doesnt contain any core classes This path is passed in via the system property loaderclasspath Each serializer is initialized using its own classloader and this path Each serializer classloader is also given the jars in lib The classes in buildbytecodemainsx and jars in lib cannot be referenced by the system classloader otherwise this mechanism breaks Only those serializers which are referenced using include are actually initialized There is a mapping between serializer name and the implementing class see BenchmarkBasejava Unfortunately this serialzer name doesnt get used when initializing the actual class so the name in the class still needs to be maintained For some serializers one register invocation actually produces multiple tests each with a different name Need to figure out how to remove this redundancy Only some of the serializers have been tested using this new structure Scala doesnt work 