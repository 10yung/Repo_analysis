Method csharp public async Taskint GetLastChapterNumberAsyncint storyId var query SELECT MAXchaptersnumber FROM chapters WHERE chaptersfictionid nameofstoryId using var connection new NpgsqlConnectiondatabaseOptionsConnectionString return await connectionQueryFirstOrDefaultAsyncintquery new storyId A zero is expected when storyId is not found However I receive an exception Method works correctly when chapter exist Exception Object reference not set to an instance of an object at DapperSqlMapperQueryRowAsyncd MoveNext in C projects dapper Dapper SqlMapperAsynccsline at SystemRuntimeExceptionServicesExceptionDispatchInfoThrow at SystemRuntimeCompilerServicesTaskAwaiterThrowForNonSuccessTask task at SystemRuntimeCompilerServicesTaskAwaiterHandleNonSuccessAndDebuggerNotificationTask task at SystemRuntimeCompilerServicesTaskAwaiter GetResult at DataRepositoriesChapterRepositoryGetLastChapterNumberAsyncd MoveNext in C src App AppData Repositories ChapterRepositorycsline update It seems to have no problem when using a nullable int I set the maximum number of threads is and now I do stress testing with jmeter I set up in the number of threads started to access an interface this interface is a single table query I monitor database links created only without executing SQL statements such as dozens of seconds an error my program using the docker in Linux running in a container there is no problem in the Windows environment under Linux is problematic net core dapper Error message is InputMessageTimeout expired The timeout period elapsed prior to obtaining a connection from the pool This may have occurred because all pooled connections were in use and max pool size was reached Think you help me SingleOrDefaultint intquery always returned null because the IsValueTuple did not handle nullable types and thus the GenerateValueTupleDeserializer method was never called Ive added test for the case when the query does not return something the tuple should be null and when it does return something Additionally added tests for the edgecase where you select or element tuples to make sure nothing broke there Currently this code always returns null csharp connectionQuerySingleOrDefaultint id string nameselect Bob That is because IsValueTuple does not handle the case where its a NullableValueTuple and because of that the special logic for value tuple deserializer generation GenerateValueTupleDeserializer is not called Then presumably it follows the normal deserializer logic for structs and it would expect the above query to return columns called Item and Item Hello I face huge slowness when using DynamicParameters with a list The setup I am using Dapper framework Net My Db is Azure SQL Server As a service from Azure The table I request has this structure TABLE MYTABLE firstid numeric NOT NULL secondid int NOT NULL entrystart datetime NOT NULL entryend datetime NOT NULL value numeric NULL CONSTRAINT PKMyTable PRIMARY KEY CLUSTERED firstid ASC secondid ASC entrystart ASC entryend ASC The prove that this is not an index problem When I do the following there is no problem it is almost instantaneous var request select firstid secondid entrystart entryend value MYTABLE where firstid in and entrystart startdate and entryend enddate var param new DynamicParameters paramAddstartdate startDate paramAddenddate endDate var result connectionQueryMyTableDtorequest param The problem But when I want to use a param for firstid the request remains stucked var request select firstid secondid entrystart entryend value MYTABLE where firstid in ids and entrystart startdate and entryend enddate var ids new Listint var param new DynamicParameters paramAddids ids paramAddstartdate startDate paramAddenddate endDate var result connectionQueryMyTableDtorequest param Help please Do you have any idea of what causes this slowness Regards With PostgreSQL the manner in which a key property name is quoted is inconsistent between the UpdateDelete and GetInsert methods causing either Update and Delete or Get and Insert to potentially fail depending on database configuration Update and Delete use PostgresAdapterAppendColumnNameEqualsValue when appending the key field to sql which puts around the field as expected However Get and Insert fail to put quotes around the key field Get inserts the key field into the sql string directly link Insert calls PostgresAdapterInsert which fails to include quotes as part of the RETURNING sql link The result of this is if the id property is not all lowercase both in the NET class and in Postgres then either Get and Insert or Update and Delete will fail because Postgres is case sensitive and will automatically transform any column identifier to lowercase unless it is wrapped in double quotes Eg if the key field is ID in NET and ID in Postgres Get and Insert will fail because Postgres will automatically transform ID to id as it is not enclosed in double quotes if the key field is ID in NET and id in Postgres Update and Delete will fail because Postgres wont automatically transform ID to lowercase because it is enclosed in double quotes A solution for this would be Get should append the ID field with an adapterspecific call much like Update and Delete call ISqlAdapterAppendColumnNameEqualsValue PostgresAdapterInsert should use double quotes when appending the key field to the sql StringBuilder Fix for I annotated the public API in for fun and in case it could be helpful I dont have a use case for this feature as a Dapper user right now and Im not asking for it NickCraver had good thoughts and asked me to open an issue for discussion There are some big drawbacks It would hose pretty much all open PRs Fixing the new warnings results in a big change to review Flip side there are definitely bugs that got caught Using C with any target framework other than NET Core is officially unsupported by Microsoft even though they tell library authors to use this unsupported configuration for the purpose of NRT annotation If Im paraphrasing correctly Nick is concerned that enabling NRTs could make it easier for nulls to leak in or out of Dapper APIs in places where they are currently supposed to never be null Is there anything that Dapper would stand to gain by paying these costs aims to fill the tooling gap by copying nullability annotations from NET Core into the reference assemblies you compile against and by providing internal nullability attributes as source I use it for active projects from net to net and netstandard There arent any technical limitations I know of compared to the NRT experience on NET Core itself Besides bugs in this community tool of course If the DbString Length is set smaller than the value of the actual string whether or not the IsAnsi flag is true or false the value passed into the DbString will be silently truncated in the database call We experienced this in one of our apps when the value we passed in was greater than the length value specified in the dapper code and the resulting search came back with different data Our fix was to build our own nuget package that would set the DbString length to the size of the string value