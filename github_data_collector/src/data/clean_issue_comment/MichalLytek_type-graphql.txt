When we serialize the raw typescript entity object this doesnt respect the various field annotations in our GQL entities and ends up leaking unwanted data Example below a Profile entity class import Field Int ObjectType from typegraphql import Column Entity ManyToOne OneToMany from typeorm import Account from accountaccountentity export class Profile Field Column unique true public username string Field Column public name string Relations Column public accountId string ManyToOnetype Account account accountprofiles eager true public account Account account has sensitive data When we JSONstringify a Profile reference we dont want account output Account is not annotated with Field and we expect it would not be output Is your feature request related to a problem Please describe I have been using a pattern of coupling associated functions or values with the enum in a namespace with the same name I like it as it simply keeps things tidier and easier to find but I can understand if some people mightnt like it When complied the values declared in the namespace become included in the enum as one single object The problem is when TypeGraphQL reads the enum it understandably includes every key including functions arrays etc typescript export enum DateGranularity hourly hourly one grain per hour daily daily one grain per day fullCampaign fullCampaign one grain for the entire campaign export namespace DateGranularity export const asArray DateGranularityhourly DateGranularitydaily DateGranularityfullCampaign returns true if a is finer granularity than b ie site is finer grain than region export function isFinerOrEquala DateGranularity b DateGranularity return a b a DateGranularityhourly a DateGranularitydaily b DateGranularityfullCampaign registerEnumTypeDateGranularity name DateGranularity eg helper functions can be used as such DateGranularityisFinerOrEqualDateGranularityhourly DateGranularitydaily This renders the following schema graphql enum DateGranularity hourly daily fullCampaign asArray notice the array and function are included isFinerOrEqual Describe the solution youd like Ive read over the internal code and can understand what is happening Id be quite happy to make a PR with the changes but I can see a few possible routes or perhaps its not a desired feature Possible solution As TypeScript only allows strings and numbers as enum values I think the most intuitive and straight forward solution is to modify getEnumValuesMap and simply only include string or number values in the map hence stripping out any functions arrays etc declared in namespaces Please correct me though if this wouldnt work Possible solution Alternatively rather than doing it automatically EnumConfig could be modified to have an optional whiteblacklist of keys to include in the schema It is a bit more flexible but I prefer solution as it uses existing language restrictions and doesnt require any extra declarations While it doesnt really match my exact use case this solution may perhaps be useful to be able to shield of certain enum values ie internalonly values from the schema Obviously there are fairly straightforward workaround to achieve that though Describe alternatives youve considered I tried having a wrapper function for registering which would register a different object with only the keys I wanted but this doesnt work when you try to use the enum as an inputoutput type because it tries to find the enum by equating objects which fails as the full enum and object with desired keys are different Hello wave First of all thank you very much for your work on this library it has helped us a lot in rapidly creating a graphql endpoint to go hand in hand with our existing REST API In this PR I will attempt to address this issue I have tried to base my implementation off of the comments I could read in the issue and also in the PRs that were previously created for this I also took inspiration from the Directive PR which helped me by showcasing recent good PR practices on the project I will leave several comments of my own where I am unsure about my approach I would be grateful if you could let me know your views on them and also for any time you would spend reviewing the PR I wont be very active during the upcoming weekend but Ill definitely try to address any feedback as fast as I can during the next week Best Before I send pull request I want to make sure I am thinking about this the right way I patched the compiled metadatagenerator code to test this idea For real code I would presume some configuration customized text filtered internal roles not showing in docs etc buildClassMetadatadefinitions definitionsforEachdef const fields thisfieldsfilterfield fieldtarget deftarget fieldsforEachfield iffieldroles fielddescription fielddescription fielddescription user can authorize via roles ArrayisArrayfieldroles fieldrolesjoin fieldroles deffields fields Describe the bug So Im not sure if this is a bug or Im simply doing something wrong but it seems confusing I found defaultValue through intellisense on Field and Im using it on ObjectType Setting a defaultValue on a field makes the field nullable I couldnt find any documentation regarding defaultValue other than for Args To Reproduce ObjectType export class Test Field defaultValue public testField number Generates the following schema type Test testField Float Additionally trying Field defaultValue nullable false results in the following error node UnhandledPromiseRejectionWarning Error Wrong nullable option set for testField You cannot combine default value with nullable false at ObjectwrapWithTypeOptions nodemodules typegraphql dist helpers typesjs Expected behavior The schema should have the field marked as required type Test testField Float Enviorment please complete the following information OS Windows Node v Package version TypeScript version Is your feature request related to a problem Please describe We are using extensively cool TypeScript feature which allows parameters from constructor map to class members Example ts export class User constructor public id number public username string then ts let admin new User admin consolelogadminid prints Describe the solution youd like I would like to be able to decorate these parameters as well Describe alternatives youve considered Dont use this TS feature I am thrilled to present the first preview of the upcoming TypeGraphQL Prisma Framework integration integration logo You can install it right now its distributed as a package typegraphqlprisma on NPM All the docs in readme examples and the source code of the integration are located on the prisma branch of this repo in the future it will be moved into a master branch when I finish converting the project to a monorepo Currently released version x is just a preview it lacks some customization option like pickingomitting fields of object types to expose in the schema as well as picking CRUD methods and exposed args However the base functionality is working well so I strongly encourage you to give it a try and play with it Any feedback about the developers experience bug reports or ideas about new features or enhancements are very welcome However during the preview I would ask to add comments only in this issue not to create a new issues as I dont want to pollute the repo for now And in the near feature when Prisma SDK will be ready the typegraphqlprisma integration will also allow to use a codefirst approach to build a schemaprisma and GraphQL schema at once using classes with decorators as a single source of truth Stay tuned muscle Describe the solution youd like Id like to be able to put authorization checks inside the subscription topics option so that I can dynamically block or allow users on subscriptions Right now my auth checks are asynchronous but the SubscriptionTopicFunc doesnt accept Promises Describe alternatives youve considered Its possible to put the authorization checks in the filter method or in the subscription logic itself however this means that the authorization checks will fire for every event instead of just once at subscription time which is much more expensive Additional context Add any other context or screenshots about the feature request here Is your feature request related to a problem Please describe Trying to write client code which queries a graphql server whose resolvers and types were defined using typegraphql Im building a webpackdevserver alternative that supports HMR in node and web and Id like to use graphql to define a datatransfer method agnostic API for fetching bundle updates eventually support remote javascript debugging Describe the solution youd like I would like a typescript graphql client to be generated at compiletime based on the typegraphql ObjectType definitions with a designtime typed client API available This could be a separate package from typegraphql like typegraphqlclient Describe alternatives youve considered The third option doesnt work because its React specific The first two are headed in the right direction but they vend a CLI that requires connection to a running graphql server These options just inspect the predefined schema in order to generate the client so theoretically we should be able to generate a client based on typegraphql ObjectTypes since these ObjectTypes act as the source of truth for generating a graphql schema Additional context Ideally the typegraphql annotated ObjectType classes would be isomorphic typescript a DTO shared between client and server Often times clients are bundled via webpack for example but right now there are difficulties bundling typegraphql into a webpack bundle because it has nodespecific dependencies there are imports to fs and path in the codebase for example which means I cant bring an ObjectType annotated class into a web targeted bundle without some config hacks One workaround would be to separate the typegraphql annotations into a separate library like typegraphqlannotations which has zero dependencies and is written to run in any javascript runtime in this case the annotations would be used more like metadata tags rather than performing any operations and then the main typegraphql node library or the typegraphqlclient library would be able to interpret the meaning of the tags then generate a graphql schema via graphqljs or a graphql client respectively Ideally the typegraphqlclient library would only know how to generate query strings and would have no knowledge of where or how to submit the strings That choice would be left up to clients of the library If youre open to something like this Id be happy organize this project understand typegraphql more organize a backlog work on some epicsstoriestasks The upcoming Prisma integration will generate TS classes with TypeGraphQL decorators based on data model definition of Prisma schema But to allow for further customization TypeGraphQL needs some operators to transform the generated classes into the user one Mainly to hide some fields from database like user password so we need a way to omit some fields of the base class or pick only some selected fields Proposed API have two approaches to apply the transformation pickomit fields from emitted GraphQL schema using decorator option ts ObjectType pick firstname lastname export class User extends BaseUser ObjectType omit password salary export class User extends BaseUser This approach is for use cases where you still want to have access to the hidden fields in other field resolvers like hidding array or rates but exposing average rating by the field resolver pickomit fields both from emitted GraphQL schema and TS type using class wrapper ts ObjectType export class User extends PickBaseUser firstname lastname ObjectType export class User extends OmitBaseUser password salary This approach is better when you want to create a derived type like a subset of some input type so you wont accidentally use the not existing field Initial version might not support inheritance or have a prototype methods leaks because its not needed by the Prisma integration In the next release cycle I will try to make it work with broader range of use cases Later more types transformation utils will be implemented like PartialFoo for making fields optional RequiredFoo for making fields nonnullable If possible maybe I will try to add even a mapping util that will map the keys of one type to new values in a new type For example if you want to generate a sorting input with field types only ASCDESC based on an object type which fields are representing database columns 