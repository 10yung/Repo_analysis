The Dockerfile in either the clang or the gcc folders ends with a aptget update How does nng get built Im using the lastest version nng lib on windows And get some error in my code I wanna make a pubsub test My code is like this nngsocket sock NNGSOCKETINITIALIZER if rv nngpubopen sock fatalnngpubopen exit stdstring url tcp if rv nngdialsock urlcstr NULL fatalnngdial exit There is a issue when nngdial the function returns it means Interrupt Is there something wrong in my code my url is wrong I cant find anything in demo code This correctly moves the entire protocol header for XREQ and XRESPONDENT protocols to the message header not the body This is where it should always have been There is some small chance that applications which were coded to parse the header from the body will break We dont think there are any such applications in use fixes issue number issue synopsis Comments describing your change Not all changes need this Note that the above format should be used in your git commit comments You agree that by submitting a PR you have read and agreed to our contributing guidelines There is code for nngmsggetopt and underlying nnimsggetopt and nnimsgsetopt that is entirely unused today The idea here was to support collecting data from the pipe so that we could provide details like the authentication details certificate or credentials on a message In the time since that code was written weve found no practical use for it as the nngmsgpipe lets us achieve the same things This extra support for options means we have extra banches as well as space in every message header that is unused This is not free and we should clean it up The legacy nngmsggetopt function should return NNGENOTSUP and be marked deprecated or even removed entirely from the documentation A stub will have to be left behind to avoid breaking any program which might have a link dependency on it The raw mode stuff is really inconsistent in its use of the message headers For some protocols we discard a header if it is present when sending but then we put data in the header on receive for others My feeling is that we should choose one of two options Eliminate the header from the raw mode public API and always place the header in the received message body There is probably usually room although there might not be if there is a big backtrace which would make reallocation painful Backtrace limits of just a half dozen would be fine though Consistently use the header for message header and only leave user data in the body Thats not what compat expects though Im starting to lean towards the first option Elimination of the public header API would also eliminate a common point of confusion Hello The comment nngsupplementalhttphttph line says that this function will fail with NNGENOTSUP if the server replies with a chunked encoding But it seems that the documentation is out of date and chunked encoding is handled properly Because we use semantic versioning it should be possible to use the nngh header file to provide the NNGABIVERSION in the CMakeListstxt This would make this a little less error prone when it comes to editing Also we should look at better ways to handle prereleases ie what is on tip Probably we want to branch each time we create a release going forward The top of pages says This documentation is for version of nng but the latest released version is Please see the documentation for for the most uptodate information With a link that goes to while it should be NNG Platform details NNG tag on Linux x Expected Behavior nngctxsend should not crash when TX data is set via nngaiosetiov Actual Behavior I modified the nngdemoasyncserverc code to set TX data via nngaiosetiov instead of nngsetmsg The subsequent call to nngctxsend crashes in nnimsgheaderappend because the message inside struct aio is already freed It seems nngctxsend can only handle messages not iovs Steps to Reproduce Modify example from nngdemoasyncserverc case workRECV auto rv nngaioresultworkaio error handling omitted for brevity auto msg nngaiogetmsgworkaio RX msg handling omitted for brevity nngmsgfreemsg MSG in struct AIO is freed here modification directly send response state WAIT does not exist in my code generation of TX data omitted for brevity struct nngiov iov ioviovbuf txdata ioviovlen txdatalen rv nngaiosetiovworkaio iov error handling omitted for brevity workstate workSEND nngctxsendworkctx workaio BOOM here break The idhash code currently has an embedded lock This was design to make it intrinsically MT safe But it turns out that we use it in contexts where need to have a surrounding lock anyway and this extra lock actually hurts us We can gain a little bit by eliminating the lock and making consumers provide their own locks