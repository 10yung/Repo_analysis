Fix a bug where using SystemLinq using MoreLINQ Causes calls to ToHashSet to fail to compile because an identical implementation exists in Net The base Net framework starting in Net Framework and Net Core includes its own IEnumerable extension method ToHashSet It should be removed from MoreLinq with a compiler flag for and Core Currently its easy to end up in a place where you cant compile if you have using statements for both SystemLinq and MoreLinq What about adding extensions allowing producing diffgrams between sequences of objects with value and id identity The desired behavior would be csharp TestMethod public void CompareValueIdentity var source new var modified new var inserted deleted sourceComparemodified CollectionAssertAreEqualnew insertedToArray CollectionAssertAreEqualnew deletedToArray And csharp TestMethod public void CompareIdIdentity var source new A B C var modified new B D E var inserted updated deleted sourceComparemodified x xItem CollectionAssertAreEqualnew E insertedToArray CollectionAssertAreEqualnew D updatedToArray CollectionAssertAreEqualnew A deletedToArray Library code is csharp public static class SequenceChange public static IEnumerableT Inserted IEnumerableT Deleted CompareT this IEnumerableT source IEnumerableT modified sourceComparemodified EqualityComparerTDefault public static IEnumerableT Inserted IEnumerableT Deleted CompareT this IEnumerableT source IEnumerableT modified IEqualityComparerT comparer modifiedExceptsource comparer sourceExceptmodified comparer public static IEnumerableT Inserted IEnumerableT Updated IEnumerableT Deleted CompareT TKey this IEnumerableT source IEnumerableT modified FuncT TKey keySelector sourceComparemodified keySelector EqualityComparerTDefault public static IEnumerableT Inserted IEnumerableT Updated IEnumerableT Deleted CompareT TKey this IEnumerableT source IEnumerableT modified FuncT TKey keySelector IEqualityComparerT comparer modifiedExceptBysource keySelector from s in source join m in modified on keySelectors equals keySelectorm where comparerEqualss m select m sourceExceptBymodified keySelector This PR add TestSortedMergeDoNotCallMoveNextEagerly Unlike for Interleave this test pass This PR addresses As discussed here in with current implementation of Interleave The code below throws C var sequenceA TestingSequenceOf var sequenceB new BreakingSequenceint var interleave sequenceAInterleavesequenceBTake ToList While we can expect interleave to be a list of one element Added TestInterleaveEarlyThrowOnNullElementInOtherSequences TestInterleaveDisposesAllIteratorsOnPartialEnumeration Hi Im making updates for Open Collective Either you or another core contributor signed this repository up for Open Collective This pull request adds financial contributors from your Open Collective What it does adds a badge to show the latest number of financial contributors adds a banner displaying contributors to the project on GitHub adds a banner displaying all individuals contributing financially on Open Collective adds a section displaying all organizations contributing financially on Open Collective with their logo and a link to their website PS As with any pull request feel free to comment or suggest changes Thank you for your great contribution to the Open Source community You are awesome And welcome to the Open Collective community Come chat with us in the opensource channel on great place to ask questions and share best practices with other Open Source sustainers Use a LinkedList in Interleave implementation to avoid many null checks See Transpose Interleave and SortedMerge are three methods that have to deals with enumeration of a collection of IEnumerable In this three methods implementation have to ensure that all enumerators from the input enumerables are disposed when The enumeration of the input collection of IEnumerable fail The result sequence enumerator is disposed is assured by Acquire in the three methods is assured by DisposableGroup in SortedMerge and by some try finaly blocks in Transpose and Interleave and those make Acquire useless as discussed here Acquire return an array DisposableGroup is based on an list For the three methods we can build cases where enumerators are heavily removed from the arraylist or for Transpose tested as null Since remove for arraylist or repeatedly skip null elements is ON in time that lead to ON time complexity This can be easily fixed with the use of a LinkedList and by removing null elements from it I propose a ToDisposableLinkedList method that have the functionality of Acquire on error dispose already acquired elements and provide a DisposableLinkedList that have the functionality of DisposableGroupT being disposable and dispose its content when disposed It will be used like that C using var enumerators sourceSelecte eGetEnumeratorToDisposableLinkedList The using here allow to remove the try finally from here and here and improve the DisposableGroupAcquire combo from here 