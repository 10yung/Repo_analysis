Fix for Package This issue is related to the following monorepo packages eyeglass broccolieyeglass x emberclieyeglass Description When multiple versions of emberclieyeglass are in the nodemodules tree especially common when using yarn link theres not a single version of the singleton weak maps that are used to get the assets installed into the main application This causes there to be missing data and results in an exception Expected behavior The different instances of emberclieyeglass should coordinate correctly and use the same shared data Package This issue is related to the following monorepo packages eyeglass broccolieyeglass x emberclieyeglass Description Theres a weird issue in a LinkedIn project where a file that isnt installed gets installed anyway js let ignoredExtensions new Set js css eyeglassassetsinstallerfunction myInstaller assetFile assetUri oldInstaller cb const assetExtension assetUrisplitpop if ignoredExtensionshasassetExtension cbnull assetFile else oldInstallerassetFile assetUri cb Returning null should cause the asset to not be installed but they are seeing that it is found after restarting the server Let s get started with automated dependency management for eyeglass muscle Greenkeeper has found a yarnlock file in this repository Greenkeeper supports lockfile updates for public packages If you use private packages in your repository please use greenkeeperlockfile to make sure these can get updated as well This pull request updates all your dependencies to their latest version Having them all up to date really is the best starting point for keeping up with new releases Greenkeeper will look out for further dependency updates and make sure to handle them in isolation and in realtime but only after you merge this pull request Important Greenkeeper will only start watching this repository s dependency updates after you merge this initial pull request Greenkeeper has detected multiple packagejson files They have all been added to a new greenkeeperjson config file They ve been collected in a group called default meaning that all of them will receive updates together You can rename add and remove groups and freely assign each packagejson to whichever group you like It s common for example to have one frontend group and one backend group each with a couple of packagejson files In any case all files in a group will have their updates collected into single PRs and issues details summary Tests on this branch are failing Here s how to proceedsummary To solve the issue first find out which of the dependency s updates is causing the problem Then fix your code to accomodate the changes in the updated dependency nextupdate is a really handy tool to help you with this Then push your changes to this branch and merge it details details summary How to check the status of this repositorysummary Greenkeeper adds a badge to your README which indicates the status of this repository This is what your badge looks like right now pointright Greenkeeper badge details details summary How to configure Travis CIsummary Greenkeeper has added a rule to your travisyml that whitelists Greenkeeper branches which are created when your dependencies are updated Travis CI will run your tests on these branches automatically to see if they still pass No additional setup is required details details summary How to ignore certain dependenciessummary You may have good reasons for not wanting to update to a certain dependency right now In this case you can change the dependency s version string in the packagejson file back to whatever you prefer To make sure Greenkeeper doesn t nag you again on the next update add a greenkeeperignore field to your packagejson containing a list of dependencies you don t want to update js packagejson greenkeeper ignore packagenames youwantmetoignore details details summary How to update this pull requestsummary bash Change into your repository s directory git fetch all git checkout greenkeeperinitial npm installtest Adapt your code until everything works again git commit m chore adapt code to updated dependencies git push greenkeeperinitial details details summary How do dependency updates work with Greenkeepersummary After you merge this pull request Greenkeeper will create a new branch whenever a dependency is updated with the new version applied The branch creation should trigger your testing services and check whether your code still works with the new dependency version Depending on the the results of these tests Greenkeeper will try to open meaningful and helpful pull requests and issues so your dependencies remain working and uptodate diff underscore underscore The above example shows an inrange update is included in the old range because of the caret character When the test services report success Greenkeeper will silently delete the branch again because no action needs to be taken everything is fine However should the tests fail Greenkeeper will create an issue to inform you about the problem immediately This way you ll never be surprised by a dependency breaking your code As long as everything still works Greenkeeper will stay out of your way and as soon as something goes wrong you ll be the first to know diff lodash lodash In this example the new version is not included in the old range For version updates like these let s call them out of range updates you ll receive a pull request This means that you no longer need to check for new versions manually Greenkeeper will keep you up to date automatically These pull requests not only serve as reminders to update If you have solid tests and good coverage and the pull requests passes those tests you can very likely just merge it and release a new version of your software straight away shipit To get a better idea of which ranges apply to which releases check out the extremely useful semver calculator provided by npm details details summaryFAQ and helpsummary There is a collection of frequently asked questions If those don t help you can always ask the humans behind Greenkeeper details Good luck with your project and see you soon sparkles Your Greenkeeper bot palmtree The Eyeglass API is currently optimized for wrapping a call to sass by transforming the options for a single compile Often there are many files to compile that share the same compilation options and the work to discover eyeglass modules can be shared across those compiles In Eyeglass we should expose a new class that optimizes for compiling many stylesheets and sharing the work of module discovery and resolution The goal would be that this instance can be long lived and used to compile multiple versions of the same files over time Package This issue is related to the following monorepo packages eyeglass broccolieyeglass X emberclieyeglass Description Emberclieyeglass does not respect outputPath configuration like the example in ember docs To Reproduce Steps to reproduce the behavior Add outputPath configuration css file does not appear in the right location Expected behavior Css file should show in the right location Package This issue is related to the following monorepo packages eyeglass broccolieyeglass x emberclieyeglass Description Currently discover true is optin but I suspect our goal was for this to be the default I could like to recommend we flip the default to be true and do a major version bump Questions thoughts suggested timelines Originally opened by MrChriZ at Originally opened by MrChriZ at Originally opened by nickiaconis at 