Im very interested in a bit of feedback on naming for the Jedi API So ccing a few people so I might get answers blueyed dbrgn Currently the Script names are completions gotoassignments gotodefinitions callsignatures and names Now I want to clean this up a bit The new names will be complete goto goes to a names definition infer inferres types for any statement help basically a goto with more documentation information getcontext returns the current context findsignatures returns signatures of the call a user is currently in listnames returns all namesdefinitions of a Python file Especially findsignatures and listnames are a bit long and also not very nice Im considering naming them just signatures and names but those are not verbs so Im a bit conflicted So looking for opinions What are the best names def annotateddecoratorfn Callable R Callable R works but def annotateddecoratorfn Callable R Callable R doesnt See code import jedi script jediScriptfrom tkinter import Tk root Tk rootgeometr for c in scriptcompletions printcgoto output Definition fullnametkinterWmgeometry descriptiongeometry wmgeometry Should be get wmgeometry definition And jedi api classespy jedi api initpy goto function param should be consistent miss followbuiltinimports followimports Traceback most recent call last File py line in module printcgotofollowimportsTrue File E Downloads jedi api classespy line in goto return selfgotokwargs TypeError goto got an unexpected keyword argument followimports The PR is related to Knowing that jedi has type inference capabilities is it possible to add a way to filter out invalid signatures eg python from typing import overload overload def fx str y int overload def fx str y bool overload def fx list y bool def fx y pass python f should return all signatures python fHello The last signature is dropped python f Only the last signature is returned Related to This is a follow up to General goalsideas Interpreter should use annotations of the object it is trying to auto complete on mostly functions for now This should work already c ecb extends this so PEP annotations should work too There are still some pitfalls but this should be strictly better than the current implementation If a stub package is available there should be the option for the completer to use this instead of what the object provides First this should work for any typical stub package that is installed in the used virtualenv and for pyi files in the actual module There are two extremes here that I have actually encountered and have some interest in covering I think the latter is better and is also useful in general An RPC implementation that wants to lie about the annotations of the object based on the annotations of the remote object the possibility to force that all completion for a module happens based on local stub files which would be applied based on the bridged fake type and not the true type RPC object of the object so no RPC calls need to happen for completion Current Todos x Handle PEP annotations Test for PEP annotations Decide on general implementation for annotations in pyi files next to py files Decide on general implementation for annotations in separate stub package Questions I do not have a good high level concept of the jedi architecture yet The first issue is where the stub based inference happens for Script contexts how much of this can be used for Interpreter contexts and if that requires refactoring to move code out of the interpreter context so it can be shared Please search existing issues to avoid creating duplicates Environment data VS Code version Extension version available under the Extensions sidebar OS and version PopOS Ubuntu Python version distribution if applicable eg Anaconda Type of virtual environment used NA venv virtualenv conda virtualenvwrapper Relevantaffected Python packages and their versions pybullet Jedi or Language Server ie what is pythonjediEnabled set to more info Jedi is enabled Expected behaviour IntelliSense code suggestions work after importing packages This problem was apparently fixed in Actual behaviour IntelliSense code suggestions stop working after importing pybullet and linting Steps to reproduce NOTE Selfcontained minimal reproducing code samples are extremely helpful and will expedite addressing your issue Install numpy pip install numpy In a test file import numpy as np foo npzeros dtypenpuint IntelliSense performs autocompletion suggestions Install pybullet pip install pybullet import numpy as np import pybullet as pb foo npzeros dtypenpuint printpbname IntelliSense does not work with either package Note If you think a GIF of what is happening would be helpful consider tools like or Logs Output for Python in the Output panel View Output change the dropdown the upperright of the Output panel to Python Linting Output pylint Module test conventiontrailingwhitespaceTrailing whitespace conventionmissingfinalnewlineFinal newline missing conventionmissingmoduledocstringMissing module docstring Your code has been rated at previous run Problem Currently annotation strings for parameters of compiled functions are created directly from annotation objects by means of str This leads to noisy annotations that are shown to user clip class vapoursynthVideoNode width typingUnion int NoneType None Just two of them may look fine but few dozens of them are definitely not Desired output Annotations for parameters of compiled functions as if they had sources Using example above I believe it should be as following clip VideoNode width Optional int Proposed solution This is just a proofofconcept of desired output to be achievable without much hacking It tries to be as compatible as possible with the rest of codebase so its a bit ugly One more reason why theres no best solution for this is that any attempt to subscript Optional leads to Union NoneType Going to the hacking side I checked that even though Unionorigin and Unionargs arent documented they are available on every CPython since And of course Id like to use getorigin and getargs that are available since Im not familiar with how things are done in jedi codebase and probably missing something so Im looking forward to your feedback and working further on this PR accordingly easy to reproduce with this snippet Change to your filepath obviously python import jedi DOC class B def initself selfz DOCURI filehomempanarinDesktoptestfilesreproducejedifilepy if name main will contain definitions class B def init self z allnames jediapinames sourceDOC pathDOCURI definitionsTrue allscopesTrue referencesFalse assert allnames name z assert allnames parentname init so init is a parent of z BUUUUUUT assert allnames name init this fails as it only contains self assert sorted xname for x in allnames definednames sorted self z another issue I found repr fails for self definitions this print will trigger an exception printallnames definednames Possible enhancement mariusnicolae commented on Sat Sep Please search existing issues to avoid creating duplicates Hi First of all thank you for your wonderful work I like VS Code a lot but there is an issue Id like to report Usually in Python modules there are classes definitions with methods references but without calls with actual types In this case when trying to go to a method definition the VS Code displays a No definition found for methodname message as opposed to Pycharm which displays a menu with all possible methods definitions Even if the Python file contains calls with actual objects the VS Code will go the first definition even if there are multiple possibilities Environment data Version Commit b e c e a ba e e a e ffb Date T Z Electron Chrome Nodejs V electron OS Linux x generic Extension version available under the Extensions sidebar mspythonpython OS and version Xubuntu Python version distribution if applicable eg Anaconda bits Type of virtual environment used NA venv virtualenv conda NA Relevantaffected Python packages and their versions XXX Jedi or Language Server ie what is pythonjediEnabled set to more info Jedi enabled Expected behaviour VS Code should display a menu with all possible method definitions with the ones defined in the current py file on top Actual behaviour Displays a No definition found for methodname message in case no calls with actual objects are found in the current file or goes to the first implementation otherwise Steps to reproduce Unpack the attached archive testtargz Open the project folder Open to the Testtestpy file F on the Foo method reference from line More details on the attached animated gif Go to method definition 