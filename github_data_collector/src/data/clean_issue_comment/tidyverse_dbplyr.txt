dplyr disallows mutation on grouping variables However it seems that mutatetbllazy doesnt check whether a mutated variable is a grouping variable and allows the function call to proceed without warnings The implication of this is that the seemingly successful mutation actually messed up the grouping information and introduced NA values into the grouping via this line of code Note this line of code still runs It just emits a warning about vector replacement that doesnt alert the end user of the actual problem When the user tries to call mutate again the call fails because of the NAs in grouping in this line of code when opgrps is called and triggers an Only strings can be converted to symbols error in this line of code when it tries to test if all select variables are symbol and fails on the NA value This error is quite subtle to diagnose as the final error message doesnt suggest anything related to the root cause To be consistent with dplyrs mutate behavior perhaps dbplyr should check if a mutated variable is included in the current grouping and disallow if it is in mutatetbllazy r librarydplyr Attaching package dplyr The following objects are masked from packagestats filter lag The following objects are masked from packagebase intersect setdiff setequal union librarydbplyr Attaching package dbplyr The following objects are masked from packagedplyr ident sql Create a test local lazy tibble t lazyframex y z There are no groupings opgrpst character Add groupings tgrp groupbyt x y Grouping is x y opgrpstgrp x y Calling mutate on grouped column runs successfully without warning tgrp mutatetgrp x Grouping now has an NA value opgrpstgrp Warning in grps grps in namesold new old new grps number of items to replace is not a multiple of replacement length x NA Subsequent calling of mutate now returns error mutatetgrp x Warning in grps grps in namesold new old new grps number of items to replace is not a multiple of replacement length Error Only strings can be converted to symbols supCreated on by the reprex package v sup So they appear in dplyr docs And provide an informative error for the slice method r libraryrlang librarydbplyr a expr correctly add parentheses in R expra but not in SQL dbplyrtranslatesqlb a SQL AS b supCreated on by the reprex package v sup When I debug into translatesql the R expression is first unquoted correctly to but then passed to evaltidy where the parentheses are somehow taken out corrected strdetect so it is possible to use regular expressions introduced strreplace and corrected strreplaceall with g parameter fixes These modifications address the issue described in Fixes Currently this generates a rather large set of conflicts r librarydbplyr librarydplyr Attaching package dplyr The following objects are masked from packagedbplyr dbanalyze dbbegin dbcommit dbcreateindex dbcreateindexes dbcreatetable dbdatatype dbdesc dbdroptable dbexplain dbhastable dbinsertinto dblisttables dbqueryfields dbqueryrows dbrollback dbsavequery dbwritetable ident sql sqlescapeident sqlescapestring sqljoin sqlselect sqlsemijoin sqlsetop sqlsubquery sqltranslateenv The following objects are masked from packagestats filter lag The following objects are masked from packagebase intersect setdiff setequal union supCreated on by the reprex package v sup See issue Creates a translation for the R function weightedmean casting as NUMERIC in MSSQL results in an integer being returned even if the character string is representing a floating point number casting as FLOAT results in a float being returned addresses issue x Copy over dbplyrR x Remove existing dplyr imports x Integrate into existing documentation files x Update dbplyr backend vignette x Add default methods x Add conflict resolution x Eliminate uses of srcsqlite srcpostgres and srcmysql