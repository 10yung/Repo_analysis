Currently we only detect strings in fileinfo with strings option in what is assumed as sections containing data However there are cases when there might be strings also in sections containing code or sections that are for some reason not marked as a data sections The original premise of this was to lower the amount of garbage detected as strings as some byte sequences might represent readable strings However not having certain strings detected can be punishing so we should also start detecting strings in all sections while making the threshold stricter for sections which do not resemble data sections Threshold would be the same for data sections as it was until now Same as we do with NET and VB we should also extract information about Go binaries because they seem to contain some useful information The very first thing we should try to obtain is Go build ID located at the start of code section at least in PE Some other information might be available too This is more of a research ticket Structure of Go binaries might differ when built as PE ELF or MachO so part of this ticket is also doing it for all common native file formats As we run retdecdecompilerpy xxxelf stopafter bin llvmir a xxxelfjson file will be generated during the process which by default will be used to generate xxxelfll LLVM IR file later According to retdecdecompilerpy if I understand correctly config gives users the option to specify the json config file to be used to generate the LLVM IR file In order to test if config works properly I ran the command retdecdecompilerpy xxxelf stopafter bin llvmir config pathtothexxxelfjsonthatwasgeneratedinstep With this command I explicitly asked retdec to use the json file that is the same as the one that would be automatically generated In theory a same LLVM IR file should be generated since essentially an identical json file is used despite that one command has config option while the other does not However the LLVM IR generated in step is different from the one generated in step which can be told by the decompiled main function explained below In binary the range of main function is x ab x aee The code blocks are in the gap between any two code blocks are data due to optimization x ab x d x e c x f x ab x aee With the command in step the decompiled main function is as follows which seems to be correct as at the end of the function there is a branch to x e c which is exactly the second code block However I didnt find any branches to x f which is the third code block in the LLVM IR so as other following code blocks This might be another failure to look into define i maini argc i argv declabelpc ab cpsrzglobaltolocal alloca i align slglobaltolocal alloca i align v aa pr load i i cpsrzglobaltolocal align br i v aa pr label declabelpc e c label bb bb preds bb store i i r align br label declabelpc e c With the command in step the main function was misdecompiled as multiple functions which obviously is incorrect define i maini argc i argv declabelpc ab tmp ptrtoint i argv to i store i tmp i r align store i argc i r align stackvar alloca i align v ab load i i cpsrn align br i v ab label bb label thread thread preds declabelpc ab store i i lr align br label declabelpc ac bb preds declabelpc ab v ab load i i r align v ab inttoptr i v ab to i store i v ab i v ab align critedge preds bb bb ret i v ac define i function ac i arg i arg i arg i arg declabelpc ac store i arg i r align define i function b declabelpc b store i i define i function b ai arg i arg i arg i arg declabelpc b a cpsrcglobaltolocal alloca i align Why I wanted to use config option I found that the json file generated by retdec was not very accurate eg some functions startend address and some globals are misidentified Thus I modified the json file to make it consistent with the binary In this case I must use config to let retdec use the my modified more accurate json file My attempts I tried to hard code the json file path in retdecdecompilerpy and retdeccolorcpy in various ways but none of them worked Any thoughtshelp would be appreciated Hi I tested retdec on the test Original C file C cat testc struct A int arr void testfnstruct A p parr I translate to LLVM IR code llvm clang S emitllvm testc o testll cat testll ModuleID testc sourcefilename testc structA type x i Function Attrs noinline nounwind optnone uwtable define void testfnstructA alloca structA align store structA structA align load structA structA align getelementptr inbounds structA structA i i getelementptr inbounds x i x i i i store i i align ret void Then i applied llvmir hlltool C retdecllvmir hll o testretdecc targethllc testll cat testretdecc This file was generated by the Retargetable Decompiler Website Copyright c Retargetable Decompiler inforetdeccom include stdinth Structures struct structA int t e Function Prototypes void testfnstruct structA a Functions void testfnstruct structA a a e error line a e has error operator is extra or operator is wrong which need to replace on operator sorry i was wrong I experimented with RetDec and a simple C program I compiled the program with clang Apple clang version clang on macOS The program contains a simple switchcase statement which is compiled to a lookup table and lookup indirect branching assembly code When decompiling the code the switchcases are missing in the recovered LLVM IR code I tried disabling all of the optimization passes used in bin llvmir It turns out that the indirect branch instruction is not correctly reconstructed and therefore the switchcases are unreachable blocks of code removed by optimizations The problem is unaffected by the optimization level O or O used for compilation The C program in question C include stdioh int main char operator int n n printfEnter an operator scanfc operator printfEnter two operands scanfd d n n switchoperator case printfd d dn n n n break case printfd d dn n n n break case printfd d dn n n n break case printfd d dn n n n break operator doesnt match any case constant default printfError operator is not correct return The correctly disassembled switchstatement in IDA And the incorrectly reconstructed LLVM IR code from RetDec before RetDec optimization passes Consecutively the optimized IR code is missing large parts of the program same for the reconstructed C program If I can help with this issue any further by providing binaries or anything else let me know I decompiled this function using the latest retdec from Oct on Linux func f mov rdirax c e f shr x feax c retq the result is define i func i arg localunnamedaddr declabelpc tmp icmp slt i arg v zext i tmp to i ret i v but these functions dont return the same thing when the argument is x LL the object code returns and the decompiled code returns I try to decompile the full source each process return output will have Warning out of memory trying to recover but running CArrayArgOptimizer s Running phase variable renaming readable s LLVM ERROR Could not acquire a cryptographic context The specified procedure could not be found x F Error Decompilation of file D NNNbc failed here is the file sample This project is the best ever project existed in mankind I feel thankful to these amazing contributors and the coders I salute I wanted to compile to try debugging but I am stuck in LLVM something h missing Also when I use release version of March built x F is identified look above edit when I use latest commit built using windows server this is the error output LLVM ERROR out of memory x FF C x x x FFFDF x FF D BF unknown module x FF DBDB x x FFFDF x FF D BF x B unknown module x x FFFDF x FF D BF x B x unknown module x x FF D BF x B x x B unknown module x FFFDF x B x x B x unknown module x FF D BF x x B x x unknown module x B x B x x x F A F unknown module Error Decompilation of file D NNNbc failed Dear RetDec developers I really appreciate that you make this tool But I found some problems I am not sure whether this is ARMs THUMB architecture specific Based on my guess the problem is that some functions are not lifted into LLVM This function is not explicitly called by other function because it is run by pthreadcreate However this is not a standard pthread create That means that my target binary running on the embedded device w RTOS RIOT not Linux Therefore ptheadcreate is included in the binary codes as a normal function Specifically the problem is that This function is not called by the other functions Thats why I think RetDec didnt lift it Also when this functions pointer value is passed into an argument to pthreadcreate This function pointer value should be actual function pointer value When a function is executed with ARMs Thumb mode its pointer value must be otherwise that function will be executed in the ARMs ARM mode I strongly believe you know ARM architecture supports both ARM and Thumb modes which is the unique ARM scheme But I put this description just in case As I mentioned my target firmware is not an application binary for Linux It is a baremetal firmware including RTOS pthread related functions Thats why pthread functions are considered as a just normal function Then RetDec may not take special processing to pthread functions I guess In this context could you help me to solve this problem Even if that is not possible at least very soon is there a way to forcibly convert such unlifted functions I think the fundamental reason why that function is not lifted is related to optimization For example I guess that function is considered as garbage since it is not called by any other functions during some analysis eg a sort of pointsto analysis I guess If that is possible I am fine with it at this time since I need to emergently solve this problem Or at this time I can assume my firmware has a symbol against the target unlifted function temporarily Thank you for your help PS the converted pthreadcreate call looks like this v a call i pthreadcreatei nonnull thid i v i i inttoptr i to i i i null i i inttoptr i to i i this was originally a function pointer to thread handler function But since the last bit is set it was not recognized as a function pointer maybe Im trying to get a feel for how retdec works but am unable to successfully decompile a GCC compiled shared object file and recompile the object file with Clang Im using Debian and the retdecv prebuilt debian binary Here is testc c include stdioh void printhellovoid int main printhello Here is sharedc c include stdioh void printhellovoid printf n nShared Hello World n n Here is what I am doing bash Compile testc to LLVM bitcode clang testc emitllvm c o testbc Compile sharedc to x ELF file gcc shared sharedc o shared Decompiles shared to sharedbc optretdecbinretdecdecompilerpy shared Everything above seems to work great Now I try to produce a final output binary using the bitcode files bash clang testbc sharedbc o test This fails with warning overriding the module target triple with x unknownlinuxgnu Woverridemodule warning generated usrbinld tmpsharede o in function fini testtext x multiple definition of fini usrlibgccx linuxgnu x linuxgnucrtiofini x first defined here usrbinld tmpsharede o in function init testtext x multiple definition of init usrlibgccx linuxgnu x linuxgnucrtioinit x first defined here usrbinld usrlibgccx linuxgnu x linuxgnucrtio in function init init x undefined reference to gmonstart usrbinld tmpsharede o in function init testtext x undefined reference to gmonstart usrbinld testtext x f undefined reference to unnamed usrbinld tmpsharede o in function doglobaldtorsaux testtext xcc undefined reference to unnamed clang error linker command failed with exit code use v to see invocation Am I doing something wrong What could I do to make this simple example work I am testing retdec on Juliet Test Suite Dataset when i apply retdecdecompile to binary the result is quite different as i expect I upload binary and c source code in my repositoy binary file is CWE UseofUninitializedVariableintarrayallocanoinit out i build c source code with linux gcc compiler original file is CWE UseofUninitializedVariableintarrayallocanoinit c translated file is CWE UseofUninitializedVariableintarrayallocanoinit retdecc the function is interested in is void CWE UseofUninitializedVariableintarrayallocanoinit bad int data data int ALLOCA sizeofint POTENTIAL FLAW Dont initialize data empty statement needed for some flow variants POTENTIAL FLAW Use data without initializing it int i fori i i printIntLinedata i the result of retdec is From module homevmwaretestJulietTestSuitev forCCpptestcasesCWE UseofUninitializedVariableCWE UseofUninitializedVariableintarrayallocanoinit c Address range x b x ba Line range void CWE UseofUninitializedVariableintarrayallocanoinit badvoid int t v readgsdword x int t v g x for int t i i i x f int t v int t i g printIntLinei v g x a if readgsdword v x b stackchkfail Can you explain why the result on printIntLinei is different original printIntLinedata i I have another question When I apply retdecdecompiler it shows which options they use for fileinfo and bin IR But the IR and C result is different from using retdecdecompiler and using retdecfileinfo and retdecbin llvmir with same options as retdecdecompiler Can you explain why the result of using directly retdecdecomipler and the result of using retdecfileinfo retdecbin llvmir and retdecllvmir hll as sequence Thanks