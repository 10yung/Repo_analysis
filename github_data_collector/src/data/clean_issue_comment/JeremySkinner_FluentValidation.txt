 System Details FluentValidation version Issue Description How to access the index of element in RuleForEach WithMessage when using SetValidator As an example RuleForx xOrders NotEmpty WithMessageOrders list must not be empty ForEachorder orderSetValidatornew OrderValidator public class OrderValidator AbstractValidatorOrder public OrderValidator RuleFororder orderNumber NotEmpty WithMessagePropertyName at CollectionIndex must not be empty Is there a way to access parent context collection index Related to Thanks System Details FluentValidation version Web Framework version ASPNET Core Issue Description Hi I am new to Fluentvalidation I am trying to use SetValidator to validate collection For some reason validation rules are not getting executed Am I doing something wrong Can you please help Here is the code TradeInfo class with properties public class TradeInfo public string SecurityNumber get set public int Quantity get set TradeDetails collection class public class TradeDetails public int Id get set public TradeInfo TradeInfoItems get set public class TradeInfoValidator AbstractValidatorTradeInfo public TradeInfoValidator RuleForreq reqSecurityNumberNotNullWithMessageSecuirty Number is required public class TradeDetailsValidator AbstractValidatorTradeInfo public TradeDetailsValidator RuleForEachreq reqSetValidatornew TradeInfoValidator Should read Jeremy Skinner and contributors rather than just Jeremy Skinner x Update Readme Update source code headers Nuget package metadata needs updating System Details FluentValidation version Web Framework version NET Core Web API Issue Description Hello everyone I checked through the documentation multiple times and didnt quite find an answer so im sorry if its something too obvious What I want to do is run the default rules and only if all of them pass run a specific ruleset This is how my code looks like atm var result await validatorValidateAsyncrequest if resultIsValid result await validatorValidateAsyncrequest ruleSet DbChecks Was just wondering if this is really how I should go about it or is there a better way to achieve this Edit for more clarification I want to do something like this But without having to duplicate code as suggested in the answer Or even like this But with more than rule eg I want to check if a confirmPassword field equals the password field only if both confirmPassword and password fields arent empty System Details FluentValidation version Issue Description Im trying to figure out the best way to validate some of the builtin F types such as Option In my case I have a record with some option types such as type Model Name string option I want to be able to apply the standard string validators such as MaximumLength to the Name field but I cant because the type of the field is OptionString not String I thought Transform might work but it requires the end type to be the same as the starting type Similar to the the existing When functionality what I want is something like baseWhenSomefun model modelNameMaximumLength Any pointers on implementing this functionality or is there another option to achieve this System Details FluentValidation version Web Framework version ASPNET Core Issue Description I need to inherit from FluentValidationModelValidatorProvider Can you make it public with virtual CreateValidators method I also need to inherit from FluentValidationModelValidator Can you make it pulbic with virtual Validate method I want to add validators from another ModelMetadata I will override the Validate method create a new ModelValidationContext based on another ModelMetadata and the call baseValidate on this new context If the result is empty I will then call the baseValidate method with current context Thanks I recently created a PR for the implementation of inheritance validation I think I got a little bit too enthousiastic with my first PR to an opensource project because I implemented the functionalitity right away before discussing it first The reason Ive created the PR is because I have seen alot of constructions with a visitor pattern to manage this kind of validation Its take alot of files to get it done like that My proposal as it implemented in the PR var validator new TestValidatorv vRuleForx xVehicleTitleNotNull vRuleForx xVehicleAddInheritancei iIncludeCarb bRuleForm mIsElectricMustx x iIncludeBikeb bRuleForm mHasBellMustx x validatorValidatenew Person Vehicle new Bike HasBell true Title My awesome bike public class Person public IVehicle Vehicle get set public interface IVehicle string Title get set public class Car IVehicle public string Title get set public bool IsElectric get set public class Bike IVehicle public bool HasBell get set public string Title get set The Microsoft Blazor frontend uses an ObjectInstancePropertyName combination to identify errors whereas FluentValidation uses a RootObjectPathToProperty Could we have some way of retrieving the actual object property name rather than path For example A ValidationFailure for PersonHomeAddressCity would give us object PersonHomeAddress string City Take a look here for more information in a blog by Steve Sanderson Id be happy to submit a PR if you are open to the idea of this improvement and would like to discuss an approach you are happy with System Details FluentValidation version Issue Description csharp public class Foo public Listint Numbers get set Fact public void Shouldshowpropertyname var validator new InlineValidatorFoo validatorRuleForx xNumbersForEachx xGreaterThan validatorShouldHaveValidationErrorForx xNumbers new Listint WithErrorMessageNumbers must be greater than validator new InlineValidatorFoo validatorRuleForEachx xNumbersGreaterThan validatorShouldHaveValidationErrorForx xNumbers new Listint WithErrorMessageNumbers must be greater than maybe because using a InlineValidatorIEnumerableTElement with xx lambda so the MemberInfo will be resolved as null FluentValidationClientModelValidatorProvider uses validator instances to generate clientside rules This is usally the desired behaviour but can cause confusion in certain sitautions eg if the validator is intentionally not registered with the container eg its only ever invoked with SetValidator so shouldnt be isntantiated automatically Also causes issues where multiple validators are registered for the same type Investigate implementing an abstraction eg IFluentValidationClientValidator The default implementation would retrieve rules directly from the validators descriptor like now but would allow others implementations to be registered that would allow the process to be customized 