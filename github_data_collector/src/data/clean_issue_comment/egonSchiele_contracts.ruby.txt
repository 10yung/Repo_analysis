 Example code Class A include ContractsCore include ContractsBuiltin Contract Integer Integer String def selfhello return Hello world end end puts Ahello Actual behavior No errors are raised Expected behavior I would expect this would an error because the contract specifies hello takes two integers as arguments and it is being passed none I understand that this could be considered fine as the code would work fine without type errors without the contract but that is no different from any other incorrectly specified contract Fixes is not a positive natural number When running ruby w e require contracts class Foo include Contracts end or ruby w e require contracts class Foo include ContractsCore end I get this warnings hometiagogemruby gemscontracts libcontractscorerb warning method redefined discarding old functype hometiagogemruby gemscontracts libcontractscorerb warning previous definition of functype was here The KeywordArgs contract appears to have two deficiencies A missing arg with a Maybe contract is valid despite not being declared optional development main kk ContractsKeywordArgs a ContractsMaybe String development main kkvalid true In practice this is often not an issue because the function definition would be like Contract ContractsKeywordArgs a ContractsMaybe String def fooa end and Ruby would enforce the presence of a However this would break in the more esoteric case of Contract ContractsKeywordArgs a ContractsMaybe String def fookwargs end Default values for optional args are not validated by Contracts development main module Foo development main Contract KeywordArgs a Optional String Any development main def selffooa development main end development main end development main Foofoo nil Hacking in a fix for Issue Method validatedecorators raises NameError causes in my app that same method to raise RuntimeError with a message see below claiming that there are multiple contracts on method psychyamlas which is in rubylibruby psychcoreextrb I dont know what to make of this Im not optimistic about crafting a simple example that shows the error but hope that the trace see below will be a clue for some guru begin message cRuby librubygems gemscontracts libcontractsmethodhandler rb in validatedecorators RuntimeError Oops it looks like method psychyamlas has multiple contracts ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array Symbol ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array ContractsBuiltinOr x e dc vals Symbol Array Did you accidentally put more than one contract on a single function like so Contract String String Contract Num String def foo x end If you did NOT then you have probably discovered a bug in this library Please file it along with the relevant code at end message begin trace from cRuby librubygems gemscontracts libcontractsm ethodhandlerrb in handle from cRuby librubygems gemscontracts libcontractsd ecoratorsrb in methodadded from cRuby libruby psychcoreextrb in classModule from cRuby libruby psychcoreextrb in top required from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby psychrb in top required from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby yamlrb in top required from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby librubygems gemswatir libwatircookiesr b in top required from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby librubygems gemswatir libwatirrb in top required from cRuby libruby rubygemscoreextkernelrequirerb in require from cRuby libruby rubygemscoreextkernelrequirerb in rescue in require from cRuby libruby rubygemscoreextkernelrequirerb in require from cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubuiuic lientrb in top required from cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubbasecl assesbaseclassfortestrb in requirerelative from cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubbasecl assesbaseclassfortestrb in top required from cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubtester tourtestsmeettestrb in requirerelative from cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubtester tourtestsmeettestrb in main rake aborted ErrnoENOENT No such file or directory rbsysopen CUsersBurdetteAppDat aRoamingRubyTestlogsgithubapi Wed testmeetxml cUsersBurdetteDocumentsGitHubRubyTestlibloglogrb in initialize cUsersBurdetteDocumentsGitHubRubyTestlibloglogrb in open cUsersBurdetteDocumentsGitHubRubyTestlibloglogrb in getcountsfr omfile cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubRakefile in blo ck levels in top required cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubRakefile in eac h cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubRakefile in blo ck levels in top required cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubRakefile in eac hpair cUsersBurdetteDocumentsGitHubRubyTestexamplesgithubRakefile in blo ck in top required end trace Since Func contracts return value isnt enforced with blocks was fixed in contracts given blocks are being put into a lambda So the forwarded block isnt identical with the original one Especially its arity and its sourcelocation changed Please keep as many properties as possible of the original block especially the arity Or find a way to forward the original block without breaking again So the original block could be kept Id really appreciate any ideas for this because it might be the cleanest solution nbsp nbsp Commit for introducing this bug libcontractscallwithrb module Contracts methodcallargs blk else original method name referrence methodsendtothis args blk addedblock blk lambda params blkcallparams nil methodsendtothis args addedblock end unless retvalidator result nbsp nbsp I especially need the arity to stay unchanged Some examples about arity def a b puts barity end a x puts x a xy puts xy a puts a x puts x nbsp A very simple way how to keep the arity is using eval see below But I hope we find a better way alibcontractscallwithrb blibcontractscallwithrb module Contracts methodcallargs blk else original method name reference addedblock blk lambda params blkcallparams nil addedblock nil if blk paramsary for i in blkarity paramsary xitos end paramsstr paramsaryjoin addedblock evallambda paramsstr blkcallparamsstr end methodsendtothis args addedblock end When debugging code I need to go trough all the Contracts code when stepping into a method guarded by a Contract Example ruby rdebug homeusermycodeapprb homeusermycodeapprb methoda rdb step usrlib rubygems gemscontracts libcontractsmethodhandlerrb engine currentenginenearestdecoratedancestor Is there any way to hide the Contracts code when stepping into a method Maybe something about breakpoints Or maybe there could be a global not environment variable to disable contracts which can be manually set before stepping into a method Eg rdb nocontracts true true rdb step homeusermycodeapprb puts Entering methoda rdb nocontracts false false Simply doing ENV NOCONTRACTS doesnt work Looks like that variable is only evaluated at start when Ruby goes through Contract def methoda Same problem for the byebug debugger I know I could set a breakpoint but its not always clear where a method call goes think of polymorphism And I know I can use the NOCONTRACTS environment variable But sadly thats not always a practical solution Maybe related In general Im very happy with Contracts and I dont want to miss it anymore Nevertheless theres one annoying problem With Contracts in use backtraces stacktraces become quite messed up I know I can use the NOCONTRACTS environment variable But thats not always a practical solution because I need to restart the application and reproduce whatever took me to the backtrace Example Backtrace from Contract violation usrlib rubygems gemscontracts libcontractsrb in block in classContract usrlib rubygems gemscontracts libcontractsrb in call usrlib rubygems gemscontracts libcontractsrb in failurecallback usrlib rubygems gemscontracts libcontractsmethodhandlerrb in rescue in block in redefinemethod usrlib rubygems gemscontracts libcontractsmethodhandlerrb in block in redefinemethod homeusermycodeapprb in somemethodb Example An exception in a method guided by a Contract homeusermycodeapprb in raise homeusermycodeapprb in somemethoda usrlib rubygems gemscontracts libcontractsmethodreferencerb in sendto usrlib rubygems gemscontracts libcontractscallwithrb in callwith usrlib rubygems gemscontracts libcontractsmethodhandlerrb in block in redefinemethod homeusermycodeapprb in somemethodb Could you please look for a way to clean the backtrace from all lines with internal Contracts code Eg usrlib rubygems gemscontracts libcontractsmethodhandlerrb in block in redefinemethod If thats possible an global option to enabledisable that backtrace cleaning would be wonderful PR dropped support for Ruby However this is not enforced in the gemspec This means contracts will install fine on only to fail at runtime Please consider setting requiredrubyversion in the gemspec