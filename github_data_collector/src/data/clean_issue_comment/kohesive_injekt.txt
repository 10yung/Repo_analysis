 Hi Im making updates for Open Collective Either you or another core contributor signed this repository up for Open Collective This pull request adds financial contributors from your Open Collective What it does adds a badge to show the latest number of financial contributors adds a banner displaying contributors to the project on GitHub adds a banner displaying all individuals contributing financially on Open Collective adds a section displaying all organizations contributing financially on Open Collective with their logo and a link to their website PS As with any pull request feel free to comment or suggest changes Thank you for your great contribution to the Open Source community You are awesome And welcome to the Open Collective community Come chat with us in the opensource channel on great place to ask questions and share best practices with other Open Source sustainers Hi The last release of this project was years ago Is it still up to date Have you analyzed implementing Dependency injection by type alias object RedisCache typealias Cache RedisCache If we need to change it object MongoCache typealias Cache MongoCache It is done in compile time Hello Ive been a long time user of this library and I liked it because of its simplicity I know its now deprecated in favor of the other Kotlins DI libraries but I dont feel the need to change it and Ive been hit by this bug I think its worth mentioning This only happens when injecting the instance from multiple threads and the initialization takes some time Example demostrating the issue kt class A init LogwTAG Init A Threadsleep Simulate slow init In your InjektModule class kt override fun InjektRegistrarregisterInjectables addSingletonFactory A Then to cause multiple instances example using coroutines kt fun mainargs ArrayString repeat async InjektgetA One proposed solution is to change the addSingletonFactory implementation to a lazy so that synchronization is taken into account kt SuppressUNCHECKEDCAST override fun R Any addSingletonFactoryforType TypeReferenceR factoryCalledOnce R factoriesputforTypetype existingValuesgetOrPutInstanceforTypetype NOKEY lazy factoryCalledOnce as LazyRvalue Hi during development Ive encountered that overriding singletons is not possible like shown here This came out in unit tests where different tests needs to have different stubs It would be nice to have feature either to clear all objectsfactories from Injekt before every test or to override certain singletons What do you think Hi Im looking for a injectionlike framework for Kotlin that would compile to Javascript Does your inject framework do that Regards J rund Hello Trying to get Injekt going with a test project of mine and running into trouble It works great on Lollipop but on Android x Im running into trouble The error Im seeing javalangRuntimeException Unable to instantiate application combrianeganbansacounterApplication uykohesiveinjektapiInjektionException No registered instance or factory for type combrianeganbansaStorecombrianeganbansacounterApplicationState combrianeganbansaAction at androidappLoadedApkmakeApplicationLoadedApkjava at androidappActivityThreadhandleBindApplicationActivityThreadjava at androidappActivityThreadaccess ActivityThreadjava at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNativeNative Method at javalangreflectMethodinvokeMethodjava at comandroidinternalosZygoteInitMethodAndArgsCallerrunZygoteInitjava at comandroidinternalosZygoteInitmainZygoteInitjava at dalviksystemNativeStartmainNative Method Caused by uykohesiveinjektapiInjektionException No registered instance or factory for type combrianeganbansaStorecombrianeganbansacounterApplicationState combrianeganbansaAction at uykohesiveinjektregistrydefaultDefaultRegistrargetInstanceDefaultRegistrarkt at uykohesiveinjektapiInjektScopegetInstanceScopekt at combrianeganbansacounterApplicationinitApplicationkt at javalangClassnewInstanceImplNative Method at javalangClassnewInstanceClassjava at androidappInstrumentationnewApplicationInstrumentationjava at androidappInstrumentationnewApplicationInstrumentationjava at androidappLoadedApkmakeApplicationLoadedApkjava more My code can be found here I also tried Injekting a module in onCreate instead of using a companion object with no luck Feeling like a bit of a n b here though trying to figure out what Im doing wrong Any advice would be much appreciated Add example to docs or example application where a scope is propagated to other classes See example written as test case of this Which uses LocalScoped see implementation And uses scoped factory registrations see implementation Not sure if this is useful because you can manually get pretty close see updated docs at using something like the shown MyActivityScope or MyActivityModule examples Scope can be created and linked to another scope or more than one scope The scope you create is the called scope and the others are linked scopes The linking has the following properties is the Linked scope allowed to provide existing cached instances true by default is Linked scope allowed to generate new instances false by default are new instances are cached in the called scope or the scope who s factory actually makes the object which is either called scope or linked scope called scope is the default so you would make myActivityScope linked to Injekt global and anything already in global can be used but it cannot create anything else only myActivityScope can create new instances And anything registered in myActivityScope will override the global Injekt by default you can change the behaviour by the settings listed in So this would be called something like LocalOverridingScope with those defaults others will want the settings to differ such as having the global still make new instances of types it has registered but the other scope does not others will want the caching of the instances to be in the called scope others in the scope that did the factory others will want the factory called if the local scope does not have the item but declare the factories only in the linked scope including singleton factories 