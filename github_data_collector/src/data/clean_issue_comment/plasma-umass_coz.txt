I tried running coz on the inproclat benchmark program from zeromqlibzmq This causes an interrupted system call I identified via strace as follows pid poll fd eventsPOLLIN ERESTARTRESTARTBLOCK Interrupted by signal pid SIGPROF sisignoSIGPROF sicodeSITIMER sitimerid sioverrun sivalueint ptrNULL While the code might be changed to work around this this seems to quite heavily affect the analysis results or doesnt it The coz paper states COZ s profiler thread begins an experiment by selecting a line to virtually speed up and a randomlychosen percent speedup Both parameters must be selected randomly any systematic method of exploring lines or speedups could lead to systematic bias in profile results One might assume that COZ could exclude lines or virtual speedup amounts that have not shown a performance effect early in previous experiments but prioritizing experiments based on past results would prevent COZ from identifying an important line if its performance only matters after some warmup period Id like to understand your thinking on this I only see two reasons to do this Functions need to warm up Doesnt coz already wait a little bit before starting experiments Path dependence Maybe speeding up a line a lot forces something else to get JITed or you fill up a queue and the program changes algorithms and future results depend on past ones In this case would a permutation of range for the speedups also work For collecting data for a graph I think randomly sampling from the range makes it take a lot more samples to collect all data points I think this is the coupons collector problem and taking aside the chance of speedup the other increments should take samples to fill the range on average So combined with the fact that of the time the speedup is I think this means you need to run an experiment times on average instead of to collect a full graph Let me know if theres no way around this or it doesnt matter because eg it already takes a number of experiment samples to get good information Ive mostly been running coz with fixedline but sometimes the way it doesnt get data for a particular point in the plot makes me want to run it with seq while read i do coz run fixedspeedup i fixedline Should I just tweak my program to make more samples happen anyway Or is the random speedup only needed when a random line is picked and could having coz use permuterange would work fine when fixedline is selected Regards Am d e It seems that coz run saves data only when profiling target reaches the end of main Some programs are designed to exit only when interrupted or take a long time to terminate It would be nice if Coz could deal with signals exit etc and save the data collected up to that point Heya I just found this via the emerybergers Strange Loop talk and was super impressed I was wondering what would need to happen to enable profiling of NodeJS processes Parallel execution isnt widespread in the JS world but asynchronous execution is the norm Getting this sort of profiling data would be invaluable NodeJS doesnt support macros but it does support native c bindings via nodegyp Maybe that could be leveraged In case you toggle a progress point the UI will fail to update and some times switch to a canonical path eg pathtofilec instead of just filec Changing Sort By will update the UI correctly Sample programs gcc O fnoomitframepointer gdwarf ldl o linear linearc gcc O fnoomitframepointer gdwarf lpthread ldl o threads threadsc Firefox Fedora x lineartxt threadstxt When profiling the following programs coz will fail to find optimizations of the methods showing a slowdown when optimizing in most cases Compile with gcc O fnoomitframepointer gdwarf ldl o linear linearc gcc O fnoomitframepointer gdwarf lpthread ldl o threads threadsc Furthermore the profilecoz file wont contain all progress point definitions and in the case of linearc the c data wont even show up lineartxt threadstxt I am unable to see any useful result when the dynamic library is loaded during execution time Steps to Reproduce Download and extract roundtriptargz alternatively if you dont want to run a random executable that Im uploading build this branch with cargo build release features parallel example roundtrip and you should get a binary at targetreleaseexamplesroundtrip Run coz run s walrus pathtoroundtrip someexamplewasm where someexamplewasm is any wasm file eg Expected Results Runs coz and creates a profile Actual Results coz run s walrus targetreleaseexamplesroundtrip benchesfixturesdodriotodomvcwasm libcozcpp bootstrapping coz libcozcpp Including MAIN which is homefitzgenwalrustargetreleaseexamplesroundtrip inspectcpp libx linuxgnuld so is not in scope inspectcpp libx linuxgnulibdl so is not in scope inspectcpp libx linuxgnulibrt so is not in scope inspectcpp libx linuxgnulibpthread so is not in scope inspectcpp libx linuxgnulibgccsso is not in scope inspectcpp libx linuxgnulibm so is not in scope terminate called after throwing an instance of stdunderflowerror what cannot read past end of DWARF section Hi Something is off I am trying to run coz with CryptoMiniSat with ApproxMC but I am getting coz run approxmc blastedcase cnfgznowcnfgz v libcozcpp bootstrapping coz libcozcpp Including MAIN which is buildapproxmc terminate called after throwing an instance of dwarfformaterror what DWFORMsecoffset not expected for attribute DWAT x I am using latest coz and latest libelfin both compiled from git Do you know what could be the issue Both ApproxMC and CryptoMiniSat are opensource see and But I am getting the error with plain CryptoMiniSat too so its probably in CryptoMiniSat I am compiling with g and mtuneauto and I am linking in boost zlib and m ri All are dynamically linked Should I try without linking all these I am using Arch Linux so I think the debug symbols should be available for all libraries Do you know what that issue above could mean While experimenting with a simple Intel TBB program that checks for prime numbers in parallel I noticed a difference in the projected speedup of the program while profiling for throughout and latency While profiling for throughput I placed a progress point at the end of a loop The profile highlights a line in the program and projects an almost linear increase in speedup see attached screenshot But while profiling for latency I placed progress points at the beginning and the end of loop Coz highlights the same line as the throughput profile but shows a decrease in the projected program speedup In the attached screenshot primes refers to the progress points for latency and detectprimestaskscpp refers to the progress point for throughput I expected both the latency and the throughput to increase since the highlighted link is within a region which is indeed the bottleneck in the program Any idea on why I would be seeing different results I have attached the TBB program as a text file that I used for testing Screen Shot at PM detectprimestaskstxt 