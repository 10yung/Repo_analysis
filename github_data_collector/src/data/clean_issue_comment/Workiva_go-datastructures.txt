when producer are put faster then consumer the ringbuffer will be full put function will infinite loop switch dif seq pos will always gt so alway case default this infinite loop is a cpu hog DtrieGet currently panics if called with a key that does not exist due to calling nilValue in this case Adding a nil check here will prevent this panic from happening and ensure that the behaviour is as described in documentation Tested on v From the documentation it sounds like the dtrie is intended to be an immutable hash array mapped trie initialpr implementation Dtrie A persistent hash trie that dynamically expands or shrinks to provide efficient memory allocation Being persistent the Dtrie is immutable and any modification yields a new version of the Dtrie rather than changing the original Bitmapped nodes allow for Olog n get remove and update operations Insertions are On and iteration is O However this doesnt appear true go t dtrieNewnil t t Inserta b t t Insertc d fmtPrintlntrie sizes t Size t Size t Size yields should be fmtPrintlnt Getc d should be nil fmtPrintlnt Getc d should be nil fmtPrintlnt Getc d which is correct Its also pretty easy to trigger a panic with concurrent access This will reliably result in a panic on my machine go insertLots func for i i i m InsertstringEntryv value go func insertLots go func insertLots Now I know that this project hasnt seen a ton of updates in the past couple of years and Id understand if noone wants to dig in to fix it properly Nonetheless I feel like a limitation like this would at least be worth documenting if its not going to be fixed Id be happy to make a PR to that effect initialpr Hi Thanks for creating this library Great work It seems to me that in RingBuffer we can reduce the number of heap allocations by changing nodes from an array of node pointers type nodes node to an array of node values type nodes node It should also increase locality cache efficiency and increase performance in theory As you can see the benchmark results below this change reduced nsop Bops and allocsop of BenchmarkRBAllocation a lot while having no significant impact on other benchmarks type nodes node go test bench BenchmarkRB benchmem goos linux goarch amd pkg githubcomchrisxue godatastructuresqueue BenchmarkRBLifeCycle nsop Bop allocsop BenchmarkRBLifeCycleContention nsop Bop allocsop BenchmarkRBPut nsop Bop allocsop BenchmarkRBGet nsop Bop allocsop BenchmarkRBAllocation nsop Bop allocsop PASS ok githubcomchrisxue godatastructuresqueue s type nodes node go test bench BenchmarkRB benchmem goos linux goarch amd pkg githubcomchrisxue godatastructuresqueue BenchmarkRBLifeCycle nsop Bop allocsop BenchmarkRBLifeCycleContention nsop Bop allocsop BenchmarkRBPut nsop Bop allocsop BenchmarkRBGet nsop Bop allocsop BenchmarkRBAllocation nsop Bop allocsop PASS ok githubcomchrisxue godatastructuresqueue s this test will fail func TestTrieSuccessorBigGapst testingT yfast Newuint e newMockEntry yfastInserte successor yfastSuccessor assertEqualt e successor e newMockEntry e newMockEntry yfastInserte e successor yfastSuccessor assertEqualt e successor successor yfastSuccessor assertEqualt e successor successor yfastSuccessor assertEqualt e successor successor yfastSuccessor assertEqualt e successor successor yfastSuccessor assertNilt successor successor yfastSuccessor assertNilt successor Get returns the value for the associated key or returns nil if the key does not exist func d Dtrie Getkey interface interface return getdroot dhasherkey keyValue get returns nil if the key is not found and thus Value raises a panic Is that by design q queueNewPriorityQueue true qPutbuffersItemdata priority result err qGet diff should be int else it never less than Java introduced Its very efficient if you have a List where you mostly need to iterate the ArrayList and dont modify it too often I used this data structure at Java and have an idea how to make it right at Go I am willing to work on it and create a Pull request then Just want to make sure there is no active development or it was discussed and rejected by some reason go get githubcomWorkivagodatastructures githubcomWorkivagodatastructuresbtreeimmutable D goproject src githubcom Workiva godatastructures btree immutable nodego multiplevalue uuidNewV in singlevalue context D goproject src githubcom Workiva godatastructures btree immutable nodego multiplevalue uuidNewV in singlevalue context D goproject src githubcom Workiva godatastructures btree immutable nodego multiplevalue uuidNewV in singlevalue context D goproject src githubcom Workiva godatastructures btree immutable nodego multiplevalue uuidNewV in singlevalue context D goproject src githubcom Workiva godatastructures btree immutable rtgo multiplevalue uuidNewV in singlevalue context D goproject src githubcom Workiva godatastructures btree immutable rtgo multiplevalue uuidNewV in singlevalue context 