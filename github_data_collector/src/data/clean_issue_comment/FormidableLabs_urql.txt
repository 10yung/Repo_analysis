 Hello Apollo has the very useful useLazyQuery which allows to trigger the query independently of the component rendering I didnt see an equivalent with urql Right now Im wiring things manually tsx const SelectBoxForm FC onChange any onChange const graphqlClient useClient const onSubmit async boxBarcode SelectBoxFormData const data await graphqlClient queryGetBoxQuery GetBoxQueryVariablesGETBOX barcode boxBarcode toPromise onChangedataboxByBarcode return JSX I think it would be a great addition to the lib as these lazy queries are quite common at least in my apps Also we could then leverage this hook to generate more typesafe utilities with graphqlcodegen Not sure if the other guides need to be updated as well but this is the change I needed to make in my project for the file exchange Description cases lead to different SSR and Browser representations of error SSR representation seems to be slightly off Steps to reproduce Access API from Browser directly trigger SSR Access API from Browser via link trigger client fetching By API I mean any API returning message Not Found code INTERNALSERVERERROR which is probably not perfect but is the default ApolloServer behavior AuthenticationError for authentication failures ForbiddenError for authorization failures UserInputError for validation errors on user input As a fallback for uncaught failures any other unknown errors thrown within your resolver will add the code INTERNALSERVERERROR and shouldnt really matter for the context of this issue Code some NextJS page let dataResult useQuery query if dataResulterror consolelogdataResulterror return Error messagedataResulterrortoString SSR Error CombinedError Network undefined name CombinedError message Network undefined graphQLErrors GraphQLError Not Found at rehydrateGraphQlError nodemodulesurqldistcjsindexdddbd ejs at Arraymap anonymous at new CombinedError nodemodulesurqldistcjsindexdddbd ejs at b nodemoduleswonkadistwonkajs at ArrayforEach anonymous message Not Found networkError Error undefined at nodemodulesurqldistcjscorejs at d nodemoduleswonkadistwonkajs response undefined errortoString currently produces at server Network undefined Somehow it misses the informative GraphQLError Not Found part and goes for the weird Network undefined Browser Talking about the same error in Browser errortoString currently produces GraphQL Not Found Which LGTM The same error should probably lead to the same structures in Browser and Server At least the error in Server should be improved to match the Browser one Stacktraces will be different for sure but the final messages of toString should match IMO Describe the bug I tried out updating Tripadvisor to today and discovered an unfortunate bug that appears to only surface in ConcurrentMode Real concurrent mode not StrictMode It seems that while hydrating useQuery will occasionally return a fetching true state with no data even with a fully populated SSR cache This happens nondeterministically about of the time and only when there are multiple queries on the page Setting breakpoints prevents the failure case As best I can tell nothing is getting dispatched at all for the second query however they are both dispatched Steps to reproduce As noted the behavior is nondeterministic so it can take a few refreshes to see the error show up A note on versions React is the latest semverd release with access to the createRoot API but I also validated that we see the same behavior with the experimental release corresponding to Expected behavior Expectation here would be that the initial call to useQuery always returns available SSR data Actual behavior Warning Expected server HTML to contain a matching div in div alongside the accompany nastiness that comes with React failing to hydrate Additional context Interestingly uncommenting the nonconcurrentmode hydration forces the concurrent mode one to work Guess its worth noting that the reason I was so quick to try this out is that we were seeing some other funky but far more minor concurrent mode behavior with urql on so after s release notes I was pretty excited for a potential solution Instead wed like to explore more idiomatic APIs for suspense like readFragment and not have any suspense mode on useQuery This does mean that our current SSRsupport will need to change or be preserved using an SSRonly suspense mode I am not a sure if this restriction comes from urql but it only allows absolute urls When using nextjs api routes it hinders me from an easier config since I could theoretically just passapigraphql as url About Exchange for executing queries locally using an executable schema This may be particularly useful for us when making example projects as we could mock responses here rather than implementing a server We recently had a problem on our site where we were refetching a bunch of data at a surprisingly high rate and discovered that the culprit was the cache exchange and how it invalidates caches of the time the approach of the cache exchange to invalidate based on type names works fine but in our case it didnt The page we were having the problem on is one that loads a bunch of Ideas from the site to show to the user The user can then like or dislike these ideas via a button on the site When the user does this it triggers a mutation SetIdeaSentiment that updates the idea accordingly Our problem is that SetIdeaSentiment returns part of the Idea back This meant that urqls cacheExchange would see the typename Idea in the result and immediately invalidate the cache and queue an operation to fetch the ideas again However in this case this isnt required The frontend knows that the sentiment has changed and so we dont want to do any refetching of ideas But what we want is a way to tell urql that and thats what this feature request is We fixed it by forking cacheExchange to include these extra lines in the handleAfterMutation function pendingOperationsforEachkey if resultCachehaskey const operation resultCachegetkeyoperation this conditional is the code we added if operationcontextcacheAndNeverInvalidate resultCachedeletekey reexecuteOperationclient operation And when we make the request we pass cacheAndNeverInvalidate true as an option This works and we think its an OK solution but the main thing we dont like is having to fork the cacheExchange and diverge from master What wed like to suggest is either cacheExchange provides some way for us to hook in and tell if it a request should be invalidated or not We introduce some mechanism maybe another requestPolicy of fetchthenpermanentlycache that lets some request get cached for the rest of time or some other much better idea that we havent thought of yet Thanks Jack