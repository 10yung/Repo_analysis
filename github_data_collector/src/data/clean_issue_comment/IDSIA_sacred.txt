Wed like to return the trained model from the exmain wrapped function and use it for other eval purposes later on exmain def trainandevalconfig model trainmodel return model run exrun model runresult This method isnt ideal because the whole object gets stored in the mongodb and is wasteful We dont want to store itlog it we just want to return it Is there a supported way of doing this If not how do you recommend we modify the library to add support for this only log what you need When the experiment name ends with one or several dots sacred fails to parse the commands it removes as many letters from the command name as there are dots in the end of the experiment name For instance the following code runs fine python from sacred import Experiment ex Experimentnameofexp exautomain def mymain printHello world But if I change the experiment name python from sacred import Experiment ex Experimentnameofexp exautomain def mymain printHello world It returns Usage testsacredpy with UPDATE options testsacredpy help COMMAND testsacredpy h help testsacredpy COMMAND with UPDATE options Error Command mymain not found Available commands are intconfig ymain veconfig intdependencies intnamedconfigs note the ymain appearing instead of mymain And if I add two dots python from sacred import Experiment ex Experimentnameofexp exautomain def mymain printHello world It returns Usage testsacredpy with UPDATE options testsacredpy help COMMAND testsacredpy h help testsacredpy COMMAND with UPDATE options Error Command mymain not found Available commands are intconfig main veconfig intdependencies intnamedconfigs note the main appearing instead of mymain And so on I got this bug when updating sacred from to Hello sacred authors For reasons that I explain below I am trying to find a way to instantiate an Experiment in a function that I define in some library and then call this function from a main script and run the experiment The library file where the Experimentinstantiating function is defined is take as the mainfile of the experiment and the script where I run the experiment is not part of the sources I understand that this is not how sacred is intended to be used but I was wondering if there was a way around this behavior One way I see around this would be to allow the user to specify the mainfile of the experiment although I do not know if this might have unwanted consequences To be more explicit heres a minimal example librarypy import sacred def createexpnamemyexp return sacredExperimentname runningscriptpy from library import createexp ex createexp exautomain def main printhello world For which the mainfile is librarypy and runningscriptpy is not included in the source list In case you wonder why I would do this heres more context I have my own ExperimentManager class that is in charge of organizing instantiating and running the different components of experiments It collects the configuration of a run and metrics and up to now was logging them using tensorboardhparams I found that I could quite easily switch to sacred by creating a script where I create a sacredExperiment and an ExperimentManager log the parameter dictionary that I pass to my ExperimentManagerpreparerun with Experimentaddconfig and then define an Experimentmaindecorated function that calls my ExperimentManagerdorun This is already great but it somewhat duplicates operations Ideally for userfriendliness I would like to move on to a more streamlined version where the sacredExperiment and my ExperimentManager are blended in some way I gather from issue that for the moment inheriting from sacredExperiment is not the way so I tried to have ExperimentMangerinit instantiate a sacredExperiment as its attribute call addconfig when it sets an experiment up and decorate its dorun method as the exmain In this way all sacred operations are hidden under the hood and the user does not have to care about it Most of this works except for the source discovery I understand that this is a little hacky and strays from the scriptbased approach that is default for sacred but if you can think of a workable way to ensure importbased source discovery I would really appreciate it Function parameters are not fit between Class Ingredient and dependeniessourcediscoverystrategies dict In Ingredient def init selfmainfile selfsources selfdependencies gathersourcesanddependencies callerglobals savegitinfo selfbasedir is written passing arguments However in gathersourcesanddependencies you can see sourcediscoverystrategies none lambda globs path set imported getsourcesfromimportedmodules sys getsourcesfromsysmodules dir getsourcesfromlocaldir So when I set none on SETTING DISCOVERSOURCES error occurs Basically none returns set not dependent on any arguments So it could be resolved as passing nonusable unlimited arguments like below sourcediscoverystrategies none set imported getsourcesfromimportedmodules sys getsourcesfromsysmodules dir getsourcesfromlocaldir We encountered the following error when capturing stdout OS ubuntu Python sacred Traceback most recent calls WITHOUT Sacred internals File homexxxxprogramsanaconda libpython contextlibpy line in exit nextselfgen File homexxxxprogramsanaconda libpython subprocesspy line in wait return selfwaittimeouttimeout File homexxxxprogramsanaconda libpython subprocesspy line in wait raise TimeoutExpiredselfargs timeout subprocessTimeoutExpired Command tee a tmptmpdhu kps timed out after seconds Hello I am trying to log about K data points in different metrics close to a million data points I am doing this all at once in a for loop and when I view the results in omniboard it takes a very long time to load and not all the points eventually get plotted If I want to plot many scalars at once ie at the end of the experiment and not during is there a better way than a huge for loop Many thanks Elad Sacred stores a bunch of store in the database backend Is there a way to retrieve those objects for later use in a different Python program Exploring whether using pyfilesystem could unify the the filesttorage and the S Observer Hi when adding a yamlfile using syntax to execute python funcitons as config to an experiment object the following error is thrown yamlconstructorConstructorError while constructing a Python instance expected a class but found class builtinfunctionormethod in homeazmkuuDesktoptrackingwobnwoutputfpnres mot trainvociniticcv configyaml line column This is due to the latest security improvements of the pyyaml library and your source code using the FullLoaderclass if opthasyaml def loadyamlfilename return optyamlloadfilename LoaderoptyamlFullLoader yamlhandler Handlerloadyaml optyamldump for extension in yamlextensions HANDLERBYEXT extension yamlhandler Would it be possible to let the user specify the type of loader they want to use I was able to fix this by using the pyyamls UnsafeLoaderclass Happy to make a pullrequest in case you agree to this fix Output does not appear to be captured when running in a local JupyterLab on OSX Are there any known workarounds The result is the Captured Out data tab of an experiment is a blank box Other output we care about appears to be capturing such as metrics When running from the commandline output is captured correctly