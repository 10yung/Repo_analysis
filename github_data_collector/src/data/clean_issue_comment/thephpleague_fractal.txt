Im trying to figure out how to specify which fields to select when including a resource But I cant get it to work Ive been looking through the Managerclass and I found this Request Im sending GET apiendpointproducersincludeowneridname Ive also tried the below formats GET apiendpointproducersincludeownerfieldsidname GET apiendpointproducersincludeownerfieldidname I found that syntax from another issue How is it supposed to work check if date is null if the data is null it will give error Argument passed to Transformers ExampleTransformertransform must be an instance of App Models Example null given called in leaguefractalsrcScopephp on line transformedData isnulldata transformertransformdata I try to get data from database then order them according to the sort type that is sent so I do that public function getStoreProductsstoreid array products Productwithtranslation image price grouptranslation groupsubcategorysubCategoryTranslationsstore wherestoreidstoreidwhereproductstatus groupBygroupid if requesthassort emptyrequestgetsort if requestgetsort date products productsorderBycreatedat DESC elseif requestgetsort price products productswhereHaspricewitharraypricefunctionquery queryorderBysellpriceasc elseif requestgetsort pricedesc products productswhereHaspricewitharraypricefunctionquery queryorderBysellpricedesc return thistoArrayproductspaginate so the data get sorted but when I pass them to the fractal transformer it got unsort so how can i prevent this operation products thisrepositorygetStoreProductsstoreid data FractalFacadecollectionproducts data transformWithnew ProductTransformer parseIncludes translation price images groupsubcategorytranslation groupgrouptranslation toArray dddata But I noticed that this problem happens when the sort is on the relation So for example when I sort based on the createdat which is field in product the Products get out sort as it entered but when sort the data based on the price which is the relation with the products so the entered sorted but it get out unsorted so How can I solve this problem With this feature include will be available like this includefoolimit barbaz Response example json data name lorem foo data name ipsum bar data name dolor name ipsum bar data name dolor meta pagination baz This PR will not add any new feature This will make the test setup more like real world app implementation If agree I am happy to update all tests Any chance we can have Hydra support Fractal ships with the following paginators Doctrine Phlacon Laravel PagerFanta Zend I think we should make a basic paginator class and move these to separate repositories that can be suggested via Composer Thoughts Fractal is currently responsible for the pagination and serialisation of data which is continually growing and clouding the core functionality of Fractal A lot of the issues and pull requests are to do with a specific serialiser which means to change something on one serialiser requires a minor version bump which might update the package for people who arent using the serialiser I believe we need to seperate the serialisers into their own selfcontained packages fractaljsonapi fractalcsv fractalpackage Utilising one of these packages should provide a Fractal manager using the specific serialiser The Fractal package would still provide the basic dataarray serialiser and an interface to implement another custom serialiser Also the paginators are not within the scope of the core project the interfaces would still be provided by the package and the current paginators would be extracted into their own packages By doing this and narrowing the scope of the Fractal core we would create a more maintainable concise package focussed on managing the transformation of data The issues and PRs for the serialisers and pagination would not be part of the Fractal core package meaning that updating the JSONAPI serialiser would not require people using the other serialisers to update the package It would also enable people to create their own serialisation and pagination and publish them in a recommended format The unit tests for the packages and core would be smaller and easier to maintain too