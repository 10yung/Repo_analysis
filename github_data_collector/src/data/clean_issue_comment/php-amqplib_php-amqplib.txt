 add missing and fix conflicting doc block definitions simplified if statements remove deprecated and unused method improve scrutinizer rating Currently the integration test suite does not use TLS We could use the same technique used in Pika to run the test suite once without TLS then enable TLS Configuring RabbitMQ to use TLS Running tests on Travis There is a lot of supported AMQP features but documentation is missing People keep asking how to use this library using github issues but this way is no go Would be nice to have a brief summary about all main features and use cases in some Read the docs style documentation Here are things I would like to have documented Exchange types and how to declare them simple direct fanout demoamqpconsumerfanout php topic headers demoamqpmessageheadersrecvphp Queue parameters and what they mean exclusive queue demoamqpconsumerexclusivephp Consumer features consumer cancel publish confirm demoamqppublisherwithconfirmsphp handling POSIX signals demoamqpconsumersignalsphp non blockig consume demoamqpconsumernonblockingphp Additional features delayed messages demodelayedmessagephp dead lettering demodelayedmessagephp exchange to exchange binding demoe ebindingsphp Connection parameters how to set connection name heartbeats For instance socket read timeout should be greater than x the heartbeat timeout See and other issues related to timeouts Feel free to comment and suggest what can be changedrefactored to make things more fluent and consistent in next major version Use one immutable object for all connection options and reuse it in all connection types Merge StreamIO and SocketIO into corresponding connection class Connection class should not extend channel class therefore no calls to protected methods Split AMQPChannelwait into to separate blocking and nonblocking methods separate method for internal use Refactor existing TODO Deprecate AMQPSSLConnection activate SSL context whenever protocol is secure x Deprecate public properties in connection and channel classes Deprecate global constants PSR code style Changelog standard x Remove bcmath dependency PHP typehints for most public methods Use or for low level nonblocking IO operations Consider the following example connection new AMQPStreamConnectionlocalhost user password channel connectionchannel channelbasicpublishnew AMQPMessagemessage undefinedexchange routingkey here the exception is reported to the channel and channel is closed on RabbitMQ side channelbasicpublishnew AMQPMessagemessage definedexchange routingkey this message even though valid will never reach its destination The definedexchange already exists and the undefinedexchange does not First call to basicpublish will result in channel exception being reported to the channel by RabbitMQ and channel being closed The issue I see here is that in userland we have no clue that this has happened and keep on sending new messages But they will never arrive to the server because channel has already been closed The same will happen when you have a consumer defined with prefetch grater than Take a look at the following example connection new AMQPStreamConnectionlocalhost user password channel connectionchannel channelbasicqosnull null message channelbasicgetmyqueue channelbasicackinvalidtag here the exception is reported to the channel and channel is closed on RabbitMQ side message channelbasicgetmyqueue we still get this message because it is already in buffer channelbasicackmessagedeliveryinfo deliverytag This message will not actually be acknowledged First message is processed and acked with an invalid deliverytag This results in exception being reported to the channel and channel being closed on the server side Due to QOS settings there are already other messages in the stream buffer so the library will simply grab the next available message without realizing there was an exception on the channel The library will eventually figure it out but only after all messages have been already read from the buffer and the next frame that is there is the exception itself Both of the behaviors can be dangerous First one because your well defined messages will never reach their destination without any apparent reason Second one even though very unlikely can lead to processing some messages twice when we definitely need to process them only once This behavior also presents itself when people are complaining that there is an exception being raised when they already try to close the connection This is exactly the same problem We send close message to the server but instead of getting the response we get previously buffered exception from already closed channel As a solution would be to throw an exception as soon as it is possible to detect there is an exception waiting in a buffer I do understand that this may impact performance to some extend but it would provide a logical behavior Tested on phpamqplibphpamqplib v See the discussion in It would be nice if both had identical defaults It remains to be decided what the default should be and how can we cause as little breakage as possible to existing codebases See Basically in the pcntlsignaldispatch call in the loop is no longer necessary I am use defineAMQPWITHOUTSIGNALS true And i am use custom sighandler with flag to exit If i send kill PHP Fatal error Uncaught PhpAmqpLib Exception AMQPIOWaitException A network error occured while awaiting for incoming data in usrsharenginxhtmlpushallvendorPhpAmqpLibWireAMQPReaderphp Stack trace usrsharenginxhtmlpushallvendorPhpAmqpLibWireAMQPReaderphp PhpAmqpLib Wire AMQPReaderwait usrsharenginxhtmlpushallvendorPhpAmqpLibWireAMQPReaderphp PhpAmqpLib Wire AMQPReaderrawread usrsharenginxhtmlpushallvendorPhpAmqpLibConnectionAbstractConnectionphp PhpAmqpLib Wire AMQPReaderread usrsharenginxhtmlpushallvendorPhpAmqpLibConnectionAbstractConnectionphp PhpAmqpLib Connection AbstractConnectionwaitframe usrsharenginxhtmlpushallvendorPhpAmqpLibChannelAbstractChannelphp PhpAmqpLib Connection AbstractConnectionwaitchannel usrsharenginxhtmlpushallvendorPhpAmqpLibChannelAbstractChannelphp PhpAmqpLib Channel AbstractChannelnextframe usrsharenginxhtmlpushallconnectrabb in usrsharenginxhtmlpushallvendorPhpAmqpLibWireAMQPReaderphp on line global needDie channel thisgetChannelqueuename channelbasicconsumequeuename false false false false callback whilecountchannelcallbacks try channelwaitnull false timeout catch PhpAmqpLib Exception AMQPTimeoutException e pcntlsignaldispatch ifneedDie thislogWORKER die rabbitgetChannelpushallallpushesclose rabbitconnectionclose exit 