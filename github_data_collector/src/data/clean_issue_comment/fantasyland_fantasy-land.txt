Ive not seen monet listed in But Id like to have fantasyland spec compatible libs for my node JS app Since I am fairly new Id love to have your input on this Thank you in advance I have suggested this approach in the past but after a recent realization I think it deserves its own discussion The reason for switch to symbols are as follows Two conflicting versions of Fantasy Land would automatically not try to interact with each other because they would have two different symbols More on this thought before Symbols existed here Symbols can be used to mutate prototypes of builtins without stepping on anyones toes It seems to me that this is how first class protocols are implemented underthehood and so by using symbols we are taking a first step towards It would allow a library to extend builtin prototypes with FantasyLand methods rather than implementing support for builtin types at the dispatcher level Last but not least my recent realization Using strings means that code which uses Fantasy Land is vulnerable to the exact same problem that Promisebased code is vulnerable to I have created a writeup about this vulnerability here In summary code that creates StrMaps like userInput AnyFunction and passes it to a fantasyland compliant map implementation such as Ramdas map or Sanctuarys map with the intend of mapping over the values will behave differently if the user passes fantasylandmap as input The same goes of course for all other algebras and all implementations of those that might get mixed with userinput Using symbols would remove this vulnerability as users have no way to pass symbols into a typical application from the outside Reasons I see against using symbols Managing compatibility between libraries might become more difficult Lets say Fantasy Land adopts symbols Now ADT library authors such as myself would have to add fantasyland as a dependency in order to use the correct symbols for interoperability with a dispatcher lib Then later when Fantasy Land comes out with some new algebra the dispatcher library might upgrade to it whilst the ADT library doesnt At this point it might happen that a package manager such as npm installs two distinct versions of Fantasy Land in a project which uses both the dispatcher lib and the ADT lib Those two distinct installations of Fantasy Land will provide two distinct symbols and as such the dispatcher lib will no longer be able to interact with the ADT This can be avoided in some ways having Fantasy Land as a peer dependency or using some automated deduplication strategies but either way its not as easy as it was with Strings It might take some time before symbols see full adoption Its a hardreset for the Fantasy Land community and for some transition period libraries would probably need to provide both strings and symbols Symbolfor Instead of using the distinct Symbol constructor Fantasy Land could use Symbolforfantasylandmap Library authors would not need to rely on a fantasyland package in order to provide interoperability This would remove benefit and problem from the pros and cons listed above leaving us with benefit and This is an issue in spirit rather than a pull request I am submitting the proposal in pull request form to facilitate threaded discussions and to allow changes to be made and tracked via Git The proposal is I believe sufficiently detailed so I wont repeat myself here I asked Avaq to review the proposal earlier today He noted that this approach solves rpominovfantasyland Aldwin has many ideas on this topic which I hope he will share here cc alexandru robotlolita rpominov This repository contains two things The Fantasy Land specification The source for the fantasyland package on npm Currently both are subjected to the same version number the one specified in packagejson Over the lifetime of Fantasy Land the major part of this version number has been bumped whenever a breaking change in the specification occurred the prefixing of method names the flipping ap etc The major version of Fantasy Land has therefore always been a decent indication of what libraries are compatible with one another and so a good means of communication and disambiguation With the latest major version bump the breaking changes did not apply to the specification itself but to the npm package This means that all libraries conforming to Fantasy Land also conform to Fantasy Land I think this might become a source of confusion Perhaps if others agree that this issue needs solving instead of relying on the package version number for communicating the version of the specification we could embed a formal version number in the specification document Or alternatively perhaps the npm package source code could be moved into its own separately versioned repository It is often useful to be able to traverse a nonempty structure with respect to a functor that is not quite Applicative but is nevertheless Apply A common use case I run into is transposing a something of objects into an object of something s js const result ArrsequenceObj x y x y x y The problem is that objects in JS have a straightforward implementation of lift but lawfully implementing pure would require the ability to construct infinite objects with the same value at every possible key this is possible with proxies but lets not go there Instead we want a weakening of the constraints of Traversable so that it can work with Applys Conversely the requirements on the traversable container are tightened more things are Traversable than are Traversable Here is an example of what an instance might look like for nonempty arrays js type Apply f Functor f lift a b c f a f b f c type Traversable t traverse Apply f a f b t a f t b Traversable Array const Arr const snoc xs x xs x const traverse A f x xs xsreducep c Alift snocpfc Amapx x fx return snoc traverse String String String const intersection s s const s new Sets return s filterx s hasx Apply Obj const Obj Obj v String const keys o Objectkeyso const zipWith f o o const k keyso const k keyso const ks intersectionk k return ksreducep k p k fo k o k const map f o keysoreducep k p k fo k const lift zipWith return zipWith map lift Traversable t Apply f t f a f t a const sequence T A xs T traverse Ax xxs Array Obj x Obj Array x const s sequence Arr Obj Array Obj x const input x y x y consolelogsinput x y Similar instances exist for nonempty objects themselves nonempty trees nonempty sets etc Perhaps obvious but its worth noting that all Traversable s are Traversable for free since all Applicatives are at least Apply Hi After reading I still dont understand why these kind of law are needed The topic starts talking about No parts of b return value should be checked But finally it concludes that the implementations that perform this kind of checks are breaking other laws For example javascript class Maybe static ofval return new Justval class Just extends Maybe constructorval super thisval val mapf const r fthisval return r null new Nothing Maybeofr class Nothing extends Maybe mapf return this This implementation breaks No parts of fs return value should be checked However it is also breaking the composition law javascript const f x x null x const g x x null x Maybeof mapfmapg Nothing Maybeof mapx gfx Just val Then I wonder if No parts of fs return value should be checked is a really necessary law For me its a weird law because is talking about the implementation For example these two implementations of Maybe javascript class Just extends Maybe mapf const r fthisval return Maybeofr and javascript class Just extends Maybe mapf const r fthisval return r null Maybeofr Maybeofr behave the same and are identity and composition law compliant However the second breaks the No parts of fs return value should be checked and is not functor lawful It doesnt make sense for me Cheers Wondering what ReadableStream and other streaming data structures are instances of Id love to see a version of Fantasy Land which takes advantage of michaelficarras FirstClass Protocols proposal This proposal unifies Fantasy Land and Static Land The unified specification is based on modules simple objects with functions that dont use this as opposed to putting methods directly to values Although values still have a single property reference to a module which makes the unified specification equivalent in flexibility to Fantasy Land I see following advantages of this approach We need only one property that is subject to name clashes Sometimes its impossible to add even a single property to values but we still can implement a compliant module which well have to pass explicitly everywhere though Also we may implement multiple modules for a single type Although again only one can be referenced from values and another well have to pass explicitly Since every implementation will have modules it allows for a whole different programming style where we choose to always pass modules explicitly even though they can be referenced from values This may have some advantages for example types are more explicit in code Also this approach should be easier to works with when we want to use static type systems like TypeScript or Flow To be honest I dont know much about this area But other people did a lot of research gcanti works on and alexandru works on and argued that static functions are much easier to work with than method here To my shame I still havent looked into these projects But I hope gcanti and alexandru can participate in the discussion here Previous discussions about this unification approach can be found here I also want to say a big thank you to briancavalier who came up with the idea of unification This PR comes with a huge diff and comments may become hard to follow if we discuss every single change here I think itll be better if we only discuss here whether we want this or not in general and for particular changes create issues or PRs in the fork This PR is a competitor with and based on a comment from iamtom Benefits over The Fantasy Land organization could provide a library of canonical types which could be used or wrapped by or not by conforming libraries cata provides a simple easy to remember interface to the type which provides it cata doesnt prescribe any naming convention for conforming libraries to follow The cata interface provides a means for conforming libraries to automatically convert between each other An example for point js var Maybe Just x x cata f fx mapf return MaybeJustfx Nothing cata d d mapf return MaybeNothing map f m mcataMaybeNothing composeMaybeJust f var Maybe requireotherlibmaybe Maybemap f Maybe Just equalsMaybeJust mapf Drawbacks Native types cant be overload with different views as mentioned in cata has a different signature for each type This could be confusing for newcomers No enforced name standardization Edit add point under Drawbacks 