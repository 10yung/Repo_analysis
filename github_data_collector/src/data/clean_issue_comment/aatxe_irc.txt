We currently upcoming have a Sender which uses an unbounded channel for outgoing messages This doesnt provide any back pressure to the send function in case we are unable to process the messages quickly enough possibly leading to OOM conditions A fairly straight forward way to solve this would be to limit the buffer size of the channel See buffer in documentation This does mean that the sender needs to use send and await over it as appropriate requiring all sendrelated functions to be async This would mean an impactful API overhaul but it would in my view be worthwhile was fixed but I didnt implement rate limiting using burst windows As per the comment in I raised the question whether this project should provide a builtin rate limiter at all or if we should encourage the user to use an external project like leakybucket full disclosure my project The following is an example of how an external rate limiter is used for anyone who is curious Unfortunately this hides a lot of utility functions of Sender like sendcapreq and its not straight forward to make async functions like acquire below pluggable async functions are not supported in traits nor do we have existential types yet so the anonymous future can be named The benefit however is that the rate limiter is an async function that can be awaited at any point You have full control over its configuration use and implementation Rate limiting happens before the send is buffered which makes sure that the rest of your application is back pressured when necessary rust use anyhowResult use ircMessage Sender use leakybucketLeakyBucket struct RateLimitedSender sender ircSender ratelimiter LeakyBucket impl RateLimitedSender pub fn newsender Sender ResultSelf OkSelf sender leakybucket LeakyBucketbuilder max refillintervalDurationfromsecs refillamount build pub async fn sendm impl IntoMessage Result selfratelimiteracquire await selfsendersendm Ok This is part of an effort to resolve by replacing owned strings with borrows Cows and generics where possible The most straightforward part is the Message type which now references a single buffer containing the messages serialization It avoids additional allocations by using iterators for parameterstags instead of storing them in collections This PR also resolves as part of the reimplementation of the message type delayed TODO Reimplement prefix parsing Add parser tests Integrate the new Message type with the other APIs Add more buildersconstructors for Message Unresolved questions How do we want to implement this in the broader scale Command and Prefix are also going to have to be rewritten to allow zeroallocation as they liberally use String but we still havent really discussed our options here Do we want to split these other changes into different PRs or would it be best to review and merge together I get a panic from an assertion failure in debug builds after starting a client that is configured to join a large number of channels The message burst stuff is at its defaults after maybe a minute or two it panics while trying to respond to a ping Maybe because the transport is considered not writable due to the throttling If my understanding is correct maybe if it fails to send a ping immediately it can set a flag that the transport can look for whenever it does become writable to know to preempt the queued messages and send a pong thread irc panicked at assertion failed resultisready homesqwishycargoregistrysrcgithubcom ecc db ec irc srcclienttransportrs As pointed out on the IRCv channel the library shouldn t present a difference between trailing and middle parameters to users This mistake has persisted for a long time but correcting it should actually simplify a lot of code though the change will be breaking After extracting the parameter list all parameters are equal whether matched by middle or trailing Source Equivalent WeeChat option ircserverdefaultcommanddelay delay in seconds after execution of command and before autojoin of channels example give some time for authentication before joining channels default values Alternative solution to for joining r channels Turns out you can also identify during connection if you do it via the password option eg setting it to accountpassword for Freenode Thanks panicbit While looking into how I could implement reconnection after pingtimeout in ircbot I hit this question Suppose that several IrcClients are cloned their clones are registered with an IrcReactor r with rregisterclientwithhandler and rrun is called and after running for a while returns Can the same sequence of events safely be repeated registering new clones of the same IrcClients with the same IrcReactor and running the reactor again I would guess that if the reactor shut down because a connection failed the IrcClient corresponding to that connection no longer would be usable but what about the other clients running on the same reactor I would like to suggest that the answer be documented covering whether an IrcClient c that was being run on an IrcReactor can be reused thus in the following cases the run call returns Ok the run call returns Err because of a problem with c and the run call returns Err otherwise such as because of a problem with a different IrcClient I note largely for the sake of making GitHub create crossreferences between these issue tickets that this seems relevant to tickets and Im having a very hard time as a Rust beginner figuring out how to hack in an SASL connection with urlbotrs and I havent found a dependent crate that actually uses SASL to use as an example WeeChat lets you specify the SASL mechanism A similar config option could be used here to state whether to not use SASL use plain authentication or use external authentication which afaik would then use this crates clientcert options The reason I want to use SASL is so I can join channels that require registeredidentified users This is especially important on Freenode where unsetting r is just inviting spammers Turns out you can also identify during connection if you do it via the password option eg setting it to accountpassword for Freenode Thanks panicbit Id love to have the proto half of this repo available in wasm contexts but the client half gets very in the way of that Would you be opening to either splitting up the crate or doing something with a feature flag Resolves eventually Im not sure how complete that implementation is at this point since you know the codebase a lot better than I do you might be able to give some pointers So far it seems I can just ignore all options that are not relevant for me but Im wondering if its possible to disable reconnects and handle them myself A reconnect attempt would likely error out since configserver is None As a note this is somewhat related to 