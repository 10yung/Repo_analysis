Added float version of GetPickRay to allow sub pixel selection Have deprecated the integer version Hi xoofx Due to inactivity of SharpDX Ive decided to start new DirectX bindings but with some standard stuff I target net standard and use mathematics from SystemNumerics Vector Vector etc Use Unsafe instead of Interop patching API strict to native C API so porting will be easy Wont bind Direct D probably nor Direct D Not sure about XAudio or Multimedia framework No DirectInput DirectSound DirectManipulation DirectComposition or RawInput Will support recent Windows SDK and I plan to add raytracing support as well I took some approach from SharpDX for some bindings part The repo is here And here you can see some example of API usage If you want you can update README with links to thoose bindings Matrix x ScaleVector returns new Vector M M This is only correct if M M Heres an easy test var transform Matrix x Scaling f f DebugWriteLineScaling transformScaleVector prints Scaling X Y transform Matrix x RotationfloatMathPI DebugWriteLineScaling transformScaleVector prints Scaling X E Y E As explained in This Mathematics Stack Exchange answer there is no real answer to What is the scale vector of this matrix If you ignore the fact that the scaling can be the negative version of the rotation A degrees you can calculate scale like this var scaleX MathSqrttransformM transformM transformM transformM var scaleY MathSqrttransformM transformM transformM transformM var cosA transformM scaleX var cosB transformM scaleY var sinA transformM scaleY var sinB transformM scaleX At this point scaleX and scaleY are valid only if cosA cosB and sinA sinB within tolerance I run CustomFont sample and I use NuGet to install SharpDx if I install version all good but if I install version I get the following error Unexpected error Reason SystemObjectDisposedException Cannot access a disposed object Cannot add a reference to a nonreferenced item SharpDXCallbackBaseAddReference SharpDXComObjectShadowAddRefImpl SharpDXComObjectShadowComObjectVtblAddRefImplIntPtr thisObject SharpDXDirect D RenderTargetDrawTextLayoutRawVector origin TextLayout textLayout Brush defaultFillBrush DrawTextOptions options SharpDXDirect D RenderTargetDrawTextLayoutRawVector origin TextLayout textLayout Brush defaultForegroundBrush FontsFromFolderCustomFontrenderControlPaintObject sender PaintEventArgs e K SharpDXmaster Samples SharpDXSamplesmaster Desktop DirectWrite CustomFont CustomFontcs I have project that shows the world map but I was having issues with the memory so I have created a new empty project currently I only have the following MainWindowxaml Window xClassWorldMapMainWindow xmlns xmlnsx xmlnsdxcclrnamespaceSharpDXWPFassemblySharpDXWPF xmlnslocalclrnamespaceWorldMapScenario TitleWorld Map Height Width WindowStartupLocationCenterScreen Grid BackgroundLightGray dxcDXElement GridColumn xNamemDxelement dxcDXElementRenderer localSceneMap xNamemSceneMap dxcDXElementRenderer dxcDXElement Grid Window MainWindowxamlcs using SystemWindows namespace WorldMap public partial class MainWindow Window public MainWindow SceneMapcs using SharpDXWPF namespace WorldMapScenario public class SceneMap D D public SceneMap When I execute it the memory increases really fast around MB each minute what am I doing wrong I am new into SharpDX so I really appreciate any help Thanks in advance Hello just a small change in Direct D Fix GetUnorderedAccess view call in case no depth buffer is bound Add ComArray binding for CSSetUnorderedAccessViews same as Constant bufferSRV counterpart Thanks Since MapSubresource returns the mapped subresource rather than taking a destination pointer there is no way to pass pMappedResource NULL to Map which is required for the ReadFromSubresource operation Relevant docs Some MediaFoundation classes return UInt Example However in the autogenerated Interfacescs of SharpDX I could not find any GetULong instead the GetLong is used which casts ulong to long and therefore might cause troubles with overflows I am suspecting this because the following call returns wrong framerate values in certain videos which have fractional framerates var mediaType sourceReaderGetCurrentMediaTypevideoStreamIndex var rate mediaTypeGetMediaTypeAttributeKeysFrameRate returns Im trying to read back a texture to CPU so I created a staging texture The problem is that this texture may have an arbitrary size so I create it with something like stagingTextureDescWidth stagingTextureDescHeight stagingTextureDescCpuAccessFlags SharpDXDirect D CpuAccessFlagsRead stagingTextureDescBindFlags SharpDXDirect D BindFlagsNone stagingTextureDescOptionFlags SharpDXDirect D ResourceOptionFlagsNone stagingTextureDescUsage SharpDXDirect D ResourceUsageStaging texIntfDatamIntermediateStagingTexture new SharpDXDirect D Texture DtexIntfDatamIntermediateDevice stagingTextureDesc texIntfDatamIntermediateStagingShaderResourceView new SharpDXDirect D ShaderResourceViewtexIntfDatamIntermediateDevice texIntfDatamIntermediateMipMapTexture Now when I read it back later it reports me this size however internally it is definitely has a width of because the data I read back MarshalCopy is aligned to and not It does not matter if the texture is multiple of or or an uneven number it seems to be always the larger power of in the end The problem is there is no way to really query the size of the texture or am I wrong 