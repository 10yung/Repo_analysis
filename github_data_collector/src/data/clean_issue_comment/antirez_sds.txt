I know that sds is a library solely intended for C but I happened to include the header sdsh in a C application I dont want to go into details why I needed to do this However when compiling the C application I get some of these errors sdsh error invalid conversion from void to sdshdr fpermissive define SDSHDRVARTs struct sdshdrT sh voidssizeofstruct sdshdrT A minor change in the header would fix this issue I dont think that it breaks anything but I think you antirez know best if it causes sideeffects or not Ive tested this change with in my Application and it works fine in C and C so far SDSNOINIT is currently declared in sdsh without extern resulting in multiple definitions across sdsh consumers With GCC the default of fcommon option will change to fnocommon resulting in an error As Ive read in the reference and source when you pass an sds string to these two functions you always have to assign the pointer back Is there any workaround to make these functions work inplace That is pass them an sds and have it modified without changing the objects pointer Example c sds str str sdsnewHi str sdscatstr str printfs n str not Hi Hi It might be worth considering only allocating strings of a capacity that is a power of two including header to reduce memory fragmentations A simple code snippet to round up to the next power of two unsigned int v compute the next highest power of of bit v v v v v v v v v v v v v I can make the code contribution if youd like Optimized the use of vsnprintf The tokens will contain empty sds element when the separator is at the beginning or the end of the unsplit string the code have passed the sdstest I did some investigation on Redis source code while I was doing my job Something about sdshdr and sdshdr storage had raised my curiosity and something really confused me popped up Here are the steps to reproduce the scenario Open redis cli Type SET key value So here from my perspective and observation THE value has been stored with sdshdr and THE key has been stored with sdshdr through dbAddsdsdup I was guessing with the help of MEMORY USAGE THE key should be analysed as sdshdr while THE key was passed via cargv ptr it will be first encapsulated with method createdEmbeddeStringObject which adopt sdshdr as the struct type So it will be analysed as sdshdr rather than sdshdr So could anyone explain what is the actual reason for this and will this affect the accuracy of MEMORY USAGE command Appreciated