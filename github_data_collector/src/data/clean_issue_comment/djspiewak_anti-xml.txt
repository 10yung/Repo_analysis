Are there plans to release antixml for Scala I see that theres noarktekkantixml in Maven Central but that doesnt look like an official antixml release Or is it Suppose you have val xml Elem foobarfooconvert and I want to modify the document to foobarbazbarfoo val barzipper Zipper Elem xml bar val newbarzipper Zipper Elem barzipperupdated barzipperhead addChild bazconvert val newxml newbarzipperunselect apply The problem is that unlike most of the other Zipper methods Zipper T unselect returns a Zipper Node rather than Zipper T Thus newxml has the general type Node rather than Elem even though the original zipper was of type Zipper Elem If you want to use Elemspecific functions on the result you have to cast it val newxmlwithextrachild Elem newxmlasInstanceOf Elem addChild blahconvert Hi scala def syncElemse Elem e Elem Elem val fullAttrs e attrsfilterNot isEmpty val newAttrs e attrsfilterNot at fullAttrskeys exists at filter at e attrskeys exists at e copyattrs fullAttrs newAttrs throws a CastClassException while scala def syncElemse Elem e Elem Elem val fullAttrs e attrsfilterNot isEmpty e copyattrs fullAttrs e attrsfilterNot at fullAttrskeys exists at filter at e attrskeys exists at works fine Thanks GN I know AntiXML is not an XHTML library but if you want to be able to use it for XHTML as I did want to you should know that while script srcfooscript is valid XHTML script srcfoo isnt And now the browser HATES me scalaxmlXML seems to go to the other extreme always expanding empty tags to nonempty tags I guess I could use AntiXML just for queries and manipulation XML but use the xmlNodeSeqs toString to write it to disk but then Id either need to keep both representations around or have some way to convert back from antixmlNode to xmlNode Any suggestions Thanks for a nice little library PS The only valid empty tags in XHTML Strict are basemetalinkhrbrparamimgareainputcol Im grabbing the XHTML from this page As one big string blob This is in Scala on Windows JRE When i try to perform var xml XMLfromStringbody Its throwing me a StackOverflowException a short segment of the stack trace looks like at javautilregexPatternGroupTailmatchPatternjava at javautilregexPatternBranchConnmatchPatternjava at javautilregexPatternCharPropertymatchPatternjava at javautilregexPatternBranchmatchPatternjava at javautilregexPatternGroupHeadmatchPatternjava at javautilregexPatternLoopmatchPatternjava at javautilregexPatternGroupTailmatchPatternjava at javautilregexPatternBranchConnmatchPatternjava at javautilregexPatternCharPropertymatchPatternjava at javautilregexPatternBranchmatchPatternjava at javautilregexPatternGroupHeadmatchPatternjava at javautilregexPatternLoopmatchPatternjava at javautilregexPatternGroupTailmatchPatternjava at javautilregexPatternBranchConnmatchPatternjava The rest of the stack trace looks about the same This is a pretty typical if slightly large XHTML page kb and it should not be cause the XML parser to fail The TODO list is quite outdated by now and should probably be revised Also Im looking for a new issue to tackle so having an updated list would definitely help me choosing Thanks When you have a namespace asigned to the root node default prefix like this xml root xmlnsurnfoobar child root This translates into the Antixml tree scala ElemSome root Attributes Map urnfoobar GroupElemNone child Attributes Map urnfoobar Groupempty This is incorrect The prefix in the child node should also be Some Ive been trying to use antixml to parse and generate some XML documents that use some elements from the atom namespace My code uses our own private namespace but in the documents it is bound to the default namespace An example XML looks like this profile xmlns xmlnsatom atomlink id href profile Ive run into two issues with this The first is that the conversions drop the namespace entirely see Ive fixed this so that its more in line with the existing API The second issue I see now is that the entire API is oriented around the prefix parts instead of the namespace part When Im converting the XML to my Profile object I dont care about the prefix I just want the elements named link inside the Atom namespace Right now Ill have to do this by hand I would like to adjust the API so that its more in line with javaxmlQName and W s definition see and The prefix is not a part of the qualified name of an element and really not very interesting when it comes to matching on objects Im hoping to be able to write something like this def atomLinkse Elem e Namespacesatom link Does this make sense I really like antixml and were using it for most of our XML stuff now but this came up as an issue the other day and I dont see a way to fix it without changing antixml Ive implemented my ideas under my own repository Im not entirely satisfied with the current solution but it shows what I want to achieve All the existing tests passes and Ive added some more too An attempt to break Zipper into traits as per Not sure whether this is the most elegant way to do this As theres a bunch of ZipperXXX files now I decided to move them into a separate folder Should we move them into a separate subpackage as well 