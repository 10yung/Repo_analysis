I noticed that oncall method was in the code but it didnt come in the bundled version By bumping the version I want to make rubygemsorg look for the newest stuff Does anyone know what parts of this gem will stop working if any when Twitter changes the stream API in August The details are here and here Thanks Hi I imagine this is because of the new limit Result looks like Lorem ipsum dolor sit amet consectetur adipiscing elit Etiam et sem dignissim vestibulum mauris et viverra maur Is that a twitter api issue UPD Tweets need to be fetched in extended mode to fix this See When I call the stopstream function on a user stream after receiving an onreconnect it fails to stop the stream and I continue to receive the onconnect messages It somehow fails to stop the stream class TwitterUserStream def initializeuserid accesstoken accesstokensecret userid userid accesstoken accesstoken accesstokensecret accesstokensecret end def beginstream credentials consumerkey ConsumerKey consumersecret ConsumerSecret oauthtoken accesstoken oauthtokensecret accesstokensecret client TweetStreamClientnewcredentials clientonreconnect do timeout retries clientstopstream end clientuserstream end end For now rubocop dependency was set to at least but as rubocop is getting stricter it will just fail if you will bundle and execute rubocop although nothing changed However I fixed some complains of rubocop and set it to I tried to update the twitter gem as well to fix but somehow travis cant build rubinious at the moment PS your rubocop rules are pretty weird Hashrocket style in First of all tweetstream is awesome I love it However currently it depends on an old version of the twitter gem The old twitter gem version depends on json And json isnt compatible to ruby However newer versions of the twitter gem have no dependency to the json gem anymore so increasing the twitter gem version may help By using Twitter User Streams on iOS Im aware that sometimes it passes a block of data which isnt the full data of a message Thus I had to implement a system whereby if the data wasnt complete itd hold onto it until the next block came and then append it only reading it as full JSON once it detected the end of the data and a complete JSON structure Im not too familiar with Ruby I was wondering if TweetStream implements this same logic or if perhaps this isnt a problem when not using an iOS streaming technology client TweetStreamClientnew puts STARTING bot clientuserstream do status Cada status recebido pelo User Stream ser manipulado dentro desse bloco puts statustext print do texto do tweet end Ive setup a simple test app which has this code It starts user streams for separate users and when the second user receives a message it stops their userstream Stopping an individual userstream while keeping the others alive is a critical part of my app Ruby Threadnew do firstcredentials consumerkey ABC consumersecret DEF oauthtoken GHI oauthtokensecret JKL firstclient TweetStreamClientnewfirstcredentials firstclientondirectmessage do directmessage puts direct message directmessagetext end firstclientuserstream end Threadnew do secondcredentials consumerkey ABC consumersecret DEF oauthtoken MNO oauthtokensecret PQR secondclient TweetStreamClientnewsecondcredentials secondclientondirectmessage do directmessage puts another direct message directmessagetext secondclientstop end secondclientuserstream end I test this by sending a few messages to the first client which all work Then a message to the second client which works and then it calls stop to stop the connection Another message to the second client doesnt get printed as expected but nor do any messages to the first client as its userstream has also been stopped 