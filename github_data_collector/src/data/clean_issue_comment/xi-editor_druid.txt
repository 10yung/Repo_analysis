This addresses This requires to have access to currenttransform which is necessary to keep track of applied transformations One thing that is missing here also because Im not sure is keeping track of clipping Right now previous clipping is not applied to zorder painting It would be a bit trickier since PaintCtx would need to keep track of clipping One other thing that I was thinking about was thinking about is whether it would make sense to allow negative zindexes to allow painting below content Im running code which in simplified version looks like this rust use stdthread time use druidwidgetButton Flex use druidAppLauncher Widget WindowDesc Clicking a button should close the window The close button close the window fn main let window WindowDescnewbuildwidget AppLauncherwithwindowwindow usesimplelogger launch u expectlaunch failed dbgGUI killed The close button makes the window hang fn main dbgLAUNCHGUI let mut shouldgui true loop dbgLOOP ITERATION if shouldgui true dbgSHOW GUI shouldgui false let window WindowDescnewbuildwidget AppLauncherwithwindowwindow usesimplelogger launch u expectlaunch failed dbgGUI KILLED let sleeptime timeDurationfrommillis threadsleepsleeptime fn buildwidget impl Widgetu Flexcolumn withchild Buttonsized Close evtctx data env dbg data evtctxwindowclose evtctxsubmitcommanddruidcommandsCLOSEWINDOW None Im expecting the window is closed properly and the program keeps looping without GUI Instead Im getting a hanging window which cant be closed see druidclosebroken Also discussed here Software versions gtk develx fc glib develx fc Hi Cool project Im a year UI dev and would like to contribute Here are a few items I feel this project could benefit from and would love your feedback Im a relative newcomer to Rust and Druid but UI has been my focus for some time and the patterns used in Druid are very familiar to me This PR is a WIP and contains Virtual List widget Tested using million rows with no performance cost It can take many many more rows with zero performance impact Works with both Vertical and Horizontal axis A Decoupled Scrollbar widget Basically a slider that interpolates between a given Range instead of a viewport boundary This decoupling allows the most flexible usage for views that virtualize layouts EventSize propagates to children this was necessary to adjust the scroll position bindings and to calculate a new maxscrollposition value To Test run the virtuallistrs in examples TODO VirtualList Keyboard navigation accessibility x Determine if reusing popped widgets provides advantages and implement if yes tabled for later Variable size rowscols Potentially impactful with performance since all items would need to be measured in order to calculate the maxscrollposition Smooth scroll A fairly straightforward implementation since the VirtualList design keeps this in mind Test thoroughly Scrollbar x Apply animation to scrollbar this will likely be a copypaste from the original Scroll widget x Page the scroll position up or down depending on where a mouse event occurs in relation to the scroll thumb along the scroll track Wire in whatever solution is found for Test thoroughly I have a few questions also The update flow seems to aggressively clone the entire data structure even when a single field is all that has changed This still seems to happen when manually implementing the Data trait also Is there a way to avoid this If no are there plans to address this eg Observables I found the Data requirement to be cumbersome Why was this chosen over just PartialEq I see they are somewhat synonymous druidsamefn PartialEqeq EventMouseMoved requires a delta to be calculated manually Are there plans to include the delta similar the EventScroll I hope you find these widgets useful I certainly had fun creating them Thank you for your time and feedback Justin This is branched from but has come up repeatedly so I felt it needed its own issue Mouse move and up events are dropped when the mouse is clicked in window then dragged outside This causes all kinds of problems as widgets reasonably expect an eventual mouse up after a mouse down I think it needs to be solved at the druidshell level On Windows we should be calling SetCapture and ReleaseCapture Im not sure what the counterparts are on other systems on macOS I think this may be handled by the platform When should the app grab mouse capture One possibility is to always do this on mouse click Another is to have it plumbed down from setactive and there is a TODO in the source for this If the behavior on macOS is to always capture then I think the former route is more developerfriendly as theres less risk of strange behavior when setactive is not called and of course less platform variation breaking out of Theres currently an issue where commands issued during or after update wont be handled until after the next normal event arrives We shouldnt have to wait if there are commands to handle we should immediately schedule a new update and handle them edwin cheng youre welcome to take this if youre interested The best way to handle this right now would be to schedule an idle call with the runloop if there are commands to process after painting is finished that would trigger a new eventupdate pass This is something we will need to do anyway because lifecycle will work like update and you will be able to submit commands there but we wont run them until after this paint cycle If youre interested in implementing this you would be welcome to it would work like timer does where you request a callback from the WindowHandle or WinCtx and then I would probably add a fn idle mut self method to druidshellWinHandler with an implementation in druidwinhandler that just processes commands Also the mechanism for scheduling idle tasks exists but is a bit confusing basically you call WindowHandlegetidlehandle which returns an OptionIdleHandle then you call addidle on that passing a closure that will be called with an dyn Any that is actually your WindowHandler type you can downcast that to the correct concrete type and do stuff with it Im not totally sure what the rationale for this approach is the basic idea is that you can do arbitrary things with your WindowHandler in that closure like create and dispatch events but its definitely an awkward API Originally posted by cmyr in I am running textbox example from main branch on windows compiled with stablex pcwindowsmsvc rustc e steps to reproduce run textbox example select all text in top textbox move the cursor out of the window before releasing the mouse button type something move cursor back into textbox after typing Textbox needs to handle key press event so It doesnt keep selecting after user types something I want to open a pull request for this if this is a bug I found out when modifying data in AnimFrame the Widgetupdate will not run For example I have a widget which use AnimFrame event to poll some thread results and then it will change a boolean flag in my data which is controlling a Either widget But it do not work as expect and my Either widget do not switch I think the reason of that is If I understand correctly It should call update after AnimFrame event but current implementation did not Weve been talking about this for a while in zulip though Im just now realizing theres no issue for it This is a first step toward doing some fancy buttons like a control strip and the button aspect of a dropdown menu but also asis it should be helpful for many scenarios where something needs to be clickable Two issues with my implementation to recreate the existing styling I made a ButtonBackground widget but for some reason that widget doesnt get isactive updates from its parent only ishot so I have to do extra event handling Its very possible Im doing a very dumb error but I couldnt find it to make lifetimes work with WidgetExt I had to make WidgetExt T Data static which Im guessing is not ideal Its unclear to me what Im doing weird here because WidgetExt is working with other widgetpodaschild widgets asis Also all the names for things are up for debate but Im pretty happy with it right now I guess theres a larger question if this is appropriate for WidgetExt but it felt right to me Followup from The Github workflow should be updated to check against feature flags so that any future APIbreaking change doesnt also silently break the flagged feature I have some code that creates a split layout fn uibuilder impl Widgeti Splithorizontal FlexcolumnwithchildLabelnewSidebar goes herecenter FlexcolumnwithchildLabelnewTask goes herecenter draggabletrue If I drag the split handle so that the left side of the Split is smaller than the width of the Label it contains the label text overflows its container and into the right side of the split This is what it looks like img width altScreen Shot at PM src I can reproduce the same issue by manually setting the size of the Split fn uibuilder impl Widgeti Splithorizontal FlexcolumnwithchildLabelnewSidebar goes herecenter FlexcolumnwithchildLabelnewTask goes herecenter draggabletrue splitpoint If I use a Button instead of a Label as a child the button resizes itself to fit inside the Split as expect But the text inside the button overflows the Split container as well as the button Heres the code to reproduce the issue fn uibuilder impl Widgeti Splithorizontal FlexcolumnwithchildButtonnewButton goes here Buttonnoopcenter FlexcolumnwithchildLabelnewTask goes herecenter draggabletrue splitpoint Heres is what it produces img width altScreen Shot at PM src The issue occurs on the current master branch I havent had a chance to test it on 