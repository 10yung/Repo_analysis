 cd liblumeneirinterpreter cargo run ident foorun examplessimpleserver Actual thread main panicked at value Userslukeimhoffcargogitcheckoutseir a c f a f bblibeirirsrcalgolivers details simpleserverlog details Expected Im not sure what the output should be but I doubt it is a panic KronicDeth encouraged me to report not implemented stuff I ran into while trying Lumen so yall can get an idea of what is actually used I tried a few things by modifying spawnchain and most things ran into panicked at not implemented examplesspawnchainsrcelixirenumreducerangedec rs Trying to interact with a JS object Trying to start a GenServer and a few other experiments all lead there Hope that helps Let me know if you need anything more As seen in and other test runs otperlangtermtobinary testroundtripsthroughbinarytoterm sometimes fails For this specific failure it was shrunk to thread otperlangtermtobinary testroundtripsthroughbinarytoterm panicked at called Resultunwrap on an Err value FailReasonassertion failed left right n left OkBox x f fa literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa at x f fa n right OkBox x f fa literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa at x f fa at lumenruntimesrcotperlangtermtobinary testrs Pid Box x f fa e literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa d literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa d at x f fa e srclibcoreresultrs note run with RUSTBACKTRACE environment variable to display a backtrace Reformatting for clarity assertion failed left right left OkBox x f fa literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa at x f fa right OkBox x f fa literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa at x f fa at lumenruntimesrcotperlangtermtobinary testrs Pid Box x f fa e literalfalse valueTermBoxedliblumenallocertstermtupleTupleTupleTermPID Box x f fa d literalfalse valueTermBoxedliblumenallocertstermpidExternalPidExternalPid header HeaderliblumenallocertstermpidExternalPid b arcnode Node id name Mutex data Cell value external creation pid Pid at x f fa d at x f fa e Do you have any example of its usage using Erlang and not elixir that are not imply npm also Although the location is optional for stacktraces from getstacktrace we should include it because we have it Based on the examples in the docs for getstacktrace badarg exception should have a stacktrace when caught with catch or when using getstacktrace However the badarg macro and other exception macros do not do this so most of the usages are not going to show helpful stacktraces Generate stacktraces for all exception macros from the Processstacktrace externalsize termtobinary Should only be implemented if it called by other code as it requires supporting multiple deprecated and future versions of the protocol and compression To be able to support the community debugging tools specifically Observer well need to be able to expose the Lumen runtime running in a browser tab to the host Because the host wants to connect to nodes it can find by first talking to EPMD we will need a proxy that shows up as another node on the host but then gets forwarded to the browser Make the distribution transport pluggable in lumenruntime This may be the same interface as netkernel or something specific to Lumen using Rust fn similar to the time source Use mobileoverlords phoenixclient to connect to the HOST Use wrapper around LumenWebWebSocket to connect to HOST in place of websocketclient that phoenixclient uses by default A LumenBeamSplitter Elixir project that runs on the HOST A dedicated socket similar to how phoenixlivereload is on a separate socket prefix from the apps default one Bind a port on the host that can act as a secondary node on the host PROXYPORT Negotiate with EPMD so it thinks PROXYPORT is another node Pass messages received on PROXYPORT to the Phoenix Channel With this setup it should be possible for observerstart launched from iex S mix phxserver on HOST to then connect to the localhostPROXYPORT and talk to the Lumen runtime in the browser tab Alternatives netkernel on HOST Overriding netkernel on HOST so that it natively understand websockets similar to how other developers have overridden netkernel on Heroku and other restricted environments Raw WebSockets Instead of going over Phoenix Channels we could use a raw websocket This makes it easier to talk to things that arent Phoenix but makes it hard to integrate with Phoenix as we couldnt use the Endpoint socket DSL Process spawning BIFs that take a Node on which to spawn the process which should be implemented with the Distribution work and potentially as stubs that only work for nonodenohost when the local node is not alive spawnnode fun spawnnode module function args spawnlinknode function spawnlinknode module function args spawnoptnode function options spawnoptnode module function args options 