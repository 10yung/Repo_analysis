Feedback on cbc ea d cdef b b a b in As far as I can tell theres no way to set a databasewide default objectPolicy and metadataPolicy This is a bit of a drag as we dont necessarily know the names of all the collections in order to specify the policies during database setup Ideas Allow setObjectPolicyforCollection to set a policy for a nil collection and use that as the default policy It looks like the method implementation already accepts nil and turns it into its just that the consumer of getObjectPoliciesmetadataPolicies doesnt seem to check as a fallback Readd new methods to set default object and metadata policies that are used as a fallback Happy to make a PR that does one of those but not sure what the design intention was when making this change Hi Pardon me if I am asking a trivial question but this is something I am unable to figure out As per my understanding the YapDatabase instance is the one which just opens the database file Then we use YapDatabaseConnection to open a Sqlite connection How do we close this connection Like in FMDB we have a dedicated method to close an open database connection In one of the issues I found a way to handle the closing by use of a notification but that happens when the YapDatabase instance is deallocated Is there an exposed API to force close an open instance Otherwize how will we accomplish this We should support SPM before we add much more swift code SPM doesnt support mixed language targets so its probably best to come up with a nonpainful way to support SPM now rather than waiting until theres even more swift code to deal with The main pain point is exposing the public headers of the Clanguage code Resolves The Xcode project no longer builds due to several files not being included in the project Files in question YapDatabaseTypesh YapDatabaseConnectionProxyhm YapDatabaseConnectionPoolhm YapDatabaseCollectionConfighm YapDatabaseConnectionConfighm YDBLogMessagehm YapDatabaseLoggingm doesnt exist but is in the compile sources build phase Databases created with SQLCipher x are not compatible with SQLCipher x by default For more details Hello This issue is more of a question than exactly an issue According to Apple documentation NSCoding is vulnerable to object substitution attacks It recommends using NSSecureCoding instead We got this warning in a security scan of an application that uses YapDatabase I d like to ask if YapDatabase handles this vulnerability Best regards Problem When I for example I want to display a maximum of two items in a specific group and do this objc mappings setRangeOptions YapDatabaseViewRangeOptions fixedRangeWithLength offset fromYapDatabaseViewBeginning forGroupgroup there will be a bug if the group contains N items when this call is made Internally YapDatabase sets the length of the range options to MINlength objectCount and then forgets about this value This is a problem when the view and mappings are created first and then data comes in from a network request to populate the groups The range options will forever be in length If this was intended Id love to understand why Solution Never overwrite the maxLength of fixed range options Were getting this crash quite often when updating a view from changes with view mappings Its happening presumably when there are many updates happening at the same time Its possible that this crash is due to a bug in UITableView it also happens in UICollectionView The crash is reproducible both on simulator and device The frequency of the crashes seem directly related to how big the changeset is attempt to perform an insert and a move to the same index path NSIndexPath xbd b a c f length path Sometimes the crash will instead be this attempt to insert row into section but there are only rows in section after the update I have made a sample view controller that will quickly reproduce this crash However its not deterministic and will happen on different changesets every time even if the changes are exactly the same on each run The interesting thing is that it doesnt seem like YapDatabase actually reports a move and insert to the same index path since then the assert inside yapDatabaseModified shouldve fired which is what leads me to believe that the crash might be in UITableCollectionView Has anyone else ran into this Could it be a YapDatabaseissue Were unfortunately getting this a lot and we might have to turn off animated updates completely Possible fix Ignoring all YapDatabaseViewChangeUpdate seems to completely fix all crashes Possibly related to this crash also observed here It appears that reloads simply arent compatible with other collection updates Solution When doing manyquick updates reloads must be performed individually In yapDatabaseModified heres one way to fix all the crashes In your objectAtIndexPathfunction cache the NSIndexPath YapCollectionKeypair In yapDatabaseModified From the notifications filter out all YapDatabaseRowChanges with of type YapDatabaseViewChangeUpdate Call reloadRowsAtIndexPaths for these updates The table view will call cellForRowAt which should return an object according to the cache mentioned in Clear the cache Update the viewMappings to grab the changes the normal way Perform all the batch updates the normal way but skip all YapDatabaseViewChangeUpdate Implementation example here The cache is needed because when you call reloadItemsAtIndexPaths the viewConnection will be at the latest database snapshot but the viewMappings will not so it seems that the rowids doesnt match The cache makes sure that we always fetch the correct object because we have associated index paths with a collectionkeypair Reproducing view controller Just add it as the initial view controller of an empty project objc import ViewControllerh import AppDelegateh import YapDatabaseYapDatabaseAutoViewh interface ViewController property nonatomic strong YapDatabase database property nonatomic strong YapDatabaseConnection connection property nonatomic strong YapDatabaseConnection writeConnection property nonatomic strong YapDatabaseViewMappings mappings end implementation ViewController define RNDMAX MAX randMAX voidloadDatabase NSURL library NSFileManager defaultManager URLsForDirectoryNSLibraryDirectory inDomainsNSUserDomainMask firstObject NSURL databaseURL library URLByAppendingPathComponentdatabasesqlite selfdatabase YapDatabase alloc initWithPathdatabaseURLpath selfdatabase newConnection readWriteWithBlock YapDatabaseReadWriteTransaction transaction transaction removeAllObjectsInAllCollections voidviewDidLoad super viewDidLoad srand Used to reproduce changesets self loadDatabase selfconnection selfdatabasenewConnection selfwriteConnection selfdatabasenewConnection self registerView self setupViewMappings selftableView reloadData NSNotificationCenterdefaultCenter addObserverself selectorselectoryapDatabaseModified nameYapDatabaseModifiedNotification objectnil NSTimer scheduledTimerWithTimeInterval repeatsYES block NSTimer Nonnull timer self changeData voidregisterView if selfdatabase registeredExtensionview return YapDatabaseView view YapDatabaseAutoView alloc initWithGrouping YapDatabaseViewGrouping withObjectBlock NSString YapDatabaseReadTransaction transaction NSString collection NSString key NSDictionary object return object section stringValue sorting YapDatabaseViewSorting withObjectBlock NSComparisonResultYapDatabaseReadTransaction transaction NSString group NSString collection NSString key NSDictionary object NSString collection NSString key NSDictionary object return object value compareobject value selfdatabase registerExtensionview withNameview voidsetupViewMappings NSMutableArray groups NSMutableArray new for int i i i groups addObjectistringValue selfmappings YapDatabaseViewMappings mappingsWithGroupsgroups viewview selfmappingsisDynamicSectionForAllGroups YES selfconnection beginLongLivedReadTransaction selfconnection readWithBlock YapDatabaseReadTransaction transaction selfmappings updateWithTransactiontransaction voidyapDatabaseModifiedNSNotification notification NSArray notifications selfconnection beginLongLivedReadTransaction NSArray sectionChanges nil NSArray rowChanges nil selfconnection extview getSectionChanges sectionChanges rowChanges rowChanges forNotificationsnotifications withMappingsselfmappings if sectionChanges count rowChanges count return selftableView performBatchUpdates for YapDatabaseViewSectionChange sectionChange in sectionChanges switch sectionChangetype case YapDatabaseViewChangeDelete selftableView deleteSections NSIndexSet indexSetWithIndexsectionChangeindex withRowAnimationUITableViewRowAnimationAutomatic break case YapDatabaseViewChangeInsert selftableView insertSections NSIndexSet indexSetWithIndexsectionChangeindex withRowAnimationUITableViewRowAnimationAutomatic break default break for YapDatabaseViewRowChange rowChange in rowChanges switch rowChangetype case YapDatabaseViewChangeDelete selftableView deleteRowsAtIndexPaths rowChangeindexPath withRowAnimationUITableViewRowAnimationAutomatic break case YapDatabaseViewChangeInsert selftableView insertRowsAtIndexPaths rowChangenewIndexPath withRowAnimationUITableViewRowAnimationAutomatic break case YapDatabaseViewChangeMove for YapDatabaseViewRowChange c in rowChanges if ctype YapDatabaseViewChangeInsert NSAssert cnewIndexPath isEqualrowChangenewIndexPath Move and insert to same index path selftableView moveRowAtIndexPathrowChangeindexPath toIndexPathrowChangenewIndexPath break case YapDatabaseViewChangeUpdate selftableView reloadRowsAtIndexPaths rowChangeindexPath withRowAnimationUITableViewRowAnimationNone break completionnil NSIntegernumberOfSectionsInTableViewUITableView tableView return selfmappingsnumberOfSections NSIntegertableViewUITableView tableView numberOfRowsInSectionNSIntegersection return selfmappings numberOfItemsInSectionsection NSString tableViewUITableView tableView titleForHeaderInSectionNSIntegersection return selfmappings groupForSectionsection UITableViewCell tableViewUITableView tableView cellForRowAtIndexPathNSIndexPath indexPath UITableViewCell cell tableView dequeueReusableCellWithIdentifiercell block NSDictionary obj nil selfconnection readWithBlock YapDatabaseReadTransaction transaction obj YapDatabaseViewTransaction transaction extview objectAtIndexPathindexPath withMappingsselfmappings celltextLabeltext obj value stringValue return cell voidchangeData selfwriteConnection asyncReadWriteWithBlock YapDatabaseReadWriteTransaction transaction Delete some keys NSArray existingKeys transaction allKeysInCollectioncollection NSUInteger numberOfKeysToDelete RNDexistingKeyscount NSMutableSet keysToDelete NSMutableSet new for int i i numberOfKeysToDelete i keysToDelete addObjectexistingKeys RNDexistingKeyscount transaction removeObjectsForKeyskeysToDeleteallObjects inCollectioncollection Move some objects around NSArray existingKeys transaction allKeysInCollectioncollection NSUInteger numberOfKeysToMove RNDexistingKeyscount for int i i numberOfKeysToMove i NSString key existingKeys RNDexistingKeyscount NSMutableDictionary obj transaction objectForKeykey inCollectioncollection mutableCopy obj section RND obj value RND transaction setObject obj copy forKeykey inCollectioncollection Insert objects so we have between items in total NSUInteger count transaction numberOfKeysInCollectioncollection NSUInteger target MAXRND count for NSUInteger i count i target i transaction setObjectsection RND value RND forKey NSUUID UUID UUIDString inCollectioncollection end 