The current implementation skips this procedure for a given device object when a global symbol is found in the cache This is incorrect There could be other undefined globals that have not been previously encountered further down the list If a symbol is found in the cache it doesnt need to be pinned again but it still need to be defined for the current executable Added special case for the printf buffer symbol already pinned by HCC The bug was exposed by running printf on different GPUs Fixes and hipMemcpy D still requires further refactoring for different input and output combinations I am currently running PIConGPU for AMD GPUs accelerated with HIP and get hipErrorRuntimeOther from hipMallocPitch From the documentation of the error code it sound like the error should never happen on a system What could be a reason for this error By looking into the code I found only possible return codes from I never call hipIpcCloseMemHandle explicit so I am not sure if it is coming from that part of the code I get this error only on a development system with xRadeon VII The system is now on Rocm with HIP but I saw this error also with Rocm I am using HIPclang to compile my application On an other system from CRAY with xMi this error is not shown I am searching for a possible reason and would be happy about any suggestion short trace alloc a buffer with hipMallocPitch there is one other D malloc and a kernel call before hipapi pid tid hipDeviceSynchronize ret hipSuccess ns alloc ew eh ewb ptr pitch hipapi pid tid hipGetLastError hipapi pid tid hipGetLastError ret hipSuccess ns hipapi pid tid hipMallocPitch x fffb bef x fffb beef hipapi pid tid hipMallocPitch ret hipErrorRuntimeOther ns hipapi pid tid hipGetErrorName hipErrorRuntimeOther hipapi pid tid hipGetErrorString hipErrorRuntimeOther hipapi pid tid hipGetErrorName hipErrorRuntimeOther homerwideraworkspacepicongputhirdPartyalpakaincludealpakamembufBufHipRthpp hipMallocPitch memPtr pitchBytes staticcaststdsizetwidthBytes staticcaststdsizetheight returned error hipErrorRuntimeOther hipErrorRuntimeOther Full log hipMallocPitchtxt hipconfig detailssummaryclick to see hipconfig resultsummary p hipconfig HIP version fae cf hipconfig HIPPATH optrocmhip HIPPLATFORM clang Use of uninitialized value CPPCONFIG in print at optrocmhipbinhipconfig line CPPCONFIG Environment Variables PATHoptspackmoduleslinuxubuntu x gcc hwloc ugoji jrv jlidtiqswhidfgffkorpgbinoptspackmoduleslinuxubuntu x gcc cmake saw nehnhdb rgfclqkmtclywsc jvwjbinoptrocmhipbinoptrocmllvmbinoptrocmbinhomerwiderabinhomerwideralocalbinoptspackmoduleslinuxubuntu x gcc environmentmodules yznfzd orfbj ykprx tg dpb ntkrrModulesbinoptspackbinusrlocalsbinusrlocalbinusrsbinusrbinsbinbinusrgamesusrlocalgamesoptrocmopenclbinoptrocmhccbinoptrocmhipbinoptrocmllvmbin HIPCLANGPATHoptrocmllvmbin LDLIBRARYPATHoptspackmoduleslinuxubuntu x gcc hwloc ugoji jrv jlidtiqswhidfgffkorpgliboptrocmliboptspackmoduleslinuxubuntu x gcc boost o jqkacrhkhpmvqhw hjzi ps nczzxliboptspackmoduleslinuxubuntu x gcc zlib nus knzumx ik yl jxtgtsl d xbliboptrocmhiplib HIPTRACEAPI x HIPPLATFORMclang HIPPATHoptrocmhip HIPLAUNCHBLOCKING Linux Kernel Hostname fwk Linux fwk generic Ubuntu SMP Wed Dec UTC x x x GNULinux No LSB modules are available Distributor ID Ubuntu Description Ubuntu LTS Release Codename xenial p details Package selects the correct CMAKEVERSION depending on the type of build If hipifyclang is built along with HIP it uses the HIPVERSION cmake produces a hipversion file when HIP is built extracting the HIPVERSION data from it If hipifyclang is built standalone it uses the LLVM version hipMemcpy D is not supporting positions and therefore behaves different to cudaMemcpy D This avoids to port cuda programs over to HIP The missing implementation is marked as todo This feature should IMO be implemented together with the fix for Test case The example is slicing a x x integer C pointer array the offset is x x and applied directly to the pointer addresses the extent is x x The destination array is initialized with the value and the values in the source array are enumerated include stdioh include hipruntimeh global void Fillint ptr sizet pitch const int numElements forint z z numElements z forint y y numElements y forint x x numElements x int idx z numElements numElements y numElements x intcharptr z numElements pitch y pitch x idx int mainint argc char argv hipPitchedPtr dPtr auto extent makehipExtent sizeofint hipMalloc D dPtr extent int hPtr hipMallocHostvoid hPtr sizeofint forint i i i hPtr i hipLaunchKernelGGLHIPKERNELNAMEFill intdPtrptrdPtrpitch auto srcColumn makehipPitchedPtr chardPtrptr dPtrpitch auto dstColumn makehipPitchedPtr hPtr sizeofint auto copyExtent makehipExtent sizeofint hipMemcpy DParms window window srcArray nullptr window dstArray nullptr window srcPtr srcColumn window srcPos makehipPos sizeofint window dstPtr dstColumn window dstPos makehipPos sizeofint window extent copyExtent window kind hipMemcpyDeviceToHost hipMemcpy D window forint z z z forint y y y forint x x x int idx z y x printfi hPtr idx printf n printf n printf n return hipMemcpy D is working incorrectly When I copy a arrays with different pitch the destination offset is wrong The example is slicing a x x integer C pointer array the offset is x x and applied directly to the pointer addresses the extent is x x The destination array is initialized with the value and the values in the source array are enumerated C include stdioh include hipruntimeh global void Fillint ptr sizet pitch const int numElements forint z z numElements z forint y y numElements y forint x x numElements x int idx z numElements numElements y numElements x intcharptr z numElements pitch y pitch x idx int mainint argc char argv hipPitchedPtr dPtr auto extent makehipExtent sizeofint hipMalloc D dPtr extent int hPtr hipMallocHostvoid hPtr sizeofint forint i i i hPtr i hipLaunchKernelGGLHIPKERNELNAMEFill intdPtrptrdPtrpitch auto srcColumn makehipPitchedPtr chardPtrptr sizeofint dPtrpitch auto dstColumn makehipPitchedPtr hPtr sizeofint auto copyExtent makehipExtent sizeofint hipMemcpy DParms window windowsrcArray nullptr windowdstArray nullptr windowsrcPtr srcColumn windowsrcPos makehipPos windowdstPtr dstColumn windowdstPos makehipPos windowextent copyExtent windowkind hipMemcpyDeviceToHost hipMemcpy D window hipErrort err hipGetLastError if hipSuccess err printferror s n hipGetErrorString err forint z z z forint y y y forint x x x int idx z y x printfi hPtr idx printf n printf n printf n output is but should be The bug is a wrong offset in the destination array is must be C unsigned char dst unsigned chardstPtr i pdstPtrysize dstPitch j dstPitch Should fix and the related internal bug jglaser if you have time to verify it for HOOMD itd be greatly appreciated Dont allow HIPPATH to be propagated to hipconfig when run by CMake to detect the package version as it leads to the wrong version is detected when theres already HIP of some different version installed in the system and HIPPATH points to its location hipconfig tends to return the version of the installed HIP rather than the value defined for the distribution The compiled results report wrong version and spoils the rest of the stack in this case First found during the testing of the ebuild for HIP at and fixed there with clearing HIPPATH just before calling cmake as the first measure But it looks that the proper fix is like in this request I dont know whether this should be a github issue or not but what is the policy on unimplemented CUDA identifiers in HIP Here are a few which Ive encountered warning CUDA identifier is unsupported in HIP cudaMemoryTypeManaged cudaMemAdvise cudaMemAdviseSetAccessedBy cudaCpuDeviceId cudaMemPrefetchAsync cudaStreamPerThread cudaLimitStackSize Are these on the roadmap Also if these do not make it into hipifyclang do they have a natural translation into hip