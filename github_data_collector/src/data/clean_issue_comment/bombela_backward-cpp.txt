See This is useful for binaries using backwardcpp that are built with relative source file paths In such a situation backwardcpp will generally not be able to locate the source files This change allows the user to specify a delimited list of search paths in the following environment variable BACKWARDCXXSOURCEPREFIXES The paths are separated by semicolons on Windows and colons otherwise When the environment variable is set those search paths will be tried first If they do not yield any valid files then backwardcpp will fall back to current behavior Fixes Hi I happens that in some build systemsconfigurations a binary can end up with relative paths to source files in the debug info in the binary This can happen in some cases when building a C program with CMakeNinja and currently this behavior is not easy to workaround in general Then if the program is run in a different directory then backwardcpp will not be able to locate the source files and so the stack trace will not contain snippets I propose allowing the user to specify an optional path prefix that backwardcpp will use when searching for source files using the following algorithm in the SourceFile class If the source file path is absolute just open it asis If the path is relative then first try to open it asis if this fails and if there is a userspecified prefix prepend the prefix to the filename and retry opening the file The prefix could be specified through an environment variable BACKWARDCPPSRCPREFIX how does that sound If it sounds OK then I can submit a PR for it Also open to other suggestions It happens sometimes that otherwise working backward prints Stack trace most recent call last in thread and then it hangs I am not able to reproduce this error reliably to check better Ive only seen it happening after message from memory mallocator to stderr double free or corruption prev double free or corruption out free invalid next size normal thus I am suspecting it might be linked to I dont mind wrongconfusingcorrup stack trace being printed but it troubles me that the program never quits it is a service which gets restarted automatically after abort Would it be possible to eg optionally install POSIX timer when stack is about to be printed which would send SIGKILL or some other so that there is at least core dump for postmortem to the process after a few seconds Should I try a PR in that direction something like adding STACKWALKINGTIMEOUT by default installing the timer just after printheader It would be nice to have an char getbackwardbackend function to display what backend is being used If cxademangle fails here then result is NULL and the buffer is leaked Backwardcpp currently finds the path to the executable by calling readlink procselfexe is a special file that normally acts like a symlink but when the executable it links to has been deleted or replaced calling readlink on it returns the path to the original executable with the string deleted appended which is obviously not a valid path and prevents Backwardcpp from working as a result However in that case directly opening procselfexe still lets you access the original executable file Backwardcpp should be directly opening procselfexe rather than the file it links to in order to function correctly when the executable has been deleted or replaced When cmake detects dwarf library due incorrect initialization of BACKWARDLIBRARIES the interface target BackwardBackward generates an empy INTERFACELINKLIBRARIES which causes all tests to fail at link time Offending line Should be LISTAPPEND BACKWARDLIBRARIES LIBDWARFLIBRARIES Example note missing ldwarf lelf ldl cmake DCMAKEBUILDTYPEDebug DBACKWARDTESTSON G CodeBlocks Unix Makefiles homeProjectsbackwardcpp The CXX compiler identification is GNU Check for working CXX compiler usrbinc Check for working CXX compiler usrbinc works Detecting CXX compiler ABI info Detecting CXX compiler ABI info done Detecting CXX compile features Detecting CXX compile features done Could NOT find libdw missing LIBDWLIBRARY LIBDWINCLUDEDIR Could NOT find libbfd missing LIBBFDLIBRARY LIBBFDINCLUDEDIR Found libdwarf usrlibx linuxgnulibdwarfso Found Backward homeProjectsbackwardcpp Configuring done Generating done Build files have been written to homeProjectsbackwardcppcmakebuilddebug Building CXX object CMakeFilesteststacktracedirteststacktracecppo usrbinc DBACKWARDHASBACKTRACE DBACKWARDHASBACKTRACESYMBOL DBACKWARDHASBFD DBACKWARDHASDW DBACKWARDHASDWARF DBACKWARDHASUNWIND isystem usrincludelibdwarf isystem homeProjectsbackwardcpp Wall Wextra pedanticerrors g g stdgnu o CMakeFilesteststacktracedirteststacktracecppo c homeProjectsbackwardcppteststacktracecpp Linking CXX executable teststacktrace homelocalshareJetBrainsToolboxappsCLionch bincmakelinuxbincmake E cmakelinkscript CMakeFilesteststacktracedirlinktxt verbose usrbinc Wall Wextra pedanticerrors g g rdynamic CMakeFilesteststacktracedirteststacktracecppo o teststacktrace WlrpathhomeProjectsbackwardcppcmakebuilddebug libtestmainso CMakeFilesteststacktracedirteststacktracecppo In function backwardTraceResolverLinuxImplbackwardtraceresolvertaglibdwarfresolvebackwardResolvedTrace homeProjectsbackwardcppbackwardhpp undefined reference to dladdr homeProjectsbackwardcppbackwardhpp undefined reference to dwarflinesrc homeProjectsbackwardcppbackwardhpp undefined reference to dwarfdealloc homeProjectsbackwardcppbackwardhpp undefined reference to dwarflineno Compiled with DBACKWARDHASDW and g Debian deb u Fix the following warnings Woldstylecast Wsignconversion Wswitchdefault In filehandleresetopenfilenameobjectcstr ORDONLY open returns only if we open stdout That means in reset we always creating empty handler in this line explicit handleT val valval emptyfalse ifval empty true and that means when we convert to pointer in operator const dummy const if empty return nullptr return reinterpretcastconst dummyval we always return but since in lines if filehandle return r true code never returns even when open failed Also since filehandle is empty file never closes handle if empty Deleterval But to check this API should be changed Simplest change I can think of is adding lambda to check emptiness explicit handleT val stdfunctionboolT const val isempty valval emptyfalse empty isemptyval void resetT newval stdfunctionboolT const val isempty handle tmpnewval isempty swaptmp filehandleresetopenfilenameobjectcstr ORDONLY int const vreturn v Alternatively template can be specified differently for int Thats not up to me anyway