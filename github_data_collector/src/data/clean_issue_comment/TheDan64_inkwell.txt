TheDan Heres my changes after switching from my own fork of llvmsys to the mainline fork Everything compiles cleanly but naturally there are merge conflicts with master as this branch is a bit behind albeit not by that much It also includes things that arent strictly required for the LLVM update but which I needed so they ended up on this branch Nothing convtroversial I dont think but worth keeping an eye on just in case Im not sure Ill have time to get things caught up with master this week or next but if nobody else gets to it Ill return to it as soon as I can Feel free to take this branch and hack it up as needed though Not sure if this is a bug or not but Im experiencing long compilation times mins when using Inkwell mins doesnt sound like much but it feels like an eternity when developing Im on Windows using a manually compiled Release version of LLVM compiled using Visual Studio LLVM offers a number of intrinsics roughly corresponding to C library functions for instance memcpy and memset From the LLVM reference these intrinsics allow sourcelanguage frontends to pass information about the alignment of the pointer arguments to the code generator providing opportunity for more efficient code generation It would be nice if inkwell provided access to these intrinsics The implementation would probably consist of a few trivial wrappers in the Builder for llvmsys functions How do I link a simple helloworld LLVM module into an executable using LLD Per this documentation for LLVM this is possible from code but I am not sure it is implemented in Inkwell Hi It would be nice to have LLVM bindings exposed in a separate branch That will help me a lot for a project that I want to publish soon quote syn and procmacro should be upgraded to Describe the Bug The icmp instruction returns a boolean value or a vector of boolean values based on comparison of its two integer integer vector pointer or pointer vector operands There doesnt appear to be a builder function that builds comparisons of pointers Im not sure whether IntMathValue permits vectors of pointers though it probably does by accident The same LLVMBuildICmp C API function supports pointers just fine For now Im using something like this Note see comment on buildintcompare regarding return value type pub fn buildpointercompareT PointerMathValue self op IntPredicate lhs T rhs T name str TBaseType as PointerMathTypePtrConvType as IntMathTypeValueType let cstring CStringnewnameexpectConversion to CString failed unexpectedly let value unsafe LLVMBuildICmpselfbuilder opinto lhsasvalueref rhsasvalueref cstringasptr TBaseType as PointerMathTypePtrConvType as IntMathTypeValueTypenewvalue but I feel like thats a bit of a hack there is no equivalent to build pointer compare in LLVM its all just integer comparisons so I didnt put it in a PR Describe the Bug Functions have an asglobalvalue method to cast to a GlobalValue GlobalValues have getthreadlocalmode which gets the current thread local storage mode That property only exists on C llvmGlobalVariable which is a subclass of C llvmGlobalValue C llvmFunction is also a subclass of C llvmGlobalValue so the asglobalvalue method should be there but maybe inkwell should grow a GlobalVariable class to match the safety of the C API To Reproduce testvaluesrs testfunctionvaluetoglobaltopointer demonstrates the bug let fnvalue moduleaddfunctionmyfunc fntype None let fnglobalvalue fnvalueasglobalvalue assertfnglobalvaluegetthreadlocalmodeisnone Heres what happens if you run this test with an assertionsenabled build of LLVM test testvaluestestfunctionvaluetoglobaltopointer Assertion failed isaXVal castTy argument of incompatible type function cast file includellvmSupportCastingh line The cast in question is the cast of a C llvmFunction to a C llvmGlobalVariable and that is indeed an invalid cast LLVM Version please complete the following information LLVM Version releaseassertsexpensive checksasanubsan Inkwell Branch Used master Desktop please complete the following information OS macOS Is your feature request related to a problem Please describe longwusha had a great suggestion we should have code styling preferences Particularly via rustfmt Describe the solution youd like We should use rustfmt to standardize code style Describe possible drawbacks to your solution My ideal configuration for rustfmt uses unstable options but this project is on stable So I do not wish to enforce nightly rustfmt Additional context Stabilization checklist WIP commentwidth formatdoccomments true matcharmblocks false matchblocktrailingcomma true x maxwidth x mergederives true mergeimports true x newlinestyle Unix x usefieldinitshorthand true x usetryshorthand true wrapcomments true Bug description The AnyValue implementation for FunctionValue returns an AnyValueEnumPointerValue variant instead of a AnyValueEnumFunctionValue variant Code to reproduce rust srcmainrs use inkwellcontextContext use inkwellvaluesAnyValue AnyValueEnum fn main let context Contextcreate let module contextcreatemodulefnorptr let fntype contextf typefntype false let functionvalue moduleaddfunctionfnorptr fntype None dbgfunctionvalue dbgfunctionvalueasanyvalueenum dbgAnyValueEnumFunctionValuefunctionvalue Cargotoml dependencies inkwell git branch llvm This produces the following output srcmainrs functionvalue FunctionValue name fnorptr address x fe c isconst true isnull false llvmvalue ndeclare float fnorptr n llvmtype float srcmainrs functionvalueasanyvalueenum PointerValue PointerValue ptrvalue Value name fnorptr address x fe c isconst true isnull false isundef false llvmvalue ndeclare float fnorptr n llvmtype float srcmainrs AnyValueEnumFunctionValuefunctionvalue FunctionValue FunctionValue name fnorptr address x fdf c isconst true isnull false llvmvalue ndeclare float fnorptr n llvmtype float Expected output functionvalueasanyenumvalue should return a AnyValueEnumFunctionValue variant LLVM version Rust version rustc aa c cf Also unrelated why arent methods getname printtostring isnull etc part of the AnyValue trait This forces casting AnyValueEnums into the correct Value type using astypevalue to call any of those methods I imagine that in many cases its possible to know the type of the value but would just require explicit code duplication or manual matching