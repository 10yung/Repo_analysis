gperftools cpu profiler coroutine process cause segmentation fault does cpu profiler conflict with coroutine implemented with assembly instruction Building gperftools with gcc on Ubuntu I get this warning srctcmalloccc warning void tcdeletenothrowvoid const stdnothrowt alias between functions of incompatible types voidvoid const stdnothrowt and voidvoid Wattributealias extern C PERFTOOLSDLLDECL void tcdeletenothrowvoid p const stdnothrowt PERFTOOLSNOTHROW srctcmalloccc note aliased declaration here void tcfreevoid ptr PERFTOOLSNOTHROW And indeed they do seem to be incompatible Probably a tcfreenothrow routine should be introduced and used as the alias it would just call tcfree and ignore the extra argument If that sounds right to you I can whip up a patch SafeLinking is a security mechanism that protects singlelinked lists such as the Free Lists from being tampered by attackers The mechanism makes use of randomness from ASLR mmapbase and when combined with object alignment integrity checks it protects the pointers from being hijacked by an attacker While SafeUnlinking protects doublelinked lists such as the Small Bins in ptmalloc there wasnt any similar protection for attacks against singlelinked lists This solution protects against three common attacks Partial pointer override Modified the lower bytes Little Endian Full pointer override Hijacks the pointer to an attackers location Unaligned objects pointing the list to an unaligned address The design assumes an attacker doesnt know where the heap is located and uses the ASLR randomness to sign the singlelinked pointers We mark the pointer as P and the location in which it is stored as L and the calculation will be PROTECTP L PAGESHIFT XOR P L PROTECTP This way the random bits from the address L which start at the bits in the PAGESHIFT position will be merged with the LSB of the stored protected pointer This protection layer prevents an attacker from modifying the pointer into a controlled value An additional check that the objects are kAligned adds an important layer Attackers cant point to illegal unaligned memory address Attackers must guess correctly the alignment bits Due to kAlignment being an attacker will be directly fail out of times And this could be improved in the future if the alignment will match the class size per Free List This proposed patch was benchmarked and on the worst test case it has an additional overhead of while the overhead for the average test case was a negligible In addition in a similar mitigation was incorporated into Chromiums Free List FL implementation in their version of TCMalloc branched out from gperftools According to Chromiums documentation the added overhead was less than For more information feel free to read our full whitepaper attached SafeLinkingWhitePapertxt My program overrides the newdelete operators and forwards them to mallocfree after some additional bookkeeping This works fine with jemalloc however because TCMalloc calles new as part of its initialization this causes a recursive loop My analysis of the code shows this could be resolved with static object instead of one dynamically allocated My questions are Is there some special method that already exists to solve this use case Ive seen issues in the past about overriding newdelete so my understanding is this use case is supported Would a PR changing these dynamic allocations in the initialization path to static objects be accepted My process had a deadlock between thread and thread connectoracle shlib dlopen dlclose locks dlloadwritelock in glibc free locks pageheaplock thread malloc locks pageheaplock GetStackTrace GIdliteratephdr locks dlloadwritelock in glibc glibc does locking and calls tcmalloc while tcmalloc also does locking and calls glibs this is clearly a risky design Detail Thread is trying to get a lock in a free tcmallocThreadCacheIncreaseCacheLimit this x a c at srcthreadcachecc void ThreadCacheIncreaseCacheLimit SpinLockHolder hStaticpageheaplock IncreaseCacheLimitLocked This is called from glibc dlclosec called from dlopen to load a shlib x ffff df b in dlcloseworker mapoptimized out at dlclosec x ffff deebbd in dlopen file x ffffffe b cmlocalbuildoptoracleproduct liblibnque so modeoptimized out callerdlopenoptimized out nsidoptimized out argc argv x fffffff env x fffffff at dlopenc But on frame we can see that dlcloseworker locked mutex dlloadwritelock free imap rtldlockunlockrecursive GLdlloadwritelock All this called from the main process connecting to oracle complete trace x cc b in sysfutex v a x t x ffffffe b v o a x bc tcmallocStaticpageheaplock at srcbaselinuxsyscallsupporth baseinternalSpinLockDelay wwentry x bc tcmallocStaticpageheaplock value looploopentry at srcbasespinlocklinuxinlh x cc f in SpinLockSlowLock thisthisentry x bc tcmallocStaticpageheaplock at srcbasespinlockcc x cb in SpinLockLock thisoptimized out at srcbasespinlockh SpinLockHolderSpinLockHolder loptimized out thissynthetic pointer at srcbasespinlockh tcmallocThreadCacheIncreaseCacheLimit this x a c at srcthreadcachecc x cb in tcmallocThreadCacheScavenge thisoptimized out at srcthreadcachecc x ffff df b in dlcloseworker mapoptimized out at dlclosec x ffff deebbd in dlopen file x ffffffe b cmlocalbuildoptoracleproduct liblibnque so modeoptimized out callerdlopenoptimized out nsidoptimized out argc argv x fffffff env x fffffff at dlopenc x ffff ffab in dlopendoit aaentry x ffffffe at dlopenc x ffff dea a in dlcatcherror objname x errstring x mallocedp x operate x ffff ff dlopendoit args x ffffffe at dlerrorc x ffff a ad in dlerrorrun operateoperateentry x ffff ff dlopendoit argsargsentry x ffffffe at dlerrorc x ffff a in dlopen fileoptimized out modeoptimized out at dlopenc x e in snldlldl x bbe in ntevgblini x e d in ntgblini x ef in nsgblini x in niotns x ca in osncon x fccd in kpuadef x dee in upiini x e c in kpuatch x ee b in OCIServerAttach The other thread is trying to lock the same mutex in glibc to read dwarf info x ffff aa ef in GIdliteratephdr callbackcallbackentry x dcf ULx dwarfcallback datadataentry x ffff e f at dliteratephdrc Make sure nobody modifies the list of loaded objects rtldlocklockrecursive GLdlloadwritelock x dd be in ULx dwarffindprocinfo as x localaddrspace ipipentry pipientry x ffff e a needunwindinfoneedunwindinfoentry arg x ffff e at dwarfGfindprocinfolsbc x dd e in fetchprocinfo ccentry x ffff e ip needunwindinfoneedunwindinfoentry at dwarfGparserc This unwind is called from GetStackTrace which could have been avoided by scopeIsStacktraceAllowed x ccf in GetStackTrace resultresultentry x a maxdepthmaxdepthentry skipcountskipcountentry at srcstacktracecc PERFTOOLSDLLDECL ivoid result int maxdepth int skipcount StacktraceScope scope if scopeIsStacktraceAllowed return initdefaultstackimplinner return frameforcergetstackimplGetStackTracePtrresult maxdepth skipcount but this is called from tcmalloc doing a malloc which needs to get more memory after grabbing the same pageheaplock spinlock x c a in tcmallocCentralFreeListPopulate thisthisentry x b tcmallocStaticcentralcache at srccentralfreelistcc Span span SpinLockHolder hStaticpageheaplock span StaticpageheapNewnpages All this called from thread calling malloc complete trace llllockwait at nptlsysdepsunixsysvlinuxx lowlevellockS x ffff eb in Llock from lib libpthreadso x ffff daf in GIpthreadmutexlock mutex x ffff ffd rtldlocal at nptlpthreadmutexlockc x ffff aa ef in GIdliteratephdr callbackcallbackentry x dcf ULx dwarfcallback datadataentry x ffff e f at dliteratephdrc x dd be in ULx dwarffindprocinfo as x localaddrspace ipipentry pipientry x ffff e a needunwindinfoneedunwindinfoentry arg x ffff e at dwarfGfindprocinfolsbc x dd e in fetchprocinfo ccentry x ffff e ip needunwindinfoneedunwindinfoentry at dwarfGparserc x dec in ULx dwarffindsavelocs ccentry x ffff e at dwarfGparserc x dc in ULx dwarfstep ccentry x ffff e at dwarfGstepc x dc in ULx step cursor x ffff e at x Gstepc x cc bb in GetStackTracelibunwind resultoptimized out maxdepth skipcountoptimized out at srcstacktracelibunwindinlh x ccf in GetStackTrace resultresultentry x a maxdepthmaxdepthentry skipcountskipcountentry at srcstacktracecc x c e e in tcmallocRecordGrowth growth at srcpageheapcc tcmallocPageHeapGrowHeap thisthisentry x fde tcmallocStaticpageheap nnentry at srcpageheapcc x c d in tcmallocPageHeapNew this x fde tcmallocStaticpageheap nnentry at srcpageheapcc x c a in tcmallocCentralFreeListPopulate thisthisentry x b tcmallocStaticcentralcache at srccentralfreelistcc x c a in tcmallocCentralFreeListFetchFromOneSpansSafe thisthisentry x b tcmallocStaticcentralcache NNentry startstartentry x ffff e end x ffff e at srccentralfreelistcc x c a in tcmallocCentralFreeListRemoveRange this x b tcmallocStaticcentralcache startstartentry x ffff e endendentry x ffff e N at srccentralfreelistcc x cb da in tcmallocThreadCacheFetchFromCentralCache this x a d cloptimized out bytesize oomhandler x b tcmallocmallocoomunsigned long at srcthreadcachecc x ef in gnatmalloc Technology used Linux kernel el x glibccommon el x gperftools libunwind oracle OCI gcc GCC for GNAT Pro tcmalloc was built using CCusrbingcc m configure prefixPREFIX execprefixPREFIX CXXFLAGSm ggdb O CPPFLAGSm ggdb O CFLAGSm ggdb O withtcmallocpagesize withtcmallocalignment targetx unknownlinuxgnu make j make j check make install so we do not use what is documented in configure as risky enablestacktraceviabacktrace enable use of backtrace for stacktrace capturing may deadlock As usual such deadlocks are very rare and I have not yet found a way to reproduce the problem This seems a hairy issue so ideally would like some info how to build tcmalloc without this stack trace if IsStacktraceAllowed would have returned false there would have been no such risk but I dont see a configure option disablestacktrace PS Avoiding shared libs would also have avoided this particular risk for deadlock but both Oracle and RedHat support are unhelpful to get this implemented so that is no option in the near future I complied gpreftools by mingw i releaseposixdwarfrtv rev when run test I got Unable to patch because function is too short code is preamblepatcherwithstubcc line else if ITRETURN instructiontype SIDESTEPASSERTfalse Unable to patch because function is too short return SIDESTEPFUNCTIONTOOSMALL my app is using tcmalloc it significantly boosted the performance of our app thanks Im trying to use openvino library MLKDNNplugindll that is causing the issue is a part of openvino is using xbyak library where the issue actually occurs xbyak library uses a combination of alignedmalloc and VirtualProtect to allocate an aligned memory and set it to RWE mode After several successful allocations it is always a pair of alignedmalloc and VirtualProtect VirtualProtect fails with ERRORINVALIDADDRESS error code x E Attempt to access invalid address both disabling tcmalloc and replacing alignedmalloc with VirtualAlloc resolve the issue Is there a proper way to resolve the issue Is there a way to prevent tcmalloc from handling alignedmalloc Windows x visual C release x Im having the exact same problem in My program is built with the flags below clang stdc g O includes cpp files o cpphmisshmiss usrlocalCellargperftools liblibprofilerdylib Im enabling and running CPU profiling with the following line DYLDFALLBACKLIBRARYPATHoptlocallib CPUPROFILEhmissprof hmiss After running the profiling I run pprof and get the following output s ca pprof text hmiss hmissprof Using local file hmiss Using local file hmissprof Total samples x c ad x c a x c a x c a x c a a x fff f da NC enddef NC inqvarfill mhexecuteheader exleavedef exputblock exputblockparam exputblockparams ncenddef nciomove posixioopen Weirdly Im getting function names for linked libraries just not my program Ive seen people include the lprofiler flag in the build process but it doesnt change anything for me Is there something else I need to do here to get the function names in the profiling data Thanks for any help Max diff wcr UsersbartoDownloadsgperftoolsmastersrcteststcmallocunittestcc srcteststcmallocunittestcc UsersbartoDownloadsgperftoolsmastersrcteststcmallocunittestcc Mon Apr srcteststcmallocunittestcc Mon Nov delete p VerifyDeleteHookWasCalled p new char CHECKp NULL VerifyNewHookWasCalled delete p VerifyDeleteHookWasCalled p newstdnothrow char delete p VerifyDeleteHookWasCalled char p new char CHECKp NULL VerifyNewHookWasCalled delete p VerifyDeleteHookWasCalled p newstdnothrow char delete p VerifyDeleteHookWasCalled p newstdnothrow char CHECKp NULL VerifyNewHookWasCalled delete p VerifyDeleteHookWasCalled Another way of calling operator new delete p VerifyDeleteHookWasCalled p newstdnothrow char CHECKp NULL VerifyNewHookWasCalled delete p VerifyDeleteHookWasCalled Another way of calling operator new operator deletep sizeofchar VerifyDeleteHookWasCalled p new char CHECKp NULL VerifyNewHookWasCalled operator delete p sizeofchar VerifyDeleteHookWasCalled endif operator deletep sizeofchar VerifyDeleteHookWasCalled p new char CHECKp NULL VerifyNewHookWasCalled operator delete p sizeofchar VerifyDeleteHookWasCalled endif delete poveraligned VerifyDeleteHookWasCalled poveraligned new overalignedtype CHECKpoveraligned NULL CHECKsizetpoveraligned OVERALIGNMENT u VerifyNewHookWasCalled delete poveraligned VerifyDeleteHookWasCalled poveraligned newstdnothrow overalignedtype delete poveraligned VerifyDeleteHookWasCalled overalignedtype poveraligned new overalignedtype CHECKpoveraligned NULL CHECKsizetpoveraligned OVERALIGNMENT u VerifyNewHookWasCalled delete poveraligned VerifyDeleteHookWasCalled poveraligned newstdnothrow overalignedtype delete poveraligned VerifyDeleteHookWasCalled poveraligned newstdnothrow overalignedtype CHECKpoveraligned NULL CHECKsizetpoveraligned OVERALIGNMENT u VerifyNewHookWasCalled delete poveraligned VerifyDeleteHookWasCalled Another way of calling operator new delete poveraligned VerifyDeleteHookWasCalled poveraligned newstdnothrow overalignedtype CHECKpoveraligned NULL CHECKsizetpoveraligned OVERALIGNMENT u VerifyNewHookWasCalled delete poveraligned VerifyDeleteHookWasCalled Another way of calling operator new UsersbartoDownloadsgperftoolsmastersrcbasebasictypesh Mon Apr srcbasebasictypesh Mon Nov public AssignAttributeStartEndconst char name char pstart char pend Find out what dynamic library name is defined in if dyldpresent for int i dyldimagecount i i const machheader hdr dyldgetimageheaderi ifdef MHMAGIC public AssignAttributeStartEndconst char name char pstart char pend Find out what dynamic library name is defined in if definedAPPLE if dyldpresent endif for int i dyldimagecount i i const machheader hdr dyldgetimageheaderi ifdef MHMAGIC UsersbartoDownloadsgperftoolsmastersrcbasesysinfocc Mon Apr srcbasesysinfocc Mon Nov ifdef HAVESYSSYSCALLH include syssyscallh endif ifdef SYSopen solaris at least sometimes only defines SYSopenat define safeopenfilename mode syscallSYSopen filename mode else define safeopenfilename mode openfilename mode endif ifdef SYSread define safereadfd buffer size syscallSYSread fd buffer size else define safereadfd buffer size readfd buffer size endif ifdef SYSclose define safeclosefd syscallSYSclose fd else define safeclosefd closefd ifdef HAVESYSSYSCALLH include syssyscallh endif if definedSYSopen definedAPPLE solaris at least sometimes only defines SYSopenat define safeopenfilename mode syscallSYSopen filename mode else define safeopenfilename mode openfilename mode endif if definedSYSread definedAPPLE define safereadfd buffer size syscallSYSread fd buffer size else define safereadfd buffer size readfd buffer size endif if definedSYSclose definedAPPLE define safeclosefd syscallSYSclose fd else define safeclosefd closefd return result if definedAPPLE static char CopyStringUntilChar char text unsigned outlen int c char out char endptr SkipWhileWhitespace endptr c return endptr endif templatetypename T static bool StringToIntegerUntilCharWithCheck return true if definedAPPLE static bool ParseProcMapsLinechar text uint start uint end char flags uint offset int major int minor int inode return false endif endif ProcMapsIteratorProcMapsIteratorpidt pid Initpid NULL false diff wcr UsersbartoDownloadsgperftoolsmastersrcbasesysinfoh srcbasesysinfoh UsersbartoDownloadsgperftoolsmastersrcbasesysinfoh Mon Apr srcbasesysinfoh Mon Nov int fd filehandle on procmaps endif pidt pid if definedAPPLE char flags endif Buffer dynamicbuffer dynamicallyallocated Buffer bool usingmapsbacking true if we are looking at mapsbacking instead of maps 