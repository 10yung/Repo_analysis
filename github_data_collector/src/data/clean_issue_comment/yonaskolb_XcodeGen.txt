Solved Resolves sources path examplemp resourceTags example movie If the file exists directly under Foo and Foo is specified in the sources need to use excluded sources path Foo excludes examplemp path Fooexamplemp resourceTags example movie Is there way to setting ondemandresource tags img width alt src Hey I seem to have ran into a bug with the SwiftPM package integration for static libraries When a static library depends on an SDK eg Foundation UIKit all SwiftPM packages will also be linked into it Adding other types of dependencies doesn t seem to have any impact It seems like it s only when a static library depends on both a SwiftPM package and an SDK that the issue occurs In my case it caused just over duplicate symbol errors As both my app and static library target linked with Alamofire from SwiftPM I was able to reproduce with latest master See an example sing this small modification of the SPM test fixture yaml name SPM packages Codability url majorVersion localPackages XcodeGen itself targets App type application platform iOS sources SPM scheme dependencies package Codability target StaticLibrary StaticLibrary type librarystatic platform iOS sources StaticLibrary dependencies package Codability sdk UIKitframework the addition Screenshot Screenshot of Xcode with the incorrect linkage of the SwiftPM package I have a use case where I want my unit test targets to not set their TESTHOST automatically to a product target that is a dependency to the test target and if possible set it to None Would it be a good idea to maybe creating an optional spec configuration to set the TESTHOST manually to a specific targetnone if present and bypass the automatic one Xcodegen version Hey Im trying to migrate our iOS project that uses Xcodegen to start using a SwiftPM library we use internally As part of doing this I am specifying in my projectyml the SwiftPM dependency to use However in trying to attempt this I run into the following problem that is fundamentally at odds with Xcodegen From this article I understand that the Packageresolved fileused for making sure all developers are using the same version of packages is stored in the xcodeproj directory Heres the relevant quote You can find the Packageresolved file inside your xcodeproj directory at appName xcodeprojprojectworkspacexcshareddataswiftpmPackageresolved However the premise of using Xcodegen is that the repository is able to discard the xcodeproj folder and related artefacts So the Packageresolved file can also not be checked in How then do developers of a repository get deterministically same versions of their dependencies I may be missing something here Ive been able to use XcodeGen to create a today extension but when I create another target with appextensionintentsservice the infoplist fails to generate and the extension is not recognized as an intents extension Here is what my target looks like and ive embedded this into the container app as follows targets ExtensionIntents type appextensionintentsservice deploymentTarget platform iOS templates ExtensionIntentsTemplate settings base PRODUCTBUNDLEIDENTIFIER coprojectIntents INFOPLISTFILE InfoExtensionsExtensionIntentsInfoplist sources path Intents Main App MainApp dependencies target IntentsExtension embed true codeSign false buildPhase copyFiles destination plugins And yes an infoplist does exist at that path When I create the intents target manually through xcode everything looks good but for my use case this extension needs to be regenerated every time Motivation I want to sort files sort by type as we can with Xcode Description I added code to sort by type before sorting by name We should consider adding as optional Do you have any ideas Using the current TestProject I am unable to install and run the watchOS app scheme The error message is Could not install at this time No WatchKit app bundle found for app comprojectappwatchextension XCode Version B Latest version of XcodeGen moved from Implementation status x Write Project to a yaml file Generate Project from XcodeProj roughly done some project settings are not treated yet Remove default values from yaml Change to proper command names and CLI improvements Fix to find C header files appropriate way About the last item As far as I know C header files are not added to the build phase on the application target so we have to find them from the group Currently I am adding all header files in the group as sources but if the group doesnt match the target it will cause problems