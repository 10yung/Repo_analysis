In this example class User name string createdAt Date const user name John createdAt consolelogplainToClassUser usercreatedAtgetTime getTime is not a function of createdAt even if createdAt is a Date This example works consolelognew Date getTime prints the time Feature Request When I use Type Number and pass a string parameter x its transformed to I expect to receive NaN by default because this is not decimal but receive It would be great to add an extra optional parameter for example transformNumberFromNonDecimal to transform explicitly by default it should be false Because in most cases you dont need to handle non decimal value ts class LoveB IsString readonly name string null class LoveA Type LoveB love Mapstring LoveB new Map ts ittransform const test JSONparselove feature name feature name const transformedObject plainToClassLoveA test expecttesttoBeInstanceOfLoveA Ok in browser and NodeJS expecttestlovetoBeInstanceOfMap Ok in Node fails in browser expecttesttoBeInstanceOfLoveB Ok in browser fails in NodeJS typescript import reflectmetadata import Expose plainToClass Type from classtransformer export class Skill Expose name string export class Weapon Expose name string Expose range number export class Player name string Expose Type Skill skills SetSkill Expose Type Weapon weapons Mapstring Weapon const v name name skills new Set name skill remove name skill remove weapons new Map w name weapon range remove w name weapon range remove consolelog plainToClassPlayer v excludeExtraneousValues true Output javascript Player skills Skill name skill Skill name skill weapons Map name undefined range undefined Expected output javascript Player skills Skill name skill Skill name skill weapons Map w Weapon name weapon range w Weapon name weapon range set to null original JSON json id a xxxxx ts class UserModel Exposei id number Expose name a avatar string Expose name a get avatarUrl return thisavatar I walk through all the code I found it uses Map structure to store originKeynewKey and the key was unique Hi this is now quite an important library to our project so it is worrying to see that no commits are being made no PRs are getting merged everythings waiting for a review Is this alive Could be new reviewers promoted so stuff can get merged AFAIK there is no other major TS library which fully do what classtransformerclassvalidator are capable of so it would be very sad to see this repo wither Tell me if Im wrong Id be happy to have a look at the others and be calmer knowing there is a fallback Cheers Hi there thanks for the lib I have the following use case and wondering if there is a workaroundfix for the issue Im facing Ive made an isolated data fetching logic module and put it into a separate npm package to reuse across my projects classtransformer is its dependency and there is a method like below in the package getDataFromApiMyModelType The idea was that the data will be converted into MyModelType automatically when its returned from the api Its working fine for the top level object However it doesnt transform the nested objects even though I set Type annotation The transformation is working fine if I move the transforming logic from the npm package back to my app basically I just call plainToClassclazz data where clazz is MyModelType in this case Im wondering what might cause the problem and if there is any way to overcome it If I can provide any additional info to better cover the use case please let me know Imagine we have a property or set of properties that appears consistently in different classes here Im using both classtransform and classvalidate decorators typescript IsOptional Transformvalue any value true value true value value propertyA boolean Is there any way to avoid having to write each time propertyA and its decorators in all the different transformation classes Our usecase is that we use classtransformer and classvalidator to transform JSON inputs of a NestJS API and most of the endpoints reuse similar structures of query objects so instead of writing times the same parameter we could somehow extend inhert it However this happens with multiple groups of parameters so we need to inhert from multiple classes at the same time which is a mixin pattern no Ive been checking on using a mixin but it seems its not possible as mixins in TypeScript do not accept decorators inside of them typescript class ClassB IsOptional propertyB boolean type ConstructorT new args any T function AddPropATBase extends ConstructorBase TBase return class extends Base IsOptional Transformvalue any value true value true value value propertyA boolean constructorargs any superargs Maybe we can se the transformationvalidation here without a decorator const ClassBWithPropA AddPropAClassB Is there any way to attach a Transform decorator without using the decorator after defining the class Or at least to write the metadata that the Transform decorator writes without using the decorator