I use refreshInterval to implement the Interval polling But Id know how to cancel it when its running This attempts to resolve Implementation Notes I created a CacheInterface and make the global config create a default instance of the cache also exported both the interface and the Cache class I also updated useSWR to read from the cache instance received through the context object I was not able yet to find a way to make mutate and trigger read from the correct cache instance because they are global my only idea so far was to pass the cache instance as a third argument probably optional but that could make it hard to test components using a custom cache for tests and a default cache for the mutate call Missing things useSWRPages is still using global cache I havent tried yet to use it here but I believe is the same as mutate and trigger mutate is still using global cache trigger is still using global cache Any feedback is welcomed as described will add a demo asap A bit of context we introduced swr two weeks ago to our codebase Everything is working fine but we started to get some reports about some parts of the app being broken in slightly older browsers Chrome Firefox Edge etc We found out that swr was causing a syntax error in these browsers because webpack by default picked the ESM build rightly so but because its not transpiled it ended in the bundle without going through our babel config Which broken these older browsers So Id like to add a not in README file about the ESM build webpack what do you think Using Graphql with SWR via the graphqlrequest library and it appears that Im not getting updates when I call mutate with my mutated data Ive stored my graphql query as a constant and pass it both to useSWR and mutate and Ive validated the data structure Im passing into mutate Alternatively mutating works as expected when I use REST API endpoints via traditional HTTPfetch calls Is SWRmutate capable of working with graphql strings as keys Is that the issue For example say I have two components A and B A uses messagesbefore after B uses messagesstarredtrue Lets say the user stars a message with id message from in component B and we issue a POST to star the message If we just called mutatemessagesstarredtrue otherMessages message isstarred true B would be uptodate and show the starred message but A wouldnt Would you recommend keeping a mapping from object id to URLs that we could use to call mutate with all the URLs In the example above the map would be message messagesbefore after messagesstarredtrue Or is there something else that would be better And a big thank you for all your work on this awesome project Hi there were currently using useSWR but we have found conditional revalidation a bit limiting For example we have some occurences where we want to trigger revalidation only after a certain action is being taken could be a button click With current conditional revalidation techniques we are forced to use an additional state just to prevent first validation on mount This PR aims to add a simple autoLoad or whatever other name flag in the options so that automatic revalidation on mount can be prevented and we can simply trigger it directly in a callback for example a button onClick Best Gabriele From version the isValidating flag doesnt seem to change anymore it just stays at false even when there is a request going on Has the API of it changed after Do I need to read it differently or something Is it because I have wrapped useSWR in my own hook js export default function useRequestrequest initialData config const data response returned useSWR request JSONstringifyrequest axiosrequest config initialData initialData status statusText InitialData headers data initialData return returned data response responsedata response Is there something in the way I get and pass on the returned values from useSWR here which is causing the isValidating flag not to change If so how would you suggest I do it instead Adding the following where I use my hook just results in a single log message of undefined js useEffect consolelogisValidating isValidating This addresses where passing initialData when theres an error in the cache will still return the error Im not sure if this is the correct way to fix this as it means the cache and state would be out of sync but maybe thats ok It did pass all tests 