 brew tap isenngdotnetsdkversions brew cask install dotnetsdk brew cask install monomdk I suggest adding a editorconfig file to the project to unify the coding style A good baseline would be to simply copy the editorconfig that is used by Microsoft for NET Core development to keep things similar Fixes Proposed Changes This PR fixes some ThreadingAsync issues by utilizing Tasks and the ThreadPool instead of dedicated threads This should result in better better core utilization and gets rid of the overhead of creating separate threads It also replaces AutoResetEvent and TaskCompletionSource objects with SemaphoreSlim to fix a possible racecondition that could trigger a deadlock These changes work with the x branch but should ideally also be pushed out to x as well to fix the race conditiondeadlock issue Types of Changes X Bug fix nonbreaking change which fixes a possible deadlock issue Checklist X I have read the CONTRIBUTINGmd document X I have signed the CA see X All tests pass locally with my changes X I have added tests that prove my fix is effective or that my feature works I have added necessary documentation if appropriate Any dependent changes have been merged and published in related repositories Further Comments Have run all tests locally and below is a program that triggers said deadlock in the current version of the client Important Moving background work to Tasks ThreadPool might impact those that create a lot more connections than their have corecount on their machines not recommended btw In those cases the ThreadPool slowly increments the minimum number of Threads that can run at a time from the ThreadPool affects one of the tests that creates hundreds of connections In those cases customers might want to call SystemThreadingThreadPoolSetMinThreads if they want all those connections to become immediately active otherwise they slowly ramp up as the ThreadPool sees more work to do This is well documented here Code to reproduce deadlock csharp using RabbitMQClient using RabbitMQClientEvents using System using SystemThreading using SystemThreadingTasks namespace DeadlockRabbitMQ class Program private static int messagesSent private static int messagesReceived private static int batchesToSend private static int itemsPerBatch static async Task Mainstring args ThreadPoolSetMinThreads EnvironmentProcessorCount EnvironmentProcessorCount var connectionString new Uriamqpguestguestlocalhost var connectionFactory new ConnectionFactory DispatchConsumersAsync true Uri connectionString var connection connectionFactoryCreateConnection var connection connectionFactoryCreateConnection var publisher connectionCreateModel var subscriber connection CreateModel publisherConfirmSelect subscriberConfirmSelect publisherExchangeDeclaretest ExchangeTypeTopic true subscriberQueueDeclaretestqueue true false true var asyncListener new AsyncEventingBasicConsumersubscriber ConsumerTag testconsumer asyncListenerReceived AsyncListenerReceived subscriberQueueBindtestqueue test myawesomeroutingkey subscriberBasicConsumetestqueue false asyncListenerConsumerTag asyncListener var batchPublish TaskRun while messagesSent batchesToSend itemsPerBatch var batch publisherCreateBasicPublishBatch for int i i itemsPerBatch i var properties publisherCreateBasicProperties propertiesAppId testapp propertiesCorrelationId GuidNewGuidToString batchAddtest myawesomeroutingkey true properties BitConverterGetBytesi messagesSent batchPublish publisherWaitForConfirmsOrDie messagesSent itemsPerBatch while messagesReceived batchesToSend itemsPerBatch ConsoleWriteLineMessages received messagesReceived await TaskDelay await batchPublish ConsoleWriteLineDone receiving all messages ConsoleReadLine subscriberDispose publisherDispose connectionDispose connection Dispose private static async Task AsyncListenerReceivedobject sender BasicDeliverEventArgs event Doing things in parallel here is what will eventually trigger the deadlock probably due to a race condition in AsyncConsumerWorkServiceLoop although Ive had trouble pinpointing it exactly but due to how the code in there uses a TaskCompletionSource and elsewhere overrides it it might cause Enqueue and Loop to eventually be working with different references or thats at least the current theory Moving to better synchronization constructs solves the issue and using the ThreadPool is standard practice as well to maximize core utilization and reduce overhead of Thread creation await TaskWhenAllIncrementCounterAsTask WriteToConsoleeventBasicPropertiesCorrelationId eventBodyAsTask sender as AsyncEventingBasicConsumerModelBasicAckeventDeliveryTag false private static ValueTask IncrementCounter InterlockedIncrementref messagesReceived return new ValueTask private static ValueTask WriteToConsolestring correlationId byte body ConsoleWriteLineReceived event correlationId with value BitConverterToInt body return new ValueTask bording approved We recently ran into an issue where part of our solution crashed after An unhandled exception terminated the CLR This was due to us trying to Serialize the AlreadyClosedException We generally treat all Exceptions as Serializable since the Exception type implements ISerializable and the CA code analysis recommends all custom Exceptions implement constructors the last of which is a Serialization constructor Feature request Support connectionupdatesecret in RabbitMQClient Background The AMQP reference guide at defines a method connectionupdatesecret This method is intended to be used with authorization plugins like rabbitmqauthbackendoauth This plugin allows establishing a connection with a token rather than a password Such tokens usually have an expiry timestamp and connections become unusable after this point Using the method connectionupdatesecret it is possible to supply a new token that has not yet expired without having to reestablish the connection It would also allow updating permissions at this point The plugin ships with RabbitMQ and therefore it makes sense to support it within RabbitMQClient Without this feature we can not make use of this plugin Proposed Changes As requested in this test demonstrates the issue where the consumer tag in the ConsumerCancelled event is not as expected Types of Changes Bug fix nonbreaking change which fixes issue NNNN New feature nonbreaking change which adds functionality Breaking change fix or feature that would cause an observable behavior change in existing systems Documentation improvements corrections new content etc Cosmetic change whitespace formatting etc Checklist x I have read the CONTRIBUTINGmd document I have signed the CA see x All tests pass locally with my changes x I have added tests that prove my fix is effective or that my feature works x I have added necessary documentation if appropriate x Any dependent changes have been merged and published in related repositories Ive run into an issue where an exception happens after recovery which causes the connection to be closed and no attempt to recover As far as I can tell from logs this is whats happening RecoverySucceeded event raised ModelShutdown event raised with close reason NOTALLOWED Connection is closed but ConnectionShutdown event is not raised From a quick look over the code it seems like the problem is here There is already a close reason set but there is another exception happening Here is the full exception taken from mshutdownReport Unable to read data from the transport connection An existing connection was forcibly closed by the remote host at RabbitMQClientImplInboundFrameReadFromNetworkBinaryReader reader at RabbitMQClientFramingImplConnectionMainLoopIteration at RabbitMQClientFramingImplConnectionClosingLoop Problem Creating a new channel in an asynchronous consumer creates new channel on server but throws timeout exception on client Details I tried to make a pipeline from multiple queues and ran into a problem that a basic consumer is working but an asynchronous one is constantly falling with a timeout It turned out to understand that the problem is in creating a new channel using same connection inside async consumer callback it hangs when creating But if you create a channel before the start consuming and pass inside consumer using closure it works How to reproduce Send some message to queue when in queue async consumer try to create new channel or try lazy initializationlazy cache need connectionCreateModel call and when send using created channel to somewhere else Example Client version pre Server version Exception stack trace csharp SystemTimeoutException The operation has timed out at RabbitMQUtilBlockingCell WaitForValueTimeSpan timeout at RabbitMQClientImplSimpleBlockingRpcContinuationGetReplyTimeSpan timeout at RabbitMQClientImplModelBaseModelRpcMethodBase method ContentHeaderBase header Byte body at RabbitMQClientFramingImplModelPrivateChannelOpenString outOfBand at RabbitMQClientFramingImplAutorecoveringConnectionCreateNonRecoveringModel at RabbitMQClientFramingImplAutorecoveringConnectionCreateModel at PhemaRabbitMQRawClientProgramcDisplayClass Mainb dMoveNext in C Users Sergey GitHub Phema PhemaRabbitMQ examples PhemaRabbitMQRawClie nt Programcsline 