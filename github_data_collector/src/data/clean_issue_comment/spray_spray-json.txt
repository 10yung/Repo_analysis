Ive been trying for hours to get some code to compile and about to give up on sprayjson as Im having no luck Im trying to get rid of the error Error Cannot find JsonWriter or JsonFormat type class for comintertrustmodulusservicesauditEvent val result etoJson Ive used sprayjson for years and am always confounded by errors such as this and seek some methodology for debugging these and isolating WHY I get these occasionally when Im pretty certain that I have implicit json formatters inscope for all the case classes that extend the base trait here Event When the hierarchy is trait Event extends Product with Serializable sealed trait AccountEvent extends Event case class AccountAddedname String password String extends AccountEvent case class AccountDeletedname String extends AccountEvent case class AccountPasswordChangedname String password String extends AccountEvent sealed trait FooEvent extends Event case class FooEvent extends FooEvent The compiler should be able to find that the ONLY types that extend Event are those case classes since the trait from which they derive is sealed So why cant it find the implicit jsonFormatter I have defined in a trait that is extended by the class in which the error is occurring parser changes implicit definition changes parser improvements String parsing dominates parsing times so far for real world input that isnt particularly number heavy So heres a first attempt to improve performance The speedups mostly come from no explicit bounds checking removing tricks some code reorganization Before GithubIssuesJsonASTreadCirce githubakkaissuesjson opss GithubIssuesJsonASTreadCirce bigstringarrayjson opss GithubIssuesJsonASTreadPlayJson githubakkaissuesjson opss GithubIssuesJsonASTreadPlayJson bigstringarrayjson opss GithubIssuesJsonASTreadSprayJsonFromBytes githubakkaissuesjson opss GithubIssuesJsonASTreadSprayJsonFromBytes bigstringarrayjson opss GithubIssuesJsonASTreadSprayJsonFromString githubakkaissuesjson opss GithubIssuesJsonASTreadSprayJsonFromString bigstringarrayjson opss GithubIssuesCaseClassReadingreadCircePartial opss GithubIssuesCaseClassReadingreadJacksonPartial opss GithubIssuesCaseClassReadingreadPlayJsonPartial opss GithubIssuesCaseClassReadingreadSprayJsonViaASTPartial opss After GithubIssuesJsonASTreadSprayJsonFromBytes githubakkaissuesjson opss GithubIssuesJsonASTreadSprayJsonFromBytes bigstringarrayjson opss GithubIssuesJsonASTreadSprayJsonFromString githubakkaissuesjson opss GithubIssuesJsonASTreadSprayJsonFromString bigstringarrayjson opss GithubIssuesCaseClassReadingreadSprayJsonViaASTPartial opss Ie about x x faster for byte input So string parsing has been improved by x which leads to a x improvement for the test case k json from github API As ParserInput needs to be changed the change wont be simply binary compatible Ill probably deprecate the current parser infrastructure and duplicate it by simpler entrypoints that dont leak so many implementation details for common cases This PR adds an instance of JsonFormat UUID as requested in Im not sure as to where to place this object currently BasicFormats is my best guess but feel free to request any changes Closes To keep it compatible we just remove the implicit marker for now and provide implicit forwarders in traits that are mixed into JsonFormat Later we should deprecate usage and especially inheritance of BasicFormats etc and recommend to use the methods in JsonFormat directly Refs By providing the predefined implicits directly from the companion object of JsonFormat no extra imports are needed for simple usages Thats standard for any typeclass based library but we missed it back then The difficulty is to keep everything compatible but it seems I found a way that it is simple and compatible Lets keep an open tab of implicits that have been converted in that style AdditionalFormats BasicFormats CollectionFormats StandardFormats All of those are included in close close This implementation uses agemooijs implementations Implementation is simpler than but performance is less than The not show bad performance characteristics when object keys hashCodes collide test in JsonParserSpec is flaky In absolute terms the regularTime is about E ms on a modern laptop This time is sufficiently large to make the test mostly pass on a dedicated machine However on a shared environment such as a TravisCI build it frequently causes the build to fail Potential solutions easy increase the number of keys by an order of magnitude futureproof dont assume a number of keys will give a large enough time but rather incrementally deduce that number for a given system time and then run the test import sprayjson import sprayjsonDefaultJsonProtocol val list MapkfnrdListffff printlnlisttoJson compiler error Cannot find JsonWriter or JsonFormat type class for scalacollectionimmutableMap StringjavaioSerializable I used wrong Otherwise its easy to create BigDecimals that are so big that any operation on them will take a long time Its somewhat arguable that sprayjson needs to care for this if your application does anything with usersupplied BigDecimals it should cut them into digestible proportion But on the other hand as most of these values are somewhat unlikely it might make sense to provide guards Quoting plokhotnyuk at Even after successful parsing of BigDecimal values like e or e users can be affected by any subsequent operations like longValue etc Just try how this code works in your Scala REPL scala val f x BigDecimal x f BigDecimal scalamathBigDecimal Lambda ac e scala fBigDecimal e or scala val g x BigDecimal x g BigDecimal scalamathBigDecimal Lambda e ea scala gBigDecimal e javamathMathContextUNLIMITED To prevent this the parser should avoid returning of BigDecimal with too big exponent or scale or with MathContextUNLIMITED by default BTW in jsoniterscala javamathMathContextDECIMAL and a corresponding K limit for the scale were selected as safe defaults plokhotnyukjsoniterscalajsoniterscalamacrossrcmainscalacomgithubplokhotnyukjsoniterscalamacrosJsonCodecMakerscalamasterL L 