I wish we could have polymorphic relationships like we could do in Hibernate Indeed I know you can use interface to abstract out some of the fields and put them into one own entity with such shared traits to mock the behavior of polymorphic relationships but it simply wont synchronize with the database design in mind Im trying to use Ktorm on Android Reading an existing database works fine with SQLDroid but when I come to create records the function BaseTableinsertAndGenerateKey fails with a null pointer error The problem is that it results in a call to connprepareStatementsql RETURNGENERATEDKEYS which is not supported by SQLDroid fastJSON kotlin Databaseconnectjdbcmysql baseframecharsetutf mb useSSLfalse driver commysqlcjjdbcDriver user root password var items iframeDictfindList dbiframeDictzdValue eq items object iframeDict TableiframeDictiframedict val zdId by intzdIDprimaryKeybindTo itzdId val zdName by varcharzdNamebindTo itzdName val zdValue by varcharzdvaluebindTo itzdValue val zdLabel by varcharzdlabelbindTo itzdLabel val zdType by intzdtypebindTo itzdType val zdSort by intzdsortbindTo itzdSort val zdParentid by intzdParentIDbindTo itzdParentid val zdIsparent by intzdIsParentbindTo itzdIsparent val zdIsshow by intzdIsShowbindTo itzdIsshow val zdAttr by varcharzdAttrbindTo itzdAttr interface iframeDict EntityiframeDict companion object EntityFactoryiframeDict val zdId Int val zdName String val zdValue String val zdLabel String val zdType Int val zdSort Int val zdParentid Int val zdIsparent Int val zdIsshow Int val zdAttr String jdbc boolean mysqlmysqlconnectorjava sql T ListT limit orderBy commicrosoftsqlserverjdbcSQLServerException Invalid column name AID var result staffinnerJoindepartment on departmentaid eq staffdepartmentAid innerJoinstateStaff on stateStaffid eq staffstateId selectstaffphone staffname stateStaffname where staffaid eq orderBystaffaiddesc limit map row StaffEntityrow staffphone row staffname row stateStaffname A few weeks ago I implemented a service Some tables had composite primary keys in SQL I remember being astounded that this is implicitly supported when doing the Ktorm mapping Today I started integrating the service but in the meantime primary key uniqueness is checked it is commit d f eaeca a e c c df a e I wonder why it worked just as expected before maybe because I didnt use lookups by ID but employed regular where clauses Have you already thought of how to realize compoundcomposite keys I shall have a look how other ORMs do it Hello I had a situation in which I had multiple Database s with the same connection parameters around Rollback had no effect when I used the transaction scope as a method dbuseTransaction but succeeded whenever I used the function useTransaction ie on the global instance I stepped through the code rollback SQL is called reliably but in the case described above has no effect As soon as I reduced the multiple connections to one both ways of employing the transaction scope worked Maybe having multiple same connections is against the concept Then of course it can also be correct undefined behaviour Great work by the way