The ConstT type would necessarily compile to a const an immediate operand or something of the sort Additionally it could have extra bounds on it to make some optimizations possible altho Im not sure how those would be done in practice It would for the most part only exist at compiletime as in hostrust compiletime not JIT compiletime And also the host code would specify when things get compiled rather than doing it whenever the library wants to The basic idea is to do the most work of optimizing and stuff at Rust compiletime so that very little work needs to be done at runtime That is zerocost abstractions for your JIT compiler JITs should be performant and tuneable and HolyJIT might well be performant altho I doubt it compares to eg V but it doesnt look very tuneable as it currently stands I do not believe the library should handle all the details of the JIT but rather it should be a glorified selfmodifying code library just without being able to modify yourself while youre running it should make copies ofc This pull request is a workinprogress to handle the LIR to Cranelift IR conversion It adds a LIR representation and adds a Cranelift backend However it does not yet change the MIR to LIR mapping nor the serialization of the LIR Thus this pull request cannot yet be tested with a complete pipeline to handle the Brainfuck example Tests for this pull requests are added as part of the test of the newly added codegen subproject These tests are creating LIR units which are then lowered into Cranelift IR compiled and tested The current IR is a quick and dirty format made only to support the needs of a proof of concept than something which deserve to remain asis in the next version However one concept might still be interesting to investigate such as having SSA values which sizes are not restricted to simple types and being able to address memory inside them Thus we could have SSA values which are representing complex data structures and the need of addressing in them could force them to be stack allocated One of the feature that needs to be added and is not yet tried in any JIT as far as I know it to version parts of the data flow graph and control flow graph in order to make the graph patchable literally applying patches in a version control system Among the required features to be able to frequently apply previously recorded patches graph mutation made during previous compilations to a graph we need the nodes instructions of the graph to have a limited context Thus having a little as possible ordering edges and no indexes Should this be named VSSA for Versioned SSA The usual control flow represenation approach of SSA made out of basic blocks which forces the order of all instructions from the beginning might cause the patches to not be applicable because of newly inserted nodes The seaofnodes representation would remove the ordering of instructions until the scheduling pass which would help Also SSA relies on the indexing of instructions in order to access them quickly For a VSSA we have to add a way to index instruction which is stable across multiple compilations A contentaddressing will cause the dataflow of an instruction to be replaced each time an instruction is mutated which is too much However we can have a contentaddressing which ignores a replacedby field which can be mutated patched and record the contentaddress of the newer instruction Cranelift previously named Cretonne is far from being ideal as the Cranelift IR does not provide the features needed to express versioning needs and using it as a backend implies having an additional intermediate representation However Cranelift does have more stable code base and would remove a good chunk of work from HolyJIT early days Thus it makes sense to base HolyJIT on Cranelift for the early days of HolyJIT until it becomes a pain point I tried running the example command in the README but I got this projectsholyjit RUSTCWRAPPERpwdrustcsh cargo run example brainfuck Finished dev unoptimized debuginfo targets in secs Running targetdebugexamplesbrainfuck Did not found JIT Code in the context Start compiling bincodeErrorKind IoError failed to fill whole buffer JIT Compiler Error Deserialize Currently it might seems opaque to a lot of persons why will HolyJit should use its own LIR representation instead of relying on LLVM IR or directly targeting Cretonne for doing transformations on the code extracted from the MIR The problem with existing projects is that it is hard to retrofit new constraints on an existing compiler without rewriting large parts of the compiler In order to avoid mistakes ourself we should explicit and document the constraints that we want on the LIR on analysis and on transformation phases before implementing of it The core idea is that HolyJit should be optimized for recompilation Optimizing for recompilation means that the compiler should minimize the time needed to recompile after a deoptimization which invalidated the previously optimized code This comes from the conclusion that the cost of a deoptimization is proportional to the cost of the recompilation Reducing the deoptimization cost implies that we can afford to do more speculative optimization reducing the need for proves in the compiler in the early tiers of the JIT compiler I came across this while trying to implement inputoutput for brainfuck I looked at the crash for a bit in rr it seems that something is calling indexmut without setting registers properly rsi x which causes a null deref In short rust Program received signal SIGSEGV Segmentation fault x bde eacc in allocvecimplindexmutu self x fff ff index at shareddevrustrustpatchsrcliballocvecrs fn indexmut mut self index opsRangeusize mut T rr print self allocvecVecu buf allocrawvecRawVecu allocheapHeap ptr coreptrUniqueu pointer corenonzeroNonZeroconst u x f f e marker coremarkerPhantomDatau cap a allocheapHeap len rr bt x bde eacc in allocvecimplindexmutu self x fff ff index at shareddevrustrustpatchsrcliballocvecrs x f f de in x be f in paniclocC x bdf bcc in strj x c in x be f in paniclocC x b in x f f in x in x in x f f a in x in x in x in So this is definitely crashing on indexing the mem variable Heres code that triggers this crash Note I use boxed traits because the jit macro doesnt accept generic functions rust featureplugin customattribute pluginholyjitplugin featureunboxedclosures macrouse extern crate holyjitlib as hj use stdio use stdioRead Write Cursor jit fn evaljc hjJitContext program String input BoxRead output BoxWrite Result evalimpl in jc fn evalimpljc hjJitContext program String mut input BoxRead mut output BoxWrite Result let prog programasbytes let mut pc usize let mut ptr usize let mut mem Vecu Vecwithcapacity memresize loop if pc proglen return Ok match proggetpcunwrap b ptr if ptr memlen mempush b ptr ptrsaturatingsub b mem ptr mem ptr wrappingsub b mem ptr mem ptr wrappingadd b outputwrite mem ptr ptr unwrap b inputreadexact mut mem ptr ptr unwrap b if mem ptr let mut iter pc loop iter match iter prog iter p b pc p break p d b p d p d b p d p d p d continue skip pc increment b let mut iter pc loop iter match iter prog iter p b pc p break p d b p d p d b p d p d p d continue skip pc increment panicUnknown Symbol pc fn main let jc hjJitContext Defaultdefault let res evaljc into BoxnewCursornewbHello world Boxnewiostderr let res evaljc into resunwrap With this program evaljc into the brainfuck interpreter panics because it sees an unknown symbol at the program counter garbage memory With evaljc into the program receives a SIGSEGV caused by a read of one byte before an allocated page Ill try to run these with ASAN and report the results EDIT I cant build with ASAN because kernel sys fails to link Brainfart I need to pass the target flag but holyjit also fails to link EDIT I just realized the brackets in these programs are mismatched which means bounds checks arent emitted properly under jit