 Passport Version Laravel Version PHP Version Database Driver Version Description Steps To Reproduce Passport Version Laravel Version PHP Version Database Driver Version na Description When using inherited scopes and you attempt to set scope inside PassportactingAsuser api the can method returns false when checking scope apiusersindex Steps To Reproduce public function testactingasignoreswithinheritedscopes PassportwithInheritedScopes true user PassportactingAsfactoryUserclasscreate api thisassertTrueusertokenCanapi Works as expected thisassertTrueusertokenCanapiusers Fails thisassertTrueusertokenCanapiusersindex Fails public function testactingasingoreswildcard PassportwithInheritedScopes true user PassportactingAsfactoryUserclasscreate thisassertTrueusertokenCanapi Fails The issue related to Passportphp acting as method public static function actingAsuser scopes guard api token MockerymockselftokenModelshouldIgnoreMissingfalse This check is different to the logic performed inside the standard token model foreach scopes as scope tokenshouldReceivecanwithscopeandReturntrue userwithAccessTokentoken if issetuserwasRecentlyCreated userwasRecentlyCreated userwasRecentlyCreated false appauthguardguardsetUseruser appauthshouldUseguard return user Tokenphp here logic to handle wildcard and inherited scopes is checked public function canscope if inarray thisscopes return true scopes PassportwithInheritedScopes thisresolveInheritedScopesscope scope foreach scopes as scope if arraykeyexistsscope arrayflipthisscopes return true return false It would be great if Passport supported hashing tokens similar to the way you can hash tokens with the API guard I looked through the existing issues and saw but that issue is about hashing the client ID and secret Hashing the access and refresh tokens is a bigger win for security in my opinion because The client secret needs to be stored in plaintext by the client anyway but the tokens do not Stealing a client secret lets you impersonate the client but wont normally give you access to users data Stealing an access or refresh token does give you access to users data It would be great if we could ship this feature for I would be willing to write the PR Passport Version Laravel Version PHP Version Database Driver Version Description My userid is a big Integer so cannot insert to oauthclients I can change column type myself I think all coumn integer in should change to BigInteger for fresh install Passport Version Description Since Passport uses Laravels own url Validator to check for valid redirect URIs its impossible to use most private or provisional schemes as recommended by RFC OAuth for Native Apps see for use with mobile apps or nonwebclients that cant listen on the loopback interface in general The latter is recommended for computer software but isnt possible with the permission structure of modern mobile device operating systems The Laravel URL validator is made for forms on websites and will in of all cases be used to validate a web URL Its not good at all for private or provisional URI schemes that are either registered with IANA or used in private contexts like interapp communication Steps To Reproduce Option A Try to use a valid permanent scheme that isnt hierarchicallly structured and therefore doesnt use the double forward slashes like urnietfparamsoauthgranttypedevicecode You will not be able to pass through any authorization that requires a redirect and will instead see the One or more redirects have an invalid url format errormessage Option B Use a provisional or private URI scheme not included in the scheme list of the Laravel URL Regex like the android scheme see Again you will not be able to pass through any authorization that requires a redirect and will instead see the One or more redirects have an invalid url format errormessage There has been a previous attempt at fixing that behaviour but I think that went the wrong direction when the author wanted to fix the widely used Laravel URL Validator Id rather fix the broken behaviour of that validation rule separately from simply allowing all kinds of URIs conforming to the scheme set in RFC for the purpose of redirects Heres the corresponding bug report at the main Laravel repo There I suggested limiting the current url Validator to the most common URI schemes and instead adding a secondary generic URI validator that just checks if the format is valid I can see why one wouldnt want a too broad URI validation in the framework when that is used in form validation and stuff like that where one woudl want to prevent website users from doing bad things Therefore I would very much welcome it if we could throw the halfhearted URL validator from the main framework out the window in this library and instead use a custom regex to validate just the format Passport Version v Laravel Version PHP Version PHP stretch gbp ebb cli built Mar NTS Database Driver Version Mysql Description If we use PassportactingAsuser and then we try to get the expiresat it will return false instead of the expires date Steps To Reproduce Assuming you have a Passport oAuth login in place already create a test and execute PassportactingAsuser usertokenexpiresat return false instead of the Date Cordially In core framework getAuthIdentifier is used to get user identifier for authentication However in passport getKey is used to get user identifier Below are the places where made us confused In our case we used uuid as auth identifier but kept primary key as primaryKey field for relationships Would you consider to change to use getAuthIdentifier to be in sync with core framework design Since has been locked we are no longer able to discuss the issue Before I submit a PR I want to make sure we have a common ground on what the expected behavior is for multiprovider support in Passport More specifically should the provider be defined at the oauth client level This would limit that client idsecret pair to always return from a specific provider If the gate requested another provider than what the client has defined it would return a This is the functionality I have built into my current project and I would be more than willing to issue a PR for it but I want to make sure that is what everyone is expecting EDIT I should note that if no provider is set on the oauth client then it will follow the same logic as what is in place now so it should be backward compatible outside of the migration Brief overview The main purpose of this feature is to make Laravel Passport more unified with the main application Detailed The session token name is generating with the following formula StrslugenvAPPNAME laravel session And this is how the Passport is making the name public static cookie laraveltoken Why not implement this thing to the Passport by default This will likely remove most cookie name override needs Thanks in advance When using the api authentication with cookie we might have silent error The trycatch in the getTokenViaCookie function on the TokenGuard class wraps the decodeJwtTokenCookie function so an error occured while executing decodeJwtTokenCookie we wont know about it and it will return errorUnauthenticated In my case it took me half a day to understand that the authentication was failling message Allowed memory size of bytes exhausted tried to allocate bytes exception Symfony Component Debug Exception FatalErrorException file varwwwvendorlaravelpassportsrcGuardsTokenGuardphp line trace And I fixed the problem for now by adding PassportunserializesCookies true in my AuthServiceProvider Anyway it could be nice to know that something has failed maybe I did something wrong during the install process 