Currently it appears impossible to use eachWhere with a map It is formally possible to invoke eachWhere on a Map A B but it would result in this method using Iterable A B as the output for setting the value which causes type mismatch errors My use case is as follows I have a map like Map String SomeValue and I need to modify only those entries whose key satisfies some predicate scala val predicate String SomeValue Boolean case k someConditionOnKeyk modifysourceseachWherepredicatenestedvalue Apparently there is no simple way to do it now Having an ability to use eachWhere on a map would solve the issue adding a failing test for I am at a bank where GitHub is blocked and I need to share the documentation Please follow these instructions to create a GitHub page I would appreciate it case class Test T a T b Int Test modifybsetTo Given the code case class Aa B case class Bb Int def xb Int Future Int Id like to be able to write a A amodifyabusingx Id expect it to yield Future A Id also expect it to work for any F that has QuicklensFunctor type class instance Hi Im using quicklens and comsoftwaremillcommon tagging v Im unable to modify a value containing tagged datatypes For example import comsoftwaremilltagging import comsoftwaremillquicklens case class Adata String sealed trait B type C A B case class Dvalue C val a C AtesttaggedWith B val d Da dmodifyvaluedatasetTomodified This does not compile error type mismatch error found A error required C error which expands to A with AnyReftype Tag B error L dmodifyvaluedatasetTomodified I understand why this doesnt compile but I was wondering if there is any way around this I also tried using shapeless tagging it uses a trait instead of a type for tagging but the issue remains Apologies if this has been asked before I searched open closed issues but could not find anything relevant Using scala JDK u Quicklens Using the following setup with an example from the documentation case class Streetname String case class Addressstreet Option Street case class Personaddresses List Address val person PersonList AddressSomeStreet Functional Rd AddressSomeStreet Imperative Dr Then this will work person modifyaddresseseachstreeteachWherenamestartsWith name usingtoUpperCase but this will fail with a compilation error val one person modifyaddresseseachstreeteachWherenamestartsWithonename usingtoUpperCase The exception is quite long but it starts like this error javalangIllegalArgumentException Could not find proxy for val one String in Listvalue one method anonfunnew value local QuickLensIncidentTest class QuickLensIncidentTest package empty package root currentOwner method anonfunnew error at scalatoolsnsctransformLambdaLiftLambdaLiftersearchIn LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLifteranonfunproxy LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLiftersearchIn LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLifteranonfunproxy LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLiftersearchIn LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLifteranonfunproxy LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLiftersearchIn LambdaLiftscala error at scalatoolsnsctransformLambdaLiftLambdaLifteranonfunproxy LambdaLiftscala So it looks like closures dont work Hi Given a nested chain of Options is there a way to coerce the most inner one to Some The current operator each allows traversing Options but acts like map scala import comsoftwaremillquicklens case class Cd Option Int case class Bc Option C case class Ab Option B val a Ab None amodifybeachceachdeachsetTo res A ANone the result is ANone but how can we achieve a ASomeBSomeCSome It could be useful if there were some operator say all which can act as follows scala amodifyballcalldallsetTo res A ASomeBSomeCSome The following code case class Toppingcherries Int case class Caketoppings List Topping case class Bakerycakes List Cake val myBakery BakeryListCakeListTopping Topping CakeListTopping CakeNil import comsoftwaremillquicklens modifymyBakerycakeseachtoppingsat cherriessetTo produces the following exception javalangIndexOutOfBoundsException at scalacollectionLinearSeqOptimizedapplyLinearSeqOptimizedscala at scalacollectionLinearSeqOptimizedapplyLinearSeqOptimizedscala at scalacollectionimmutableListapplyListscala at comsoftwaremillquicklenspackageanon atpackagescala at anonfunres console at Lambda applyUnknown Source at scalacollectionimmutableListmapListscala at comsoftwaremillquicklenspackageanon mappackagescala at comsoftwaremillquicklenspackageQuicklensFunctoreachpackagescala at comsoftwaremillquicklenspackageQuicklensFunctoreachpackagescala at comsoftwaremillquicklenspackageanon eachpackagescala at anonfunres console at Lambda applyUnknown Source at comsoftwaremillquicklenspackagePathModifysetTopackagescala elided I would expect it to return the same Bakery except with the first Toppings and set to Is there any way to compose only PathModifies Something like following scala case class AbB case class BcC case class CvalueInt val a ABC val mod amodifyb val mod mod somecomposefunctionc mod setToC I know that you can compose functions of U PathModify U V but I want to know if there is a way to compose PathModifys directly