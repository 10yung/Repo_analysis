Id love to help out as Im using it in the dokku project and it would be great to have this package in a more maintained form Ive created a small middleware that implements timeSleep May be useful during development to see how clients handle timeouts or slow requests Also ordered the list alphabetically Every exported function in a program should have a doc comment The first sentence should be a summary that starts with the name being declared From effective go PR generated by CodeLingo Install here to drive Continuous Higher Standards I build this project example in Countries demo bash curl i H ContentType applicationjson d CodeFRNameFrance it has to return CREATED but return OK curl i H ContentType applicationjson d CodeUSNameUnited States it has to return CREATED but return OK curl i H ContentType applicationjson d CodeUSNameUnited States return CONFLICT I customed curl i curl i curl i curl i X DELETE curl i curl i X DELETE curl i if data is conflict go if store countryCode nil restErrorw conflict return but I dont know modified responsecode override could you help me This adds the PathExp to the Request object so that code downstream of the router is aware which route is satisfying the current request Primary motivation for this is to give middlewares some additional information When investigating memory usage for an app that uses this project I noticed that memory usage continually climbed over time with thousands of requests After further investigation I think I have identified the problem being in the timer middleware Heap profile pprof top Showing nodes accounting for MB of MB total Dropped nodes cum MB Showing top nodes out of flat flat sum cum cum MB MB NAMEREMOVEDvendorgithubcomant inegojsonrestrestTimerMiddlewareMiddlewareFuncfunc Memory Allocation List pprof list MiddlewareFuncfunc ROUTINE NAMEREMOVEDvendorgithubcomant inegojsonrestrestTimerMiddlewareMiddlewareFuncfunc in NAMEREMOVEDvendorgithubcomant inegojsonrestresttimergo MB MB flat cum of Total MiddlewareFunc makes TimerMiddleware implement the Middleware interface func mw TimerMiddleware MiddlewareFunch HandlerFunc HandlerFunc return funcw ResponseWriter r Request MB MB start timeNow MB MB rEnv STARTTIME start call the handler MB hw r end timeNow MB MB elapsed endSubstart rEnv ELAPSEDTIME elapsed It seemed odd that there was a large memory profile for a time allocation Looking into this closer it seemed like the env values were escaping to the heap and is not garbage collected go test gcflags m githubcomsnaglesgojsonresttest exampletestgo func literal escapes to heap exampletestgo func literal escapes to heap exampletestgo leaking param h to result r level exampletestgo start escapes to heap exampletestgo start escapes to heap exampletestgo moved to heap start exampletestgo leaking param w exampletestgo leaking param r exampletestgo elapsed escapes to heap exampletestgo elapsed escapes to heap exampletestgo moved to heap elapsed Ive removed the reference and changed start and end to start and end and that kept the memory on the stack Test Program package test import log sync testing time githubcomant inegojsonrestrest githubcomant inegojsonrestresttest func TestSimpleRequestt testingT api restNewApi apiUse TimerMiddleware router err restMakeRouter restGetr funcw restResponseWriter r restRequest if err nil logFatalerr apiSetApprouter var wg syncWaitGroup wgAdd for i i i go funcwg syncWaitGroup testRunRequestt apiMakeHandler testMakeSimpleRequestGET nil wgDone wg wgWait TimerMiddleware computes the elapsed time spent during the execution of the wrapped handler The result is available to the wrapping handlers as requestEnv ELAPSEDTIME timeDuration and as requestEnv STARTTIME timeTime type TimerMiddleware struct MiddlewareFunc makes TimerMiddleware implement the Middleware interface func mw TimerMiddleware MiddlewareFunch restHandlerFunc restHandlerFunc return funcw restResponseWriter r restRequest start timeNow rEnv STARTTIME start call the handler hw r end timeNow elapsed endSubstart rEnv ELAPSEDTIME elapsed Unless Im misunderstanding should all rEnv values be set to nonpointers Would like to get the ability to get the bytes written in response Consider this a RFC pull request to get your ideas let me know how you would like it Is there have a multiinstance example On a single server I have multiple ports Mapping and how to do how can i upload file use go json rest I am just use this code to do success func uploadw restResponseWriter r restRequest rParseMultipartForm file handler err rFormFileuploadfile if err nil fmtPrintlnerr return defer fileClose f err osOpenFilehandlerFilename osOWRONLYosOCREATE if err nil fmtPrintlnerr return defer fClose ioCopyf file fmtFprintlnwhttpResponseWriter upload ok func indexw restResponseWriter r restRequest whttpResponseWriterHeaderSetContentTypetexthtml whttpResponseWriterWrite bytetpl const tpl html head meta charsetutf title title head body form enctypemultipartformdata actionupload methodpost input typefile nameuploadfile input typehidden nametoken value input typesubmit valueupload form body html