Will propagate As pointed out by schloerke expandChainoutputSummary this is likely more intuitive than expandChainoutputSummary It seems like we could support either way r libraryshiny libraryshinymeta ui fluidPage selectInputvar label Choose a variable choices namescars verbatimTextOutputSummary verbatimTextOutputcode server functioninput output var metaReactive cars inputvar outputSummary metaRenderrenderPrint summaryvar outputcode renderPrint expandChainoutputSummary shinyAppui server Fixes The knitexpand mechanism is a bit too lowlevel since it works on a purely textual level its easy for values intended to be text to be interpreted as code instead eg an Rmd template that contains this snippet not in a code block The variable well be focusing on in this report is colname And then buildRmdBundle vars listcolname inputcolname A malicious client could easily send a colname value of nr nunlinkwhatever recursiveTRUE n n which would expand into the Rmd template as The variable well be focusing on in this report is r unlinkwhatever recursiveTRUE Some ideas We could add the values in vars to the knitr environment then tell people to do r colname instead of colname Wont work see my next comment We could recommend people pass noncode values through params That seems like a higheroverhead version of the previous option though Wont work see my next comment We could error on suspicious vars or substitutions Yuck security heuristics We could stop using knitexpand altogether and use a different chunk type to insert code dynamically This would probably be a considerable amount of knitr hacking I think I looked at this last time and I couldnt find an obvious way to preprocess a chunk and then have knitr treat it as code Note builds on PR because it relies on the scope correction of metaExpr in that branch Fixes r existsfoo FALSE shinymetametaExprfoo TRUE TRUE existsfoo FALSE I think this is due to the use of rlangevaltidy r rlangevaltidyquotefoo TRUE TRUE existsfoo FALSE Switching to baseeval will fix this Currently input values are inlined into the generated code which makes it cumbersome to change an input value in the generate code One of my preferred debugging techniques in a problematic reactive is to insert browser in the relevant construct Looking at the modules example app in PR I tried this out r values metaReactive reqinputcol bb metaExpr browser df dplyrpullinputcol If I assign the complete chain above to an object everything works perfect But if I try assigning df to an object I get an error about not finding function Of course I can simply use df instead but it might help to talk about the nuances of using or not using when debugging the app 