 Description When any piston program is run and the window is resized the graphics appear incorrectly To Reproduce Run this extern crate piston extern crate graphics extern crate glutinwindow extern crate openglgraphics use pistonwindowWindowSettings use pistoneventloop use pistoninput use glutinwindowGlutinWindow as Window use openglgraphics GlGraphics OpenGL pub struct App gl GlGraphics impl App fn render mut self args RenderArgs use graphics const GREEN f const RED f let square rectanglesquare let x y argswidth argsheight selfgldrawargsviewport c gl clearGREEN gl let transform ctransformtransx y rectangleRED square transform gl fn update mut self args UpdateArgs fn main let opengl OpenGLV let mut window Window WindowSettingsnew spinningsquare openglopengl exitonesctrue build unwrap let mut app App gl GlGraphicsnewopengl let mut events EventsnewEventSettingsnew while let Somee eventsnext mut window if let Somer erenderargs apprender r if let Someu eupdateargs appupdate u and then resize the window Expected behavior The boxes should continue to appear in the centre of the window Screenshots Initial window img width altScreenshot at src When I change the size the square moves towards the top right as the windows grows img width altScreenshot at src Hardware and Software Piston versions piston piston dgraphics pistoncoreglutinwindow piston dopenglgraphics OS macOS Mojave inch x DPI is Graphics card Intel Iris Plus Graphics Im trying to draw an image from a path and ran into some type issues Can somebody tell me why this is happening The official example on the docs also doesnt compile for another set of reasons it seems Relevant sections of code rust use graphicsrectanglesquare use graphicsContext DrawState Graphics Image use openglgraphicsTexture TextureSettings use stdpathPath impl GameView pub fn drawG Graphics self c Context g mut G let img Imagenewrectsquare let texture TexturefrompathPathnewassetsbrickpng TextureSettingsnew expectCould not load brick let drawstate DrawState Defaultdefault imgdraw texture drawstate ctransform g Im using an OpenGL backend rust while let Somee eventsnext mut window gamecontrollerevent e if let Someargs erenderargs gldrawargsviewport c g use graphicsclear clear g gameviewdraw c g Heres the error I get rust srcgameviewrs imgdraw texture drawstate ctransform g expected associated type found struct openglgraphicsTexture note expected type G as graphicsGraphicsTexture found type openglgraphicsTexture I tried to use expect method on the result of CharacterCachecharacter method but turns out I cant because the associated Error type doesnt require Debug trait Rust error E no method named expect found for type stdresultResultgraphicscharacterCharacter G as graphicsGraphicsTexture C as graphicscharacterCharacterCacheError in the current scope srcsomefilers let chglyph glyphscharacter chexpectCouldnt load character note the method expect exists but the following trait bounds were not satisfied C as graphicscharacterCharacterCacheError stdfmtDebug It would be obvious to add a constraint that Error should implement the Debug trait It seems to me as a good idea however Im not sure of it since I have modest Rust experience I even asked a question on stack overflow about this pattern Anyway if you guys think its a good idea it seems kind of obvious to add the derive to all of its implementations and I would be glad to do it Im trying to make piston scale my graphics automatically but it seems to cause some wierd artifacting What Im trying to do is cause my coordinate space to be stretched to fit the size of the window without changing the coordinates Im currently using this code to scale it which does work ctransform ctransformscale argswidth as f argsheight as f Where args is RenderArgs and c is Context This causes everything everything to be sized and positioned relatively with x being the lower left corner However it causes some serious artifacting This image the image is only the black part and has no white in it Turns into this again blue is just a background When the window size is by The issue is present even downscaling by eg x In fact this happens even if the window is by and no scaling should happen The issue might be solved by using a Viewport but it doesnt seem obvious to me how its supposed to be used and I couldnt get it to work properly when trying Is this because Im scaling it incorrectly not using a viewport or a bug I have a weird use case for piston dgraphics where Im making draw calls without a game loop because Im generating a batch of oneoff images in a headless OpenGL context The problem is that given a glutinHeadlessContext with dimensions widthxheight I dont know how to construct a graphicsViewport that covers exactly that rectangle For clarity heres where my code diverges from regular code Where a lot of sample code suggests something like rust let mut glgraphics GlGraphicsnewopengl let mut events EventsnewEventSettingsnew while let Somee eventsnext mut window if let Someargs erenderargs glgraphicsdraweviewport c g somethingdrawctransform g I instead use code like this because I dont have a window or event loop rust let mut glgraphics GlGraphicsnewopengl let viewport Viewport rect width height pretty sure this is wrong drawsize width as u height as u windowsize width as u height as u for in someiterator glgraphicsdraw viewport c g what Id like to write is graphicsimage sometexture ctransform g but to make sure my viewport coordinates are sensible I currently write graphicsRectanglenew draw cdrawstate ctransform g and spoiler theyre not The resulting image shows the square stretched out of shape and partially off the horizontal edge it should be aligned to and Im pretty sure its the result of my initial viewport dimensions being wrong The quality of rusttype rendering as well as the number of font formats available makes it a little experimental for generalpurpose use Is it be possible to use features to activate this in piston or have a feature to change it to freetype I needed this for getting turtlers running in the browser via webassembly so I wrote up a partial implementation here It only does plain colors not textures because thats all Turtle needed Is this of interest Maybe to Hi Is there a way to draw multiple points that are collected by lines The polygon method fills the shape What can I use to draw the entire path as a set of lines Drawing each line of the path individually is extremely slow at the moment Thanks Currently you pass the draw state as argument to every draw method on the backend implementing the Graphics trait The benefit of this design is that the API is stateless The draw state object keeps track of the state of the backend However in practice there are some downsides to this approach Most code never changes the default draw state It is mostly used for stencil clipping and scissoring which changes infrequently Passing in draw state leads to typing more code The backend code to perform efficiently needs a state for the draw state and detecting when to pack the vertices into buffers anyway Checking the draw state for equality against previously set draw state leads to unnecessary overhead When changing the draw state through the Graphics trait the backend can do this directly and detect whether flushing of buffers is required Instead of manipulating the draw state for clipping one could use a separate object with a method taking a closure that changes the draw state and sets it back end to previous state when done Plan Add two new method to Graphics fn setdrawstate mut self DrawState fn getdrawstate self DrawState Remove Contextdrawstate Remove draw state parameters on draw methods