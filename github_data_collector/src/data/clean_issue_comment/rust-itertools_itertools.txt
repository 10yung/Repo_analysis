I was using tuplecombinations for iterating over various card combinations and ran into the tuple limitation when trying to iterate over all possible card combinations of a deck of cards Any chance youd add a fivetuple implementation or should I use another method Every once in a while I find myself reimplementing a dedup with count an iterator that instead of yielding T yields usize T rust let data vec asserteq dataintoiterdedupwithcountcollect vec If you agree that these dedupwithcountdedupbywithcount are useful methods I can open a PR with the implementation soon Pretty selfexplanatory Useful for nonclonable elements or otherwise stateful interspersing intersperse could be implemented via interspersewith allowing the change to be more minimal I havent done it currently but if you dont see any downsides Id amend this change to do selfinterspersewith element for intersperse instead Im trying to find something similar to Scalas Streamdiff Computes the multiset difference between this sequence and another sequence that the sequence of elements to remove returns a new sequence which contains all elements of this sequence except some of occurrences of elements that also appear in that If an element value x appears n times in that then the first n occurrences of x will not form part of the result but any following occurrences will I see theres but it doesnt seem to do the same thing Maybe we call it something else I found myself wanting filtermapresults and just implemented filterresults in the same stretch I hope you find it useful I wasnt sure if applies to these new iterators I just implemented them I spent several hours debugging my code written using the groupby function I expected from this function the logic of grouping the same objects by a key how surprised I was that he groups only some nearby elements while the group key has the same value In the documentation it is also indicated somehow strange and until the last I was not sure if this is a bug or feature I carefully read the documentation times and it turned out to be a feature Awful incomprehensible feature I do not think that this is the behavior that many expect for this method name I demand to rename this method to something more suitable like consgroupby or lazygroupby not to mislead users Example Im not the only one to think so Resolves count last and nth of the MergeJoinBy iterator are made faster when one of the iterators is completely consumed by directly calling the methods of the underlying only iterator left there is benefit if the underlying iterator also specialized these methods This is in particular useful when you want to count the number of different elements in the union of two sorted knownsize iterators count Those methods are also specialized on the PutBack adaptor for the same performance reasons The nth specialization on the MergeJoinBy iterator depends on the nth specialization on the PutBack adaptor working A few methods of the MergeJoinBy iterator could be made faster when one of the iterators is completely consumed by directly calling the methods of the underlying only iterator left count last nth It might be useful to add a chainwith function to the itertools that does the same thing as chain but lazily calling the function that builds the iterator This would make chaining with iterators computed in another thread easier The workaround described here is somewhat limited because map is not an FnOnce even though the way it is used provides the guarantee it will only be used once It seems that the code here doesnt follow the Rust style guide Maybe consider applying rustfmt and add CI step to enforce it I think that would make people more comfortable to contribute as they wouldnt need to think about what code style should they use and can just rely on the tool to figure out