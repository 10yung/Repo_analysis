Pull latest from origin If I define a codec that doesnt align at byte boundaries remotely doesnt like it Heres a small reproducer According to mpilquist this is in fact a valid codec If I change bool to bool it is aligned at byte boundaries and works as expected Quick digging into the sources revealed the following lines in remotely scala package object codecs extends lowerprioritycodecs implicit val bool Cbool use a full byte This line has been there for at least two years but I couldnt find any explanation anywhere Could remotely not pad or at least throw an exception explaining that the codec needs to be bytealigned Finally heres the stack trace sbt run info Compiling Scala sources to homelarstmpremotelybugtargetscala classes info Running Main server NEGOTIATION got ssl parameters None with localhost server NEGOTIATION about to bind with localhost server NEGOTIATION bound with localhost server NEGOTIATION channel connected with server NEGOTIATION sending capabilities with server NEGOTIATION sent capabilities with server NEGOTIATION creating queue with server NEGOTIATION closing queue with server server header Map server trace ac f f d a d b a server request id server result ElemtagListtypeintListElemtextListcontent List server duration nanoseconds client client header Map client trace ac f f d a d b a client request id client result javalangIllegalArgumentException bits remaining x client duration nanoseconds error runmain javalangIllegalArgumentException bits remaining x javalangIllegalArgumentException bits remaining x at scodecinteropscalazpackageAttemptSyntaxanonfuntoTaskextension applypackagescala at scodecinteropscalazpackageAttemptSyntaxanonfuntoTaskextension applypackagescala at scodecinteropscalazpackageAttemptSyntaxanonfuntoTaskextension applypackagescala at scodecinteropscalazpackageAttemptSyntaxanonfuntoTaskextension applypackagescala at scodecAttemptFailurefoldAttemptscala at scodecinteropscalazpackageAttemptSyntaxtoTaskextension packagescala at scodecinteropscalazpackageAttemptSyntaxtoTaskextension packagescala at remotelypackageanonfunevaluate anonfunapply anonfunapply anonfunapply anonfunapply applypackagescala at remotelypackageanonfunevaluate anonfunapply anonfunapply anonfunapply anonfunapply applypackagescala at scalazconcurrentTaskanonfunflatMap anonfun applyTaskscala at scalazconcurrentTaskanonfunflatMap anonfun applyTaskscala at scalazconcurrentTaskTryTaskscala at scalazconcurrentTaskanonfunflatMap applyTaskscala at scalazconcurrentTaskanonfunflatMap applyTaskscala at scalaFunction anonfunandThen applyFunction scala at scalazconcurrentFutureanonfunflatMap applyFuturescala at scalazconcurrentFutureanonfunflatMap applyFuturescala at scalazconcurrentFuturestepFuturescala at scalazconcurrentFuturelistenFuturescala at scalazconcurrentFutureanonfunlisten anonfunapply applyFuturescala at scalazconcurrentFutureanonfunlisten anonfunapply applyFuturescala at scalazFreeanonfunmap applyFreescala at scalazFreeanonfunmap applyFreescala at scalazFreescalazFreefastFlatMapFreescala at scalazFreeanonfunresume applyFreescala at scalazFreeanonfunresume applyFreescala at scalazstdFunctionInstancesanon anonfunmap applyFunctionscala at scalazFreeanonfunrun applyFreescala at scalazFreeanonfunrun applyFreescala at scalazFreego Freescala at scalazFreegoFreescala at scalazFreerunFreescala at scalazconcurrentFutureanonfunasync anonfunapply applyFuturescala at scalazconcurrentFutureanonfunasync anonfunapply applyFuturescala at scalazstreamasyncmutableQueueanonfun applyQueuescala at scalazstreamasyncmutableQueueanonfun applyQueuescala at scalazstreamasyncmutableQueueanonfunscalazstreamasyncmutableQueuestop anonfunapply applymcVspQueuescala at scalazstreamasyncmutableQueueanonfunscalazstreamasyncmutableQueuestop anonfunapply applyQueuescala at scalazstreamasyncmutableQueueanonfunscalazstreamasyncmutableQueuestop anonfunapply applyQueuescala at scalazconcurrentStrategysLowanon anon callStrategyscala at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava trace Stack trace suppressed run last compilerun for the full output javalangRuntimeException Nonzero exit code at scalasyspackageerrorpackagescala trace Stack trace suppressed run last compilerun for the full output error compilerun Nonzero exit code error Total time s completed RemoteSpec relies on the order of ScalaCheck property evaluation in order to clean up the pool in the end Heres what happens after upgrading to ScalaCheck x info Remoteroundtrip List Int OK passed tests info Elapsed time sec info Remotecheckserializers OK proved property info Elapsed time sec info Remoteadd OK passed tests info Elapsed time sec info Remoteroundtrip OK passed tests info Elapsed time sec info Remotecheckdeclarations OK proved property info Elapsed time sec info Remotecleanup OK proved property info Elapsed time sec info Remoteroundtrip Double Exception raised on property evaluation info ARG List info ARG Map info Exception javalangIllegalStateException Pool not open info orgapachecommonspool implBaseGenericObjectPoolassertOpenBaseGenericObjectPooljava info orgapachecommonspool implGenericObjectPoolborrowObjectGenericObjectPooljava info orgapachecommonspool implGenericObjectPoolborrowObjectGenericObjectPooljava info remotelytransportnettyNettyTransportanonfun applyClientscala info remotelytransportnettyNettyTransportanonfun applyClientscala more stack trace This blocks an upgrade to ScalaCheck x It can be easily fixed by converting it into a ScalaTest suite See larsrhremotely b ae fdefe f cf c f cb c a for an implementation This contains the same change as plus a code change to the protocol definition so that it compiles and an explanation on what the macro generates it wasnt obvious to me at first Currently it is possible to create any kind of Remote This is not too much of an issue because remotes should be generated by the macro most of the time It might still be interesting to associate the creation of a Remote with its environment andor protocol in order to make manual creation more typesafe It would also in theory make the macro implementation more fool proof in theory It might also allow to more easily assert the fact that it is only possible to stream one stream per Remote call if we decide to go down that route The latest version of scalazstream contains an implementation of uncons that is generalized to any Monad It also contains a bug fix over the implementation found within the Remotely code base Its out of date Also in three years the current ones expire at which time someone will spend an afternoon figuring out why the tests are suddenly failing been there done that The Travis builds are failing because we never manage to pass the tests on all platforms There does not seem to be any rhyme or reason about which platforms are failing so I am guessing its some general flakiness that may or may not be introduced by the fact that they are running in parallel In the mean time it might be worth reducing the number of platforms to a single one and see if that improves things A travis build that always fails is not very useful 