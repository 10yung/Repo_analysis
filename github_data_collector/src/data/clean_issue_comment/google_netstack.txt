In my system TCP connect to this stack established in this way IP Flags SEW seq win options mss sackOKTS val ecr nopwscale length x fffe x c aca ea a a Eu x a d c d etR x a c a b a dK x c cb b R IP Flags S seq win options mss sackOKTS val ecr nopwscale length x fffe x c aca e a a Eu x a d c d etR x a a ec a dG x c ae b R IP Flags S seq ack win options mss nopnopTS val ecr nopwscale length x fffe x c a Eb x a a f d c e Ret x a fd a d x dc c fc c ae R IP Flags ack win options nopnopTS val ecr length x fffe x aca f a a E u x a d c e f etR x d c a c af R x dc c fc As you see first packet with SYN flag set ignored because in we are see this go case sflags headerTCPFlagSyn After sec OS resend packet so time to establish TCP connect is too much May will be better do check SYN flag like this go case sflags headerTCPFlagSyn headerTCPFlagSyn I am try this change connection established without resend SYN and waiting for sec IP Flags SEW seq win options mss sackOKTS val ecr nopwscale length x fffe x c d ab ae a a EJ x a a af eRp x a c a f a do x c a a b RJJ IP Flags ack win options nopnopTS val ecr length x fffe x d ac aed a a E J x a a af b eRq x d d a c acf RJ x db a f z IP Flags ack win options nopnopTS val ecr length x fffe x a a E b x a a b a af Re q x a e e a db a f cf z x c acf RJ The sndSsthresh variable defined as int overflows with assignment mathMaxInt on bit systems This currently prevents compilation on arm bit systems which has to be worked around by defining the variable as int or assigning a non overflowing bit value which is probably the wrong thing to do Error gopkgmodgithubcomgooglenetstackv fcc cd ebtcpiptransporttcpsndgo constant overflows int Signedoffby A Ray kazauta gmailcom Im getting tired of forking different golang projects to get them to use the conn interface from this project Is there a way to get the runtime to always use a given netstack interface Thanks How can I use CreateNICid tcpipnicid linkEP tcpiplinkendpointid in Windows The fdbased library is not implemented on Windows The endpoint returned by udpForwarderRequestCreateEndpoint doesnt have effectiveNetProtos filled its nil Maybe Im missing something and I should do some initialization by hand Therere two things that make me think this is not true Endpoints returned by tcpForwarderRequestCreateEndpoint have their effectiveNetProtos set A test that uses udpForwarder at doesnt do anything more than CreateEndpoint Missing effectiveNetProtos means that such endpoint wont be closed correctly while stackRegisterTransportEndpoint is called with hardcoded netProtos in ForwarderRequestCreateEndpoints the UnregisterTransportEndpoint in endpointClose is called with netprotos nil This means that the code as simple as golang var wq waiterQueue f udpNewForwarders funcr udpForwarderRequest if zalupa err rCreateEndpoint wq err nil logPrintfPacket received v rID zalupaClose sSetTransportProtocolHandlerudpProtocolNumber fHandlePacket misses new packets if the source port is reused Can someone give an overview as to how netstack is different from the linux network stack I know its a user space application but how does things like scheduling and packet transfer work in netstack and why is the performance affected so much add support for icmp MultiPath TCP seems not include in netstack I dont know the how difficulty to implement it I see the mptcp implementation for Linux and the code is not very long Do you have any plan to include mptcp in netstack Because many client machines does not support use a userspace tcpip stack is necessary 