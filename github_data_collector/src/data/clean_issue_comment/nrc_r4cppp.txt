In Destructuring pt in the second code snippet regarding the first option of the match statement it says in the first approach we dereference x to a temporary variable with type Enum which copies the value in x Enum has copy semantics so it makes sense that x the value in x is copied into a temp variable From that I conclude that if there is a match statement on a dereference of an object with copy semantics a temporary variable is created and the value of x is copied into it So far so good However in the third code snippet option of the match statement where the value of x now of type Enum has move semantics shouldnt the same hold true but this time with a move operation making this scenario illegal That is when creating a match statement on a dereference of an object with move semantics it should following the same logic result in a temporary variable into which x would be moved Or does that not apply in case of object with move semantics That is if you have a match statements on a dereference of an object with move semantics no temporary variable is created I dont know the answer as Im just starting out with Rust and it gets me confused I think this point should be clarified In the Data Types section a way of accessing the elements of a tuple discussed in this tutorial is through destructuring Under Tuple structs it is suggested that this is the only way of accessing tuple elements Their fields must be accessed by destructuring like a tuple rather than by name However there is another way of accessing tuple elements through dot notation Tuple elements can be accessed directly by using a period followed by the index of the value For example rust fn barx i i printlnx was x x Note the x and x This can also be applied to tuple structs rust struct IntPoint i i fn foox IntPoint printlnx was x x Note the x and x It is quite intriguing to me as to why this is left out because this syntax is encountered early on in the Rust Programming Language book In the section on data types it states A rust struct is similar to a C struct or a C struct without methods Simply a list of named fields The syntax is best seen with an example This statement is misleading because it suggests that methods can not be defined for a struct while methods can be defined via impl blocks There is a brief mention of this possibility with Behaviour is defined by functions and those can be defined in traits and impls However this suggests the impls would define functions rather than methods while in fact impls can define both For reference here is a short example outlining the type of functionality I am describing Rust struct Example foo i bar i impl Example fn baz self i selffoo selfbar fn main let ex Example foo bar println exbaz This will print I believe a section on this functionality should be added as it is critical to creating useful abstractions The document shows that if no type can be inferred declarations default to isize and usize According to this This is not the case Actually doing this on a bit machine let x gives warning literal out of range for i when compiled However let x isize gives no issues whatsoever I would like to write a chapter on Rusts error handling and comparing and contrasting it against both integercustom type error handling and exceptions in C I just wanted to check to see if this would be worthwhile work before I started going too deep As a C programmer the tutorial felt very off because it focus heavily on C like the style section briefly mentions It might be worth it to put this upfront so that it is clear from the very beginning In the primitive type chapter it might be a good idea to describe the mechanisms of integer overflow in Rust RFC And also the difference between debug and release build here In Destructuring you write Lets say you want a reference to a variable in a pattern You cant use because that matches a reference rather than creates one and thus has the effect of dereferencing the object For example Do you mean a Lets say you want to make a reference to an ordinary struct field using a pattern effectively aliasing the field b Lets say you want to refer to a reference variable in a struct using a pattern creating an additional reference to the object referred to by the field or c something else Why would matching a reference have the effect of dereferencing the object On the face of it that is surprising behavior unless its to avoid a T in which case Id still have expected the dereference to yield the expected T Maybe another sentence explaining why the dereference would be helpful working with for index loop example rustc version rustc nightly ae fn printall all Veci for i in alllen println i allgeti fn main the compiler error seen is foridxrs error the trait bound stdopsRangeTousize stditerIterator is not satisfied E foridxrs for i in alllen foridxrs help run rustc explain E to see a detailed explanation foridxrs note stdopsRangeTousize is not an iterator maybe try calling iter or a similar method foridxrs note required by stditerIntoIteratorintoiter foridxrs error the trait bound stdoptionOption i stdfmtDisplay is not satisfied E foridxrs println i allgeti std macros note in this expansion of formatargs std macros note in this expansion of print defined in std macros foridxrs note in this expansion of println defined in std macros foridxrs help run rustc explain E to see a detailed explanation foridxrs note stdoptionOption i cannot be formatted with the default formatter try using instead if you are using a format string foridxrs note required by stdfmtDisplayfmt error aborting due to previous errors Hi recently I started working my way through this chapter Its the most interesting part but its quite difficult to read at least compared to the other parts and especially if your are quite new to Rust like me and I guess most people here For instance I guess it would increase the readability to use less Rust code in the sectionheadings and also in the text This means less RcRefCellNode in the continuous text only in examples or if the words fit into the text ie Weak pointer is fine Another issue is the choice of words It could be more consistent with the official Rust documentation which c programmers will definitely consult too nrc If you do not like these ideas please let me know I would be happy to make some proposals and to contribute to this Just started a branch some days ago work in progress I did not find the time to come up with good alternatives for every issue yet but this issue is also a reminder to myself to do so Cheers and thanks again for this project 