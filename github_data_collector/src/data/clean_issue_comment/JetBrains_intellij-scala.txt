While opening a project the ScalaCompilerReferenceService decides whether to enable bytecode indexing It is done via CompilerIndicesSettingsisBytecodeIndexingActive One of the requirements is that there must exist a ProjectTaskRunner that can run projects modules and is either an SBT runner or a JPS runner Unfortunately the hasCompatibleRunner indices function loooks only for the first runner that can run all the modules and then checks if it is ans SBT or JPS runner If the first runner can run the modules or the module list is empty the lookup will stop Then if its neither a JPS or an SBT runner the result of hasCompatibleRunners will be false even if there is a good runner further on the list With this change we search through the whole list for a good runner YouTrack SCL fixed Adresses This is really hacky implementation but I managed it to work Not sure if this is correct direction since this is generally big hack but we can make it productionready The problem was that autotests listen for messages on COMPILATIONSTATUS topic that standard compiler produce This PR adds skeleton implementaion for bsp to publish required messages autotest On linux some choose to mount tmp with noexec and redirect a list of apps known to require temporary executables onto another mount For java this can be done via Djavaiotmpdir Forward this property to the sbt downloader process to avoid sbt hanging when trying to use the default noexec temporary dir Such a setup causes this error in idealog WARN nprocessBaseOSProcessHandler Process hasnt generated any output for a long time If its a longrunning mostly idle daemon process consider overriding OSProcessHandlerreaderOptions with BaseOutputReaderOptionsforMostlySilentProcess to reduce CPU usage Command line sbtbased downloader javalangThrowable Process creation at comintellijexecutionprocessBaseOSProcessHandlerinitBaseOSProcessHandlerjava at comintellijexecutionprocessOSProcessHandlerinitOSProcessHandlerjava at orgjetbrainspluginsscalaprojecttemplatepackageanonfuncreateTempSbtProject packagescala at orgjetbrainspluginsscalaprojecttemplatepackageusingTempDirectorypackagescala at orgjetbrainspluginsscalaprojecttemplatepackageanonfuncreateTempSbtProject packagescala at orgjetbrainspluginsscalaprojecttemplatepackageusingTempFilepackagescala at orgjetbrainspluginsscalaprojecttemplatepackagecreateTempSbtProjectpackagescala at orgjetbrainspluginsscalaprojecttemplateVersionDialoganonfunshowAndGetSelected VersionDialogscala at orgjetbrainspluginsscalaprojecttemplateVersionDialoganonfunshowAndGetSelected adaptedVersionDialogscala at orgjetbrainspluginsscalaextensionspackageanon computepackagescala at comintellijopenapiprogressimplCoreProgressManager runCoreProgressManagerjava at comintellijopenapiprogressimplCoreProgressManagerTaskRunnablerunCoreProgressManagerjava at comintellijopenapiprogressimplCoreProgressManager runCoreProgressManagerjava at comintellijopenapiprogressimplCoreProgressManagerlambdarunProcess CoreProgressManagerjava at comintellijopenapiprogressimplCoreProgressManagerregisterIndicatorAndRunCoreProgressManagerjava at comintellijopenapiprogressimplCoreProgressManagerexecuteProcessUnderProgressCoreProgressManagerjava at comintellijopenapiprogressimplProgressManagerImplexecuteProcessUnderProgressProgressManagerImpljava at comintellijopenapiprogressimplCoreProgressManagerrunProcessCoreProgressManagerjava at comintellijopenapiapplicationimplApplicationImpllambdanull ApplicationImpljava at comintellijopenapiapplicationimplApplicationImpl runApplicationImpljava at javautilconcurrentExecutorsRunnableAdaptercallExecutorsjava at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava This causes the following Currently any include added to scalafmtconf is not resolved This limits our options for enforcing uniform style across our projects This PR changes how scalafmtconf is loaded Instead of reading file contents then parsing it as text once a typesafeconfig ConfigIncluder is used to resolve includes over VirtualFile The loaded Config is then rendered to text rootrender Still missing is change detection only changes to the main configuration file scalafmtconf trigger configuration reload Note that even though include mydefaultsconf resolves files relative to the including file when using ConfigFactoryparseFile this behavior is currently broken for scalafmt both cli and sbt plugin due to similar reasons single file read once includes left unresolved Im pursuing PRs against scalafmt as well This PR integrates new zinc and features it introduced compiling to jar file and specifying ignored scalac options It also has multiple smaller improvements mostly related to general build performance Note that I opened this PR now to allow review suggesting changes etc It is not ready to merge because zinc is not yet released the available version M has a bug that is already fixed and merged but we will need wait for the release I may add some more independent peformance improvements but potentially on a different PR I dont plan to change the code that is here unless required by the review Compile to jar Most of the details are in the zinc PR Basically zinc was adjusted to be able to call scalac with output specified as jar file which means that classes are written directly to a jar file instead of multiple class files This can give notable performance improvements mostly on windows that has poor performance wrt eg creating multiple small files The current integration is not full and perfect but it works Before invoking zinc the output directory is replaced with output directoryjar Resources are still copied to the output directory To allow running apps the jar file has to be added to the classpath of the module which is handled by CompileToJarComponent There are known problems If the output jar does not exist at all and user runs the app which triggers build the application will fail with class not found This is because intellijs file system doesnt seem to realize fast enough that the jar appeared before running app and it is not included in the classpath Second and further runs work as expected Switching between compile to jar and to classes back and forth is not seamless If project was compiled with zinc to classes and then users tries to compile it to jar zinc will pick up analysis files from regular compilation and fail with error on them This means that the switch should be followed by cleaning output directories rebuild does not seem to remove zinc analysis files But in general this is one time operation users shouldnt switch too often between those modes Ignored scalac options Normally if a scalac option is changed added removed this means that zinc would trigger full compilation not incremental Some of the options though do not impact the bytecode This integration allows to specify which option changes should be ignored For example Xprinttyper Both this and compile to jar features were put in a new settings panel under Build Execution Deployment Compiler Scala Compiler Zinc right next to Scala Compile Server as those are currently related to zinc only and tbh there is no room for them anywhere else THIS PROGRAM IS SUBJECT TO THE TERMS OF THE BSD CLAUSE LICENSE THE FOLLOWING DISCLAIMER APPLIES TO ALL SOFTWARE CODE AND OTHER MATERIALS CONTRIBUTED IN CONNECTION WITH THIS SOFTWARE THIS SOFTWARE IS LICENSED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS AS IS AND ANY EXPRESS OR IMPLIED WARRANTIES INCLUDING BUT NOT LIMITED TO THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE AND ANY WARRANTY OF NONINFRINGEMENT ARE DISCLAIMED IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT INDIRECT INCIDENTAL SPECIAL EXEMPLARY OR CONSEQUENTIAL DAMAGES INCLUDING BUT NOT LIMITED TO PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES LOSS OF USE DATA OR PROFITS OR BUSINESS INTERRUPTION HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY WHETHER IN CONTRACT STRICT LIABILITY OR TORT INCLUDING NEGLIGENCE OR OTHERWISE ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE THIS SOFTWARE MAY BE REDISTRIBUTED TO OTHERS ONLY BY EFFECTIVELY USING THIS OR ANOTHER EQUIVALENT DISCLAIMER IN ADDITION TO ANY OTHER REQUIRED LICENSE TERMS ONLY THE SOFTWARE CODE AND OTHER MATERIALS CONTRIBUTED IN CONNECTION WITH THIS SOFTWARE IF ANY THAT ARE ATTACHED TO OR OTHERWISE ACCOMPANY THIS SUBMISSION AND ORDINARY COURSE CONTRIBUTIONS OF FUTURES PATCHES THERETO ARE TO BE CONSIDERED A CONTRIBUTION NO OTHER SOFTWARE CODE OR MATERIALS ARE A CONTRIBUTION 