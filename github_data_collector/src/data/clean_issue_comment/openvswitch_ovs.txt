There was no way to initialize the serial number in ofprotoc Added it as a configuration parameter dpsn Conflicts appveyoryml While checking unit tests with valgrind tool make checkalgrind I have noticed several memory leaks detected in column parsing functions for example ovsrecportparseinterfaces ovsrecbridgeparseports ovsrecbridgeparseprotocols as can be seen in the following example report Memcheck a memory error detector Copyright C and GNU GPLd by Julian Seward et al Using Valgrind and LibVEX rerun with h for copyright info Command ovsvsctl timeout addbr br set bridge br datapathtypedummy failmodesecure otherconfigdatapathidfedcba otherconfighwaddraa aa protocols Op enFlow OpenFlow OpenFlow OpenFlow OpenFlow OpenFlow addport br p set Interface p typedummy Parent PID HEAP SUMMARY in use at exit bytes in blocks total heap usage allocs frees bytes allocated bytes in blocks are definitely lost in loss record of at x C DB F malloc in usrlibvalgrindvgpreloadmemcheckamd linuxso by x B xmalloc utilc by x F ovsrecportparseinterfaces vswitchidlc by x F E ovsdbidltxnwrite ovsdbidlc by x A ovsrecportsetinterfaces vswitchidlc by x B cmdaddbr ovsvsctlc by x C E dovsctl ovsvsctlc by x C E main ovsvsctlc bytes in blocks are definitely lost in loss record of at x C DB F malloc in usrlibvalgrindvgpreloadmemcheckamd linuxso by x B xmalloc utilc by x F ovsrecportparseinterfaces vswitchidlc by x F E ovsdbidltxnwrite ovsdbidlc by x A ovsrecportsetinterfaces vswitchidlc by x A addport ovsvsctlc by x A D cmdaddport ovsvsctlc by x C E dovsctl ovsvsctlc by x C E main ovsvsctlc bytes in blocks are definitely lost in loss record of at x C DB F malloc in usrlibvalgrindvgpreloadmemcheckamd linuxso by x B xmalloc utilc by x EC ovsrecbridgeparseports vswitchidlc by x F E ovsdbidltxnwrite ovsdbidlc by x ovsrecbridgesetports vswitchidlc by x B bridgeinsertport ovsvsctlc by x A E addport ovsvsctlc by x A D cmdaddport ovsvsctlc by x C E dovsctl ovsvsctlc by x C E main ovsvsctlc bytes in blocks are definitely lost in loss record of at x C DB F malloc in usrlibvalgrindvgpreloadmemcheckamd linuxso by x B xmalloc utilc by x E ovsrecbridgeparseprotocols vswitchidlc by x F E ovsdbidltxnwrite ovsdbidlc by x D setcolumn dbctlbasec by x EDD cmdset dbctlbasec by x C E dovsctl ovsvsctlc by x C E main ovsvsctlc After the investigation I have found out the origin of these memory leaks lies in the design of column parseunparse functionality ovsdbidl module deals with several table classes AutoAttach Bridge Controller which are depicted in ovsrectableclasses instance Each of entry in this instance refers to ovsdbidlcolumn instance what is actually a description of certain table class number of colums column type column flags column parseunparse functions Column value of certain table row is modified by calling calling apparent column parse function and passing datum argument with new data There exist bunch of different column parse functions and some of them like aforementioned ovsrecportparseinterfaces ovsrecbridgeparseports ovsrecbridgeparseprotocols dynamically allocates memory In order not to leak memory it is important that before calling parse function apparent unparse function is called which frees previously allocated memory Also before the row itself is freed the apparent unparse function should be called And here is the catch of leaking the memory It looks in the past rows were modified in a somehow transnational way First modifications were collected in newdatum array and later on after all new data were collected modificationtransaction was applied by calling ovsdbidlrowparse function with its counterpart ovsdbidlrowunparse function At the end just before the row was deallocated ovsdbidlrowunparse function is called as well in order to deallocate memory previously allocated in parse function The problem was that both ovsdbidlrowparse and ovsdbidlrowunparse function were guarded by ovsdbidlrowparsed flag which was modified at the end for transaction or cancellation As a result unparse functions were not called in case transaction was not applied at all The problem actually started I dont know if this is actually in the original design or not when fieldscolumn of table row were modified directly outside of transactions In this case appropriate parse function was called while its counterpart unparse function was not called before row deallocation because ovsdbidlrowparsed was not set In aforementioned valgrind example report the problem was in cmdaddport function port ovsrecportinsertctxtxn ovsrecportsetnameport brname ovsrecportsetinterfacesport iface here memory was allocated in parse function while parsed flag was not set br ovsrecbridgeinsertctxtxn ovsrecbridgesetnamebr brname ovsrecbridgesetportsbr port the same issue At the end when port and br rows were deallocated memory allocated in parse functions were not deallocated I have overcame this issue by replacing ovsdbidlrowparsed guard flag which implies that all columnsfields were parsed or not with ovsdbidlrowparsedcolumns bitmap which for each individual column marks if it is parsed or not Signedoffby damijans damjanskvarcgmailcom Even if pmdrxqaffinity have been set the pmd that this interface RX queue map to will no been isolated if this value set to true passthrough expects source network in logicalip column and destination network in externalip column For the traffic that goes from source to destination passthrough disables NAT by adding a priority flow with a match of ip ip src A ip dst B and an action of next Signedoffby Rostyslav Fridman rostyslavfridmanepamcom This patch modifies systemtrafficat at points of some long lines that results in the patch getting corrupted by gmail by the time it reaches patchwork Hence I am submitting as a pull request commit d aeabff b ba f f d dfabfaa Added pkgconfig support for libovn and the corresponding modifications This patch update information for faucetrst with Update from docker build t faucetfaucet to docker build t faucetfaucet f Dockerfilefaucet Because the Dockerfile name is not standard so need to pass Dockerfile name Here are link to Dockerfile Update the requirement for MAC learning and ARP timeouts When ovsdbserverservice is restarted theres a time window during which clients arent able to connect to the socket To cope with this systemd is able to manage the sockets and pass it to the services This patch set makes use of the facility