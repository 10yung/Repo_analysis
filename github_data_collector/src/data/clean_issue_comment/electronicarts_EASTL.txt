Add pushback move rvalue flavour in order to code like eastlmovecontainerbegin containerend eastlbackinsertercontainer to work as intended which is to use moveversion of pushback obviously deque seems to explicitly require a copyable type even if its movable Other STL implementations arent this strict instead using move constructionassignment for basic operations like emplaceback and popfront Offending line Why does eastlrbtree have to provide these template typename U typename Compare iterator findasconst U u Compare compare template typename U typename Compare constiterator findasconst U u Compare compare const instead of using the std way of achieving this by supplying an explicit stdless instead of relying on the default stdlessT as the compare class template argument and using the following transparent query methods instead template class K iterator find const K x template class K constiterator find const K x const which do not require an explicit compare object to be passed That way one can just pass stdstringview for instance to a stdmap with stdstring keys without having to construct an actual stdstring for the lookup Maybe it is possible to even go one step further and just use stdless and eastlless as defaults Hi We have some issue using eastlfixedvector that forbids heap allocations ie has bEnableOverflow false when compiling code as simple as that eastlfixedvectorint false v vinsertvbegin This compiles fine when using MSVC v toolset both Windows PC and Xbox One latest PS Clang and WSL Ubuntus GCC but fails missurably when I try to compile it on CentOS using GCC EASTLincludeEASTLinternalcopyhelph In member function void eastlvectorT AllocatorDoInsertValueeastlvectorT Allocatorconstiterator Args with Args const int T int Allocator eastlfixedvectorallocator false eastldummyallocator EASTLincludeEASTLinternalcopyhelph error G F A argument null where nonnull expected Werrornonnull return Tmemmoveresult first sizetuintptrtlast uintptrtfirst last first In file included from homebuildusergnugccincludec cstring from codeincCoreCoreh from codesrcGamePrecompiledh usrincludestringh note in a call to function void memmovevoid const void sizet declared here extern void memmove void dest const void src sizet n Note that GCC with O issues Wnonnull warning which we treat as error I believe it somehow manages to reveal that eastlfixedvectorallocator returns nullptr when fixed storage is exhausted even though we want to ignore that kind of checks as we disabled overflow on purpose The problem is somewhat subtle and is very hard to reproduce After all we observe that only when using CentOS manually installed compiler toolchain if I remember correctly CentOS comes with GCC by default which is pretty old by any means My collegue kind of managed to reproduce this behaviour in Compiler Explorer Here vDoAllocate is passed as an arguement to memmove through the call to an intermediate function Changing anything in the example will likely hide the problem but there it is Im not sure what to do with the error For now I plan to disable Wnonnull but may be theres a better way Im using eastl to build my own engine and Im surprised that something as simple as splice it calling a copy operator This causing both performance problem and annoying architecture problem for me especially when I want to use stuff like Atomic here is a test code to isolate the problem include list include EASTLlisth class C public C default Cconst C delete CC delete define useEA ifdef useEA typedef eastllistC list else typedef stdlistC list endif int main list l l emplaceback l emplaceback list l l emplaceback l emplaceback l splicel end l l begin if you comment the line define useEA it will compile properly without any problem but if you keep it you will get something like includeEASTLlisth error call to deleted constructor of eastllistC eastlallocatorvaluetype aka C newvoid pNodemValue valuetypeeastlforwardArgsargs includeEASTLlisth note in instantiation of function template specialization eastllistC eastlallocatorDoCreateNodeconst C requested here nodetype const pNode DoCreateNodevalue includeEASTLlisth note in instantiation of member function eastllistC eastlallocatorinsert requested here insertposition i using clang with stdc According to the original STL No elements are copied or moved only the internal pointers of the list nodes are repointed which is definitely super useful when you want to move heavy object or having conditions where its not a good idea to copy