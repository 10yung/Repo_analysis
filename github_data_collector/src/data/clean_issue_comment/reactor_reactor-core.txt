See See also conversation in Expected Behavior FluxSinkonDispose should not invoke callbacks before a terminal signal or a cancellation Actual Behavior If a callback is already attached FluxSinkonDispose will invoke the provided callback immediately Steps to Reproduce java Test public void repoCase var cleanedUp new AtomicBoolean Fluxcreatesink sinkonDispose cleanedUpsettrue sinkonDispose cleanedUpsettrue should not be invoked before sink is disposed assertFalsecleanedUpget sinkcomplete assertTruecleanedUpget subscribe Possible Solution support multiple disposables or throw exception if disposable is already attached or mention current behavior in documentation Your Environment Reactor versions used RELEASE JVM version java version openjdk version OpenJDK Runtime Environment Zulu CA build MTS OpenJDK Bit Server VM Zulu CA build MTS mixed mode sharing OS and version eg uname a Linux o box bpo amd SMP Debian bpo x GNULinux From I cant verify because the step before bufferUntil is concatMapIterable which produces a collection of allocated items and those dont seem to pass through doOnDiscard in case of a downstream error Could there be an issue with concatMapIterable Here is a simplified test java Test void concatMapIterableDoOnDiscardTest Foo foo new Foo Foo foo new Foo Foo foo new Foo FluxFoo source Fluxjust concatMapIterablei ArraysasListfoo foo foo doOnDiscardFooclass Foorelease StepVerifiercreatesource consumeNextWithfoo foorelease thenCancel verify assertThatfoo getRefCountisEqualTo okay assertThatfoo getRefCountisEqualTo fails assertThatfoo getRefCountisEqualTo fails static class Foo int refCount public int getRefCount return thisrefCount public void release thisrefCount Originally posted by rstoyanchev in Provide a general summary of the issue in the Title above Make sure to follow the Contribution Guidelines notably for security issues and questions Expected Behavior Tell us what you think should happen According to the javadoc onErrorContinue should recover from errors by dropping the incriminating element from the sequence and continuing with subsequent elements Actual Behavior Tell us what happens instead of the expected behavior In an possibly infinite Flux after invocations of onErrorContinue the Flux stops processing elements Steps to Reproduce Provide a link to a live example or an unambiguous set of steps to reproduce this bug eg a unit test Include code to reproduce if relevant java Test public void repoCase int numberOfRequests SetInteger sink new HashSet Flux fromStreamIntStreamrange numberOfRequestsboxed mapsinkadd flatMapi Monoerrornew Exceptionany onErrorContinuethrowable o subscribe Threadsleep AssertionsassertNotEqualsnumberOfRequests sinksize AssertionsassertEquals sinksize Possible Solution Not obligatory but you can suggest a fixreason for the bug I have no clue how to solve this Just the fact that it is reproducible let me guess that some kind of state or metainformation like the Context is stored within just one bit an is just full after entries Your Environment Include as many relevant details about the environment you experienced the bug in Especially always include the versions of Reactor librarylibraries you used I used a standard spring boot application created from the initializer with spring boot version RELEASE Thus the version of reactor core is RELEASE Reactor versions used Other relevant libraries versions eg netty JVM version javar version java version JavaTM SE Runtime Environment build b Java HotSpotTM Bit Server VM build b mixed mode OS and version eg uname a Windows Enterprise Version I already asked the question in the community but didnt receive any answer but comments on how to circumvent onErrorContinue Provide a general summary of the issue in the Title above Expected Behavior windowUntil should complete regardless of the prefetch value According to the documentation Prefetch is a way to tune the initial request made on these inner sequences My interpretation is that prefetch can be used to tune performance or order of operations but it shouldnt cause significant changes in behavior Actual Behavior windowUntil doesnt complete if prefetch is too small Therefore if windowUntil needs to correctly handle arbitrary inputs I believe prefetch should always be set to unbounded IntegerMAXVALUE Steps to Reproduce If prefetch is large enough or unbounded IntegerMAXVALUE this code generates WindowFlux and then completes java Fluxrange windowUntili i false IntegerMAXVALUE log subscribe onSubscribe Fuseable FluxWindowPredicateWindowPredicateMain requestunbounded onNextWindowFlux onNextWindowFlux onNextWindowFlux onNextWindowFlux onComplete However if prefetch is too small this code will print less than windows and never completes java Fluxrange windowUntili i false log subscribe onSubscribe Fuseable FluxWindowPredicateWindowPredicateMain requestunbounded onNextWindowFlux Possible Solution Not obligatory but you can suggest a fixreason for the bug Your Environment Include as many relevant details about the environment you experienced the bug in Especially always include the versions of Reactor librarylibraries you used Reactor versions used DysprosiumSR Other relevant libraries versions eg netty JVM version javar version OpenJDK Runtime Environment AdoptOpenJDK build OS and version eg uname a Windows Version Provide a general summary of the issue in the Title above BlockHound sometimes detects blocking call on cancel timeout task Make sure to follow the Contribution Guidelines notably for security issues and questions Expected Behavior Tell us what you think should happen BlockHound should not detect blocking calls in reactorcore Actual Behavior Tell us what happens instead of the expected behavior BlockHound detects blocking calls in reactorcore Steps to Reproduce Provide a link to a live example or an unambiguous set of steps to reproduce this bug eg a unit test Include code to reproduce if relevant Here is code which could reproduce issue java BeforeAll static void setUp BlockHoundinstall Test void cancelTimeoutBlocks Scheduler sc SchedulersnewParallelmysc true FluxLong test FluxintervalDurationZERO DurationofMillis flatMapit return Monojustithide timeoutDurationofMillis subscribeOnsc subscribeOnSchedulersparallel takeDurationofMillis testblockLast Run it and check for logs mysc ERROR reactorcoreschedulerSchedulers Scheduler worker in group main failed with an uncaught exception javalangError Blocking call jdkinternalmiscUnsafepark at reactorblockhoundBlockHoundBuilderlambdanew BlockHoundjava at reactorblockhoundBlockHoundBuilderlambdainstall BlockHoundjava at reactorblockhoundBlockHoundRuntimecheckBlockingBlockHoundRuntimejava at javabasejdkinternalmiscUnsafeparkUnsafejava at javabasejavautilconcurrentlocksLockSupportparkLockSupportjava at javabasejavautilconcurrentlocksAbstractQueuedSynchronizerparkAndCheckInterruptAbstractQueuedSynchronizerjava at javabasejavautilconcurrentlocksAbstractQueuedSynchronizeracquireQueuedAbstractQueuedSynchronizerjava at javabasejavautilconcurrentlocksAbstractQueuedSynchronizeracquireAbstractQueuedSynchronizerjava at javabasejavautilconcurrentlocksReentrantLocklockReentrantLockjava at javabasejavautilconcurrentScheduledThreadPoolExecutorDelayedWorkQueueremoveScheduledThreadPoolExecutorjava at javabasejavautilconcurrentThreadPoolExecutorremoveThreadPoolExecutorjava at javabasejavautilconcurrentScheduledThreadPoolExecutorScheduledFutureTaskcancelScheduledThreadPoolExecutorjava at reactorcoreschedulerSchedulerTaskdisposeSchedulerTaskjava at reactorcorepublisherMonoDelayMonoDelayRunnablecancelMonoDelayjava at reactorcorepublisherOperatorsMultiSubscriptionSubscriberdrainLoopOperatorsjava at reactorcorepublisherOperatorsMultiSubscriptionSubscriberdrainOperatorsjava at reactorcorepublisherOperatorsMultiSubscriptionSubscribercancelOperatorsjava at reactorcorepublisherOperatorsterminateOperatorsjava at reactorcorepublisherStrictSubscribercancelStrictSubscriberjava at reactorcorepublisherFluxTimeoutTimeoutTimeoutSubscribercancelFluxTimeoutjava at reactorcorepublisherFluxTimeoutTimeoutMainSubscriberonNextFluxTimeoutjava at reactorcorepublisherFluxHideHideSubscriberonNextFluxHidejava at reactorcorepublisherOperatorsScalarSubscriptionrequestOperatorsjava at reactorcorepublisherFluxHideHideSubscriberrequestFluxHidejava at reactorcorepublisherOperatorsMultiSubscriptionSubscribersetOperatorsjava at reactorcorepublisherFluxTimeoutTimeoutMainSubscriberonSubscribeFluxTimeoutjava at reactorcorepublisherFluxHideHideSubscriberonSubscribeFluxHidejava at reactorcorepublisherMonoJustsubscribeMonoJustjava at reactorcorepublisherMonosubscribeMonojava at reactorcorepublisherMonoSubscribeOnSubscribeOnSubscriberrunMonoSubscribeOnjava at reactorcoreschedulerWorkerTaskcallWorkerTaskjava at reactorcoreschedulerWorkerTaskcallWorkerTaskjava at javabasejavautilconcurrentFutureTaskrunFutureTaskjava at javabasejavautilconcurrentScheduledThreadPoolExecutorScheduledFutureTaskrunScheduledThreadPoolExecutorjava at javabasejavautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javabasejavautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javabasejavalangThreadrunThreadjava Possible Solution Not obligatory but you can suggest a fixreason for the bug Probably extend allowed blocking methods or document it Your Environment Include as many relevant details about the environment you experienced the bug in Especially always include the versions of Reactor librarylibraries you used Reactor versions used reactorcore RELEASE blockhound RELEASE Other relevant libraries versions eg netty JVM version javar version openjdk version OpenJDK Runtime Environment build OpenJDK Bit Server VM build mixed mode OS and version eg uname a Win Motivation When integrating with external APIs there is often limits like one request per minute With the reactor it would be extremely useful to limit the calls to such API by limiting FluxApiRequest with according operator There might be other usecases when it would be useful to limit quantity of processed object in period of time Desired solution Code might look like this java Fluxgenerate s sink sinknexts return s limitRate DurationofMinutes subscribeo SystemoutprintlnGot ints per minute Considered alternatives We came up with custom implementation of such operator and using it via transformDeferred java Fluxgenerate s sink sinknexts return s transformDeferredflux FluxUtillimitRateflux DurationofMinutes subscribeo SystemoutprintlnGot ints per minute The problem Since expand is an operator the one has to have a bit of a code duplication to use it java FluxPage flux clientfetchPagenullexpandit return Mono justOrEmptyitnextPageId flatMapnextPageId clientfetchPagenextPageId Here clientfetchPage is duplicated Proposal It would help to have a factory method with a default state java public S T FluxT expand SupplierS stateSupplier FunctionT S stateExtractor FunctionS extends PublisherT expander And use it like this java flux Fluxexpand Optionalof PagenextPageId it return MonojustOrEmptyit flatMapnextPageId MonofromCompletionStage clientfetchPagetrimToNullnextPageId We have a pretty complex pipeline including FluxswitchMap Under high load it is trowing following NPE java javalangNullPointerException null at reactorcorepublisherFluxSwitchMapSwitchMapInnerdeactivateFluxSwitchMapjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxSwitchMapSwitchMapMainonNextFluxSwitchMapjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxFilterFilterSubscriberonNextFluxFilterjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxConcatArrayConcatArraySubscriberonNextFluxConcatArrayjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxFilterFilterSubscriberonNextFluxFilterjava reactorcore RELEASEjar RELEASE at reactorcorepublisherEmitterProcessordrainEmitterProcessorjava reactorcore RELEASEjar RELEASE at reactorcorepublisherEmitterProcessorEmitterInnerdrainParentEmitterProcessorjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPublishPubSubInnerrequestFluxPublishjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxConcatMapConcatMapImmediatedrainFluxConcatMapjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxConcatMapConcatMapImmediateinnerCompleteFluxConcatMapjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxConcatMapConcatMapInneronCompleteFluxConcatMapjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPeekPeekSubscriberonCompleteFluxPeekjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPeekPeekSubscriberonCompleteFluxPeekjava reactorcore RELEASEjar RELEASE at reactorcorepublisherMonoIgnoreElementsIgnoreElementsSubscriberonCompleteMonoIgnoreElementsjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPeekPeekSubscriberonCompleteFluxPeekjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPeekPeekSubscriberonCompleteFluxPeekjava reactorcore RELEASEjar RELEASE at reactorcorepublisherMonoFlatMapManyFlatMapManyInneronCompleteMonoFlatMapManyjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPublishOnPublishOnSubscriberdoCompleteFluxPublishOnjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPublishOnPublishOnSubscribercheckTerminatedFluxPublishOnjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPublishOnPublishOnSubscriberrunAsyncFluxPublishOnjava reactorcore RELEASEjar RELEASE at reactorcorepublisherFluxPublishOnPublishOnSubscriberrunFluxPublishOnjava reactorcore RELEASEjar RELEASE at reactorcoreschedulerWorkerTaskcallWorkerTaskjava reactorcore RELEASEjar RELEASE at reactorcoreschedulerWorkerTaskcallWorkerTaskjava reactorcore RELEASEjar RELEASE at javabasejavautilconcurrentFutureTaskrunFutureTaskjava nana at javabasejavautilconcurrentScheduledThreadPoolExecutorScheduledFutureTaskrunScheduledThreadPoolExecutorjava nana at javabasejavautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava nana at javabasejavautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava nana at javabasejavalangThreadrunThreadjava nana Expected Behavior Concurrent cancelonNext calls should be handled with proper synchronization Steps to Reproduce Issue could be reproduce with latest master However I can reproduce issue only when running test in debug mode from IDE Stacktrace was from actual docker container in running env java Test public void shouldProcessNextForCancelledInner AssertSubscriberLong payloadSubscriber AssertSubscribercreate AssertSubscriberVoid concurrentSubscriber AssertSubscribercreate EmitterProcessorLong payloadProcessor EmitterProcessorcreate false payloadProcessorswitchMapevent Fluxjust LsubscribepayloadSubscriber payloadProcessoronNext L Monowhen Fluxrange mapIntegerlongValue flatMapevent MonofromRunnable payloadProcessoronNextevent subscribeOnSchedulerselastic MonodelayDurationofMillis thenMonofromRunnablepayloadSubscribercancel subscribeconcurrentSubscriber concurrentSubscriber awaitDurationofMillis L assertComplete Possible Solution FluxSwitchMap should check for cancelled inner in FluxSwitchMaponNext java SwitchMapInnerR si inner if si null sideactivate sicancel java SwitchMapInnerR si inner if si null si CANCELLEDINNER sideactivate sicancel Your Environment Reactor versions used JVM version javar version openjdk version OpenJDK Runtime Environment AdoptOpenJDK build OpenJDK Bit Server VM AdoptOpenJDK build mixed mode OS and version eg uname a Linux legionerwork generic Ubuntu SMP Thu Nov UTC x x x GNULinux 