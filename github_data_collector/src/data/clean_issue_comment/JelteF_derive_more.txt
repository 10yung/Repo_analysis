Hi This code rust deriveDeref DerefMut pub struct HasTT where T Clone Send Sync static Expands to rust impl T coreopsDeref coreopsDeref for HasT where T Clone Send Sync static type Target T inline fn deref self SelfTarget self impl T coreopsDerefMut coreopsDerefMut for HasT where T Clone Send Sync static inline fn derefmut mut self mut SelfTarget mut self But T need not be bounded coreopsDeref We have a lot of instances of this pattern rust deriveDebug PartialEq Eq Hash Clone Copy DieselNewType Serialize Deserialize From Into Display pub struct FooUuid impl FromStr for Foo type Err MyError fn fromstrs str ResultSelf SelfErr Ok Foo sparse maperrerr MyErrorInvalidFooerr Backtracenew We currently cant use deriveFromStr to reduce this boilerplate but it would be nice if support for wrapping the error using a custom function could be added Eg rust deriveFromStr fromstr err MyErrorInvalidFooerr Backtracenew struct FooUuid Or similar Would that be possible Implementation is mostly done but there are unresolved issues The way State process attributes need some reorganization stateattributeprocessingissue Right now Ive worked around it by sticking conditional on deriving Error right into State code stateattributeprocessingissueworkaround Im not sure what is the proper way to unstablefeaturegate macrogenerated code macrogeneratedcodefeaturegating Im not sure what is the proper way to enabledisable tests for unstable features eg backtrace testsfeaturegating testsfeaturegating stateattributeprocessingissue stateattributeprocessingissueworkaround macrogeneratedcodefeaturegating testsfeaturegating testsfeaturegating Love the library thanks for your work Wanted to point out a small bug I have a struct like rust allowclippytoomanyarguments deriveConstructor Clone pub struct SomeStruct pub field String pub field String The allow attribute doesnt seem to get passed through to the generated constructor Id expect this to work generally for lints Thanks Theres not really a reason to derive from for for variants without fields Its somewhat unexpected and results in the problems described here in Lets remove this in the next breaking release probably This would allow the same flexibility thats provided by derivenew for From TryFrom FromStr and Constructor It would also be nice to add new as a derive as well so derivemore can be a dropin replacement for derivenew As was initially proposed in it would be very useful to have a general way of deriving for enums The basic idea is that when theres an enum we all variants forward to their fields So in case of Index something like the following would work rust deriveIndex enum VecOrSliceslice VecVec Slice slice We can currently forward From but not TryFrom Implementing this for a single field would be fairly easy For multiple fields this would be harderimpossible because we would have to figure out what to do with the multiple possibly different errors that you can get This would probably mean creating a temporary enum For TryInto we only support deriving it for an enum but we dont allow forwarding it to the inner field This should also be supported For a struct with multiple fields this would have the same problem as TryFrom tyranron I thought some more about your idea for deriving only Error with deriveError in and I think its a great idea I also saw the new thiserror crate coming by on reddit which has some cool ideas I put some ideas on how to add those to derivemore here I asked the author if he wanted to work together on this but it seems he isnt a fan of that which is completele fine ofcourse Please let me know what you think of this syntax and if youre indeed going to pick it up For completeness here is the content of my comment with ideas the rest of the issue thread is also useful for context Thats definitely a good point Some options I can think of rust Specific solution for error that does auto detection of backtrace field deriveFrom Debug enum EnumError fromerror Exampleerror ioError backtrace Backtrace NotFromablei rust More general but more verbose deriveFrom Debug enum EnumError Example error ioError fromdefaultBacktracecapture backtrace Backtrace NotFromablei Because of the way Ive implemented attribute handling the first one would also work easily for the big struct by putting the from attribute on the enum rust deriveFrom Display Error displayE prefix fromerror pub enum E displayio error E source ioError backtrace Backtrace E source serdejsonError backtrace Backtrace E source regexError backtrace Backtrace E source hyperError backtrace Backtrace E source anyhowError backtrace Backtrace fromignore sourceignore maybe errorignore displaywrong count count SomeCustomErrorcount i backtrace Backtrace Ill think a bit more about this but I actually like the option above quite a bit Im not sure if this has been proposed before but has there been any thought to implementing support for deriving the Read and Write traits from stdio I think it might be useful to save boilerplate when making an enum where each of the variants contains something that implements ReadWrite