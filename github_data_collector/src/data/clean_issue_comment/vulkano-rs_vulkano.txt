Im trying to upload data to an image that Im also using for rendering Ideally I shouldnt have to worry about sync since Im only using one queue but unless I signal a fence and wait for it after rendering and before uploading I get an AccessError AlreadyInUse If I dont also wait for the GPU after uploading the application seems to work as intended but the validation layer I have active complains VUIDvkQueueSubmitpCommandBuffers ERROR SPEC msgNum VkCommandBuffer x df cb f is already in use and is not marked for simultaneous use The Vulkan spec states If any element of the pCommandBuffers member of any element of pSubmits was not recorded with the VKCOMMANDBUFFERUSAGESIMULTANEOUSUSEBIT it must not be in the pending state Objects type name NULL UNASSIGNEDCoreValidationDrawStateCommandBufferSingleSubmitViolationERROR SPEC msgNum VkCommandBuffer x df cb f was begun w VKCOMMANDBUFFERUSAGEONETIMESUBMITBIT set but has been submitted x times Objects type name NULL Heres some pieces of my code Ill try to make a minimum working example when I have time rust Draw let commandbuffer AutoCommandBufferBuilderprimaryonetimesubmitwindevice winqueuefamily unwrap beginrenderpassframeframebuffer false clearvaluesclone unwrap draw pipelineclone windynamicstate BufferlessVertices vertices instances descclone pc unwrap endrenderpass unwrap build unwrap let f future joinframeacquire thenexecutewinqueueclone commandbuffer unwrap thenswapchainpresentwinqueueclone winswapchainclone frameimagenum thensignalfenceandflush match f Okf future Boxnewf as Box ErrvulkanosyncFlushErrorOutOfDate recreateswapchain true future Boxnewvulkanosyncnowwindevice as Box Errerr Well keep going its probably not a big deal println err future Boxnewvulkanosyncnowwindevice as Box Another thread sends a list of blocks of the image to update if let Okupdate recvtryrecv AccessError if I remove this future thensignalfenceandflush unwrap waitNone unwrap future Boxnewvulkanosyncnowwindevice for loc data in updateblocks let b blockbufchunkdataunwrap let cmd AutoCommandBufferBuilderprimaryonetimesubmit windevice winqueuefamily unwrap copybuffertoimagedimensions b imageclone loc unwrap build unwrap future Boxnewfuturethenexecutewinqueueclone cmdunwrap Validation layer complains if I remove this future thensignalfenceandflush unwrap waitNone unwrap future Boxnewvulkanosyncnowwindevice Im using Vulkano on Arch Linux with a Radeon R x with mesas RADV EDIT Heres a gist with a single file demonstrating the issue Version of vulkano OS Windows x GPU the selected PhysicalDevice GeForce GTX GB GPU Driver Issue I am trying to copy pixel data from buffer to an image using copybuffertoimagedimensions function This in result calls checkcopybufferimage which performs validation The format of pixel data that I am uploading is compressed and has blocks with size of x pixels where each block weights bytes BC RGBUnormBlock FORMATBC RGBUNORMBLOCK Some compressedtexturecompressionbc u That means if I upload x texture that has x blocks the buffer size should be x x bytes The vulkano however reports that this is not enough bytes to fill the image buffer dimsDim d width height formatBC RGBUnormBlock blockdimensions thread main panicked at called Resultunwrap on an Err value CheckCopyBufferImageErrorBufferTooSmall requiredlen actuallen The broken code seems to be in the file srccommandbuffervaliditycopyimagebufferrs on the line For me it is not clear why is the size of image computed in this way rust let blockwidth blockheight imageformatblockdimensions let numblocks imagesize blockwidth blockwidth imagesize blockheight blockheight imagesize imagenumlayers let requiredlen numblocks as usize imageformatrate as usize if requiredlen bufferlen return ErrCheckCopyBufferImageErrorBufferTooSmall requiredlen requiredlen actuallen bufferlen When vulkanoshaders generates Rust data types for each uniform block in the shader it would be useful if it could also generate an implementation of Default for those types That way they can be initialised without knowing all the values up front And more importantly the user can skip having to initialise dummy values that are only for padding and dont matter otherwise x Added an entry to CHANGELOGVULKANOmd or CHANGELOGVKSYSmd if knowledge of this change could be valuable to users Updated documentation to reflect any userfacing changes in this repository Updated documentation to reflect any userfacing changes PR to the guide that fixes existing documentation invalidated by this PR Fixes ease integration with windowing apis My current solution to integrate glfw in my project has been to create my own RawInstanceExtensions struct and transmuting it to a vulkano RawInstanceExtensions This solution is very ugly so I added the helper function and some documentation in the code The function is unsafe to make it clear to the user that they need to be careful while using it I know Vulkano is about creating a safe api but this should be unsafe since misuse could cause odd behaviour Template If you dont understand something just leave it If you can provide more detailed information than the template allows for please ignore the template and present all of your findings Version of vulkano OS Fedora GPU the selected PhysicalDevice RX XT GPU Driver radv in kernel fn main initglfw let monitorcount getmonitorcount let window VulkanWindownewwindowedYo use glfwnative println getvulkanoextensions let inst InstancenewOptionNone getvulkanoextensions OptionNoneexpectFailed to create vulkan instance let surface windowgetvulkanosurface inst let physical PhysicalDeviceenumerate instnextexpectOops there is no device let queuefamily physicalqueuefamiliesfindq qsupportsgraphicsexpectThere is no queue family that support graphics let deviceext vulkanodeviceDeviceExtensions khrswapchain true vulkanodeviceDeviceExtensionsnone let device mut queues Devicenewphysical Featuresnone deviceext queuefamily iterclonedexpectCould not create device let queue queuesnextunwrap printlnpre pre start let caps surfacecapabilitiesphysical expectfailed to get surface capabilities printlnpre start let dimensions capscurrentextentunwrapor let alpha capssupportedcompositealphaiternextunwrap let format capssupportedformats let swapchain images Swapchainnewdeviceclone surfaceclone capsminimagecount format dimensions capssupportedusageflags queue SurfaceTransformIdentity alpha PresentModeFifo true OptionNone expectfailed to create swapchain while windowshouldclose unsafe glfwPollEvents printlnstart let imagenum acquirefuture vulkanoswapchainacquirenextimageswapchainclone OptionNoneunwrap let cmdbuf AutoCommandBufferBuildernewdeviceclone queuefamilyunwrap clearcolorimageimages imagenum clone ClearValueFloat unwrap let future acquirefuturethenexecutequeueclone cmdbufbuildunwrapunwrap let present futurethenswapchainpresentqueueclone swapchainclone imagenumthensignalfenceandflush printlnlooop stdthreadsleepDurationnew The program outputs pre pre start Does anyone know why this could be Ps its a xcb surface I was testing the example and saw that the Swapchain Constructor dont need a Colorspace as an Parameter only an old Swapchain so i fixed that Today I tried to subscribe for updates from vulkano in slack but it turned out slack needs to be installed for the repo before I can do that could somebosy please do that Assuming there arent any reasons not to The Swapchainnewinner function requires a SharingMode value But the function doesnt actually do anything when you provide SharingModeExclusive the inner value just gets discarded This matches the Vulkan spec which determines queue ownership based on first use Vulkano shouldnt require the user to provide a dummy value here Issue The vulkanoshadersshader macro as part of the vulkanoshaders rust module has trouble identifying storage buffers in the descriptor layout I am using the compute shader example from glsl version layoutlocalsizex localsizey localsizez in layoutset binding buffer Data uint data buf void main uint idx glGlobalInvocationIDx bufdata idx When using this shader the generated descriptor for set binding is seen as a uniform leading the buffer being passed to PersistantDescriptorSetnew being seen as a uniform buffer This causes the validationlayer error that is printed on line of the programs output I decided to run cargo expand computeshader to see what the generated descriptors for the compute shader were Most notably the storage attribute of the generated Layouts DescriptorDesc for usize usizes DescriptorBufferDesc is set to false on line of the macro expansion output System Details Version of vulkano OS Linux Ubuntu GPU the selected PhysicalDevice Nvidia GTX GB GPU Driver NVIDIA Link to mainrs mainrs Link to repository Kneelawkcomputeerrorexample glslangValidator Details Glslang Version ESSL Version OpenGL ES GLSL glslang Khronos GLSL Version glslang Khronos SPIRV Version x Revision GLSLstd Version Revision Khronos Tool ID SPIRV Generator Version GLKHRvulkanglsl version ARBGLglspirv version glslc Details glslc is not installed Possibly Related Compute shader shader example doesnt perform compute on mac compute shader example fix descriptor set codegen for SSBO after spirv update 