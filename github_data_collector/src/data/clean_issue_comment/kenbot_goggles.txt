On my poor Windows default the unicode borders of the fancy error tables turn into question marks Sections Types Optics myBasket ShoppingBasket items ShoppingBasket List Item Getter List Item Item Traversal returning Fold name Item getmyBasketitemsname I wonder if theres some way to detect this and switch to ASCII hyphens pipes or just use them and forget the fancy stuff I was trying to use goggles to modify a value inside a case class with a type parameter type parameters should remain the same Simplified code like this scala import goggles case class Boxed A get A setBoxed get results in following error The types of consecutive sections dont match found PlaygroundthisBoxed Int required PlaygroundthisBoxed Int Sections Types Optics Boxed Int get Boxed Int A Setter while I would expect Boxed it would be nice even if compiletime error was less misleading This is more for discussion rather than saying we should do it now but I want to note that dotty seems to be going in the direction of using more string interpolation eg XML literals will likely be replaced as interpolated strings and Id hazard a guess that using VS Code with it or any other editor that supports the language protocol in the future would actually show syntax errors within an editor When a literal is interpolated in an index position the type is overspecialised to the exact literal instance type Int Stringabc Chara etc rather than the expected type Int String Char I believe the problem lies in the code that parses the implicit monoclefunctionIndex SIA instance Example scala val x Mapa b c x scalacollectionimmutableMap StringInt Mapa b c scala getx a console error No implicit monoclefunctionIndex scalacollectionimmutableMap StringInt Stringa found to support indexing scala getx a String res Option Int Some Currently if Yrangepos is not set then interpolated args cannot be displayed in the leftmost column of the error table and the position of the indicator cannot be accurately set We should gracefully show something meaningful such as ARG for the argument names rather than an empty string and fixing the at the start of the expression We could also print a message that suggests that the user add scalacOptions Yrangepos to buildsbt Specs doesnt have a great ScalaJS story at the moment We are not using any fancy features with our tests at the moment we just need asserts and ScalaCheck If we move our tests to uTest instead we should be able to run them cross platform so ScalaJS is tested too Monocle is adding support We should too A common Monocle idiom currently unsupported by Goggles is composing lens setmodify expressions before the object is applied This returns an endofunction with pleasing compositional properties For instance val x Item Item itemQtyLensmodify andThen itemPriceLensset It also aligns with the common FP intuition of compose first many times execute last once Is there some way to support this idiom in getset modes without making everything weird and complicated One way might be to allow a from MyType type hint as per in the leftmost position instead of the source object which would return an endofunction rather than the usual result This might prove a confusing special case though Lens mode has to start with an interpolated optic so that it knows the type to start with If you want to start with something else its possible to put a monocleIsoid MyType in the leftmost position which does the trick ie lensIsoid Blah foobar However this has some problems Requires the user to know about the concept of an Iso just for an implementation hack to supply the type to the macro Isnt very you already know how do it requires detailed knowledge of Monocles API Adds an additional method calls at runtime Adds a pointless Iso line at the top of the compile error table One idea is to have a method with an obvious name which one returning Isoid that is in scope with an import goggles With the right name this might arguably barely satisfy you already know how to use it but wouldnt fix the performance Performance Isoid cannot itself be changed to override composition to just return the other thing because the composeXXX methods are final and should probably stay that way However if we make our own type that behaves exactly like Iso we can make it have zero runtime overhead While it essentially functions as a terminal object in the lens hierarchy it might be better called TypeHint rather than IdIso which is its actual reason for existing We could easily make the error tables omit or specially handle the TypeHint line at the start Code quality A benefit here is that getset modes could use this approach too instead of the AppliedObjectconst Unit A Iso hack This could mean more unified code with less special cases and the generated code would be more recognisable Monocle code with the object applied at the end This would also improve their performance as there would no longer be an runtimeunnecessary Iso at the start Naming This is probably the hardest part of this ticket There probably isnt a name that a typical user already knows Too rare and its just yet another obscure library curiosity Too common and there will be namespace problems for users Some examples lenschoose Blah foobar lensselect Blah foobar lensselectType Blah foobar lenstypeOf Blah foobar lenst Blah foobar lenson Blah foobar lensfrom Blah foobar lensfromType Blah foobar lenstyped Blah foobar julientruffaut mentioned that Lenses still cause a performance overhead around x comparing to hand written copy as measured with jmh Since Goggles is generating code anyway could we gain a speedup by directly generating the underlying code for chains of name optics Getters would fuse into a single Getter with direct method calls foobarbaz Setters would fuse into nested copy calls foocopybar foobarcopybaz new thing Lenses could fuse both Dont forget that lens mode might produce Isos as well pending We would have to examine the produced bytecode to ensure parsimony and we would have to introduce benchmarks to demonstrate that sufficiently impressive speedups occur in practice Since we would still want to provide the illusion of the segments being separate optics ie in the fancy error message table some clever software engineering might be required to maintain a modular design within the macro code