 I know that backbone likes to call destroy on each model but in my particular case it would be nice to be able to destroy all models in a collection with one call to speed up the process My scenario I am using Appcelerator which uses backbone collections to bind models to a list view Say I have models in the collection bound to the listview This listview contains leads customers who made a call to a dealership in the past days Now I only want to show the customers who made calls to the dealer in the past days I could use reset but that does not remove the models so the current list would still show the day list instead of the day list In order to show the day list I have to run a loop to destroy each model in the collection and repopulate the collection The destroy loop for just items takes about seconds while adding the items takes under a second Without being able to remove all at once the UI since Appcelerator runs on the main thread is frozen until all the models are deleted Currently there is no workaround for this issue This PR fixes issue where a model was not properly removed from a collection after its ID was unset The cause for this is that onModelEvent handles potential model deletions upon detecting an event called change when the actual event name being sent was changeattribute An extra check was added so that the latter case is handled as well Hi there Were having a strange issue when using a collection of models with custom idAttribute Basically if idAttribute attribute has a value that looks like cid c c etc the model is not added to collection or merged with some previously added model Please check the following simplified example const MyModel BackboneModelextend idAttribute myId const MyCollection BackboneCollectionextend model MyModel const list myId c name John myId c name James myId c name William myId c name Henry myId c name Michael myId c name Fred myId c name George myId c name Larry myId c name Peter myId c name Neil const testCollection new MyCollectionlist alerttestCollectionlength expected actual Or check this fiddle I believe this happens because Backbone stores models both by cid and idAttribute when available here Then during set it finds the previously stored by cid model and assumes its found a duplicate Now I understand that this looks like someones tried really hard to find a defect and created ids that look like cids but we actually use custom id attributes that are unique but dont follow same pattern they come from different sources and sometimes they actually look like cid Is there a reason why cid is still being used as key for byId even when models have idAttribute declared fixes issue collectionbyId is an internal object used solely for mapping ids to models and doesnt need any of the standard object prototype methods for its internal usage Unlikely to be a breaking change for any external uses unless someone is really hacking into the core backbone functionality and they can simply do things like ObjectprototypehasOwnPropertyapplycollectionbyId Alternative solution could be to use a Map object for collectionbyId but that would require many more code changes would not be supported in old browsers and is more likely to break external uses const collection new BackboneCollection const model new BackboneModel id hasOwnProperty collectionset model TypeError existingset is not a function In Collectionset it does var existing thisgetmodel which in this case is setting existing to ObjecthasOwnProperty rather than undefined because Collectionget is returning the result ofthisbyId hasOwnProperty Have reproduced this bug in a codepen here When using an ES class idAttribute should be returned from a getter rather than being set in the preinitialize function javascript class Meal extends BackboneModel get idAttribute return id Otherwise the following will not work javascript let model MealCollectiongetsomeId Due to the use of prototype in the collection function javascript Define how to uniquely identify models in the collection modelId functionattrs return attrs thismodelprototypeidAttribute id If a backbone model is an ES class with a statc property and one use Modelextend to make a subclass instead of the ES extends the static properties of the base model are not added to the subclass x fix the es version of the backbonelocalStorage rollup task for creating UMD bundle backbonejs x lodash underscore 