Is there a case of reconnection My setup typescript server and typescript client as different projects importing a common third project that contains sharedcommon stuff especially the data model and the Schema and exposes them as es modules Even with a simple Schema such as export class TestSchema extends Schema typenumber whatever When a client joins the server i get the error on the client JOIN ERROR Error SchemaSerializer error See at new MatchMakeError homestefanoprojectxprojectxwebclientnodemodulescolyseusjslibClientjs at Clientanonymous homestefanoprojectxprojectxwebclientnodemodulescolyseusjslibClientjs at step homestefanoprojectxprojectxwebclientnodemodulescolyseusjslibClientjs at Objectnext homestefanoprojectxprojectxwebclientnodemodulescolyseusjslibClientjs at fulfilled homestefanoprojectxprojectxwebclientnodemodulescolyseusjslibClientjs at anonymous at processtickDomainCallback internalprocessnexttickjs code and on the server Error SchemaSerializer error See at SchemaSerializerreset homestefanoprojectxprojectxservernodemodulescolyseuslibserializerSchemaSerializerjs at GameRoomsetState homestefanoprojectxprojectxservernodemodulescolyseuslibRoomjs at GameRoomonCreate homestefanoprojectxprojectxserversrcGameRoomts at homestefanoprojectxprojectxservernodemodulescolyseuslibMatchMakerjs at Generatornext anonymous at homestefanoprojectxprojectxservernodemodulescolyseuslibMatchMakerjs at new Promise anonymous at awaiter homestefanoprojectxprojectxservernodemodulescolyseuslibMatchMakerjs at createRoom homestefanoprojectxprojectxservernodemodulescolyseuslibMatchMakerjs at Objectanonymous homestefanoprojectxprojectxservernodemodulescolyseuslibMatchMakerjs If the TestSchema class is defined in the server project no error is encountered it only triggers when I import it from the common project The error fails on a instanceof check I guess because the server and the common project have different versions of the Schema class and therefore that check fails I have the usecase where reconnection is going to be disabled by some game rules so being based only by a timeout is not effective in this case eg disable reconnection after turns in a turnbased game Something like this typescript const reconnectionToken thisallowReconnectionclient await reconnectionTokenresolve later during game logic reconnectionTokencancel Hi I am currently wondering if it would be possible to return a promise for the listen function I am trying to catch errors using a try catch and await but the process keeps exiting I am creating the error by running servers on the same machine Unity and Defold HTML build have problems when connecting into a room without any state defined It should not be required to have a state to connect into the room in these environments We encountered a suspecious memory leak when using this framework the reservedSeatTimeouts of Room seems not release in some unkown reasons The cpu will grow slowly from to much higher We inspected the heap dump and found the reservedSeatTimeouts of room stored so many Timeout instances See below screenshot leak screenshot It seems in this function the thisreservedSeatTimeouts should delete the reservedSeatTimeoutdelete thisreservedSeatTimeouts sessionId when seats reservaltion expired Hi I added an instanceCount variable in RegisteredHandler to store the number of instances created for a given room Then I could check if a new room exceeds the maximum instance number defined in instanceLimit When I fetch the metadata from the server The room has existed for a long time and there is only one player in the room But metadataclients shows I think its a bug Colyseus version is and using MongoDB When the network connection time out It showed the error below How can I update the time out config Colyseus server version Nodejs version v Context Given the newer Matchmaking system currently using a local or mongoose MongoDB driver this presents problems when a local driver is not applicable to scalable solutions and the singular MongoDB solution presents more persistentstorage operations management Especially at larger scales Since Redis has a lack of querying support I propose a MySQL Driver for the Colyseus Gameserver Ill start work on this in a week or so at the present it wont support transactions As the MongoDB supports but is not currently used by Colyseus however since transactional queries are supported by MySQL this is still a potential future feature of the driver For now the driver will serve a for now personal vendatta against having to manage different operational database structures for the sake of scalability Redis for presence MySQL for persistent storage MongoDB for Room discovery This issue will track my progress