 alyzer Work towards reducing CompilationEnd analyzers in the repo ation analyzer Fixes This was reported internally as a slow analyzer for multiple repros Primary slowdown seems to be coming in GetSymbolInfo invocations for every single object creation node Analyzer package MicrosoftCodeAnalysisFxCopAnalyzers Package Version v Latest Diagnostic ID Example CA Repro steps create a method that accept a non nullable reference like this public void HandleEventBase theEvent theEventDoAnything theEventDoAnything will complain about even if the is applied to the expression Expected behavior CA should be NRT nullable reference type aware in order to not trigger when are are confident about never pass a null value from external libraries The C nullable feature is nice but it still requires to write lot of boilerplate code to ensure its happy about public method arguments that may be null when invoked from external libraries When we are confident well use NRT in all project using such library having a way to not write all null checks would be valuable Another very common scenario is when using classes in dependency injection scenarios where a great percentage of classes shouldnt need an explicit null check probably this behavior should be supported by a language feature like using on method arguments to suppress this message implicitly or even let the compiler generate the standard null check Actual behavior there is no way to prevent CA to trigger except of course to nullcheck or disable the rule even using the notnull operator in the expression Analyzer package MicrosoftCodeAnalysisFxCopAnalyzers Package Version v Latest Diagnostic ID CA Repro steps var x new StringReaderabc Expected behavior StringReader is a wellknown type that does not need to be disposed so no warning Actual behavior CA is reported Analyzer package MicrosoftCodeAnalysisFxCopAnalyzers Package Version v Latest Diagnostic ID CA Repro steps Note this is strict a simple example not something you might actually write csharp int TryConvert string value try return Int Parsevalue catch Exception e return Compile the above code and you correctly get the warning that you shouldnt catch generic exception Expected behavior The issue with this warning is that there are cases where methods are safe Safe methods are methods that are attempting to do something and the expectation is that they can fail but that it isnt an error that should be bubbled up Lets ignore for purposes of this discussion that some exceptions like OutOfMemoryException cannot be correctly handled by the exception Because C doesnt have an easy way to say handle all exceptions except other than exception filters it is difficult to properly build a series of trycatch blocks that would correctly handle all the exceptions you might care about and the few you dont short of an exception filter Since the purpose of this warning is to just let you know something might be wrong it makes sense to be able to ignore it when it doesnt make sense The problem is that the existing suppression syntax outside a global suppression is either a verbose code analysis attribute or pragmas It would be nice if certain methods could be considered safe out of the box and therefore be ignored by this warning Off the top of my head Id argue that Safe and Try methods would qualify but I could easily see other methods that might as well Id like to see either these types of methods autoexcluded andor a special attribute be added or perhaps there is one already such that a method can be marked safe for this type of error Again the existing analysis attribute just seems too wordy and the pragma clutters up things I believe this was done for the validating null argument rule so something similar would be nice here Actual behavior Currently you have to suppress this warning in safe methods even though most of the time such exceptions are silently loggedeatenetc Analyzer package MicrosoftCodeAnalysisFxCopAnalyzers Package Version v Latest Diagnostic ID CA Repro steps Code snippet csharp public class SomeType public string GetValue var data SomeHelperMethodThatReturnsAGenericTypeNestedType return dataValue private class NestedType public string Value get set Compile the code with CA enabled Get a warning that NestedType is not used Clearly the type is used because it is passed as a type parameter In this particular case it also is the return value so data is of that type Expected behavior Types used as type parameters should not be considered to be unused by this rule Additionally it seems odd that the analyzer didnt determine that data was that type and so it was also used as a local variable Actual behavior Get a warning of CA with the recommendation of removing the type even though it is used as part of a generic type and a local variable is declared as that type as well Analyzer package MicrosoftCodeAnalysisFxCopAnalyzers Package Version v Latest Diagnostic ID CA Repro steps cs using System using SystemIO public sealed class Program IDisposable public ProgramStream stream if stream is null throw new ArgumentNullExceptionnameofstream public static void Main foreach object in new object using FileStream stream FileOpenReadstringEmpty using Program pe new ProgramStreamNull public void Dispose Expected behavior CA is not reported Actual behavior CA is reported for FileOpenRead Doing some cleanup in the tests I have noticed that the behavior of MicrosoftCodeAnalysisCSharpTestingXUnitCodeFixVerifier and TestUtilitiesCSharpCodeFixVerifier is different The same is true for the VisualBasic pendant For example in the class DoNotMixAttributesFromDifferentVersionsOfMEFTests the test NoDiagnosticCasesUnresolvedTypes will return diagnostics with the first verifier and only with the second In the class PartsExportedWithMEFv MustBeMarkedAsSharedTests the test NoDiagnosticCasesUnresolvedTypes will return diagnostics with the first and none with the second These tests are the only failing tests but I suspect that we might have more nonfailing tests impacted by this difference Tagging sharwell as you know quite a lot on the test framework