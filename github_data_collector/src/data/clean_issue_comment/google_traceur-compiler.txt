The filename argument passed to the writeFile function in fileutiljs may be manipulated to write arbitrary directories on the filesystem The writeFile function attempts to sanitize the untrusted filename but calls the mkdirRecursive function on the untrusted filename before the filename is sanitized For example passing the filename testtargettxt on a nix system will create the directory test in the parent directory An attacker can use the dotdotslash path manipulation technique to create directories anywhere on the filesystem function writeFilefilename contents Compute the output path var outputdir fsrealpathSyncprocesscwd mkdirRecursivepathdirnamefilename var filedir fsrealpathSyncpathdirnamefilename filedir removeCommonPrefixoutputdir filedir outputdir pathjoinoutputdir filedir mkdirRecursiveoutputdir var outputfile pathjoinoutputdir pathbasenamefilename fswriteFileSyncoutputfile contents utf Hi All we are upgrading to jQuery version We have Rihno version R and we are getting error ObjectdefineProperty is not a function I tried other new version of Rihno but nothing worked The reason may be ObjectdefineProperty is defined in JS and rihno is in JS can anyone of you help me to solve this When Chrome sees a script typemodule tag it will interpret is as an ES module Is there any way to detect this at runtime to prevent Traceur doing transpilation when we dont need it to GNU Guile has now a working prototype of a compiler backend that generates JavaScript It use lots of tail calls I compiled it with traceur using the following command sh traceur out scriptjs script outprettierjs propertailcalls experimental I run it in chrome using the following html file html html body script src script src script srcscriptjs typetextjavascriptscript body html It fails with a Uncaught RangeError Maximum call stack size exceeded The original scheme program is scheme jsinvoke jseval console log h llo world The input JavaScript file can be found here That input file is correctly intrepreted by nodejs v using the harmonytailcalls flag Like these codes js libjs export let c name Hello export function ins return cname export function reset c name Hello js import c ins reset from lib cname consolelogc consolelogins reset consolelogins consolelogc When execute indexjs that use babel or TypeScript compiled will print name Hello name Hello But use traceur that will print name Hello name Would you tell us which compiler is compile right Could we implement this proposal for Traceur By scanning the generated ES code I discovered that the getter methods follow the format get property namereturn The above getter and setter syntax is good for most of the modern web browsers However Id like to run the generated ES code in the Safari x which doesnt sustain the getter shorthand syntax On the contrary ObjectdefineProperties is supported utterly ObjectdefinePropertiesobject property name enumerable true get functionreturn So I intend to modify the Traceur source code to replace the shorthand syntax with the integral version based on ObjectdefineProperties My st goal is the getter counterpart serving the ES export commands Could you please teach me which Traceur sourcecode file is most relevant to my st goal Id like to report a bug for the ES module importing According to the ES spec the ES Module statement import Module File Path merely executes the JavaScript routine inside the module body but doesnt really import any external variables or functions into the current context However accompanying the latest Google Traceur the statement import Module File Path doesnt execute the module body as expected On the contrary I feel that the importing statement is directly ignored Only the statement import from does run the ES module body Nevertheless in my use case I only intend to execute a piece of JavaScript program by importing its module without any of the importing variables I anticipate the incorrect ES compilation behavior can be renovated This is to make it easier to use in Node I upgrade the Google Traceur to the latest However the compilationoutput ES JavaScript program cant work in the web browser The transpiling command for Traceur nodemodulesbintraceur scriptwwwjswidgetnestthermostatbbjs outwwwjswidgetnestthermostatjs requiretrue arrowfunctionstrue blockbindingtrue classestrue computedpropertynamestrue defaultparameterstrue destructuringtrue foroftrue generatorstrue numericliteralstrue propertymethodstrue propertynameshorthandtrue restparameterstrue spreadtrue symbolstrue templateliteralstrue unicodeescapesequencestrue unicodeexpressionstrue propertailcallstrue annotationstrue arraycomprehensiontrue asyncfunctionstrue asyncgeneratorstrue exponentiationtrue exportfromextendedtrue forontrue generatorcomprehensiontrue membervariablestrue spreadpropertiestrue typestrue experimental sourcemapsfile The traceur runtime has been introduced in the HTML page script typetextjavascript srcjstraceurruntimejsscript The file traceurruntimejs is copied from the folder nodemodulestraceurbin The Error is thrown from the web browser when I visit the web page TypeError Cannot read property default of undefined By scanning the compilatiooutput ES JS program I discovered the error point is var initTailRecursiveFunction traceurRuntimegetModuletraceurRuntimenormalizeModuleNametraceurdistcommonjsruntimemodulesinitTailRecursiveFunctionjs widgetnestthermostatbbjsdefault Thats to say traceurRuntimegetModuletraceurRuntimenormalizeModuleNametraceurdistcommonjsruntimemodulesinitTailRecursiveFunctionjs widgetnestthermostatbbjs returns null Memo in my project ES JS file is suffixed with bbjs After they are compiled their corresponding ES file is js 