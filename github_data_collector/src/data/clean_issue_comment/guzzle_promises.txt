PHP with the same changes as I proposed for Guzzle avoiding calling the helper functions within the core code to mitigate global package installation issues Looks like there are a couple of fixes merged into master that have not yet made it into a release Looking at the outstanding PRs that could be merged or closed right now we have Looks good to merge to me I dont think should be closed Not immediately obvious risky or unfinished Im sure this doesnt affect many people but I came across this issue in an older project that uses an autoloader that in some circumstances can call include without checking for file existence relying on the class file existing somewhere in a directory defined in includepath Boiling it down if you register a simple autoloader php splautoloadregisterfunctionclass dieclass Then any of the following will trigger the call to die php promise new FulfilledPromiseNotAClassName php promise new RejectedPromiseNotAClassName php promise promiseforNotAClassName php promise new Promise promisethenfunction A handler must be defined to get to the relevant code promiseresolveNotAClassName Or reject This happens because methodexists will attempt to load the class if provided with a string that could be a class name So this PR adds explicit object checks before calling methodexists as I cant imagine triggering the autoloader being an intended side effect inspectall simply goes over an iterable param and passes values to inspect which accepts only PromiseInterface instances In general if a promises getState returns FULFILLED or REJECTED then wait returns a value or error immediately ie you can call inspect on a nonpending promise and get a valid answer But this is not the case if you resolve or reject with a promise either directly or indirectly by returning one from a then handler In such a case you can have a promise whose state is fulfilled or rejected on the surface but is actually pending internally Thiis appears to be a violation of section of the PromisesA spec ie If x is pending promise must remain pending until x is fulfilled or rejected But this librarys promise implementation prematurely settles the promise rather than leaving it pending per the spec In cases where you want to be able to poll the value of promises but cant actually wait on them this is a problem because there is no way to know from outside the promise that this pseudofulfillment condition can be detected The only way to avoid it seems to be to either exclusively use coroutines never use getState and wait or never call resolve with a promise or return one from a then handler ISTM that it would be better here to follow the spec and have a promise remain pending when resolved or rejected with another promise until such time as the other promise resolves or rejects especially since a pending promise passed to resolve could later reject resulting in the paradoxical condition of a promise whose state is fulfilled yet throws an error when you wait on it Fixes If a coroutine throws after its st yield then the promise is rejected as expected php result Promise coroutinefunction yield true thrown new Exception thennull function return false wait OK result false But if it throws before the st yield the exception is not caught php result Promise coroutinefunction thrown new Exception yield true thennull function return false wait KO Uncaught Exception Hey there Ive got the following code promisethen onFulfilled function user bla bla onRejected function reason throw new Errorresetpasswordtokenexpired but the error is being caught What can I do to allow it to propagate up the error chain and crash the app Thank you As far as I can quickly test this minor change fixes this issue Beyond that the guzzle library appears to work just fine within a pthreads environment 