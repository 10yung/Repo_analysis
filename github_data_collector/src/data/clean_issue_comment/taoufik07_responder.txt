Are there any good methods for to get pathstrings including slashes as an argument of route like the following flasks code python approutetestpatharg def examplearg printfpath is arg testfoobar path is foobar I could only come up with the following solution python import responder responderroutesCONVERTORS path str r apiroutetestargpath def examplearg printfpath is arg I want to use responder with other async loop such as IoT uses fetching BLE GATT I usually use flask but that library is not asyncio friendly So flask replace more asyncio friendly library such as responder But I faced a problem that is where can I start other fetching main loop Responder invoke looprununtilcomlete in the nonasync function so Im not clear to start other fetching method The followibg is psuedo code I want use responder with this server code Please share me the way to use responder class BLEServer async def runself while selfrunning Some fetching code invoking many async functions def getself name return selfdatafetchedatasyncrun name I am trying to split a server into multiple modules and I am running into troubles I did put the example of the OpenAPI Schema Support example into the file restdemoapipy In order to get it working I had to start the responder server before importing that module import responder api responderAPI from restdemoapi import apirun At that point I can call the endpoints but the specs fail as marshmallow cannot properly bind back to the PetSchema class So my question is responder designed to split the server into multiple modules If yes what is the proper way so people would not run into the issues I am seeing Yesterday I updated to responder In my route I make use of the api attribute This worked in the past But after upgrading to version it is always None I checked the implementation The call method of Route in routespy creates a new Request object without providing an api argument and the default in modelspy is None Is this a intentional design change or a bug Maybe Im spotting the wrong piece of code If this is an intentional change what is the best way to access the api in a Routeclass method I found a work around by adding my own middleware Responder currently has class based views in order to specify handlers for specific HTTP methods For example python apiroute class ExampleResource def ongetself req res restext get def onpostsef req res restext fpost reqmedia It would be nice however if responder allowed for allowed HTTP methods to be specified via apiroute for function endpoints python apiroute methods GET def getonlyreq res restext only a get Addresses Note largely a replay of on top of responder v The PR adds an init parameter reverseproxyroute to prefix all routes using the new Router class Notes added makeroute function to Router apimakeroute checks that routes begin with if reverseproxypath is not set apimakeroute returns the route unchanged test cases docsroute openapiroute staticroute all function when reverseproxypath is set test incorrect reverseproxypath cant have trailing A few implementation examples here I suppose the already implemented WebSockets support would be a good fit for this Im not sure if this is possible or how to approach it Happy to contribute an example if someone can point me in the right direction Following the test instructions on the test takes seconds If you dont provide a domain name Responders version Requests makes the hostname and then tries to resolve it Since thats hopefully not a real host it fails to resolve and the developer has to wait for a timeout For now the tests cover of our code base it would be cool if we can reach the Name Stmts Miss Cover Missing responderinitpy respondermainpy responderversionpy responderapipy responderapppy responderbackgroundpy responderclipy respondercorepy responderextinitpy responderextgraphqlpy responderformatspy respondermodelspy responderroutespy responderstaticspy responderstatuscodespy respondertemplatesinitpy TOTAL 