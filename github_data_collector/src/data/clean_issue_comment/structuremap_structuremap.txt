I know StructureMap is sunsetted and this may not get fixed but just in case someone has the same problem When adding explicit arguments either via ExplicitArguments on GetInstanceargs or defining them in the registry via Ctorname StructureMap thinks that the argument has not been defined at all This actually used to work in Here are some test cases which all fail cs Fact public void supplynamedargumentsnullctor var container new Containerx xForIWidgetUseColorWidgetCtorstringIsdefaultstring containerWithcolorEqualTonull GetInstanceIWidget ShouldBeOfTypeColorWidget ColorShouldBeNull Fact public void supplynamedargumentsnullarg var container new Containerx xForIWidgetUseColorWidgetCtorstringIsRed containerGetInstanceIWidget ShouldBeOfTypeColorWidget ColorShouldBeRed containerWithcolorEqualTonull GetInstanceIWidget ShouldBeOfTypeColorWidget ColorShouldBeNull Fact public void supplynamedargumentsnullarg var container new Containerx xForIWidgetUseColorWidgetCtorstringIsRed containerGetInstanceIWidget ShouldBeOfTypeColorWidget ColorShouldBeRed var args new ExplicitArguments argsSetArgcolor null containerGetInstanceIWidgetargs ShouldBeOfTypeColorWidget ColorShouldBeNull I would expect these to be a valid setup but the following error occurs in the first two StructureMapStructureMapBuildPlanException Unable to create a build plan for concrete type StructureMapTestingAcceptanceColorWidget new ColorWidgetString color String color Required primitive dependency is not explicitly defined Attempting to create a BuildPlan for Instance of StructureMapTestingAcceptanceIWidget a a f f dec fd bf b StructureMapTestingAcceptanceColorWidget a a f f dec fd bf b ContainerGetInstanceStructureMapTestingAcceptanceIWidgetcolor When accessing documentation website eg the browser fails to load jquery due to mixed content Thus the search bar does not work Proposed solution use the protocolrelative url in script sections UseIfNoneregistration is ignored when calling GetAllInstances GetInstance does respect UseIfNone ctorIMyInterface item IListIMyInterface items Current result item is not null and items is empty Expected result item is not null and items contains at least one item I have registered some MediatR handlers as IAsyncRequestHandler types like FortypeofIAsyncRequestHandlerParamType ResponseTypeUsetypeofConcreteHandler When I concurrently call a API which in turn executes mediatorSend to one of the handlers I have registered sometimes I see one ore more calls have exception for Handler was not found for request of type and dig deeper and see No default Instance is registered and cannot be automatically determined for type IRequestHandlerParamType ResponseType Any idea how could it happen I already registered for IAsyncRequestHandler type but somehow exception is thrown for not found IRequestHandler Were experiencing an issue similar to ArgumentNullException when defining a null value for a NullableT parameter but with a string parameter The class were injecting has a default parameter that sets the string to null Because the value is null we get an exception in the plan builder code here StructureMapBuildPlanException Unable to create a build plan for concrete type SteeltoeManagementEndpointHeapDumpHeapDumper new HeapDumperIHeapDumpOptions String basePathOverride ILoggerHeapDumper IHeapDumpOptions Default String basePathOverride Required primitive dependency is not explicitly defined ILoggerHeapDumper Default If we set the parameter to default to an empty string it works fine The same behavior occurs with nullable types Were a bit confused by this behavior the default value of strings and nullable types is null so why is a null value considered an error condition The same class injects fine using ASPNET Core builtin DI Was considering a PR to allow null strings and nullable types but that would seem to contradict one of the PRs already merged I not fully following the reasoning behind that PR if you define a parameter as nullable doesnt that mean you intend for it to be optional so a null should be expected and valid whether making parameters optional nullable types is a good idea in the first place is a totally separate conversation Hi just a question For a project we now use StructureMap to inject some custom implementations but we needed to alter the GetInstance call on the container because the instances in the container were registered with a scheme ex file and it was based on a fully location ex filesomefilepath that we needed to resolve the instances We had for example these registrations Name file instance FileUploader Name instance HttpSender And based on a location string like we need to resolve the HttpSender Would it be useful to add a overload to the GetInstance method in the Container class to not only select an instance based on the exact match of a name but with a custom predicate GetInstanceFuncInstance bool Thanks in advance This is with respect to the issue The bidirectional dependency relationship exception is still being raised when the lifecycle is changed from AlwaysUnique to Transient Below is the modified code from the issue to reproduce the error public class Program private const String PearCode P private static void Main var container new Container ForIFruitUsePearNamedPearCode ForFruitProviderUseFruitProvider ForISomethingUseSomething var tasks new ListTask var fruitProvider containerGetInstanceFruitProvider for var i i tasksCapacity i var t TaskFactoryStartNew fruitProviderGetPearCode tasksAddt try TaskWaitAlltasksToArray catch Exception e DebuggerBreak public class FruitProvider private readonly FuncString IFruit factory public FruitProviderFuncString IFruit factory factory factory public IFruit GetString name return factoryname public interface IFruit String Name get public class Pear IFruit private readonly ISomething something public PearISomething something Please note that this is NOT needed to cause the issue but will increase the number of times the issue occurs something something public String Name get return Pear public interface ISomething Object Something get public class Something ISomething public Object Something get return DateTimeUtcNow I have TaskWhenAlltasks and each task uses AutoMappers ValueResolver which has dependency resolved via DI public AutoMapperRegistry ForSingletonOfMapperConfigurationUseBuild AutoMapper config ctx var profiles ctxGetAllInstancesProfile var config new MapperConfigurationcfg cfgAllowNullCollections true foreach var profile in profiles cfgAddProfileprofile return config ForIMapperUsectx ctxGetInstanceMapperConfigurationCreateMapperctxGetInstance When AutoMapper creates ValueResolver instance same dependency added to dictionary more than once SystemArgumentException An item with the same key has already been added at SystemThrowHelperThrowArgumentExceptionExceptionResource resource at SystemCollectionsGenericDictionary InsertTKey key TValue value Boolean add at StructureMapSessionCacheGetDefaultType pluginType IPipelineGraph pipelineGraph at AutoMapperMappingOperationOptions CreateInstance T Looks like expcetion from hi iam use Structuremap in mvc core iam use this code but It doesnt register i dont want use Structuremap in Startup with public IServiceProvider ConfigureServicesIServiceCollection services There is another way for use Structuremap public class StructuremapRegistry Registry public StructuremapRegistry Scan Scan ScanTheCallingAssembly ScanAddAllTypesOfIUnitOfEntity ScanWithDefaultConventions ScanLookForRegistries ScanAssembliesAndExecutablesFromApplicationBaseDirectory public static IServiceProvider ConfigureServicesSMthis IServiceCollection services var container new Container containerConfigureconfig configAddRegistrynew StructuremapRegistry configPopulateservices return containerGetInstanceIServiceProvider return services Registration in Startupcs public void ConfigureServicesIServiceCollection services servicesConfigureServicesSM Here is example inspired by typical MediatR sample Question why resolution for X is working but for IRequestHandler is not Live code is here using System using StructureMap public class Program public static void Main var sm new Container FortypeofXUsetypeofY FortypeofIRequestHandlerUsetypeofAdapter ConsoleWriteLinesmGetInstanceXint string ConsoleWriteLinesmGetInstanceIRequestHandlerint string public class XT T public class YT XT string public interface IRequestHandlerTRequest TResponse public class AdapterTRequest IRequestHandlerTRequest string 