rails connection pool does this by default when checking out from pool when the db restarts this only gets hit for the primary connection and not any that use the modelusing which then fail and continue to fail until instance is restarted this is the best I could come up with to get something equivalent as I dont see where to clear Threadcurrent vars when the connection is checked back into the pool the RequestStore gem does this for you in rails and there is a sidekiq instance as well to help with that this is going through testing on our side and if everything works on production then I will put in an update and this was raising an error sidekiq delayedmailer and yaml we use sidekiqs actionmailer extensions to add a delay which serializes yaml and then restores it when worker starts with which hits your initwith and raises exception on some of the cleanup code so this pull fixes that by rescuing some inspection could also take place but the this seemed more risky Hi Ive encountered a shard mismatch problem when using octopus with identitycache gem Environment Databases master replica Config replicated true fullyreplicated false set replicatedmodel by ourself Gems rails octopus identitycache Scenario Model User replicatedmodel hasone setting Setting replicatedmodel When I want to update the setting record fetched from cache the update query will be sent to the replica shard ruby in controller first request works later requests all failed Userfetch settingupdatesomeattribute By using bindingpry I found that first time currentshard will return master record fetched by another request will get replica then the update query sent to wrong replica database But if I using normal Active Record method eg Memberfind settingupdatesomeattribute all request are success Is there some class variables stored across requests but computing after ActiveRecord instance initialize but record initialized by IdentityCache cause the problem Thanks Bumps nokogiri from to details summaryRelease notessummary Sourced from nokogiris releases Security Address CVE A command injection vulnerability in Nokogiri v and earlier allows commands to be executed in a subprocess by Rubys Kernelopen method Processes are vulnerable only if the undocumented method NokogiriCSSTokenizerloadfile is being passed untrusted user input This vulnerability appears in code generated by the Rexical gem versions v and earlier Rexical is used by Nokogiri to generate lexical scanner code for parsing CSS queries The underlying vulnerability was addressed in Rexical v and Nokogiri upgraded to this version of Rexical in Nokogiri v This CVEs public notice is sparklemotionnokogiri Security Notes MRI Pulled in upstream patch from libxslt that addresses CVE Full details are available in Note that this patch is not yet as of in an upstream release of libxslt Security MRI Remove support from vendored libxml for future script macros MRI Remove support from vendored libxml for serverside includes within attributes Bug fixes JRuby Fix node ownership in duplicated documents JRuby Rethrow exceptions caught by Java SAX handler Thanks adjam Features MRI During installation handle Xcode s new library pathOS Thanks mlj and deepj Avoid unnecessary creation of Procs in many methods Thanks chopraanmol Bug fixes CSS selector has now correctly matches against any descendant Previously this selector matched against only direct children Thanks Phrogz NodeSetattr now returns nil if its empty Previously this raised a NoMethodError MRI XPath errors are no longer suppressed during XSLTStylesheettransform Previously these errors were suppressed which led to silent failures and a subsequent segfault trtable truncated details details summaryChangelogsummary Sourced from nokogiris changelog Security Address CVE A command injection vulnerability in Nokogiri v and earlier allows commands to be executed in a subprocess by Rubys Kernelopen method Processes are vulnerable only if the undocumented method NokogiriCSSTokenizerloadfile is being passed untrusted user input This vulnerability appears in code generated by the Rexical gem versions v and earlier Rexical is used by Nokogiri to generate lexical scanner code for parsing CSS queries The underlying vulnerability was addressed in Rexical v and Nokogiri upgraded to this version of Rexical in Nokogiri v This CVEs public notice is sparklemotionnokogiri Security Notes MRI Pulled in upstream patch from libxslt that addresses CVE Full details are available in Note that this patch is not yet as of in an upstream release of libxslt Security MRI Remove support from vendored libxml for future script macros MRI Remove support from vendored libxml for serverside includes within attributes Bug fixes JRuby Fix node ownership in duplicated documents JRuby Rethrow exceptions caught by Java SAX handler Thanks adjam Features MRI During installation handle Xcode s new library path Thanks mlj and deepj Avoid unnecessary creation of Procs in many methods Thanks chopraanmol Bug fixes CSS selector has now correctly matches against any descendant Previously this selector matched against only direct children Thanks Phrogz NodeSetattr now returns nil if its empty Previously this raised a NoMethodError MRI XPath errors are no longer suppressed during XSLTStylesheettransform Previously these errors were suppressed which led to silent failures and a subsequent segfault trtable truncated details details summaryCommitssummary beb e version bump to v d Merge branch csstokenizerloadfilevulnerabilityv x into v x c b fc update CHANGELOG fe f regenerate lexical scanner using rexical eliminate eval from Builderinitialize a bc rufo formatting ecb rubocop security scan is run as part of the test rake target d cd add rubocop as a dev dependency ee b adding a temporary pipeline for v x e af version bump to v Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details Hi Im trying to get Octopus working with my Rails application What I want to achieve is to use an AWS RDS readreplica for the readonly queries of my Rails application Im using Octopus v Gemfile ruby gem aroctopus Here is what my MYPROJECTconfigshardsyml looks like yml octopus environments production replicated true fullyreplicated true production rdsreadreplica adapter postgresql host XXXeuwest rdsamazonawscom port database XXX username XXX password XXX encoding utf However when I run bundle exec rails server I have the huge cryptic error below The application works fine without Octopus Do you have an idea of what can cause this problem Error srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusshardtrackingrb in aliasmethod undefined method any for class ActiveRecordAssociationsCollectionAssociation NameError from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusshardtrackingrb in createshardedmethod from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusshardtrackingrb in block in shardedmethods from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusshardtrackingrb in each from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusshardtrackingrb in shardedmethods from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopuscollectionassociationrb in included from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopuscollectionassociationrb in include from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopuscollectionassociationrb in main from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in block in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcacheloadedfeaturesindexrb in register from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in block in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in loaddependency from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in require from srvMYPROJECTvendorbundleruby gemsaroctopus liboctopusrb in main from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in block in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcacheloadedfeaturesindexrb in register from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in block in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in loaddependency from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in require from srvMYPROJECTvendorbundleruby gemsaroctopus libaroctopusrb in main from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in block in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcacheloadedfeaturesindexrb in register from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from usrlocalbundlegemsbundler libbundlerruntimerb in block levels in require from usrlocalbundlegemsbundler libbundlerruntimerb in each from usrlocalbundlegemsbundler libbundlerruntimerb in block in require from usrlocalbundlegemsbundler libbundlerruntimerb in each from usrlocalbundlegemsbundler libbundlerruntimerb in require from usrlocalbundlegemsbundler libbundlerrb in require from srvMYPROJECTconfigapplicationrb in main from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in block in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcacheloadedfeaturesindexrb in register from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in block in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in loaddependency from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in require from srvMYPROJECTvendorbundleruby gemsrailties librailscommandsserverservercommandrb in block in perform from srvMYPROJECTvendorbundleruby gemsrailties librailscommandsserverservercommandrb in tap from srvMYPROJECTvendorbundleruby gemsrailties librailscommandsserverservercommandrb in perform from srvMYPROJECTvendorbundleruby gemsthor libthorcommandrb in run from srvMYPROJECTvendorbundleruby gemsthor libthorinvocationrb in invokecommand from srvMYPROJECTvendorbundleruby gemsthor libthorrb in dispatch from srvMYPROJECTvendorbundleruby gemsrailties librailscommandbaserb in perform from srvMYPROJECTvendorbundleruby gemsrailties librailscommandrb in invoke from srvMYPROJECTvendorbundleruby gemsrailties librailscommandsrb in main from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in block in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcacheloadedfeaturesindexrb in register from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in requirewithbootsnaplfi from srvMYPROJECTvendorbundleruby gemsbootsnap libbootsnaploadpathcachecoreextkernelrequirerb in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in block in require from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in loaddependency from srvMYPROJECTvendorbundleruby gemsactivesupport libactivesupportdependenciesrb in require from binrails in main Once the first version of Rails beta is released there will be a migration guide to help users migrate from Octopus to Rails In many setups the default master shard might be a different database server in each environment A single mastershard config setting doesnt fit This patch first checks the shardsyml for octopus mastershards Rails env for a setting and still falls back to octopus mastershard if it doesnt exist Example octopus mastershard fallback mastershards development dev production lion environments development production development dev dev production lion tiger Hi folks Im trying to pin down a slippery issue with a Rails API thats using Octopus to maintain a large list of SQL Server database shards for multitenancy We host our application on MS Azure which has a limit of SNAT ports used for all outbound TCP connections including DB connections that we seem to be periodically exhausting I understand ActiveRecord maintains a connection pool so that it can reuse connections when they complete queries but I dont understand is how this intersects with Octopus For example our Databaseyml which we load settings from when loading shards sets the pool size at We then apply these settings to each shard in a list of shard names with the below code snippets Building the list of shards where config is loaded from our databaseyml def selfbuildshardsdbnames config shards ENV RAILSENV tosym dbnameseach do name shards ENV RAILSENV tosym name host config host pool config pool adapter config adapter database name username config username password config password port config port azure config azure timeout config timeout variables config variables end return shards end saving the list of shards to octopus Save shards to config Octopussetup do config configenvironments ENV RAILSENV configshards shards end Is this maintaining essentially a separate connection for each database shard Or is there a unified pool somehow Thanks much Im familiar with Octopus for a previous project but opted to try the new Rails connection switching per the note in the READMEmd However I cant seem to get it to reproduce a usingtenant usingtenant approach it seems setup for a rolebased readwrite strategy rather than sharding Can go into detail on challenges if needed but seemed like I was going against the grain with various approaches Is the plan still to create a migration guide and depreciate Octopus or are features like shardingusinggroupextended migration features etc still an Octopus only feature to be continued Thanks This adds optional support for the ibmdb gem If the ibmdb gem is not loaded in the bundle octopus should behave the same as before If the ibmdb gem is loaded it enables some monkey patches in the ibmdb gem to work with Rails and Rails This includes the Docker dev system commits in Much of this PR is supporting code for the test suite and build system 