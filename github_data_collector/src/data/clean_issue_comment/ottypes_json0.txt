Lets imagine that the data contains a very big branch fe key a b z other We are going to delete the whole branch key for some reason As I understand the operation then should look like p key oda b z But for the delete operation the logically required information is the only key of the deleted item The deleted object content is the extra info which is not necessary for the operation It was probably useful to exclude repeating object content for the delete operation and replace it by something neutral like logical true p key odtrue It looks much more compact and logical Closes issue Builds on PR by houshuang Theres interest in adding presence to json and I thought Id make an issue to summarize the need and link to related material My desire is to add presence features cursors selections to an app that is using text within json Others are interested in using the already defined presence implementation of otrichtext The goal is to define presence in such a way that any json leaf node of any OT type can have presence if its OT type implements presence Related Presence issue in ottypesjson Presence issue in ottypesjson Presence issue in ottypesrichtext Add presencerelated properties in ottypesdocs pending PR Teamwork for of ottypesdocs PR merged presence implementation in ShareDB pending PR by gkusiba Teamwork Fork of ShareDB PR is merged otrichtext implements presence Operationjs implements the presence functions Interesting Cursor Transform Work by Robert Lord implements presence differently than ShareDB but will leverage the ottypes family My question to you josephg is would a PR that implements presence for json we welcome here or would we be better off maintaining a fork for presence I understand that merging such a PR into json may be risky as mainline ShareDB does not implement the presence spec which itself is not really official quite yet Faced with the challenge of implementing presence for text strings embedded deep within json documents I was perusing the json forks network and stumbled upon this quite interesting work by lord I dont fully understand what the changes here are really doing but I have a suspicion it may be an interesting lead Im creating a PR so its easy to see the changes and any interested parties can discuss here Related Adding presence to otjson by houshuang Sync ephemeral presence data by gkusiba It would be really great if the library could apply ops such that instead of mutating the original data a new object is created with shared structure with the previous data object Related Immutable Update Patterns Immer I might try using this with json Ive started work on an OT plugin for CodeMirror and I was wondering has anyone ever create TypeScript type declarations for json This change adds validation to array and object deletion If the values provided in either ld or od do not match the current value then apply will throw It will also throw if oi overwrites an existing value without providing od The primary motivation of this change is to ensure that all submitted ops remain reversible At the moment the following series of ops is possible start with foo bar apply this op p foo oi baz resulting in foo baz invert the previous op p foo od baz and apply the inverted op When I apply invert and apply I should always wind up where I started but in this case I clearly do not By ensuring that the od matches the current value we make sure that all ops remain reversible Deep equality adds a dependency on fastdeepequal For pPATH oiNEWVALUE The documentation says When inserting the key must not already be used However if they key exists it currently will overwrite it Not sure what the correct behaviour is From jsonapply for var j j cplength j var p cp j parent elem parentKey key elem elem key key p if parent null throw new ErrorPath invalid If parent is null this code will break on elem elem key It should be for var j j cplength j var p cp j parent elem if parent null throw new ErrorPath invalid parentKey key elem elem key key p 