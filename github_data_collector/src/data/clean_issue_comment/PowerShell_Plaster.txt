Added ability to substitute whole files into Modify content element By specifying isFiletrue InvokePlaster will load and substitute an entire file into the variable See example below replace conditionPLASTERPARAMCustomLoggingType eq AppInsights originalPLASTERSnippetPSScriptCodeMainLoggingoriginal substitute isFiletrue SupportingDirectories Template PSSnippets SnippetPSScriptCodeMainLoggingps substitute replace Added explanation of dynamic parameters in Example I found the Plaster module in the vscode module folder and wanted to check it out After reading the examples and trying them out it appears that example doesnt work InvokePlaster TemplatePath Destination GitHub NewModule ModuleName Foo Version InvokePlaster A parameter cannot be found that matches parameter name ModuleName The parameters for FullName and Email are read from the gitconfig file of the user The issue I have seen is that Plaster looks under userprofile but sometimes these files are stored elsewhere because git looks at homedrive and homepath Because its possible to store the previous values entered this is a very minor issue However you may want to change how plaster looks for users git files I see there are some open merges and it doesnt look like the PowerShell Gallery has the latest version of the code Is this dead Related issue When trying to import Plaster in PowerShell Core the TestModuleManifest call in Plasterpsm is failing stating the manifest is invalid I am able to remediate this interactively doing powershell GetModule ListAvailable Refresh ImportModule Name Plaster Force but this remediation does not work when executed from my powershell profile Note I could not replicate the behavior in Windows PowerShell My current workaround is modifying the psm to powershell PlasterVersion version ImportPowerShellDataFile Path PSScriptRoot Plasterpsd ModuleVersion Environment Details Windows SP x PowerShell Core Instead of a single file I want to copy complete folders with content Is that possible too NewModuleexample still used schema for VSCode tasksjson including the isShellCommand truebug that was fixed in Updated remaining tasksjson to schema Ive noticed that if I have several version of the same module containing a plaster template inside even if the manifest has the same version GetPlasterTemplate cmdlet returns all instances of the templates from all the versions of the same module So if I have the following MyTemplatesPSModule v MyTemplate v MyTemplatesPSModule v MyTemplate v MyTemplatesPSModule v MyTemplate v Running GetPlasterTemplate IncludeInstalledModules currently returns all three templates besides the default ones This behavior makes me want to make sure that I uninstall previous versions of such modules right after UpdateModule Is there really a need to go through all the PS Module versions instead of just the latest ones To me it seems that going through the latest ones only should be the default behavior similar to ImportModule besides it should run faster If theres actually a need to expand all previous module versions the functionality could still be accessible through a dedicated switch ie ExpandAllModuleVersions There might as well also be an additional switch ie IncludeAllTemplates to list out all template instances even if their versions are identical as follows PowerShell GetPlasterTemplate IncludeInstalledModules Should return Default Templates MyTemplate v GetPlasterTemplate IncludeInstalledModules ExpandAllModuleVersions Should return Default Templates MyTemplate v from MyTemplatesPSModule v MyTemplate v GetPlasterTemplate IncludeInstalledModules ExpandAllModuleVersions IncludeAllTemplates Should return Default Templates MyTemplate v from MyTemplatesPSModule v MyTemplate v from MyTemplatesPSModule v MyTemplate v The multi choice parameter allows you to use the same letter as a shortcut key for more than one choice powershell choice label ampPrivate helpAdds a Private folder to the module root valuePrivate choice label ampPublic helpAdds a Public folder to the module root valuePublic In the above example if the letter P is used as a shortcut it will create both the Private and Public folder My current work around is to use different letters powershell choice labelP amprivate helpAdds a Private folder to the module root valuePrivate choice labelP ampublic helpAdds a Public folder to the module root valuePublic It seems buggy that InvokePlaster and perhaps TestPlasterManifest would allow for this behavior The expected behavior would be an indication to the user that theres a conflict and that a different value should be used for one of the choice labels