Hi Im trying to add EnTT to an Unreal project with C enabled When compiling I see these warnings Are these known or have I done something wrong Thanks E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetatypenode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetapropnode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetabasenode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetaconvnode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetactornode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetadatanode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetafuncnode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt meta metahpp error C Implicit conversion from const enttinternalmetatypenode const to bool Possible information loss E testy Source entt meta metahpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt signal delegatehpp error C Implicit conversion from void cdecl const const void stdtuplevoid to bool Possible information loss E testy Source entt signal delegatehpp note consider using explicit cast or comparison to nullptr to avoid this warning E testy Source entt signal delegatehpp note while compiling class template member function enttdelegatevoid void operator boolvoid noexcept const E testy Source entt entity signalsighhpp note see reference to function template instantiation enttdelegatevoid void operator boolvoid noexcept const being compiled E testy Source entt entity signalsighhpp note see reference to class template instantiation enttdelegatevoid void being compiled I often find myself doing things like this cpp enttentity hovered enttnull for auto entity registryviewHovered hovered entity break Where there may be many things carrying this particular component eg behind or infront of the cursor and where you may have sorted them front to back and only want the frontmost one Another usecase is for selection where the first gets special treatment like a different kind of draw call And was thinking that could be simplified to eg cpp auto hovered registryfirstHovered Along with for symmetry cpp auto hovered registrylastHovered Thoughts Closes The name invokeoncomponent is still up for debate as is this entire PR Feel free to close was just something I felt would be helpful I propose adding a method of iterating over all components IDs that are currently attached to an entity What I want to achieve is mapping the components to my custom reflection system and that could be done by mapping looking them up with runtime component IDs generated via registrytypeComponent In addition to the type ID I would also need a pointer to the actual component type that I could then cast to the correct type based on the ID The resulting API could look something like the following registrycomponentsentity enttcomponent componentid void instance The naming of the method should probably be considered maybe it should somehow clearly indicate that this is very raw data as it only feeds the caller void pointers It would be quite nice to have an option to enable Thread Safety when the registry initializes its component pools Basically as we talked about on the gitter when you loop over your view for the first time it will most likely at least in my case be the first time that the registry sees a given component type therefore it has to initialize the pool for that specific type however as it is right now this isnt thread safe and while there are plenty of work arounds I think it would be nice to have an option to enable this At the end of the day using a mutex to make it thread safe isnt really a performance concern as this is a one time setup thing that would happen only on the very first iteration of a view that has a component that the registry havent seen before it would hide away a lot of otherwise Setup code that the programmer would have to do in order to either prepare the registry like using Registerprepare or running all views single threaded for the first iteration Would it be possible to add an overload for the onconstructfamily of methods on the sinks to allow for a member function of the underlying component type without an instance of the member functions type Heres a visual example c struct somecomponent int i void init cout Ive initd i endl registryonconstructsomecomponentconnect somecomponentinit In the above pseudocode we dont use a static function nor do we use a member function with a pointreference to a specific instance Instead we use a pointer to a member function of the component itself to call with this being the pointer to the newly created component itself This would greatly clean up some of the glue code in some parts of the engine as right now I am either passing lambdas or creating stubs to do pretty much exactly this For context I could be using constructors and destructors but given the inherently PODlike structures default move constructors et al Im writing my components in a way they can be reused via init and destroy member methods where a call to destroy could in theory be followed by init assuming all of the nondefault POD properties have been set prior I fully realize this isnt a design requirement by ENTT but it seems like a clean approach for my usecase Would love to hear your thoughts or why this might not be a good idea As mentioned in chat there might be an opportunity for the API to save a few characters from being typed by introducing a any to the registry Before cpp if registryhasSelectedentity registryhasSelectedByParententity registryhasSelectedByChildentity flags ImGuiTreeNodeFlagsSelected After cpp if registryanySelected SelectedByParent SelectedByChildentity flags ImGuiTreeNodeFlagsSelected Abstract A static reflection is a tool that allows adding metainformation to types for using it at compile time for different purposes One of the use cases is generating data for runtime reflection systems like the one in EnTT or RTTR Another important use case is generating Lua bindings based on sol or similar system The main advantage of the static reflection in these cases is that it allows defining a single source of truth and generating all the necessary code with the help of generic functions that work for any type Introduction The inspiration for this definition of static reflection and its use cases comes from the following code snippet by Milerius c template typename TypeToRegister void registertype const char replacename nullptr noexcept registertypeimpl TypeToRegister reflreflect TypeToRegister members replacename template typename TypeToRegister typename Members void registertypeimpl refltypelist Members const char replacename nullptr noexcept stdstring currentname reflreflect TypeToRegister namestr stdstring finalname currentname if stdsizet found currentnamefindlastof found stdstringnpos Skip namespace finalname currentnamesubstr found LCOVEXCLLINE auto applyfunctor this auto finaltable try stdapply this auto params staticassertstdissamevstdremovecvtstdremovereferencetdecltypeparams stdnullptrt system is flawed thisluastatenewusertype TypeToRegister stdforward decltype params params finaltable catch const stdexception error stdcerr errorwhat stdendl LCOVEXCLLINE auto nametable stdmaketuple replacename nullptr finalname replacename if constexpr doommetaisdetectedv membertypeconstructorsdetector TypeToRegister using ctor typename TypeToRegisterconstructors auto finaltable stdtuplecat nametable stdmaketuple ctor stdmaketuple Membersnamecstr Memberspointer applyfunctor finaltable else auto finaltable stdtuplecat nametable stdmaketuple Membersnamecstr Memberspointer applyfunctor finaltable The code above uses the metainformation generated with the help of reflcpp library The downsides of this library are its a thirdparty library which means it cannot be included into the EnTT library it makes heavy use of macros for codegeneration which makes it relatively hard to comprehend Thus providing a static reflection system would be a great addition to the feature set of the EnTT library The only technical requirement for it now is not to be a macromonster Requirements ability to provide metainformation for any type without changing its definition not magic macros inheritance or anything along this line no prebuild steps and external code generation allow users providing custom names for the reflected entities types functions etc and a reasonable default name generation whenever possible ability to query a list of metaitems of different categories functions data members properties with types names const char or similar form and values required for using other templatebased meta systems EnTT sol ability to query metaitems by name or any other identifier Proposed wording There are several proposals for the static reflection syntax Chaincalls InnokentiyAlaytsev a rippoff of current EnTT version of runtime reflection c enttreflect T type enttname foobarhs data entttarget Tdata enttname datahs enttproperties myproperty enttproperty foohs enttproperty barhs enttannotations myannotations func entttarget Tfunc enttname funchs enttproperties anotherproperty The obvious problem with this approach is that it is a function call It should be tested whether this kind of code can be used to declare a type through decltype but it is not clear how exactly to use this approach Type lists templates InnokentiyAlaytsev c enttreflect T entttype enttname foobarhs enttdata entttarget Tdata enttname datahs enttproperties myproperty enttproperty foohs enttproperty barhs enttannotations myannotations enttfunc entttarget Tfunc enttname funchs enttproperties anotherproperty This version shares the problems of being a function call with the vatiant Another problem with this kind of approach is the impossibility of passing values of object types that is entthashedstring in the example code or string literals as template nontype parameters This will be possible in C but for now EnTT is C library It is most likely that the only way of overcoming this limitation of the language is using macros for generating some kind of class specialisation containing the desired value as static constexpr data member There are cases where passing entthashedstring as template parameter work in EnTT eg entttag type The problem here is that in fact the entthashedstring value is implicitly converted into entthashedstringhashtype so that the actual string is lost Macrobased reflection by skypjack c REFLECT T TYPEfoobarhs DATA FUNC struct Type int foo void bar void quuxconst Type META TYPEType Type DATA Typefoo Foo FUNC Typebar Bar FUNC quux skypjack that resembles exactly the definition of refl too smile but for the fact that Id make an abuse of auto under the hood to allow more things than what it does InnokentiyAlaytsev Would it be possible to unwrap the META macro smartly at first have every metaitem be turned into a class specialisation and then have every metaitem be actually turned into something else that is the actual metadata storage This version is mostly intended for hiding the actual code that is most likely a bunch of specialisation On the plus side it may be possible to generate some additional code eg specialisation in the global namespace with this approach However it is important to keep those macros as simple as humanly possible Metadescriptor reflection skypjack c templatetypename struct metatype template struct metatypeT metadescriptort typeamemberfunction typeanothermemberfunction typeadatamember typeanothermember template struct metatypeT metadescriptort funcnamehs typeamemberfunction typeanothermemberfunction typeadatamember typeanothermember skypjack where metadescriptort is an alias that forward everything to a template based system that separates the arguments in lists and defines a compiletime object with a bunch of members like data func and so on Metadescriptor type specialisation shares the same problems as variant as it needs no pass some objecttype values as template parameters Otherwise it may have the API that resembles the variant to some extent It may be worth considering the implementation based on alias template pass template arguments to an alias that unwraps them under the hood to form a proper specialisation of metadescriptor type Attachment through template specialisation InnokentiyAlaytsev c struct typewp templateclass T class K struct property static bool constexpr owned false define PROPERTYitype ikey ivalue template struct propertyitype entttagentthashedstringikey static bool constexpr owned true static auto constexpr key ikey static auto constexpr value ivalue templateclass T class K constexpr bool hasproperty return propertyT Kowned PROPERTY typewp test InnokentiyAlaytsev It is far too limited The only way to query anything is to call it by name which undermines the whole idea of meta information It is possible to make yet another specialisation to hold a list of properties but it is cumbersome and errorprone since it is not possible from what I can see to check whether the list is correct or not This version may be usable in certain cases but is most likely not suitable for solving the problem at hand due to lack of querying metaitems functionality Static constexpr data structure InnokentiyAlaytsev c struct Structure int var void f template class TKey class TValue struct metaproperty constexpr metaproperty key val constexpr metaproperty TKey ik TValue iv keyik valiv TKey key TValue val template class TProp struct metaproperties template stdsizet Ts sizeofTProp constexpr metaproperties stdenableift Ts a nullptr props constexpr metaproperties TProp ip propsip stdtuple TProp props template auto TSource class TName class TProperties metaproperties struct metaitem constexpr metaitem TName in TProperties ip namein propsip static auto constexpr src TSource TName name TProperties props template class TItem struct metaitems constexpr metaitems TItem iv itemsiv stdtuple TItem items Template parameters deduction stops working if any template parameter is provided so using metaitem sourcename properties does not work Another way round is using type parameter for source and saving the source as an ordinary membervariable template auto TSource class TName class TProperties metaproperties constexpr auto makemetaitem TName in TProperties ip return metaitem TSource TName TProperties stdforward TName in stdforward TProperties ip template class T struct metainfo template struct metainfo Structure static auto constexpr variables metaitemsmakemetaitem Structurevar varhs makemetaitem Structurevar varaliashs metapropertiesmetapropertyfoohs metapropertybarhs static auto constexpr functions metaitemsmakemetaitem Structuref fhs InnokentiyAlaytsev applicable to most types of static reflection It is not possible to extend this metainformation thing because of C and compiletime But in some rare cases this kind of extension may be wanted It could be possible to use inheritance for this the metainformation type for the specific context may be inherited from the default metainformation type and have a distinct name The default specialisation will just inherit the base without any changes The userdefined implementation may shadow the base type members definitions with its own that are composed from the base class definition and new items This version represents one of the ways the underlying compiletime data structure of some templatebased reflection variants and something in the style of variant Having to write this kind of data structure by hand is not desired Template typelist skypjack c struct Type int foo void bar void quuxconst Type using typemeta meta Type nameType data Typefoo nameFoo func Typebar nameBar func Typequux nameQuux skypjack here meta could rely on reordering for parameters and easily handle everything under the hood with a bit of template magic BUT there is a problem with the name mainly because youre already in a context where you cannot push outside the name to define or specialize a class with the sole goal of carrying a const char Cista rippoff c struct row sqlcol int nameid primary notnull userid sqlcol stdstring namefirst notnull firstname sqlcol stdstring namelast notnull lastname r Full example The idea here is to use the same trick involving macros to drag string literals into the type definition Constexpr function chain skypjack c using tmetatype enttmetaTtypeFoodata TmemberBar Or typeFoo dataamemberbardataanothermemberquux skypjack Btw its something like using this and so on well this can be constexpr with a decltype and some typename here and there Then we can add syntactic sugar to get rid of the decltype and all the rest This can be fully compiletime time and it solves the problem with the names InnokentiyAlaytsev Even if those calls are all constexpr then they still return something so you cant use using the way youve done it My thought was something like using tmetatype decltypeenttmetaTtypeFoodata TmemberBar Another option is turing it into static auto constexpr tmetainfo enttmetaTtypeFoodata TmemberBar skypjack Dont worry about the result you can still define metatypet and hide the decltype to the user The important part is that this would be fully macroless As discussed on gitter Not quite sure how this feeds into the wiki or if some other configuration is needed to propagate it somewhere At the moment it seems unclear as to what shared components will actually look like when implemented in EnTT I thought it would be a good idea to open an issue so that the discussion is all in one place and we can refer to it later I find that conversations get lost and forgotten on Gitter I came up with a few things that I think could be part of the shared components API This issue is for discussing that API and the use cases for shared components attachCe Construct C and attach it to e e will have its own copy of C This is valid even if e is already sharing C attachcopyCe Copy construct the existing C and attach it to e e is given its own copy of C Assert that e is sharing C attachfromCe s Take the C that is attached to s and share it with e This is valid even if e is already sharing C Assert that s is sharing C sharingCa b Are a and b both sharing the same C Assert that both a and b are sharing possibly different instances of C hasCe Is e sharing C removeCe Detach C from e If e was the last entity to share C we must destroy C Assert that e is sharing C uniqueCe Does e have just one C all to itself No use cases have popped into my head so maybe its useless Also Id imagine that youd have to iterate the whole sparse set to find this information so its probably not a good idea sharingwithCe Get the list of entities that share that same C shared by e Not sure if we should also include e Im not sure how efficient this would be It might also involve iterating the whole sparse set We could return an iterator range so that the user could copy the list to a collection or just iterate the entities if they want to This is faster and more flexible than returning a stdvector The iterators could iterate the sparse set and return only the entities that share C with e Maybe they could do something more efficient viewC Single component view of shared C Iterations will potentially show the same instance of C multiple times Raw iterations will provide access to each instance of C only once viewC R Multicomponent view of shared C and regular R Iterations will potentially show the same instance of C multiple times Raw iterations are not allowed It wouldnt make sense anyway The names Ive chosen are just placeholders Maybe Im missing some functions Maybe Ive included something I shouldnt have Maybe something behaves differently to what users will expect Discuss