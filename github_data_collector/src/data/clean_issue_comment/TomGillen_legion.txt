I noticed that the benchmark tests werent compiling due to API changes I came across this project and tried to use it in my engine however components seem to need the copy bound which is unfortunate Is there any good reason why this is necessary Wouldnt clone suffice I am writing a game where each servers manage one or multiple different gamegeographically adjacent regions of a world and a client connects to multiple regions of the world How well does legion support this use case Suppose the client is located at and I have four servers managing the regions x x x and x respectively The client would have to render and partially simulate the events happening on all nearby regions so it has to connect to all servers at once and handle the world events as if they are in the same world How would legion work with my use case In particular Different processes would have different Universes But I want to transfer entities between servers How would legion work with this eg could it preserve the entity ID This matters because it would increase the risk of data anomaly if the client has to destroyrecreate entities all the time just because they moved between servers if the client could identify entities in a consistent manner the risk of bugs is much lower How much of the facilities from legion could I use when processes from different mcahines cannot share the same event queue etc Or did I miss something Should I simply not use legion In several of the GTK applications that I write I need to know the entity ID in advance of assigning components to the entity so that the entity ID may be passed into GTK signals belonging to the widgets which are later added as components Currently using slotmap to achieve this at the moment rust Componentless entity let entity entitiesinsert revealerconnectclickedenclosesender move let sendersendUiEventAuditAuditEventToggleSkuentity buttonconnectclickedenclosesender move let sendersendUiEventAuditAuditEventToggleSkuentity Adding components after weve initialized their behaviors in advance revealersinsertentity revealer buttonsinsertentity button I have entities with similar tags Layer Layer when I add a component to both of them the second entitys tag changes its value to Layer rust deriveDebug Clone Copy PartialEq struct Layerpub u deriveDebug Clone Copy PartialEq struct Collisionpub bool test fn testtagchange let mut world Worldnew let entity worldinsertLayer vec firstunwrap let entity worldinsertLayer vec firstunwrap let tag worldgettagLayerentity unwrap let tag worldgettagLayerentity unwrap asserteqtag Layer before component tag failed OK asserteqtag Layer before component tag failed OK worldaddcomponententity Collisionfalse worldaddcomponententity Collisionfalse let tag worldgettagLayerentity unwrap let tag worldgettagLayerentity unwrap asserteqtag Layer after component tag failed OK asserteqtag Layer after component tag failed failed Added a test to ensure it doesnt happen again looks like a sortofdupe of This code doesnt work rust use legionprelude Define our entity data types deriveClone Copy Debug PartialEq struct Position x f y f deriveClone Copy Debug PartialEq struct Velocity dx f dy f deriveClone Copy Debug PartialEq struct Modelusize deriveClone Copy Debug PartialEq struct Static fn main Create a world to store our entities let universe Universenew let mut world universecreateworld Create entities with Position data and a tagged with Model data and as Static Tags are shared across many entities and enable further batch processing and filtering use cases let e worldinsert Model Static map Position x y let e e worldaddtage Model worldaddtage Static if you remove this it works printlnModel worldgettagModele This code prints Model SomeModel If you remove the last addtag then the code works and prints Model SomeModel This program results in undefined behavior rust use legionprelude fn fetcher legionresourcePreparedReadu let mut resources Resourcesdefault resourcesinsert u Readu fetch resources fn main println xx fetcher In spirit of this comment I experimented a bit with replacing serveral usize indices via the new type pattern by introducing ArchetypeIndex ChunkIndex ComponentIndex and SetIndex as well as a TypedIndex trait to make it a bit nicer to use these index types for getting things out of slices Unfortunately the SliceIndex trait in std isnt stable and as it seems will never be stabilized which makes this a bit more ugly and verbose to implement than it could be and due to how name resolution works I was unable to use the get name for retrieving values through this new trait which is why I settled with fetch for nowthough given resources use this name as well another name might be better I also implemented a few accessor methods for the different storage kinds to make indexing nicer While doing this I found two wrong index usages Fixed one index misuse in queryChunk where a set index was partially used in place of chunk indices the Chunk now keeps track of both indices given both are needed Fixed another index misuse in DynamicTagLayout where it was using a chunk index instead of a set index for indexing into the Tags Let me know if this is welcome andor if I should make any adjustments This implements clonemerge a copying merge that lets the user choose how the copy is made It also supports transforming one component type to another during the merge operation where the user defines the transformation clonemerge will allocate new entity IDs in the dst world by default but can be fed with an entity mapping to specify the mappings of IDs from src to dst world A resultmapping can be supplied if the user wishes to know about the final mappings of src to dst world entities which takes into account newly allocated entities as well as any replaced entities