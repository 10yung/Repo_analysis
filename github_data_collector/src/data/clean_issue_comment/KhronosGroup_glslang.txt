There is a set of tests in VKGLCTS that use dynamically uniform indexes when accessing arrays of descriptors of different types like uniform buffers storage buffers storage texel buffers etc These tests check for the corresponding feature to be available and enabled in the device as you can see here If dynamic indexing is supported and the index type is DEPENDENT for example these tests generate code like the following one version core extension GLEXTnonuniformqualifier enable layoutr i set binding uniform iimage D simage layoutset binding uniform ubodef int val ubo layoutset binding uniform ubodef int val ubo layoutset binding uniform ubodef int val ubo layoutset binding uniform ubodef int val ubo layoutset binding uniform ubodef int val ubo layoutlocalsizex localsizey in void main int accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp temp ubo accum val accum temp ivec color accum ivec ivec imageStoresimage ivec glGlobalInvocationIDxy color However when this specific GLSL shader is compiled to SPIRV the output does not declare the UniformBufferArrayDynamicIndexing capability which I believe needs to be declared for the generated code to work NB vendors are still passing these tests so its probably not critical The same problem is also happening with other DynamicIndexing capabilities Desktop GLSL allows initializing unbuffered uniform variables to a constant value directly in shader code As far as I can tell and please let me know if Im wrong glslangs reflection interface doesnt expose those values anywhere but it does internally detect them because it correctly errors when a uniform is initialized to a nonconstant value on desktop GLSL and when a uniform is initialized to a constant value in GLSL ES Id really like a way to obtain their values and whether theyve been explicitly initialized through glslangs APIs I have an existing tool with desktop GLSL shaders written for it by a large number of people and I want to use glslangs SPIRV output capabilities combined with SPIRVCross to translate those shaders to other graphics APIs but not every shader will be able to be fully ported without having a way to identify those values and I wouldnt be able to tell users when their shader wouldnt work either unless I restrict myself to GLSL ES The test spvbufferhandle frag generates a forward reference to an array This is now caught by the validator When creating a graphics pipeline with the shaders below Vulkan validations layers from SDK display the following error Vulkan debug message validation UNASSIGNEDCoreValidationShaderInterfaceTypeMismatch Number of elements inside builtin block differ between stages vertex shader vs geometry shader Vertex shader glsl version core void main vec Pos Pos vec Pos vec glPosition Pos glVertexIndex Geometry shader glsl version core layout points in layout trianglestrip maxvertices out layoutlocation out vec outColor void main vec Pos Pos vec Pos vec Pos vec vec Col Col vec Col vec Col vec for int i i i glPosition vec Pos i xy glin glPositionxy glin glPositionzw outColor Col i EmitVertex EndPrimitive Fragment shader glsl version core layoutlocation in vec inColor layoutlocation out vec outColor void main outColor vec inColor When using hlsl and specifying global constants as uniform float const registercXXX those constants are assembled in Global cb in order they appear in source and not in order specified by corresponding cXXX register This results in offsets not being sequentially growing in spirv uniform float const registerc uniform float const registerc uniform float const registerc float main SVPosition return float const x const x const x OpCapability Shader OpExtInstImport GLSLstd OpMemoryModel Logical GLSL OpEntryPoint Vertex main main entryPointOutput OpSource HLSL OpName main main OpName main main OpName Global Global OpMemberName Global const OpMemberName Global const OpMemberName Global const OpName OpName entryPointOutput entryPointOutput OpMemberDecorate Global Offset OpMemberDecorate Global Offset OpMemberDecorate Global Offset OpDecorate Global Block OpDecorate DescriptorSet OpDecorate Binding OpDecorate entryPointOutput BuiltIn Position void OpTypeVoid OpTypeFunction void float OpTypeFloat v float OpTypeVector float OpTypeFunction v float Global OpTypeStruct v float v float v float ptrUniformGlobal OpTypePointer Uniform Global OpVariable ptrUniformGlobal Uniform int OpTypeInt int OpConstant int uint OpTypeInt uint OpConstant uint ptrUniformfloat OpTypePointer Uniform float int OpConstant int int OpConstant int float OpConstant float ptrOutputv float OpTypePointer Output v float entryPointOutput OpVariable ptrOutputv float Output main OpFunction void None OpLabel OpFunctionCall v float main OpStore entryPointOutput OpReturn OpFunctionEnd main OpFunction v float None OpLabel OpAccessChain ptrUniformfloat int uint OpLoad float OpAccessChain ptrUniformfloat int uint OpLoad float OpAccessChain ptrUniformfloat int uint OpLoad float OpCompositeConstruct v float float OpReturnValue OpFunctionEnd heres a workaround we came up with diff git aglslangMachineIndependentParseContextBasecpp bglslangMachineIndependentParseContextBasecpp index ecca e cca aglslangMachineIndependentParseContextBasecpp bglslangMachineIndependentParseContextBasecpp void TParseContextBasegrowGlobalUniformBlockconst TSourceLoc loc TType mem if typeList typesetStructtypeList TTypeLoc typeLoc type loc globalUniformBlockgetTypegetWritableStructpushbacktypeLoc auto struc globalUniformBlockgetTypegetWritableStruct strucpushbacktypeLoc stdsortstrucbegin strucend const auto a const auto b return atypegetQualifierlayoutOffset btypegetQualifierlayoutOffset Insert into the symbol table if firstNewMember void TParseContextBasegrowGlobalUniformBlockconst TSourceLoc loc TType mem errorloc failed to insert the global constant buffer uniform else This is a followon request we need to amend the first insert symbolTableamendglobalUniformBlock firstNewMember symbolTableamendglobalUniformBlock firstNewMember diff git aglslangMachineIndependentSymbolTableh bglslangMachineIndependentSymbolTableh index ca da c e a aglslangMachineIndependentSymbolTableh bglslangMachineIndependentSymbolTableh public virtual const TAnonMember getAsAnonMember const override return this virtual const TVariable getAnonContainer const return anonContainer virtual unsigned int getMemberNumber const return memberNumber void setMemberNumberunsigned int m memberNumber m virtual const TType getType const override public bool insertAnonymousMembersTSymbol symbol int firstMember const TTypeList types symbolgetAsVariablegetTypegetStruct for unsigned int m firstMember m typessize m TAnonMember member new TAnonMember types m typegetFieldName m symbolgetAsVariable symbolgetAsVariablegetAnonId if levelinserttLevelPairmembergetMangledName membersecond return false for unsigned int m firstMember m typessize m if levelfindtypes m typegetFieldName levelend TAnonMember member TAnonMemberlevel types m typegetFieldName membersetMemberNumberm else TAnonMember member new TAnonMember types m typegetFieldName m symbolgetAsVariable symbolgetAsVariablegetAnonId if levelinserttLevelPairmembergetMangledName membersecond return false return true Reserve unused std uniform block in reflection and fix the uniform block struct member not affected by block matrix layout and memory layout fixed in d e c According to the spec OpenGL spec Uniform Variables All members of a named uniform block declared with a shared or std layout qualifier are considered active even if they are not referenced in any shader in the program The uniform block itself is also considered active even if no member of the block is referenced We should reserve std block and shared block in reflection According to the spec glsl Uniform and Shader Storage Block Layout Qualifiers The rowmajor and columnmajor qualifiers only affect the layout of matrices including all matrices contained in structures and arrays they are applied to to all depths of nesting These qualifiers can be applied to other types but will have no effect We need ensure all matrix block member been effect include the member of a struct in this block Support EShMsgKeepUncalled in reflection fixed in a adec EShMsgKeepUncalled is a link message for link program We need only one option to control uncalled function optimization If we set EShMsgKeepUncalled as false in link time linker wont be keep the uncall function sequence in AST and if we set EShMsgKeepUncalled as true in link time linker will keep all uncalled function sequence in AST Recursively layout packing to block member fixed in c b Layout packing isnt set recursively it causes TReflectiongetOffsets doesnt work correctly So in reflecte time we just only travers all function sequence It make EShMsgKeepUncalled only work at linker and can effect reflection When converting GLSL to SPIRV if I have a vertex shader that uses multiple utility files and more than one file uses the same UBO I have to name the UBO differently in each file its used Otherwise the values in the utility shaders are not set If they are named the same I get parsing andor link errors Example The main shader uses this block layoutstd binding uniform MatrixBlock mat ModelViewMatrix mat ProjectionMatrix mat ModelViewProjectionMatrix mat NormalMatrix matrixblock A utility shader also needs this UBO for lighting or whatever The only way this will work is if I rename the block to be MatrixBlock or anything other than the above MatrixBlock and the instance name to be matrixblock or anything other than the above matrixblock layoutstd binding uniform MatrixBlock mat ModelViewMatrix mat ProjectionMatrix mat ModelViewProjectionMatrix mat NormalMatrix matrixblock 