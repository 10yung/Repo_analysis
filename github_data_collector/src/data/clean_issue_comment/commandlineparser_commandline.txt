 Beyond parsing the string into lines how would I modify this to call LogInformation for each line of help generated It seems the API is capable of this but Im obviously struggling to figure it out myself static void DisplayHelpTParserResultT result IEnumerableError errs var helpText HelpTextAutoBuildresult h hAutoHelp true hAutoVersion true return HelpTextDefaultParsingErrorsHandlerresult h e e LogInformationhelpText I added basic support for a default verb a verb that will be assumed if no verb is specified Tests all completed on my end but Im not too knowledgable about this code if there is any problem let me know I tried using this library in my project today Im able to parse the command line from the examples just fine but found no way to access the parsed options object directly from ParserResult By my coding style I prefer not use callbacks here ie WithParsed and WithNotParsed Im already able to use the Tag property to check if parsing succeeded Am I just missing something here or can a property exposing the parsed object be added desired ability to have a nullable value that when the switch is provided it will go to the defaultobj value but if the user provides an option it will parse it Reasoning want the ability to have default values when the user turns on the switch but give them the option to set the value Optionp parallel public int Parallelism get set MyProgramexe p if OptionsParallelism null OptionParallelism defaultint var parallelism EnvironmentProcessorCount alternatively MyProgramexe p So the standard separator for IEnumerable options is the space if another separator is specified say for example a common ie Separator space it still treated as a separator for instance passing appexe p key value key value results in two items key value key value which is expected but passing appexe p key value key value note the spaces results in five items key value key value This behavior is a bit undesired and confusing everything up until the the next option ie starts with an option prefix or should only be separated by the separator character specified Ive tried a variety of things none of which work but here is what I would expect Options sync Required false Default All HelpText Processes the synchronization queue immediately optionally specifying a repository to sync public String Sync get set If I run my app with like this myapp s I would expect it to be assigned a default value of All but if I ran it with myapp s myrepo I would expect it to be assigned myrepo While the latter works the former results in ERRORS Option s sync has no value Maybe I am just misunderstanding how it works What is the proper way to implement an option that can have zero or more strings associated with it In my case I want s to sync all my repos and s myrepo to sync just that individual repo I would like to work with dotnet async Main method having the following signature static async Task Mainstring args var parser new Parser var parserResult parserParseArgumentsOptionsargs var mainAsync new MainAsync parserResultWithParsedOptionsasync options await mainAsyncRunoptionsConfigureAwait Run is defined like public async Task RunOptions options Problem is my async methods behave strangely They may work but can also simply terminate my program It would seem I am doing something wrong but I cant figure out what it is If I do this instead there doesnt seem to be any problems but I lose my async main method and some other stuff I have needs to be rewritten static void Mainstring args var parser new Parser var parserResult parserParseArgumentsOptionsargs var mainAsync new MainAsync parserResultWithParsedOptionsoptions mainAsyncRunoptionsGetAwaiterGetResult Why does the topmost Main fail in strange way and bottom one just works Is CommandLineParser not async compatible I have a generic method that is used in the ProgramMain for some microservices I want want to reuse options but have different defaults Is there a way to specify the defaults that arent compiled property attributes