a page can have multiple links to multiple feeds but it is only possible to get hold of the first link found via feed while keeping the old behavior this adds two new methods feedswithtitle which gives you a collection of arrays of the form href title feeds which gives you an array of all hrefs eg href Getting following error in Production environment alone Tried to reproduce the same in development environment but no luck Error undefined method headers for nilNilClass Code MetaInspectornewsomeurl connectiontimeout readtimeout Error Trace bundlergemsmetainspectordd libmetainspectorrequestrb in contenttype undefined method headers for nilNilClass NoMethodError from bundlergemsmetainspectordd libmetainspectordocumentrb in document from bundlergemsmetainspectordd libmetainspectordocumentrb in tos from bundlergemsmetainspectordd libmetainspectorparserrb in parsed from bundlergemsmetainspectordd libmetainspectorparserrb in initialize from bundlergemsmetainspectordd libmetainspectordocumentrb in new from bundlergemsmetainspectordd libmetainspectordocumentrb in initialize from bundlergemsmetainspectordd libmetainspectorrb in new from bundlergemsmetainspectordd libmetainspectorrb in new I know that this is a know issue and that it has been handled in the past but it was my understanding after looking at the previous issues that I should expect a MetaInspectorRequestError when theres a problem decoding a site but I have one url that is actually throwing an ArgumentError which is kind of unexpected and a bit broad to handle Heres a sample session showing the issue shell rootb d app cat Gemfile grep metainspector gem metainspector rootb d app bundle exec rails c Loading development environment Rails prymain MetaInspectornew pry output error ArgumentError invalid byte sequence in UTF bundlegemsmetainspector libmetainspectorparserstextsrb in gsub bundlegemsmetainspector libmetainspectorparserstextsrb in block in findbesttitle bundlegemsmetainspector libmetainspectorparserstextsrb in map bundlegemsmetainspector libmetainspectorparserstextsrb in findbesttitle bundlegemsmetainspector libmetainspectorparserstextsrb in besttitle bundlegemsmetainspector libmetainspectordocumentrb in tohash bundlegemsawesomeprint libawesomeprintformatterrb in converttohash bundlegemsawesomeprint libawesomeprintformatterrb in awesomeself bundlegemsawesomeprint libawesomeprintformatterrb in format bundlegemsawesomeprint libawesomeprintinspectorrb in unnested bundlegemsawesomeprint libawesomeprintinspectorrb in awesome bundlegemsawesomeprint libawesomeprintcoreextkernelrb in ai bundlegemsawesomeprint libawesomeprintcustomdefaultsrb in block in pry bundlegemspry libprypryinstancerb in showresult bundlegemspry libprypryinstancerb in block in handleline bundlegemspry libprypryclassrb in criticalsection bundlegemspry libprypryinstancerb in handleline bundlegemspry libprypryinstancerb in block levels in eval bundlegemspry libprypryinstancerb in catch bundlegemspry libprypryinstancerb in block in eval bundlegemspry libprypryinstancerb in catch bundlegemspry libprypryinstancerb in eval bundlegemspry libpryreplrb in block in repl bundlegemspry libpryreplrb in loop bundlegemspry libpryreplrb in repl bundlegemspry libpryreplrb in block in start bundlegemspry libpryinputlockrb in withownership bundlegemspry libpryinputlockrb in withownership bundlegemspry libpryreplrb in start bundlegemspry libpryreplrb in start bundlegemspry libprypryclassrb in start bundlegemsprybyebug libprybyebugpryextrb in startwithprybyebug bundlegemsrailties librailscommandsconsoleconsolecommandrb in start bundlegemsrailties librailscommandsconsoleconsolecommandrb in start bundlegemsrailties librailscommandsconsoleconsolecommandrb in perform bundlegemsthor libthorcommandrb in run bundlegemsthor libthorinvocationrb in invokecommand bundlegemsthor libthorrb in dispatch bundlegemsrailties librailscommandbaserb in perform bundlegemsrailties librailscommandrb in invoke bundlegemsrailties librailscommandsrb in top required scriptrails in require scriptrails in main Not sure what the issue is as I havent really digged into it but I assume the site is partially correct but some part of the metadata is incorrect In any case I suppose that this should be rescued somewhere and converted into a RequestError I had a usecase where it was helpful to avoid network requests and simply save the same response into a cache store in my case it was redis to improve the response time in the case that having some potentially stale data is acceptable Any suggestions Hey when you request a page with many images eg and use pageimageswithsize the request is so slow that our applications times out s Is there a way to limit the number of images it calculates the size for It would love to be able to only fetch the size of the first images for example Some pages like have a relative base href tag html base href This makes the scraping fail because we expect it to be an absolute URL To fix this we should also absolutify this base href with the url of the scraped page If the base href was already an absolute one it wont get changed Related to my use case for this feature is if I discover a URL that points to a large file like a video or a PDF that I know Im not going to scrape then theres no need to issue the full HTTP GET request to download the entire thing just to throw up a non HTML content error This gives us a point to inspect the server response headers like ContentType in this case to make a decision if we still want to request the full body or not First of all thanks for the great gem It seems when inspecting pages that have a lot of links to big files like PDFs that the entire file is downloaded HTTP GET before checking the ContentType header to see that its not an HTML file and then raising the MetaInspectorParserError It would be really nice if there was an option or something to pass in so that MetaInspector first just does an HTTP HEAD request on the URL to get the response headers back from the webserver so it can check things like response HTTP Status Code and ContentType more efficiently without having to download the entire large PDF file first to do so Thanks Hi jaimeiniesta I finally managed to get some time to work on the PRs for and This PR adds the following Support for the author and bestauthor method Support for parsely and sailthru tags as fallbacks in determining best methods Let me know if this looks good