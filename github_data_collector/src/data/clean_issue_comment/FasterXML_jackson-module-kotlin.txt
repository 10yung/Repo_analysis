 KotlinModuleclasscreateInstance Fails in runtime with Exception in thread main javalangIllegalArgumentException Class should have a single noarg constructor class comfasterxmljacksonmodulekotlinKotlinModule If I create exactly the same class declaration in my own code with default parameters then my class works with KClasscreateInstance Its probably an issue with some nondefault compiler options or version of Kotlin compiler that you are using Tested with and Kotlin I have Json to deserializecopying the problematic chunk below values IEnumerationValueClass EnumerationValueName id value id comment Indicates the calculation in net values name MonetaryNet type IDataTypeClass EnumerationType values IEnumerationValueClass EnumerationValueName id value id comment Indicates the calculation in gross values name MonetaryGross type IDataTypeClass EnumerationType values IEnumerationValueClass EnumerationValueName id value id comment Indicates the calculation is using times as unit name Time type IDataTypeClass EnumerationType values IEnumerationValueClass EnumerationValueName id value id comment Indicates the calculation is using volume as unit name Volume type IDataTypeClass EnumerationType values IEnumerationValueClass EnumerationValueName id value id comment Indicates the calculation is using bonus specific unit name Bonus type IDataTypeClass EnumerationType values name GLOBALUnitType comment type baseType DataType Integer kind mixed global true code name GLOBALUnitType comment type baseType DataType Integer kind mixed global true code name GLOBALUnitType comment type baseType DataType Integer kind mixed global true code name GLOBALUnitType comment type baseType DataType Integer kind mixed global true code When I try to deserialize following exception is thrown comfasterxmljacksondatabindexcInvalidTypeIdException Missing type id when trying to resolve subtype of simple type class IEnumerationValue missing type id property IEnumerationValueClass for POJO property values at Source StringReader line column through reference chain MainModel searchActions javalangObject Table columns javautilArrayList TableColumn types javautilArrayList ColumnDataType type EnumerationType values javautilArrayList EnumerationValue type EnumerationType values javautilArrayList From what I see After serializing the the json have the type info IEnumerationValueClass EnumerationValueName id but when the same id is refer in the json later on values Jackson is not able to recognize the type Interface JsonTypeInfo use JsonTypeInfoIdNAME include JsonTypeInfoAsPROPERTY property IEnumerationValueClass JsonSubTypes JsonSubTypesTypevalue EnumerationValueclass name EnumerationValueName public interface IEnumerationValue Child class JsonIdentityInfogenerator ObjectIdGeneratorsIntSequenceGeneratorclass propertyid public class EnumerationValue implements IEnumerationValue Serializable Cloneable Really appreciate the help Thanks So looks like there is a minor regression in master for SNAPSHOT regarding fix and one of tests for I will refactor test to have failing case for this issue in master branch I have a Either definition kotlin JsonTypeInfouse JsonTypeInfoIdNAME JsonSubTypes JsonSubTypesTypeEitherLeftclass name left JsonSubTypesTypeEitherRightclass name right sealed class Eitherout A out B class LeftAval value A EitherA Nothing class RightBval value B EitherNothing B that I use in a simple data class kotlin data class Foo val bar EitherString String val second String I create an instance and try to serialize kotlin return Foo bar EitherLeftaaa second bbbb but jackson throws an IndexOutOfBoundsException Caused by javalangIndexOutOfBoundsException Index at javabasejavautilCollectionsEmptyListgetCollectionsjava at comfasterxmljacksondatabindtypeTypeFactoryresolveTypePlaceholdersTypeFactoryjava at comfasterxmljacksondatabindtypeTypeFactorybindingsForSubtypeTypeFactoryjava at comfasterxmljacksondatabindtypeTypeFactoryconstructSpecializedTypeTypeFactoryjava at comfasterxmljacksondatabindcfgMapperConfigconstructSpecializedTypeMapperConfigjava at comfasterxmljacksondatabindDatabindContextconstructSpecializedTypeDatabindContextjava at comfasterxmljacksondatabindserBeanPropertyWriterfindAndAddDynamicBeanPropertyWriterjava at comfasterxmljacksondatabindserBeanPropertyWriterserializeAsFieldBeanPropertyWriterjava at comfasterxmljacksondatabindserstdBeanSerializerBaseserializeFieldsBeanSerializerBasejava common frames omitted Is it some misconfiguration on my side I am using jackson The introduction of KotlinObjectSingletonDeserializer in breaks the deserialization of Kotlin structures that could successfully be deserialized in Ive forked jacksonmodulekotlin and introduced three branches that demonstrate the problem and show a solution I branched from tag and introduced a test that passes successfully for this release see the test here I branched from tag and in this branch the same test now fails I branched from master and introduced a change to KotlinObjectSingletonDeserializer that fixes this particular issue such that the test passes again see the change here To quickly try this all out just do git clone gitgithubcomgeorgehawkinsjacksonmodulekotlingit cd jacksonmodulekotlin git checkout objectid mvn DtestcomfasterxmljacksonmodulekotlintestTestGithubX test INFO Tests run Failures Errors Skipped git checkout objectidbug mvn DtestcomfasterxmljacksonmodulekotlintestTestGithubX test ERROR Errors ERROR TestGithubXtest reading involving type id and object InvalidTypeId Miss git checkout masterobjectidfix mvn DtestcomfasterxmljacksonmodulekotlintestTestGithubX test INFO Tests run Failures Errors Skipped Above I check out the three branches in turn and for each ask Maven to run the test that Ive added for the based branch everything works fine for the based branch things break and then in the master based branch things are fixed You could merge my masterobjectidfix branch to fix this particular problem But Im actually going to suggest reverting the addition of KotlinObjectSingletonDeserializer instead KotlinObjectSingletonDeserializer was introduced to try and resolve issue Its certainly confusing for people if they deserialize an object and get a different instance of what was supposed to be a singleton But Jackson has so many special cases and so much clever logic for dealing with eg things like cycles JsonIdentityInfo etc and with things like generics JsonTypeInfo etc that its extremely difficult to cover all situations where Jackson deserializes stores and reuses objects KotlinObjectSingletonDeserializer as it is is just the beginning and it would require quite invasive changes elsewhere in Jackson not just the Kotlin module to be able to handle all cases Even with my change its still fairly trivial to construct a case where a new instance is returned by deserialization rather than the original singleton Eg see this test that fails irrespective of whether the change I made above to KotlinObjectSingletonDeserializer is applied or not To try this just do git checkout masterobjectinstancebug mvn DtestcomfasterxmljacksonmodulekotlintestTestGithubY test ERROR test reading a list of objects with idcomfasterxmljacksonmodulekotlintestTestGithubY Time elapsed s FAILURE javalangAssertionError second element is not the same instance as Child Ive added a detailed explanation of whats going on in this particular situation below But in short I think the problem is too complex to be easily addressed for all possible cases So I think its maybe better to just accept that unfortunately Kotlin singletons get deserialized to a different instance than to go with a solution that only works in a certain subset of simpler cases As such I think the addition of KotlinObjectSingletonDeserializer should be reverted Longer explanation The new KotlinObjectSingletonDeserializer wraps an instance of JsonDeserializer JsonDeserializer has quite a number of potentially overrideable methods see below but currently KotlinObjectSingletonDeserializer only delegates the three that Ive marked with an asterisk Of the remaining methods all but one of them marked with a minus below is overridden in at least one subclass in the standard Jackson libraries So it would be surprising if the fact that KotlinObjectSingletonDeserializer doesnt delegate these methods doesnt cause problems in circumstances where the given behavior is overridden in the wrapped deserializer createContextualctxt DeserializationContext property BeanProperty JsonDeserializer deserializep JsonParser ctxt DeserializationContext T deserializep JsonParser ctxt DeserializationContext intoValue T T deserializeWithTypep JsonParser ctxt DeserializationContext typeDeserializer TypeDeserializer Any deserializeWithTypep JsonParser ctxt DeserializationContext typeDeserializer TypeDeserializer intoValue T Any findBackReferencerefName String SettableBeanProperty getDelegatee JsonDeserializer getEmptyAccessPattern AccessPattern getEmptyValuectxt DeserializationContext Any getKnownPropertyNames CollectionAny getNullAccessPattern AccessPattern getNullValuectxt DeserializationContext Any getObjectIdReaderctxt DeserializationContext ObjectIdReader handledType Class isCachable Boolean replaceDelegateedelegatee JsonDeserializer JsonDeserializer resolvectxt DeserializationContext supportsUpdateconfig DeserializationConfig Boolean unwrappingDeserializerctxt DeserializationContext unwrapper NameTransformer JsonDeserializerT And even if you do delegate to the wrapped deserializer for these methods there are still issues that KotlinObjectSingletonDeserializer cant address Eg in the test I mentioned above JsonIdentityInfo is used When using JsonIdentityInfo its the delegate that stores identified instances The following stacktrace shows where the ID based storage happens initially in this test As you can see it happens in ObjectIdValuePropertydeserializeSetAndReturn which is called fairly deep down after KotlinObjectSingletonDeserializer has passed over control to the delegate deserializeSetAndReturn ObjectIdValueProperty comfasterxmljacksondatabinddeserimpl deserializeAndSet ObjectIdValueProperty comfasterxmljacksondatabinddeserimpl deserializeFromObject BeanDeserializer comfasterxmljacksondatabinddeser deserializeWithObjectId BeanDeserializerBase comfasterxmljacksondatabinddeser deserializeOther BeanDeserializer comfasterxmljacksondatabinddeser deserialize BeanDeserializer comfasterxmljacksondatabinddeser deserialize KotlinObjectSingletonDeserializer comfasterxmljacksonmodulekotlin deserializeTypedForId AsPropertyTypeDeserializer comfasterxmljacksondatabindjsontypeimpl deserializeTypedFromObject AsPropertyTypeDeserializer comfasterxmljacksondatabindjsontypeimpl deserializeWithType AbstractDeserializer comfasterxmljacksondatabinddeser deserializeWithObjectId CollectionDeserializer comfasterxmljacksondatabinddeserstd In the case of a singleton the delegate stores its deserialized duplicate of the original object rather than the original singleton that only KotlinObjectSingletonDeserializer knows about When Jackson then encounters an ID for an already stored instance it will use this deserialized duplicate it doesnt even give KotlinObjectSingletonDeserializer a chance to be involved in this process In the above stacktrace we can see that were deserializing a list so CollectionDeserializer is being used and that were storing an element of this list thats identified with an ID In this stacktrace below the same CollectionDeserializer has hit that ID again and as you can see it just looks up the ID directly via findObjectId it doesnt involve KotlinObjectSingletonDeserializer at all so the stored duplicate is retrieved rather than the original singleton instance findObjectId DefaultDeserializationContext comfasterxmljacksondatabinddeser deserializeFromObjectId AbstractDeserializer comfasterxmljacksondatabinddeser deserializeWithType AbstractDeserializer comfasterxmljacksondatabinddeser deserializeWithObjectId CollectionDeserializer comfasterxmljacksondatabinddeserstd Hence if you look at the test youll see the problem just with the second occurrence of the given singleton object and you would see the same issue with any further occurrences in a longer list class Bar tempVar SomeEnum null var id Long this class will fail to deserialize from the response of a restTemplate like restTemplatepostForObject mapOfString String Barclassjava Interestingly if you make class Bar in Java instead there arent any issues Also if you change the SomeEnum into another class or Long String etc there arent any issues Also it works when deserializing from RequestParam It exclusively fails when being deserialized from RestTemplate response when the class is defined in Kotlin has a constructor has a requiredoptional parameter that is not a fieldvarval while having a type of Enum issue demo If this is actually a Spring framework bug please close the issue With the following data class kotlin import comfasterxmljacksonannotationJsonPropertyOrder JsonPropertyOrderalphabetictrue data class Objectval a String val c Int val b false and the following main function kotlin fun mainargs ArrayString printlnObjectMapperregisterModuleKotlinModulewriteValueAsStringObjecta I get the following output aac bfalse ie constructor parameters first then fields Id expect all properties to be alphabetically sorted I wasnt sure if I was supposed to create these changes off of master or the branch since I was told Update any work to be current with the branch so for now I created one off the branch Let me know for future PRs if I should be branching off master instead Im not sure what your workflow is for maintaining multiple branches and releases I am trying to do kotlin class Idval name String val scope Int class Fooname String val age Int val id Idname val mapper ObjectMapperYAMLFactoryregisterKotlinModule val foo FooMary val s mapperwriteValueAsStringfoo val bar mapperreadValueFoos This fails with comfasterxmljacksonmodulekotlinMissingKotlinParameterException Instantiation of simple type class commetricstreammetadataserviceFoo value failed for JSON property name due to missing therefore NULL value for creator parameter name which is a nonnullable type at Source StringReader line column through reference chain commetricstreammetadataserviceFoo name It works if I change Foo to kotlin class Fooval id Id val age Int constructorname String age Int thisIdname age but I would like to keep the original Foo definition kotlin import comfasterxmljacksonannotationJsonSubTypes import comfasterxmljacksonannotationJsonTypeInfo import comfasterxmljacksondatabindannotationNoClass import comfasterxmljacksonmodulekotlinjacksonObjectMapper import comfasterxmljacksonmodulekotlinreadValue sealed class Entity data class Bacteriaval speciesName String Entity data class Diseaseval diseaseId Long Entity enum class EntityType MYBacteria MYDisease data class MyRequestBody val entityType EntityType JsonTypeInfo use JsonTypeInfoIdNAME include JsonTypeInfoAsEXTERNALPROPERTY property entityType defaultImpl NoClassclass visible true JsonSubTypes JsonSubTypesTypevalue Diseaseclass name MYDisease JsonSubTypesTypevalue Bacteriaclass name MYBacteria val entity Entity null fun main val jsonString entityType MYBacteria trimMargin val reader jacksonObjectMapper val deserialized readerreadValueMyRequestBodyjsonString printlndeserialized results in Exception in thread main comfasterxmljacksondatabindexcMismatchedInputException Missing property entity for external type id entityType at Source String entityType MYBacteria line column at comfasterxmljacksondatabindexcMismatchedInputExceptionfromMismatchedInputExceptionjava at comfasterxmljacksondatabindDeserializationContextreportInputMismatchDeserializationContextjava at comfasterxmljacksondatabinddeserimplExternalTypeHandlercompleteExternalTypeHandlerjava at comfasterxmljacksondatabinddeserBeanDeserializerdeserializeUsingPropertyBasedWithExternalTypeIdBeanDeserializerjava at comfasterxmljacksondatabinddeserBeanDeserializerdeserializeWithExternalTypeIdBeanDeserializerjava at comfasterxmljacksondatabinddeserBeanDeserializerdeserializeFromObjectBeanDeserializerjava at comfasterxmljacksondatabinddeserBeanDeserializerdeserializeBeanDeserializerjava at comfasterxmljacksondatabindObjectMapperreadMapAndCloseObjectMapperjava at comfasterxmljacksondatabindObjectMapperreadValueObjectMapperjava at MainKtmainMainkt at MainKtmainMainkt However if we change it to use JsonTypeInfoAsPROPERTY it works for the missing field kotlin import comfasterxmljacksonannotationJsonSubTypes import comfasterxmljacksonannotationJsonTypeInfo import comfasterxmljacksondatabindannotationNoClass import comfasterxmljacksonmodulekotlinjacksonObjectMapper import comfasterxmljacksonmodulekotlinreadValue sealed class Entityval entityType EntityType data class Bacteriaval speciesName String EntityEntityTypeMYBacteria data class Diseaseval diseaseId Long EntityEntityTypeMYDisease enum class EntityType MYBacteria MYDisease data class MyRequestBody JsonTypeInfo use JsonTypeInfoIdNAME include JsonTypeInfoAsPROPERTY property entityType defaultImpl NoClassclass visible true JsonSubTypes JsonSubTypesTypevalue Diseaseclass name MYDisease JsonSubTypesTypevalue Bacteriaclass name MYBacteria val entity Entity null fun main val jsonString val reader jacksonObjectMapper val deserialized readerreadValueMyRequestBodyjsonString printlndeserialized It successfully prints MyRequestBodyentitynull