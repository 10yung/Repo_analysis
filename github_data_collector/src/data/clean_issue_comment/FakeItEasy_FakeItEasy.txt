 Address all coding and style violations detected during a Release build send a regular pull request which must be merged before continuing ensure completeness of draft release notes including nonowner contributors if any move release notes forward from any prereleases to the current release before releasing check integration package compatibility AutoFixtureAutoFakeItEasy blairconrad broken by ReturnValue not set released in SetReturnValue is no longer found by FakeObjectCall Created AutoFixtureAutoFixture with two potential fixes submitted as PRs MachineFakesFakeItEasy AutofacExtrasFakeItEasy blairconrad tested with alpha aede f f ab fb cbe a fed EntityFrameworkTestingFakeItEasy blairconrad tested with alpha aede f f ab fb cbe a fed run tools preparereleasecmd next xyz vNext to change vNext names to appropriate xyz version for the next GitHub Release milestone and release checklist this issue create a new draft GitHub Release milestone and release checklist tag master with the new version number and push to upstream This will cause the build server to push the nupkgs to nugetorg attach all nupkgs from the tagged build to the GitHub Release add a comment to each issue and pull request in the release saying it was published in this release wait for NuGet package validation delist prerelease NuGet packages if present publish the GitHub release tweet mentioning contributors and post link as comment here for easy retweeting post tweet in Gitter add a note in each issue that has a significant contribution from a community member thanking the contributor close this issue if this is not a prerelease close the milestone for this release From a conversation in At that point I suggested a UserCallbackException but the documentation for that class says its An exception thrown when a userprovided callback throws an exception so we should either consider a different exception or update the docs for that class The Source Stepping documentation page is out of date It should be updated with instructions regarding SourceLink This article by Scott Hanselman has some configuration instructions Perhaps using the Try NET Global Tool See what Scott Hanselman has to say about it C introduced the default interface methods feature ie interface methods with a default implementation this feature works only on NET Core Currently its not possible with FakeItEasy to make a fake that calls the default implementation Using CallsBaseMethods doesnt work because CastleCore doesnt support this feature yet We should support default interface methods in FakeItEasy API options Reuse CallsBaseMethods to call the default interface methods in addition to what it currently does Introduce a new CallsDefaultImplementation to cover that scenario Maybe use a more explicit name default implementation could be misleading Implementation options Wait for CastleCore to support it Do it ourselves Default interface methods are methods whose declaring type is an interface and have IsAbstract false We need to call them nonvirtually otherwise it would cause infinite recursion POC implementation here GetCalls allows to get the call list of the faked object however making your way through it isnt as friendly as the rest of the API As such would it be possible to either Add a FakeItEasyConfigurationIReturnValueArgumentValidationConfigurationGetCalls method or Add the FakeGetCallsFakeItEasyConfigurationIReturnValueArgumentValidationConfiguration overload To immediately get the call list of a specifically setup call Having configured a fake object in strict mode I dont seem to be able to provide a fake method call for a method thats taking an anonymous object as its parameter Can you please add an example to the documentation providing information about how to deal with anonymous types in method call signatures My Code excerpt ACallTo converterToParametersnew loginName x functionId division stringnull Returnsnew ParameterDefinitionPowershell Exception Details Call to unconfigured method of strict fake IPowershellObjectConverterToParameters fAnonymousType SystemStringSystemInt SystemString anonymousObject loginName x functionId division This is kind of a question rather then a bug I am wondering if it might be smarter to validate all rules before throwing an exception that any one rule is not working See comments below in the code example c using System using FakeItEasy using MicrosoftExtensionsLogging using MicrosoftExtensionsLoggingInternal using MicrosoftVisualStudioTestToolsUnitTesting namespace fmExtensionsLoggingTests TestClass public sealed class FakeItEasyBugTests summary This test fails with Test method fmExtensionsLoggingTestsFakeItEasyBugTestsFailTest threw exception FakeItEasyUserCallbackException Argument matcher ex exMessage Test Exception threw an exception See inner exception for details SystemNullReferenceException Object reference not set to an instance of an object at lambdamethodClosure Exception at FakeItEasyCoreDefaultArgumentConstraintManager MatchesConstraintFakeItEasyCoreIArgumentConstraintIsValidObject argument in C projects fakeiteasy src FakeItEasy Core DefaultArgumentConstraintManagercsline End of inner exception stack trace at FakeItEasyCoreDefaultArgumentConstraintManager MatchesConstraintFakeItEasyCoreIArgumentConstraintIsValidObject argument in C projects fakeiteasy src FakeItEasy Core DefaultArgumentConstraintManagercsline at FakeItEasyExpressionsExpressionCallMatcherArgumentsMatchesArgumentConstraintsArgumentCollection argumentCollection in C projects fakeiteasy src FakeItEasy Expressions ExpressionCallMatchercsline at FakeItEasyExpressionsExpressionCallMatcherArgumentsMatchesArgumentCollection argumentCollection in C projects fakeiteasy src FakeItEasy Expressions ExpressionCallMatchercsline at FakeItEasyConfigurationRuleBuilderRuleMatcherMatchesIFakeObjectCall call in C projects fakeiteasy src FakeItEasy Configuration RuleBuildercsline at SystemLinqEnumerableCount TSource IEnumerable source Func predicate at FakeItEasyCoreFakeAsserterAssertWasCalledFunc callPredicate Action callDescriber CallCountConstraint callCountConstraint in C projects fakeiteasy src FakeItEasy Core FakeAssertercsline at FakeItEasyConfigurationRuleBuilderMustHaveHappenedCallCountConstraint callCountConstraint in C projects fakeiteasy src FakeItEasy Configuration RuleBuildercsline summary TestMethod public void FailTest ILogger fake AFakeILogger fakeTraceTest Message fakeTracenew ExceptionTest Exception Test Message ACallTo fakeLogobjectLogLevelTrace AFormattedLogValuesThatMatchesf fToString Test Message AExceptionThatIsNull AFuncobject Exception stringIgnoredMustHaveHappenedOnceExactly ACallTo fakeLogobjectLogLevelTrace AFormattedLogValuesThatMatchesf fToString Test Message The following line will fail because it is matched against the first log message which has no exception AExceptionThatMatchesex exMessage Test Exception AFuncobject Exception stringIgnoredMustHaveHappenedOnceExactly ACallTo fakeLogobjectLogLevelTrace AFormattedLogValuesThatMatchesf fToString Test Message Workaround check for null AExceptionThatMatchesex ex null exMessage Test Exception AFuncobject Exception stringIgnoredMustHaveHappenedOnceExactly Would be nice a new argument matcher for a collection of values that can be good if we are testing some method that process an argument list Something like this IsInOrderFromColection cs public interface IDep Doubleint n var mock AFakeIDep ACallTo mockDoubleAintReturns var numbers new foreach var n in numbers mockDoublen ACallTo mockDoubleAintThatIsInOrderFromColection MustHaveHappened it should verify if the Double method is called with and in sequence stakx is adding delegategenerating code to DynamicProxy lets create a spike that uses it to see how well it fits our model Ill make notes here so my inprogress investigation and inevitable backtracking doesnt pollute the discussion in 