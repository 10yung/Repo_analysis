When I call playStoreBillingClient QuerySkuDetailsAsync params method the internal callback I getSkuDetails failed Response code Then when I call playStoreBillingClient ConsumeAsync params method an internal callback occurred An internal error occurred I couldnt find the relevant solution please help me Several public functions of BillingRepository access the lateinit property playStoreBillingClient However it is optional for this property to be instantiated because startDataSourceConnections is optional to call BillingViewModel actually calls through to one of these functions queryPurchasesAsync with its own public function queryPurchases The Problem After purchase a nonconsumable product uninstall the app and reinstall the user cant restore their purchase Because in order to save the purchase result into the database as an entitlement the sample code called playStoreBillingClientacknowledgePurchase firstly but since purchase isAcknowledge is true the response is an internal error In Detail What did I do Using the sample code to implement my own IAP logic with one managed inapp product that is nonconsumable After installing the app to my device and successfully purchased this product then acknowledged purchase and update the local database Everything is Ok Then I uninstall the app and reinstall it after successfully established connection to Google Play onBillingSetupFinished queryPurchasesAsync processPurchases acknowledgeNonConsumablePurchasesAsync gets called What happens The response code in playStoreBillingClientacknowledgePurchase is an internal error because the purchase is already acknowledged so I cant restore the purchase What should happen I think Maybe in acknowledgeNonConsumablePurchasesAsync we should filter the list of purchases based on its acknowledge status and call disburseNonConsumableEntitlement on purchases that are already acknowledged so the user can restore their purchase on the device without launch billing flow again code maybe like private fun acknowledgeNonConsumablePurchasesAsyncnonConsumables ListPurchase val alreadyAcknowledged toAcknowledge nonConsumables partition itisAcknowledged alreadyAcknowledgedforEach disburseNonConsumableEntitlementit toAcknowledgeforEach purchase call playStoreBillingClientacknowledgePurchase and handle response The Java sample TrivialDrivev was never updated to the new API as mentioned in Im maintaining an older application where I have absolutely no desire to convert to Kotlin I want to update it to the latest Play billing API but the lack of a working Java sample makes that task very arduous Its ridiculous that such a high profile API critical for so many developers does not have a working official Java sample Please fix this I installed classy taxi and back end server I can log in with google account or email on both app and web app but if I click basic or premium nothing pops up asking me to purchase Ive set the two iap subscription items correctly I dont get an error or anything comauntecphoto EAndroidRuntime FATAL EXCEPTION main Process comauntecphoto PID javalangRuntimeException Unable to start activity ComponentInfocomauntecphotocomandroidbillingclientapiProxyBillingActivity javalangNullPointerException Attempt to invoke virtual method boolean javalangBooleanbooleanValue on a null object reference at androidappActivityThreadperformLaunchActivityActivityThreadjava at androidappActivityThreadhandleLaunchActivityActivityThreadjava at androidappActivityThreadwrap Unknown Source at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNative Method at comandroidinternalosRuntimeInitMethodAndArgsCallerrunRuntimeInitjava at comandroidinternalosZygoteInitmainZygoteInitjava Caused by javalangNullPointerException Attempt to invoke virtual method boolean javalangBooleanbooleanValue on a null object reference at androidosParcelreadExceptionParceljava at androidosParcelreadExceptionParceljava at androidappIActivityManagerStubProxystartActivityIntentSenderIActivityManagerjava at androidappActivitystartIntentSenderForResultInnerActivityjava at androidappActivitystartIntentSenderForResultActivityjava at androidappActivitystartIntentSenderForResultActivityjava at comandroidbillingclientapiProxyBillingActivityonCreateProxyBillingActivityjava at androidappActivityperformCreateActivityjava at androidappActivityperformCreateActivityjava at androidappInstrumentationcallActivityOnCreateInstrumentationjava at androidappActivityThreadperformLaunchActivityActivityThreadjava at androidappActivityThreadhandleLaunchActivityActivityThreadjava at androidappActivityThreadwrap Unknown Source at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNative Method at comandroidinternalosRuntimeInitMethodAndArgsCallerrunRuntimeInitjava at comandroidinternalosZygoteInitmainZygoteInitjava PurchaseState value of Purchase object is defined as below Purchasejava package comandroidbillingclientapi RetentionSOURCE public interface PurchaseState Purchase with unknown state int UNSPECIFIEDSTATE Purchase is completed int PURCHASED Purchase is waiting for payment completion int PENDING Returns the state of purchase public PurchaseState int getPurchaseState switch mParsedJsonoptIntpurchaseState PurchaseStatePURCHASED case return PurchaseStatePENDING default return PurchaseStatePURCHASED Why is the PurchaseState value of the JsonObject different from the numeric value of the defined State When you call queryPurchaseHistoryAync you receive a list of PurchaseHistoryRecord objects There is no state for judging purchase status from PurchaseHistoryRecord object It is likely that we need a State value to check whether the purchase of PurchaseHistoryRecord is completed refunded or consumed How can I check this Inventory Returns the listing details for an inapp product public SkuDetails getSkuDetailsString sku return mSkuMapgetsku Returns purchase information for a given product or null if there is no purchase public Purchase getPurchaseString sku return mPurchaseMapgetsku The user refunded but getPurchase returns a nonnull value Hello team User uses an account to login into our application and purchase subscription will attach this subscription to his account If the user login with another account on the same device and want to purchase a subscription for his account it doesnt work because the previous subscription is acknowledged and stay in the purchase it cannot be purchased again Could you let us know this behaviour is by designed The same subscription product can only be purchased one time on the same device