I maintain the tidyquery package which uses rlangexprdeparse to power the showdplyr function I would like to be able to disable the truncation of deparsed vectors and lists This PR adds a new argument maxlen to control this Thank you In ggplot we extensively use the pattern data default value as in color datacolor red This works great when we know what column we want to look up in the data frame but it fails if we want to do this with evaltidy because evaltidy fails instead of returning NULL In my own code Ive worked around this by defining a function evaldefault which works like evaltidy but swaps in a default value if evaltidy fails r libraryrlang evaldefault functionx data default forcedefault suppressWarnings tryCatch error functione default evaltidyx data data dataframex evaldefaultquox data NULL evaldefaultquoy data NULL NULL supCreated on by the reprex package v sup Based on the conversation here it seems Im not the only one running into this issue so maybe adding something like this function to rlang is justified One comment regarding my proposed implementation I had to add suppressWarnings to prevent a warning restarting interrupted promise evaluation that would sometimes pop up I find this warning sufficiently disconcerting that Im not sure I can just ignore it but I dont know enough about the internals of R evaluation to understand what the warning means and whether it can be avoided instead of suppressed Should be an error r setnames c NA This is undocumented as far as I can tell and might be a bug foo functionx printsubstitutex printrlangenexprx UseMethodfoo foodefault functionx printsubstitutex printrlangenexprx invisible bar baz foobar bar bar bar baz The gradethis package needed a way to standarise call but also include the default function arguments so code written as meanc and mean narm TRUE are marked as being the same We made a PR into gradethis that implements this behavior along with unit tests Would it make sense to submit this function as a PR into rlang Ive reproduced the function below for convenience r callstandardiseformals functioncode env rlangcurrentenv try to catch invalid function ie corrupt language object tryCatch fxn rlangcallfncode env env error functione returncode if existsfxn returncode some reason the above tryCatch doesnt go to the error part ifclassfxn function returncode standarise but dont bother trying to fill out default formals for primitives like mean unable to distinguish between mean and meandefault if isinfixcode isprimitivefxn returnrlangcallstandardisecode forms rlangfnfmlsfxn defaultparams forms vapplyforms issymbol logical USENAMES FALSE codestd rlangcallstandardisecode env env order and label existing params codeparams rlangcallargscodestd get arguments passed from user codemissingdefaultargs defaultparams namesdefaultparams in namescodeparams if lengthcodemissingdefaultargs returncodestd return rlangcallstandardiserlangcallmodifycodestd codemissingdefaultargs env env I feel like if the argument is not missing it should check that the input is a string not a character vector I think I wanted an error here r myfn functionx ca b c rlangargmatchx myfnca c a myfnca d a supCreated on by the reprex package v sup Currently r rlangsetnamesNULL character Error x must be a vector supCreated on by the reprex package v sup Would it be safe to return NULL here There is a limit for the length of the error message the default is characters and it can be set higher but the max is Since the trace is printed as part of the error message this means that the trace can be truncated which is especially not great in noninteractive sessions Eg r catdeparsesubstitute ff lapply functioni assign paste f i function docallpaste f i list envir GlobalEnv f function rlangabortoops f file tmp tempfile sep n out processxrunR cq f tmp catoutstderr Error oops Backtrace f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list f basedocallpaste f i list globalf supCreated on by the reprex package v sup r a function b b function c c function abortlowlevel f function g g function h h function tryCatcha error functionerr aborthighlevel parent err f Error highlevel Call rlanglasterror to see a backtrace lasterror errorrlangerror highlevel Backtrace globalf globalg globalh Call rlanglasttrace to see the full backtrace lasttrace errorrlangerror highlevel Backtrace globalf globalg globalh parent errorrlangerror lowlevel Backtrace globala globalb globalc lasterrorparent errorrlangerror lowlevel Backtrace globalf globalg globalh globala globalb globalc lasterrorparenttrace globalf globalg globalh basetryCatch basetryCatchListexpr classes parentenv handlers basetryCatchOneexpr names parentenv handlers L basedoTryCatchreturnexpr name parentenv handler globala globalb globalc Comments from gaborcsardi It would make sense to indicate in the default output that there is another level Even the lasterror output does not indicate that actually You probably end up staring at the error for a bit and then calling lasterror as suggested and then after some more staring lasttrace as suggested And youd better not mistype either one because then the last error object will be gone Having to call parent to get a complete stack is not great especially if you have more than two levels ie lasterrorparentparent etc The same with lasterrorparentparenttrace etc Having different numbers for the parent frames in lasttrace might be confusing Personally I would prefer if the numbers were not mangled and they referred to the real frame numbers There is no way to see all error messages and a full stack in the same output Personally this is my preferred output as above as it shows all information and the levels are clearly separated by whitespace and they are easy to parse I can decide how deep I need to dig into the output without issuing additional commands Relatedly I am not sure that having all these different kinds of output is great People need to learn to parse all of them and think about whether the information they are looking for is missing in general or they need the other kind of output etc