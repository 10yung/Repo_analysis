This PR implements the approach proposed in It uses reflection to discover the case class properties and then uses the manual derivation for defining the ConfigReader Reflection is only used once per case class to discover the property names at time of initializing the reader Usage Define a case class MyClass scala package example case class MyClass boolean Boolean port Port adt MyAdt list List Double map Map String String option Option String Now define the ConfigReader It can be either placed in companion object for MyClass or in package object scala import pureconfig import pureconfigmodulereflectReflectConfigReaders package object example implicit val myClassConfigReader ConfigReader MyClass configReader MyClass Here we use any of the configReaderXXX method where xxx is based on arity of case class to define the ConfigReader Now one can simply do sourceload MyClass to create MyClass instance from config Key aspects Supports only case class Does not support sealed traits value classes and tuples No dependency on any other library like Shapeless Minimal impact on compilation time As this module does not Shapeless there is no major impact on compilation timing In our project we have seen reduction in timing for compilation Compilation time reduced from sec to secs See apacheopenwhisk for more stats Currently does not support default values Support for this can be added later if needed Test cases are based on tests done for pureconfigmangolia module Lets try out GitHub Actions as an alternative to Travis The advantages are that have better integration with GitHub duh and they are more flexible allowing us to automate some more workflows in the future not strictly related to CI and not necessarily triggering on pushes and PRs In this PR the only things not on par with our Travis build are Cache dependencies the mechanism to cache things is a bit more complex than in Travis However GitHub seems to be outperforming Travis anyway m s on GitHub vs m s on Travis with GitHub builds triggering earlier so we can start without caching and iterate later if needed Upload coverage to Coveralls see TODO on workflow definition Since we havent disabled Travis yet well continue to have coverage data PR comments on website changes this would actually be easier now as GitHub provides us a token but since jobs are shown separately in PR checks this is not needed anymore we can simply make diffwebsite not pushblocking Some other ideas to use GitHub Actions in the future Publish a snapshot JAR to Sonatype automatically each time we push to master Publish the website to pureconfiggithubio on every tag push risky for now the script is not foolproof We can leave both GitHub Actions and Travis running for a while to evaluate whether we are good to move definitely and whether we want it This PR proposes a refactoring to ProductHints and CoproductHints in order to make them more general The idea behind this is to allow better customization of derived readers and writers regardless of the derivation code used to produce them Incidentally this moves a lot of repeated code between shapelessbased and magnoliabased derivation to the hints This also enables which I leave for a future PR This is obviously not binary compatible with older versions of PureConfig However only custom implementations of ProductHint not created via ProductHintapply and CoproductHint need to be migrated This also modifies the derivation of readers for case classes in pureconfigmagnolia to accumulate errors at the expense of using the unsafe rawConstruct I ended up doing so because the constructMonadic interface of Magnolia doesnt play very well with the proposed ProductHint interface of returning both the result of reading a field and the next ConfigObjectCursor to use Hi with version ConfigSourceresourcesresourceName fails yet ConfigSourceurl works specifically see this code gist I can find the resource turn it into a URL and resolve it OK using ConfigSourceurltheurl but if I use resources for an absolute resource it fails with the exception main ERROR cstMainServer Uncaught exception in main class Exiting javalangExceptionInInitializerError null at commycompanyfooMainServerrunMainServerscala at catseffectIOAppanonfunmain IOAppscala at catseffectinternalsIOAppPlatformmainFiberIOAppPlatformscala at catseffectinternalsIOAppPlatformmainIOAppPlatformscala at catseffectIOAppmainIOAppscala at catseffectIOAppmainIOAppscala at commycompanyfooMainServermainMainServerscala at commycompanyfooMainServermainMainServerscala at javabasejdkinternalreflectNativeMethodAccessorImplinvoke Native Method at javabasejdkinternalreflectNativeMethodAccessorImplinvokeNativeMethodAccessorImpljava at javabasejdkinternalreflectDelegatingMethodAccessorImplinvokeDelegatingMethodAccessorImpljava at javabasejavalangreflectMethodinvokeMethodjava at comintellijrtexecutionapplicationAppMainV mainAppMainV java Caused by pureconfigerrorConfigReaderException Cannot convert configuration to a comskyfiitokeniserconfigConfiguration Failures are Unable to read resource applicationdevconf resource not found on classpath applicationdevconf at pureconfigConfigSourceloadOrThrowConfigSourcescala at pureconfigConfigSourceloadOrThrowConfigSourcescala at pureconfigConfigSourceanon loadOrThrowConfigSourcescala at mycompanyfooconfigConfigurationforEnvironmentConfigurationscala at mycompanyfooServerStreaminitMainServerscala at mycompanyfooServerStreamclinitMainServerscala common frames omitted Currently our modules are organized in a complex and tricky way We have test utilities testkits mixed with test suites and we have module tests depend on both of them Even though we define generic as a module it has a special status since all tests and tut code depend on it making it impossible for pureconfiggeneric to have tests using BaseSuite and for us to generalize project definitions in buildsbt All tests depend heavily on generic derivation even when were only testing unrelated pureconfigcore classes The effort to have an alternative derivation module will create more special modules Ideally I see our project having a structure like this All documentation including modulespecific docs in a single docs project that is rendered on the website this is also required by A testkit project containing only test utilities This could be elevated later to a public published module if we decide to get it mature enough Test suites live in their related projects like coresrctest or modulesgenericsrctest What do you think about this proposal jcazevedo and leifwickland Currently every time our build detects a change in the website content on a PR from an external contributor ie from a forked repo the script fails That is happening because of this We need to find a workaround for these cases The builds for our commits bumping to a stable version automatic issued by sbtrelease always fail because the example project cannot find the appropriate version Example ca bf f f e e cbd ec f b ccd Travis build We should probably set the PureConfig version in the example project dynamically by reading versionsbt Tut is being abandoned in favor of mdoc so we should try to migrate our documentation This would also allow us to start compiling the documentation against Scala I tried to do this before and I hit some roadblocks at the time Some things might have changed but well probably need some structural changes in our repo Say I have a project with two applicationconf one in mainresources and the other in testresources Now when I use pureconfigloadConfig SomeConfig in the test classes to load test configs I find the main configs in the mainresources will also be merged in the following codes from comtypesafeconfigimplParseable java protected AbstractConfigObject rawParseValueConfigOrigin origin ConfigParseOptions finalOptions EnumerationURL e loadergetResourcesresource while ehasMoreElements Here both applicationconf in scala classes and scala testclasses will be loaded and MERGED Because both applicationconf in scala classes and scala testclasses are merged some substitute values in mainresources will be also needed in the Config of test classes which is not clean Any idea quick example model case class Foo strictProp String stringWithDefault String FooDefaultString optionWithDefault Option String FooDefaultOption object Foo val DefaultString String defaultname val DefaultOption Option String None tryout val raw ConfigFactory parseString strictProp foo val config pureconfigloadConfig Foo raw result RightFoofoo null null it can be fixed by specifying default values inplace like this case class Foo strictProp String stringWithDefault String defaultname optionWithDefault Option String None but can we have original example working as well thanks