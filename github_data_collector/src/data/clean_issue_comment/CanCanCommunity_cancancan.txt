context KernelArray calls not only Objecttoary but also Objecttoa but some classes which represent cluster may implement toa I think thats why ActiveSupport has Arraywrap I confirmed theres no performance regression via the following snippet ruby require bundlerinline gemfiletrue do source gem benchmarkips gem cancancan gem allocationtracer end module CanCan class Rule def initializebasebehavior action subject conditions block flag bothblockandhasherror You are not able to supply a block with a hash of conditions in action subject ability Use either one raise Error bothblockandhasherror if conditionsisaHash block matchall actionnil subjectnil basebehavior basebehavior case flag when array actions Arrayaction subjects Arraysubject when flatten actions action flatten subjects subject flatten when wrap actions wrapaction subjects wrapsubject else raise end conditions conditions block block end def wrapobject if objectnil elsif objectrespondtotoary objecttoary object else object end end end end def memprofname GCdisable before ps o rss p Processpidsplit nlasttoi ObjectSpaceAllocationTracertrace do times do yield end end after ps o rss p Processpidsplit nlasttoi puts name Mem diff after beforetof MB GCenable GCstart end puts Ruby RUBYVERSION memprofKernelArray CanCanRulenewnil read write foo bar nil nil flag array memprofArrayflatten CanCanRulenewnil read write foo bar nil nil flag flatten memprofArraywrap CanCanRulenewnil read write foo bar nil nil flag wrap Benchmarkips do b breportKernelArray CanCanRulenewnil read write foo bar nil nil flag array breportArrayflatten CanCanRulenewnil read write foo bar nil nil flag flatten breportArraywrap CanCanRulenewnil read write foo bar nil nil flag wrap bcompare end END Ruby KernelArray Mem diff MB Arrayflatten Mem diff MB Arraywrap Mem diff MB Warming up KernelArray k i ms Arrayflatten k i ms Arraywrap k i ms Calculating KernelArray k is k in s Arrayflatten k is k in s Arraywrap k is k in s Comparison KernelArray is Arraywrap is sameish difference falls within error Arrayflatten is sameish difference falls within error Ruby KernelArray Mem diff MB Arrayflatten Mem diff MB Arraywrap Mem diff MB Warming up KernelArray k i ms Arrayflatten k i ms Arraywrap k i ms Calculating KernelArray k is k in s Arrayflatten k is k in s Arraywrap k is k in s Comparison Arraywrap is KernelArray is sameish difference falls within error Arrayflatten is sameish difference falls within error Ruby KernelArray Mem diff MB Arrayflatten Mem diff MB Arraywrap Mem diff MB Warming up KernelArray k i ms Arrayflatten k i ms Arraywrap k i ms Calculating KernelArray k is k in s Arrayflatten k is k in s Arraywrap k is k in s Comparison KernelArray is Arraywrap is sameish difference falls within error Arrayflatten is x slower Hi consider the following ability class MyAbility include CanCanAbility def initialize can i index show Product countonhand FloatINFINITY nil end end ability MyAbilitynew The user should have access to products that have countonhand set to nil or at least This works when using accessibleby puts Productaccessiblebyabilitytosql SELECT products FROM products WHERE productscountonhand IS NULL OR productscountonhand However when using it via can it doesnt work puts abilitycanshow Productnewcountonhand false WRONG I digged into the source code and found out that it simply uses a valueincludeattribute when an Enumerable is used for a matcher def conditionmatchattribute value case value when Hash hashconditionmatchattribute value when Range valuecoverattribute when Enumerable valueincludeattribute her it asks FloatINFINITY nil include which is false else attribute value end end It would be great if the behaviour for hash conditions used for scopes and on a per object basis would be the same Unfortunately I cant use cannot i index show Product countonhand because this would exclude rows where countonhand is NULL For now Im using a monkeypatch like this def conditionmatchattribute value case value when Hash hashconditionmatchattribute value when Range valuecoverattribute when Enumerable valueany v conditionmatchattribute v else attribute value end end But Im unsure if this is a good the right solution Hiya So Ive implemented slugs on the pokemon model in this app In the routes file I have resources pokemons param slug In the pokemonscontrollerrb I am attempting to utilize loadandauthorizeresource but unfortunately it isnt working Im fairly certain it has something to do with my routes using slug in params instead of id FWIW I also tried loadandauthorizeresource findby slug and that didnt work either I am open to any suggestions undefined method definedenums for Class x b f d d Getting error on this line if can update campaign Starting distinct used in buildrelation if joins present DISTINCT would fail when used on tables with json columns PostgreSQL have no equality operator for type json Example ERROR could not identify an equality operator for type json LINE SELECT DISTINCT users FROM Looks like this is regression so added spec to cover this case This PR intentionally fails TravisCI on develop branch for postgresql adapter due to regression What is the problem Looks like there is no ability for noncallorators to edit the wiki pages See here for example I am unable to amend the wiki documentation Whats wrong with that It places additional burdens on the maintainers of the gem to update the documentation A lot of people can assist in fixing small issues here and there if they can edit the wiki How to fix Please change access permissions for wiki pages See here Steps to reproduce Define two rules can manage all cannot i index retrieve Model Modelfromsandbox do msandbox end When accessing the index action I receive the following error Unable to merge an Active Record scope with other conditions Instead use a hash or SQL for index Model ability from following method def overridescope conditions compressedrulesmap conditionscompact return unless conditionsany c cisaActiveRecordRelation return conditionsfirst if conditionssize raiseoverridescopeerror end Because compressedrules in ActiveRecord Adapter is set as follows pryCanCanModelAdaptersActiveRecord Adapter compressedrules CanCanRulecannot index retrieve Modelattributes type Model CanCanRulecan manage all the overridescope method would succeed if only one condition exists But the rules defined above are not merged Expected behavior cannot with scope should overwrite can manage all for a specific model for the index action Actual behavior It raises the error mentioned above System configuration Rails version Ruby version p revision x linux CanCanCan version Thanks in advance Best regards Lukas When applying filters with related entities CanCan used to generate a LEFT JOIN plus a DISTINCT clause to avoid repeated records This is problematic for a number of reasons Postgres is picky about setting ORDER BY with a column not on the DISTINCT clause because it applies the ORDER after the DISTINCT so it cannot see the referenced column Groups and Counts become more difficult to do because foodistinctcount is not the same as foocount The way to avoid this problem is to use inner queries that dont multiply the number of returned records We do this by running the query we were previously using inside a WHERE IN block This is a different approach than cc ghiculescu Fixes Just ran into an issue here If I pass throughassociation and singleton things dont work It should check and send options throughassociation if set I guess The original issue has already been closed Please see my rationale rationale below x Add tests x Changelog entry Updates beableto matcher with a negative expectation handler Now if you pass an array of abilities while using notto the expectation will fail if any of the specified abilities turn out to be permitted Previously the following test would pass despite the user only being able to read posts ruby it isexpectednotto beableto create read Post class Ability include CanCanAbility def initializeuser can read Post end end Rationale The matchers current behavior when handling negative expectations is unlikely to be useful in many situations Because its behavior is unexpected it is easy to accidentally write tests that look like theyll work but then unexpectedly pass This can be very dangerous if a developer doesnt realize how the matcher actually behaves when initially implementing the test The next best approach to confirm that an ability cannot be used would be to iterate over an array of abilities and test them individually This is a bit verbose and difficult to read especially compared to the awesome oneliner already provided 