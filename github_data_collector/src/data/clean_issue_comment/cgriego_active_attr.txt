This introduces a UUID typecasting option which effectively functions as a string but coerced to nil unless the string exactly matches the UUID pattern This fixes issue Hi there Im using Neo J which uses this gem for attribute declaration Im also building a Rails app that uses UUIDs as primary keys in my Postgres database I would like to be able to reference these primary keys eg userid and have them be of the UUID type This could look something like class Node include ActiveAttrTypecastedAttributes attribute userid type UUID end Currently Im using type String but that doesnt ensure that the given value is actually a UUID and I have to write Active Model validators to ensure this which is a bit of a pain Any pointers on where to start working on a PR is much appreciated Thanks We recently ran into a memory issue that I successfully traced back to the creation of an anonymous class Classnew based on a type that includes AttriveAttrBasicModel Below is the simplest form of the scenario demonstrating the Class objects eating up memory It looks like the Class objects are somehow being held on to which might be ok in general but not ideal in case of an anonymous class instance created each time Running this test for any class that does not involve AttriveAttrBasicModel clears up the memory as expected I am not proposing that creating anonymous classes like this is a best practice We removed this pattern from our code base but ideally this shouldnt have happened ruby require activeattr class MyClass include ActiveAttrBasicModel end def classobjectcount ObjectSpacecountobjects TCLASS tos end puts classobjectcount Classes Before times ClassnewMyClass puts classobjectcount Classes After GCstart puts classobjectcount Classes After GC ruby class MyItemObject include ActiveAttrModel attribute one attribute two end Class MyObject include ActiveAttrModel attribute myobjects type MyArrayObject typecaster values valuesmap value MyItemObjectnewvalue end object MyObjectfromjsonjsondump puts objectmyobjectsobjectid puts objectmyobjectsobjectid This will produce a different objectid at each run Cant say I expected this If typecasting results are temporary perhaps they should be returned as frozen Documents known options for attribute and attribute There may be others that Im not aware of All of the default typecasters are stateless so allocating a new instance for each field becomes extremely costly especially for larger models To reduce this we can memoize the TYPECASTERMAP This should be a backwards compatible change with a speed boost The only people who might have trouble are those who modified the typecaster map This is a frozen constant though so nobody should be touching this This is currently about quicker on a model with fields The benchmark creates a model and then calls tojson I also ran the benchmark on a smaller model with only String fields and saw a improvement Currently typecasting works on attribute reading There are two defects every reading is every typecasting if typecasted class has attributes they cant be changed because typecasting creates a new instance every time I suggest typecasting on writing It avoids from both defects This conversion is done by Transpec with the following command transpec f conversions from objshould to expectobjto conversions from expected to eqexpected conversions from it should to it isexpectedto conversions from objshouldreceivemessage to expectobjto receivemessage conversions from objshouldnot to expectobjnotto conversions from it shouldnot to it isexpectednotto conversion from expected to be expected conversion from to matcharray conversion from expected to be expected conversion from objstubmessage to allowobjto receivemessage For more details 