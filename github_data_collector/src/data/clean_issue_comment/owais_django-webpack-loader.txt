 alpha has been released and it only supports webpack and newer djangowebpackloader should drop support for older webpack versions and rely on alpha of webpackbundletracker This mainly means updating the test suite and making sure it passes with webpack and bundle tracker Starting this issue to track what should go into This will be a backwards incompatible release so we have a chance to improve things we couldnt before For one will only support webpack and newer Please add a comment or link to an issue if youd like it to be resolved in Ive used djangowebpackloader in a singleapp django site and it serves me well thanks owais Now I want to break up my django app into reusable apps which Ill add to INSTALLEDAPPS These reusable apps will contain templates and javascript which Id like to compile with webpack and reference in the templates with djangowebpackloader as I currently do in my singleapp site I want the templates and the js they contain to work out of the box when I add the app to the django site I havent found a way to do this yet Currently the sites settingspy can contain something like python WEBPACKLOADER DEFAULT BUNDLEDIRNAME bundles STATSFILE ospathjoinBASEDIR webpackstatsjson DASHBOARD BUNDLEDIRNAME dashboardbundles STATSFILE ospathjoinBASEDIR webpackstatsdashboardjson Great I can define as many webpack projects as I want However if one of my webpack projects is an INSTALLEDAPP as opposed to a subdirectory of BASEDIR I need to find the path to the apps webpack stats I can think of a hacky way to do this importing the apps package then looking up its file attribute then finding webpackstats from there But that makes integrating the app that much harder and introduces more coupling between the site and the app than is necessary Ideally Id like something analogous to djangos collectstatic Id give webpack loader a STATSFILEDIRNAME config telling the loader the names of the directories containing webpackstatsjson files The loader would collect webpackstats from all app directories with that name So my webpack config in settingspy might look like python WEBPACKLOADER DEFAULT BUNDLEDIRNAME bundles STATSFILEDIRNAME stats Then when using renderbundle in an html template I could specify the apps name like so renderbundle DJANGOAPPNAME BUNDLENAME The template tag would look up the appropriate webpackstatsjson file for that app The author of this SO question seems to be looking for the same thing Does anyone have thoughts on how to accomplish this When using renderbundle stylebase css djangowebpackloader renders link typetextcss hrefstaticdistcssstylebase b css relstylesheet link typetextcss hrefstaticdiststylebasecss relstylesheet Is there anyway to tell webpack not to render both the hash version and the hashless one or djangowebpackloader to keep only the hash version path Thanks The django community is very dependent on this package however its now outdated enough that it no longer works according to the documentation Can the maintainer please add some other admins onto this project so we can get it working again If not Im happy to fork it and start accepting pull requests for fixes Context I am using djangowebpackloader in a multipages Django app that runs VueJS components in Django templates I set the publicPath option in webpack to an empty string so that I can control the static url from the Django settings and properly use a CDN server as described in Issue JS and CSS assets are saved to css and js subfolders Here is what webpackstatsjson looks like status done chunks compA name csscompAcss path D home site wwwroot commonstatic assets frontend css compAcss name csscompA e ce ddc fdcss path D home site wwwroot commonstatic assets frontend css compA e ce ddc fdcss Note that the chunk name uses a UNIXlike path csscompAcss In settingspy I have the following configuration WEBPACKLOADER DEFAULT when true webpack will read stats file only once and cache results CACHE not DEBUG dir in which webpack outputs the bundles it should not be full path BUNDLEDIRNAME ospathjoinassets frontend add a trailing slash location of the bundle tracker file STATSFILE STATSFILE POLLINTERVAL TIMEOUT None IGNORE r hotupdatejs r map The BUNDLEDIRNAME value ends up being assets frontend on Windows With these settings djangowebpackloader prints an invalid path in the Django template by concatenating BUNDLEDIRNAME with the chunk name static assets frontend csscompAcss The issue is in the getchunkurl of webpackloaderloaderpy def getchunkurlself chunk publicpath chunkgetpublicPath if publicpath return publicpath relpath format selfconfig BUNDLEDIRNAME chunk name return staticfilesstorageurlrelpath Concatenation does not take into account that the two relative paths may be formatted differently In addition it requires the BUNDLEDIRNAME settings to end with a slash Solution This issue is easily fixed by replacing the path concatenation with def getchunkurlself chunk publicpath chunkgetpublicPath if publicpath return publicpath relpath ospathnormpath ospathjoinselfconfig BUNDLEDIRNAME chunk name return staticfilesstorageurlrelpath This makes the path concatenation OSindependent and allow greater flexibility to define output paths in the webpack config For one loaders is changed to rules Then nodemodulesbinwebpack config webpackconfigjs Invalid configuration object Webpack has been initialised using a configuration object that does not match the API schema configurationresolve has an unknown property modulesDirectories These properties are valid object alias aliasFields cachePredicate cacheWithContext concord descriptionFiles enforceExtension enforceModuleExtension extensions fileSystem mainFields mainFiles moduleExtensions modules plugins resolver symlinks unsafeCache useSyncFileSystemCalls Options for the resolver Im not familiar with webpackbabel and an updated guide that just works would be appreciated Added an option to specify css file with relpreload renderbundle commons css ispreloadTrue It renders to link typetextcss hrefstaticdistcommonsce c c a f d d bundlecss relpreload asstyle In other word I havnt to press F to preview the modification just like a pure frontend project with hot replacement enabled