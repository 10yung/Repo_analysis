 cranks We crank library versions pretty aggressively on OpenBSD and libFAudio is already out of sync Better to leave out the SO version suffix on OpenBSD and leave it to the porter me The current FNA code implements this logic structure to push data to the main thread from a different one csharp public class ADevice IGLDevice public void AGLMethodCall if DISABLETHREADING ForceToMainThread endif code if DISABLETHREADING endif This patch aims to remove the implicit new Action allocation in runtime in this way csharp public class ADevice IGLDevice public void AGLMethodCall if DISABLETHREADING if mainThreadId ThreadCurrentThreadManagedThreadId endif code if DISABLETHREADING else ForceToMainThread code endif The code formatting should be the same now I have a set of RenderTarget Ds I rotate through and then call GetData on to read back the result of rendering operations GetData operations usually occasionally dont for no obvious reason block until vsync under these circumstances while they take about ms under windows d d XNA I tried lots of stuff and have come up with exactly one workaround If its blocking on vsync what if I get rid of vsync csharp SDL SDLSDLGLSetSwapInterval instanceGetDatabuffer SDL SDLSDLGLSetSwapInterval Occasionally I dont seem to get a Cursed Context at startup and the GetData calls are speedy without doing this so it seems to be something weird in the GL ICD Its more likely to work right in Release builds of FNA Forcing the core context or compatibility context seems to have no impact EDIT Also this applies to both forms of readback glReadPixels from an RT while its bound and reading via glGetTextureSubImage The Vulkan specification has been released The quick reference manual is here Example code can be found here This will act as a tracker for a possible alternative to the FNA OpenGLDevice that uses Vulkan for graphics driver interaction There would be a handful of benefits including a dramatic reduction in CPU overhead something we desperately need as a C project as well as better use of XNA s GraphicsDevice render state bindings but the downside is that it requires higherspec graphics hardware no matter how fast it ends up being Additionally this would mean maintaining two separate devices which means more regression testing for critical graphics changes Apple does not have native Vulkan support but MoltenVK should allow us to use it via Metal similar to our D D support via ANGLE A high level overview of the work needed to get a VulkanDevice x Implement a SPIRV emitter for MojoShader x Integrate ARBglspirv into MojoShader Start with a clone of the ModernGLDevice or MetalDevice Port individual pieces of the GLDevice to Vulkan until device is Vulkan If required create a MOJOSHADERvk API In theory Vulkan should be more compatible with XNA than OpenGL and we may even be able to use XNA s own limitations to our advantage when wrangling any possible use cases thereby eliminating overly generic cases typically handled by drivers and further reducing overhead but part of having explicit control will mean taking in responsibilities previously handled by driver vendors and the difficulty of such responsibilities should NOT be underestimated This will act as the monolithic thread for bringing our static analysis warnings down to for ALL possible analyzers For starters here are our current reports VS The Utilities folder is the only folder that is NOT to be touched This is because we need to keep MonoGame compatibility for these files in particular In addition we will NOT be touching the StockEffects since those came directly from Microsoft so changing them would only be more inaccurate Lastly these reports include messages for thirdparty libs you ignore these warnings For this task simply take any task in the report you want letting us know youre doing so send me the PR to fix it and Ill update the report Ideally we should be able to properly fix all of these defects but some are by XNA s design for example MicrosoftXnaFrameworkInputTouch is a massive namespace and Gendarme reports this but we cant change this without breaking XNA compatibility In these situations add a line to suppress the warning and document why the suppression is needed As we get closer to resolving all the warnings Ill be lowering the threshold for warning level and certainty so expect more defects to show up as the list gets smaller If you decide to take a task please post here and let us know youre working on it Because were doing so much work on so much code we need to be sure were not conflicting with other branches