I have been trying to flash digisparks firmware and noticed the run option is quite mandatory while applying the firmware to remove s delaly Why do we need to pass the run argument to micronucleus while uploading the firmware Dont we just want to flash the firmware and not run it at that time Why does it all go crazy when we dont provide the run argument Also while trying to flash another firmware after this would I need to connect P to GND This configuration allows operating the controller down to V as long as the bootloader is not activated eg entry condition not met This allows for coin cell operation still not losing bootloader functionality when a USB cable is plugged This branch build upon and can be seen of an example implementation For certain applications there could be the need to operate the AVR on low voltage meaning it would not run properly on MHz A flag CKDIVRESET is introduced that runs after the bootloader entry has been decided and clears CKDIV to Another flag CKDIVRESTOREDEFAULT allows resetting CKDIV to the reset value before entry of the application so the application sees the same clock speed as it does without the bootloader being activated before See my second PR for a branch with a demo configuration Changes Convert firmwarereleasesm pextclockhex to LF Upgrade all upgradereleaseshex to firmware Add upgradereleasesm pextclockhex Also fixes LGT F P Arduino Clone Chip ATMega P It has high speed internal MHz RC that means no ext oscillator needed for vusb application It has different flash compare to the original mega p the page size is kB and it can only write by bit the relocated interrupt table base address has to be byte aligned Sorry but my english is bad I use google translator In Release using the command to view the recorded version I get the information Please plug in the device Press CTRLC to terminate the program Device is found connecting complete connecting complete connecting complete connecting complete Device has firmware version Device signature x e b Available space for user applications bytes Suggested sleep time between sending pages ms Whole page count page size Erase function sleep duration ms Error opening mainhex No such file or directory Error loading or parsing hex file I use the line micronucleusmaster commandline micronucleus run type intelhex mainhex Is it my mistake or the new version Sorry but my english is poor I use google translate In Release and at some point USB plug or unplug I lose access to the program written to the Digispark card After reprogramming with the Arduino IDE it works again My program is a button USB HID Joystick Does anyone know if this problem is known I get the same error that but solutions mentioned there not worked for me According if I plug my Digispark clone to USB USB hub or not I randomly get on of these errors or micronucleus librarymicronucleuslibc micronucleusconnect Assertion res failed I use Arduino IDE and Ubuntu I already edited udev rules and attempted to run Arduino IDE as root I only get different errors Can you help me I m using an Attiny which is programmed over USB micronucleus I m using the Tiny in an standalone circuit with analog sensors on A A if the analog values are low ca V the Micronuleus ist running instead of the loaded application The Version is working fine I had a look at disassembled v t default Id like to discuss some changes in firmware code in order to help improve compactness without changing algorithm there are unused registers r r r and SRAM accesses by ldssts commands to access variables by placing the global variables of usbdrvc into registers as it is done with currentAddress and idlePolls in mainc would save bytes eg uchar usbDeviceAddr change to register uchar usbDeviceAddr asmr there are SRAM accesses by ldssts commands to read or write data in the transmitreceive buffer accessing them with a basepointer displacement would save bytes the functions bootpageerase bootpagewrite and bootpagefill as defined in booth waste bytes each by accessing SPMCSR as a RAMlocation sts command instead of a port register out command bytes usbCrc Append is very short as it is called only once it could be placed inline bytes as long as usbCrc is called only once it could be placed inline too bytes the smaller version of usbCrc starts with usbCrc mov ptrL argPtrL mov ptrH argPtrH while the faster one starts with usbCrc movw ptrL argPtrL which does the same but is bytes smaller USBINTRVECTOR is no longer a real interrupt vector but is called from the main program so it is not necessary to pushpop SREG and all the registers it uses we need to save only the registers containing valid data savings bytes These are some of the more obvious things when looking at the disassembled code I did not test any of the suggestions because v does not run on my system issue Someone wants to deal with it Thanks bitflipser How do I generate the nice red and green underlayed code change listings 