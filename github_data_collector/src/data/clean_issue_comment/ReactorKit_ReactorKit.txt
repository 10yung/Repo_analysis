i dont known how to use catchError to set error in State Have you used Reactors to have local state tied to a view and also Reactors for shared state We have shared stores built around certain features and then local view models to derivecombine those where needed and also dispatch updates Im trying to determine if theres a clean way to do this with ReactorKit In the Drrrble sample I see a couple different things that look similar One is sending an action to a shared Reactor inside a reducer func reducestate State mutation Mutation State var state state switch mutation case let setRefreshingisRefreshing stateisRefreshing isRefreshing return state case let setShotshot stateshotSectionReactoractiononNextupdateShotshot return state case let setCommentscomments statecommentSectionItems comments mapShotViewCommentCellReactorinit mapShotViewSectionItemcomment return state This seems a little clunky no offense Then I see that you have shared state that isnt a Reactor in the UserService class and that doesnt use the actionreducer flow at all It seems like theres probably a solution where you could have a method for converting local actions to global actions and dispatching them to a global Reactor Any thoughts for ex func transformaction ObservableAction ObservableAction func transformstate ObservableState ObservableState i dont known how to use thanks I need to run this code selfcurrentState state in currentThread immediately not queueing Please check my code MainSchedulerinstance sometimes queueing such as user tying keyboard rapidly public func createStateStream ObservableState let action selfactionasObservable let transformedAction selftransformaction action let mutation transformedAction flatMap weak self action ObservableMutation in guard let self self else return empty return selfmutateaction actioncatchError in empty let transformedMutation selftransformmutation mutation let state transformedMutation scanselfinitialState weak self state mutation State in guard let self self else return state return selfreducestate state mutation mutation catchError in empty startWithselfinitialState observeOngetScheduler let transformedState selftransformstate state doonNext weak self state in selfcurrentState state replay transformedStateconnectdisposedby selfdisposeBag return transformedState private func getScheduler RxSwiftImmediateSchedulerType if ThreadisMainThread return CurrentThreadSchedulerinstance else return MainSchedulerinstance reactorstate subscribeonNext state in here is currentThread Not queueing disposedby selfdisposeBag I have a Reactor like this swift class ProductReactor Reactor enum Action case getProduct case getLocationInt enum Mutation case updateProductProduct case updateLocationLocation struct State var product Product var location Location func mutateaction Action ObservableMutation switch action case getProduct return getProductmap MutationupdateProduct case getLocationlet id return getLocationidmap MutationupdateLocation func reducestate State mutation Mutation State var state state switch mutation case updateProductlet p stateproduct p case updateLocationlet l statelocation l return state func getProduct ObservableProduct return Observableempty func getLocation id Int ObservableLocation return Observableempty Initially I trigger getProduct action from viewDidLoad to get the product Now I want that after product state changed the getLocation action will be triggered automatically inside Reactor to get location from productlocationId without subscribing to state in view So how to do that where should I put the action trigger reproducible crash on app launch img width altimage src This PR is blocked by This PR closes This PR closes First load succeeds but when I try to append the next items and bind it to rxdatasources it always crushes with the error which says Terminating app due to uncaught exception NSInternalInconsistencyException reason attempt to insert row into section but there are only rows in section after the update ViewController func bindreactor Reactor DATASOURCES selftableViewrxsetDelegateselfdisposedby selfdisposeBag selftableViewrxwillDisplayCell filter arg Bool in let indexPath arg guard argindexPathsection else return false let rows selftableViewnumberOfRowsinSection return selftableViewcellForRowat IndexPathrow indexPathrow section indexPathsection nil rows indexPathrow filter in reactorcurrentStatehasNext filter in reactorcurrentStateisLoading map in ReactorActionloadNext bindto reactoraction disposedby disposeBag let dataSource RxTableViewSectionedAnimatedDataSourceItemSectioninitanimationConfiguration AnimationConfigurationinsertAnimation fade reloadAnimation fade deleteAnimation fade configureCell weak self dataSource table indexPath item in guard let self self else return UITableViewCell if indexPathsection guard let cell selftableViewdequeueReusableCellwithIdentifier ProfileCell for indexPath as MyProfileCell else return UITableViewCell guard case let ItemUseruser item else return UITableViewCell cellreactor MyProfileCellReactorparent self user user cellselectionStyle UITableViewCellSelectionStylenone return cell else guard let cell selftableViewdequeueReusableCellwithIdentifier PostCell for indexPath as PostCell else return UITableViewCell guard case let ItemPostpost item else return UITableViewCell cellreactor PostCellReactorpost post likeService reactorlikeService commentService reactorcommentService viewService reactorviewService likeCount postlikeCount commentCount postcommentCount viewCount postviewCount isLiked reactorlikeServicecheckIsLikedpost post parent self return cell ACTION ObservableVoidjust map in ReactorActionload bindto reactoraction disposedby disposeBag STATE reactorstateasObservable map sections distinctUntilChanged bindto selftableViewrxitemsdataSource dataSource disposedby selfdisposeBag Reactor struct State var user User var posts Item var isLoading Bool var sections ItemSection guard let user user else return guard selfpostsisEmpty else return let sections ItemSection ItemSectionmodel MyProfile items ItemUseruser ItemSectionmodel MyPosts items selfposts return sectionsfilter itemsisEmpty var hasNext Bool var lastSnapshot DocumentSnapshot func reducestate State mutation Mutation State var newState state switch mutation case let setUseruser newStateuser user newStateuser user case let setPostsposts lastSnapshot lastSnapshot hasNext hasNext newStateposts postsmap ItemPost newStatelastSnapshot lastSnapshot newStatehasNext hasNext case let appendPostsposts lastSnapshot lastSnapshot hasNext hasNext newStatepostsappendcontentsOf postsmap ItemPost newStatelastSnapshot lastSnapshot newStatehasNext hasNext case let setLoadingisLoading newStateisLoading isLoading case empty printempty return newState I am so happy if you would help me Thanks in advance This example is the MVVM project architecture I use for daily development and I hope it will help beginners like RxSwift and MVVM