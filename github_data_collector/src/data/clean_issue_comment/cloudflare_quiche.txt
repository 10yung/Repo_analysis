multiconnect test requires The client is expected to establish a separate connection for each of the files requested in the REQUESTS parameter The connections may be established serially or in parallel This is exactly how we are doing right now so adding test name will be good enough Update buildrs to support recent NDK or later build instruction You can still get previous NDK style support using features ndkoldgcc buildandroidndk sh is an example script to build using NDK travis android build will try both way Update README This PR will fix and This is needed for libp p among other uses Currently we only test build with old gcc based NDK However recent NDK switched to clang so need to test and fix the necessary part not sure if we want to do this but rust adds nonexhaustive which seems to align well to making the quiche crate more extensible because it forces downstream crates to code for the possibility of new fields in structs or new enums variants Ive focused on just quiches public enums here the small pact can be seen in the rust example client and server Theres probably also some other things like the integration tests or C examples that CI will catch once its uplifted to Simple lost detection when the recovery episode ends and the duration of current recovery episode is short than a given threshold currently defined by x minrtt This means there was a small loss recovered very quickly indicating this has a low probability of congestion but a simple packet lost In this case we restore previous cwndssthresh to resume faster after recovery This gives a good performance improvement in case of high random loss not by congestion Test result shows that it can improve more than in case of random loss Note that it can be used other than Reno cubic etc too not BBR ps This PR assumes IsAppLimited can be defined by bytesinflght cwnd Lets consider the following scenario initcwnd Send pkt size bytesinflight cwnd Recv ack bytesinflight cwnd Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd Recv ack bytesinflight cwnd slow start Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd Currently isapplimited returns always false We are actually doing like this Send pkt size bytesinflight cwnd Recv ack bytesinflight cwnd slow start Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd Recv ack bytesinflight cwnd slow start Send pkt size bytesinflight cwnd Send pkt size bytesinflight cwnd It means cwnd may be bloated by acks delivered before bytesinflight reached cwnd This happens because in the beginning of QUIC connection has Initial and Handshake which exchanges data before Application starts To solve this isapplimited need to be defined However we cant define isapplimited as bytesinflight cwnd This is because in onpacketackedcc we decrease bytesinflight first so when we call selfisapplimited later it always return true because at this point bytesinflight cwnd This has an adverse impact because now isapplimited returns true all the time cwnd will not grow To prevent this now applimited is a field in Reno We update this value in onpacketsentcc only When bytesinflight is same or higher than cwnd applimited will be false Then when onpacketackedcc is called and when bytesin flight is same to cwnd or higher we use applimited updated last time when onpacketsentcc is called So when bytesinflight cwnd onpacketsentcc will decrease bytesinflight but still see applimited false so cwnd will be updated Note that same technique can be used for cubic and other similar CCs ps This PR assumes Not a part of spec but many implementations use a windowed minrtt eg Related to and fixes The idea is to have a cclog macro basically same to other logging macro but basically its not enabled without QUICHECCLOG so only we need logging from CC we can set this environment variable I used CCLOG static mut variable but it only changed in the callonce and not changed so using it under unsafe is fine or I cant find not to use unsafe in the scenario ps This PR assumes 