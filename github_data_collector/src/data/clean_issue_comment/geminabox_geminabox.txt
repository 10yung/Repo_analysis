GitHub supports GitHub Package to release private gem nowadays You may not need to host your own private rubygems server with geminabox Check it out Hello I was wondering if there is any plan to add support for GET apiv gems GEM NAME jsonyaml API I updated the GUI to Boostrap jQuery Datatables RestfulizerJs Also made some small modifications to the Sinatra app so it redirects properly using Bootstrap A great tool but one deficiency we have come across is this Maintaining an application longer term sees the OS platform migrate through consecutive versions A subset of gems require compilation To avoid the need for build env tools in application docker images such gems can be compiled once and both the uncompiled and compiled version pushed to geminabox This works outof thebox the two resulting gems are differentiated by a platform tag added by the build process The geminabox UI displays gem install nokogiri v x linux gem install nokogiri v So far so good but we need to maintain builds on different OS versions of the same platform eg SLES ltx gtSP lty gt This introduces a name clash The workaround used is to maintain separate instances of geminabox for each OS flavour with the associated maintenance overhead Can geminabox be enhanced to cater for this Maybe one optional directory level and corresponding segregation in internal the storage can be added to the url Ive not tested if this works but the idea would be to add such a dir in the source field of the apps Gemfile It seems that there is no official image for geminabox on Docker Hub I can find only various inofficial ones Having official images would probably help everyone looking for a proper geminabox installation that wont be outdated soonish Thank you for Gem in a box It would be nice if the Dockerfile would create a non privileged user instead of root For example like described here We ran into the issue that if geminabox is configured as proxy and multiple clients are connecting the service becomes completely unresponsive as geminabox downloads the index and merges it for every single request I implemented some simple caching by using the gem cachy which can use different backend based on the requirements of the deployment It can simply use moneta with a file store if geminabox is running on a single node or something like memcached if the cache should be shared among multiple nodes The implementation is pretty simple and if nothing is configured everything will behave as it currently does Im not sure if this is something you even want to include but I thought if others have the same issue there is at least a patch available or an idea how this can be solved We are running this in production for almost a year now and so far we had no issues Hi we run a geminaboxServer in our company When deleting the Gemfilelock and running bundle install verbose on our projects were getting the following error Running bundle install verbose with bundler Found changes from the lockfile reresolving dependencies because bundler is unlocking gems OURGEM ruby HTTP GET HTTP Not Found BundlerFetcherFallbackError NetHTTPNotFound CRuby librubygems gemsbundler libbundlerfetcherdownloaderrb in fetch CRuby librubygems gemsbundler libbundlerfetchercompactindexrb in call CRuby librubygems gemsbundler libbundlercompactindexclientupdaterrb in block in update CRuby libruby tmpdirrb in mktmpdir CRuby librubygems gemsbundler libbundlercompactindexclientupdaterrb in update CRuby librubygems gemsbundler libbundlercompactindexclientrb in update CRuby librubygems gemsbundler libbundlercompactindexclientrb in updateandparsechecksums CRuby librubygems gemsbundler libbundlerfetchercompactindexrb in available CRuby librubygems gemsbundler libbundlerfetchercompactindexrb in call CRuby librubygems gemsbundler libbundlerfetchercompactindexrb in block in compactindexrequest CRuby librubygems gemsbundler libbundlerfetcherrb in useapi CRuby librubygems gemsbundler libbundlersourcerubygemsrb in block in apifetchers CRuby librubygems gemsbundler libbundlersourcerubygemsrb in select The Gemfile only uses our geminaboxServer source The path to versions on our geminaboxServer does not exist so were getting this error What could we do what is wrong Im getting NameError uninitialized constant GemUtil with the latest version on rubygemsorg NameError uninitialized constant GemUtil varlibgems gemsgeminabox libgeminaboxserverrb in block in allgemswithduplicates varlibgems gemsgeminabox libgeminaboxserverrb in map varlibgems gemsgeminabox libgeminaboxserverrb in allgemswithduplicates varlibgems gemsgeminabox libgeminaboxserverrb in allgems varlibgems gemsgeminabox libgeminaboxserverrb in loadgems varlibgems gemsgeminabox libgeminaboxserverrb in block in classServer varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in block in compile varlibgems gemssinatra libsinatrabaserb in block levels in route varlibgems gemssinatra libsinatrabaserb in routeeval varlibgems gemssinatra libsinatrabaserb in block levels in route varlibgems gemssinatra libsinatrabaserb in block in processroute varlibgems gemssinatra libsinatrabaserb in catch varlibgems gemssinatra libsinatrabaserb in processroute varlibgems gemssinatra libsinatrabaserb in block in route varlibgems gemssinatra libsinatrabaserb in each varlibgems gemssinatra libsinatrabaserb in route varlibgems gemssinatra libsinatrabaserb in block in dispatch varlibgems gemssinatra libsinatrabaserb in block in invoke varlibgems gemssinatra libsinatrabaserb in catch varlibgems gemssinatra libsinatrabaserb in invoke varlibgems gemssinatra libsinatrabaserb in dispatch varlibgems gemssinatra libsinatrabaserb in block in call varlibgems gemssinatra libsinatrabaserb in block in invoke varlibgems gemssinatra libsinatrabaserb in catch varlibgems gemssinatra libsinatrabaserb in invoke varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in forward varlibgems gemssinatra libsinatrabaserb in routemissing varlibgems gemssinatra libsinatrabaserb in route varlibgems gemssinatra libsinatrabaserb in route varlibgems gemssinatra libsinatrabaserb in block in dispatch varlibgems gemssinatra libsinatrabaserb in block in invoke varlibgems gemssinatra libsinatrabaserb in catch varlibgems gemssinatra libsinatrabaserb in invoke varlibgems gemssinatra libsinatrabaserb in dispatch varlibgems gemssinatra libsinatrabaserb in block in call varlibgems gemssinatra libsinatrabaserb in block in invoke varlibgems gemssinatra libsinatrabaserb in catch varlibgems gemssinatra libsinatrabaserb in invoke varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemsrackprotection librackprotectionxssheaderrb in call varlibgems gemsrackprotection librackprotectionpathtraversalrb in call varlibgems gemsrackprotection librackprotectionjsoncsrfrb in call varlibgems gemsrackprotection librackprotectionbaserb in call varlibgems gemsrackprotection librackprotectionbaserb in call varlibgems gemsrackprotection librackprotectionframeoptionsrb in call varlibgems gemsrack libracknullloggerrb in call varlibgems gemsrack librackheadrb in call varlibgems gemssinatra libsinatrashowexceptionsrb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemsrackprotection librackprotectionxssheaderrb in call varlibgems gemsrackprotection librackprotectionpathtraversalrb in call varlibgems gemsrackprotection librackprotectionjsoncsrfrb in call varlibgems gemsrackprotection librackprotectionbaserb in call varlibgems gemsrackprotection librackprotectionbaserb in call varlibgems gemsrackprotection librackprotectionframeoptionsrb in call varlibgems gemsrack libracknullloggerrb in call varlibgems gemsrack librackheadrb in call varlibgems gemsrack librackmethodoverriderb in call varlibgems gemssinatra libsinatrashowexceptionsrb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemssinatra libsinatrabaserb in block in call varlibgems gemssinatra libsinatrabaserb in synchronize varlibgems gemssinatra libsinatrabaserb in call varlibgems gemsrack librackauthbasicrb in call varlibgems gemsrack libracktempfilereaperrb in call varlibgems gemsrack libracklintrb in call varlibgems gemsrack libracklintrb in call varlibgems gemsrack librackshowexceptionsrb in call varlibgems gemsrack librackcommonloggerrb in call varlibgems gemssinatra libsinatrabaserb in call varlibgems gemsrack librackchunkedrb in call varlibgems gemsrack librackcontentlengthrb in call varlibgems gemsrack librackhandlerwebrickrb in service usrlibruby webrickhttpserverrb in service usrlibruby webrickhttpserverrb in run usrlibruby webrickserverrb in block in startthread Im trying to start geminabox using rackup host configru My configru is straightforward as provided in the readme with the following changes Geminboxdata pointing to my actual data directory obviously RackAuthBasic I dont face this issue on version Ive been getting a HTTP Bad Request whenever Im trying to upload a gem via the gem push command while having the Basic Auth configured as per READMEWiki What Ive found out is that the the gem command will happily use HTTP basic auth for GET operations against a gem server the gem push command specifically ignores any configured basic auth and will use any configured rubygemsorg API key instead resulting RackAuthBasic throwing a instead of a which Id have expected in that case Looking at libruby rubygemscommandspushcommandrb it seems there is no way to tell the gem push command to use basic auth instead of the API Key which means in a company where lots of developers have their own gems which they maintain privately there is no way to push gems to geminabox via the gem push command without gathering the API keys of each developer I think this caveat should be prominently displayed at the start of the basic auth documentations since this interaction and behavior of gems isnt really intuitive or expected