When using stream compression in combination with SSE event streams you need to flush every time you sent an event to ensure data still in the compression buffer is effectively sent The compression middlewares Flush doesnt flush compressed data because the underlying writer eg gzipWriters Flush doesnt have the httpFlusher signature because it has an error return argument This patch flushes the underlying stream if it implements gzips flush signature After flushing the GZip stream the underlying response writer will have pending data as well and so needs to be flushed too Add go mod and sum files This makes the list of dependencies clearer even if none exists outside stdlib in this case It also prevents the ugly incompatible suffix that is added in downstream projects dependent on this Include Allow Header for MethodNotAllowed responses Context RFC Include tests for default methodNotAllowed handler improve performance in the node routes checking existence on a map instead of doing a loop calling methodTypString adds tests for AllowContentType middleware use map for better lookup performance Go is out GOPATH is gone Most of the packages have go module support Whats holding Chi back How can I help Im trying to learn Chi coming from PythonFlask background I assume that this is a proper way to get Url parameters id chiURLParamr id approutepostintpostid def showpostpostid show the post with the given id the id is an integer return Post d postid Im not sure what sync should do Is there a shorthand for yielding status code errors wWriteHeaderhttpStatusNotFound wWrite byte HTTP status code returned Shorthand in flask for comparison from flask import abort abort url The Go documentation states the following on httpRequestRemoteAddr The HTTP server in this package sets RemoteAddr to an IPport address before invoking a handler Therefore you could expect that a code like this is correct go package main import fmt net nethttp githubcomgochichi githubcomgochichimiddleware func main r chiNewMux rUsemiddlewareRealIP rGettest funcrw httpResponseWriter r httpRequest host port err netSplitHostPortrRemoteAddr if err nil fmtFprintfrw Error v n err else fmtFprintfrw Host s nPort s n host port httpListenAndServe r However the RealIP middleware is just copying the XForwardedFor value into rRemoteAddr which usually does not contain a port making the code fail dirbaiomars curl localhost test Host Port dirbaiomars curl localhost test H XForwardedFor Error address missing port in address dirbaiomars curl localhost test H XForwardedFor Error address too many colons in address Perhaps RealIP should try to parse XForwardedFor for a hostport and if it isnt add a port Maybe to denote the port is unknown like This is particularly frustrating with IPv addresses because they have colons but theyre not the hostport colon making it hard to parse the RemoteAddr in user code Ive been scratching my head for the past day where the chi wouldnt route the request properly Here are the registered routes go rRouteaccountsidme azAZ funcr chiRouter works rRouteaccountsidme azAZ newlink funcr chiRouter works rRouteaccountsidme Backwardcompatlink funcr chiRouter no request wont be routed here debugger shows that this route has been added under accountsidme azAZ Fixes go r NewRouter A handler that does not use middleware rPostparent postHandler rGroupfuncr Router rUsemw rRouteparent funcr Router rGet getHandler other routes at or under parent that use the middleware Requests to GET parent hit the middleware and handler as expected Requests to POST parent hit the middleware and not the handler Method Not Allowed is returned Neither of those things are expected Simplifying to this produces the same result GET handler works POST handler does not go r NewRouter rPostparent postHandler rRouteparent funcr Router rGet getHandler Here is a test demonstrating the issue go func TestRouteAndStandalonet testingT handlerCalled false handler funcw httpResponseWriter r httpRequest tLogfCalled s handler rMethod handlerCalled true r NewRouter rPostparent handler rRouteparent funcr Router rGet handler ts httptestNewServerr defer tsClose resp testRequestt ts httpMethodPost parent nil if respStatusCode httpStatusOK tErrorfFailed to reach POST handler s respStatus if handlerCalled tErrorExpected to reach POST handler but did not handlerCalled false resp testRequestt ts httpMethodGet parent nil if respStatusCode httpStatusOK tErrorfFailed to reach GET handler s respStatus if handlerCalled tErrorExpected to reach GET handler but did not The output is text go test v run TestRouteAndStandalone RUN TestRouteAndStandalone FAIL TestRouteAndStandalone s muxtestgo Failed to reach POST handler Method Not Allowed muxtestgo Expected to reach POST handler but did not FAIL exit status FAIL githubcomgochichi s This is true of v and master c e ab