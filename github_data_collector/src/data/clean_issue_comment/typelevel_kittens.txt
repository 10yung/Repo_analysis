As discussed here this allows things like error accumulation when validating with Either This could be done without changing Sequence just as syntax via the approach in the Stack Overflow answer but that involves a lot of extra overhead of the syntactic runtime and compiletime variety I would have added a record version and parTraverse but both RecordSequence and Traverse dont preserve the F context which makes it a little more complicated I can understand the reasoning for Traverse not having an F but not RecordSequence which seems like it should match Sequences type members semiauto doesnt use Lazy That improves compile time performance marginally and has better error messages on Scala Moved semiauto test instances to companion objects to ensure serializability This would have to go into a release I have a problem with Show instance derivation of GADT defined in companion object Here is the example scala but I think I see the same issue on scala kittens scala object example import catsShow import catsderivedsemi import catsimplicits sealed trait Response object Response final case class OKmessage String extends Response final case class Failuremessage String error Error Int extends Response sealed trait Error T object Error final case class Recoverablecause Int extends Error Int case object Unexpected extends Error Unit implicit val show Show Response semishow ends up with compilation error Error diverging implicit expansion for type catsderivedutilVersionSpecificLazy catsderivedMkShow A starting with method catsKernelStdHashForSortedMap in trait SortedMapInstances semishow The workaround is pretty simple I have to move Error definition outside of Response companion object scala object example import catsShow import catsderivedsemi import catsimplicits sealed trait Response object Response final case class OKmessage String extends Response final case class Failuremessage String error Error Int extends Response sealed trait Error T object Error final case class Recoverablecause Int extends Error Int case object Unexpected extends Error Unit implicit val show Show Response semishow Now it compiles Also there is no issue when Error is not GADT or have no generic type But still looks like a bug Im not pretty sure if this applies to kittens or shapeless but I think you have now enough info to figure it out Cheers Great lib guys When updating version numbers for scalazandcats I noticed a fairly stark performance regression for kittensderived Eq between RC and RC For a simple caseclass scala case class Fooage Int msg String truthy Boolean Previously the deriving syntax was scala implicit val fooEq Eq Foo deriveeq Foo And now it is scala implicit val fooEq Eq Foo import derivedautoeq derivedsemieq For two length List Foo who have the same contents but are not the same object to compare every element dropped from ns to ns Either number is an order of magnitude slower than a handwritten instance vanilla Scalas or a ScalaZ autoderived instance Kittens allows us to work with raw HLists and Coproducts scala import catsinstancesall import catsderivedMkMonoid import catssyntaxmonoid a HNil b HNil ok However we cant work with raw Records and Unions scala k HNil k HNil no Monoid instance The same goes for other type classes as well It mostly boils down to defining an instance for FieldType K V Are there any objections to adding them