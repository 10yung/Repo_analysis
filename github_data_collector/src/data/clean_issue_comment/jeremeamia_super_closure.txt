php environment php PHP User Notice yii base ErrorException with message Serialization of closure failed The closure was not found within the abstract syntax tree echo x superclosure dont suport syntax change opcacheenablecli to opcacheenablecli It would be nice to have it at final release php serializer new SuperClosure Serializer b test fna a c serializerserializetest Expected serialized closure Actual result ClosureAnalysisException The closure was not found within the abstract syntax tree Hi first of all thank you for bringing us SuperClosure It inspired me to write a userland implementation of varexport that can export closures as well Just like SuperClosure its based on nikics PHPParser library and works pretty well with a few caveats Would you be willing to add a link to it in the Alternatives section of the README Cheers Ben Package nikicphpparser minimal version is otherwise tests failed when a closure like this php php hello function name world echo name it will be unserialize failed The above says it cant throw but my small test shows its possible Am I missing something Nested closures not working First works but the nestes does not Inspired on your work I created my own serializable closure take a look here Bellow a test code to understand the issue usrbinphp php CHANGE PATH TO AUTOLOAD requireoncehomesalomondevphpreposvendorautoloadphp errorreportingEALL use SuperClosure Serializer use SuperClosure SerializableClosure class MyTestClass private onTest null public function construct FIRST CLOSURE WORKS thisonTestfunction echo first test n HERE IS THE PROBLEM NESTED CLOSURE NOT WORKS thisonTestfunction echo second test n public function onTestcallable callback echo adding closure n thisonTest new SerializableClosurecallback new Serializer printrcallback public function test calluserfuncarraythisonTest t new MyTestClass s serializet t unserializes die t test ttest I hope my little contribution be helpful for you I recently started using your Super Closure PHP module in our Yii framework when implementing a worker queue I got a problem there when I used self in the closures I want to serialize In the moment the unserialized closure is called I get a fatal PHP error PHP Fatal error Call to undefined method SuperClosure SerializableClosuresendNotifications in commonvendorjeremeamiaSuperClosuresrcSerializableClosurephp evald code on line Let me provide some information the closure passed looks like php functionusers use pushnotificationitemiditemtypelinktypesilentappnotificationid selfsendNotificationsusers pushnotification itemid itemtype linktype silent appnotificationid This is how I unserialize and run the closure php thisbody new SuperClosure Serializerunserializethisbody payload thisexitCode calluserfuncarraythisbody isarraythisparams thisparams array The serialized string contains the following C SuperClosure SerializableClosure a s codes function users usepushnotification itemid itemtype linktype silent appnotificationid selfsendNotificationsusers pushnotification itemid itemtype linktype silent appnotificationid s contexta s pushnotificationO PushNotification s pagesearchNs CActiveRecordnewb s CActiveRecordattributesa s statusi s iscategorytexti s weeki s texts guest followed yous dates s appnotifications s ids s CActiveRecordrelateda s CActiveRecordcNs CActiveRecordpks s CActiveRecordaliass ts CModelerrorsa s CModelvalidatorsNs CModelscenarios updates CComponenteNs CComponentmNs itemids s itemtypes users linktypes userprofiles silentb s appnotificationids s bindingNs scopes PushNotificationServices isStaticb Im using the AstAnalyzer but as I understood the documentation it should actually work with both analyzers Im running on PHP reported in my email to jeremeamia on copy here for tracking reasons Take a look at Opis Closure Uses stream wrapper to load code instead of eval allows for multiple unserializations Compare Token Parser logic See if we can determine if a closure is static with code parsing instead of with this awful function Next major version See if we can get the token parsers feature uptopar Make PHPParser an optional dependency Perhaps join projects with Opis Closure 