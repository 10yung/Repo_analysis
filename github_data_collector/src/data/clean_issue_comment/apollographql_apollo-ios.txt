Hi Im trying to generate code with the following mutation mutation MagicLinkEmailemail String magicLinkEmailemail email The graphql scheme is defined as magicLinkEmailemail String Boolean The generator is giving errors when it tries to generate files when returning scalar values Im doing something wrong It works o GraphiQL Workspace HI I am looking for an ios client and i have seen that there is only Apollo I read the documentation and tried your frontpage example I have a question To keep having persistent objects offline I have to use sqlitecache All is well ok But if now I have to make changes offline the problem is that the mutation logic is on the server the only thing that would be interesting is to have a queue of operations to send when connected again The concept is offline sync Infact on AWS AppSync service we have a AppSyncClient that processes both offline and online mutations and mutations are queued for processing even while the client is offline so this count represents a good measure of the number of mutations that have yet to be successfully sent to the service regardless of the state of the network Have you think about it Have you know a simple way to implement it Changes add a column modifiedAt in the cache change the ApolloClient protocol to return context alongside the result So far the context GraphQLResultContext only contains the age of the returned result but could be later extended extend ApolloClient to support existing usage where the handler doesnt care about this context Motivation Reading from cache is a great way to reduce the number of network requests emitted and cloud hosting costs However developers usually want to make sure that the cache result is not too old and without this information they are likely to fetch a fresh result just in case This change makes it possible to know how old the returned result is swift apolloClientfetchWithContext query query cachePolicy returnCacheDataDontFetch context nil queue main result in switch result case successlet data context if contextresultAge DatemilisecondsSince use fresh enough data else fetch default fetch Tests I added test for the database migration and for the context returned when reading from cache Comments I had to change a lot of files to keep track of the timestamps when passing around the object been built through the GraphQLExecutor Installation docs point to broken formatter link please use the GraphQL Formatter tool Hello there Ive modified the build script to make use of two schemas one public and the other private It works fine Im facing a little problem though In both schemas Im using the ProductFragment for example When I put in public GraphQL folder only I get an error saying that the my fragment is not recognized in private makes sense but when a copy of the fragment on the private GraphQL folder it says that the redeclaration is invalid make sense too Is there a way to share a fragment in both APIs of mine The only thing that works is to make another fragment but different name but this way I lost the benefit of the fragment Thanks a lot SCRIPTPATHPODSROOTApolloscripts cd SRCROOTTARGETNAMEAPIPublicAPI SCRIPTPATHcheckandrunapolloclish codegengenerate targetswift includesGraphQLgraphql localSchemaFileschemaPublicjson PublicAPIswift cd SRCROOTTARGETNAMEAPIPrivateAPI SCRIPTPATHcheckandrunapolloclish codegengenerate targetswift includesGraphQLgraphql localSchemaFileschemaPrivatejson PrivateAPIswift As the notes mentioned in the documentation site uploading files section has one point Due to some limitations around the spec whatever the file is being added for should be at the root of your GraphQL query So if you have something like mutation AvatarUploaduserID GraphQLID file Upload id it will work But if we wrap it in a object like this mutation AvatarUploadavatarObject AvatarObject id Assump AvatarObject has userID GraphQLID and file Upload It wont I also noticed that this one was resolved on the Android side So Im really want to know why we couldnt do that on iOS What are the limitations here Thank you we are using fragments on our query like this products TestModel fragment TestModel on OurModelOnServer id name description price outofstock TestModel is an array of items and it returns array of nil items like this nilnilnil But when i take the keys outside the fragment like the following products id name description price outofstock then it works Knowing that we are using fragments on many queries and it is working except on a new query that is created recently PS the new query is built on a new structuremy colleague habib will reply what is changed in the below comments This is the mutation Im generating mutation ReportDriverTaskRelativeETA taskId ID reportDriverTaskRelativeETAinput taskId taskId on NoData typename description Codegen seems to be renaming the ETA part in the mutation name to ETum for no apparent reason public struct ReportDriverTaskRelativeETum GraphQLSelectionSet public static let possibleTypes NoData public static let selections GraphQLSelection GraphQLFieldtypename type nonNullscalarStringself GraphQLFielddescription type nonNullscalarStringself That glitch alone would be fine ie usable but then the get accessor for the struct var renames the ETum part of the name yet again to Etum public var reportDriverTaskRelativeEta ReportDriverTaskRelativeETum get return ReportDriverTaskRelativeEtumunsafeResultMap resultMap reportDriverTaskRelativeETA as ResultMap set resultMapupdateValuenewValueresultMap forKey reportDriverTaskRelativeETA This renaming mismatch causes a build error Screenshot at This only happens to this particular mutation and if I rename it to something else say ReportDriverTaskRelativeEstimatedTimeOfArrival its generated properly and works normally Anyone ever ran into something like this Any ideas why this would happen As requested in pointed up something we havent changed since conditional conformance landed we really need to be taking better advantage of it especially comparing things that implement Equatable 