I want to use GraphQLBatch to load arguments for running mutations and its not clear to me from reading the documentation if it is safe for me to use GraphQLBatchbatch wherever I feel the need in my application The note in the documentation refers only to using this in unit tests Can you provide clarification on whether GraphQLBatchbatch can be safely used outside the test environment Hi My graphqlruby version is and I use the association loader in the example directory I have these models Route RoutesStop and Stop Route has this association hasmany stops order routestopsorder through routestops When I use association loader to load stops field in my RouteType I got this kind of issue ActiveRecordStatementInvalid PGUndefinedTable ERROR missing FROMclause entry for table routestops and the sql it actually execute is SELECT stops FROM stops WHERE stopsid IN ORDER BY routestopsorder How can I unscope the order scope of ActiveRecordRelation to avoid the exception OR what can I do to deal with the exception under the premise of not removing the scope in the hasmany relationship definition Thanks Can you explain this to me a little bit more We want to load the associations on all records even if they have the same id def cachekeyrecord recordobjectid end Which situation are we talking about here I dont know if this is a bug or just a dumb question but let me explain it Starting with this simple type class TypesProjectType TypesBaseNode graphqlname Project field title String null false field milestones TypesMilestoneTypeconnectiontype null false def milestones objectmilestones end end And running this query query projectsperPage edges node title milestones edges node title Returns the desired result but leads to this Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid So I thought it would be good to use the AssociationLoader to eager load the milestones using this def milestones LoadersAssociationLoaderforProject milestonesloadobject end But this ends up in this Milestone Load ms SELECT milestones FROM milestones WHERE milestonesprojectid IN projectid projectid projectid projectid projectid projectid projectid projectid projectid projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Milestone Load ms SELECT milestones milestonesid AS cursor FROM milestones WHERE milestonesprojectid ORDER BY milestonesid asc projectid Completed OK in ms Views ms ActiveRecord ms user petergoebel POST graphql AVOID eager loading detected Project milestones Remove from your finder includes milestones Call stack Why are all milestones still queried individually even with eager loadingpreloading Hi everyone First i would like to thank you for your awesome job on the OSS community Ive probably a bug using graphqlbatch Ive duplicate reads of replacements associated records when i use the AssociationLoader class only after a succeed mutation not when i use a query If i disable the batch it works well Any idea of whats going bad data createMandate errors mandate replacements id flexibleTime false endsAt T Z priority false id flexibleTime false endsAt T Z priority false id flexibleTime false endsAt T Z priority false id flexibleTime false endsAt T Z priority false id flexibleTime false endsAt T Z priority false success true ruby appmodelsmandaterb class Mandate ApplicationRecord hasmany replacements classname Replacement autosave true dependent destroy hasmany proposals through replacements classname Proposal acceptsnestedattributesfor replacements allowdestroy true end ruby appgraphqltypesmandaterb class TypesMandate TypesBaseObject field replacements TypesReplacement Mandates replacements null false def replacements AssociationLoaderforMandate replacementsloadobject end end ruby appgraphqlassociationloaderrb class AssociationLoader GraphQLBatchLoader def selfvalidatemodel associationname newmodel associationname nil end def initializemodel associationname model model associationname associationname validate end def loadrecord raise TypeError model loader cant load association for recordclass unless recordisamodel return Promiseresolvereadassociationrecord if associationloadedrecord super end We want to load the associations on all records even if they have the same id def cachekeyrecord recordobjectid end def performrecords preloadassociationrecords recordseach record fulfillrecord readassociationrecord end private def validate unless modelreflectonassociationassociationname raise ArgumentError No association associationname on model end end def preloadassociationrecords ActiveRecordAssociationsPreloadernewpreloadrecords associationname end def readassociationrecord recordpublicsendassociationname end def associationloadedrecord recordassociationassociationnameloaded end end cc Shopifycomponentpatterns Problem We have tended to avoid using promises throughout out codebase and have instead relied on preloading associations However as we split our codebase into components that arent coupled to each other models we are needing to stop relying on these associations for this purpose Instead I would like a simple primitive that avoids the N problem without having to think about promises so that we can easily use a nonpromise based component APIs Solution Add the concept of a batch loaded field which can be specified next to the field declaration like a typical resolver method However instead of an instance method for the batch resolve method a class method is used which is given an array of objects to load the field on For example ruby class Product GraphQLSchemaObject field inventoryquantity Int null false do extension GraphQLBatchLoadedFieldExtension end def selfinventoryquantityinstances productids instancesmap instance instanceobjectid quantities ProductVariantgroupproductidwhereproductid productidssuminventoryquantity instanceseach do instance instanceinventoryquantity quantitiesfetchinstanceobjectid end end The result is just assigned to an attribute writer on the GraphQLSchemaObject instance which fulfills the promise Since this relies on there being a graphql object to assign the result to this feature depends on the graphql gems classbased API In addition to not having to think about promises this feature also simplifies grouping It will automatically group by the graphql object class field and arguments If either the lookahead or irepnode extras are used it will group by their astnodes since that means it depends on the selections on the field The resolvetype seems to get the promise rather than the solved value Target GraphQLUnionTypedefine do name MyTarget possibletypes XType YType resolvetype obj ctx do bindingpry objclass GraphQLBatchPromise case o when X then XType when Y then YType end end end Type GraphQLObjectTypedefine do name MyType field id GraphQLCommonObjectId field targets types Target do resolve obj args ctx do case objtargettype when X then objtargetsmap t RecordLoaderforXloadt when Y then objtargetsmap t RecordLoaderforYloadt end end end This library is fantastic and thanks for publishing it In my testing IDs are not always aggregated across multiple queries when Schemamultiplex is used The promises do resolve correctly but one DB query is made per multiplexed gql query I found a test in this repo which runs queries with multiplex and uses QueryNotifiersubscriber to assert that only query is made but my loader does not behave Current gem versions ruby gem graphql gem graphqlbatch The loader in question is very simple ruby module Loaders class Single GraphQLBatchLoader attrreader model options key def initializemodelarg optionsarg model modelarg options optionsarg key optionsfetchkey id end def performids modelwherekey idsalleach methodfulfillrecord idsreject methodfulfilledeach methodfulfillnil end private def fulfillrecordrecord fulfillrecordsendkey record end def fulfillnilid fulfillid nil end end end In the README a CountLoader example is named but its not particularly detailed ruby CountLoaderforShop smartcollectionsloadcontextshopid CountLoaderforShop customcollectionsloadcontextshopid A clear example that demonstrates You can also batch other stuff not only load records from a DB could be very helpful for new users A great example would be something that does a HTTP request to some external API combining two nonrecordfromdbloading use cases Hey everyone i am searching for a possibility use the Loader for other columns then the keycolumn to work with the following case I have some ContactModes and every ContactMode is either an Email or a Telephone number the problem with the Loader is that the foreignkey is in the other table so I have to load emailcontactmodeid selfid instead of emailid contactmodeemailid In TypesContactModeType field email do type types TypesEmailType resolve contactmode args ctx Emailwherecontactmodeid contactmodeid end field address do type types TypesAddressType resolve contactmode args ctx Addresswherecontactmodeid contactmodeid end Is there any possibility to call the loader use Tablecolumn instead of Tableid for Loading Thanks for answer