The current nix implementation of readlink which is a rather nice improvement over the previous version is rust fn wrapreadlinkresultv mut Vecu res ssizet ResultOsString match Errnoresultres Errerr Errerr Oklen unsafe vsetlenlen as usize OkOsStringfromvecvtovec pub fn readlinkP Sized NixPathpath P ResultOsString let mut v VecwithcapacitylibcPATHMAX as usize let res pathwithnixpathcstr unsafe libcreadlinkcstrasptr vasmutptr as mut cchar vcapacity as sizet wrapreadlinkresult mut v res The Linux man page for readlink has this to say Using a statically sized buffer might not provide enough room for the symbolic link contents The required size for the buffer can be obtained from the statstsize value returned by a call to lstat on the link Dynamically allocating the buffer for readlink and readlinkat also addresses a common portability problem when using PATHMAX for the buffer size as this constant is not guaranteed to be defined per POSIX if the system does not have such limit Per the above the fixedsize buffer should be replaced by one of the following approaches Use lstat to read the size of the link allocate a buffer that large plus one readlink If the return value isnt exactly vcapacity start over An approach like this is recommended in the Linux manpage but supposedly some filesystems stat implementations report a size of zero bytes for all symlinks so Starting with a reasonable minimum size PATHMAXmax or something and increasing each time repeatedly readlink until the returned size is strictly less than the buffer size maybe fall back to this if lstat returns zero size Also we should probably guard against readlink returning a size larger than the buffer I dont know of any actual UNIXoid that does this but this is Rust after all I would take a crack at this myself but Im still recovering from some nastiness Just composing this issue took me six hours drifting in and out of dizzy semiconsciousness Not the best state to write important code in One more solution The code is adapted from the shadow crate which is MIT licensed So Ive just added them Cant find any analogues to these macros SISREG SISDIR SISCHR SISBLK SISFIFO SISLNK SISSOCK I noticed that the filesystem checks API setfsuid and setfsgid where missing while available in libc This PR adds the implementation for both of them This pull request adds support for setting the IPRECVERR sockopt and then decoding the resulting messages from recvmsg My intent is to use this to implement a traceroute program And so need ICMP TTL exceeded messages though IPRECVERR is useful in general when writing UDP network programs It is unfortunately a linuxspecific API Theres no tests here but Ive been trying it out with this bit of code SockExtendedErr is the struct type returned as a Cmsg from recvmsg It like the C linuxerrqueueh which defines it uses u and u I think well want something more userfriendly here so Id say this PR is still a workinprogress I am new to the nix codebase and am not very experienced with Rust so would appreciate early feedback Id like to have some conversion sugar to get an nixerrnoErrno from a stdioError That is going in the opposite direction of Strawman would be rust Convert into an Errno pub trait AsErrno Try to convert into an Errno If the conversion is not semantically meaningful None is returned fn aserrno self OptionErrno impl AsErrno for stdioError fn aserrno self OptionErrno selfrawoserrormapErrnofromi The use case is to improve ergonomics when pattern matching on stdlib results like this rust use nixerrnoAsErrno Errno match stdioxyz Errref err if erraserrno SomeErrnoEPERM foo bar Would something like this be welcome in nixerrno I am using the wait module to check after the child processes after receiving a SIGCHLD signal Naturally I want to collect all available events at once as SIGCHLD might be sent only once for multiple child process events I am using an iterator for that which might be useful for other users It would be nice to see this integrated into the modules API this would be a cool addition to the API pub fn eventiter stditerFromFnfn OptionResulti i nixError let eventiter stditerfromfngetnextexitedchild I use this function to make my iterator fn getnextexitedchild OptionResulti i nixError match nixsyswaitwaitpid SomenixsyswaitWNOHANG Okexitstatus match exitstatus nixsyswaitWaitStatusExitedpid code SomeOkpid code nixsyswaitWaitStatusSignaledpid signal dumpedcore signals get handed to the parent if the child got killed by it but didnt handle the signal itself if signal libcSIGTERM if dumpedcore SomeOkpid signal as i else SomeOkpid signal as i else None nixsyswaitWaitStatusStillAlive traceNo more state changes to poll None traceChild signaled with code exitstatus None Erre if let nixErrorSysnixerrnoECHILD e else traceError while waiting edescriptiontoowned SomeErre 