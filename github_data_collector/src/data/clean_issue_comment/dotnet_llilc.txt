Hi wave It looks like the builds of the coredistools native library shipped in the MicrosoftNETCoreCoreDisTools package for nonWindows platforms are a little old and arent supported by tools like R RDumpdll for getting disassembly out of DLLs in the Ready To Run format I just tried building libcordistoolsdylib myself on OSX using master and everything appears to work ok I can use it with R RDumpdll to get disassembly Is there anything blocking updating this package Right now CorDisTools can not be used to disassemble JIT output during SuperPMI with ARM JIT due to the fact that on ARM the code block is appended with literal pool What happens is that the disassembler goes beyond JIT code and tries to decode data in literal pool where it obviously fails I couldnt find any information collected during JITEE interactions that can help to determine the size of JIT code region It seems that we are loosing such information during allocMem call by explicitly passing in roDataSize What I am doing here is trying to reconstruct boundary between JIT code and constant pool during instruction decoding by looking at LDR instructions that have PCRel immediate as a second operand and computing the corresponding label addresses using current value of PC The minimum address is then assumed to be the beginning of a literal pool I did experimentation with running SuperPMI with ARM JIT with CorDisTools with these changes and it seems that this approach works on the all framework libraries in CoreRoot dotnetjitcontrib Does anyone think about a better way to figure out the literal pool size briansull BruceForstall Hey guys Im trying to find a manual or guide to tell me how I can use LLILC to generate an LLVM IR file from a MSIL file Is there a way to do this Im not even sure how to use LLILC in general but I really only need LLILC to perform this function and Ive not found anything on this yet Thanks Hey guys I m following the getting started on Windows and I m trying to run the command cmake G Visual Studio Win llvm DWITHCORECLRcoreclr path bin Product platformarchbuild DLLVMOPTIMIZEDTABLEGENON I m getting an the error that says system is unable to find the file specified I then tried to run this a folder up but then I get a access is denied I ve tried to redo the whole process in different locations and run the administrator command prompt I ve even tried temporarily disabling the firewall Has anyone else had issues with getting this to work Were there any small tweaks you had to make Any suggestions would be super helpful Thanks In readercpp function ReaderBaseclassHasGCPointers bool ReaderBaseclassHasGCPointersCORINFOCLASSHANDLE Class GCLayout Layout getClassGCLayoutClass freeLayout return Layout nullptr Inspecting the value of a pointer that has been rendered invalid in this case by freeing is undefined behavior The function should be rewritten as bool ReaderBaseclassHasGCPointersCORINFOCLASSHANDLE Class GCLayout Layout getClassGCLayoutClass bool RetVal Layout nullptr freeLayout return RetVal It looks like this project is dead no commits since June It might be worth updating the READMEmd with this fact and possibly rationale As you know Roslyn currently translates C into MSIL whilst LLILC is currently focused on compiling MSIL into LLVM bitcode WebAssembly looks interesting but clearly needs lots of work before gaining a firm foothold One key step is obviously getting all popular browsers to interpretJIT wasm s binary ASTs and capitalize on the extra optimizations made possible by emitting the asmjs subset of JS Until then Polyfill will decompile to asmjs Yes wasm is being worked on by some big names Google Microsoft Mozilla Apple We agree it deserves attention from all components of the toolchain So LLILC will follow the progress of wasm and consider supporting in due course as a clearer picture emerges The clear picture emerged What is your progress on this Thanks see Upcasting Pointers uint t GenIRsizeCorInfoType CorType switch CorType case CorInfoTypeCORINFOTYPEBOOL case CorInfoTypeCORINFOTYPECHAR case CorInfoTypeCORINFOTYPEBYTE return case CorInfoTypeCORINFOTYPEUBYTE case CorInfoTypeCORINFOTYPESHORT case CorInfoTypeCORINFOTYPEUSHORT return Shouldnt UBYTE be and CHAR be 