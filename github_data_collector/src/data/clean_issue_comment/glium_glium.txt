When running the tutorial code currently posted I noticed that the colors arent interpolating smoothly between the vertices as expected EDIT I made some observations check the bottom of the post To recall heres the expected output expected output heres the actual output triangle Colors So far I have attempted to add smooth attributes in the shaders and change the Enum values of smoothness in the DrawParameters EDIT When hardcoding the color values myself by providing a color field in the vertex buffer format I noticed some unexpected behaviours when setting some of the rgba values to negative and some to For example see what happens when you provide these colors for vertices Smooth interpolation Border I believe negative values for colors should be clamped to but it seems like this isnt the case when you interpolate between two nonblack colors I have tested this both on Windows and Linux Could you please let me know what could be the cause of this WIP as I need to figure out a solution to the examplessupportmodrs build failure see The examples are currently returning from the function if an event was received theres no handler for This results in the renderer braking as long as you move your mouse I have a test that draws million quads It works reasonably well on my macbook pro Claims to get fps However as soon as resize the window it drops to fps Im using the latest released versions Heres my code heavily based on the trianglers example macrouse extern crate glium mod support allowunusedimports use gliumglutin Surface use gliumindexPrimitiveType NoIndices use stdtimeInstant use randRng deriveCopy Clone struct Vertex position f color f implementvertexVertex position color fn main let eventloop glutineventloopEventLoopnew let wb glutinwindowWindowBuildernewwithinnersizeglutindpiLogicalSize width height let cb glutinContextBuildernew let display gliumDisplaynewwb cb eventloopunwrap let mut rng randthreadrng Generate the array of squares let mut squares Vecwithcapacity for in let pos f rnggenrange rnggenrange let col f rnggenrange rnggenrange rnggenrange squarespushVertex position pos color col squarespushVertex position pos pos color col building the vertex buffer which contains all the vertices that we will draw let vertexbuffer gliumVertexBuffernew display squaresunwrap compiling shaders and linking them together let program program display vertex version uniform mat matrix in vec position in vec color out vec vColor void main glPosition vec position matrix vColor color geometry version uniform mat matrix layoutlines in layouttrianglestrip maxvertices out in vec vColor out vec color void main vec c glin glPosition vec c glin glPosition Swap x coordinates float tmp c x c x c x c x tmp glPosition matrix c color vColor EmitVertex glPosition matrix glin glPosition color vColor EmitVertex glPosition matrix glin glPosition color vColor EmitVertex glPosition matrix c color vColor EmitVertex EndPrimitive fragment version in vec color out vec fColor void main fColor vec color unwrap let mut x f let mut i let mut lastframetime Instantnow supportstartloopeventloop move events building the uniforms let uniforms uniform matrix x f x drawing a frame let mut target displaydraw targetclearcolor targetdraw vertexbuffer NoIndicesPrimitiveTypeLinesList program uniforms Defaultdefaultunwrap targetfinishunwrap i if i i let duration lastframetimeelapsed lastframetime Instantnow printlnFPS durationassecsf let mut action supportActionContinue polling and handling the events received by the window for event in events match event glutineventEventWindowEvent event match event glutineventWindowEventCloseRequested action supportActionStop action Maybe Im missing something but it seems like enabling double buffering also causes vsync to be enabled As in my frame time going from ms to eg ms solely by enabling double buffering even if vsync is forced to being off I would have expected additional input lag caused by having to wait for one more frame but not a drop of the frame rate to my screens refresh rate Is this a bug or do I have to tune my configuration rust let context glutinContextBuildernew withdepthbuffer withmultisampling withvsyncfalse withdoublebufferSomeRENDERINGDOUBLEBUFFER withhardwareaccelerationSometrue withglglutinGlRequestSpecificglutinApiOpenGl where RENDERINGDOUBLEBUFFER false results in ms frame time RENDERINGDOUBLEBUFFER true results in ms frame time using glium Using glium version and the following code Rust extern crate glium use gliumglutin use gliumSurface fn main let mut eventsloop glutinEventsLoopnew let windowbuilder glutinWindowBuildernew withdimensions into withtitleFragula let contextbuilder glutinContextBuildernew let display gliumDisplaynewwindowbuilder contextbuilder eventsloopunwrap let mut closed false while closed let mut target displaydraw targetclearcolor targetfinishunwrap eventslooppolleventsevent match event glutinEventWindowEvent event match event glutinWindowEventCloseRequested closed true I receive the following window with the wrong RGB color glium Using C and libepoxy with similar code I receive the correct color as shown below opengl Here is the output of glxinfo if it helps name of display display screen direct rendering Yes Extended renderer info GLXMESAqueryrenderer Vendor Intel Open Source Technology Center x Device Mesa DRI IntelR HD Graphics Broadwell GT x Version Accelerated yes Video memory MB Unified memory yes Preferred profile core x Max core profile version Max compat profile version Max GLES profile version Max GLES profile version OpenGL vendor string Intel Open Source Technology Center OpenGL renderer string Mesa DRI IntelR HD Graphics Broadwell GT OpenGL core profile version string Core Profile Mesa OpenGL core profile shading language version string OpenGL core profile context flags none OpenGL core profile profile mask core profile OpenGL version string Mesa OpenGL shading language version string OpenGL context flags none OpenGL ES profile version string OpenGL ES Mesa OpenGL ES profile shading language version string OpenGL ES GLSL ES Is there any reason because Vertex trait cannot be implemented using a procedural macro Resulting code would be more idiomatic Preview rust deriveCopy Clone Vertex struct Vertex position f texcoords f The gpgpu example does show a minimum use case of compute shader however it does not explain how to share data between other shader stage Im implementing an example of compute shader In this case I need a buffer which can be written by compute shader program as well as read by vertex buffer in ordinary pipeline If I want this buffer to be written by compute shader stage as explained in gpgpu example I have to declare it as UniformBufferDataType If I want this buffer to be read by vertex buffer I have to declare it as VertexBufferVertexType I cant figure out how to share the buffer content between them This should be a common case of using compute shader Glium seems to be exhibiting some strange flushingwaitingrelated behavior if draw is called more than once Glium ends up busywaiting on Vsync rather than allowing the drivers and application to sleep wait until the next frame This results in high CPU usage even if very few objects are drawn onscreen How to reproduce Run keeshond example doggymark and spawn more than doggos Notice that the average ms for draw jumps considerably It should instead climb very gradually as more and more doggos are spawned I did not have this issue on the previous OpenGL library I used gfx prell In I missed that the PR actually broke the code Only later in the problem was pointed out to me in manual review Right now travis CI is allowing test failures as some of our tests failed and still fail on it We should identify those failing tests set ignore on them and block travis CI on the tests Im not sure how to ignore the tests that fail due to so I guess this issue is blocked on resolving that issue first