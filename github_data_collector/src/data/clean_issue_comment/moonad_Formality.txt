I have recently deployed the current Formbase code currently hosted on moonadorg to our Kubernetes cluster This pull request just change the URL to the new hosted one using HTTPS which enables usage on frontends behind HTTPS I was trying to write affine functions where I can copy elements of any type I ended up making a CopiableType Type T CopiableTypeT copiableType copy T PairTT firstProj x T x pairfst copyx secondProj x T x pairsnd copyx Using this I can write functions that use x two times It would be something like this fooX c CopiableTypeX x X PairXX case c copiableType ccopyx If I wanted to use it more times foo could accept multiple CopiableTypeX or a CopiableTypeCopiableTypeX to copy the copy function lol At first It seemed to me that all types are copiable but then realized that erasures can make a Type not copiable CopiableTypeX itself is not copiable but without erasures it would be My question is if this could be a buildin part of Formality Only by looking at a Type one can see if it is copiable or not and if it is writing a copy function is trivial using pattern matching This way it won t be necessary to pass a copy function everywhere you want to use it The only drawback that I see is that in the current version of Formality the number of times a term can be used is restricted maybe the number of times a term is used could be part of the Type itself It is possible to give a term of the type NotCopiableTypeX if X is not copiable What is the purpose of having the erasure in the Subset type If I Im writing a proof using some term of the type p Nat suchthat IsEven then at some point I would need to use psnd right If I should use a Sigma instead then why having Subsets Thank you The type Output doesnt exist or the examples are missing some import This has a recursive call inside each case toBrainFuckp ListInstruction String case p nil nil cons case phead as ins right cons toBrainFuckptail left cons toBrainFuckptail inc cons toBrainFuckptail dec cons toBrainFuckptail write cons toBrainFuckptail read cons toBrainFuckptail loop concat concat cons toBrainFuckinscode toBrainFuckptail So when compiled to JS every case would recurse being accidentally exponential A temporary solution insert toBrainFuck ListInstruction String inside toBrainFuck below the second case This will pass the recursive calls linearly to each branches preventing this problem from happening it is also a very good practice in general interaction nets like that style On the long term we can make the JS compiler lazy by wrapping every value inside a closure Because types are corecursively defined to check whether those types are equal we cannot just normalize them and check whether their normal forms are definitionally equal Rather we attempt to reduce redexes in all possible orders branching and performing a breadthfirst search However the problem with this is that type checking some code like nattest TheNat n the add n n is incredibly exponentially slow since it will try to reduce add n n in all possible orders A better solution would be to normalize the term before How should we prevent the type checker from doing the slow search when it isnt needed As a possible direction to the solution of this problem I stress that while types are corecursively defined terms are recursively defined so that we might need different strategies depending on whether we are dealing with a term or a type The following code doesnt stop while typechecking import Base T CommutesTf T T T commutesf T T T proof aTbT fa b fb a main CommutesNat aNatbNat addab a The following typechecks and runs fine haskell T Thing thing main Thing case thing thing thing But this does not haskell main Thing case thing thing thing T Thing thing It gives the following parse error the space between case and thing on line is highlighted tmp fm t PARSEERROR Couldnt find the ADT for this patternmatch Make sure the cases have the correct name and order I noticed the problem on line col file mainfm main Thing case thing thing thing T Thing thing Hi Victor do you need a js visualization for the formalitycore I just have one which can do interaction combinators and it seems it is easy to adapt for your needs As I am not competent in the intricacies of your project I leave the link here Also I have to pay back for your nice questions on chemlambda All is needed is to input the rewrite rules in obvious places and to feed the script with a network presently done by adding it to molLibjs 