I first went for QEMU to run test programs but I was not able to build the loader hikariatlantis loader cargo xbuild target x unknownhermitloaderjson Updating cratesio index Compiling core v homehlabhikarirustuptoolchainsnightlyx unknownlinuxgnulibrustlibsrcrustsrclibcore Compiling compilerbuiltins v Compiling rustcstdworkspacecore v homehlabhikarirustuptoolchainsnightlyx unknownlinuxgnulibrustlibsrcrustsrctoolsrustcstdworkspacecore Compiling alloc v tmpxargo B MgwlFncp Finished release optimized targets in s Downloaded bitflags v Downloaded x v Downloaded rawcpuid v Downloaded cc v Compiling semverparser v Compiling cc v Compiling x v Compiling bitflags v Compiling rustyloader v homehlabhikarirustyhermitloader Compiling multiboot v Compiling semver v Compiling rustcversion v error failed to run custom build command for rustyloader v homehlabhikarirustyhermitloader Caused by process didnt exit successfully homehlabhikarirustyhermitloadertargetdebugbuildrustyloaderc c aeae de buildscriptbuild exit code stderr thread main panicked at called Resultunwrap on an Err value Os code kind NotFound message No such file or directory buildrs note run with RUSTBACKTRACE environment variable to display a backtrace warning build failed waiting for other jobs to finish error build failed Same problem for Win and Ubuntu I also gave uhyve a try but it hangs without giving any output hikariatlantis helloworld sudo cargobinuhyve targetx unknownhermitdebughelloworld C I had to run it as sudo since otherwise there will be a permission error The readme doesnt mention anywhere that the described steps are Linuxonly I suspect this is the actual reason that cargo build Z buildstdstdcoreallocpanicabort target x unknownhermit fails for me on macOS Catalina with running cc cc O ffunctionsections fdatasections fPIC m I srclibbacktrace I Usersmoritzcoderustunikerneltargetx unknownhermitdebugbuildbacktracesys bab e f f aout fvisibilityhidden DBACKTRACEELFSIZE DBACKTRACESUPPORTED DBACKTRACEUSESMALLOC DBACKTRACESUPPORTSTHREADS DBACKTRACESUPPORTSDATA DHAVEDLITERATEPHDR DGNUSOURCE DLARGEFILES Dbacktracefullrdosbacktracefull Dbacktracedwarfaddrdosbacktracedwarfadd Dbacktraceinitializerdosbacktraceinitialize Dbacktracepcinfordosbacktracepcinfo Dbacktracesyminfordosbacktracesyminfo Dbacktracegetviewrdosbacktracegetview Dbacktracereleaseviewrdosbacktracereleaseview Dbacktraceallocrdosbacktracealloc Dbacktracefreerdosbacktracefree Dbacktracevectorfinishrdosbacktracevectorfinish Dbacktracevectorgrowrdosbacktracevectorgrow Dbacktracevectorreleaserdosbacktracevectorrelease Dbacktracecloserdosbacktraceclose Dbacktraceopenrdosbacktraceopen Dbacktraceprintrdosbacktraceprint Dbacktracesimplerdosbacktracesimple Dbacktraceqsortrdosbacktraceqsort Dbacktracecreatestaterdosbacktracecreatestate Dbacktraceuncompresszdebugrdosbacktraceuncompresszdebug Dmachogetviewrdosmachogetview Dmachosymboltyperelevantrdosmachosymboltyperelevant Dmachogetcommandsrdosmachogetcommands Dmachotrydsymrdosmachotrydsym Dmachotrydwarfrdosmachotrydwarf Dmachogetaddrrangerdosmachogetaddrrange Dmachogetuuidrdosmachogetuuid Dmachoaddrdosmachoadd Dmachoaddsymtabrdosmachoaddsymtab Dmachofiletohostu rdosmachofiletohostu Dmachofiletohostu rdosmachofiletohostu Dmachofiletohostu rdosmachofiletohostu o Usersmoritzcoderustunikerneltargetx unknownhermitdebugbuildbacktracesys bab e f f aoutsrclibbacktraceelfo c srclibbacktraceelfc cargowarningsrclibbacktraceelfc fatal error linkh file not found cargowarninginclude linkh cargowarning cargowarning error generated exit code If the above is expected on nonLinux platforms see this issue in backtracesys I suggest adding a note to the READMEmd that the instructions in there are Linuxonly Or adding instructions how to install a toolchain that alleviates it for nonLinux platforms Citation microvm is a machine type inspired by Firecracker and constructed after its machine model Its a minimalist machine type without PCI nor ACPI support designed for shortlived guests microvm also establishes a baseline for benchmarking and optimizing both QEMU and guest operating systems since it is optimized for both boot time and footprint Conseqeuntly it is a interesting platform for RustyHermit and should be supported cleanup of internal repo integration into the current master branch Build a bootable image with bootimage Bootimage use a boot loader which is better maintained in comparison to our own Docker is cool Nevertheless there should be a guide on how to install without docker 