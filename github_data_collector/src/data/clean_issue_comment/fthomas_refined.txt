This change might prevent the compiler crash reported in by removing the self type in Validate see Since I havent been able to reproduce or even observe the crash in I cant say if this actually improves anything Updates orgscalazscalazcore from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgscalaz artifactId scalazcore details labels semverpatch Was there a particular reason behind the RFCs that were chosen in I found that PrivateNetwork did not match what I expected it to The addresses in rfc seem like they should never be routed to Operational Implications Addresses within the TESTNET TESTNET and TESTNET blocks SHOULD NOT appear on the public Internet and are used without any coordination with IANA or an Internet registry RFC Network operators SHOULD add these address blocks to the list of non routeable address spaces and if packet filters are deployed then this address block SHOULD be added to packet filters These blocks are not for local use and the filters may be used in both local and public contexts There is also a bug in Rfc ClassBPrivateSpec It should start at not Im by no means an expert but it seems like adding types for rfc would be a better way to go Without digging into each RFC I suspect what most people would want is any address which is listed in rfc as a valid destination IP address and maybe the loopback addresses Destination A boolean value indicating whether an address from the allocated specialpurpose address block is valid when used as the destination address of an IP datagram that transits two devices Thoughts this came up in the Scala community build after refined started failing with the problem is reproducible outside dbuild just with binc eed d after adding a resolver followed by coreJVMTestcompile looking at git log merges f bac eed d it seems likely the cause is lrytz fthomas does this seem like a progression to you and not a regression in the community build I can work around it by temporarily excluding AdjacentSpecscala Sorry about the long title but this is a weird one and I wasnt sure how to name that I had the problem in my configuration heres a simplified version scala object Test import pureconfiggenericauto import eutimepitrefinedpureconfig I tried removing the refined import and explicitly declaring the implicit but it didnt change anything implicit val evidence ConfigConvert NonEmptyString new ConfigConvert NonEmptyString override def toa NonEmptyString ConfigValue override def fromcur ConfigCursor Result NonEmptyString implicit val evidenceMg ConfigConvert McGuffin new ConfigConvert McGuffin override def toa McGuffin ConfigValue override def fromcur ConfigCursor Result McGuffin case class TestedNesa Set NonEmptyString case class TestedNesLista List NonEmptyString case class TestedPia Set PosInt case class TestedMga Set McGuffin class McGuffin def successWithList loadConfig List TestedNes def successWithListInside loadConfig Set TestedNesList def successWithoutCollection loadConfig TestedNes def successWithoutCaseClass loadConfig Set Set NonEmptyString def successWithoutRefined loadConfig Set TestedMg def failureWithNonEmptyString loadConfig Set TestedNes def failureWithPosInt loadConfig Set TestedPi The definitions of failureWithPosInt and failureWithNonEmptyString do not compileThe same problem exists with Seq instead of Set but it goes away with List either on the inner or the outer collection so theres a workaround but Id rather have Sets as thats what makes sense in my model It is linked to Refined somehow as using a random class instead didnt fail whether Im using Set or Seq but I just cant see how Im using version with refinedscalaz refinedpureconfig and refinedscopt See for the rationale As discussed in there is room for a Sorted predicate Im currently running into use cases where an algorithms implementation differs for sorted and unsorted collections If we can decide on a type signature I can start with the implementation With regards to the sort direction in my opinion we can do two things we can just assume ascending we can provide some sort of enum type which describes the direction Id like to hear opinions on this Also our implicit Validate will need some sort of implicit Ordering to decide if the collection is sorted or not Example For BigDecimal we can use NonNegative but cant use literal predicates like Greater or Interval This looks strange why we cannot apply numeric predicates to the numeric type from the standard library see 