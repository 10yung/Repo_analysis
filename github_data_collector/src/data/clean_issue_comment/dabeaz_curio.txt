 there was a failed attempt of contextvars support with a promise to revisit please revisit dabeaz David given all your deep GIL hacking experience say an application is running curio in main thread as an orchestration framework only no heavy io no heavy math then pushing bytes via asyncio and doing heavy math via threading all in separate threads do you think curio kernel thread priority elevation approaches such as pthreadsetschedparam for Linux and SetThreadPriority for Windows can prevent main thread starvation ie protection against both heavy io threads and heavy math threads hi i just found this powerful libraryand i had noticed that there were async file readwrite methods but they were all bound to the async fileobj so if i had a file descriptor how could i wrap it into these async fileobj PS my file descriptor came from ptyopenpty in case you might say why not use your api to open the file and got the fileobj fix typo abrubtly to abruptly Output if you download the source from pypi and do pytest test you will get something similar to ImportError while loading conftest buildcurio testsconftestpy pypathlocalLocalPathImportMismatchError conftest UsersbeazleyDesktopProjectsjunkcuriotestsconftestpy localbuildcurio testsconftestpy the tests are picking up the pycache directory and reading invalid information Looking at the documentation here it suggests I should be able to use curioQueueput from a sync context without using await Im still new to curio so maybe Ive missed something but I was unable to make this work though it does work if I use a curioUniversalQueue Wanted to confirm that Im not missing something here The following code python import curio async def tocancel try await curiosleep except curioTaskCancelled async def main async with curioTaskGroup as tg await tgspawntocancel await tgcancelremaining curiorunmain printSuccess will print the ZeroDivisionError in the exception handler but otherwise it will appear to exit successfully python xxpy Task Crash Taskid nametocancel stateTERMINATED Traceback most recent call last File xxpy line in tocancel await curiosleep File homezahanaconda libpython sitepackagescuriotaskpy line in sleep return await sleepseconds False File homezahanaconda libpython sitepackagescuriotrapspy line in sleep return yield trapsleep clock absolute curioerrorsTaskCancelled TaskCancelled During handling of the above exception another exception occurred Traceback most recent call last File homezahanaconda libpython sitepackagescuriokernelpy line in runcoro trap currentthrowcurrentnextexc File homezahanaconda libpython sitepackagescuriotaskpy line in taskrunner selfnextvalue await coro File xxpy line in tocancel ZeroDivisionError division by zero Success echo status I think the exception should be propagated in the implicit tgjoin at the exit of the context manager and from there all the way to curiorun Hello I have a piece of code that looks like this py async def checker async def clientconn c await curiospawncheck while True try data await curiotimeoutafter connrecv except curioTaskTimeout if cterminated await cjoin break Couple of things in this code client is spawning another task called checker client periodically checks the status of client and if it has been terminated joins on the task and breaks Is this the best way of checking on the status of a task when you yourself might be awaiting on something in this case client is awaiting on a socket objects recv function The above code works I occassionally get the above WARNING curiotaskTaskid nameclient stateRUNNING Timeout occurred but was uncaught Ignored What does this warning mean Nothing bad seems to be happening but I am curious why this is happening Note that if I increase the timeout to secs I dont see this WARNING anymore Theres some good stuff in the meta module Especially the awaitable decorator was something that I was wanting But Im worried I might die What are the odds of it being stable enough that I wont die 