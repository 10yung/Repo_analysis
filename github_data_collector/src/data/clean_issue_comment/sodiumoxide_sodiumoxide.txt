SODIUMUSEPKGCONFIG secretly uses vcpkg if the MSVC toolchain is selected which is pretty counter intuitive looking at the name of this variable cc sdroege Make sure we use the target when deciding on what to probe link or build Make it easy to persistently enable pkgconfig and vcpkg via feature flag Align environment variables with pkgconfig and vcpkg bindings Closes Closes This is my first try that does not take any precautions wrt backwards compatibility but sticks to the idea that the bundled build is the default while making it easy to persistently enable pkgconfig or vcpkg usage I also separated linking prebuilt libraries and building from source as this simplifies building from source a bit Also exposes that libsodium provides a recommended minimum hash size currently bits so that the user can be freed from having to come up with a reasonable hash size in many cases The API change of Statenew is of course breaking which could be avoided in various ways State just requires the user to supply a hash size and hash has a different API A separate Staterecoutlen constructor is provided that forwards to an internal generic constructor Expose the recommended digest length as a constant DIGESTREC that the user must pass instead of None Personally I opted against that as the current x crate version suggests that the API is still evolving and hence a clean API seems preferable to a compatible one This allows to zero out types like generichashState Digest which are sometimes performance critical but contain sensitive information in other cases so that always zeroing out on drop could be considered prohibitively expensive Another design point here would be to omit the Copy bound to make this more flexible and avoid making the target types Copy but this would allow misuse if eg the type only indirectly owns the relevant memory Memzero variants for consuming methods for cases when blake b is used for confidential data key deriving etc Continuation of Branch rustsec should not be purged unpack libsodium to libsodiumsyslibsodium to build it It all started when I tried to crosscompile sodiumoxide to wasm wasi cfgalltargetarchwasm targetoswasi fn buildlibsodium stdcompileerrorwasm cfgtargetarch or comment out this function fn buildlibsodium Did not help at all I kept receiving error error E cannot find function buildlibsodium in this scope libsodiumsysbuildrs buildlibsodium not found in this scope The issue is buildrs gets compiled on host So our target predicates in buildrs are equal to host target predicates In order to make everything work perfectly we have to crosscompilation envHOST envTARGET if crosscompilation if on windows try find libsodium from vcpkg try find libsodium in env vars or unpack prebuilt library eg msvcx Releasev or mingwwin if on unix try find libsodium from pkgconfig try find libsodium in env vars or build with configure make else try find libsodium in env vars or if crosscompiling to windows for msvc unpack prebuilt library eg msvcx Releasev if crosscompiling to windows for gnu unpack prebuilt library eg mingwwin if crosscompiling to wasm wasi unpack prebuilt library eg wasm wasilibsodiuma if crosscompiling on windows fail cannot crosscompile on windows if crosscompiling on unix to ios or mac or configure with CFLAGS make Does it make sense to you jeanairoldie you can fix this algo to provide versionh for windows stouset you can try to fix this algo to unify environment variables with those used in pkgconfig dnaq what do you think jedisct this issue would be much easier to resolve if we can somehow list all cc files and pass them to cc crate Closes Linked issues Added ability to create ed key pair from byte secret key slice Libsodiums secret key is the byte secret key concatenated with the byte public key Openssl PEMDER files contain just the byte secret key The new method keypairfromsecretkeyslice accepts the byte secret key and derives the byte public key using scalarmultbase It then creates a new SecretKey using the resulting byte concatenation of the secret and public keys It returns the resulting SecretKey and the PublicKey