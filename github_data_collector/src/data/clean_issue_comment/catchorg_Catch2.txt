If an unexpected exception is thrown from a catch test case catch will catch exception and print out the contents of what for the failing test case This is often fairly useless for me at least since its hard to debug without any information on where the exception was actually thrown ie a call stack By default at least on Linux if exceptions are not caught abort will be called providing a useful coredump as well as breaking the program at the point the exception was thrown if running in a debugger Im not very experienced with Windows development but as far as I remember Windows can do something similar giving the developer an option to debug the program if an exception is not caught if Visual Studio is installed There seems to be some options to disable exception handling at compile time but it would be very useful to have a command line option to disable the catch exception handler at runtime This could be used for instance to allow exceptions to be caught without much information when running in a CI environment while giving the developer an easy option to look into the details when reproducing the issue I will be happy to help implement this if it makes any sense Thanks a lot Describe the bug Using a thread sanitizer setup with clang our CI seems to hit an assertion probably in a background thread After that our log is flooded with sanitizer violations that seem to be related to Catch starting like this terminate called without an active exception WARNING ThreadSanitizer signalunsafe call inside of a signal pid operator newunsigned long tmpllvmprojectcompilerrtlibtsanrtltsannewdeletecc synctest x gnucxxnewallocatorcharallocateunsigned long void const optrhdevtoolset rootusrlibgccx redhatlinux includec extnewallocatorh synctest x c stdstringRepScreateunsigned long unsigned long stdallocatorchar const optrhdevtoolset rootusrlibgccx redhatlinux includec bitsbasicstringtcc synctest x c b char stdstringSconstructchar constchar const char const stdallocatorchar const stdforwarditeratortag optrhdevtoolset rootusrlibgccx redhatlinux includec bitsbasicstringtcc synctest x b char stdstringSconstructauxchar constchar const char const stdallocatorchar const stdfalsetype optrhdevtoolset rootusrlibgccx redhatlinux includec bitsbasicstringh synctest x f char stdstringSconstructchar constchar const char const stdallocatorchar const optrhdevtoolset rootusrlibgccx redhatlinux includec bitsbasicstringh synctest x ed stdbasicstringchar stdchartraitschar stdallocatorchar basicstringchar const unsigned long stdallocatorchar const optrhdevtoolset rootusrlibgccx redhatlinux includec bitsbasicstringtcc synctest x ca CatchStringRefoperator stdstring const homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x a aa CatchRunContexthandleFatalErrorConditionCatchStringRef homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x f a anonymous namespacereportFatalchar const homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x dd CatchFatalConditionHandlerhandleSignalint homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x tsanCallUserSignalHandlertsanThreadState bool bool bool int sanitizersanitizersiginfo void tmpllvmprojectcompilerrtlibtsanrtltsaninterceptorscc synctest x bd gnucxxverboseterminatehandler null libstdcso x d application code stack follows Another example WARNING ThreadSanitizer signalunsafe call inside of a signal pid operator deletevoid tmpllvmprojectcompilerrtlibtsanrtltsannewdeletecc synctest x ae gnucxxnewallocatorstdstringdeallocatestdstring unsigned long optrhdevtoolset rootusrlibgccx redhatlinux includec extnewallocatorh synctest x ccde stdallocatortraitsstdallocatorstdstring deallocatestdallocatorstdstring stdstring unsigned long optrhdevtoolset rootusrlibgccx redhatlinux includec bitsalloctraitsh synctest x ccd stdcxx Vectorbasestdstring stdallocatorstdstring Mdeallocatestdstring unsigned long optrhdevtoolset rootusrlibgccx redhatlinux includec bitsstlvectorh synctest x b b void stdcxx vectorstdstring stdallocatorstdstring Mreallocinsertstdstring const gnucxxnormaliteratorstdstring stdcxx vectorstdstring stdallocatorstdstring stdstring const optrhdevtoolset rootusrlibgccx redhatlinux includec bitsvectortcc synctest x d stdcxx vectorstdstring stdallocatorstdstring pushbackstdstring const optrhdevtoolset rootusrlibgccx redhatlinux includec bitsstlvectorh synctest x d e stddebugvectorstdstring stdallocatorstdstring pushbackstdstring const optrhdevtoolset rootusrlibgccx redhatlinux includec debugvector synctest x b dbe CatchXmlWriterstartElementstdstring const CatchXmlFormatting homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x e CatchXmlWriterscopedElementstdstring const CatchXmlFormatting homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x c e CatchJunitReporterwriteGroupCatchCumulativeReporterBaseCatchJunitReporterNodeCatchTestGroupStats CatchCumulativeReporterBaseCatchJunitReporterNodeCatchTestCaseStats CatchCumulativeReporterBaseCatchJunitReporterSectionNode const double homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x a a CatchJunitReportertestGroupEndedCatchTestGroupStats const homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x a a CatchRunContexttestGroupEndedstdstring const CatchTotals const unsigned long unsigned long homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x c b CatchRunContexthandleFatalErrorConditionCatchStringRef homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x f b anonymous namespacereportFatalchar const homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x dd CatchFatalConditionHandlerhandleSignalint homejenkinsagentworkspaceObjectBoxSanitizerssync cbuildDebugtsanobjectboxsrcmaincppsynctestexternalcatchcatchhpp synctest x tsanCallUserSignalHandlertsanThreadState bool bool bool int sanitizersanitizersiginfo void tmpllvmprojectcompilerrtlibtsanrtltsaninterceptorscc synctest x bd gnucxxverboseterminatehandler null libstdcso x d In total there are warnings like that in the log Expected behavior Catch should not trigger tsan warnings Reproduction steps Currently around out of builds produce an assertion and thus trigger the warning flood No simple repro known Platform information Fill in any extra information that might be important for your issue OS CentOS Compilerversion clang Catch version v Additional context asyncsignalsafe functions Of course we will need to fix triggering the assertion and this is not the issue The question is if Catch is doing things in a signal handler that it should not do like calling new and delete Describe the bug Does the link order of Catch Catch Main matter Linking Catch Main Catch works but using the opposite order results in undefined references liblibCatch Mainacatchmaincppo in function main catchmaincpptextstartup x undefined reference to CatchSessionSession usrbinld catchmaincpptextstartup x undefined reference to CatchSessionSession usrbinld catchmaincpptextstartup x undefined reference to CatchSessionapplyCommandLineint char const const usrbinld catchmaincpptextstartup x undefined reference to CatchSessionrun Expected behavior Either a this is intentional or b a should be fixed both are OK to me Reproduction steps Build v preview as a static library eg using CMake Compile minimal program see below and change order of Catch Catch Main cpp minimal program define CATCHCONFIGMAIN include catch catchhpp sh Fails undefined references g CatchMaincpp I include L lib lCatch lCatch Main Ok g CatchMaincpp I include L lib lCatch Main lCatch Platform information OS Linux Compilerversion GCC v Catch version v preview Additional context I find the Custom precision feature very useful However it does not work with implicit conversions TESTCASEPrecision bug CatchStringMakerdoubleprecision struct Foo double val operator double const return val Foo x double y REQUIREx y REQUIREdoublex y Output with tests s UserskghoseCodegrohotestsunitstestcpp PASSED REQUIRE x y with expansion e UserskghoseCodegrohotestsunitstestcpp PASSED REQUIRE doublex y with expansion The expected behavior is for these implicit conversions to behave the same way as explicit casts Note that this example behaves identically with or without the precision invocation Tested with Compiler clang version Thank you Thanks very much for all work on Catch Checking this code cpp include stdexcept include string define CATCHCONFIGMAIN include catchhpp CATCHTRANSLATEEXCEPTION const stdinvalidargument return stdstring Some invalidargument was caught here hellipwith clangtidy checkscerterr cpp source isystem catchincludedir fmacrobacktracelimit gives nohighlight warnings generated source warning initialization of catchinternalExceptionRegistrar with static storage duration may throw an exception that cannot be caught certerr cpp CATCHTRANSLATEEXCEPTION const stdinvalidargument catchincludedircatchhpp note expanded from macro CATCHTRANSLATEEXCEPTION define CATCHTRANSLATEEXCEPTION signature INTERNALCATCHTRANSLATEEXCEPTION signature catchincludedircatchhpp note expanded from macro INTERNALCATCHTRANSLATEEXCEPTION define INTERNALCATCHTRANSLATEEXCEPTION signature INTERNALCATCHTRANSLATEEXCEPTION INTERNALCATCHUNIQUENAME catchinternalExceptionTranslator signature catchincludedircatchhpp note expanded from macro INTERNALCATCHTRANSLATEEXCEPTION namespace CatchExceptionTranslatorRegistrar INTERNALCATCHUNIQUENAME catchinternalExceptionRegistrar translatorName note skipping expansions in backtrace use fmacrobacktracelimit to see all catchincludedircatchhpp note expanded from macro INTERNALCATCHUNIQUENAMELINE define INTERNALCATCHUNIQUENAMELINE name line INTERNALCATCHUNIQUENAMELINE name line catchincludedircatchhpp note expanded from macro INTERNALCATCHUNIQUENAMELINE define INTERNALCATCHUNIQUENAMELINE name line nameline note expanded from here catchincludedircatchhpp note possibly throwing constructor declared here ExceptionTranslatorRegistrar stdstringtranslateFunction T Suppressed warnings in nonuser code Use headerfilter to display errors from all nonsystem headers Use systemheaders to display errors from system headers as well it seems my fmacrobacktracelimit didnt work unamused This can be seen on Godbolt The check is documented here and it refers to this CERT rule Perhaps you consider this unavoidable or just not worth the effort to address But I think it would be good to analyse whether judicious use of catch and noexcept can avoid this securitybased warning Thanks again Description In the command line description for specifying which tests to run it is not immediately clear how to OR multiple test case names I first assumed that I had to separate them by space and Im not the only one Then by reading that tags can have a comma as OR I deduced that it might also work for test names I think it would be much clearer to explicitly say that test case names can be comma separated as well I would like some kind of indication of the progress of the tests when running with d yes For example say I am running tests I would like the first test to show the second and so on until the final test shows Such as s RKI s test fxaudusdjpywbRKIchangingWindowsmallerput s test fxaudusdjpywbRKIchangingWindowsmallerput When I am running tests during the day I would like some kind of indication of how much longer I have to wait before the tests will finish so that I can decide how to best utilise my time Thank you for your consideration Describe the bug v preview release has CMake code which states version number is cmake projectCatch LANGUAGES CXX VERSION in this location Expected behavior Version number should match the release Describe the bug I just test Fibonacci use my own test its cost about ms compare your test only ns so I test more input data about Fibonacci Fibonacci Fibonacci Fibonacci benchmark name samples iterations estimated mean low mean high mean std dev low std dev high std dev Fibonacci ms ns ns ns ns ns ns Fibonacci ms ns ns ns ns ns ns Fibonacci ms ns ns ns ns ns ns Fibonacci ms us us us ns ns ns Fibonacci ms us us us ns ns ns Fibonacci ms us us us ns ns ns Fibonacci s ms ms ms us us ms Fibonacci s ms ms ms ms ms ms Fibonacci cost us vs Fibonacci cost us there must be something wrong with the benchmark I guess it is the cause of Memoization which caused the test performance Fibonacci to be more than times faster Use global counts to exclude Memoization I get new result of performance test cpp stduint t Count globle variable for Unmemoization stduint t Fibonaccistduint t number Count in case of Memoization return number Fibonaccinumber Fibonaccinumber benchmark name samples iterations estimated mean low mean high mean std dev low std dev high std dev Fibonacci ms us us us ns ns ns Fibonacci ms us us us us ns us Fibonacci ms ms ms ms us us us Fibonacci s ms ms ms us us us Fibonacci s ms ms ms us us us Fibonacci s ms ms ms us us us Fibonacci s ms ms ms us us us Fibonacci s ms ms ms ms ms ms Fibonacci cost about ms Close to my own test results ms Fibonacci cost ms vs Fibonacci cost ms Its Looks more correct than before the time ratio Also in line with the Golden Ratio haha Platform information Fill in any extra information that might be important for your issue OS Windows Compilerversion VC CPU i k Catch version v Description To have a SECTION variant SECTIONIF that would be only executed if condition was true define SECTIONIFcond The motivational example TESTCASEMyVector auto vector GENERATEstdvectorint stdvectorint SECTIONIFvectorisEmpty operator REQUIREvector Currently I can skip code inside a section with if but the section will still cause the whole test to be needlessly restarted even if it is not relevant for given generated input eg empty vector Another option would be to have two separate test cases but since the tests share a lots of code it that is less than ideal Same as putting the generators or initialization code in only the relevant sections Too much code duplication Instead I resorted to the following workaround ifcondition SECTIONMySection That seems to work but there is a bug report that seems to have issues with this approach might be outdated though so this might be buggy way of doing things I hope this can be added seemelssly Not sure if this would greatly upset how SECTIONs are handled by Catch 