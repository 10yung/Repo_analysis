Im working on a nostd project and Id love to use Dyon for scripting but I cant easily use it without nostd support I might implement the support myself and put in a pull request but that wont happen any time soon I have experienced panic in dyon in following code use stdsyncArc use dyonloadstr error Call Module Runtime RustObject deriveDebug struct Test fn main let mut module Modulenew errorloadstrmaindyon Arcnewr fn testfuncobj return return obj into mut module let ref module Arcnewmodule let j Test Call function that returns Rust object let call Callnewtestfuncrustj match callrunretRustObject mut Runtimenew module Okanswer println answerlockunwrapdowncastrefTest Errerr errorErrerr thread main panicked at index out of bounds the len is but the index is dyon srcruntimemodrs It may be related to comment in runtimemodrs TODO Could return the last value on the stack Requires popfn delayed after Is this a bug or am I doing something wrong how to add variable i use v before and then i want to change to rust from c i look for all doc and find way to add function by moduleadd or moduleaddstr but i cant find how to add variable dyon support this Sometimes it is nice to use Dyon scripts to analyze Dyon code The lifetimetype checker has a lot of useful knowledge about the source that currently is not available for Dyon scripts For example which functions are called from where functions are called the type of an expression in the code the parentchild relationships of expressions the kind of an expression call call argument loop etc By adding a checkinstringimports scripts can access the knowledge that the lifetimetype checker has about the source at the end of inference For example rust fn adda any b any any all T T f T f T f This is needed since addition on adhoc types is only valid for the same adhoc type A none adhoc type is a type f which adhoc type is T f The all quantifier uses the semantics that none adhoc type is quantified over This way one only needs to write a single rule for all adhoc types plus the default case The normal adhoc rule is not involved since one can simply leave out the case eg f f f and use all T T f T f T f instead The none adhoc type of the previous arguments is lifted to T This means that for binary operators you can leave out adhoc type of the left argument and still pass the type check rust fn kma f km f return clonea fn main println km Works fine printlnkm ERROR rust fn main f printlnf prints Related to Sometimes you want to express that a function call will not work for some type You also might want to display a custom error message rust fn fooa return a b str ERROR This function does not work with str Got this idea from Look up in arrays rust b a b first c b second d b last e b second last f b reports runtime error if b has not length rust b okhi a ok b reports runtime error if b is err rust b a b gets second item in list if the first is c a b gets second item in list if the first is equal to a 