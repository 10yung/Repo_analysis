The bug in parkinglot that made it necessary to use a writelock has been fixed and we can go back to using an upgradable readlock This cleanup is part of issue Signedoffby Michal Terepeta michalterepetagmailcom This is somewhere between a question and a feature request but here goes Ive been trying out salsa on a pet project of mine building a kind of database over a list of records consisting of Subj Pred Obj I then have queries for doing what is essentially graph analysis over these records or rather this single list of entries The Subj Pred and Obj is interned using the salsainterned attribute and the main input to this database is a imVectorTrip where Trip is an interned record This seemingly works pretty well however it required me to bring in some form of cheaptoclone copyonwrite list type myself so I was wondering if this shouldnt be part of salsa itself I imagine something like the following to be very useful to have rust struct MyQGroup salsainputlist fn files self static str let mut db Defaultdefault this returns a handle borrowing the db sort of like a RwLockGuard let mut files dbfilesmut files have a veclike API filespushfoobar explicit drop here cause in this case everything is in a single scope dropfiles let files dbfiles println fileslen Note in this sample Ive simplified things quite a bit and used a slice as the return value from the files fn This is probably not what should be done at all given that a slice requires continuous memory as far as I know at least and that doesnt mesh that well with any sort of immutable list structure again as far as I know Im expecting that the actual implementation of this would rely on some sort of trait like InternKey Whats returned from filesmut is also entirely up in the air I just figured this could be something to start discussion off Or simply decide that this is an unwanted feature As an alternative to this I would at least suggest some documentation on how to work with lists and probably an example with lists cause at least for me that was the biggest how do I start using this for anything but toy samples question I had When using the salsainvoke attribute inside a querygroup clippy complains about type repetition inside the functions bounds This is the code in question rust salsaquerygroupIrDatabaseStorage pub trait IrDatabase hirHirDatabase Get the LLVM context that should be used for all generation steps salsainput fn context self ArcContext Gets the optimization level for generation salsainput fn optimizationlvl self OptimizationLevel Returns the target for code generation salsainput fn target self Target Given a type return the corresponding IR type salsainvokecrateirtyirquery fn typeir self ty hirTy AnyTypeEnum Given a hirFileId generate code for the module salsainvokecrateirmoduleirquery fn moduleir self file hirFileId ArcModuleIR Given a type return the runtime TypeInfo that can be used to reflect the type salsainvokecratecodegensymbolstypeinfoquery fn typeinfo self ty hirTy TypeInfo and these are the consequent warnings in clippy rust warning this type has already been used as a bound predicate crates muncodegen src dbrs fn typeir self ty hirTy AnyTypeEnum note warnclippytyperepetitioninbounds on by default help consider combining the bounds typeir IrDatabase salsaplumbingHasQueryGroupIrDatabaseStorage help for further information visit warning this type has already been used as a bound predicate crates muncodegen src dbrs fn typeir self ty hirTy AnyTypeEnum help consider combining the bounds typeir salsaplumbingHasQueryGroupIrDatabaseStorage salsaDatabase help for further information visit warning this type has already been used as a bound predicate crates muncodegen src dbrs fn moduleir self file hirFileId ArcModuleIR help consider combining the bounds moduleir IrDatabase salsaplumbingHasQueryGroupIrDatabaseStorage help for further information visit warning this type has already been used as a bound predicate crates muncodegen src dbrs fn moduleir self file hirFileId ArcModuleIR help consider combining the bounds moduleir salsaplumbingHasQueryGroupIrDatabaseStorage salsaDatabase help for further information visit warning this type has already been used as a bound predicate crates muncodegen src dbrs fn typeinfo self ty hirTy TypeInfo help consider combining the bounds typeinfo IrDatabase salsaplumbingHasQueryGroupIrDatabaseStorage help for further information visit warning this type has already been used as a bound predicate crates muncodegen src dbrs fn typeinfo self ty hirTy TypeInfo help consider combining the bounds typeinfo salsaplumbingHasQueryGroupIrDatabaseStorage salsaDatabase help for further information visit Used version toml salsa OK so its going to be a bit tricky The problem is this somebody needs to be able to give us a simultaneously live mut QStorage and mut SalsaRuntime Unfortunately right now those two bits of data are supplied by two distinct traits One thing that might help us here would be if we gave up the idea that the user defines the Salsa database type Instead salsa database would be a struct that we define but it has a userdata field that users can specify Ive thought about this for other reasons In particular for the purposes of guaranteeing safety it seems suboptimal that the DB runtime link is defined by endusers who could do all manner of crazy things in there Originally posted by nikomatsakis in In the older codebase GC could never collect a slot key We now enable this by transforming slots to a removed state There is a slight race condition in that someone reading the slot might now race with the GC which would remove it in the meantime in that case we simply try again In I noted an alternative impl strategy for cycle handling that I wanted to explore Anyway I also started a branch that was implemented a bit differently What I was trying to do was to have each active query have an associated Arc with a pointer to the next active query on the stack ie what it is blocked on This way you could follow a chain of queries forward across threads pretty cleanly and lazily I seem to recall that the code in this PR was a bit more complex but then I dont think Ive looked at it since you rebased Filing this issue so I dont forget Still hoping to explore this but Id also be happy to work with someone else on it matklad made a number of comments in that seem worth following up on but which are not particularly related to that PR so Im pulling them into a separate comment to be pursued separately observation we call validatememoizedvalue in readupgrade after replacing QueryState with InProgress It seems to me that after slots we actually can do that in read without aquiring a write lock at all Originally posted by matklad in Also we can switch back to upgradable reads here the issue was fixed in parking lot a while ago Originally posted by matklad in Also maybechecksince looks suspiciously similar to probe validatememoizedvalue Could it be the case that after slots we can share more code between the two Originally posted by matklad in Part of the is confusing to me as it suddenly talks about a query struct which has not been previously mentioned when talking about the database My reading the comments in the helloworld example skills tell me that it may be referring to storage being split out in structs per query group and the database just puts all those together but I actually know nothing about Salsa so its very possible that Im wrong TLDR I can count to three but I cant understand this Would it be possible to have Salsa print the underlying data for interned values in its debug output For example Internal error cycle detected SalsaDatabaseKey kind CheckerStoragecheckdeclarationheadDocumentUri id Identifier id SalsaDatabaseKey kind CheckerStoragecheckdeclarationheadDocumentUri id Identifier id It would be nice to see the underlying strings for the identifiers Wanted to check how much code would need to be addedduplicated to support async queries This isnt a a full implementation I havent even tested to call async functions but the normal sync implementation still work with this with what shouldnt be too much overhead Not really interested in this until asyncawait gets to stable but figured a PR with this could still be useful