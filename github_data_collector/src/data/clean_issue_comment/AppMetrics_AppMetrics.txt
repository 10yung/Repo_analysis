So iam new to metrics maybe im doing something wrong here Let me describe the problem I am reporting metrics data to influxDb I am measuring time of api request calls like so in c csharp using metricsMeasureTimerTimeoptionsTimerOptions response await baseSendAsyncrequest cancellationToken And reporting metrics every seconds like so csharp await TaskWhenAllmetricsReportRunnerRunAllAsync It looks all good when there are calls going to apis Data reported looks correct Here is an example of what is being reported httprequestdurationsecondsRoleAPIURLapisecurityloginHttpMethodGETappUnifyServerserverMyServerenvreleasemtypetimerunitrequnitdursunitrates countmeter irate m E rate m rate m ratemean samples ilast counthist isum min max mean median stddev p p p p p After a while of inactivitywhen there are no call to api something like minutes or so it resets some of the values which results in reporting data like this httprequestdurationsecondsRoleAPIURLapisecurityloginHttpMethodGETappUnifyServerserverMyServerenvreleasemtypetimerunitrequnitdursunitrates countmeter irate m E rate m E rate m E ratemean E samples ilast counthist isum min max mean median stddev p p p p p Notice the following values have been reset to samples icounthist isum min max mean median stddev p p p p p I am using this data in Grafana to show mean time of api calls When they are being reset my grafs look all wrong How can i force metrics not to reset data Were using AppMetrics v and in the process of upgrading our app to NET Core The latest nuget v doesnt seem to have this extension servicesAddMetrics Also were now using Endpoint Routing instead of MVC Routing as per suggestions from NET Core team Whats the likely ETA for NET Core upgrade to be released if its already not supported See when trying to run App Metrics Prometheus Plain text without Syncronous IO which is the default now nothing is reported only after explicitly allowing Syncronous IO will Prometheus Plain Text work During our microservice performance test after migrating all stuff to netcore we saw not observed before issue with low CPU saturation After searching we concluded that the actual problem was inside one of your components that was misbehaving try IMPORTANT this hack is throwing exception for every request Its hack to catch TypeLoadException FuncIListIRouter ActionDescriptor func routersList var attributeRouteHandler routersListFirstOrDefaultr rGetTypeName nameofMvcAttributeRouteHandler as MvcAttributeRouteHandler return attributeRouteHandlerActions return funcrouters catch TypeLoadException return null As described in comment we always get TypeLoadException due to MvcAttributeRouteHandler changed location in netcore packages And when exception is thrown on every request it has a negative effect Either way I suggest to do either of things port this lib to netcoreapp not use this code at all we used this approach to have our own IRouteNameResolver for netcoreapp which did nothing as route was built by different part of code as before but without exceptions as everything inside this class has dependency on routeDataRouters you can just check for routeDataRoutersAny in the beginning It is bad but still better that what you currently have To check that this was not done due to our incorrect usage of libraries I tried the same on your MetricsSandboxMvc project with same results I have some investigation data if you need any I noticed then when using UDP reporter the max send buffer size on application size exceeds OS default and UDP reporter backs off Should UDP reporter use lower flush interval of secs or less I know default is secs Or UDP based reporting needs a feature to send the metrics immediately The success of an HTTP response is defined incorrectly right now cs public static bool IsSuccessfulResponsethis HttpResponse httpResponse return httpResponseStatusCode StatusCodesStatus OK httpResponseStatusCode StatusCodesStatus MultipleChoices xx status codes are considered unsuccessful but they should not Eg there is nothing unsuccessful about a Not Modified response Maybe this was implemented to be consistent with HttpResponseMessageIsSuccessStatusCode but I think it does not have to be On the client we may want to have a stricter check of the status code eg to make sure we are safe to read the body but on the server the notion of success should less strict otherwise the metric OneMinErrorPercentageRate and the like give false alarms I propose to change the above method to cs public static bool IsSuccessfulResponsethis HttpResponse httpResponse return httpResponseStatusCode StatusCodesStatus BadRequest The sample link here points to a non existent url Im also looking for an example of using v with a net console application I can get the reporter to send appmetricsinternalreportsuccess just fine but none of my metrics Hello What do you think about new dotnet trace strategy with etw Stupid question Can AppMetrics uses this EventPipe Does it make sense When selecting the second overload on the Increment method the text displays The amount to decrement the counter I am hoping is the wrong help text I think it would be nice to be able to configure AppMetrics only from the Startupcs class Instead of cs public static void Mainstring args CreateHostBuilderargsBuildRun public static IHostBuilder CreateHostBuilderstring args HostCreateDefaultBuilderargs ConfigureMetricsWithDefaultsctx builder builderConfigurationConfigureconfig configAddAppTagApplicationConstantsAPPLICATIONNAME configAddEnvTagctxHostingEnvironmentEnvironmentName builderOutputMetricsAsPrometheusPlainText UseMetricsEndpoints UseMetricsWebTracking ConfigureWebHostDefaultswebBuilder webBuilderUseStartupStartup Something like this cs public class Program public static void Mainstring args CreateHostBuilderargsBuildRun public static IHostBuilder CreateHostBuilderstring args HostCreateDefaultBuilderargs ConfigureWebHostDefaultswebBuilder webBuilderUseStartupStartup public class Startup This method gets called by the runtime Use this method to add services to the container public void ConfigureServicesIServiceCollection services servicesAddMetricsconfig configAddAppTagApplicationConstantsAPPLICATIONNAME configAddEnvTagctxHostingEnvironmentEnvironmentName servicesAddMetricsEndpoints servicesAddMetricsTrackingMiddleware This method gets called by the runtime Use this method to configure the HTTP request pipeline public void ConfigureIApplicationBuilder app IWebHostEnvironment environment ILoggerStartup logger appUseMetricsAllMiddleware appUseRouting appUseAuthentication appUseAuthorization appUseEndpointsendpoints endpointsMapMetricsEndpoints endpointsMapMetricsEndpointsRequireHost endpointsMapControllers I think this approche is much cleaner than adding AppMetrics to the hostBuilder I generally dont like modifying the Programcs because Id like to have all my configuration at one place in one file