 Hi Daniel When using the same program from I realised that Wasabi returned incorrect answers for indirect function calls js In WasabiresolveTableIdx Out should be In instanceexportswasabitableget Out function The code in question is this If we look at what happens when we do wasmobjdump x for an instrumented binary we will get this brainfucktestinstrumentedwasm file format wasm x Section Details Type type i i nil type i i i i nil type i i i i i i nil type i i i nil type i i i i i nil type nil Import func sig a a func sig wasabihooksbeginfunction wasabihooksbeginfunction func sig wasabihooksglobalgeti wasabihooksglobalgeti func sig wasabihooksi load u wasabihooksi load u func sig wasabihooksi const wasabihooksi const func sig wasabihooksi add wasabihooksi add func sig wasabihooksi store wasabihooksi store func sig wasabihooksreturn wasabihooksreturn func sig wasabihooksendfunction wasabihooksendfunction func sig wasabihooksi sub wasabihooksi sub func sig wasabihooksglobalseti wasabihooksglobalseti func sig wasabihooksi eqz wasabihooksi eqz func sig wasabihooksif wasabihooksif func sig wasabihooksbeginif wasabihooksbeginif func sig wasabihookscall wasabihookscall func sig wasabihookscallpost wasabihookscallpost func sig wasabihooksendif wasabihooksendif func sig wasabihooksbeginelse wasabihooksbeginelse func sig wasabihooksendelse wasabihooksendelse func sig wasabihookslocalseti wasabihookslocalseti func sig wasabihooksbeginloop wasabihooksbeginloop func sig wasabihookslocalgeti wasabihookslocalgeti func sig wasabihookslocalteei wasabihookslocalteei func sig wasabihooksi ne wasabihooksi ne func sig wasabihooksbrif wasabihooksbrif func sig wasabihooksendloop wasabihooksendloop func sig wasabihookscallindirect wasabihookscallindirect func sig wasabihooksi gts wasabihooksi gts func sig wasabihooksi xor wasabihooksi xor func sig wasabihooksi gtu wasabihooksi gtu func sig wasabihookscalliii wasabihookscalliii func sig wasabihookscallii wasabihookscallii Function func sig inc func sig dec func sig shl func sig shr func sig start func sig end func sig prn func sig func sig func sig func sig func sig b Table table typefuncref initial Memory memory pages initial Global global i mutable init i global i mutable init i global i mutable init i global i mutable init i global i mutable init i Export func inc inc func dec dec func shl shl func shr shr func start start func end end func prn prn func b b table wasabitable memory c Elem segment table count init i elem func inc segment table count init i elem func dec segment table count init i elem func shl segment table count init i elem func shr segment table count init i elem func start segment table count init i elem func end segment table count init i elem func prn Code func size inc func size dec func size shl func size shr func size start func size end func size prn func size func size func size func size func size b In is because of the imported hooks inflating the function ids Therefore my first thought was subtracting the hook count like so js const functionIdx parseIntWasabimoduletablegettableIdxname ObjectentriesWasabimodulelowlevelHookslength However the approach would not work properly if there are existing imports I think the best solution would be for Wasabi to emit a importCount in Wasabimoduleinfo to be used together with the code above js var functionIdx parseIntWasabimoduletablegettableIdxname if functionIdx WasabimoduleinfoimportCount functionIdx functionIdx ObjectentriesWasabimodulelowlevelHookslength return functionIdx Merry Christmas and a Happy New Year tada depends on multiple tables GCanyref proposal multiple memories source language for analysis that can be compiled to WebAssembly Rust AssemblyScript analysis API in that language Motivation no offline instrumentation step necessary any longer could in principle just add one wasabijs file with wasm inline that does all the instrumentation JS codegen Potential steps target wasmunknownunknown how to call from JS use wasmbindgen Rust has evolved quite a lot since the starting of Wasabi In particular we are now using stable Rust edition One thing where the old code shows is the procedural macro that generates a wasm parser from the wasm ast in the libwasm crate Update it to use newest quotesynn crates Hi Daniel I just have implemented a NodeJS wrapper for Wasabi It will be useful if we could use Wasabi from NodeJS to support automatic integration tests for analyses with some libraries like puppeteer Its the first time I have written in Rust language so welcome for any feedback Hope it will be merged soon Ps This actually a part of my research project in university Im working on with your guys awesome paper It would be very useful to be able to modify the state of an operation inside of a hook Eg javascript Wasabianalysis binarylocation op first second r If result for i eq operations in function are change it to then continue execution with the new result if op i eq location func result result consoleloglocation op result result 