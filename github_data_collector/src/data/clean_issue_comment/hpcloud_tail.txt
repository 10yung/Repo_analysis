When the tailTell method runs the next line may have been read This results in offset not being a precise value Whether to consider adding a configuration When the configuration is true send offset in lines channel Config is used to specify how a file must be tailed type Config struct Filespecifc Location SeekInfo Seek to this location before tailing ReOpen bool Reopen recreated files tail F MustExist bool Fail early if the file does not exist Poll bool Poll for file changes instead of using inotify Pipe bool Is a named pipe mkfifo RateLimiter ratelimiterLeakyBucket Generic IO Follow bool Continue looking for new lines tail f MaxLineSize int If nonzero split longer lines into multiple lines Logger when nil is set to tailDefaultLogger To disable logging set field to tailDiscardingLogger Logger logger add this config LinesOffset bool When the configuration is true send offset in lines channel type Line struct Text string Time timeTime Err error Error from tail Offset int this tell file offset When doing this on an inexist file tailTailFileoutputFilename tailConfig Follow true ReOpen true MustExist false It logs waiting for file to appear If i create the file now in a text editor enter some lines and save tail correctly detect there are new lines However if the file is created by another program and not closed for example this python script with openoutputFilename w as f for i in range fwritestri fwrite n fflush timesleep Then the tail doesnt detect file exist before the file is closed But the file content does changed before its closed I can verify by open the file in a text editor or rerun the go tail program this time it can watch the file line by line Hi Ive been debugging this issue and fixed it with the changes in this pull request Im a bit new to go so forgive me If I misunderstand but heres what happened Quick context first I am using hpcloudtail in my component called CsvTail which tails a file parses the CSV records in that file and only stops when it encounters the NUL byte at the beginning of a line The CSV files are streamed and written by another service which uses the NUL byte to indicate the end of the file The code would sometimes deadlock when calling tailStop Stop internally calls tailWait which waits for the tomb to be declared as dead What happens is that another line comes in after my read of the NUL byte but before my Stop call causing the tail library to block on this line Tail would never reach the end of tailFileSync where it checks for tailDying returns and sets the tomb as Done My fix is to add a select and cancel the write if the tomb enters dying state Not sure if this is right though let me know if Im misunderstanding or misusing the library Best Paul Fixes GOOSdragonfly go build returns an error githubcomhpcloudtailtailgo undefined OpenFile This library is a dependency of quicgo which we use in Caddy and Caddy can no longer compile for Dragonfly because of this This updates to use the new fsnotify import path also remove vendor to work with go modules Hello I want to receive a notification when deleting a file or directory What should I do Tailing a file that gets regularly written to like Apache log files can crash with message The process cannot access the file because another process has locked a portion of the file This happened on a Windows version installation Please also see where I provide more details and steps that I used for reproducing including a minimal Go program that uses just the tail module Although for reproducing I used githubcominfluxdatatail in that program this probably also applies to githubcomhpcloudtail given that influxdatatail and hpcloudtail have minimal differences and there appear to be no differences in the relevant tailFileSync function tailer err tailTailFilepodLogPath tailConfig ReOpen true MustExist true Follow true Poll true Logger tailDiscardingLogger RateLimiter lplimiter Location tailSeekInfo When log file being writed very fast and rotated will lose logs what Im missed Calling Cleanup on a Tail can decrement the watch counter below zero which can prevent future attempts to tail the file Here is some code that can be used to show the issue go func main Setup and tail being careful to avoid issue t err tailTailFileosArgs tailConfigFollow true if err nil fmtPrintlnerr go func for line range tLines tStop tCleanup At this point the watch count for this is negative the next time we try to tail a watch will not be set t err tailTailFileosArgs tailConfigFollow true if err nil fmtPrintlnerr go func for line range tLines fmtPrintfq n lineText tWait To duplicate go run maingo testlog from another shell echo testlog echo testlog Expected the lines appended to testlog should be printed to screen Actual no output Looking into the history of this function it appears it was originally added to close all inotify watches before the program exists and it did not originally require access to the Tail objects Since now you need the Tail to call it seems preferrable to call Stop instead The Cleanup function also does not ensure that the watch count goes to zero it just does a single decrement which wont be enough if there are multiple tails on a file 