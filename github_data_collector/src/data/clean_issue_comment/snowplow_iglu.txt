All components migrated to their own repositories We need to list these repos and figure out what to do with this umbrella repository Fixed dead link Right now if client requests but it does not exist entity just fails with schema not found dilyand is wondering if instead it can fallback to A counterargument client defined schema with some keys Then sends an event with unkown bar key of length it falls back to Then client uploads with bar maxLength We have a falsely valid entity A counterargument to conterargument if validates this unknown bar it must have additionalProperties true In that case next schema with defined bar should not be an ADDITION Just updated a schema in one of embedded registries and realized how easy it can get out of sync with main Iglu registry Illustrative scenario we have some schemaed Fooenum Bar Baz entity in a spark job that needs to be Parsed from JSON Validated by Iglu client Decoded into FooBar or FooBaz class Decoder knows that Bar and Baz are acceptable values However once we add Qux to list of acceptable values schema will get out of sync With sbtiglupush we can configure an SBT task to derive schema from decoder and push it to Iglu Server during CICD Kind of reverse of which is Schema Class definition while we have Class definition Schema which is much more approachable I tried to follow up with the first step for proposed plan in There is no serious logic change It is just moving codes around Please support with your comments cc nafid zakipatel This was raised multiple times mostly in order to reduce boilerplate code but we never actually considered it closely enough Now dilyand found another good application for it in datamodeling with graphoriented DBs Wondering if this should classic JSON Schema ref or we can use igluprotocol to link schemas Several applications group schemas by vendor field but theres two different behaviours comacmemarketingschemas are subset of comacme comacmemarketing is independent of comacme I believe first behavior is correct The whole point of vendor is to provide proper namespacing and namespacing assumes hierarchy Documentation Scala Iglu Client Scala Repo Server probably Schema DDL 