is the case for multiple links I suppose a search replace is in order Once the core is stabilized and were confident the internal schema representation wont drastically change again we need to make the API ready for public consumption by naming things correctly reducing the API surface removing the dependency to shapeless or at least hiding it from the user right now we only need shapeless for getting singleton types for fields and branches names Before releasing a first version we must provide a threetiered documentation each tier targeting a specific level of interaction with the library User the general philosophy behind the library its intended purpose and goals stepbystep descriptions of the most common usecases typeclass derivation schema evolution for every provided module Poweruser how to extend the library how the derivation mechanism works internally and how to create new modules and interpreters how the migration mechanism works and how to implement newcustom migrations Contributor the design decisions that have lead to the current implementation and the reasons behind them and more generally anything that is useful to know before contributing to the core of the library Once all other issues labelled with neededforv are done a few things need to be done in order to move out the prototyping phase add file headers and other administrative stuff most of this should be done in sbtorgpolicies add a proper CONTRIBUTINGmd merge prototyping into master reconfigure the repository to make master the default branch again CI protected branches etc We can and should pull the isos out of the SchemaF patternfunctor We would end up with a userfacing SchemaZ case class containing an iso from a business type T to a generic representation sums of products A and a Schema A The typeclass derivation would still work the same it would derive instances for A and corresponding instances for T would be obtained by maping or contramaping the relevant half of the iso The impact on migrations is still unknown though TypeDefs is a project in Idris with very similar goals and internals as scalazschema It already supports several target languages and scalazschema has got a good opportunity to become the Scala implementation Building upon it seems rather obvious that we should be able to automatically derive the schema of any ADT at compile time as a matter of fact this gist achieves just that using shapeless Like to this should be provided in the generic sbt module with no impact on the existing API for constructing schemas Also if gets merged before this issue is solved words must be added in the documentations to stress out the fact that such fully automatic derivation should be used with caution for it somehow defeats the purpose of having schemas as runtime values in scenarios where schema evolution is a needed feature it OK to fully derive schemas at compile time as long as the application stores the derived schema somewhere at runtime From the users point of view the most tedious part of defining a schema is writing the values of the iso field of unions and records For instance in ordre to define the schema for a class scala final case class Fooi Int l Long s String b Boolean one must implement an Iso Int Long String Boolean Foo which is boilerplate Using generic programming it is possible to derive automatically at compile time an Iso between any case class product type and its nested tuples representation We should provide such a way in the generic module using scalazderiving This issue must be solved without modifying the existing API for building schemas namely the public methods in SchemaModule An acceptable solution would be to define some Generic module extending SchemaModule with two methods caseClass allowing to define a Record by simply providing a product of labelled fields with automatic derivation of the iso sealedTrait allowing to define an Union by simply providing a sum of labelled branches with automatic derivation of the iso Important note This issue should be solved while taking into account the results of these names are merely suggested names Implementing automatic data migration implies being able to compute the structural difference between to schemas Ideally this difference would be represented as a sequence of schema transformation as defined in 