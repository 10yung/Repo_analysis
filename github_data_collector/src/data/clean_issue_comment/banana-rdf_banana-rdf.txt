To my mind we should go with the time and provide a RDF J implementation This could lead to a bananrdf SHACL adapter and other things It came out of an experiment but I quickly recognized that there was not much to be changed As all tests run I want to contribute it I tested it with version and A small change to the NTriple test suite had to be made Especially in scalajs I recognized slow speed accessing graph structured of moderate size here I present an approach to get a better performance using an immutable Hexastore approach with a dictionary mapping URIsStrings to Integers It keeps a lookup Map Map Vecor with the following combinations spo sop pso pos osp ops Probably of these are enough to cover all cases in pattern matching I continue this approach by using a mutable BTree for the dictionary and later possibly also for the maps to gain even more performance insert and query with Olog N which you can follow here bastiionBPlusTree I folow the approach of Hexastore Sextuple Indexing for Semantic Web Data Management by Weiss Karras und Bernstein Could this be an option If yes I would try to unfiddle the commits again from the other non necessary changes At the very top of each of your GitHub repository pages there is a button that says Edit and below that a button that says manage topics Topics are useful to make it easier to find your repo from Could you add like five topics as keywords to the top of your repo We need to implement an algorithm to make a graph lean This may be implemented in Jena or Sesame but is not implemented in Plantain See the very good paper Everything you ever wanted to know about blank nodes It looks like there actually are some pretty efficient algorithms for this especially for smaller graphs Ideally I would like to see the Travis CI showing build passing instead of build unknown See Sometimes when I search for projects in GitHub Advanced Search I filter by license Also my employer is kind of picky when it comes to submitting approvals for Free Open Source Software FOSS Could you please include the LICENSE file in the repo so it appears at the top of the GitHub page like so Instructions Also if you could go with a slightly more common permissive software license like Apache or MIT that would be helpful I think its possible to include a LICENSE file in all packaged artifacts like so Hey I am considering using Banana RDF A couple of questions License The software license you have isnt the usual Apache or MIT license and the LICENSE file does not appear in the project itself Example Usage Can I use this as a drop in substitute for Eclipse RDF J Sesame and can this library process the RDF Turtle syntax Hi I followed the addition configuration need for Eclipse project generation on the main READMEmd but I still get the following error Any clue info About to create Eclipse project files for your projects javalangNoSuchMethodError scalazScalazToValidationVLjavalangObjectLscalazsyntaxValidationV at comtypesafesbteclipsecorepackagesettingpackagescala at comtypesafesbteclipsecoreEclipseskipParentsEclipsescala at comtypesafesbteclipsecoreEclipseanonfunaction applymcZspEclipsescala at comtypesafesbteclipsecoreEclipseanonfunaction applyEclipsescala at comtypesafesbteclipsecoreEclipseanonfunaction applyEclipsescala at scalaOptiongetOrElseOptionscala at comtypesafesbteclipsecoreEclipseactionEclipsescala at comtypesafesbteclipsecoreEclipseanonfuneclipseCommand applyEclipsescala at comtypesafesbteclipsecoreEclipseanonfuneclipseCommand applyEclipsescala at sbtCommandanonfunapplyEffect anonfunapply applyCommandscala at sbtCommandanonfunapplyEffect anonfunapply applyCommandscala at sbtCommandanonfunapplyEffect anonfunapply applyCommandscala at sbtCommandanonfunapplyEffect anonfunapply applyCommandscala at sbtCommandprocessCommandscala at sbtMainLoopanonfun anonfunapply applyMainLoopscala at sbtMainLoopanonfun anonfunapply applyMainLoopscala at sbtStateanon processStatescala at sbtMainLoopanonfun applyMainLoopscala at sbtMainLoopanonfun applyMainLoopscala at sbtErrorHandlingwideConvertErrorHandlingscala at sbtMainLoopnextMainLoopscala at sbtMainLooprunMainLoopscala at sbtMainLoopanonfunrunWithNewLog applyMainLoopscala at sbtMainLoopanonfunrunWithNewLog applyMainLoopscala at sbtUsingapplyUsingscala at sbtMainLooprunWithNewLogMainLoopscala at sbtMainLooprunAndClearLastMainLoopscala at sbtMainLooprunLoggedLoopMainLoopscala at sbtMainLooprunLoggedMainLoopscala at sbtStandardMainrunManagedMainscala at sbtxMainrunMainscala at xsbtbootLaunchanonfunrun applyLaunchscala at xsbtbootLaunchwithContextLoaderLaunchscala at xsbtbootLaunchrunLaunchscala at xsbtbootLaunchanonfunapply applyLaunchscala at xsbtbootLaunchlaunchLaunchscala at xsbtbootLaunchapplyLaunchscala at xsbtbootBootrunImplBootscala at xsbtbootBootmainBootscala at xsbtbootBootmainBootscala error javalangNoSuchMethodError scalazScalazToValidationVLjavalangObjectLscalazsyntaxValidationV This modification adds the possibility to serialize an PlantainGraph back to jsonldjs The design of bananardf unfortunately does not allow to pass parameters to the serializer so no further customization of the output can be done While working on a jsonldjs feature I recognized that none of the scalajs code was actually beeing tested There were some mistakes in the way how the jsonldjs resource was beeing loaded it coudlnt be referenced in an nodejs environment because you have to specify it commonJSName Furthermore dependencies of scalajs crossprojects have to be specified with orgorganisation package this cannot not be done in Dependenciesscala In general I thought it was time to leverage the build chain to use the latest sbt version and the plugindependencies Unfortunatly I coudlnt get unidoc working at the moment Further investigation is necessary what needs to be aggregated and excluded