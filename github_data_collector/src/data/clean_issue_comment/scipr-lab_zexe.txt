Thanks Pratyush for the help w this FpParameters Inv The current comment is incorrect The updated comment should be correct independent of hardware This is because the integers used are explicitly declared as u throughout the library Ive confirmed this equation matches what is in edwardsbls Edwardsbls Fix the mismatch between comment and generator Field generator Remove redundant information about it being a quadratic nonresidue A quadratic residue is the square of an element As we are in a nonbinary field the order of the multiplicative subgroup is even Therefore any element with a quadratic residue cannot be a multiplicative generator Currently the polynomial library does not support an API to multiply more than two polynomials together efficiently For n polynomials the API would ideally Add up their degrees create a new domain with the degrees FFT the polynomials with the new domain multiply all of the polynomials in their eval form IFFT using the new domain The derive macros defer to the versions implemented on Selftype references This eliminates a lot of the impl boilerplate might go away when Rust figures out how to to autorefderef on operators Hopefully this also serves as inspiration for extension of the approach to Sub Neg Uses rustfmtskip annotations on field constants and numerical definitions This should help us build more confidence in avoiding accidental performanceimpacting copies FFTs in the library are all nlogn However they could be nlogd which is an efficiency improvement when doing polynomial multiplication This can be taken advantage of in two possible ways Split up the FFT into nd independent FFTs operating over the same polynomial but evaluating on distinct cosets Both of these subFFTs are dlogd At the end concatenate these two vectors Skip the first few rounds of butterflying arithmetic in the current FFT algorithm and just copy the polynomial coefficients into the correct positions This is implemented in libiop This probably doesnt matter for the current pairing based SNARKs as they are dominated by MSM time This is a straight forward sConstraintSystemR CS cargo test passes If anything beyond this was implied by the item in let me know Maybe renaming all the cs CS This is one of the critical missing pieces for this library A sketch of the design I have in mind is to make CanonicalSerialize and CanonicalDeserialize traits rust pub trait CanonicalSerialize type Output IteratorItem u fn serialize self Output pub trait CanonicalDeserialize CanonicalSerialize fn deserialize SelfOutput Self The idea would then be to implement these directly for the final instantiated curves eg for Bls G I dont see an easy way to have a generic implementation that works for all base fields algebra Move curve specific modules to their own crates Reduces compilation time Investigate how to make ToBytes and FromBytes nostd compatible Possibly replace identity functions in Field Group and ProjectiveAffineCurve traits with OneZero traits from numtraits Possibly add impl AddSelf for Self besides just impl Add Self for Self Add a generic trait for Point Compression for AffineCurve elements benchutils Check whether it can be replacedintegrated with tracing Move into algebra behind a trace feature r cscore Refactor ConstraintSystem ConstraintVar LinearCombination and Variable APIs as per and Rename ConstraintSystem to R CS Prefer ConstraintSystementerns and ConstraintSystemleavens to ConstraintSystemns Additionally refactor Namespace struct to be just a guard struct which automatically decrements the scope when dropped r csstd Make FieldVar GroupVar and other variable structs generic over CS ConstraintSystemF as well This enables getting rid of cs CS arguments to various functions like add mul etc In turn this allows impl AddSelf for FieldVar impls impl new impl Add MulSelfConstant for FieldVar impls with the constants This might not be possible due to coherence rules might have to use enumbased approach standardize UInt cryptoprimitives Make gadget APIs consistent with above conventions 