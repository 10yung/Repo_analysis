Occasionally it is useful to flip the arguments of a function Particularly when pipping data if the function you want to use expects the data argument to be the second argument the current best approaches as far as I can tell would be data partialfn x value data fnvalue Haskell implements a function called flip tthis was previously mentioned by lionel in but I cant see that there was any further discussion about this function The implementation in R AFAIK shouldnt be too difficult As a very minimal example of this function working r flip functionfn functionx y fny x TRUE flip FALSE A bit more of an admittedly contrived example of the use of this function is below Here I am working with an sf table which if I join some extra data to but have the sf table as the right table I lose all of the sf metadata But if I flip innerjoin I am pipping my data to be the right input and it stays as a sfc r librarytidyverse librarysf Linking to GEOS GDAL PROJ nc streadsystemfileshapencshp packagesf astibble TRUE Reading layer nc from data source C Program Files R R library sf shape ncshp using driver ESRI Shapefile Simple feature collection with features and fields geometry type MULTIPOLYGON dimension XY bbox xmin ymin xmax ymax epsg SRID proj string projlonglat datumNAD nodefs nc astibble selectCNTYID mutatern rownumber flipinnerjoinnc by CNTYID Simple feature collection with features and fields geometry type MULTIPOLYGON dimension XY bbox xmin ymin xmax ymax epsg SRID proj string projlonglat datumNAD nodefs A tibble x AREA PERIMETER CNTY CNTYID NAME FIPS FIPSNO CRESSID BIR SID NWBIR dbl dbl dbl dbl fct fct dbl int dbl dbl dbl Ashe Alle Surry Curr Nort Hert Camd Gates Warr Stok with more rows and more variables BIR dbl SID dbl NWBIR dbl geometry MULTIPOLYGON rn int If this would be a useful addition to purrr I will happily raise a PR ave is the base functional I use the most if I attach tidyverse but it has several issues Its name and default are awkward I was a bit intimidated of this function as a beginner The doc is misleading and only numeric input AND output are documented so technically we shouldnt use it on characters and to return character for instance The FUN argument must always be spelt explicitly as it comes after the dots We cant use purrr lambdas We cant pass additional arguments to dots so many times we have to type a soul crushing ok maybe dramatizing a bit FUN functionx meanx narm TRUE when wed really rather type mean narm TRUE ave cant output lists Type stability especially as ave sometimes returns a wrong type It could play well with vctrs peformance could be improved it seems given that Hadleys remarks from have not been considered as far as I can see It might have been considered but since I found no relevant issues here it is Heres rough implementation not type stable and not very efficient to get my point across r mapalong functionx along f if islistalong along interactionalong as used by basesplitdefault f rlangasfunctionf body ascallcquotef quotex evalsubstitutealist fun rlangnewfunctionalistx body avex along FUN fun mapalongc NAc mean NA NA NA mapalongc NAc mean narm TRUE mapalongc NAc mean narm TRUE supCreated on by the reprex package v sup A neat additional feature would be to have a magical function or pronoun to access the relevant instance of along in the loop ave doesnt support this and I missed it a few times helps with debugging too Fix The only item missing relative to the discussion in is the capturing of conditions other than messages and warnings but I think that warrants a separate discussion and fix Fixes Currently I dont see a nice and easy way to extract information from a list of lists eg to extract the names of all labels in repurrrsivediscog r repurrrsivediscog mapcbasicinformation labels mapfunctionlabel mapchrlabel xname There it would be nice to write something along the lines of r map repurrrsivediscog listbasicinformation labels iterate name Tobi Records La Vida Es Un Mus La Vida Es Un Mus La Vida Es Un Mus Beat Generation Beat Generation Maybe one could also have something like iterateca b to only iterate over elements with these names In this spirit one might also have a special version of map r x list comp list labels list label listname labelA label listname labelA label listname labelA comp list labels list label listname labelB label listname labelB produce columns for named iterators mymapx listcomponent iterate labels label iterate name A tibble x componentid componentname labelid labelname label int chr int chr chr comp label labelA comp label labelA comp label labelA comp label labelB comp label labelB Consider the following dataframe df dataframex y NA As expected we have purrrpmapdf sum NA However I would expect to obtain the same result when I run purrrpmapdf sum which is not the case This latter result seems to relate to the following behavior sumc NA NA sum NA NA sum rlangasfunction sum sum c NA NA sum NA A common scenario for me is to map over nested lists AFAIK there is no built in or purr functionality for this Basically an rapply version but which would operate not just on leaves but also on the inner nodes Example R rmapsessionInfo unclass Seems like this might make a nice entry in vignette This is the anticipated behavior I guess r purrr v env rlangemptyenv add functionx y printrlangenvparent x y add purrrpartialadd x env env add Error in addx could not find function add supCreated on by the reprex package v sup Then with v r purrr v env rlangemptyenv add functionx y printrlangenvparent x y add purrrpartialadd x env env Warning The env argument is softdeprecated as of purrr This warning is displayed once per session add environment RGlobalEnv supCreated on by the reprex package v sup When looking at the source code I think the problem is that env is not in when in purrrpartialadd x env env and hence not in args so it wont be spliced r partial functionf env NULL lazy NULL first NULL args enquos call callmodifycall fn args 