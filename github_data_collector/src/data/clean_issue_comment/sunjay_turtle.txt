NB This is a far future idea at the time of writing but who knows maybe well get it done sooner than we think smile It would be very cool if we added support for allowing turtles to divide up the drawing into layers The layer stack would behave exactly like layers behave in graphics programs like Photoshop The base Drawing would act as a permanent bottom layer cannot be reordered Heres the API Im imagining for this rust pub struct Layer impl Layer Adds a layer to above this layer and returns it Any drawings created on this new layer will appear above this layer and any other layers below it in the layer stack Drawings on this new layer will also appear above the original Drawing itself Other layers and the Drawing can still be used as normal as you use this layer pub fn addlayerabove mut self Layer Creates a new turtle and assigns it to this layer pub fn addturtle mut self Turtle Merges the drawings of this layer into the layer below it or into the Drawing if this is the first layer This layer may not be used anymore after this point Any Turtles that have been assigned to this layer will be reassigned to the layer this was merged with Panics Panics if there is no lower layer to merge into pub fn mergedownself Moves this layer underneath the given layer in the layer stack The drawings of this layer will now be drawn underneath that layer Any Turtles assigned to this layer will continue drawing on it unaffected Panics The base layer from Drawing cannot be moved Attempting to do so will result in a panic pub fn moveunder mut self other Layer pub fn moveover mut self other Layer Clears all the drawings from this layer All other layers as well as the original Drawing are completely unaffected pub fn clear mut self Removes this layer from the layer stack deleting all drawings on this layer in the process Any turtles assigned to this layer are reassigned to the original Drawing Panics Trying to remove the base layer from Drawing will result in a panic pub fn removeself Duplicates this layer and all of its drawings leaving any assigned turtles still assigned to the previous layer The new layer is placed above this layer pub fn duplicate self Sets the clipping rectangle in which this layer will be drawn No drawings outside of the given rectangle will show This can be useful to accomplish a picture in picture effect or even a split screen effect pub fn setclipping mut self topleft Point size Size topleft and size are in turtle world coordinates Clears the clipping rectangle for this layer and allows it to be drawn across the entire window pub fn clearclipping mut self TODO setbackgroundcolor rust impl Drawing Creates a new turtle that can draw on this drawing pub fn addturtle mut self Turtle Adds a layer to this drawing and returns it Any drawings created on this new layer will appear above any previously created layers as well as the original Drawing itself Other layers and the Drawing can still be used as normal as you use this layer pub fn addlayerabove mut self Layer Clears the drawing and all layers in the layer stack pub fn clearall mut self rust impl Turtle Assigns this turtle to draw on the given layer You may also pass the original Drawing to this method to assign the turtle back to the base layer of the layer stack pub fn drawonL AsLayer mut self layer L The addturtle methods are specifically a part of the multiple turtles API Every other part of this can be implemented independent of that The setclipping method can become a future extension and a separate GitHub issue if it is too much work to implement it as part of this Missing from this API is any way to traverse the layer stack I have no idea if that is a useful feature or not or how the API should look The functions above should be sufficient as a starting point There should also be more getters in the final API A probably silly idea I had was that we should think about supporting a mode where instead of drawing a simple D triangle we actually draw a full D turtle that walks around a plane and draws with a pen tied around its tail I thought of this while looking at a screenshot from one of my oldest years ago games The green thing in the center of this screenshot is a turtle We could have something like that drawing on a white plane Other than some method to set the mode none of the turtles interface needs to change This is just a neat way to render the animated drawings I think its important to have some sort of mouse controls so you can rotate the view pan and zoom around the D world while the turtle draws I have no idea how we would render the D paths the actual drawings in D I think the new rendering backend should help with that though because it represents everything in terms of vertices and faces using the lyon crate Model a simple lowpoly D turtle with a pen on its tail Create a new backend for the turtle that draws in D instead of D Render a turtle D model Render the plane it walks on better if very big infinite sized Render the paths being drawn as the turtle moves around Mouse controls for moving around the D world Left mouse button drag rotate view around center of view Middle mouse button drag pan the view Right mouse button drag zoom in and out Consider what the control scheme should be for people without a mouse middle mouse button Bonus points for making it possible to change the color of the D pen when the pen color of the Turtle struct changes We should consider implementing the Debug trait for the Turtle struct so that it becomes possible to print out the turtle and immediately see information about it It wouldnt be useful to just derive the trait automatically because the Turtle struct doesnt actually directly contain any real information about itself All of that is in the separate renderer process This implementation will probably not be added anytime soon because querying each individual property would just be horrendously slow Eventually once we add some low overhead ways to access the other processs memory we will be able to do this in a reasonably performant way The implementation should print out as if the turtle struct actually had all of these fields as normal fields position heading printed with a unit either or rad depending on the angle unit speed pen properties printed as a field called pen that prints Pen thickness fill color visible etc See getter methods on struct We can use the methods on the Formatter struct that specifically allow for printing structs Basically we want to totally fake the internal representation just for the sake of making debugging easy While this issue is specific to the turtle struct this may be applicable to other types in the crate as well Updates the requirements on rand to permit the latest version details summaryChangelogsummary Sourced from rands changelog Fixes Fix incorrect pointer usages revealed by Miri testing Fix tiny bias in Uniform for and bit ints Crate Bumped MSRV min supported Rust version to Updated to Rust Edition Removed dependence on randxorshift randisaac randjitter crates Remove dependency on winapi Removed all buildrs files Removed code already deprecated in version Removed the serde feature Its still available for backwards compatibility but it does not do anything Many documentation changes randcore Updated to randcore Error type redesigned with new API Move fromentropy method to SeedableRng and remove FromEntropy SeedableRngfromrng is now expected to be valuestable Standard RNGs OS interface moved from randos to new getrandom crate getrandom Use ChaCha for StdRng and ThreadRng Featuregate SmallRng ThreadRng now supports Copy Deprecated EntropyRng Enable fork protection of ReseedingRng without std Distributions Many distributions have been moved to randdistr Bernoullinew constructor now returns a Result Distributionsampleiter adjusted for more flexibility Added distributionsweightedaliasmethodWeightedIndex for O sampling Support sampling NonZeroU types with the Standard distribution Optimised Binomial distribution sampling Optimised SIMD float sampling Sequences Make results portable across and bit by using u samples for usize where possible Crates Update randcore to Move JitterRng to its own crate Add a wasmbindgen test crate Platforms Fuchsia Replaced fuchsiazircon with fuchsiacprng trtable truncated details details summaryCommitssummary See full diff in compare view details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it To ignore the version in this PR you can just close it dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Automerge options neverpatchminor and devruntime dependencies Pull request limits per update run andor open at any time Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired Finally you can contact us by mentioning dependabot details We have things in our API that are unstable Some examples include many methods on Drawing everything to do with events We should make it impossible to use these accidentally by forcing people to use a cargo feature called unstable This feature will be disabled by default We should make sure that docsrs still shows these functions and that we have some documentation in each of them to indicate that they shouldnt be used One day we might be able to get a working unstable attribute but until then this will have to do For every type that can be randomized Color Point Speed etc we should add a section Generating Random X that documents how to use random and randomrange to generate values of that type Behaviour of random and randomrange for each type Examples of using each Examples of the different bounds types supported by each most of them implement RandomRangeB with B IntoX Do this for the scalar types too Distance etc Need to put some thought into this and then add a note in the README Relevant links A perturtle way to support undoing and then potentially redoing the last actions of a given turtle Since we only have one turtle per drawing right now it is fine to maintain just a single undo stack but the idea is that this feature will eventually work well with multiple turtles as well We can also add something called a save point to return an identifier to a particular point in the turtles state This can be used to undoredo the drawing back to a particular point Then instead of an undo stack we could even make an undo graphtree where you can go back and forth to any arbitrary point in history Modeling it as a graph is probably a much later extension to what can start as a simpler feature This undoredo functionality is related to the Push Pop functionality added to this Lsystems workshop that uses turtle Hello Turtle is a great project in so many ways I noticed that after completing the Rust logo cargo run example rust the cargo process was using of a core on my MacBook Pro while the operating systems WindowServer process was using This suggests Turtle is still drawing when idle I dont know much about the GUI graphics stacks so have no idea if this is difficult to fix Side note CPU utilisation is also pretty high while drawing managing to use all four cores on my laptop Reducing idle CPU utilisation should help with that too Somewhere in CONTRIBUTINGmd or otherwise we need to document the architecture of the turtle crate That means talking about its dualprocess design how animations work drawing commands interprocess communication etc If this information is not directly in CONTRIBUTINGmd it needs to be linked in that file This is very important for onboarding new contributors into the turtle codebase