When migrating existing fields from the model into the translation table the newly created fields are all nil Example ruby Before migration class Post ApplicationRecord translates title body attribute is not translated end Postfind body Untranslated body Migrating body to being translated class Post ApplicationRecord translates title body end In the migration Postaddtranslationfields body text migratedata true Postfind body nil After some digging I think it comes from the call to readattribute during the data migration It seems that instead of returning the raw data from the column it returns nil Even the call to ActiveRecords readattribute returns nil For now we have to run the data migrations manually ruby def up addcolumn posttranslations body string Postfindeach do post translation posttranslationforen translationupdatebody postbody end end def down removecolumn posttranslations body end This is using globalize rails This is based on the commits in PR extended by phansch smile Closes Closes phanschglobalize Initial review of a fix for that removes database checks for column names and ignored columns This suggestion is based off the fact that it should not be connecting to the database for tests and before it is in a production setting Developers should technically be reading the docs to see how it uses the columns and translation tables before implementing D Shoutout for love of docs We shouldnt try to connect to the database during asset precompilation for example Thanks to and ruby gem rails gem globalize When precompiling assets in a Docker environment Rails fails with the following error rails aborted PGConnectionBad could not connect to server Connection refused Is the server running on host localhost and accepting TCPIP connections on port could not connect to server Connection refused Is the server running on host localhost and accepting TCPIP connections on port Volumesomittedappmodelscategoryrb in classCategory Volumesomittedappmodelscategoryrb in main Volumesomittedconfiginitializersrailsadminrb in block in main Volumesomittedconfiginitializersrailsadminrb in main Volumesomittedconfigenvironmentrb in main Volumesomittedbinrails in top required Volumesomittedbinspring in top required binrails in load binrails in main Tasks TOP environment See full trace by running task with trace Because were doing this as part of a Docker build we dont have access to any database Rails is attempting to open a connection because a translation exists on my Category model which is being interrogated by Rails Admin This issue originally arose in and was resolved in by guarding database checks with connected A subsequent PR to support Rails reintroduced this bug in b f e a a e aa e because connected doesnt return true when running tests using a database because theres nothing to trigger the actual connection altered the behaviour to rescue ActiveRecordNoDatabaseError however a failed Postgres connection raises PGConnectionBad which leads to the error Im experiencing suggested rescuing from PGConnectionBad but understandably this was rejected as it makes pg a dependency of globalize and doesnt cater for Mysql ErrorConnectionError This comment has some insight into how this could be avoided in Globalize but Im not familiar enough with GlobalizeActiveRecord to put together a fix happy to be pointed in the right direction though Im mostly opening this issue for visibility as the conversationscomments are all on closed issues and merged PRs Would you be open to a PR reverting b f e a a e aa e in the interim GlobalizeActiveRecordInstanceMethodssave wraps ActiveRecordBasesave and therefore all lifecycle methods with an explicit set of Globalizelocale equal to the localization value at the point when save was called This is problematic because it makes calls to I nwithlocale and friends in an aftersave not change Globalizelocale and therefore makes translated models not work in that context My usecase is indexing translations in elasticsearch via an aftersave callback where I was surprised to find that only in aftersave my models were not responding to switching locales In other words in any AR lifecycle callback the following holds true so long as the model was saved while I nlocale en I nwithlocalees Globalizelocale en Heres a gist with the repro case Possibly related to andor I dont know if this is an edge case or not but I added the option to enable fallbacks for empty translations for all models It might not be necessary but I thought it might be useful in some cases Calling findbyattributename on translated object produces following output Placefindbyname London Place Load ms SELECT places FROM places INNER JOIN placetranslations ON placetranslationsplaceid placesid WHERE placetranslationsname rubyobjectActiveRecordStatementCacheSubstitute n AND placetranslationslocale de LIMIT nil Placewherename Londonfirst Place Load ms SELECT places FROM places INNER JOIN placetranslations ON placetranslationsplaceid placesid WHERE placetranslationsname London AND placetranslationslocale IN en de ORDER BY placesid ASC LIMIT PlaceTranslation Load ms SELECT placetranslations FROM placetranslations WHERE placetranslationsplaceid IN Place id name London createdat updatedat ruby p revision x linux rails globalize 