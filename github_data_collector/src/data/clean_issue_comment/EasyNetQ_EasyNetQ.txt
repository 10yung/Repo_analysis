I think there is a bug in the DefaultConsumerErrorStrategy Publisher Confirm is not taken into account when the channel is created in the DefaultConsumerErrorStrategy csharp using var model connectionCreateModel var errorExchange DeclareErrorExchangeWithQueuemodel context var messageBody CreateErrorMessagecontext exception var properties modelCreateBasicProperties propertiesPersistent true propertiesType typeNameSerializerSerializetypeofError modelBasicPublisherrorExchange contextInfoRoutingKey properties messageBody return AckStrategiesAck I think it needs to wait for the Publisher Confirm if it is enabled before it returns Ack or Nack for example by using csharp modelWaitForConfirmsOrDienew TimeSpan or csharp modelConfirmSelect modelBasicAcks sender ea code when message is confirmed modelBasicNacks sender ea code when message is nacked or am i missing something Best Regards Ren DO NOT MERGE THIS This is just a proof of concept about the idea of having an injectable ILogger interface along with LibLob as default implementation See the discussion LibLog is now deprecated see My recommend course of action for library developers is to use MicrosoftExtensionsLoggingAbstractions as it is now the defacto standard logging interface in the NET ecosystem For library developers that wish to continue to use LibLog or need to make adjustments for their needs should copy the code into their project after all thats just what LibLog did Thanks to all contributors and users for the support over the years Damian Im using this library and quite happy with it But I have a problem and I didnt find any solution for it int docs or sources Yesterday my DC restarted several times so rabbit broker seems to cancel subscription This is the most recent entry in the logs Context EasyNetQConsumerBasicConsumer MessageTemplate Consumer with consumerTag consumerTag has cancelled Then my app stuck because it couldnt reconnect back to the broker Or I suspect that because nothing get written in the logs although queue contained some messages In other words if there are some reconnection attempts I dont see them in logs Is there any way to handle this As I see BasicConsumerHandleBasicCancel is not virtual or anything so I dont see how can I change this behavior Id like to either setup some reconnect strategy like start polling broker and reestablish connect or at least allow code to crash with broker is unavailable so I could restart my app and thus make reconnect happen Looks related to In a word SystemThreadingChannels from netcore above and it has builtin async support and uses the new ValueTask for better performance when the task completes synchronously Some info An Introduction to SystemThreadingChannels SystemThreadingChannels Namespace The core abstractions exposed from the SystemThreadingChannels library are a writer csharp public abstract class ChannelWriterT public abstract bool TryWriteT item public virtual ValueTask WriteAsyncT item CancellationToken cancellationToken default public abstract ValueTaskbool WaitToWriteAsyncCancellationToken cancellationToken default public void CompleteException error public virtual bool TryCompleteException error and a reader csharp public abstract class ChannelReaderT public abstract bool TryReadout T item public virtual ValueTaskT ReadAsyncCancellationToken cancellationToken default public abstract ValueTaskbool WaitToReadAsyncCancellationToken cancellationToken default public virtual IAsyncEnumerableT ReadAllAsync EnumeratorCancellation CancellationToken cancellationToken default public virtual Task Completion get Hi Im trying to use the requestrespond methods following the example here Ive created a new solution to try and get this working so Im running the same code as in that comment The server responds correctly whenever I publish a message Throwing about Hello World Throwing about Hello World but the exception isnt picked up in the client it just times out after a few seconds Unhandled exception SystemTimeoutException Request timed out Any idea whats going on here Has error handling for requestrespond changed since Feb EasyNetQ Version alpha RabbitMQ Version Erlang Version Whenever I try to alter the name of my connection using EasyNetQ undefined is displayed inside the management ui which basically indicates that a null value was given I do not believe that the RabbitMQ server is the problem root here as it is possible to set the name using python Unfortunately I am not able to derive a solution from looking at the ConnectionConfiguration source code and cannot debug the problem myself Example Coding c var configuration new ConnectionConfiguration Name MyCustomName tried this as well same result configurationClientPropertiesAddconnectionname MyCustomName gives undefined var connection RabbitHutchCreateBusconfiguration gives undefined var connection RabbitHutchCreateBus nameMyCustomName However it is possible to declare completely new fields on ClientProperties Hi Brother we use EasyNetQ to publish message every minutes in client If RabbitMQ highwater markeither disk space or memory is reached RabbitMQ Server will refuse any client incoming message which will cause client application threads count to increase to more than thousands how to solve this problem is is possible to precheck highwater mark in client before publish message thank you Hi We currently hosting rabbitmq as docker image and sometimes we need to kill or restart that container while subscribers using easynetq are connected If it happens after rabbit is available to subscribers no queues are created till subscribers are restarted Also it looks like that if we configure rabbit in a way that all needed queues are automatically created then pub and sub side cant communicate So how to force subscribers to create queues after recovering from Rabbit restart Hi team I wish to know how we can customize the client properties visible in the connection tab in RabbitMq server using EasyNetQ Please guide Thanks