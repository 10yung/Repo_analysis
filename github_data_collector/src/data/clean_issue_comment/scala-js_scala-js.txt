 Please follow these steps to help us fixing the bug Make sure it is a bug for this repo Can you reproduce the bug with ScalaJVM If yes report it to instead Make sure it is not one of the intended semantic differences Does the bug involve macros If yes make sure to reproduce without macros or file an issue to the relevant macro library instead or ask on Gitter if its your own macro Is it about the website If yes report it to instead If in doubt ask on Gitter first Make sure we can understand and reproduce the bug Give code and reproducible steps to provoke the bug Give the version of Scala and Scalajs you are using if relevant sbt as well What did you expect to happen What actually happened If possible minimize the bug This helps fixing bugs more quickly Try to get rid of any external library Thank you Symptom MethodAccessorImpl NoClassDefError happens with Scalajs RC when compiling multiple ScalaJS projects We have no such issue with Scalajs x After rerunning fastOptJS the compilation eventually succeeds Im using sbt and JDK The same error happens with JDK CI log It might be an issue of sbtscalajs plugin and sbt xs new classloader The same problem happens with sbt Ill work on reproduction of this issue It seems the reflection call of PathOutputFile in the LinkerImpl is failing scala private val outputFileMethod loadMethodPathOutputFile atomic classOf LinkerOutputFile classOf Path This is used here scala val out LinkerOutputlinkerImploutputFileoutputtoPath withSourceMaplinkerImploutputFilesourceMapFiletoPath withSourceMapURIrelURIsourceMapFilegetName withJSFileURIrelURIoutputgetName A workaround is splitting an aggregated project into a smaller set of projects and running fastOptJS individually Reproducible in x and x in and In things work correctly Full repro scala package helloworld class Apply def testTraitMixinInLocalLazyVal Unit trait TraitMixedInLocalLazyVal val foo foobar lazy val localLazyVal class ClassExtendsTraitInLocalLazyVal extends TraitMixedInLocalLazyVal val obj new ClassExtendsTraitInLocalLazyVal assertobjfoo foobar localLazyVal object HelloWorld def mainargs Array String Unit new ApplytestTraitMixinInLocalLazyVal In and the IR of the inner class is scala class helloworldApplyClassExtendsTraitInLocalLazyVal extends javalangObject implements helloworldApplyTraitMixedInLocalLazyVal val foo javalangString val outer helloworldApply def fooLjavalangString javalangString thishelloworldApplyClassExtendsTraitInLocalLazyVal foo def helloworldApplyTraitMixedInLocalLazyValsetterfooeqLjavalangStringVhelloworldApplyTraitMixedInLocalLazyValsetterfoox javalangString thishelloworldApplyClassExtendsTraitInLocalLazyVal foo x def helloworldApplyTraitMixedInLocalLazyValouterLhelloworldApplyouter helloworldApply thishelloworldApplyClassExtendsTraitInLocalLazyVal outer constructor def initLhelloworldApplyVouterouter helloworldApply if outer null throw modscalascalajsruntimepackageunwrapJavaScriptExceptionLjavalangThrowableLjavalangObjectnull else thishelloworldApplyClassExtendsTraitInLocalLazyVal outer outer thisjavalangObjectinitV thishelloworldApplyTraitMixedInLocalLazyVal initV in which the field foo is immutable This is incorrect because it is assigned to in the trait setter def helloworldApplyTraitMixedInLocalLazyValsetterfooeqLjavalangStringV One problem is that for scalac that field is not marked as MUTABLE This has always been an issue for val fields in traits so we have logic that patches up fields that are unexpectedly mutated They are recorded as such in case Assign at and patched up in genClassFields at However when all the following conditions are met Scala The class that does the mixin is in the rhs of a lazy val That lazy val is inside a def so its a local lazy val not a field then scalac ends up creating different Symbols for that field One is used in the Assign node and the other is listed a member of the class and hence used by genClassFields This causes our patching up to fail to process that field since it is not the same symbol but they have the same nameowneretc This is a followup of where we always enabled the IR checker in x Unclear if we should do this in or in With Nodejs on the PATH in x toolsJStest fails one test namely StackTraceTestdecodeclassnameandmethodname Test run started Test orgscalajstestsuitelibraryStackTraceTestdecodeclassnameandmethodname started Test orgscalajstestsuitelibraryStackTraceTestdecodeclassnameandmethodname failed null took sec Test orgscalajstestsuitelibraryStackTraceTestdecodeclassnameandmethodname finished took sec Test run finished failed ignored total s This does not happen on Nodejs v nor in x for testSuite bootstraptest in that branch Upgrading sourcemapsupport to same as in x does not solve the issue My first guess would be that its related to the fact that toolsJStest executes everything in an eval whereas in x testSuite bootstraptest uses all the right setups to execute the bootstrapped test suite as a toplevel script just like the nonbootstrapped one If I cant nail it down quickly enough I will first submit a PR to disable that test in the boostrap to repair the CI When the ES module option is active scala scalaJSLinkerConfig withModuleKindModuleKindESModule the js file obtained trough fullOptJS isnt minified and projectoptjs is only smaller in size than projectfastoptjs See We should split them into Implementation details of the Emitter the true EmittersymbolRequirements Things that should be reached by the Analyzer See for details See discussion on 