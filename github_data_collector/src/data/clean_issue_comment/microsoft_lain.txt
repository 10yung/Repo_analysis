It seems like there would be adapter libraries or this would be one piece of a larger fuzzing system Where does this fit in with cargo fuzz or other existing rust fuzzing tools What is the purpose is this type It seems to always cast the variant to Invalid as well as just punting on mutation to the primitive value within the original variants In the example the mutator does not only mutate between the provided variants it passes a u to mutate and wraps the result in UnstableEnumInvalidu Which isnt what I would expect from an Enum mutation except for maybe very rarely like ignoring tags I am seemingly having some issues getting fields to mutate within a defined structure The simplest way to reproduce this is to remove the Fixup implementation on the examplefuzzer and comment out the connecting and sending packets The mutator will also ignore any lainignore flags on the first field of the structure and still do a walking bitflip pass While this is just odd behavior the real problem is the lack of mutation on the fields within the structure even during Havoc mode mutations I have run this through million iterations looking for a change in length with this setup and have yet to see one Additionally typ does not seem to mutate after the initial run through bit flips Looking through the code it looks like there may be an issue with duplicated unsigned fields I am not sure how this could happen and I am still looking around the code but obviously offset is being mutated properly Based on the trace info typ is getting into the macro generated mutate function but then failing to call mutatefrommutationmode Meanwhile the length field seems to be placed under what looks to be an ignore flag by trying to get the chance to ignore the flag Obviously this could be chalked up to the mutator focusing on a single field first but that is not my understanding of how Havoc works so I am curious if there is any other insight on this issue or if it is reproducible for other people Sending packet PacketData typ Invalid offset length data T Z TRACE lainmutator generating number between and T Z TRACE lainmutator got T Z INFO lainmutator Havoc T Z INFO lainmutator num is T Z INFO lainmutator T Z TRACE lainmutatable Mutating unsigned value T Z INFO lainmutator Havoc T Z INFO lainmutator num is T Z INFO lainmutator T Z TRACE lainmutator Operation selected BitFlip T Z TRACE lainmutator xoring bit T Z TRACE lainmutatable Mutating unsigned value T Z INFO lainmutator Havoc T Z INFO lainmutator num is T Z INFO lainmutator T Z TRACE lainmutator generating number between and T Z TRACE lainmutator got T Z TRACE lainmutator generating chance got so returning false T Z TRACE lainmutator generating number between and T Z TRACE lainmutator got T Z TRACE lainmutator generating chance got so returning false T Z DEBUG examplefuzzer getting serialized size of PacketData T Z TRACE lainbuffer getting serialized size for Vec T Z TRACE lainbuffer returning since theres no elements T Z DEBUG examplefuzzer size of PacketData is x T Z DEBUG examplefuzzer getting serialized size of PacketData T Z TRACE lainbuffer getting serialized size for Vec T Z TRACE lainbuffer returning since theres no elements T Z DEBUG examplefuzzer size of PacketData is x Sending packet PacketData typ Invalid offset length data This fixes an issues with Vec mutation where the mutator can actually try to remove more bytes than exist in the vector This causes a panic The fix here is pretty simple we just take the min of the length of the vector or the randomly generated range When calling Mutatablemutate on an object that contains a Vec the current impl MutatableT for VecT will treat itself as a slice and mutate all objects inplace Shrinkinggrowing the Vec is desirable and should for a baseline require the following work Fix mutate methods not passing down Constraints Add two new impls rust implT Mutatable for VecT where T Mutatable Where only shrinking a Vec would be performed and rust implT Mutatable for VecT where T Mutatable NewFuzzed SerializedSize Where shrinking or growing a Vec would be performed The separation here allows us to call NewFuzzednewfuzzed on the new elements in the vec while also respecting the max size constraint if its provided Another desired feature would be to randomly mutate fields or slice elements to be the length of any known vectors in the data structure including encapsulating structures but this is a pretty large undertaking Known issues to fix SerializedSize and NewFuzzed are oddly coupled since the former is used when a Constraint with maxsize is supplied String mutation isnt very welltested NewFuzzed is slower than it needs to be as a result of initializing fields in random order This could be fixed with a const fn that checks if any of the fields recursively contain dynamicsize members and if not use static initialization ordering The randomness only matters when we have dynamic fields in order to try influencing the number of items generated for a dynamic field when working with a maxsize constraint Done as part of the release of lain When things fail they panic This is mostly bydesign to have things failfast but some errors are just swallowed eg serializing to a buffer thats too small Add support for unnamed struct fields and named enum fields From an overall cleanup perspective the following changes should probably be made at some point as well The mutators state machine should possibly be decoupled from the mutator itself Im not a huge fan of calling mutatorbeginnewiteration in the harness driver or mutatorbeginnewcorpus when fuzzing a new item from my corpus I found myself in my corpus management checking against MutatorModeHavoc to switch between items in my corpus since this is the last state in the state machine which may be misleading or not futureproof Cleanup of API exports Work on verifying reproducible runs This is loosely verified through tests but isnt very elaborate Proc macros are somewhat of a mess to follow Driver isnt super well thoughtout and is mostly for convenience