Implemented the scheduleWithFixedDelay and scheduleWithFixedRate functions for the FakeScheduledExecutorService Since this is a singlethreaded executor and the service always has to catch up to the clock fixed delay is no different from fixed rate to my understanding JUnit Kotlin Mockito Moshi OkHttp Datadog Retrofit ShadowJar SLF J Adds an identifier to a hibernate session which stays the same across retries Can be used to determine whether something happened in the same transaction For We need misksecurityssl for clients When you switch to the new Android Gradle plugin XX you should replace all your compile with the implementation keyword Then try to compile and test your app If everything its ok leave the code as is if you have problems you probably have something wrong with your dependencies or you used something that now is private and not more accessible Suggestion by Android Gradle plugin engineer Jerome Dochez If you are a library mantainer you should use api for every dependency which is needed for the public API of your library while use implementation for test dependencies or dependencies which must not be used by the final users kotlin Constraintdirectorname fun directorNamename String MovieQuery queryFactorynewQueryMovieQuery directorNameGeorge Lucas deletesession will generate something like delete from movies cross join directors where nameGeorge Lucas which is invalid Our cluster abstraction exposes ClusterResourceMapper as an instance variable of ClusterSnapshot This makes sense because the mapper uses only the set of cluster members to generate a mapping from resource ids to cluster members However the RangeRound Robin ResourceMapper described in requires both the set of cluster members and the set of all resource ids This PR separates ClusterResourceMapper from ClusterSnapshot and adds a ClusterResourceMapperProvider that provides it based on the current cluster snapshot This makes it easy to add a range ClusterResourceMapperProvider that reads both the current cluster members and all leases tldr consistent hashing is the only way to load balance leases in misk Although it is a well established way to partition databases counter intuitively it is not the best way to load balance event consumers where the number of total leases is small and each consumer is stateless Our team operates a service that consumes an event topic This topic has partitions and emits events per second At some time last week the service was auto scaled pods Most pods were doing work But according to the metrics the load on these pods was not evenly distributed pods were idle not consuming any events while pods were busy consuming a lot of events After doing some math I found this Assuming the consistent hash ring assigns partitions to a specific pod let s call it pod A time out of given pods Given partitions we have the following binomial distribution img width altScreen Shot at PM src the probability that pod A receives partition is the probability that pod A receives partitions is the probability that pod A receives partitions is the probability that pod A receives partitions is the probability that pod A receives partitions is This distribution consistent with the production metrics is not ideal pods are idle consuming partition pods take twice the load consuming partitions As we increase the number of partitions the distribution becomes more uniform of partitions img width altScreen Shot at PM src of partitions img width altScreen Shot at PM src It is common for databases to have more than rows But it is not practical for a topic to have this many partitions There are other ways to assign partitions to worker pods that yield more consistent and uniform results For example kafka client provides a RoundRobinAssignor and a RangeAssignor kinesis client uses something similar to RangeAssignor Conclusion we should provide similar options in misk for stateless lease holders This does not fail gracefully and failing to lookup a feature flag should not impact a production system See also The misk module currently contains several groups of things Relatively dependency free things clustering config environment metrics token gen etc Clients miskclient including TypedHttpClient etc Server miskwebjetty including some other helpers Actions most of the existing misk module code anything that touches WebAction clients also depend on this in tests today We should separate the misk module into something like these four pieces miskcore miskserver miskclient miskactions Additionally we should merge miskinject into miskcore