Dear Mr Craver i have implemented a datastore to OracleDB I hope this will help other develpers in future if the need oracle support Maybe you are interested to include it to your great Exceptional lib What i dont know is if the oracle licence for the oracle client Nuget OracleManagedDataAccessCore is a problem for the licence of your project Hi I came across this strange issue when publishing StackExchangeExceptional as part of a NET Core Worker service making it fail to run When a worker project references the StackExchangeExceptionalAspNetCore package as in docs its published projectruntimeconfigjson file includes the framework name as MicrosoftAspNetCoreApp instead of MicrosoftNETCoreApp Actual error message when worker is run on a machine with NET Core runtime worker project shouldnt need the ASPNET Core runtime It was not possible to find any compatible framework version The framework MicrosoftAspNetCoreApp version was not found No frameworks were found You can resolve the problem by installing the specified framework andor SDK The specified framework can be found at Any idea why this happens and how to fix it Environment NET Core and SDK StackExchangeExceptional v latest Tested on Windows bit and Ubuntu Server bit Steps to reproduce Create new worker project dotnet new sln dotnet new Worker n MyWorker dotnet sln add MyWorker Add the Exceptional package reference to the MyWorkercsproj project file ItemGroup PackageReference IncludeStackExchangeExceptionalAspNetCore Version ItemGroup Build and publish the project dotnet build configuration Release dotnet publish MyWorker c Release o publish worker Open the publish worker MyWorkerruntimeconfigjson file which will show the incorrect framework name as MicrosoftAspNetCoreApp runtimeOptions tfm netcoreapp framework name MicrosoftAspNetCoreApp version Without the Exceptional package reference the build and publish step generate a valid runtime config with framework name as MicrosoftNETCoreApp Currently the docs for ASPNET Core usage with regards to UseExceptional middleware say Note that you should call this before anything you want handled as exceptions will bubble up to this point But Exceptional doesnt log anything when the app is also using the inbuilt UseExceptionHandler middleware as shown below csharp public void ConfigureIApplicationBuilder app appUseExceptional appUseExceptionHandlerError Please make a note in the docs that when using UseExceptionHandler UseExceptional must be called after it not before for both to work I was playing around with implementing an error store for elmahio during the weekend While I could get it working I stumbled across a couple of issues that needed hacks in order to implement Like error stores need a connection string which doesnt make a lot of sense for cloudhosted services These typically use some kind of authentication and an API to log errors What are your thoughts about this Does it make sense to implement cloudhosted error stores or is Exceptional geared towards databases only Also cloud services typically have their own UI to present errors why implementing all of the getters and deletes feels redundant Would give the user a choice to use either the cloud service UI or something like Opserver of course Using v im initialising the MemoryErrorStore like so However the ApplicationName setting is not respecting the log UI still shows My Application settingsDefaultStore new StackExchangeExceptionalStoresMemoryErrorStorenew ErrorStoreSettings ApplicationName Test RollupPeriod TimeSpanFromMinutes Size Note that this is in an aspnet netFull application And im not using any of the webconfig stuff other then the httpmodule initialisation Note that using the config setting Exceptional applicationNameTest name Exceptional Does work Not sure if this is intentional or not but currently the GetHash function only includes the ExceptionToString and optionally MachineName but it does not consider custom Exception metadata for example from opserver Source for the GetHash function We find this information helpful to recover from what happened here but what seems to happen is that multiple errors with different information get rolled up into one and only one of the exceptions message remains and the others are lost Thats cool if this was intended but thought Id check may be worth at least having an option for it like the MachineName Happy to do a PR to implement this if you agree that it always should should have an option to When trying to use the MySQL error store on a dotnet core application I get the following error Exception Could not find error store type MySQL StackExchangeExceptionalErrorStoreGetErrorStoreSettings settings StackExchangeExceptionalInternalExceptionalSettingsBasegetDefaultStore StackExchangeExceptionalExceptionalMiddlewareHandleRequestAsyncHttpContext context ProjectNameAdminControllerExceptions in AdminControllercs public async Task Exceptions await ExceptionalMiddlewareHandleRequestAsyncHttpContext After a bit of investigation it looks like it might be having trouble finding the StackExchangeExceptionalMySQLdll On my machine the dll is in the nuget folder Usersjohnbokernugetpackagesstackexchangeexceptionalmysql libnetstandard The bin folder in the project only contains my dlls and a ProjectNamedepsjson that references dependencies Im guessing since its not in the same folder as the loading assembly it wont find it correctly A bit below the above referenced line there is a call to AppDomainCurrentDomainGetAssemblies I thought that might get what was needed but when I put that in Main the following is output List of assemblies loaded in current AppDomain SystemPrivateCoreLib Version Cultureneutral PublicKeyToken cec d bea e ProjectName Version Cultureneutral PublicKeyTokennull SystemRuntime Version Cultureneutral PublicKeyTokenb f f f d a a SystemRuntimeExtensions Version Cultureneutral PublicKeyTokenb f f f d a a SystemConsole Version Cultureneutral PublicKeyTokenb f f f d a a MicrosoftAspNetCoreHostingAbstractions Version Cultureneutral PublicKeyTokenadb ddae netstandard Version Cultureneutral PublicKeyTokencc b ffcd ddd MicrosoftAspNetCoreHosting Version Cultureneutral PublicKeyTokenadb ddae Heres my config Exceptional Store ApplicationName ProjectName Type MySQL ConnectionString servermyserverport databaseexceptionaluidxxxxpasswordxxxx In the csproj I have ItemGroup PackageReference IncludeMySqlData Version PackageReference IncludeStackExchangeExceptionalMySQL Version PackageReference IncludeStackExchangeExceptionalAspNetCore Version ItemGroup So what am I doing wrong For a project at my company I am making a package that has to be installed to a bunch of different websites We want to get errors from error loggers if they are installed And are currently willing to support Elmah and Exceptional My boss however also wants to only distribute package for different possibilities these being Website with exception logger installed Website with StackExchangeExceptional installed Website with Elmah installed To make these possible Im trying to dynamically load the dlls of these logger packages and invoke methods needed or get the parameter This working perfectly fine for Elmah by doing for example the following cs Assembly assembly AssemblyLoadFileHostingEnvironmentMapPathbinElmahdll Type type assemblyGetTypeElmahErrorLog object parameters new object parameters null var customResult typeInvokeMemberGetDefault BindingFlagsInvokeMethod null type parameters Type myType customResultGetType IListPropertyInfo props new ListPropertyInfomyTypeGetProperties string result foreach PropertyInfo prop in props if propName Name result propGetValuecustomResult nullToString Which right now simply gets the name of the default ErrorLog Then getting to Exceptional and trying a similar approach cs Assembly assembly AssemblyLoadFileHostingEnvironmentMapPathbinStackExchangeExceptionaldll Type type assemblyGetTypeStackExchangeExceptionalExceptionalModule object objectInstance ActivatorCreateInstancetype PropertyInfo info typeGetPropertyErrorStore foreachPropertyInfo property in typeGetProperties LogHelperInfoExceptionalpropertyName propertyGetValueobjectInstance null This piece of code is to try and get the name of the ErrorStore of the Default ErrorStore used With some logging for testing and such However the moment it has to do anything with the Default parameter of the ErrorStore class which is supposed to return the default ErrorStore I always get an exception thrown SystemReflectionTargetInvocationException Exception has been thrown by the target of an invocation SystemArgumentOutOfRangeException ErrorStore type must be specified Parameternaam settings bij StackExchangeExceptionalErrorStoreGetFromSettingsErrorStoreSettings settings bij StackExchangeExceptionalErrorStoreGetErrorStoreFromConfig bij StackExchangeExceptionalErrorStoregetDefault bij StackExchangeExceptionalExceptionalModulegetErrorStore Einde van intern uitzonderingsstackpad bij SystemRuntimeMethodHandleInvokeMethodObject target Object arguments Signature sig Boolean constructor bij SystemReflectionRuntimeMethodInfoUnsafeInvokeInternalObject obj Object parameters Object arguments bij SystemReflectionRuntimeMethodInfoInvokeObject obj BindingFlags invokeAttr Binder binder Object parameters CultureInfo culture bij SystemReflectionRuntimePropertyInfoGetValueObject obj BindingFlags invokeAttr Binder binder Object index CultureInfo culture bij SystemReflectionRuntimePropertyInfoGetValueObject obj Object index bij h ysrpackageExceptionsExceptionalExceptionalErrors bij h ysrpackageDataCollectorSenderStartCollectiond MoveNext Which brought me to the part of the code that is throwing the error cs if settingsTypeIsNullOrEmpty throw new ArgumentOutOfRangeExceptionnameofsettings ErrorStore type must be specified This being part of the Exceptional package and therefore accessible by me via code Is there anyway to make sure type gets specified when loading the StackExchangeExceptional dll dynamically Or is just not doable Requests such as testillegaljpg throw a SystemWebHttpException exception HttpException x A potentially dangerous RequestPath value was detected from the client SystemWebHttpRequestValidateInputIfRequiredByConfig SystemWebPipelineStepManagerValidateHelperHttpContext context Exceptional does catch these exceptions but it is lacking information such as the actual Url We can trace this down to where in this case the contextHandler null ASPNET core servicesAddExceptionaloptions optionsDefaultStoreSettingsApplicationName Business Trips API optionsEmailFromDisplayName StackExcangeExceptional optionsEmailFromAddress xxxxxxru optionsEmailToAddress xxxxxxru optionsEmailSMTPHost smtpyandexcom optionsEmailSMTPPort optionsEmailSMTPUserName xxxxxxru optionsEmailSMTPPassword xxxxx 