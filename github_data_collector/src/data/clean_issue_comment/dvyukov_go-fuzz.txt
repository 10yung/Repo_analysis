There is a decent chance I am just confused here but as far as I can tell I suspect if your starting point is a clean environment then running go generate in the gofuzzgofuzz directory requires first installing some flavor of gobindata If you dont you get an unhelpful error Cannot find gobindata executable in path Maybe you need go get githubcomelazarlgobindataassetfs I suspect the advice emitted on the second line there by elazarlgobindataassetfs is incorrect based on briefly looking at that repo as well as based on trying that suggested step and then seeing it not help elazarlgobindataassetfs is vendored by gofuzz but I suspect it alone is not complete The corresponding go generate commands are I tried a couple different flavors of gobindata Based on comparing the output results I suspect the most recent go generate run by josharian in was using but not sure The older seems pretty clearly not to be the flavor that was used If you are starting in a clean environment with a copy of dvyukovgofuzz then this seems to work for me go get u githubcomkevinburkegobindata go get u golangorgxtoolscmdgoimports go get u golangorgxtoolscmdstringer cd dvyukovgofuzzgofuzz go generate Part of the context here is that at the time I was looking into what it would take to embed the support packages into the binaries I havent dived very deeply here so sorry in advance if this is incorrect broken out from discussion in Itd be better to do as std does with testing and emit an executable instead of a zip file and using an external runner Off the top of my head steps for this figure out how to have instrumented code live alongside regular code test runner make sonar instrumentation always present and controlled on a run by run basis do dynamic rather than static literal collection refactor everything to support this I dont know how to do step one The rest are nontrivial but seem possible Regarding The problem If a Fuzz function crashes on every initial input provided the fuzzer still executes and posts stats to stdout However since no inputs are provided to the workers nothing meaningful happens The behavior is confusing because of two points No proper logging is done The coordinator continues to execute and posts stats Crashing inputs in general are allowed The problem arises only if all initial inputs crash The problem in more detail The coordinator maps the initial corpus into memory If no corpus is provided the coordinator creates a default input the empty input Workers then access the corpus over the hub not over the coordinator Before this happens they are given the initial corpus files and are testing them If the Fuzz function crashes on these inputs they will never be passed to the hub Therefore they are not available to the workers after this initial stage The proposed solution After the initial triage stage we wait a short amount of time for synchronization purposes Then we check if the corpus is still empty If it is we conclude that the target crashed on every input and shut down the fuzzer with the respective error message Please comment if the solution lacks in anything cc thepudds mvdan In dvyukov wrote Re CoverTab it always was supposed to be of tunable size Its just that I did fixed K initially as the simplest option and then never had timeneed to improve that This issue is to trackdiscuss this From previous experience changing CoverTab size manually to a different hardcoded value heres the places that need updating Generate code that masks down a highwidth counter at runtime As Dmitry wrote CoverTab LOCATIONHASH GlobalSizeMask For folks who just want to tweak CoverTab manually you can also just change func genCounter in gofuzzbuild to generate different width counters const CoverSize in gofuzzdefs gofuzzcompareamd s assembly implementations for clearing the covertab Probably easiest to just pass in log CoverSize And require that CoverSize be a power of two Look for the BTL instructions The other TODO here is to do a bit of performance tuning with higher values of CoverSize My experience is that cranking up the size of covertab uncovers new performance pain points Ive fixed a few of these but more remain cc thepudds Issue The code of the function times produced by instrumentation is wrong This is the minimal reproducible example File fuzzgo go package fuzz func timesNb byte n int b byten func times b byte timesNb gonoescape func times b byte func Fuzzdata byte int times data times data return File timess go include textflagh TEXT times SB NOSPLIT RET Command sh gofuzzbuild Output sh gofuzzbuild fuzzgo can only use gonoescape with external func implementations Instrumented code wrong go line homeuserbugfuzzgo package fuzz line homeuserbugfuzzgo import gofuzzdep gofuzzdep func timesNb byte n int gofuzzdepCoverTab b byten func times b byte gofuzzdepCoverTab gonoescape line homeuserbugfuzzgo timesNb line homeuserbugfuzzgo func times b byte line homeuserbugfuzzgo func Fuzzdata byte int line homeuserbugfuzzgo gofuzzdepCoverTab times data times data return line homeuserbugfuzzgo var gofuzzdepCoverTab Instrumented code expectedcorrect go line homeuserbugfuzzgo package fuzz line homeuserbugfuzzgo import gofuzzdep gofuzzdep func timesNb byte n int gofuzzdepCoverTab b byten func times b byte gofuzzdepCoverTab line homeuserbugfuzzgo timesNb line homeuserbugfuzzgo gonoescape func times b byte line homeuserbugfuzzgo func Fuzzdata byte int line homeuserbugfuzzgo gofuzzdepCoverTab times data times data return line homeuserbugfuzzgo var gofuzzdepCoverTab If my fuzz function panics it seems to cause cessation of all fuzzing Output starts showing execs sec Not sure if thats the expected behavior or not I was imagining it would log the panic as a crash then keep mutating pineapple has a test case go package pineapple func Fuzzinput byte int panictried to eat a pinecone shell gofuzzbuild gofuzz v worker triages coordinator input minimizedtrue smashedtrue worker triageq execs mininp mincrash triage fuzz versifier smash sonar hint testee panic tried to eat a pinecone goroutine running githubcombookmoonspineappleFuzz x e x x x homeusergosrcgithubcombookmoonspineapplepineapplefuzzgo x gofuzzdepMain xc cf x x tmpgofuzzbuild gorootsrcgofuzzdepmaingo x b mainmain tmpgofuzzbuild gopathsrcgithubcombookmoonspineapplegofuzzmainmaingo x testee worker processes crasher workers corpus s ago crashers restarts execs sec cover uptime s hub corpus bootstrap fuzz minimize versifier smash sonar workers corpus s ago crashers restarts execs sec cover uptime s hub corpus bootstrap fuzz minimize versifier smash sonar workers corpus s ago crashers restarts execs sec cover uptime s hub corpus bootstrap fuzz minimize versifier smash sonar workers corpus s ago crashers restarts execs sec cover uptime s hub corpus bootstrap fuzz minimize versifier smash sonar It never seems to pick back up shell gofuzz workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s workers corpus s ago crashers restarts execs sec cover uptime s When running fuzz tests I very often come across cases where it will run for hours without generating additional cases workers corpus h m ago crashers restarts execs sec cover uptime h m However when restarting it will generate new cases usually within minutes workers corpus m s ago crashers restarts execs sec cover uptime m s workers corpus s ago crashers restarts execs sec cover uptime m s To me no expert this seems like a missed opportunity and I am wondering if it is possible to do this without having to manually restart the process The libFuzzer integration works pretty smooth though the backtrace is much less clear then the equivalent gofuzz vanilla engine Is there a theoretical possibility that libFuzzer will be able to output a better stack trace The integration to libFuzzer imho is important and also can save some time for example implementing same logic again in gofuzz like distributed fuzzing timeouts etc and only focus on the go compilation instrumentation and integration part I didnt deep dive into the gofuzz core source so I dont really know if this idea is possible or makes sense Will be happy to hear feedback EDIT I saw something similar implemented in rust fuzzer using a flag RUSTBACKTRACE though I dont know specifically how they implemented it yet CC dvyukov Itd be nice if we could embed the support packages gofuzzbuild needs into the binary rather than relying on the go tool being able to find them on disk See discussion at and the following few comments added package overlay support to gopackages This is a reminder issue to experiment with whether it would suffice for embedding our support packages and if so to start using it 