Hello It is possible to upgrade the uuid deps to Thanks Describe the bug Errors that occur in a list of items do not have the index in the path To Reproduce Steps to reproduce the behavior Building off the actixweb example I used this as my schemars use juniperFieldResult FieldError use juniperRootNode use juniper use stdcollectionsHashMap pub struct Database pub humans HashMapi String impl juniperContext for Database pub struct Human id String name String juniperobject name Human Context Database impl Human pub fn id self str selfid pub fn name self context Database FieldResultOption str if contexthumanslen if testing selfname Fake Check for permission for the field OkSome selfname else ErrFieldErrornew DENIED graphqlvalue internalerror DENIED else ErrFieldErrornew Could not open connection to the database graphqlvalue internalerror Connection refused pub fn humanscontext Database VecHuman Fake a query to get a friend vec Human id tostring name nottestingtostring deriveGraphQLInputObject graphqldescription A humanoid creature in the Star Wars universe struct NewHuman name String pub struct QueryRoot juniperobject name QueryRoot Context Database impl QueryRoot pub fn humanid String context Database FieldResultVecHuman let humans contexthumansiter filter name id name map name Human id nameclone name nameclone collect Okhumans pub fn countcontext Database i contexthumanslen as i pub struct MutationRoot juniperobject name MutationRoot Context Database impl MutationRoot pub fn humanid String newhuman NewHuman Human unimplemented Human id name Oknewhumanname appearsin newhumanappearsin homeplanet newhumanhomeplanet pub type Schema RootNodestatic QueryRoot MutationRoot pub fn createschema Schema SchemanewQueryRoot MutationRoot and this as my mainrs Actix web juniper example A simple example integrating juniper in actixweb use stdio use stdsyncArc macrouse extern crate juniper use actixwebmiddleware web App Error HttpResponse HttpServer use juniperhttpgraphiqlgraphiqlsource use juniperhttpGraphQLRequest mod schema use crateschemacreateschema Schema Database use stdcollectionsHashMap async fn graphiql HttpResponse let html graphiqlsource HttpResponseOk contenttypetexthtml charsetutf bodyhtml async fn graphql st webDataArcSchema data webJsonGraphQLRequest ResultHttpResponse Error let user webblockmove let mut humans HashMapnew humansinsert Luketostring humansinsert testingtostring let db Database humans let res dataexecute st db Ok serdejsonerrorErrorserdejsontostring res await OkHttpResponseOk contenttypeapplicationjson headerAccessControlAllowOrigin headerAccessControlAllowCredentials true headerAccessControlAllowHeaders contenttype bodyuser async fn handleoptions ResultHttpResponse Error OkHttpResponseOk headerAccessControlAllowOrigin headerAccessControlAllowCredentials true headerAccessControlAllowHeaders contenttype body actixrtmain async fn main ioResult stdenvsetvarRUSTLOG actixwebinfo envloggerinit Create Juniper schema let schema stdsyncArcnewcreateschema Start http server HttpServernewmove Appnew dataschemaclone wrapmiddlewareLoggerdefault servicewebresourcegraphql routewebposttographql routeactixwebRoutenewmethodactixwebhttpMethodOPTIONStohandleoptions servicewebresourcegraphiqlroutewebgettographiql bind start await when going to and running the query humanid Luke id name humans id name I get the result data human id testing name testing humans id name null id Luke name null humans id name null errors message DENIED locations line column path human name extensions internalerror DENIED message DENIED locations line column path human humans name extensions internalerror DENIED message DENIED locations line column path human humans name extensions internalerror DENIED Expected behavior I expected the path value of the error to contain the index of the human that couldnt return its name and as such is null otherwise I dont know exactly which error maps to which place In the graphql documentation for a similar example the error includes an index see Since in my example the query is returning a list of humans that internally have a list of humans it would expect a result like data human id testing name testing humans id name null id Luke name null humans id name null errors message DENIED locations line column path human name extensions internalerror DENIED message DENIED locations line column path human humans name extensions internalerror DENIED message DENIED locations line column path human humans name extensions internalerror DENIED Note the paths now have indexes to indicate which item the error applies to in the path Is your feature request related to a problem Please describe A clear and concise description of what the problem is Ex Im always frustrated when I want to display the integer on enum like rust derivejuniperGraphQLEnum pub enum Gender Man Woman and rust field something executor name String FieldResultSomething OkSomething gender GenderMan when I call it and it will display on gender Adds two workflows based on the Travis and Azure setup I havent looked into the Codecov stuff whether an additional secret is required for the CI workflow or how it could be possible to use the Codecov Action codecov The Book workflows requires a ACTIONDEPLOYKEY secret for deployment to GitHub Pages See peaceirisactionsghpages addsshdeploykey ghpages for the configuration The secretsGITHUBTOKEN token wouldnt trigger a page rebuild I dont know whats wrong with the macOS nightly run related to macOS nightly codecov ghpages Is your feature request related to a problem Please describe No Describe the solution youd like I find the serde macro serderenameall camelCase really useful on a day to day basis I think it would be nice to have the same thing in juniper Describe alternatives youve considered Wiriting graphqlname fieldName on evry single field Additional context serde reference Im not that much an advanced rust user I can try send a PR but Im not very confident with procmacros code This removes the dependencies on ring inside the rocket crate Allowing me to use the jsonwebtoken crate which requires a newer version of ring Adapter Ports x Port juniperrocket Port juniperwarp Port juniperhyper Port juniperiron Port juniperactixweb depends on Is it possible to access Context when defaulting fields for GraphQLInputObjects I dont believe it is I think it would be really useful to support dynamic defaulting of input field values based on the current Context rust struct Context The ID of the user making this request obtained from a JWT currentuser Id rust deriveserdeSerialize juniperGraphQLInputObject struct MessageInput graphqldefault contextcurrentuser author Id body String This could either be combined with the skip attribute from or validated elsewhere to ensure that contextcurrentuser has authorization to set the author of a Message to the provided value Drawbacks Not sure how official this is and would have to be documented in playgroundgraphiql etc Alternatives Making the field an Option and then later mutating itcreating a new struct with the default from the Context I dont like this method because then you have to be careful about exactly when the field will become Some and what sets it Using a different struct and using a custom From like trait to fill it in with the field from Context I need to have a generic context that is instantiated differently in testing The context contains a handler to the DB that is mocked during tests In nontest mode the context contains a handler to the DB and a reference to a read transaction the type that represents the read transaction has an explicit lifetime whose lifetime will therefore correspond to the lifetime of the context Thats why I need to instantiate a different context for each request The problem is that the new macro juniperobject does not seem to allow to declare a context with generics without the generics going back to the Query type and therefore to the Schema I try pub struct Query juniperobject Here we specify the context type for this object Context QueryContextDB BcDbInReadTx impl Query But obviously it doesnt compile It compiles if I pass the generics back to Query but as explained above it is not a possible solution in my case How can we declare a generic to the context only It seems that this was possible with the macro graphqlobject But I didnt try because I dont want to imply time on something depreciated my environment rust juniper Is your feature request related to a problem Please describe This may be a wild breaking change but I found it errorprone for FieldError to implement FromDisplay trait According to the document FieldError now implements FromDisplay trait which can transform anything implementing Display into FieldError This is dangerous with the operator For example I may have something like rust impl Mutation fn somemutationcontext Ctx Resultbool FieldError dothemutation Danger Something else Oktrue fn dothemutation Result SuperSecretError implementation where SuperSecretError implements Display trait and contains some critical information I dont like users to know However when i use the operator in somemutaion function rust will automatically transform SuperSecretError into FieldError and send it to users There WONT be any compile error or warning Such transformation simply relies on format macro As a backend programmer I implement the Display trait for better logging not for web users The leakage of information is counterintuitive Even if theres no critical information leakage such transformation is not what a programmer would expect Describe the solution youd like Remove the FromDispaly trait for FieldError Describe alternatives youve considered Now in my own project I use the trait IntoFieldError and strictly forbid anyone to use the raw FieldError We can document the danger of FieldError Display so people can still take advantage of such transformation while it is encouraged not to do so 