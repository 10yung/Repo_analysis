Im playing around OpenCascade simple wrapper I use one header Geom dLinehxx class Geom dLine inherited from Geom dCurve which contain next method StandardEXPORT virtual StandardBoolean IsPeriodic const in Geom dLine class this method overrides Returns False StandardEXPORT StandardBoolean IsPeriodic const StandardOVERRIDE OS Windows when it converted to C I have property in Geom dCurve public abstract bool IsPeriodic get but in Geom dLine I have these two members summaryReturns Falsesummary public virtual bool IsPeriodic var slot void IntPtr OriginalVTables var IsPeriodicDelegate globalUniCadDelegatesFuncboolIntPtr MarshalGetDelegateForFunctionPointernew IntPtrslot typeofglobalUniCadDelegatesFuncboolIntPtr var ret IsPeriodicDelegateInstance PointerAdjustment return ret and this in same CS class public override bool IsPeriodic get There are two issues We have property and method with same names Property not overrided correctly as a minimum should return IsPeriodic method but issue in this case What should I do in this case can I solve it with custom pass or something Thanks Used headers Geom dLinehxx Used settings Target MSVC Brief Description Invalid generated code for template class Follow up to Used headers cpp template typename T class Abstract public virtual void func class Derived public Abstractint public void func override Used settings GenerateClassOptions true Stack trace or incompilable generated code Generated Encodingscs genEncodingsEncodingscs error CS Unexpected symbol Internal expecting or genEncodingsEncodingscs error CS Unexpected symbol Internal expecting or public unsafe abstract partial class AbstractT IDisposable public globalSystemIntPtr Instance get protected set protected int PointerAdjustment internal static readonly globalSystemCollectionsConcurrentConcurrentDictionaryIntPtr globalEncodingsAbstractT NativeToManagedMap new globalSystemCollectionsConcurrentConcurrentDictionaryIntPtr globalEncodingsAbstractT protected internal void OriginalVTables protected bool ownsNativeInstance internal static globalEncodingsAbstractT CreateInstanceglobalSystemIntPtr native bool skipVTables false return new globalEncodingsAbstractTInternalnativeToPointer skipVTables internal static globalEncodingsAbstractT CreateInstanceglobalEncodingsAbstractInternal native bool skipVTables false return new globalEncodingsAbstractTInternalnative skipVTables This invalid code globalEncodingsAbstractTInternal Brief Description Cppsharp generates the classes from cpp code as public Is there some way to generate it as internal OS Windows OS X Linux include version andor distro Used headers Used settings Target MSVCGCCClang Other settings Stack trace or incompilable generated code Brief Description Hi When using the CppSharp libs through NuGet looking at the assemblies files properties it appears that the version is always set as Any good reason for that behaviour Also is there an available build pipeline that someone can use to create a test releaseartifact of CppSharp when making changes rather than building it locally Thanks This keeps the original functions instead of ignoring them which helps when rearranging passes in particular when the pass for symbols is involved Brief Description Previously I had been using CppSharp After upgrading to I noticed this bug This is the diff in generation after updating diff public static string UUIDToCharglobalSystemGuid uid char str ulong len var arg iFaceRecFixGuiduid var arg sbyte str var arg sbyte str var ret InternalUUIDToChararg arg len return ret Original function prototype is C extern const char ifrUUIDToCharIFRUUID uid char str sizet len I also apply a rename to IFRUUID with a FixGUID which I dont think is relevant here because this affects the char If you need info about the IFRUUID type please mention this OS Windows Used headers stringh Used settings Target MSVC Hi Im facing a similar issue as I have a template class and am trying to generate a CCLI equivalent So far nothing is generated for such classes Does this support exist yet or not If not what recommended approaches are there to generate CCLI wrappers for template classes Thanks Brief Description Please refer to this repo for a reproducible example If you build and run the app youll get the issue faced I have a simple class with one constructor that takes a LPCSTR typedef for const char param and has a member of the same type The member generation is fine however the constructor generation is incorrect The constructor is imported as internal static extern globalSystemIntPtr ctorglobalSystemIntPtr instance globalSystemIntPtr lpsz With the generated C equivalent looking like public Consumerstring lpsz Instance MarshalAllocHGlobalsizeofglobalCppSharpTestNativedllConsumerInternal ownsNativeInstance true NativeToManagedMap Instance this InternalctorInstance PointerAdjustment lpsz The last line is failing because the imported signature is expecting an IntPtr but the generated class is using a SystemString Is there a way to generate the import signature with the correct type or modify the generated code to correctly convert to and from LPCSTR The LPCSTR member is generated fine with the correct marshaling public string MLpsz get return MarshalPtrToStringAnsiglobalCppSharpTestNativedllConsumerInternal Instancemlpsz set globalCppSharpTestNativedllConsumerInternalInstancemlpsz globalSystemIntPtr MarshalStringToHGlobalAnsivalue The constructor however is not Thanks OS Windows Target MSVC Hi Is it possible to customize the genertation of the DllImport lines For example rather than SuppressUnmanagedCodeSecurity DllImportGenerated CallingConvention globalSystemRuntimeInteropServicesCallingConventionCdecl EntryPointentry point internal static extern int GetValueForExternalNameglobalSystemIntPtr name I wish to have SuppressUnmanagedCodeSecurity DllImportGenerated CallingConvention globalSystemRuntimeInteropServicesCallingConventionCdecl EntryPointentry point internal static extern int GetValueForExternalName MarshalAsUnmanagedTypeLPStr string name Notice that the desired parameter is MarshalAsUnmanagedTypeLPStr string name rather than globalSystemIntPtr name Similarly I wish to modify the declared return type For example rather than SuppressUnmanagedCodeSecurity DllImportGenerated CallingConvention globalSystemRuntimeInteropServicesCallingConventionCdecl EntryPointentry point internal static extern void GetCodeglobalSystemIntPtr instance globalSystemIntPtr return I wish to have SuppressUnmanagedCodeSecurity DllImportGenerated CallingConvention globalSystemRuntimeInteropServicesCallingConventionCdecl EntryPointentry point return MarshalAsUnmanagedTypeBStr internal static extern string GetCodeglobalSystemIntPtr instance Again instead of an out IntPtr the return is marshaled as SystemString Thanks