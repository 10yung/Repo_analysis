ZboxFS seems to think in terms of transactions There are transactionrelated error cases in zboxError there are limitations based on transactions eg inability to write multiple files in parallel but there is few things about transaction available in API If transactions are repositorywide not filescoped I suggest to add something like fn ongoingtransaction self OptionTransactionInfo in zboxRepo which should tell if a transaction is ongoing Additional information like number of uncommitted bytes affected file or datetime may be provided in TransactionInfo Example code is from issue about ENOSPC behaviour Run cargo run that example code multiple times interrupting it with CltrC Eventually it starts failing vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest C vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest C vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest C vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest C vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest C vl tmpzboxtest RUSTBACKTRACE cargo run Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest thread main panicked at assertion failed secisfinished homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragefilesectorrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingbeginpanic at rustc eeb d f fbae bb c d b abeaf da f srclibstdpanickingrs zboxvolumestoragefilesectorSectorMgrwriteblocks at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragefilesectorrs zboxvolumestoragefilefileFileStorage as zboxvolumestorageStorableputblocks at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragefilefilers zboxvolumestoragestorageWriterwriteframe at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragestoragers zboxvolumestoragestorageWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragestoragers zboxvolumevolumeWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumevolumers stdioWritewriteall at rustc eeb d f fbae bb c d b abeaf da f srclibstdiomodrs zboxcontentsegmentWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srccontentsegmentrs zboxcontentcontentWriterappendchunk at homevicargoregistrysrcgithubcom ecc db ec zbox srccontentcontentrs zboxcontentcontentWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srccontentcontentrs zboxcontentchunkerChunkerW as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srccontentchunkerrs zboxcontentstoreWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srccontentstorers zboxfsfnodeWriter as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcfsfnoders zboxfileFile as stdioWritewriteclosure at homevicargoregistrysrcgithubcom ecc db ec zbox srcfilers zboxtranstxmgrTxHandlerun at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxfileFile as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcfilers zboxtestmain at srcmainrs If needed I can attach a storage dump with the repro T Z DEBUG zboxtranstxmgr run tx failed IoCustom kind Other error Not in transaction T Z DEBUG zboxtranstxmgr abort tx T Z DEBUG zboxtranstxmgr tx aborted T Z ERROR zboxmountzboxfuse IO error Not in transaction stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs corepanickingpanic at srclibcorepanickingrs coreoptionOptionTunwrap at rustc eeb d f fbae bb c d b abeaf da f srclibcoremacrosmodrs zboxtranstxmgrTxMgraborttrans at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxtranstxmgrTxHandleabort at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxtranstxmgrTxHandlerun at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxfileFile as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcfilers Steps to reproduce Mount tmpfs with a size limit Create ZboxFS file storage on that size Create a zboxFile there and start filling it with data without finishing ad infinum Expected Eventually stdioWritewrite returns IO error suggesting that allowed storage space is exhaused Ideally the file may be finished at that point with the data previously accepted by stdioWritewrite without error being guaranteed to fit on remaining space Actual T Z DEBUG fusemtfusemt getxattr file securitycapability T Z DEBUG fusemtfusemt getxattr error T Z DEBUG fuserequest WRITE ino x fh offset size flags x T Z DEBUG fusemtfusemt write file x x b T Z DEBUG fuserequest GETXATTR ino x name securitycapability size T Z DEBUG fusemtfusemt getxattr file securitycapability T Z DEBUG fusemtfusemt getxattr error T Z DEBUG fuserequest WRITE ino x fh offset size flags x T Z DEBUG fusemtfusemt write file x x b a T Z DEBUG zboxtranstxmgr run tx failed IoCustom kind Other error other os error T Z DEBUG zboxtranstxmgr abort tx T Z WARN zboxtranstxmgr abort tx failed No space left on device os error T Z ERROR zboxmountzboxfuse IO error other os error T Z WARN fuserequest Ignoring unknown FUSE operation T Z DEBUG fuserequest GETXATTR ino x name securitycapability size T Z DEBUG fusemtfusemt getxattr file securitycapability T Z DEBUG fusemtfusemt getxattr error T Z DEBUG fuserequest WRITE ino x fh offset size flags x T Z DEBUG fusemtfusemt write file x x b a T Z DEBUG zboxtranstxmgr run tx failed IoCustom kind Other error other os error T Z DEBUG zboxtranstxmgr abort tx thread main panicked at called Optionunwrap on a None value rustc eeb d f fbae bb c d b abeaf da f srclibcoremacrosmodrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs corepanickingpanic at srclibcorepanickingrs coreoptionOptionTunwrap at rustc eeb d f fbae bb c d b abeaf da f srclibcoremacrosmodrs zboxtranstxmgrTxMgraborttrans at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxtranstxmgrTxHandleabort at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxtranstxmgrTxHandlerun at homevicargoregistrysrcgithubcom ecc db ec zbox srctranstxmgrrs zboxfileFile as stdioWritewrite at homevicargoregistrysrcgithubcom ecc db ec zbox srcfilers Additionally storage cannot be opened again after that T Z INFO zboxbase ZboxFS v Zerodetails privacyfocused inapp file system T Z INFO zboxfsfs open repo filetmplimitq readonly false T Z DEBUG zboxvolumevolume volume opened StorageFileStorage base tmplimitq T Z DEBUG zboxtranswal cold redo abort tx T Z DEBUG zboxtranswal cold abort completed T Z DEBUG zboxtranswal WalQueue opened seq watermarks txid block Error IoCustom kind Other error Decrypt error Example file store Password sad Only about megabytes of of test is read then it returns IO error File not found Issue is reproducible when using fstest or maybe other similar filesystem stresstest tool on zboxmount Also reproducible with mem storage Only text description is copied into stdioError not the actual matchable zboxError grep Cargotoml srcmainrs Cargotoml package Cargotomlname zboxtest Cargotomlversion Cargotomlauthors Vitaly Vi Shukela vi ossgmailcom Cargotomledition Cargotoml Cargotoml dependencies Cargotomlzbox srcmainrsfn main srcmainrs let mut ro zboxRepoOpenernew srcmainrs rocreatetrue srcmainrs let roopenmem unwrap srcmainrs cargo stable run Compiling zboxtest v tmpzboxtest Finished dev unoptimized debuginfo targets in s Running targetdebugzboxtest Aborted rustgdb targetdebugzboxtest Reading symbols from targetdebugzboxtestdone gdb set pagination off gdb r Starting program tmpzboxtesttargetdebugzboxtest Thread debugging using libthreaddb enabled Using host libthreaddb library libx linuxgnulibthreaddbso Program received signal SIGABRT Aborted GIraise sigsigentry at sysdepsunixsysvlinuxraisec sysdepsunixsysvlinuxraisec No such file or directory gdb bt GIraise sigsigentry at sysdepsunixsysvlinuxraisec x ffff d in GIabort at abortc x ffff f baa in from usrlibx linuxgnulibsodiumso x ffff f f d in sodiummalloc from usrlibx linuxgnulibsodiumso x a in zboxbasecryptoSafeBoxTnewempty at homevicargoregistrysrcgithubcom ecc db ec zbox srcbasecryptors x c d in zboxvolumestoragestorageStoragenew uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragestoragers x ccc in zboxvolumevolumeVolumenew uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumevolumers x in zboxfsfsFsexists uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcfsfsrs x d b in zboxrepoRepoexists uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcrepors x d in zboxrepoRepoOpeneropen self x fffffffde uri pwd at homevicargoregistrysrcgithubcom ecc db ec zbox srcrepors x c a in zboxtestmain at srcmainrs gdb bt full GIraise sigsigentry at sysdepsunixsysvlinuxraisec set val pid optimized out tid optimized out ret optimized out x ffff d in GIabort at abortc savestage act sigactionhandler sahandler x bb sasigaction x bb samask val saflags sarestorer x sigs val repeats times x ffff f baa in from usrlibx linuxgnulibsodiumso No symbol table info available x ffff f f d in sodiummalloc from usrlibx linuxgnulibsodiumso No symbol table info available x a in zboxbasecryptoSafeBoxTnewempty at homevicargoregistrysrcgithubcom ecc db ec zbox srcbasecryptors size x c d in zboxvolumestoragestorageStoragenew uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumestoragestoragers framecache zboxbaselruLruusize allocvecVecu zboxvolumestoragestorageFrameCacheMeter zboxbaselruPinCheckerallocvecVecu capacity used map linkedhashmapLinkedHashMapusize allocvecVecu stdcollectionshashmapRandomState map stdcollectionshashmapHashMaplinkedhashmapKeyRefusize mut linkedhashmapNodeusize allocvecVecu stdcollectionshashmapRandomState base hashbrownmapHashMaplinkedhashmapKeyRefusize mut linkedhashmapNodeusize allocvecVecu stdcollectionshashmapRandomState hashbuilder stdcollectionshashmapRandomState k k table hashbrownrawRawTablelinkedhashmapKeyRefusize mut linkedhashmapNodeusize allocvecVecu bucketmask ctrl coreptrnonnullNonNullu pointer x b repeats times data coreptrnonnullNonNulllinkedhashmapKeyRefusize mut linkedhashmapNodeusize allocvecVecu pointer x growthleft items marker coremarkerPhantomDatalinkedhashmapKeyRefusize mut linkedhashmapNodeusize allocvecVecu head x free x meter zboxvolumestoragestorageFrameCacheMeter pinckr zboxbaselruPinCheckerallocvecVecu marker coremarkerPhantomDataallocvecVecu depot zboxvolumestorageBoxStorable pointer x ba UUU vtable x x ccc in zboxvolumevolumeVolumenew uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcvolumevolumers info zboxvolumevolumeInfo id zboxtranseidEid repeats times ver zboxbaseversionVersion major minor patch uri mem compress false cost zboxbasecryptoCost opslimit zboxbasecryptoOpsLimitInteractive memlimit zboxbasecryptoMemLimitInteractive cipher zboxbasecryptoCipherXchacha ctime zboxbasetimeTime coretimeDuration secs nanos x in zboxfsfsFsexists uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcfsfsrs No locals x d b in zboxrepoRepoexists uri at homevicargoregistrysrcgithubcom ecc db ec zbox srcrepors No locals x d in zboxrepoRepoOpeneropen self x fffffffde uri pwd at homevicargoregistrysrcgithubcom ecc db ec zbox srcrepors No locals x c a in zboxtestmain at srcmainrs ro zboxrepoRepoOpener cfg zboxfsConfig cost zboxbasecryptoCost opslimit zboxbasecryptoOpsLimitInteractive memlimit zboxbasecryptoMemLimitInteractive cipher zboxbasecryptoCipherXchacha compress false opts zboxfsOptions versionlimit dedupchunk false create true createnew false readonly false force false rustc stable version rustc ea apt policy libsodium libsodium Installed If underlying files of zbox file storage are modified by an attacker what worst can happen I expect only selective attackerchosen data loss never executed malicious code or injected malicious data when I try to use that storage If storage continues to work after tampering I expect newly added data to be as secure as original data Does it all hold true IMO CLI utilities are needed to accelerate adoption Also FUSE support will be very useful for users that want to use zbox as their personal cloud storage It seems like zbox does not currently allow for any multithreaded concurrency at all Sadly this limits usage to very simple use cases Are there plans for introducing concurrency A simple first step could be to allow concurrent reads with a global write lock Although Id really love to have concurrent reads and writes as well