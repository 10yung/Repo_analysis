My library uses a global Client to run its requests The following code rust cfgtest mod tests use hyper clientClient HttpConnector Body Request lazystaticlazystatic static ref CLIENT ClientHttpConnector Body Clientnew async fn requri str CLIENT requestRequestbuilderuriuribodyBodyfromunwrap await unwrap macrorules tests nameident tokiotest async fn name req testst t t t t t t t t t With tokio hyper and lazystatic generates tests t t with each one making a simple request using a global client Every cargo test a random number of them panic with this backtrace This has been reported before but was closed by the author The error seems to be that I am using the same Client from different runtimes on different threads use tokionetUnixListener let path roottestsock if let Errerr fsremovefilepath if errkind ioErrorKindNotFound eprintln let unixlistener UnixListenerbindpathunwrap let acceptor hyperserveracceptfromstreamunixlistenerincoming For every connection we must make a Service to handle all incoming HTTP requests on said connection let makesvc makeservicefnconn async Ok Infallibleservicefnhello let serveri Serverbuilderacceptor let server serveriservemakesvc serverawait Ok let acceptor hyperserveracceptfromstreamunixlistenerincoming the trait futuresStream is not implemented for futureexfutureextokionetunixIncoming Originally posted by IThawk in see It was a long time ago one had to write std to make rustc recognize the path Now just std works fine Had some issues getting the examples to run as there was no clear Cargotoml for referencing the correct dependancies and versions etc Heres what worked for me could we add it to the examples folder or the README cat Cargotoml dependencies hyper tokio version features full prettyenvlogger Theres a blanket implementation of towerserviceService for mut S but not for S Since hyperClientrequest takes self only Client can implement Service allowing users to take advantage of Towers abstraction without additional ownership restrictions featclient Chunk method to detect if it is the final part of real httpchunk or not During chunked transfer hyper can return only part of httpchunk and it does not provide ability to detect if it is just part of the chunk or not The solution could be to fill chunks in the buffer until you know that you read full size of the httpchunklen This PR adds Chunkisendofchunk self bool method which return true if you read httpchunklen rust let mut buf Vecnew bodyforeachmove chunk let isfinal chunkisendofchunk bufextendfromslice chunkintobytes if isfinal return Ok printlnbuf contains valid json bufclear Introduced in the HTTP UpgradeCONNECT API currently is accessed via hyperBodyonupgrade This has some downsides that Id like to address with a modified API It makes the Body type fatter It requires people keep the Body around meaning they cant use stream combinators to read the body first and then wait for the upgrade to finish This also makes it more annoying for users who may wish adjust their httpRequestBody into some httpRequestDoodad Proposed API Similar to the proposal in the change would be to pass the httpRequest or httpResponse to a free function hyperupgradeonreqorresp OnUpgrade We can also allow passing just a mutable reference thus not consuming the request or response Optional other functions could be added but not necessary hasupgrade etc Implementation Plan The types would be inserted into the httpExtensions of the requestresponse though with a private wrapper type to hide the exact details Add the new hyperupgradeon function The Bodyonupgrade method would become deprecated So as to not be a behavioral breaking change the OnUpgrade would need to be placed in both the Body and the Extensions wrapped in some ArcLock that only allows taking it once Id like to in a future release be able to not put it in an ArcLock and place it in the Body but Im not sure how that could really be done in x I knew Id find something I forgot to change after finally releasing XD Im trying to work with an API on an internal server and hyper keeps blowing away the connection due to invalid HTTP header parsed There doesnt appear to be a specific error provided however which has so far made it impossible to troubleshoot Ive enabled RUSTLOGtrace and even tried switching off certificate and domain name checks and gzip is there any way to get it to work or at least figure out what hyper thinks is wrong with the header Both curl and Postman appear to work fine and testssl doesnt reveal any glaring issues Thanks