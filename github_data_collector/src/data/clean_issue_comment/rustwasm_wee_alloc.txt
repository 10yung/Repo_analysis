 Describe the Bug weealloc is supposedly useful for embedded devices but I tried it over the weekend and of the total amount of memory of KiB weealloc is only able to allocate KiB in its default configuration Something seems to be off here Steps to Reproduce Use the static array backend Configure KiB of memory Do a few allocations in the range bytes like in the image provided weealloc should run out of memory very early Expected Behavior It should be able to use at least KiB or so Actual Behavior It can only allocate KiB As mentioned in but for tracking separately sizeclasses is enabled by default so one of the lines had to remain cargo check release but another is supposed to be cargo check release nodefaultfeatures to test without sizeclasses enabled Hmm looks like there is a bunch of other places in buildsh checksh appveyoryml that use features sizeclasses fitzgen Does this mean they are all similarly broken testing same configuration as default or am I missing some switch Summary Compiling a testapp with different settings dlmalloc and weealloc the resulting binary sizes of weealloc builds are not as small as expected Benefit is just KB the relation is KB for dlmallocbuilds compared to KB for weeallocbuilds with code using simple Stringallocation see With an application without any dynamic memory allocation weealloc is adding bytes wasmgameoflifedlmallocpkgwasmgameoflifebgwasm wasmgameoflifeweeallocpkgwasmgameoflifebgwasm With an application using simple String allocation weealloc is adding ca bytes being just KB better than dlmalloc wasmgameoflifedlmallocdynpkgwasmgameoflifebgwasm wasmgameoflifeweeallocdynpkgwasmgameoflifebgwasm Steps to Reproduce git clone cd wasmdynmemrustbindgen make build printsizes Expected Results Linking against weealloc instead of dlmalloc I expected binaries being much more smaller and gaining larger benefit compared to dlmallic Just in some cases the binary is larger and the relation is just KB vs KB Maybe weealloc is using some codepatterns that can not be optimized as good as expected dependabotstart Dependabot is rebasing this PR If you make any changes to it yourself then they will take precedence over the rebase dependabotend Updates the requirements on quickcheck to permit the latest version details summaryCommitssummary See full diff in compare view details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase If all status checks pass Dependabot will automatically merge this pull request details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot merge will merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Automerge options neverpatchminor and devruntime dependencies Pull request limits per update run andor open at any time Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired Finally you can contact us by mentioning dependabot details dependabotstart Dependabot is rebasing this PR If you make any changes to it yourself then they will take precedence over the rebase dependabotend Updates the requirements on rand to permit the latest version details summaryCommitssummary See full diff in compare view details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase If all status checks pass Dependabot will automatically merge this pull request details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot merge will merge this PR after your CI passes on it dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Automerge options neverpatchminor and devruntime dependencies Pull request limits per update run andor open at any time Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired Finally you can contact us by mentioning dependabot details Summary I need an advice how properly implement runtime initialized storage Motivation Now I use ugly hack to make weealloc work with my unikernel wrapper around solo In compile time i dont know anything about available heap address and size I only can get it in runtime from specific structure So I add impptrarray with specific allocpages implementation and call something like fn initstart usize size usize but thats very bad thing usable only for initial testing As i can see I need some trait or function which can change internal state of allocpages implementation How does this further weeallocs goal of being the best allocator for wasm unknownunknown with a very small wasm code size footprint It doesnt make weealloc any bigger in wasm code size but makes it more usable as general purpose nostd allocator Details What bits of code would need to change Which modules As I see it will be additional specific implementation similar to staticarray without significant impact on other parts What are the trade offs Additional trait to be implemented on WeeAlloc structure Are you willing to implement this yourself If you had a mentor Are you willing to mentor someone else Im ready to implement it Summary Investigate rounding up allocations to at least two words and making the free list doubly linked Motivation This could simplify code maybe shrink code size and lessen fragmentation Details We could remove deferred consolidation of cells Simplifying code and hopefully also shrinking code size We could always consolidate a free cell with both of its neighbors if they are also free Right now we can only do one or the other because the free list is singly linked and doesnt afford these kinds of manipulations in O time Downside is that heap allocations of size words get rounded up I think this is probably an OK choice We would make FreeCell have another link prevfreeraw that is the previous free list pointer Anywhere we insert into or remove from the free list we would need to make sure that the new link is kept valid Happy to mentor anyone who wants to try their hand at this FEATURE REQUESTS Summary Emit statistics visualizations of heap fragmentation There are edge cases where we cant currently consolidate adjacent free cells into a larger contiguous free cell This would let us empirically answer whether that is a problem in practice Motivation Remove unknown unknowns Be a better allocator Details Maybe use graphviz At least get some statistics aggregated numbers on free vs allocated and distribution of free cell sizes in the free list This would be a nice smoke test FEATURE REQUESTS Summary Add a C API crate that wraps weealloc and provides posix malloc and free Motivation C and C projects targeting wasm could benefit from weealloc too and more users more bug reports and reliability work and all that good stuff Details New crate at the top level of the repo depending on weealloc Wraps a weealloc global allocator and exposes malloc and free and I think realloc is part of the posix spec too