Other tokio crates have been using this eg tokiothreadpool Is this library still being maintained Please upgrade the version of smallvec and release the latest tokioproto The old version of this library was checked for security holes cargo audit Fetching advisories Scanning crates for vulnerabilities advisories in database Warning Vulnerable crates found ID RUSTSEC Crate smallvec Version Date URL Title Possible double free during unwinding in SmallVecinsertmany Solution upgrade to ID RUSTSEC Crate smallvec Version Date URL Title Possible double free during unwinding in SmallVecinsertmany Solution upgrade to error vulnerabilities found relate Writing a library that depends on tokio cannot use tokioprotoTcpClient of course note expected type tokiocorereactorHandle found type tokioreactorHandle Updating the dependency would solve that problem but its a breaking change isnt it Signedoffby Igor Gnatenko ignatenkobraingmailcom As a library author Id love to get some more clarity about the future of tokioproto Within the tokioreform I can read the following So in general the future direction for tokioproto is unclear This is not a good foundation for tokiolibrary developers is it We need to be driven by strong concrete usecases What exactly do you mean by strong If you have one of these wed love to hear about it It might not the most popular use case but nevertheless it is one of many tokiomodbus I recently added a server implementation based on tokioprotoTcpServer It kind of works but I dont see that this is the best solution Eg there is no way to configure the TcpStream timeouts etc I love to spend a lot of time to improve the tokio project and the rust ecosystem in general And to do so clarity would help a lot I really would like to get some feedback on how I should behave Update smallvec to a current release Fixed BoxFuturerelated warnings Dependency updates futures log smallvec tokiocore I implemented the code from the echo server example pasted below for your convenience Throughput decreases dramatically as the number of requests lines the request type for Echo as Service because of the LineCodec submitted increases Number of requests Requestssecond The server process is spinning at CPU while doing this Benchmark sh yesdd bs count MBnc localhost dd bs pv i devnull You have to divide the bytess by two to get requestss since each request line is bytes You can also wait for the command to finish and divide the time reported by the second dd instance by the count number This was previously filed as Code rust dependencies bytes futures tokioio tokiocore tokioproto tokioservice extern crate bytes extern crate futures extern crate tokioio extern crate tokioproto extern crate tokioservice use stdio use stdstr use bytesBytesMut use futuresfuture Future BoxFuture use tokioioAsyncRead AsyncWrite use tokioiocodecEncoder Decoder Framed use tokioprotopipelineServerProto use tokioprotoTcpServer use tokioserviceService pub struct LineCodec impl Decoder for LineCodec type Item String type Error ioError fn decode mut self buf mut BytesMut ioResultOptionString if let Somei bufiterposition b b b n remove the serialized frame from the buffer let line bufsplittoi Also remove the n bufsplitto Turn this data into a UTF string and return it in a Frame match strfromutf line Oks OkSomestostring Err ErrioErrornewioErrorKindOther invalid UTF else OkNone impl Encoder for LineCodec type Item String type Error ioError fn encode mut self msg String buf mut BytesMut ioResult bufextendmsgasbytes bufextendb n Ok pub struct LineProto implT AsyncRead AsyncWrite static ServerProtoT for LineProto For this protocol style Request matches the Item type of the codecs Decoder type Request String For this protocol style Response matches the Item type of the codecs Encoder type Response String A bit of boilerplate to hook in the codec type Transport FramedT LineCodec type BindTransport ResultSelfTransport ioError fn bindtransport self io T SelfBindTransport OkioframedLineCodec pub struct Echo impl Service for Echo These types must match the corresponding protocol types type Request String type Response String For nonstreaming protocols service errors are always ioError type Error ioError The future for computing the response box it for simplicity type Future BoxFutureSelfResponse SelfError Produce a future for computing a response from a request fn call self req SelfRequest SelfFuture In this case the response is immediate futureokreqboxed fn main Specify the localhost address let addr parseunwrap The builder requires a protocol and an address let server TcpServernewLineProto addr We provide a way to instantiate the service for each new connection here we just immediately return a new instance serverserve OkEcho 