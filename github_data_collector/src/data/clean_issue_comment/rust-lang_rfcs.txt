Rust gives we programmers strong safetythanks for Rust team but also gives us freedom to write some code maybe unsafe with keyword unsafe But as should be known to all Rust programmers it doesnt mean the code be tagged as unsafe is exactly unsafe as long as we know what we are doing no undefined behavior For example maybe crazy about the classic panic issue giving a value to a vector with index that is out of range Does it should be recognized as unsafe all the time Generally yes it is unsafe But what if as a reverse engineering I know exactly what the data in heap is and for some purpose I want to give a value exactly behind the safe bound of the vector Here what I want to point out is that I agree with what Rust team think about what Rust should be But following the road I think maybe the keyword unsafe is too subjective maybe a word more objective is better like say caution Though in my own style I would prefer but to follow Rust philosophy a more complex word may be better to caution us and try best to avoid it Ok I have to admit that the reason for this suggestion is due to the recent Actix issue I dont want to someone who would be pissed off by just not quite knowing about the keyword unsafe but not exactly unsafety A redesigned asm macro with a path to stabilization Rendered Thanks to everyone involved in the inline asm project group for their feedback which helped make this RFC possible From closed as needing an RFC It would be nice for RangeIdx Copy to implement Copy I want to store a Range in a struct but that prevents me from making the struct Copy I can make a start end struct that wraps it but that seems a little silly With Range from the standard library playground rust use coreopsRange error E the trait Copy may not be implemented for this type deriveCopy struct HasRange r Rangeusize otherfield usize works fine struct HasRangeWrapper r RangeWrapper otherfield usize deriveCopy Clone pub struct RangeWrapper start usize end usize Note that Range is isomorphic to RangeWrapper you can convert freely between the two impl FromRangeusize for RangeWrapper fn fromrange Rangeusize Self Self start rangestart end rangeend impl FromRangeWrapper for Rangeusize fn fromrange RangeWrapper Self Self start rangestart end rangeend There is more discussion of pros and cons in the rustlangrust issue Assuming that the elements within a LinkedList never move in memory which is normally the case iterating over the list could return Pin T or Pin mut T rather than plain T or mut T framedpicture Rendered PreRFC thread memo Summary Change item resolution for generics and trait objects so that a trait bound does not bring its supertraits items into scope if the subtrait defines an item with this name itself This makes it possible to write the following which is currently rejected by the compiler due to ambiguity rust trait Super fn foo self trait Sub Super fn foo self fn genericfnS Subx S xfoo Sometimes we want do divide an integer by another integer and round up the result to next integer For example we might want to know how many write operations of a specific size are required to fully write a file of a specific size Regular integer division in such scenarios will result in a value that is below the desired result for all operations that involve a remainder and correct for those that dont There are typically three methods used to calculate such a value cast to a floating point and subsequently round up do the integer division then check if the modulo produces a remainder and add one in that case and finally dividend divisor divisor The final method while being efficient is not the most readable Not only can it get very long if we use long and descriptive variable names like datafilesize maxwritelength maxwritelength but its not quite so obvious what we are doing For this reason I suggest adding the operator so the same operation can be written as such datafilesize maxwritelength or dividend divisor Although such operations almost always only make sense for positive integers One might consider also adding additional operators and to deal with situations where it is known before hand that respectively the dividend divisor or both are negative to avoid unnecessary calls to the absolute value function This is the first RFC from the inline asm project group Rendered Rendered Add the ability to export symbols from executables not just dylibs via a new compiler flag C exportexecutablesymbols Bonus Ive also implemented and used this flag as a proofofconcept to make sure I am indeed solving my problems with this suggestion but Im happy to rewrite or discard that if another approach seems better For example several of the iterator types in my crate StaticVec could pretty trivially provide correct implementations of it and Id absolutely add them immediately if it were possible Rendered 