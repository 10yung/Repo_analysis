Story so far homerhodgesgithubboostorgboostlibsbeastcmakebuilddebugtestbeastcoretestsbeastcore beastcoreasyncbase beastcorebase beastcorebasicstream beastcorebindhandler beastcorebuffer beastcorebuffertraits beastcorebufferedreadstream beastcorebuffersadaptor beastcorebufferscat beastcorebuffersprefix beastcorebuffersrange beastcorebufferssuffix beastcorebufferstostring beastcoreclamp beastcoredetectssl beastcoreerror beastcorefileposix beastcorefilestdio beastcoreflatbuffer beastcoreflatstaticbuffer beastcoreflatstream beastcoregetiocontext beastcoremakeprintable beastcoremultibuffer beastcoreostream beastcoreratepolicy beastcoreread beastcorereadsize beastcoresavedhandler beastcoresha beastcorespan beastcorestaticbuffer beastcorestaticstring beastcorestreamtraits beastcorestringparam beastcoretcpstream beastcoretuple beastcorevariant beastcorevarint ms suites cases tests total failures Version of Beast Steps necessary to reproduce the problem Create a lightweight proxy to hold a reference to a boostasiodynamicstringbuffer compiled with the following preprocessor symbol defined BOOSTASIONODYNAMICBUFFERV All relevant compiler information gcc fedora To reproduce stdstring store auto dynbuf boostasiodynamicbufferstore auto os boostbeastostreamLightWeightProxydynbuf os foo Outcome std library throws an exception followed by segfault Investigation beastostream creates a specialisation of beastdetailostreamhelper which in turn references a beastdetailostreambuffer beastdetailostreambuffer is derived from stdostream and overrides member functions overflow and sync The problem is that when handling the first character overflow is called which calls sync sync then calls commit on the underlying buffer However contrary to the requirements of asio v dynamic buffers prepare has not yet been called at this stage Beasts dynamic buffers are resilient to this incorrect code sequence but asios V dynamic string buffer is not Solution Add a call to bprepare in the constructor of beastdetailostreambuffer Even though conceptually this is a noop it serves to satisfy the precondition of calling bcommit The internal state of asiodynamicstringbuffer is subtly modified even though the no difference is observed by calls to the size member function by user code Hello I am exploring desing options with the client system I am building and because it is not possible to have multiple httpasyncwrites with beast on the same http stream at this moment I am queuing my writes However it might turn out that I will not need to explicitly process inbound responses in http stream with beast which also includes parsing http response header and instead I might just get away with pulling in data from http stream and even discarding it in case of OK I tried boostasioasyncread on http stream and either it reads only some of the inbound data or it fails depending on invocation I my naivety I expected this to just read whatever data the server sent in the response I also tried asioasyncreaduntil but I dont seem to make it work at all One detail I was trying to do the above with flatstaticbuffer I was hoping maybe you have some advice on what is the best approach if one just needs to drain inbound http stream to collect unparsed response data to either discard it or to apply some limited inspection Thank you This would enable convenient looping like for auto const name value fields See spec and example Hello everyone Id like to implement an asynchronous HTTP client with KeepAlive feature using BoostBeast My idea is to create Client object resolve and connect to the host and then send getpostdelete requests asynchronously iocontext will be working because of iocontextwork object But I have a question about how does it works on lower layer Say I have two requests Req time to handle on the server is seconds Req time to handle on the server is seconds and Im doing two requests immediately clientGetReq clientGetReq Note that I suppose to have one connected socket into the client object and use KeepAlive mechanism and I have the one certain thread running iocontextrun Is it guaranteed that the sequence of async calls for Req will be totally completed before the sequence of async calls for Req will be started Otherwise I risk to get response for Req earlier than response for Req Not entirely sure how does it work Ubuntu GCC Boost I have taken your sample and built it against boost with gcc According to boost documentation I believe this should compile but I am receiving an error The sample I am using is Thoughts on why it doesnt compile Thanks in advance In file included from extlinuxx releaseincludeboost boostbeastwebsockethpp from extlinuxx releaseincludeboost boostbeasthpp from miscbeastsocketcommonincludebeastcommonbeasth from miscbeastsocketserverincludebeastserverwebsocketsessionh from homereposmiscbeastsocketserversourcewebsocketsessioncpp extlinuxx releaseincludeboost boostbeastwebsocketstreamhpp In instantiation of class boostbeastwebsocketstreamboostbeastbasicstreamboostasioiptcp boostasioexecutor boostbeastunlimitedratepolicy miscbeastsocketserverincludebeastserverwebsocketsessionh required from here extlinuxx releaseincludeboost boostbeastwebsocketstreamhpp internal compiler error in tsubst at cpptc asynchandshake x ed c tsubsttreenode treenode int treenode gcc gcccpptc x f tsubsttemplateargs gcc gcccpptc x ebf b tsubsttreenode treenode int treenode gcc gcccpptc x ec b tsubsttreenode treenode int treenode gcc gcccpptc x f tsubsttemplateargs gcc gcccpptc x ebf b tsubsttreenode treenode int treenode gcc gcccpptc x ec d tsubsttreenode treenode int treenode gcc gcccpptc x ed tsubsttemplateparm gcc gcccpptc x ed tsubsttemplateparms gcc gcccpptc x f tsubstdecl gcc gcccpptc x ec af tsubsttreenode treenode int treenode gcc gcccpptc x fddd instantiateclasstemplate gcc gcccpptc x fddd instantiateclasstemplatetreenode gcc gcccpptc x b d completetypetreenode gcc gcccptypeckc x d e grokdeclaratorcpdeclarator const cpdeclspecifierseq declcontext int treenode gcc gcccpdeclc x c grokfieldcpdeclarator const cpdeclspecifierseq treenode bool treenode treenode gcc gcccpdecl c x e cpparsermemberdeclaration gcc gcccpparserc x cae cpparsermemberspecificationopt gcc gcccpparserc x cae cpparserclassspecifier gcc gcccpparserc x cae cpparserclassspecifier gcc gcccpparserc Please submit a full bug report with preprocessed source if appropriate Please include the complete backtrace with any bug report See for instructions make beastsocketserversourcewebsocketsessiono Error I have an HTTPS server built off beast At seemingly random times an assertion inside timeouthandler within basicstreamhpp that asserts that statetimeout is false fails and kills my server My program is basically the example HTTPS server with POST handling added and Im really not sure what the source of the issue is I provided some code that may be related Does anybody have any idea how it would be possible for statetimeout to sometimes fail to be reset to false Looking through the code the timeout appears to only be set directly after this assertion and in two other areas within basicstreamhpp I cannot seem to find anybody else experiencing this error Could it have something to do with using a doclose function Or could it have something to do with using a thread pool I have been struggling with this all day and would appreciate any input beast code where assertion fails templateclass Protocol class Executor class RatePolicy struct basicstreamProtocol Executor RatePolicy timeouthandler opstate state boostweakptrimpltype wp ticktype tick void operatorerrorcode ec timer canceled ifec neterroroperationaborted return BOOSTASSERT ec auto sp wplock stream destroyed if sp return stale timer iftick statetick return BOOSTASSERTtick statetick timeout BOOSTASSERT statetimeout ASSERTION FAILS HERE spclose statetimeout true Some server code Used in the asyncwrite callback if spneedeof return sessionptrdoclose sessionptrres nullptr else sessionptrres nullptr sessionptrdoread asyncreads callback includes these lines if ec boostbeasthttperrorendofstream ec boostasioerrorconnectionreset return doclose And doclose looks like void httpserversessiondoclose boostsystemerrorcode ec socketshutdowntcpsocketshutdownsend ec And my thread pool initialization looks like for auto i threadcount i i threadsemplaceback iocontext iocontextrun Version of Beast Im using Boost All relevant compiler information Microsoft Visual Studio vinniefalco thanks for the amazing ws library Ive been using this for many projects However for a strange reason it doesnt seem to work for the Bria softphone desktop API after their update The socket connection establishes without any issues but when I write to it it doesnt seem to transfer When I try to read it fails with Error The WebSocket stream was gracefully closed at both endpoints One thing to note that Bria API accepts connections to any target and if the target is incorrect this behaviour is desirable I guess But Im using the exact same target they provided and also javascript test with same target seems to work just fine Im attaching the test codes for both C and Javascript for you to check Id be thankful if you can help C auto host cpclientapisoftphonecom endpoint counterpathsocketapiv port netiocontext ioc sslcontext ctxsslcontexttlsclient websocketstreamsslstreamtcpsocket mwebsocketioc ctx tcpresolver resolverioc const auto resolved resolverresolvehost port boostasioconnectmwebsocketnextlayernextlayer resolvedbegin resolvedend mwebsocketnextlayerhandshakesslstreambaseclient mwebsockethandshakehost endpoint stdstring request GETbringToFront n UserAgent TestApp n TransactionID AE f n ContentType applicationxml n ContentLength mwebsocketwriteboostasiobufferrequest beastflatbuffer mresBuffer mwebsocketreadmresBuffer stdcout beastbufferstostringmresBufferdata stdendl mwebsocketclosewebsocketclosecodenormal Javascript const ws new WebSocketwsscpclientapisoftphonecom counterpathsocketapiv wsaddEventListenermessage function event consolelogeventdata wsaddEventListeneropen function event wssendGETbringToFront n UserAgent MyApplication n TransactionID AE f n ContentType applicationxml n ContentLength PS This is the output I get from BOOSTASIOENABLEHANDLERTRACKING if that helps asio resolver x ffee f cancel asio resolver x ffee cancel asio socket x fc a a close Error The WebSocket stream was gracefully closed at both endpoints asio socket x fc a close Hi all vinniefalco thank you for that wonderful library Im wondering what will be the most popular rest framework on top of beast at the moment The only one Ive found so far is that which is way less popular than the beast project itself Im wondering if exists something simular with better adoption Im looking for a popular library that provides ease of development and high performance