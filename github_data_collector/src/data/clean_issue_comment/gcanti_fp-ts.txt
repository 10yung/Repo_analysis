 Documentation Here its not obvious how Option helps with unsafe array or object index access The missing piece is usage of lookup function which returns Option which forces developers to handle both cases The more rare case is const foo A null null which TypeScript can fail to correctly recognize as nullable as well I dont have a simple example of that but it just happens to me The rule of thumb is not using index access nor null nor undefined which could be mentioned as well Question Once some custom data type are defined declare module fptslibHKT interface URItoKindA EitherThrowableOr EitherThrowableOrA Test TestA Those are permanently added to URItoKindA during the project That means URIS namespace is polluted Then I cannot use the same name as I have already defined for other data types Kind of intrinsic data types such as EitherThrowableOr are likely to be reused but Test are not What if someone try to use Test again for another data type that he define So I think the name Test is not proper for custom data type Suggestion To avoid this URI name collision a naming convention for data types is needed Let me hear your wisdom Thank you Bug report Current Behavior Reduced test case srcindexjs ts import max from fptses Ord consolelogmax rollupconfigjs js import resolve from rolluppluginnoderesolve export default input srcindexjs output file targetrollupjs format cjs plugins resolve packagejson json dependencies fpts rolluppluginnoderesolve rollup Then run rollup c rollupconfigjs Expected behavior The output of rollup should not include lots of unused code js use strict The Ord type class represents types which support comparisons with a total order Instances should satisfy the laws of total orderings Reflexivity Scomparea a Antisymmetry if Scomparea b and Scompareb a then a b Transitivity if Scomparea b and Scompareb c then Scomparea c See Getting started with fpts Ord since Take the maximum of two values If they are considered equal the first argument is chosen since function maxO return function x y return Ocomparex y y x consolelogmax Actual behaviour The output of rollup includes lots of unused code details summaryShow code snippetsummary js use strict since since function identitya return a var isFunctor function I return typeof Imap function var isContravariant function I return typeof Icontramap function var isFunctorWithIndex function I return typeof ImapWithIndex function var isApply function I return typeof Iap function var isChain function I return typeof Ichain function var isBifunctor function I return typeof Ibimap function var isExtend function I return typeof Iextend function var isFoldable function I return typeof Ireduce function var isFoldableWithIndex function I return typeof IreduceWithIndex function var isAlt function I return typeof Ialt function var isCompactable function I return typeof Icompact function var isFilterable function I return typeof Ifilter function var isFilterableWithIndex function I return typeof IfilterWithIndex function var isProfunctor function I return typeof Ipromap function var isSemigroupoid function I return typeof Icompose function var isMonadThrow function I return typeof IthrowError function function pipeableI var r if isFunctorI var map function f return function fa return Imapfa f rmap map if isContravariantI var contramap function f return function fa return Icontramapfa f rcontramap contramap if isFunctorWithIndexI var mapWithIndex function f return function fa return ImapWithIndexfa f rmapWithIndex mapWithIndex if isApplyI var ap function fa return function fab return Iapfab fa var apFirst function fb return function fa return IapImapfa function a return function return a fb rap ap rapFirst apFirst rapSecond function fb return function fa return IapImapfa function return function b return b fb if isChainI var chain function f return function ma return Ichainma f var chainFirst function f return function ma return Ichainma function a return Imapfa function return a var flatten function mma return Ichainmma identity rchain chain rchainFirst chainFirst rflatten flatten if isBifunctorI var bimap function f g return function fa return Ibimapfa f g var mapLeft function f return function fa return ImapLeftfa f rbimap bimap rmapLeft mapLeft if isExtendI var extend function f return function wa return Iextendwa f var duplicate function wa return Iextendwa identity rextend extend rduplicate duplicate if isFoldableI var reduce function b f return function fa return Ireducefa b f var foldMap function M var foldMapM IfoldMapM return function f return function fa return foldMapMfa f var reduceRight function b f return function fa return IreduceRightfa b f rreduce reduce rfoldMap foldMap rreduceRight reduceRight if isFoldableWithIndexI var reduceWithIndex function b f return function fa return IreduceWithIndexfa b f var foldMapWithIndex function M var foldMapM IfoldMapWithIndexM return function f return function fa return foldMapMfa f var reduceRightWithIndex function b f return function fa return IreduceRightWithIndexfa b f rreduceWithIndex reduceWithIndex rfoldMapWithIndex foldMapWithIndex rreduceRightWithIndex reduceRightWithIndex if isAltI var alt function that return function fa return Ialtfa that ralt alt if isCompactableI rcompact Icompact rseparate Iseparate if isFilterableI var filter function predicate return function fa return Ifilterfa predicate var filterMap function f return function fa return IfilterMapfa f var partition function predicate return function fa return Ipartitionfa predicate var partitionMap function f return function fa return IpartitionMapfa f rfilter filter rfilterMap filterMap rpartition partition rpartitionMap partitionMap if isFilterableWithIndexI var filterWithIndex function predicateWithIndex return function fa return IfilterWithIndexfa predicateWithIndex var filterMapWithIndex function f return function fa return IfilterMapWithIndexfa f var partitionWithIndex function predicateWithIndex return function fa return IpartitionWithIndexfa predicateWithIndex var partitionMapWithIndex function f return function fa return IpartitionMapWithIndexfa f rfilterWithIndex filterWithIndex rfilterMapWithIndex filterMapWithIndex rpartitionWithIndex partitionWithIndex rpartitionMapWithIndex partitionMapWithIndex if isProfunctorI var promap function f g return function fa return Ipromapfa f g rpromap promap if isSemigroupoidI var compose function that return function fa return Icomposefa that rcompose compose if isMonadThrowI var fromOption function onNone return function ma return matag None IthrowErroronNone Iofmavalue var fromEither function ma return matag Left IthrowErrormaleft Iofmaright var fromPredicate function predicate onFalse return function a return predicatea Iofa IthrowErroronFalsea var filterOrElse function predicate onFalse return function ma return Ichainma function a return predicatea Iofa IthrowErroronFalsea rfromOption fromOption rfromEither fromEither rfromPredicate fromPredicate rfilterOrElse filterOrElse return r The Ord type class represents types which support comparisons with a total order Instances should satisfy the laws of total orderings Reflexivity Scomparea a Antisymmetry if Scomparea b and Scompareb a then a b Transitivity if Scomparea b and Scompareb c then Scomparea c See Getting started with fpts Ord since since var URI Ord default compare for primitive types var compare function x y return x y x y function strictEquala b return a b since var ordNumber equals strictEqual compare compare Take the maximum of two values If they are considered equal the first argument is chosen since function maxO return function x y return Ocomparex y y x since function fromComparecompare var optimizedCompare function x y return x y comparex y return equals function x y return optimizedComparex y compare optimizedCompare since var ord URI URI contramap function fa f return fromComparefunction x y return facomparefx fy var contramap pipeableordcontramap since var ordDate ordcontramapordNumber function date return datevalueOf consolelogmax details Reproducible example Suggested solutions Add annotationscomments to indicate no side effects eg in fptses Ordjs diff var contramap pipeableordcontramap var pipeableResult PUREpipeableord var contramap pipeableResultcontramap export since contramap since export var ordDate ordcontramapordNumber function date return datevalueOf export var ordDate PUREordcontramapordNumber function date return datevalueOf This fixes the issue when using Rollup Reduced test case Note this does not fix the issue with webpack for some reason Additional context Add any other context about the problem here Your environment Which versions of fpts are affected by this issue Did this work in previous versions of fpts PLEASE FILL THIS OUT Software Versions fpts See above TypeScript See above This PR will add the following modules ReadonlyArray done ReadonlyNonEmptyArray done ReadonlySet done ReadonlyMap done ReadonlyRecord done ReadonlyTuple done other The goal is to obtain dropin replacements for the mutable counterparts with some exceptions see the notes below Notes ReadonlyArray didnt port copy seems useless ReadonlyNonEmptyArray didnt port copy seems useless renamed fromArray to fromNonEmptyArray Semigroup changed folds signature in order to support readonly arrays Monoid changed folds signature in order to support readonly arrays ReadonlyMap renamed toArray to toReadonlyArray ReadonlyRecord renamed toArray to toReadonlyArray ReadonlySet renamed toArray to toReadonlyArray renamed subset to isSubset Feature request Im sorry Im beginner To get familiar with fpts Im trying to convert and rewrite some taglessfinal examples written in Scala into one using fpts Here is an example I have not succeed with it yet Some features in fpts are still confusing to me Current Behavior In the Document Modules only provide APIs Just few of them provide usage examples Describing how to write the taglessfinal style only with fptothemaxiits is not enough Desired Behavior Providing usage examples in the document will be very helpful to beginners Provide more usage examples Suggested Solution Add kind of Document Recipes Migrate from Scala with cats Provide more guide and examples of how to use HKT Kind No paper no theory Who does this impact Who is this for For beginners who just get interested in fpts Describe alternatives youve considered Add usage example to each item in the modules getReaderM function Add explanatory description here Signature export function getReaderMMM MonadM ReaderMM Usage import as RT from fptslibReaderT import as R from fptslibReader Describe what it is doing RTgetReaderMRReaderfromReaderenv Additional context NA Your environment Software Versions fpts TypeScript Bug report Current Behavior The following file when processed by a bundler rollup webpack etc will include the fpts Either module twice once the es version and once the lib version import right from fptses Either import right from monocletses Either consolelogright rightright Why Because the Either module from monocle imports fptslibEither even if itself was imported through monocletses Either Expected behavior The fpts Either module should appear only once in the output Reproducible example Save the above example as inputjs and bundle using the following rollup config import commonjs from rollupplugincommonjs import nodeResolve from rolluppluginnoderesolve export default input inputjs output file outputjs format cjs plugins nodeResolve commonjs The resulting file will be KB and contain a lot of unnecessary code because rollup cant threeshake commonjs modules If I edit the monoclets package contents to always import from fptses instead of fptslib then the size drops to K Suggested solutions The only solution Im aware of is this Every module that the user is expected to import in their code has to be a folder and that folder must contain a packagejson which provides pointers to the entry points main being the commonjs entry point and module being the ES module entry point In other words in any import statement import from SOMEMODULE the SOMEMODULE must refer to a folder with its own packagejson ie nodemodulesSOMEMODULEpackagejson If SOMEMODULE contains path separators same applies eg import from fptsEither nodemodulesfptsEitherpackagejson Additional context The materialuicore package solves this in the way I described You can have a look at the contents of their package here Every direct subfolder of this package is allowed to be imported As you drill down to the subfolders youll see a packagejson en every one eg There are a few gotchas around tree shaking so it would be useful to document these somewhere This applies to other libraries in the fpts ecosystem such as monoclets Below is my understanding Is this correct If so perhaps we could add this to the docs Tree shaking works out of the box automatically thanks to the module field in packagejson ts import option from fpts This will end up importing fptses indexjs rather than fptslibindexjs Caveat when importing sub modules however you must remember to import from the es folder diff import as O from fptslibOption import as O from fptses Option Caveat libraries such as iots import from the lib folder not the es folder This means that tree shaking will not be able to work for example when using the following import ts import as t from iots The solution is to use webpacks resolvealias configuration js moduleexports resolve alias fptslib fptses In the case of using other libraries such as fptsrxjs it may also be necessary to create aliases for them too Feature request Current Behavior At the moment we need to write a ton of overloading boilerplate for HKTgeneric function typescript import Functor Functor Functor Functor C Functor Functor from fptslibFunctor import HKT Kind Kind Kind Kind URIS URIS URIS URIS from fptslibHKT export function mapTwiceF extends URIS F Functor F S R E Afa Kind F S R E A f a A A Kind F S R E A export function mapTwiceF extends URIS F Functor F R E Afa Kind F R E A f a A A Kind F R E A export function mapTwiceF extends URIS F Functor F E Afa Kind F E A f a A A Kind F E A export function mapTwiceF extends URIS E F Functor CF E Afa Kind F E A f a A A Kind F E A export function mapTwiceF extends URISF Functor F Afa KindF A f a A A KindF A export function mapTwiceFF FunctorF Afa HKTF A f a A A HKTF A export function mapTwiceFF FunctorF Afa HKTF A f a A A HKTF A return fa f FmapFmapfa f f Evenmore the signatures missing overloads for missing Functor C and Functor C And possibly overloads for other constrained functors not only by the E type arg Thats ugly Desired Behavior We want a clean and concise solution for writing fully generic functions like typescript export function mapTwiceF extends URIS F FunctorF S R E Afa KindF S R E A f a A A KindF S R E A return fa f FmapFmapfa f f Important thing is that we would also like to automate currying of typeclasses no C names Suggested Solution Ive been playing with fpts for a while and got the following typescript region HKT interface URItoKindS R E A type URIS keyof URItoKindunknown unknown unknown unknown type KindURI extends URIS S R E A URI extends URIS URItoKindS R E A URI never interface Auto readonly Auto unique symbol type OrA B A extends Auto B A endregion region abstract interface FunctorF extends URIS FS Auto FR Auto FE Auto readonly URI F readonly map S R E A B fa KindF OrFS S OrFR R OrFE E A f a A B KindF OrFS S OrFR R OrFE E B endregion region ADT interface URItoKindS R E A Either EitherE A type EitherE A tag Left left E tag Right right A const functorEither FunctorEither URI Either map fa f fatag Left fa tag Right right ffaright interface SemigroupA readonly concat x A y A A function getValidationES SemigroupE FunctorEither Auto Auto E return URI Either map functorEithermap endregion region test const mapTwice F extends URIS FS FR FEF FunctorF FS FR FE S R E A fa KindF OrFS S OrFR R OrFE E A f a A A KindF OrFS S OrFR R OrFE E A FmapFmapfa f f const semigroupString Semigroupstring concat x y x y const f n string string ntoUpperCase const test mapTwicefunctorEither tag Left left f Ok Eitherstring string const test mapTwicefunctorEither tag Left left f Ok Eithernumber string const v getValidationsemigroupString const test mapTwicev tag Left left f Ok Eitherstring string const test mapTwicev tag Left left f Error number is not assignable to string const test mapTwicefunctorEither tag Left left Symbol Ok Eithersymbol string const test mapTwicegetValidationsemigroupString tag Left left f Ok Eitherstring string const semigroupSymbol SemigroupSymbol concat x y Symbolconcat const validationSymbol getValidationsemigroupSymbol const test validationSymbolmap tag Left left Symbol f Ok EitherSymbol string const test validationSymbolmap tag Left left foo f Error string is not assignable to Symbol const test mapTwicevalidationSymbol tag Left left Symbol f Ok EitherSymbol string const test mapTwicevalidationSymbol tag Left left foo f Error string is not assignable to Symbol endregion Suggest a solution that the communitymaintainersyou may take to enable the desired behavior NOTE Feature Requests without suggested solutions may not be addressed or treated with the same level of urgency as those that have suggested solutions Who does this impact Who is this for All users of fpts especially library authors Who is this for All users TypeScript users Beginners Advanced Yourself People using X Y X etc Describe alternatives youve considered None Additional context Described approach means that theres a single dictionary left and a single version of a typeclass Theres no sensible profit in maintaining separate versions like HKT Kind Kind Monad MonadC etc It also means that a typeclass supports constrained arguments out of the box Your environment Software Versions fpts TypeScript The problem ts example from import as E from fptslibEither import pipe from fptslibpipeable type HttpError HttpError declare function geturl string EEitherHttpError string type FsError FsError declare function writepath string content string EEitherFsError void type Err HttpError FsError const program pipe get error Type HttpError is not assignable to type FsError Echaincontent writepurescripthtml content This is because Echain is inferred as ts relevant type here v chainFsError string voidf a string EEitherFsError void ma EEitherFsError string EEitherFsError void Solutions explicit cast ts const writeE path string content string EEitherErr void write const program pipe get Echaincontent writeE purescripthtml content explicit mapLeft ts const widen EmapLeftErr Erre e const program pipe get Echaincontent pipe writepurescripthtml content widen lifting with flow and mapLeft ts import flow from fptslibfunction const writeE flow write widen const program pipe get Echaincontent writeE purescripthtml content defining a chain overload that combines the error types ts const flatMap E A B f a A EEitherE B E ma EEitherE A EEitherE E B Echain as any const program pipe get flatMapcontent writepurescripthtml content Others