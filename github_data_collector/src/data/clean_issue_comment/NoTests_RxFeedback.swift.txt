As Combine is the new go to Rx framework and probably will replace RxSwift RxCocoa etc in the future there is a need for a rx feedback loop using Combine How feasible is a port and how much work would it probably be bind variant that takes owner WeakOwner actually just captures an owner strongly because it is executed on Observersystem creation and returns closure with a captured object Im using bind without owner and doing strongify manually as a workaround for now Hi there My company struggled a bit after removed react for nonequatable types I think its absolutely reasonable to to require types returned by request be equatable Though we are using Void in quite a few places to trigger feedback loops that dont require any parameters Examples include anything from networking to navigation from current location fetch to database sync We ended up writting a custom react just for this case swift func reactState Eventrequest escaping State Void effects escaping SignalEvent DriverState SignalEvent return reactrequest request nil true nil Bool to the rescue effects in effects Do you think it would make sense to add a react for Void to RxFeedback Have you encountered this Thanks I find that it is hard to test the event creationFor example i want to query some every sAnd i write this in viewDidLoad methodIm wandoring how to test the request produce and the event created in the right way let query DriverState SignalEvent react request state QueryRequest in return QueryRequest effects request in return SignaljustEventquery DriverAnysystem initialState State reduce Statereduce feedback query drive disposedby selfrxdisposeBag It seams the only way is run the app and debugSo is anyone has the same problem as me Overview We can introduce ObservableSystem this will make system chainable PlayCatch Example Before swift let bindUI ObservableSchedulerContextState ObservableEvent bindself me state in return Bindingssubscriptions subscriptions events events Observablesystem initialState StatehumanHasIt reduce state State event Event State in switch event case throwToMachine return machineHasIt case throwToHuman return humanHasIt scheduler MainSchedulerinstance feedback UI is human feedback bindUI NoUI machine feedback reactrequest machinePitching effects ObservableEvent in return ObservableInt timerseconds scheduler MainSchedulerinstance map in EventthrowToHuman subscribe disposedby disposeBag After swift ObservableSystemcreate initialState StatehumanHasIt reduce state State event Event State in switch event case throwToMachine return machineHasIt case throwToHuman return humanHasIt scheduler MainSchedulerinstance bindedself me state in return Bindingssubscriptions subscriptions events events reactedrequest machinePitching effects ObservableEvent in return ObservableInt timerseconds scheduler MainSchedulerinstance map in EventthrowToHuman system subscribe disposedby disposeBag Evolution The solution is inspired by Rx Lets get in What do we have currently in Rx I will show minimal type inferface in Rx as it will help us move fast to destination swift typealias EventElement Element mocked just a name typealias ObserverElement EventElement Void typealias Disposable Void typealias ObservableElement escaping ObserverElement Disposable Ive removed unrelate logic to make our evolution pure Now we can adds some operators which are free functions swift func filterElement predicate escaping Element Bool escaping ObservableElement ObservableElement return source ObservableElement in func mapElement Result transform escaping Element Result escaping ObservableElement ObservableResult func flatMapElement Result transform escaping Element ObservableResult escaping ObservableElement ObservableResult As far as we can tell Operator behaiver like a Middleware swift typealias MiddlewareElement Result escaping ObservableElement ObservableResult We can change operator a little bit to swift func fulter Element predicate escaping Element Bool MiddlewareElement Element func map Element Result transform escaping Element Result MiddlewareElement Result func flatMap Element Result transform escaping Element ObservableResult MiddlewareElement Result Thats what we have now in Rx Port to RxFeedback We can find a way to port all these stuff to RxFeedback What do we have in RxFeedback swift typealias FeedbackState Event ObservableState ObservableEvent typealias ImmediateSchedulerType Any Ignored in this demo context func systemState Event initialState State reduce escaping State Event State scheduler ImmediateSchedulerType feedback FeedbackState Event ObservableState We may add a createSystem function swift func createSystemState Event initialState State reduce escaping State Event State scheduler ImmediateSchedulerType FeedbackState Event ObservableState return feedback ObservableState in By comparing function system with createSystem Its not hard to find the return type has been changed form ObservableState to FeedbackState Event ObservableState Ok This will open a new world lets call the new return type System swift typealias SystemState Event FeedbackState Event ObservableState Then createSystem becomes swift func createSystem State Event initialState State reduce escaping State Event State scheduler ImmediateSchedulerType SystemState Event Next we can introduce SystemMiddleware swift typealias SystemMiddlewareState Event SystemState Event SystemState Event The feedback creator funtion like react and bind in RxFeedback now becomes operator swift func reactState Request Equatable Event request escaping State Request effects escaping Request ObservableEvent SystemMiddlewareState Event func reactState Request Equatable Event requests escaping State SetRequest effects escaping Request ObservableEvent SystemMiddlewareState Event func bindState Event bindings escaping ObservableState subscriptions Disposable events ObservableEvent SystemMiddlewareState Event Real Lets bring this to real Introduce ObservableSystem to RxFeedback swift public struct ObservableSystemState Event public typealias Feedback ObservableAnyFeedbackState Event public typealias System Feedback ObservableState public let system System private init system escaping System selfsystem system extension ObservableSystem public static func create initialState State reduce escaping State Event State scheduler ImmediateSchedulerType ObservableSystemState Event return ObservableSystem feedback in return ObservableAnysystem initialState initialState reduce reduce scheduler scheduler feedback feedback public func reactedRequest Equatable request escaping State Request effects escaping Request ObservableEvent ObservableSystemState Event let newFeedback Feedback reactrequest request effects effects let sourceSystem selfsystem return ObservableSystem feedback in sourceSystem newFeedback feedback public func reactedRequest Equatable requests escaping State SetRequest effects escaping Request ObservableEvent ObservableSystemState Event let newFeedback Feedback reactrequests requests effects effects let sourceSystem selfsystem return ObservableSystem feedback in sourceSystem newFeedback feedback public func bindedWeakOwner AnyObject owner WeakOwner bindings escaping WeakOwner ObservableSchedulerContextState BindingsEvent ObservableSystemState Event let newFeedback Feedback bindowner bindings let sourceSystem selfsystem return ObservableSystem feedback in sourceSystem newFeedback feedback other operator There are some duplicate code in each operator Its fine in the demo context since this will improve readabylity The ObservableSystem is like Observable in Rx And reacted binded is like Operators in Rx Now the system can be chainable swift ObservableSystemcreate initialState StatehumanHasIt reduce state State event Event State in switch event case throwToMachine return machineHasIt case throwToHuman return humanHasIt scheduler MainSchedulerinstance bindedself reactedrequest machinePitching effects reactedrequest effects reactedrequest effects system subscribe disposedby disposeBag It will bring us some benefits system has its own namespace ObservableSystem more consist with Rx easier to add operator less typing With the benefits I proposal to add this feature A running example can be found here with commit introduce ObservableSystem It also handle driver version DriverSystem Im open to disccuss If this is accepted I will make a PR Thanks Hi Are there plans to readd the hooks for nonequatable values returned from state requests In X it was possible to pass own function that would always return false for such cases In there doesnt seem to be one left Best Hi I seem to be having a problem using this Tried also this example And has the same issue Can you point me to the problem or to a working example img width altscreenshot at src img width altscreenshot at src Xcode dont suggests autocomplete for function of RxFeedback However if I am taking complete implementation of Driversystem usage from examples Its successful builds For some reason running Examplesdependenciessh or git submodule update init recursive force before building the Example target inside of theExamplesExamplesxcodeproj in a fresh cloned repo succeeds but trying to build Example target before running the Examplesdependenciessh or git submodule update init recursive force causes build failure I have no idea whats happening here Hello How to exchange events between different loops