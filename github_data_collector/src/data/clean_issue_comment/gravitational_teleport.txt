What happened During Kube interactive sessions Teleport does not store the executed commands as structured events What you expected to happen Similar to Enhanced Session Recording for SSH we would like to be able to programmatically process the commands executed in the K pod How to reproduce it as minimally and precisely as possible tsh login proxy MyTeleportProxy kubectl exec it pod bash do some stuff exit Environment Teleport version use teleport version Tsh version use tsh version OS eg from etcosrelease client macOS server K cluster v Podcontainer Ubuntu LTS benarent This fixes a dropped error in tooltctlcommon We use UpsertUser method to create users which results in confusing audit events being emitted as if user updated itself Also the userupdate event does not capture the user who triggered an action Instead it stores a user name being updated User X updated User X Weve had a feature request to support IBM K s Kubernetes Service Overview Reference Docs Getting started with IBM Cloud Kubernetes Service IBM Cloud Kubernetes Service CLI When inspecting the ClusterRoleBindings there are the following roles created by default in IBMs K service ibmadmin ibmedit ibmview Example ibmadmin yaml kubectl get clusterrolebinding ibmadmin o yaml apiVersion rbacauthorizationk siov kind ClusterRoleBinding metadata annotations iamikscloudibmcomreserved This role binding is automatically generated any changes will be overwritten creationTimestamp T Z name ibmadmin resourceVersion selfLink apisrbacauthorizationk siov clusterrolebindingsibmadmin uid a c d ff e a af c e c roleRef apiGroup rbacauthorizationk sio kind ClusterRole name clusteradmin subjects apiGroup rbacauthorizationk sio kind User name IAMaliceusibmcom apiGroup rbacauthorizationk sio kind User name IAMbobusibmcom Internally IBMs K service uses the identity token jwt is used to map to these Users eg IAMaliceusibmcom So this is partially the reason why we need to have the identitytoken passed as part of the cluster config There is also a refreshtoken but I don t think this is required This guide expands on a couple of features that allows Teleport to use IBMs cloud file storage and etcd password support fixes This PR contains the following changes Replaces SignupToken and SignupTokenData with resources UserToken and UserTokenSecrets Implements tctl user reset username command Adds new AudtEvent to capture UserToken creation Note this PR is against alexeywebapps branch Many access plugin implementations will end up needing to store small amounts of perrequest information eg API callbacks tokens timestamps and the like In order to support making plugins stateless we can allow them to store arbitrary data against individual access requests Layout Because multiple plugins may be running simultaneously its important that some form of namespacing exist to ensure that plugins dont accidentally overwrite oneanothers data Some obvious potential mechanisms are Use a mapping of the form pluginname blob Each plugin can store an arbitrary blob with any relevant data in its assigned slot Pros Super simple Cons Plugins must rewrite all of their state to update one element Use a doublelayered mapping or prefixing convention of the form pluginname key blob Each plugin can update keys within its mapping individually Pros Plugins can individually update subsets of their state Cons More complexity benefit is potentially marginal Im leaning towards right now mostly because I think it plays better with the operations described below Operations Given that most plugins will leverage some amount of parallelism its important that plugin authors have tools to protect themselves from getting their plugins into a bad state due to concurrent writes API should distinguish between create and upsert operations so that authors dont accidentally overwrite unexpected state API should allow authors to protect themselves from concurrent writes eg via compareandswap Sketch This is what Im leaning towards right now yaml metadata kind accessrequest spec user alice roles dictator add the extdata field with a mapping of string string extdata myplugin data golang example call demonstrating a plugin updating its stored state from data to data clientSetAccessRequestExtDataExtDataSetter RequestID abc Name myplugin Value data Value deletes if nil Expect data Expect states expected previous value for compareandswap Upsert true Upsert toggles whether this can overwrite existing data SetAccessRequestState could return FailedPrecondition code traceCompareFailedError if the given request has been updated concurrently It forces the API user to call this method in a loop Instead of this I propose to do such loop internally in Teleport so SetAccessRequestState will have updated the state eventually Not sure about implementation though What to do if for some reason loop exits without updating Perhaps some error should be returned but i think it must differ from traceCompareFailedError I think such error could only be used if the user explicitly states what is desired to compare What happened Weve early reports from a customer than when adding a user to a group via Okta they loose other permissions eg if an end user joins Okta admin group and k admin group they will only have the roles with the smallest account access What you expected to happen More info needed How to reproduce it as minimally and precisely as possible TBD Environment Multiple Teleport Cluster Okta This picks up a dropped error in tooltctlcommon