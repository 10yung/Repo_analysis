Although there is an interface for an i c blocking master a corresponding slave interface is missing Are there any ideas or work already done on this Related to PR for review discussion Part of Blockers WIP Reorganising repo RFC Changing the way we handle additionchanges to the traits RFC Use core language async primitives instead external crates RFC digitalv interface moving to a single interface add more issues PRs here Id like to propose a new CapturePin trait for representing a single input capture channel It is to the Capture trait what PwmPin is to Pwm Since singlechannel singleton abstractions are preferable to multichannel abstractions a trait like CapturePin should become the recommended way to handle input capture hardware The trait will only have the method capture which has the same API as the same method in Capture trait except it doesnt pass in a channel Since not every chip supports enablingdisabling single capture channels the enable and disable methods are omitted perhaps they can be a separate subtrait For a prototype of what the trait will look like refer to this PR Swaps digital trait default to digitalv breaking change as the next step in the planned digitalv deprecation as an alternative to I had hoped to port the compatibility shims back to the v series however this seems impossible to do without cyclic dependencies Dependencies embeddedhal release containing the semvertrick to maintain backwards compatibility Impact HAL consumers using digital traits directly will need to update to fallible types HAL consumers using digitalv or digitalv will observe no change Next steps HAL v x series should remove digitalv v compat v compat to complete the migration bump cargo version semver trick against embeddedhal v x The CapturePin trait is the input capture analogue to the PwmPin trait representing a single capture channel Unlike PwmPin theres no enable or disable methods because some chips such as the MSP FR may have trouble implementing those two methods on capture abstractions The proposed trait has been implemented in msp fr x xhal Summary This proposal proposes to change the way how async api does implemented It makes async api more clearly for use and extend Motivation Our current approach to implement trait primitives as depends on nb crate It was actually on start of this project but after version rust already have async traits and methodology for work with it So in edition of rust lang we have language words as async await The marcosses exported by nb are conflicted with key words we need to use r prefix for each macros use This RFC attempts to change implementation to core types based implementation It will be more effective and more conform rust language ideas Detailed design This RFC inspired of PR but after apply external crate I redesign for use core functionality because it will be better than external depends For example we have interface for serial rust use coretaskPoll A serial interface pub trait Serial Error type associated to this serial interface type Error Reads a single byte fn read mut self PollResultu SelfError Writes a single byte fn write mut self byte u PollResult SelfError It use coretaskPoll as point of async run status It was easy for implement and it isnt depends on nb or another external crates Alternatives Dont implement this RFC Uresolved questions More clear examples of right use async code How we need to update depend crates Do we need to rewrite nb prefer than rewrite async api of embeddedhal Remove stm f hal implementation as dependency and its examples from runned doc tests Following the This PR reorganises the embeddedhal repo into a workspace of related crates Theres a toplevel embeddedhal crate which pulls in the stable items from the other crates at stable revisions DO NOT MERGE This PR is a work in progress The goal for this PR is to allow unstable features to be developed at a different pace to stable releases By moving the traits into their own crates they can have new unstable features added as and when required which can be published to cratesio If you want a stable HAL you should simply continue to use the toplevel embeddedhal crate which simply pulls in only the stable items from some recent release of each of the subcrates For example embeddedhal might contain rust pub mod serial pub use embeddedhalserialWrite as Write Here the Write trait is being reexported from the embeddedhalserial Some new experimental AsyncWrite trait could be added to embeddedhalserial causing a minor or even major version bump of that crate but users of the toplevel embeddedhal trait wouldnt notice until we elected to upversion the dependency in the toplevel crate