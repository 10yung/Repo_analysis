Hi Ive been struggling to do one thing that I think is really easy but I can figure out how So in my case I have a type c interface ITestTT void DoTM class MyClass ITestint method I want to create void TestTargetintDoTM I need to call method Do from within the same module For this I need a reference to method ITestDo so I can set its DeclaringTypenew GenericInstanceType ITest int and then pass the result to new GenericInstanceMethod and MethodOverridesAdd I tried Create a reference by utilizing ModuleImportReference doesnt work returns the same definition Create a reference manually new MethodReference and copy all the stuff sorta works but here when I copy GenericParameters references they are changed in the way that they now belong to this reference instead of original definition which cause exception on final write Create a reference manually new MethodReference and clone all the stuff sorta works unless I try to use resulting reference in MethodOverridesAdd because it seems like here I need to have a reference with original TM generic param and not a clone So to recap I couldnt find a proper way to create MethodReference for definition in the same module with original GenericParameter so I can use it in MethodOverridesAdd There is a repro for this issue at see the README there The problem occurs when we have a type with fairly complex generics like this public class ClassWithConvolutedGenericsTTools where TTools GenericTypeTTools public ClassWithConvolutedGenericsFuncstring GenericTypeTToolsNestedType TTools func which we came across in some rdparty JetBrains dlls If we build the module containing that type then use Mono Cecil to get a TypeReference for the type GenericType the TypeReference looks different if we get it via the constructors parameters or via the classs generic constraint what we get from the generic constraint looks correct to me what we get from the constructor parameters looks wrong in particular IsGenericInstance and HasGenericParameters differ Presumably Mono Cecil is doing some caching of the type because once weve accessed the TypeReference through the classs generic constraint it updates the TypeReference we got from the constructor parameters Exactly what I mean by the above is in code in the repro at Its worth noting that this is only an issue in the case when GenericType is defined in a different module to ClassWithConvolutedGenerics Im not sure if this a bug or expected behaviour which I dont understand or user error but would appreciate some guidance on it Thanks Richard Hi Jb When you rename a TypeReference reference to a type defined in different assembly any constants of such type used as attribute constructor parameters are not renamed their type is not renamed in exported assembly Example csharp LibA public enum Foo A LibB public class CustomAttribute Attribute public CustomAttributeFoo f CustomFooA public class Cat When you rename TypeReference Foo to eg Bar in LibB exported dll still uses type Foo for the attribute ctor parameter constant resulting in type not found exception in runtime At first glance it seems to me that the type name in blob heap is not updated properly Fix for Well be losing a bit of performance on GetTypenamespace name and GetTypefullName but we were not invalidating the cache properly TypeDefinitionCollecitonnamecache keeps old namespace and name key This causes errors when trying to export another assembly where TypeReferences were appriopriately renamed as well resolving TypeReference to TypeDefinition fails Example csharp LibAdll public enum Foo A LibBdll references LibA public void BarFoo x FooA Currently its no picnic to output NET Standard libs on Cecil Granted it is possible but with a lot of added complexity such as finding the ref netstandarddll in the NuGet Package Cache manually Itd be nice if Cecil had some way of handling this within the library such as a UseNetStandard flag which will automatically map SystemPrivateCoreLib and mscorlib references to netstandard Theres a number of ways this could be tackled in the library but I want this issue to serve as a little discussion issue regarding the matter Steps to reproduce cs using SystemDiagnostics using SystemIO using SystemReflectionPortableExecutable using MonoCecil public class Program public static void Main const string Path executabledll using var reader new PEReadernew FileStreamPath FileModeOpen DebugAssertreaderPEHeadersCoffHeaderCharacteristics CharacteristicsExecutableImage CharacteristicsLargeAddressAware using var module ModuleDefinitionReadModulePath new ReaderParameters ReadWrite true moduleWrite using var reader new PEReadernew FileStreamPath FileModeOpen DebugAssertreaderPEHeadersCoffHeaderCharacteristics CharacteristicsExecutableImage CharacteristicsBit Machine per jbevain this is an implementation of the above very old Google Group discussion so things may have changed since then other than API specifics Let me know if with the addition of appropriate tests that this could be accepted or if there are alternatives to achieving the same result 