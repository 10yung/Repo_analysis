It is entirely possible to use Squid without statically checking scopes similar to MetaOCaml or Dottys quotes but of course with more features like pattern matching This simpler mode of usage is less typesafe but makes many things much easier and less intimidating for beginners One has to use the OpenCode T type which is a super type of the contextual Code TC and use unsafeasClosedCode whenever one wants to run or compile the piece of code However currently we emphasize the contextual mode of Squid as the defaultnormal mode which is intimidating and may scare beginners away Instead I think we should promote the simpler interface as the default interface and reserve the contextual interface for advanced users This would mean Changing the type synonyms OpenCode T is longwinded and a bit ugly wed like to use Code T instead The new scheme would be Code T for when you do not know the context ClosedCode T for code that is assuredly closed and can be run OpenCode TC for open code for which we statically track the scope using contextual type C for advanced users Alternatively as I previously proposed in LPTKsquidtypeexperiments we could have type synonym in to enable the nice Code T in C syntax meaning Code T type Ctx C though that would likely require changes in Squid to look at the Ctx member of code types instead of their C type argument which may cause weird typing problems down the line Changing the code types inferred by default we should have a SimplePredef which is configured to make quasiquotes infer Code T types by default instead of Code TC types even though OpenCode TC Code T this still does help with type inference such as when doing var c code c codeopen term Splitting the basic tutorial in two there should be a basic tutorial using simple Code T types and crossquotation references which are now supported and a tutorial for advanced users that demonstrates the OpenCode TC type and its interaction with pathdependent Variable T Ctx types See It turns out they are encoded differently than Scala varargs See report here It would be nice being able to use simple defs without type parameters in embedded code as well as lazy values For example it would avoid a workaround mentioned in This should be doable in the same way its done with things like ifelse ie scala codeif cnd thn else els really is equivalent to codesquidlibIfThenElsecnd thn els In the same way we could have scala codelazy val x v b virtualized as codeval y squidutilsLazyv bsubsx codeyvalue and scala codedef f if f is not recursive as codeval f and for recursive definitions using a Y combinator with byname parameters for example for a recursive definition scala codedef f if f is recursive as codeval f Yf Finally it would use an annotation similar to the one used for implicit bindings in order to mark virtualized bindings so they can be generated back to their original form when emitting Scala trees This is to prepare the ground for the new IR implementations that will replace the legacy ASTSimpleASTSimpleANF IRs which are bloated and unoptimal We need to add a Context abstract type member and an implicit parameter to reification methods so as to avoid needless global state in the reification process abstract over the representation of argument lists List ArgList so as to allow alternative and possibly more efficient representations abstract over the Extract data type for the same reason perhaps take the precautions needed to make the IRs threadsafe if it does not incur significant overhead otherwise make it optin IIRC the main place where threadsafety would be a problem is with the pattern caching mechanism and with variableid generation The rewrite macros comprise toplevel rewrite calls from the RuleBasedTransformer class as well as termlevel trewrite calls which desugar into the same These are currently expanded into calls to RuleBasedTransformerregisterRule conceptually an invocation such as rewrite case codet if c rhs expands into scala registerRule expression representation of code pattern t extractArtifact extract the different trees obtained from extractArtifact and pass them through the subpatterns for example see SubPattern in case codeSubPatternxyzInt if the guardcondition c of the pattern matching case is respected Someadapted version of rhs else None This is generated after some crazy macro hackery during which untypecheck is used to get around owner chain corruptions which incurs limitations on what can go inside a rewrite rule righthand side It incurs problems with pathdependent types some of which are fixed in a very adhoc way A saner approach would likely be to perform the main code transformation before type checking using a macro annotation since the translation is mostly syntactic anyway But we would have to split from that code the functionality that inspects the types of the pattern and righthand side in order to refine the type of the rewritten term and to check that the transformation is typepreserving Indeed that functionality needs to be expressed in a macro def as it requires type checking information but the good news is that it does not change the shape of the tree and should not result in owner chain problems Implementation of FastANF a mutable version of ANF in order to provide O substitution Basic implementation of HOPholes Does not encode types This adds the numbering of bound variables It introduces some mutable state in the PrettyPrinter which I also changed into a trait Not sure if this is the best way to do it since the numbering does not always work as expected eg see val exp in testVirtualized Constructs where x is followed by y instead of y LPTK if you have a better idea of how to handle this let me know Direct function application syntax on a pattern hole is currently interpreted as higherorder matching To extract a function one should ascribe the hole with a function type This can lead to confusing error such as the following scala error Embedding Error Unexpected expression in higherorder pattern variable argument error case irf printlnsf error In this case the error message should inform and guide users who just wanted to extract a function To make the new IR faster and compatible with ScalaJSScalaNative and also to lower its startup time we would like not to rely on Scala Reflection at runtime This means we implement our own representation of types type symbols and method symbols The downside is that we wont be able to inspect at runtime the annotations such as effects annotations defined on method symbols To work around this we will provide nice tools to provide effects annotations manually for external libraries in the same vein as this will extend the functionalities of the embed macro annotation to look at the annotations placed on methods and register them in the IR also we have to remove the runtime dependencies on Scala Reflection that currently exists in the code that embed generates