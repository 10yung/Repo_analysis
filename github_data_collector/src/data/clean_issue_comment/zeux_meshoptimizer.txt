Preparing Download Bistro from Running lodviewerexe bistroExteriorexteriorobj Observing Damaged texture coordinates Multiple holes in the mesh I am using meshoptimizers simplification methods to simplify D scans w have been triangulated using marching cubes The meshes are far more dense than they need to be so I am attempting to simplify them down to of their original density Unfortunately the result is unusable and full of holes and other defects Is this normal Here is an example Input Mesh Simplified Result I am using MeshLab to visualize the result The meshes are exported to STL format The mesh format I am using internally in my software is that of the VCG library but I think I am appropriately converting the data such that meshoptimizers simplification methods can operate correctly Here is how I am converting the data const MeshVert restrict root inputvertdata stdvectorunsigned remap stdvectorvcgPoint f vertices for const auto v inputvert verticesemplacebackvP for const auto f inputface remapemplacebackunsignedMeshVertfcV MeshVertroot remapemplacebackunsignedMeshVertfcV MeshVertroot remapemplacebackunsignedMeshVertfcV MeshVertroot const sizet indexcount remapsize stdvectorunsigned simplifiedindexcount sizet targetcount simplificationfactor indexcount float targeterror e f if restricted simplifiedresizemeshoptsimplify simplified remapdata indexcount const float restrict vertices verticessize sizeofvcgPoint f targetcount targeterror else simplifiedresizemeshoptsimplifySloppy simplified remapdata indexcount const float restrict vertices verticessize sizeofvcgPoint f targetcount Im a little confused by the concept of Index in this mesh processing library Are the indexes here referring to triplets of offsets from VertexPtr which represent each facetriangle The VCG mesh has a vector of vertices each represented by a Point f type the internal data of which is floats X Y and Z The faces contain vertex pointers I compute the offsetindex from these pointers by subtracting the start of the vertex array root Is this the correct approach Am I doing something wrong The result looks reasonable but not entirely correct Perhaps this is just the nature of decimation Hi I integrated your optimizer for generating collision meshes by using meshoptsimplify followed by meshoptoptimizeVertexFetch Unfortunately on some meshes the decimated result has some parts aggressively simplified and some other parts have redundants triangles conserved vertices have no attributes other than their position Does it come from the topology of the mesh My settings The most noticeable come from an airport terminal as you can see here some parts are really reduced while others seem to be ignored The target error were then and the vertices conserved were respectively and Models as used only positions for vertex attribute exported as OBJ Original Decimated When I use the aggressive option in gltfpack I find that the model shading looks off This appears to be caused by the normal being a bit messy Attached is a screen shot from the babylonjs viewer with normal preview turned on for one of the meshes hence the beautiful rainbow img width altScreen Shot at PM src Im not sure if this is an unavoidable artifact or something that can be improved Also I realize the input model is already pretty sparse Nonetheless the vertex removals seem reasonable if only the normals were better preserved Heres an example of the command Im using Ive also attached the input and output GLBs Im using gltfpack i tmpinputglb o tmpoutputglb si sa v Archivezip I kinda calculate an approximate error metric roughly based on hausdorff distance between the mesh after generating the simplified one Is there any chance to avoid this calculation and use some consistent object space error metric used internally by meshoptsimplify Thanks in advance BTW very handy library much appreciated