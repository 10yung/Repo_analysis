Hello there Unfortunately were dealing with a legacy system via http that behaves unstable and nondeterministic ie it could happen that internal server errors or similar ones occure but a request managed to perform the intended operation after some time has elapsed So what we are trying to do is to setup a retry policy which in case of any error response waits a certain amount of time and then checks orderCreated whether the initial operation did go through If the order was not successful orderCreated returns false and only then retry again If the ordered was successfully created orderCreated returns true we are done no retries So what we are trying to achieve In case of any expected error wait some time check whether a condition is met if not retry again otherwise continue I am wondering whether this is the correct way of dealing with our issue I have already written some unit tests and in seems to work as expected Are there any issues we should consider Are we messing things up What do you guys think Thank you so much for your help bool orderCreated everytime ThreadSleep return GetOrderIdorderId user capacityResult null return Policy HandleHttpRequestException orderCreated OrTimeoutRejectedExceptionr orderCreated thrown by Pollys TimeoutPolicy if the inner call times out OrResultHttpResponseMessager orderCreated intrStatusCode rStatusCode HttpStatusCodeRequestTimeout Retry onRetry ctx span logging ExecuteAndCaptureAsync legacyHttpClientRequestOrderuser order capacity This feature request is related to policies I would like to be able to annotate my class and interface methods with attributes that represent Polly policies such as retry circuit breaker caching etc Something like this cs Cache cache ALL the methods of this interface unless overridden Retry retry ALL the methods on this interface unless overridden public interface IWebInterface Cache Retry CircuitBreaker Bulkhead Taskstring FetchJson Asyncstring param PollyIgnore ignore all polly attributes for just this method Taskstring FetchJson Asyncstring param this method inherits cache and retry from the interface definition Taskstring FetchJson Asyncstring param These attributes would inherit from a PollyBaseAttribute class This saves having to type the policies everywhere the function is called You could also provide a uber attribute that allowed specifying all the policies in a single attribute with named parameters I could see people making some attribute subclasses that setup all the policies they care about and then applying those attributes as needed The attributes would provide all the necessary properties to create a policy automatically For example the Cache attribute could provider a Key string property If left null an automatic key could be created using the full type name plus method name If a class implements an interface or overrides base class methods with Polly attributes the class implementation would always get priority for Polly attributes The attributes would be applied in order With the attributes the interface call could work one of two ways Have an expression tree based utility method that allows calling the interface method through a Polly helper method like PolicyExecute already does The helper method would take care of finding the attributes and applying the appropriate Polly policies There is still some repetition of code since a Polly helper method would be needed anywhere you want to call a method with Polly attributes Example cs IWebInterface baseInterface new WebInterface WebInterface class implements IWebInterface string result await PollyExecuteobj objFetchJson Asyncparam finds Polly attributes and adds appropriate policies to the method call The PollyWrap call would take care of finding the attributes and applying policies You could cache the type and method name for fast attribute lookup Use TypeBuilder and allow generating a Polly wrapper on an interface For example cs IWebInterface baseInterface new WebInterface WebInterface class implements IWebInterface IWebInterface wrappedInterface PollyWrapbaseInterface MOQ style interface wrapper builder magic string result await wrappedInterfaceFetchJson param wrappedInterface provides Polly policies using TypeBuilder magic Once that is done you could call wrappedInterface and the Polly policies would be called automatically This requires either building up an interface at runtime that wraps the existing interface or having some sort of code generator that could generate a C class that wraps the interface Frameworks like MOQ do this already This eliminates all the redundant calls to Polly and helper methods and would be my ideal solution TypeBuilder documentation Id love any thoughts or feedback on this proposal Initial work to allow for dynamically calculated CircuitBreaker break periods The issue or feature being addressed See Issue reisenberger Details on the issue fix or feature implementation See Issue Note that there seem to be contentious design choices outstanding mentioned on that Issue wrt NonPositive inputs Ive gone with leaving staticduration behaviour unchanged and having no checks for dynamic durations wrt Delay durations when the response is slow to come back Ive gone with reusing the same delay until one of the responses actually completes Several things still need to be done before this is fully suitable for deployment but theyre all fairly rote changes so I want to get the meat of the change approved before doing them since if there are substantial markups the rote changes might need tweaks which would be tedious Trivially apply all the same changes to the Factory Methods for other syntaxes CircuitBreakerAsync CBTReslt CBTResultAsync Figure out what if anything should be done for the Advanced version of the CB Then apply all the same boring Factory Method changes to all version of that Update existing tests for all of the above Create new tests for the specific functionality for the duration to change dynamically as opposed to the existing tests which all use constantreturn functions This ensures that the existing functionality is unchanged and that the most basic usecase of the functionality works but is somewhat lacking in depth Add general documentation the XMLDocs are updated but I assume theres a highlevel doc somewhere that I should update too Confirm the following FIXED Branch state on your repo currently looks weird See above the existing tests have been updated and crudely exercise the new functionality Additional tests are required and Ill create them in due course wanted to get the meat of the change up for someone to look at while Im doing that x I started this PR by branching from the head of the latest dev vXY branch or I have rebased on the latest dev vXY branch or I have merged the latest changes from the dev vXY branch x I have targeted the PR to merge into the latest dev vXY branch as the base branch Y I have included unit tests for the issuefeature Y I have successfully run a local build Summary Was looking into converting some http URLs to https in the MS docs When navigating to Expected behavior Site loads with https Actual behaviour cert error Looks like the cert is only set up to cover If this project is a NET Foundation project I believe you are eligible for a free SSL cert for your domain Weve partnered with DigiCert to provide SSL certificates for the NET Foundation OU We set your project up in Digicerts system you request the certificate for your website and theyre paid for centrally by the foundation Or since youre on the azure app service if youre willing to spend a few bucks the setup for an SSL cert there isnt too tough Ive done it before let me know if I can be of help Wanted to drop this here in case its useful feel free to close if not Thanks What is PollyContribAzureFunctionsCircuitBreaker PollyContribAzureFunctionsCircuitBreaker is a durable distributed circuitbreaker implemented in Azure Entity Functions The durable distributed circuitbreaker can be consumed within an Azure functions app from anywhere over an https api Within an Azure functions app the circuitbreaker is stateful and consistent across multiple function invocations and scaling of the function app In external consumption over https api the circuitbreaker is statefully consistent to all consumers Want to know more Head over to the PollyContribAzureFunctionsCircuitBreaker repo Questions Ideas Want to contribute Open an issue on the PollyContribAzureFunctionsCircuitBreaker repo Thank you for contributing to Polly Open source is only as strong as its contributors All nontrivial contributions get a public credit in the readme The issue or feature being addressed Id like to propose extracting static SystemClock to an interface Details on the issue fix or feature implementation These are initial commits with the end goal to eventually get rid of the ambient SystemClock instance by allowing specifying one when the policies gets created This will allow to run all tests in parallel and will restrict rogue system clock injection during runtime Confirm the following x I started this PR by branching from the head of the latest dev vXY branch or I have rebased on the latest dev vXY branch or I have merged the latest changes from the dev vXY branch x I have targeted the PR to merge into the latest dev vXY branch as the base branch x I have included unit tests for the issuefeature x I have successfully run a local build The issue or feature being addressed Rate limiting Confirm the following I started this PR by branching from the head of the latest dev vXY branch or I have rebased on the latest dev vXY branch or I have merged the latest changes from the dev vXY branch x I have targeted the PR to merge into the latest dev vXY branch as the base branch x I have included unit tests for the issuefeature x I have successfully run a local build What is Simmy Simmy github nuget is a new chaosengineering and faultinjection tool integrating with Polly What can I do with Simmy Simmy lets you introduce a chaosinjection policy or policies at any location where you execute code through Polly You can inject exceptions or fault responses inject additional latency to calls inject any other behaviour Configuration allows you to target only specific call paths you identify inject chaos to randomly affect a certain proportion of calls use a master switch to safely turn chaos experiments on and off Find out more Blog Simmy the Monkey for Making Chaos by lead contributor Geovanny Alzate Sandoval Simmy github repo Simple WebAPI demo to explore Simmy capabilities Richer example using Simmy to inject chaos into distributed microservices run from docker containers as featured in Geovannys blog post Questions Ideas Discussion For questions ideas and discussion please open an issue on the Simmy repo Credits Simmy was based on ideas from mebjas reisenberger and vany with vany championing the ideas and making it all happen The logo is by the Polly teams joelhulen We are using Cache system with Polly in our NetCore solution and we cant find the way to invalidate specific cache registries When using IMemoryCache from NetCore we were able to do it using CancellationTokenSource This is an example about what we are doing to Cache an HttpClient Request using Polly var policyExecutionContext new ContextmyCacheEntryKey var response await cachePolicyExecuteAsync context httpClientGetAsyncuri policyExecutionContext Summary What are you wanting to achieve I want the cache policy execution to limit concurrency on its data loading delegate per given operation key Imagine a disrtibuted cache in Redis implemented though the IAsyncCacheProvider The cached keys have set expiryTTL in Redis The system in question experiences thousands of calls per second Now the key in Redis expires There is a high probability that tens of requests come in nearly simultaneously all requiring the same key from Redis It is not there and the cache executes the underlying data provider once per each request ie needlessly because all of those executions will yield the same value Executing the data provider is expensive Then all of those executions start setting the same keyvalue pair to Redis where setting it once would be enough This IMHO causes unnessesary load on both the cache Redis and the backing data store Or rather bursts of load whenever a key expires I would like the provider to be executed only once and once it returns all outstandingawaiting cache request would be fulfilled immediately also setting the value into the cache only once Do you have any suggestions please Is this possible with PollyCache Or is this something you would have to implement I have tried implementing this using Bulkhead unsuccessfuly I would have to have two of them one for the cache provider and one for the data provider and even then it just limits the conncurency and does not allow for fullfiling all executions in its queue at once As I am writing this I thought of using double cache with an inner layer of memory cache but I cant think of how to reasonably tell when its OK to evict from the inner cache The problem with Bulkhead is that it does not work on a per key basis and maintaining a collection of them could get expensive quickly I am also worried about overhead Something like PollyCacheRedisIAsyncCacheProvider Bulkhead PollyCacheMemoryConcurrentDictionary Bulkhead DataLoader 