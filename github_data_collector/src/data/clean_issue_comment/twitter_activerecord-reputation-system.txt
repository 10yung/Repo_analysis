Definition is hasreputation popularity source reputation watchedpointsd reputation views reputation paymentreputation weight aggregatedby sum hasreputation paymentreputation source episode sourceof reputationpopularity hasreputation views sourceuser sourceof reputationpopularity hasreputation watchedpoints sourceuser sourceof reputationpopularity Then for a given episode I have def pop e puts Popularity ereputationforpopularity puts Watched points ereputationforwatchedpoints puts Views ereputationforviews puts Payment ereputationforpaymentreputation end The result for a given episode is Popularity Watched points Views Payment How could that be Where could I even start debugging it Adding an evaluation does not result in the aggregated evaluation updating its value I have class Article ActiveRecordBase hasreputation popularity source reputation rep weight reputation rep hasreputation rep source article sourceof reputationpopularity hasreputation rep sourcecomments sourceof reputationpopularity The problem is Articleaddevalutionrep Articlefirst Articlereputationforrep Articlereputationforpopularity Then Articleaddevaluationrep Commentfirst Arctilereputationforpopularity STILL Why is it still is something I can not understand Welcome i just want to get a rank for current user Iam did currentuserrank fortotalpoints then I get this error when i use postgresql while its work whitout any issue on sqlite PGWrongObjectType ERROR count must be used to call a parameterless aggregate function LINE SELECT COUNT FROM users LEFT JOIN rsreputations ON user SELECT COUNT FROM users LEFT JOIN rsreputations ON usersid rsreputationstargetid AND rsreputationstargettype User AND rsreputationsreputationname totalpoints AND rsreputationsactive t WHERE rsreputationsvalue Hi I would like to enable a source to evaluate the same target more than one time Inside the source code it is said the same source can only review the same target once I wonder there is a good approach to override the gem to make it work in the way the same source can evaluate more than once In spec expecting by raiseerror without error type is deprecated as it can cause false positive So I added expected error types and replace unnecessary error expectation to attribute checks In Rails theres no difference between scoped and all Both returns active relation In doing so we dont need to specify findscope any more for FinderMethods methods Also the existing behavior for it doesnt give us any benefit It just calls the scope at the end of query result Can anyone tell me what the data column is for in the reputations results Can you add your own data to the records Hi Im trying to create nested reputations however I have a relationship name that is not the default these are my models and reputation definitions orderrb ruby class Order ActiveRecordBase belongsto user belongsto ofert hasreputation rates source user sourceof reputation rates of ofert end ofertrb ruby class Ofert ActiveRecordBase belongsto user hasmany orders hasreputation rates source reputation rates of orders aggregatedby average sourceof reputation karma of user end userrb ruby class User ActiveRecordBase hasmany orders hasmany createdoferts classname Ofert hasreputation karma source reputation rates of createdoferts aggregatedby average end The system should work as follows User can rate his orders The reputation of an ofert is the average of the reputation of all its orders The reputation of a user is the average of the reputation of all his oferts Right now is only working and but the reputation of an user is always as you can see the relationship of users is created using an alias hasmany createdoferts classname Ofert I tried using hasreputation totalofertrates source reputation rates of oferts but it is not working userreputationfortotalofertrates userreputationforrates It is always returning for the reputations of the user Im I doing something wrong Hi I could not find how to validate the evaluation value in the reputation system definition for example in my use case reputations can be from to and must be integers well would be great if we can add those validations in the model level so far I can only validate that from the controller Can we push the latest version to ruby gems evaluationby does not work in the ruby gems version The following error occurs on postgre running on heroku PGUniqueViolation ERROR duplicate key value violates unique constraint indexrsevaluationsonreputationnameandsourceandtarget DETAIL Key reputationname sourceid sourcetype targetid targettypewatchedpoints Episode User already exists INSERT INTO rsevaluations createdat data reputationname sourceid sourcetype targetid targettype updatedat value VALUES RETURNING id appmodelsepisoderb in block in updatewatchedpoints This is the code of the method being called def updatewatchedpoints percentage user tobegiven calculatesomevalue ActiveRecordBasetransaction do currentpoints selfevaluationby watchedpoints user currentpoints currentpointstof if currentpoints tobegiven useraddorupdateevaluation watchedpoints tobegiven self selfaddorupdateevaluation watchedpoints tobegiven user end end end Do you know what might be causing it 