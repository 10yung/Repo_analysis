This PR contains five patches Four do modernization work One implements a new default suffix feature I pursued modernization first because it simplified the macro structure before adding a new macro feature My main interest is the default suffix feature The existing methods for doing impl Default have served us fairly well However their main drawback is that we dont have the opportunity to generate a const fn default for use in constant contexts Adds a new iter method to bitflags that returns an iterator over all the enabled flags Uses iterfromfn to create the iterator to avoid having to add a new struct to the macro which would require a parameter specifying its name I was surprised to find out that matching on bitflags leads to unreachable patterns in the example below ie matchflag always return Im assuming it conflicts with the syntax in match arms is this the intended behavior of bitflags use bitflagsbitflags bitflags pub struct Flag u const A const B const C fn matchflagf Flag usize let a FlagA let ab FlagA FlagB let abc FlagA FlagB FlagC match f abc ab a fn main let abc FlagA FlagB FlagC let ab FlagA FlagB let a FlagA asserteqmatchflagabc asserteqmatchflagab asserteqmatchflaga Im trying to create a bitflags with CamelCase naming However adding allownonuppercaseglobals everywhere doesnt suppress the lints add reprtransparent for the the FFI layout replace This works in plain Rust rust const MAMMAL u const AQUATIC u const SEAL u MAMMAL AQUATIC but the equivalent when using bitflags does not rust use bitflagsbitflags bitflags pub struct FLAGS u const MAMMAL const AQUATIC const SECONDSEAL FLAGS FLAGSMAMMAL FLAGSAQUATIC You get an error error E calls in constants are limited to constant functions tuple structs and tuple variants when trying to BITOR the two flags It would be nice if it did because in my program I have a large initial array of flags to create and there are many different combinations making it impractical to spell them all out inside the bitflags call Edit Simplified the repro This doesnt parse rust bitflagsbitflags pub struct BoxFlags u Im using bitflags on a large table of u status codes where the high bits are a sequential number etc and the lower bits are bit flags Together these are ORd together to make the code This all works fine except for the default Debug trait implementation which doesnt work properly with sequential values This is easiest to demonstrate with a cutdown example macrouse extern crate bitflags bitflags pub struct StatusCode u const ISERROR x const Good const BadEncodingError x const BadDecodingError x fn main println StatusCodeBadDecodingError This outputs ISERROR BadEncodingError BadDecodingError which is inappropriate in my case I assume it is just doing a bitwise OR to all the values and appending them to the output string I would like to be able to implement my own Debug trait and not generate the default one For example the bitflags macro could have a pattern or form which excludes emitting the Debug trait pub struct nodebug StatusCode Note I can override the fmtDisplay trait for discrete cases where I need to print the StatusCode but it doesnt help when debug dumping out structs that have StatusCode as a member Now bitflags merely derives PartialOrd with the mechanism built into rustc which compares the values numerically But a flags type is also a Boolean lattice so it has another natural partial order x y iff ycontainsx As i cant disable deriving PartialOrd i cant use if the other semantics if wanted Either option would be fine Let user disable deriving PartialOrd and ergo Ord Let user choose the semantics of PartialOrd per type It would allow to use any bitflags as generic for example rust struct SomeStructF BitFlags implF BitFlags SomeStructF fn setflags mut self flags F it would also allow to document the crate without need for the examplegenerated module I can send a PR implementing this if theres interest 