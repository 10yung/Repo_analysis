paragoniescott After discovering Windows and Mac line ends in the code Ive also ran PHPCBF to adhere PSR Here you are notes Expires October No new draft seems to have been submitted yet This may need updating The footer in the README example is Paragon Initiative Enterprises however the spec hint at this field being JSON That said other than making reference to an empty footer should be treated as an empty string the format of the Footer is NOT specified If the footer was alwasy JSON when not empty this would simplify libraries and usages of the library It may be a bit strange to call an error in the documentation a security vulnerability but I think it is justified here The documentation claims that parser ParsergetLocalsharedKey ProtocolCollectionv is equivalent to php parser new Parser setKeysharedKey Adding rules to be checked against the token addRulenew NotExpired addRulenew IssuedByissuer defined during creation setPurposePurposelocal Only allow version setAllowedVersionsProtocolCollectionv From my understand however this is not the case In particular the former call does not add a rule banning expired tokens from successful validation Im afraid many users of the library relying on the documentation will use the former call without explicitly adding such a rule and therefore opening their applications up to misuse of expired tokens Please fix this documentation error or let me know in case I misunderstood something fundamentally here In the Utilphp file while figuring out how to work with the jti in the footer I found functions with duplicate phpdoc descriptions that do not perform the same operations HelloI have recently started studying PasetoAs a person coming from a JWT background I am used to the refresh token ideawhen my JWT expires I get a new one by providing a special key Now as an alternative for JWT authentication paseto provides the public purpose tokensNow my question is this When a token expires what should I do Is there any way to refresh that token or do I need to prompt the user to enter their login credentials so I can sign a new token From Thai Duong In the case of an RNG failure ie all zero bytes the BLAKE b of the nonce and message leaks the BLAKE b hash of the message which might be enough information along with the plaintext length to allow an attacker to recover a plaintext without knowing the key The story is similar for v with HMACSHA Proposed solution Instead of hashing the message and random nonce together also include the secret key in the calculation This changes the attack calculus from find the input to a hash function with a known output to break a keyed PRF without knowing the key This solution is backwards compatible with what v and v are already doing since the output is just a plaintext nonce that gets stored in the token However to make this behavior change explicit and easy to reason about Im thinking about incorporating these changes into a v and v I couldnt find any information about what is the expected order of keys in the payload it would be useful that in any implementation such code encodedecodePayload Payload Currently from what I see there is nothing that ensures such behaviour This could be achieved with and usage of ASN DER format for example but right now standard requires payload to be correct Base encoded JSON token Hello This is a very nice project and Im considering to switch from JWT I know JWT also doesnt have this feature But I want to know paseto project can support set token invalid before expired feature now or in the future thx Code in this repository results in an empty cookie being set on my production env works fine in dev PHP environment is FROM php fpmalpine as php RUN dockerphpextinstall pdomysql Fairly sure its an environment thing but Id expect an exception instead of an empty string Interesting addendum switched to V and it works fine Suspect it might be something alpinelibsoduim related