Hi thanks for the great library Correct me if Im naive but Auto Layout seems to get better performance sine iOS Have you redone any benchmarks with Auto Layout to see the performance gain with LayoutKit and would you still recommend LayoutKit especially for big apps that uses UITableViewUICollectionView a lot With iOS coming out soon is there any functionality in the framework that allows us to handle dark mode Maybe an example on how to handle that In class LabelLayoutDefaults UILabelinit is called on static stored property declaration This leads UIView init must be used from main thread only warning on Xcode Moreover it breaks on runtime some cases eg XCUITest tests layout built with using LabelLayout This PR fixes this problem SizeLayoutCustomView will not actually create a CustomView instance It doesnt feel right Maybe SizeLayout should override needsView property return true Or just make this property to be a storage property and set default value is true Hi there Is there any reason why the initializers containing the viewClass argument are marked internal It would be extremely useful if they were exposed as public Reason Lets say for example you want to define a SizeLayoutUITextField and you want to determine what UITextFieldType you want to use at runtime the current public initializers for SizeLayout prevents you from doing so swift func createSizeLayoutT UITextFieldtype TType SizeLayoutT logic for creation here let textFieldLayout createSizeLayouttype YourCustomTextFieldself this inferred as SizeLayoutUITextField if you follow the initialization steps the used initializer in BaseLayout is public initalignment Alignment flexibility Flexibility viewReuseId String nil config V Void selfalignment alignment selfflexibility flexibility selfviewReuseId viewReuseId selfviewClass Vself selfconfig config instead of initalignment Alignment flexibility Flexibility viewReuseId String nil viewClass VType config V Void selfalignment alignment selfflexibility flexibility selfviewReuseId viewReuseId selfviewClass viewClass selfconfig config Using the latter will still yield an inferred type of SizeLayoutUITextField BUT if you set breakpoints in the config closure it will be a YourCustomTextField instance This updates support for SwiftPM manifest based dependency managers Specifically this adds support for installing via Accio but will probably also work with SwiftPM once its integrated into Xcode Please note that this project is part of Accios official integration tests within the Demo project Update to Swift Maybe specifying SWIFTVERSION in buildsh could fix the CI error I ended up getting two approaches for this working The first marks whichever view is hosting the layout as a layout kit root and blocks the view recycler from examining the subviews of any view marked similarly The code for this is much simpler but theres no way to clean up an isLayoutKitRoot property from the root view and this would have no effect on view hierarchies created from makeViews with a nil view Theoretically a view hierarchy created without a parent then added to a parent view should still allow view recycling if makeViews is called again with the new parent The second implemented here would be to mark the top level views a layout generates as roots This should resolve the issues the first approach had at the cost of some additional complexity It makes the assumption that all direct subviews marked as root of a parent view passed in to makeViews belong to that layout or should be removed but that should be consistent with the existing behavior of ViewRecycler Im at a loss as to what the automatically created container view for a parentless layout with multiple views should be marked as but I think leaving it as is will match the current behavior Theres also a small bug fix for associated objects namely they should be stored as copy nonatomic