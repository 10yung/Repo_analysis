Currently writing a new layoutview group needs a bit of boilerplaterepeated code This includes Forwarding events to the active view Forwarding callonany to all views Forwarding focusview to all views Handling a layout cache Exposing a Veclike interface addgetremove And with the upcoming ViewPath selector there will be some more copypasted code to select the nth child Could we reduce the amount of duplicated code Reduce the barrier to writing view groups correctly Provide a more unified interface to access views Does a ViewGroup trait make sense Layout is often an expensive operation To avoid it views try to cache it Leaf views like TextView can cache their internal representation lines based on the size requested Group views like LinearLayout need in addition to know if any child view needs a relayout Right now this is a boolean from Viewneedsrelayout This means children need to hold a flag needsrelayout and bust this flag on any internal change Note that this is not currently implemented everywhere it should be so it may be subtly broken in some ways if you resize a BoxView in a LinearLayout for example A potential improvement would be to instead return some hash of the state from layout and take this hash in needsrelayout This way instead of requiring each view to keep a flag we only need the parent view to keep a hash of the children layouts Views would use a hash of their own content the input request Parent views should either store the childs hash or be able to recompute it from their own hash internal state For example a BoxView could hash their own state XOR a rotated hash of the child state This complexity comes from the need to be bidirectional up the tree when doing layout down the tree when asking for relayout Alternatively we could have a layouthash method views would not be asked if they need to relayout but parents would compare the children hashes with their cached ones This is a bit simpler for views no need to implement needsrelayout but they lose some flexibility they cannot unconditionally ask for relayout when they dont want to hash a large content It also makes it harder to have a default implementation that asks for a relayout every time Both these methods rely on hashes rather than boolean flags and so may add overhead in some cases Currently a large TextView resets the cache ready flag when the content is changed needsrelayout is constanttime Using hashes it would either need to recompute the hash every time making needsrelayout linear in the size of the content or cache the hash adding a bit of memory overhead Overall the memory overhead of storing the content hash is probably fine Problem description The termion backend puts stdout into raw mode which sets ISIG to prevent the default SIGINT on CtrlC In the event mapping from termion keys to cursive events CtrlC is mapped directly to EventExit and then in onevent on Cursive EventExit is hardcoded directly to quit Im working on a project where I do not want to quit on CtrlC or any other automatic exit event but its not straightforward to me how to suppress exit on CtrlC with this setup Maybe instead of having the top level check for EventExit in onevent this can be preloaded into a default global callback so that it can easily be cleared or overridden Sorry if Ive missed something and this is already simple to do Environment Operating system linux distribution windows macOS GNULinux Backend used ncurses the default one pancurses termion termion Current locale run locale in a terminal enUSutf Cursive version from cratesio from git from cratesio First is this a bug report A suggestion Or asking for help A bug report I think or maybe asking for help Problem description I have a quit button in a ripasso and in the new user wizard there is a quit button that I have implemented like this buttonsuperCATALOGgettextCancel s squit stdprocessexit This doesnt reset the terminal for the user and it looks like this fil If possible code or pseudocode to reproduce the problem present an idea See above Environment Operating system ubuntu gnometerminal Backend used ncurses the default one pancurses termion If using ncurses on linux ncurses version define NCURSESVERSION Current locale run locale in a terminal LANGsvSEUTF LANGUAGEen LCCTYPEsvSEUTF LCNUMERICsvSEUTF LCTIMEsvSEUTF LCCOLLATEsvSEUTF LCMONETARYsvSEUTF LCMESSAGESsvSEUTF LCPAPERsvSEUTF LCNAMEsvSEUTF LCADDRESSsvSEUTF LCTELEPHONEsvSEUTF LCMEASUREMENTsvSEUTF LCIDENTIFICATIONsvSEUTF LCALL Cursive version from cratesio from git First is this a bug report A suggestion Or asking for help This is a feature request Problem description In ripasso we have a list of password files and display some meta information that we fetch from a git repository This fetching can be expensive and if the user have a large amount of passwords then it can get out of hand it would therefore be nice to be able to only compute this if the password is displayed to the end user If it would be able to add items to the selectview together with a callback function that would calculate the label when needed it would reduce the startup time for those users immensely If possible code or pseudocode to reproduce the problem present an idea Environment Operating system linux distribution windows macOS Backend used ncurses the default one pancurses termion If using ncurses on linux ncurses version run grep define NCURSESVERSION usrincludecursesh Current locale run locale in a terminal Cursive version from cratesio from git Related to this pull request is not ready to be merged TODO Have a way to know ListView items height from its draw method ListChild has no size property we might want to mimic the behaviour from LinearLayout and its Child property Real tests Update documentation The current API does not allow to create custom keybindings in the menu The current API only allows to create a custom menubar subtree Keybindings are hardcoded in the menubar view README states that Cursive uses ncurses backend by default Sadly Rust bindings for ncurses are very problematic from the safety point of view ncurses crate is wildly unsound It simply wraps calls to C functions in Rust functions and declares them safe with no validation whatsoever It has format string vulnerabilities returns invalid UTF in str and so much other unsoundness that you can cause pretty much arbitrary memory corruption It is also unmaintained See pancurses crate depends on ncurses and inherits the issues This presents issues from both security and reliability standpoints Please consider switching to a backend other than ncurses by default If Rustonly backends are not anticipated to reach parity with ncurses anytime soon consider using ncursesw crate I have not audited it but it seems to be less of a lost cause than ncurses crate Is there a way to get the current cursor position so that I can show a popup at the cursor position The Margins struct is used wherever we need paddingmargins It needs values for each side and the order is kind of a mess because there is no clear canonical way to group them We could have XYusize to represent two corners but which one is topleft Or is it topright We could have a single XYusize usize but is it top bottom bottom top Also if we accept T IntoXY then well end up working with usize usize usize usize which one of the two is that The current Marginsnew method takes left right top bottom I recently realized CSS makes another choice with the now famous trbl ordering top right bottom left All in all its kind of a mess and Dialognewpadding will probably stay ambiguous Maybe this is a place where we should force named parameters and not try to be smart with all these From implementations rust use cursiveviewMargins as M DialognewpaddingM left right top bottom 