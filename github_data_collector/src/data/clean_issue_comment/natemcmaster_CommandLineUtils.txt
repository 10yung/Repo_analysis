I got two ideas on how to do this This could automatically be applied to booltype options making all three states reachable This could be enabled by specifying a novalue This would enable configure like nodepdepxyz stuff I dont have an idea how to apply this to shortoptions nos as negation of s feels slightly off Currently you can define a second option to get a similar behavior Main benefit would be less boilerplate and a shorter helptext I am willing to implement this myself if the idea sounds sound to you Describe the bug SystemInvalidOperationException Could not automatically determine how to convert string values into SystemGuid is thrown when registering Guid command line options To Reproduce Steps to reproduce the behavior Using this version of the library Run this code namespace ConsoleApp using System using SystemDiagnostics using McMasterExtensionsCommandLineUtils class Program static void Mainstring args var cmd new CommandLineApplication var guidOption cmd OptionGuidg A GUIDoption CommandOptionTypeSingleValue IsRequired var expected GuidNewGuidToString cmdOnExecute var actual guidOptionParsedValue DebugAssertexpected actualToString cmdExecutenew g expected See error Could not automatically determine how to convert string values into SystemGuid Expected behavior Specifying command options of the Guid type should work seamlessly Additional context I would suggest introducing a generic value parser that would cover most of the CLR standard library types using System using SystemComponentModel using SystemGlobalization using McMasterExtensionsCommandLineUtilsAbstractions public class GenericValueParser IValueParser private GenericValueParserType targetType TypeConverter converter TargetType targetType Converter converter public static GenericValueParser GetT var targetType typeofT var converter TypeDescriptorGetConvertertargetType return converterCanConvertFromtypeofstring new GenericValueParsertargetType converter null public Type TargetType get public TypeConverter Converter get public object Parsestring argName string value CultureInfo culture return ConverterConvertFromStringnull culture value The originally failing code would be fixed with eg namespace ConsoleApp using System using SystemDiagnostics using McMasterExtensionsCommandLineUtils class Program static void Mainstring args var cmd new CommandLineApplication cmdValueParsersAddGenericValueParserGetGuid var guidOption cmd OptionGuidg A GUIDoption CommandOptionTypeSingleValue IsRequired var expected GuidNewGuidToString cmdOnExecute var actual guidOptionParsedValue DebugAssertexpected actualToString cmdExecutenew g expected Is your feature request related to a problem Please describe I want to change dotnetserves tlsS flag to be httpstlsS and then just deprecate tls or hide it from help text I cant do this because CommandOption only supports having one long and one short option name Describe the solution youd like Support more than one long and short name This is helpful for tools that evolve their usage over time Additional context Review was a good year for this library In the last months this project Passed one million downloads on NuGetorg Received pull requests from external contributors And released versions and with new features like a proper async implementation C support posix option clustering and more plus bug fixes In the roadmap I was feeling burned out and wrote then I wont have as much free time to building new features so Im not planning to do a bunch of work That doesnt mean this library is dead but it means Im hoping improvements will be driven by your efforts Ive been happy to see many community members jumping in to help Thank you for your contributions Roadmap In I plan to continue this project This project is open for contributions Consider the issue list the authoritative source of release planning and feature design Release As of writing I have one project milestone open Release As always feel free to open issues if there is something youd like addressed Use to discuss this release further Increasing transparency To encourage more contribution Ill be adopting a few practices that should make my plans and work more transparent Im hoping increasing the visibility of my work for this projects watchers will give others more opportunity to chime in Those primary changes I have in mind are I will use pull requests for all of my own work I will open issues for release planning and scheduling as well as for feature ideas Im thinking of doing Comments Concerns Feel free to discuss Happy New Year Nate Release planning is now open for discussion I think its time for a new major version It should be because I think there are some breaking changes worth making Those are remove obsolete API rename the throwOnUnexpectedArgs parameter better support for netcoreapp in MExtCommandLineHosting fix ValidationContext for attribute binding Any other breaking changes worth doing now Im also open to doing some new features as well such as but I havent found anything super high priority yet Please chime in if there is something youd like to see addressed Is there a recommended way of loading things like subcommands lazily My thinking is that if Im frequently invoking a CLI tool with many commands each with many subcommands it would be preferable to only load the subcommands of the parent command I suppose it could be done with some custom parsing or otherwise not linking the commands and subcommands together with appCommandT but I think that kindof defeats the purpose of the commandsubcommand structure Is there another way that Im not seeing Ive spent a bit of time with this library and so far I really like the builder syntax and the lack of excessive magic Makes it easier to approach Thank you I am interested in having more contributors help me work on this project There is room for improvement on this library and Im not planning to do it myself anytime soon I dont have much time to work on open source anymore I recently became a new father and also a new job which requires hours of commuting As you can imagine I dont have much free time If you are interested in helping please let me know Cheers Nate Im using generic HostBuilder with NET Core I wish to use GuidnullableGuids as Options however but I cannot figure out how to use a custom IValueParser with HostBuilder I cant see manyany nonstandard examples using HostBuilder maybe someone has done this before using McMasterExtensionsCommandLineUtils using McMasterExtensionsCommandLineUtilsAbstractions using MicrosoftExtensionsDependencyInjection using MicrosoftExtensionsHosting using MicrosoftExtensionsLogging using System using SystemGlobalization using SystemReflection using SystemThreading using SystemThreadingTasks namespace SubcommandSample CommandName cmdlinetest VersionOptionFromMemberversion MemberName nameofGetVersion class Program static Taskint Mainstring args new HostBuilder ConfigureLoggingcontext builder builderAddConsole ConfigureServicescontext services servicesAddSingletonMyService RunCommandLineApplicationAsyncProgramargs readonly MyService mySvc public ProgramMyService mySvc mySvc mySvc OptionCommandOptionTypeSingleOrNoValue public Guid id get async Taskint OnExecuteAsyncCommandLineApplication app CancellationToken cancellationToken default await TaskDelay question where to put the ValueParsers below so I can parse guidsetc when using HostBuilder appConventionsUseDefaultConventions appValueParsersAddOrReplacenew MyGuidParser if id null ConsoleWriteLineid is set to id ConsoleWriteLinehit any key to exit ConsoleReadKey return static string GetVersion typeofProgramAssemblyGetCustomAttributeAssemblyInformationalVersionAttributeInformationalVersion class MyGuidParser IValueParser public MyGuidParser public Type TargetType get typeofGuid public object Parsestring argName string value CultureInfo culture if stringIsNullOrWhiteSpacevalue return null if GuidTryParsevalue out var result throw new FormatExceptionInvalid value specified for argName value is not a valid Guid return result class MyService public MyService Fixes It would be useful if CommandLineApplication implemented an ICommandLineApplication interface so it could be easily mocked to facilitate unit testing applications that consume this API At the moment you cannot mock CommandLineApplication and it makes code that consumes it untestable Implementing an interface that covers the entire CommandLineApplication class is quite straightforward and wouldnt cause any breaking changes as far as I know Id be happy to submit a change in a pull request if this sounds reasonable to you Please let me know your thoughts on this Im aware that youre considering refactoring the API in the future but it would be helpful to have this new functionality before then