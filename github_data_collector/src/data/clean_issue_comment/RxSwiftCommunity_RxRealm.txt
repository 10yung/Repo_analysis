Im getting a fatalError when deleting an object thats being observed It seems reasonable to send an error event to the observable when its target disappears bit this doesnt seem like a reason to terminate the app The code thats deleting from the Realm is far away from the UI thats holding the subscriptions so its impractical to find them all and dispose of them This must be a fairly common use case Is there a way to safely delete an object that may be observed When trying to install RxRealm using SPM it throws error cloning dependencies Failed to clone srcexternalpegtl Failed to clone RealmObjectStore Is there anything we can do or we just have to wait for those dependencies to support SPM errortxt Updates the add function to use RealmUpdatePolicy instead of the deprecated Bool parameter Sorry for the previous issue without much info heres a new ticket When creating an Observable from a managed Realm object using Observablefromoptional managedRealmObj the expected behavior is that similar to using Observablefromobject managedRealmObj a stream should be created that emits an initial value of the object and then new values when the update is updated via a write to the Realm If the value passed in is nil it should emit nil and then complete and dispose However this is not the case Instead the stream is created with a nonnil item an item is emitted the initial value and then the stream immediately completes and is then disposed Here are some logs to demonstrate this Observablefromoptional is broken subscribed Observablefromoptional is broken Event nextUser Observablefromoptional is broken Event completed Observablefromoptional is broken isDisposed Observablefromoptional is useful because I can have Observables with optional values eg say a logged in user that should be nil if there is no such user and would return an Observable user from Realm if it was not nil The other alternative right now would be to emit errors instead but this is not ideal Getting warnings for public func addO Objectupdate Bool false onError O Error Void nil AnyObserverO Warning addupdate is deprecated Pass error modified or all rather than a boolean error is equivalent to false and all is equivalent to true Removed public sentence from functions in order to avoid Xcode Warnings Keep things clean After updating to XCode Im receiving the following error and I cant build And Im also receiving Could not build ObjectC module RealmSwift Screen Shot at PM Use case I have a favorite button when its favorited I press it again it changes to unfavorite and removes the record When I refavorite it it should insert the object again but it accuses this error below Crash with error Project Terminating app due to uncaught exception RLMException reason Attempting to modify object outside of a write transaction call beginWriteTransaction on an RLMRealm instance first First throw call stack x babecec x b dbda x x x x aea x aeae libcabidylib terminating with uncaught exception of type NSException swift struct FavoriteTool private let disposeBag DisposeBag var didLoadFavorites Tool Void private let disposeBag DisposeBag var didLoadFavorites Tool Void func isFavoritefavoriteTool FavoriteTool ObservableResultsFavoriteTool return favoritesfilter id favoriteToolid func favoritefavoriteTool FavoriteTool if needSaveApi saveApifavoriteTool favoriteTool ObservablejustfavoriteTool subscribeRealmrxadd disposedby disposeBag func unfavoritefavoriteTool FavoriteTool favoritesfilter id favoriteToolid subscribeRealmrxdelete dispose func favoritesfilter predicateFormat String nil ObservableResultsFavoriteTool guard let realm try Realm else return Observableempty var results ResultsFavoriteTool realmobjectsFavoriteToolself if let predicate predicateFormat results resultsfilterpredicate return Observablecollectionfrom results Lets take the sample code from the readme let realm try Realm let laps realmobjectsLapself Observablechangesetfrom laps subscribeonNext results changes in if let changes changes its an update printresults printdeleted changesdeleted printinserted changesinserted printupdated changesupdated else its the initial data printresults The above code sets synchronousStart to true by default Here is the implementation of Observablechangesetfrom synchronousStart public static func changesetfrom collection E synchronousStart Bool true ObservableAnyRealmCollectionEElementType RealmChangeset return Observablecreate observer in if synchronousStart observeronNextcollectiontoAnyCollection nil let token collectiontoAnyCollectionobserve changeset in switch changeset case initiallet value guard synchronousStart else return observeronNextvalue nil case updatelet value let deletes let inserts let updates observeronNextvalue RealmChangesetdeleted deletes inserted inserts updated updates case errorlet error observeronErrorerror return return Disposablescreate tokeninvalidate If the database is modified continuously from a background thread it can happen that the database changes in between invoking code observeronNextcollectiontoAnyCollection nil and guard synchronousStart else return As a result one change is swallowed and the next change that is delivered by observeronNextvalue RealmChangesetdeleted deletes inserted inserts updated updates will be incompatible with the previously saved state of the collection in the view model Because of the lostswallowed change of the collection the incremental update of UITableView will crash the app if the change to be applied is not valid Invalid update etc The current workaround for me is to set synchronousStart to false So basically synchronous start with the current implementation does not work in some situation