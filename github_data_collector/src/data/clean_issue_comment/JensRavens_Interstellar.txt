 Hi Im huge fan of the project It is really well done and using it is a breeze Today Apple released Xcode with Swift and now we have Result type built into the language How do you think it influences the project Should it replace Interstellars Result type or would you like to keep them both by conforming to ResultType protocol I dont think its possible to silently update an observables value Such a usecase kinda poppedup for me today Do you think it makes sense to add it to Interstellars API I am wrapping URLSessionDataTask instances in Observable instances via code similar to that listed below I have removed the use of generics and replaced them with concrete types to hopefully make the example more clear swift Where the conversion of the datatask to the signal occurs func toObservableurl URL dataTaskToConvert URL ResultData Void ObservableResultData let signal ObservableResultData let value URLSessionDataTask dataTaskToConverturl result in signalupdateresult return signal Example API for consumer to make network requests without ugly callbacks func fetchurl URL ObservableResultData return toObservableurl url dataTaskToConvert fetch DataTask response handling is transformed to use an API with Interstellars Result type like so func fetchurl URL completion escaping ResultData Void URLSessionDataTask let task sharedUrlSessiondataTaskwith url data response error in if let data data completionResultsuccessdata return if let error error completionResulterrorerror return let sdkError SDKErrorinvalidHTTPResponseresponse response completionResulterrorsdkError taskresume return task Unfortunately I havent figured out a way to expose the underlying URLSessionDataTask to the client to cancel the request in a clean fashion I think ideally there would be somesort of method on the observable to stop the signal My workaround currently is to return tuple of URLSessionDataTask ObservableResultData rather than just the Observable so that the client can take advantage of the Observable API provided by Interstellar while also having the ability to cancel the request However I find the tuple API ugly to use as client code would look like the following swift must access the tuple element at index or named parameter fetchurl someURL then data in do stuff with data error handle error I am relatively new to the reactive style of programming so I am currently unable to figure out what a good strategy for disposing the observable and its underlying might be I looked into the section on Disposables in the README for ReactiveKit but Im not sure how the same concept would integrate with Interstellar Is there a way you might recommend cancelling the URLSessionDataTask I would be very happy to work on a pull request with a small bit of guidance to kick me off in the right direction if you think this feature might be useful Debounce seems to deliver the first skipped call to update instead of the last call to update I think this happens because the skipped calls to update are scheduled to be evaluated again without previous skipped calls being cancelled and are scheduled to be evaluated again very close to each other temporally Observabledelay uses DispatchQueueasyncAfter which isnt very precise so whichever one fires first usually the first one scheduled in my searchasyoutype use case will set the new lastCalled value and ignore the others skip result if there was a newer result if currentTimecomparelastCalled orderedDescending let s ObservableT sdelayseconds timeSinceLastCallsubscribeupdateIfNeededobservable supdatevalue In function subscribe public func subscribef ResultT Void SignalT if let value value fvalue mutexlock callbacksappendf return self it seems to me theres a potential data race access to value should be protected by the mutex Proposed solution public func subscribef ResultT Void SignalT var v ResultT mutexlock v selfvalue callbacksappendf if let value v fvalue return self Still this is not a reliable solution its not guaranteed that function f will be invoked before any other mapping function which is invoked due to an update These kind of issues can be solved only with introducing an execution context for example a dispatch queue which defines where the mapping function will be executed public func subscribeec ExecutionContext default f ResultT Void SignalT mutexlock if let value selfvalue ecexecAsync fvalue callbacksappendf return self Hi Jens Just a suggestion how about refactoring debounce to GCD source so that we can schedule and cancel when needed like and Merging multiple signals means you end up with a lops sided tuple Is there a better way to merge multiple signals let signal SignalHello signalmergeSignalworld mergeSignalhow are you mergeSignal next print Hello world how are you print world 