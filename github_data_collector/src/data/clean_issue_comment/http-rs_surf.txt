Closes Thanks wave Im looking to use surf to communicate with a unix domain socket and maybe a windows named pipe someday but not anytime soon I figured this would work out of the box since the default client seems to be based on libcurl and libcurl can handle unix sockets However to my dismay this seems to not work rust surfgetunixvarrundockersock v version Specifically it fails with logs like Jan DEBUG cleandockerapigetpathversion timeoutNone devloopexecutorsdocker URL for get will be unixvarrundockersock v version Jan DEBUG cleandockerapigetpathversion timeoutNone isahcagent agent waker listening on Jan DEBUG isahcagent agent took s to start up Jan DEBUG isahcagent agent ready Jan INFO cleandockerapigetpathversion timeoutNone surfmiddlewareloggernative sending request Jan DEBUG isahchandler initializing handler for request id Jan DEBUG isahccurl Protocol unix not supported or disabled in libcurl Jan DEBUG isahccurl Closing connection Jan DEBUG isahchandler curl error Unsupported protocol Jan WARN isahchandler request completed with error idAtomicCell value CurlUnsupported protocol Unsupported protocol Jan DEBUG isahcagent agent shutting down Jan WARN clean devloopexecutorsdocker Failed to reach out to docker engine api Failed to send docker API Request due to CurlUnsupported protocol Is there a known way to get this to work currently let res surfgetabcrecvstringdataawait As above this will cause the program to crash Continuation of to resolve In my commit I changed all instances of BoxError with Error I also added impl Froms for logSetLoggerError and stdioError rust use surfhttpStatusCode use surfResponse use serdeDeserialize Serialize pubcrate struct FreshAccounta pub username a str pub password a str deriveSerialize Deserialize struct LoginForma igsigkeyversion a str signedbody a str pubcrate async fn loginfresh FreshAccount Option str str printlnAttempting to login with credentials freshusername freshpassword let mut csrftoken str let mut sessionid str let uri str let freshuuid uuidUuidnewv tohyphenated let body String formatfa f be e c e a e d ba d f b a f e reglogin password deviceid username adid FE FD DCB AA E E E ED loginattemptcount phoneid freshpassword freshuuid freshusername freshuuid println printlnSigned body is body let mut res Response surfposturi setheaderAcceptLanguage enus en q setheaderAcceptEncoding gzip deflate br setheaderContentType applicationxwwwformurlencoded setheaderConnection keepalive setheaderUserAgent Instagram iPhone iOS enUS enUS scale gamutwide x AppleWebKit bodyform LoginFormigsigkeyversion signedbody bodyunwrapawaitexpectUnwrap for response of login request failed let status StatusCode resstatus println if status get from headers csrftoken csrftokenhere sessionid sessionidhere else printlnUnexpected status code statusasstr println resbodystringawaitunwrap Failed sessionid is empty Somecsrftoken sessionid Golang code Im getting a response code bad request golang is giving me a response code for the same request Rather than passing httpRequest and httpResponse through the middleware we should pass surfRequest and surfResponse through This should significantly reduce the API surface we expose and make it so folks no longer have to learn two different sets of APIs to write against Currently the middleware function is under Request I am trying to create and reuse a client a sign will be calculated base on the url path and query Is it possible that I can create a http client with applied middleware before know about any uri and http methods Basically its requestresponse interceptor for example rust let client surfClientnew let client clientmiddleware no middleware func exist in the client let request Request client the middleware func will be executed before sending out the request requestclientget Currently Surf doesnt have way to configure the client Instead it would be better if we can pass configured native client For example let nativeclient HttpClientbuilder do various configuration let client surfClientnewnativeclient let req clientget Using surf from cratesio rustc ea on Mac OS and this program rust asyncstdmain async fn main envloggerinit let rv surfget recvbytes await match rv Ok Erre println e I get of the time NoResponse as error However if I do curl on the commandline or use reqwest with tokio equivalently I do get the expected content I tried using the hyperclient feature but unfortunately that did not compile for me I currently have an httpheaderHeaderMap that I want to use with my surf request but Im having a lot of trouble getting this to work I tried a few approaches but for one reason or another they just arent feasible Accessing the internal httpRequest type doesnt work because surfRequestrequest returns a nonmutable reference It doesnt seem possible to do what surf does internally calling selfreqasmutunwrapheadersmutinsertkey value Iterating over the HeaderMap doesnt seem to work because surfRequestsetheader expects a static str for the key but my HeaderMap has a nonstatic lifetime Are there any suggestions on how this could be addressed I could use a different type in place of HeaderMap but I want to avoid this because surf will panic if the header value does not parse cleanly It seems like surf deliberately lacks this API because its more complicated than the current setheader API I totally agree but would it be possible to maybe add a surfRequestrequestmut or surfRequestsetheadersfrommap