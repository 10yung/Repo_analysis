Im kind of new to crosscompiling with rust but I managed to set up a foreign ruststd and also a gcc crosscompiler for linking Its all in cargos config cat cargoconfig targetarmv unknownlinuxgnueabihf linker armv aunknownlinuxgnueabihf how to reproduce git clone cd rustlibloading cargo build targetarmv unknownlinuxgnueabihf Updating cratesio index Compiling cc v Compiling libloading v tmprustlibloading error failed to run custom build command for libloading v tmprustlibloading process didnt exit successfully tmprustlibloadingtargetdebugbuildlibloadinga fce a fbuildscriptbuild exit code stdout cargorustclinklibdl TARGET Somearmv unknownlinuxgnueabihf OPTLEVEL Some HOST Somex unknownlinuxgnu CCarmv unknownlinuxgnueabihf None CCarmv unknownlinuxgnueabihf None TARGETCC None CC None CROSSCOMPILE None CFLAGSarmv unknownlinuxgnueabihf None CFLAGSarmv unknownlinuxgnueabihf None TARGETCFLAGS None CFLAGS None CRATECCNODEFAULTS None DEBUG Sometrue CARGOCFGTARGETFEATURE None running armlinuxgnueabihfgcc O ffunctionsections fdatasections fPIC g fnoomitframepointer marcharmv a Wall Wextra o tmprustlibloadingtargetarmv unknownlinuxgnueabihfdebugbuildlibloadingb a b cd outsrcosunixglobalstatico c srcosunixglobalstaticc stderr thread main panicked at Internal error occurred Failed to find tool Is armlinuxgnueabihfgcc installed homeusercargoregistrysrcgithubcom ecc db ec cc srclibrs note Run with RUSTBACKTRACE for a backtrace Could libloading provide a way to query a library to get the list of available symbols and functions I m working on a basic mage port to Rust and it would help if I could reflect over library entries rather than hardcode them As a workaround I m thinking of having my libraries adhere to a specific Rust trait which would itself offer methods for registering and querying symbols and functions But it would be cooler to do this dynamically rather than impose a structure on the plugins I use Return values from functions that contain static lifetimes are not reduced to the lifetime of the loaded library and can outlive it Preventing this is probably impossible especially when the static is hidden inside a type like Wrapper static u but the docs could warn about it Heres one example that segfaults Cargotoml toml package name unsafelibloading version lib path librs name loadee cratetype dylib bin name loader path mainrs dependencies libloading librs rust nomangle pub fn getstr static str Hello world mainrs rust extern crate libloading fn main libloadingResult let lib libloadingLibrarynewlibloadeeso let returnvalue static str let fun libloadingSymbolextern fn static str unsafe libgetbgetstr fun droplib printlnreturn value returnvalue Ok I assume this issue also applies to loaded global variables but dereferencing those produced bogus values even without dropping lib librs rust nomangle pub static REF static u mainrs rust extern crate libloading fn main libloadingResult let lib libloadingLibrarynewlibloadeeso let var libloadingSymbol static u unsafe libgetbREF let dereferenced u ref printlnvariable xx dereferenced dereferenced Ok prints variable x ab Operating system is Fedora uname r fc x When running cargo test multiple times sometimes test fails raising a segmentation fault rust test fn libloading let lib libloadingLibrarynewlibdltestsounwrap unsafe let testfn libloadingSymbolunsafe extern fni i libgetbtestunwrap asserttestfn test testlibloading error process didnt exit successfully homeUsertestlibloadingtargetdebugdepstestlibloadingb c df fd libloading signal SIGSEGV invalid memory reference But when this code runs in an executable crate It seems to run without the segfault even when I execute it multiple times rust fn main let lib libloadingLibrarynewlibdltestsounwrap unsafe let testfn libloadingSymbolunsafe extern fni i libgetbtestunwrap asserttestfn Im using libloading in a workinprogress large project theres a part of the projects design which necessitates returning a raw os symbol Unfortunately your library currently forces me to write the following cfgnotwindows use libloadingosunixSymbol as LibSymbol cfgwindows use libloadingoswindowsSymbol as LibSymbol Which is messier than Id like Could you please add a generic export of os symbols ie osraw to provide a cleaner import of the os symbols just like std does Thanks Most notably categories such as FFI could be specified macOS Sierra G This issue references the issue created for rustjson Sample Code is as follows Code for the dynamic library function is as follows macrouse extern crate json use jsonJsonValue nomangle pub fn methods JsonValue let rt array object fn method rt Code for my mainrs file is as follows extern crate json extern crate libloading as lib use stdenv use jsonJsonValue unsafe fn calldynamiclibname String libResult let dylib trylibLibrarynewlibname let findmethods libSymbolfn JsonValue dylibgetbmethods let funcs findmethods println funcs Ok fn main let args VecString envargscollect unsafe calldynamic args unwrap Hello Currently you can do Librarynew which loads a library For my use case it would be create to have Libraryopen that opens an already existing library Im trying to query optionally exported functions in preloaded shared library Implementation can be accomplished with the RTLDNOLOAD flag for dlopen on most unixes and GetModuleHandleEx in windows I can write the code myself and submit a PR if that works for you cargo build target asmjsunknownemscripten gave me the following output Compiling libloading v error failed to run custom build command for libloading v process didnt exit successfully homeyoongittrustfaterstargetdebugbuildlibloadingb c bb ef f buildscriptbuild exit code stderr Building for an unknown targetosemscripten Please report an issue Build failed waiting for other jobs to finish error build failed Admittedly loading dynamic libraries in Emscripten makes little to no sense so this should be expected I ran into this when trying to build my test project which depends on alsys from alto Im wondering what the desired behavior would be here My gut feeling is that libloading should still compile but produce noops but on the other hand the actual fix would probably to set libloading as an optional dependency of alsys