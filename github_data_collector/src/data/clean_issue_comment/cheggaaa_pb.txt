I want to add the break line between prefix and the progress bar Prefix to be like this Prefix my code go barPrefixfmtSprintf Prefix add n after this wont work barIncrement barBarEnd fmtSprintf vv barGet lentotal Many thanks I use to import this package from gopkgin but checking on the site the v is supported but if I try to update keeping gopkgin I got this nice error Command failed go get d go finding gopkgincheggaaapbv v go gopkgincheggaaapbv v gomod has nonv module path githubcomcheggaaapb at revision v go error loading module requirements There are some way to keep using gopkg Hey there wave I know that pb does not have any support for parallel exectuion but when running two dedicated applications in parallel the ioctl on devtty blocks which cause that they will never finish So when running this with a simple go run maingo works fine go package main import githubcomcheggaaapb func main pool pbNewPool pbProgressBar if err poolStart err nil return if err poolStop err nil return But running this application in parallel blocks and will never finish which should happen because both processes sharing the same devtty echo go run maingo commands echo go run maingo commands parallel commands wait I think this issue could be fixed with some system wide mutex but Im not sure if this is a nice solution When there is too many of bars the entire page rerenders at each interval which causes lagging and stuttering in the terminal screen I am looking for a hack to stop the rendering of completed bars Every exported function in a program should have a doc comment The first sentence should be a summary that starts with the name being declared From effective go PR generated by CodeLingo Install here to drive Continuous Higher Standards Im using v and its pretty OK when I have up to progress bars running concurrently However when it reachs the output starts stuttering and instead of overriding the current bars it simply prints new lines Whats happening doesnt look deterministic Im working on a concurrent file downloader application which simply requests chunks via byte serving And each concurrent unit is tasked to download MiB So if the target file is MiB there will be progress bars MiB for first MiB for the last chunk There is also a semaphore limiting the max concurrent workers to asciicast Here is the func main go func main fid uuidNewV String h err httpHeadlink if err nil panicerr defer h BodyClose if h StatusCode httpStatusOK panicHead request did not return with if h ContentLength panicContentLength is We dont welcome this This may mean that content is served in chunks and length is unknown else if h ContentLength panicThis content is smaller than MiB wont do files smaller than mib if acceptRanges h HeaderGetAcceptRanges acceptRanges bytes panicAcceptRanges header is not bytes Why Byte serving may not be available var bars pbProgressBar chunks findChunksinth ContentLength bufSize concurrency lenchunks for k v range chunks b pbNewvbufsize Prefix strconvItoak SetUnitspbUBYTES bars appendbars b pool err pbStartPoolbars if err nil panicerr ch makechan string concurrency sem makechan struct wg newsyncWaitGroup for i i concurrency i wgAdd sem struct go funci int defer func sem wgDone chunk chunks i bar bars i defer barFinish startRange chunkoffset if i if this is the first part of the demanded content the range start must be startRange Demanding partial content from upstream provider var r httpResponse req httpNewRequestGET link nil req httpNewRequestGET h RequestURLString nil reqHeaderSetRange fmtSprintf bytesdd startRange chunkoffsetchunkbufsize r err httpDefaultClientDoreq if err nil panicerr defer r BodyClose if r StatusCode httpStatusPartialContent panicfmtErrorfwasnt status code supposed to be but it was v r Status r Body barNewProxyReaderr Body Leftpadding the number of chunks with zeros so that they can be lexicographically ordered padCount lenstrconvItoaconcurrency Retrieving Swift authentication details using longlived Bearer token cnf home getSwiftConf home fid home fmtSprintf d padCount i Uploading the chunk to Swift req httpNewRequestPUT home r Body reqHeaderSetXAuthToken cnfToken r err httpDefaultClientDoreq if err nil panicerr defer r BodyClose ch home i wgWait poolStop closech for v range ch fmtPrintlnv fmtPrintln ndone Hello I created a quick project which takes avantage of pbs quick and easy to use API It can be found here I was thinking you could create a list of projects that use your library as in goinstas README Just a suggestion though Have a good day or night depends on your timezone pbStartPool failed Its seem to be that Finish method doing all magic in goroutine So when its finished it doesnt mean exactly that printing is finished too For example wgWait barFinish printlnDone printlnChecked N printlnCompleted N Sometimes it works exactly like expected s Done Checked N Completed N Sometimes its not Done Checked N Completed N s How to reproduce go bar pbNew barOutput osStderr barStart Run with shell myprogram output Expected Progress bar is drawn because output goes to Stderr and Stderr is a terminal Actual No progress bar is drawn only counters and percentage is shown