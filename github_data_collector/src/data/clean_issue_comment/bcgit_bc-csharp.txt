I m working on a Net application that is consuming BouncyCastle v We are considering migrating to NuGet PackageReferences But migrating the project that consumes BouncyCastle is failing because BouncyCastleCryptodll is directly in the lib folder of this package which is not supported as per above link section Assemblies in the lib root are ignored when the package is installed after the migration Is there a plan to repackage Bouncy Castle so that the dll is under the supported target frameworks sub folder BouncyCastle includes many symmetric encryption engines as well as RSA and ElGamal encryption engines asymmetric engines It also has a lot of online resources about how to use these engines to perform encryptiondecryption processes However a bouncy castle provides no Elliptic Curve engine After reviewing the code all asymmetric engines implement the AsymmetricBlockCipher interface and none of them is an EC engine There are some engines like IESEngine that provides a publicprivate EC agreement on top of the encryptiondecryption process eg ECDHBasicAgreement however it doesnt use the publicprivate keys directly instead it calculates a new symmetric key from both keys that are then used to encrypt the plaintext message using a predefined symmetric cipher Q How to implement a safe EC encryptiondecryption process using directly the ECKeyParameters generated using the above function if possible At the moment the key encryption algorithm when generating a cms envelope is taken from the subjectPublicKeyInfo of the recipients certificate It is not possible to set another padding scheme eg RSAESOAEP with parameters likesha mgf sha to the KeyTransferRecipient Meanwhile decryption of encrypted data within an cms envelope with this padding scheme created with NetCore is possible and works well I tried changing the key encryption algorithm hard coded to RSAOAEPWITHSHA ANDMGF PADDING And added the appropriate algorithm and parameters to the KeyTransferRecipient This seemed to work encryption parameters where set correctly encryption was possible Decryption worked with BC api like a charm But when validating with other libraries the encrypted data couldnt be decrypted OpenSSL NetCore My apologies if this isnt the right place to voice The file version for BouncyCastleCryptodll in the NuGet package is lower than the package When used as part of an installer this creates a problem where the older version will be left behind because its a highernewer version or removed entirely weird decadelong MSI upgrade bug Honestly not much you can do about it now and were going to solve our installation issue by sticking to the release until hits I just figured Id mention it since its very likely going to impact anyone who creates installers and followed the to upgrade path as we did Thanks for all your work on this project Bryan Test Name TestFunction Test FullName UnitTestsOrgBouncyCastleAsn TestsAsn IntegerTestTestFunction Test Source C Projects GitHub bccsharp crypto test src asn test ASN IntegerTestcs line Test Outcome Failed Test Duration Test Name TestFunction Test Outcome Failed Result StackTrace at OrgBouncyCastleAsn TestsAsn IntegerTestTestFunction in C Projects GitHub bccsharp crypto test src asn test ASN IntegerTestcsline Result Message Expected string length but was Strings differ at index Expected Asn Integer Okay But was Asn Integer no message Does BC support any of the methods of Format Preserving Encryption or are there any better options Hi faced some issue with Gost signature verification For example for such signature signaturewithfilezip If I call SignerInformationVerifysignerCert it throws SecurityUtilityException WITH not recognised Bouncy castle doesnt know anything about Gost signature algorithm widespread oids so it cant create DigestSigner object with correct signer and digest at SignerUtilitiesGetSigner In PR I add this correct mappings By the way if such configuration can be done by library user It would be perfect When i use encrypt with key store in memory stream in C var keyStream new MemoryStreamEncodingUTF GetBytesPublic key var publicKeyStream PgpUtilitiesGetDecoderStreamkeyStream var pgpObjectFactory new PgpObjectFactorypublicKeyStream var gpgObject pgpObjectFactoryAllPgpObjects return null Key file like this BEGIN PGP PUBLIC KEY BLOCK Version GnuPG v END PGP PUBLIC KEY BLOCK gpgObject is null since i can get key with command line and encrypt successfully gnupg Hi Im trying to connect to server using TLS The first handshake is OK and connection is established but when I send first HTTP request the server sends HandshakeTypehellorequest in response server probably wants to send HandshakeTypecertificaterequest in order to authenticate client and return response But client sends RefuseRenegotiation and server returns handshakefailure So instead of RefuseRenegotiation I tried this code SendClientHelloMessage thismConnectionState CSCLIENTHELLO BlockForHandshake It doesnt work I get handshakefailure as well Can you give me any tips how to implement renegotiation Thanks for your great work The EVPCipherUpdate of OpenSSL is able to do this