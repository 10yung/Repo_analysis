This is starting as a followup to but is intended to perform as many moving to asyncawait as possible in the places that would benefit from it checkruntime should only complain if the runtime has changed and the same spec impl version were used in a release tag We want the finalized chain to strongly imply availability in an honest case and for the longest chain to be the most available chain Well say that a relay chain block is availabilityprepared by a validator when the validator has its availability piece for every parablock referenced in the block Well say that a relay chain is availabilityprepared by a validator when every block in that chain is availabilityprepared by that validator up to some relatively large N blocks before the chain head In the past weve proposed rules for validators to alter their chainselection rules for GRANDPA voting and block construction Validators will vote only on chains that they have availabilityprepared Validators will build only on chains whose kprefix The chain computed by omitting the last k blocks from the target chain they have availabilityprepared Nodes that observe a doublevote in the attestation process should submit a report to the chain to trigger slashing The polkadotstatementtable crate already detects doublevotes at least during the blockbuilding phase It generates Misbehavior objects which could be turned into report transactions and sent onchain This would also benefit from keeping the StatementTable and gossip object live for a longer period of time to continue to fish for doubleattestations that are filed after that attestation session is no longer live This codepath is also taken by validators who selfselect based on VRF Availability and Validity Research at W F Validators and fishermen will select parachain blocks to revalidate In these steps Attempt to recover the PoV block falling back on the erasurecoding If not available issue report Attempt to validate the PoV block If invalid issue report This issue should implement an asynchronous fishing service which runs in the background to automatically spawn fishing work In the attestation process validators may submit only one Candidate message for a given relay chain block If issuing a Candidate message on a parachain block neither a Valid or Invalid vote cannot be issued on that parachain block as the Candidate message is an implicit validity vote Otherwise it is illegal to cast both a Valid and Invalid vote on a given parachain block Runtime handlers that take two conflicting votes as arguments and slash the offender are needed In Polkadot a bad parachain group can force inclusion of an invalid or unavailable parachain block It is the job of fishermen to detect those blocks and report them to the runtime This item is about the report handler in the runtime which aggregates votes foragainst validity of a particular parablock and slashes the relevant parties The W Fresearch writeup on availabilityvalidity provides a highlevel view of the dispute resolution process Availability and Validity Research at W F One of the main behaviors that is unimplemented and needs to be is the rollback that occurs when the dispute resolution process concludes that an error has been made When we mark a parachain block as having been invalid or unavailable we need to roll back all parachains to a point from just before this state We would also need to roll back relay chain state because there may have been messages from a parachain to a relay chain that now need to be rolled back The easiest thing to do would be to sidestep that by putting a delay on upwards messages but this would impact the UX of parachain participation in slot auctions council votes etc considerably Assuming we cant sidestep this we will have to find a way to roll back selected state of the relay chain The PovBlock or ProofofValidity block contains all the data you need to validate a parablock It will need to contain stateproofs of incoming message queues and potentially outgoing ones as well Libp p enables users to define custom protocols by implementing the NetworkBehaviour trait These custom protocols use a substream via whatever multiplexing solution libp p uses for a connection It would be useful to pass the ability to define custom protocols through Substrate up to code within Polkadot Related work having the gossip system open custom substreams Substrate by default does not differentiate between node roles eg validator sentry lightclient when choosing who to connect to One can enable the authority discovery module with which a node tries to connect to a set of validators or their sentry nodes As of today every information is broadcasted to everyone This wont scale in the long run Thus we will need to introduce the notion of multicast to subgroups within the network based on roles To do so it becomes more and more important to connect to the right set of nodes Eg a collator should connect to its validator but probably not to collators of other parachains