I already posted this as a question on stackoverflow but I thought maybe I could get help here I was trying to follow this tutorial by GoRails to add an autocomplete feature to my Rails app After following the tutorial I got the search bar to work as he demonstrates in the video but now whenever I click on a link in my app my url changes accordingly but I see this page If I refresh the page the app directs me to the page that the url shows Even if I comment out the js files for easyautocomplete and I leave these lines in the head of my applicationhtmlerb in layouts I still see the problem stylesheetlinktag application media all dataturbolinkstrack reload stylesheetpacktag application media all dataturbolinkstrack reload javascriptpacktag application dataturbolinkstrack reload If I get rid of the requireturbolinksstart in my applicationjs then the problem goes away but I still want to use turbolinks requirerailsujsstart requireturbolinksstart requirerailsactivestoragestart requirechannels requirejquery require jquery require popper require bootstrapsprockets require jqueryeasyautocomplete Also I see this error in my browser console I also created a sample app that also has the same problem in this repository Im using ruby and rails In its current state I commented out the lines linking the css and js files to easyAutocomplete and the problem persists unless I disable turbolinks by commenting out turbolinks in applicationjs Turbolinks is working great Thanks for the library Im using the progress bar but I notice that on restoration visits from cache the user presses back page displays instantly progress bar appears progress bar disappears page looks exactly as in step So for the user its confusing since it looks like the page is ready and then the bar appears Is this the intended way it should behave Is there a way to not show the progress bar on restoration visits Bumps handlebars from to details summaryChangelogsummary Sourced from handlebarss changelog v November th Bugfixes fix add noprototypebuiltins eslintrule and fix all occurences f f d fix add more properties required to be enumerable Chores Build fix use instead of c b f add chai and dirtychai and sinon for cleaner testassertions and spies deprecate old assertionmethods e e ba dad a Security The properties proto defineGetter defineSetter and lookupGetter have been added to the list of properties that must be enumerable If a property by that name is found and not enumerable on its parent it will silently evaluate to undefined This is done in both the compiled template and the lookuphelper This will prevent new RemoteCodeExecution exploits that have been published recently Compatibility notes Due to the securityfixes The semantics of the templates using proto defineGetter defineSetter and lookupGetter in the respect that those expression now return undefined rather than their actual value from the proto The semantics have not changed in cases where the properties are enumerable as in js proto some string The change may be breaking in that respect but we still only increase the patchversion because the incompatible usecases are not intended undocumented and far less important than fixing RemoteCodeExecution exploits on existing systems Commits v November th Bugfixes fix use Stringfield in lookup when checking for constructor d test add fluent API for testing Handlebars c ac c Compatibility notes no incompatibility are to be expected trtable truncated details details summaryCommitssummary c c b v c d Update release notes f f d fix add noprototypebuiltins eslintrule and fix all occurences fix add more properties required to be enumerable ba testchore add chaiexpect and sinon to runtimeenvironment dad test add sinon as global variable to eslint in the specs a test add sinonjs for spies deprecate current assertions e e chore add chai and dirtychai for better test assertions c b f fix use instead of de d v Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details Hello Im using the Olark chat with turbolinks into a Rails application and the issue is that turbolinks does not take into account the chat inserted with JS into an iframe after render the page how could tell turbolinks to start caching after load the chat Olark has this event apichatonready to detect when the Olark chatbox has loaded I was thinking about store the chat into the turbolinks cache but it is not working Any idea Hi I recently starded using turbolink with bootstrap but Im facing a couple of issues I followed the documentation and tried several solutions but i still have some issue since the exclusive behavior of turbolinks on a webpage I dont fully understand if the problem is unexpected or if I missed some configuration I have a page with checkbox and radio buttons Normally if I go back and forth from the page the selections are remembered by the browser but since I added turbolinks each time I go back to that page I see the active checkmark for a second and then they disappear then if I refresh the page the checkmarks are restored Since Im using bootstrap with a pure javascript library bootstrapnative I tried moving it into the head of the document with defer but every animation or behavior are ignored if you click on a checkbox bootstrap add an active class to the element but if I put the js in the head it does not work can you help me understandig and possibly fix this behavior thank you Hi We use turbolinks with turbolinkscachecontrolnopreview The error only happens when you have more javascript to be executed when going to a page When you go back in history and then very quickly go forward with the browser button while the javascript is still executed then you stay on the page but the url changes correctly base href is not considered when evaluating new script tags in the head that werent in the previous page This is causing the script to try and load from the wrong location if the script src is relative and relying on base href to pick up correct relativeness Turbolinks initialisation currently breaks the default refresh behaviour when its run after a POST submission A POST followed by a refresh should trigger an Are you sure confirm dialog whereas with Turbolinks installed it just reloads the existing location with a GET When starting up Turbolinks stores the initial location and restoration identifier in the session history by calling replaceState This standardises the way to retrieve a restoration identifier on any popstate event However according the to the spec If the state push flag is not set update the current entry in browsingContexts session history so that it represents a GET request if it currently represents a nonGET request eg it was the result of a POST submission So when a page loads after a POST Turbolinks replaces the current entry with a GET to the same location and therefore will not rePOST or display a confirm dialog upon refresh This pull request tweaks initialisation to store the initial restoration identifier and location as properties on the History instance avoiding the need to use replaceState When the history is popped to the initial entry eventstate will be null and by asserting that the existing location matches the stored initial location the restoration identifier is retrieved accordingly Pops to noninitial entries will be handled as before Fixes Fixes This is observed in Chrome and Firefox which comply with the spec Safari behaves as we want but does not comply with the spec PWAs usually include a back link inside the UI The back link doesnt use the browser history but the structure of the content eg link to parent category Some might argue that because Android provides a back button through the device itself then there is no need to replace the browser s back functionality In fact the two interactions do different things Most apps continue to offer a back button in the header as an up action to navigate within the hierarchical relationship between pages The system s back functionality might close a modal window or navigate to a different app entirely Turbolinks should provide a way to trigger a restoration without an additional server request when the back link is clicked even if the link doesnt use the browser history Basically it would be useful to annotate a link eg dataturbolinksactionrestore and have it restore the content if exists without additional server requests Related I decided to open a new issue since the other is very old and doesnt consider the erging patterns of PWAs See If progress delay is configured to be less than ms then subsequent requests before previous request has finished will intermittently hide the progress bar IE User clicks link before link finishes clicks a different link etc We have opted to have no delay and show the progress bar on every request and solved the above with windowTurbolinksProgressBarprototypefadeProgressElement functioncallback thisprogressElementstyleopacity callback 