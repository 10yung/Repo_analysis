See image I think you forget to release GCmallocheapl global object I got error when i compile guile for riscv More logs can be found here guilesnarfdocs o regexposixdoc regexposixc DHAVECONFIGH DBUILDINGLIBGUILE I I Ilib Ilib IbuilddirbuildBUILDguile Os fomitframepointer gdwarf Wstrictaliasing pipe Wformat Werrorformatsecurity DFORTIFYSOURCE fstackprotectorstrong paramsspbuffersize marchrv imafdc mabilp d flto cat alistdoc arrayhandledoc arraymapdoc arraysdoc asyncdoc atomicdoc backtracedoc booleandoc bitvectorsdoc bytevectorsdoc charsdoc controldoc continuationsdoc debugdoc deprecateddoc deprecationdoc dynldoc dynwinddoc eqdoc errordoc evaldoc evalextdoc expanddoc extensionsdoc fdesfinalizersdoc featuredoc filesysdoc fluidsdoc foreigndoc fportsdoc gcmallocdoc gcdoc gettextdoc generalizedarraysdoc generalizedvectorsdoc goopsdoc gsubrdoc guardiansdoc hashdoc hashtabdoc hooksdoc i ndoc initdoc ioextdoc keywordsdoc listdoc loaddoc macrosdoc mallocsdoc memoizedoc modulesdoc numbersdoc objpropdoc optionsdoc pairsdoc portsdoc printdoc procpropdoc procsdoc promisesdoc r rsportsdoc randomdoc rdelimdoc readdoc rwdoc scmsigsdoc scriptdoc simposdoc smobdoc sortdoc srcpropdoc srfi doc srfi doc srfi doc srfi doc srfi doc stackchkdoc stacksdoc stimedoc stringsdoc strorderdoc strportsdoc structdoc symbolsdoc syntaxdoc threadsdoc throwdoc treesdoc unicodedoc uniformdoc valuesdoc variabledoc vectorsdoc versiondoc vportsdoc weaksetdoc weaktabledoc weakvectordoc dynldoc posixdoc netdbdoc socketdoc regexposixdoc GUILEAUTOCOMPILE metabuildenv guild snarfcheckandoutputtexi guileprocedurestexi rm guileprocedurestexi false BUILDSTDERR Insufficient memory for main localmarkstack BUILDSTDERR binsh line Broken pipe cat alistdoc arrayhandledoc arraymapdoc arraysdoc asyncdoc atomicdoc backtracedoc booleandoc bitvectorsdoc bytevectorsdoc charsdoc controldoc continuationsdoc debugdoc deprecateddoc deprecationdoc dynldoc dynwinddoc eqdoc errordoc evaldoc evalextdoc expanddoc extensionsdoc fdesfinalizersdoc featuredoc filesysdoc fluidsdoc foreigndoc fportsdoc gcmallocdoc gcdoc gettextdoc generalizedarraysdoc generalizedvectorsdoc goopsdoc gsubrdoc guardiansdoc hashdoc hashtabdoc hooksdoc i ndoc initdoc ioextdoc keywordsdoc listdoc loaddoc macrosdoc mallocsdoc memoizedoc modulesdoc numbersdoc objpropdoc optionsdoc pairsdoc portsdoc printdoc procpropdoc procsdoc promisesdoc r rsportsdoc randomdoc rdelimdoc readdoc rwdoc scmsigsdoc scriptdoc simposdoc smobdoc sortdoc srcpropdoc srfi doc srfi doc srfi doc srfi doc srfi doc stackchkdoc stacksdoc stimedoc stringsdoc strorderdoc strportsdoc structdoc symbolsdoc syntaxdoc threadsdoc throwdoc treesdoc unicodedoc uniformdoc valuesdoc variabledoc vectorsdoc versiondoc vportsdoc weaksetdoc weaktabledoc weakvectordoc dynldoc posixdoc netdbdoc socketdoc regexposixdoc BUILDSTDERR Aborted core dumped GUILEAUTOCOMPILE metabuildenv guild snarfcheckandoutputtexi guileprocedurestexi BUILDSTDERR make Makefile guileprocedurestexi Error I noticed that when I start guile inside gdb I see a bunch of threads When I break on pthreadcreate I see they come from the GC gdb bt x ffff a in pthreadcreateGLIBC from lib libpthreadso x ffff afee in GCstartmarkthreadsinner at pthreadsupportc However the threads show up in gdb like gdb info thread Id Target Id Frame Thread x ffff fd LWP guile x ffff d in pthreadcondwaitGLIBC from lib libpthreadso Thread x ffff efc LWP guile x ffff d in pthreadcondwaitGLIBC from lib libpthreadso I think it would be nice if the GC set the names of these threads to something like GC On Linux and macOS this can be done with pthreadsetnamenp though be warned that the function takes different arguments on these platforms As reported on iOS app could be rejected in the AppStore because of excserver nonpublic symbol use This symbol is used in the incremental GC mode so the quick workaround is to build the collector with GCDISABLEINCREMENTAL macro defined In the long term it would be good to investigate and propose the change to the Darwin incremental GC mode support which is free of use of iOS undocumented API On RISCV we got this error when compiling with gcc and ldbfd while on other arches ldbfd did the trick full logs binsh libtool tagCC modelink usrbingcc fexceptions Wall Wextra Wpedantic Wnolonglong Os fomitframepointer gdwarf Wstrictaliasing pipe Wformat Werrorformatsecurity DFORTIFYSOURCE fstackprotectorstrong paramsspbuffersize marchrv imafdc mabilp d fuseldbfd fnostrictaliasing versioninfo noundefined Os fomitframepointer gdwarf Wstrictaliasing pipe Wformat Werrorformatsecurity DFORTIFYSOURCE fstackprotectorstrong paramsspbuffersize marchrv imafdc mabilp d fuseldbfd WlO Wlnoundefined o libgcla rpath usrlib allchblklo alloclo blacklstlo dbgmlclo dynloadlo finalizelo gcdlopenlo gcjmlclo headerslo machdeplo malloclo mallocxlo marklo markrtslo misclo newhblklo objmaplo osdeplo ptrchcklo reclaimlo specificlo typdmlclo pthreadstartlo pthreadsupportlo pthreadstopworldlo threadlocalalloclo fnlzmlclo lpthread ldl latomicops libtool link usrbingcc shared fPIC DPIC libsallchblko libsalloco libsblacklsto libsdbgmlco libsdynloado libsfinalizeo libsgcdlopeno libsgcjmlco libsheaderso libsmachdepo libsmalloco libsmallocxo libsmarko libsmarkrtso libsmisco libsnewhblko libsobjmapo libsosdepo libsptrchcko libsreclaimo libsspecifico libstypdmlco libspthreadstarto libspthreadsupporto libspthreadstopworldo libsthreadlocalalloco libsfnlzmlco lpthread ldl latomicops fexceptions Os fomitframepointer gdwarf pipe fstackprotectorstrong paramsspbuffersize marchrv imafdc mabilp d fuseldbfd fnostrictaliasing Os fomitframepointer gdwarf pipe fstackprotectorstrong paramsspbuffersize marchrv imafdc mabilp d fuseldbfd WlO Wlnoundefined Wlsoname Wllibgcso o libslibgcso make Leaving directory builddirbuildBUILDgc BUILDSTDERR usrlib gccriscv openmandrivalinuxgnu riscv openmandrivalinuxgnubinldbfd libsdynloado in function GCregisterdynamiclibrariesdliteratephdr BUILDSTDERR builddirbuildBUILDgc dynloadc undefined reference to datastart BUILDSTDERR usrlib gccriscv openmandrivalinuxgnu riscv openmandrivalinuxgnubinldbfd builddirbuildBUILDgc dynloadc undefined reference to datastart BUILDSTDERR usrlib gccriscv openmandrivalinuxgnu riscv openmandrivalinuxgnubinldbfd libsosdepo in function GCgetstackbase BUILDSTDERR builddirbuildBUILDgc osdepc undefined reference to datastart BUILDSTDERR collect error ld returned exit status BUILDSTDERR make Makefile libgcla Error BUILDSTDERR make Makefile allrecursive Error BUILDSTDERR error Bad exit status from vartmprpmtmpHaSj build Build Target Windowsx How to build cmake DbuildtestsON DenablecplusplusON DenablelargeconfigON DCFLAGSEXTRADNOMSGBOXONERROR cmake build config Release ctest buildconfig Release I have some doubts regarding how to make custom mark algorithms My goal is to have an array structure that has a pointer to the buffer void ptr the number of elements stored in the buffer int size Elements will be stored from ptr to ptr size Although the capacity of the buffer is stored somewhere that has no role in the marking algorithm I was able to register a custom type and function to be used by the algorithm But I am having problems writing a good algorithm inside of it Ive based some of my work in As far I as understand I need to Call GCsetmarkbit for the pointer to the buffer ptr This call MUST happen around via a GCcallwithalloclock For each ptr i i size use the GCMARKANDPUSH macro and keep the returned value as the updated markstackptr Calls to GCMARKANDPUSH does not need to be around the GCcallwithalloclock of Return the updated markstackptr from the mark algorithm Questions Are these assumptions and description accurate Ive found so far lots of contingencyslow down while trying to get the alloc lock via GCcallwithalloclock I wouldve expected to be able to use GCpushall for the whole ptr size range at once instead of manually iterating the array but since Ive found no example doing that I wonder if that is correctdoable Regarding If calling GCpushall is correct I am not sure how to guarantee the precondition mentioned in the docs Should only be used if there is no possibility of mark stack overflow Since this is to implement a base structure heavily used I want to make it as fast as possible Any recommendation and guidance are appreciated Thanks Build link Host Linuxx Source How to reproduce configure enableredirectmalloc enablegcdebug enablecplusplus enablegcassertions make check When I do not define GCDEBUG before include gch my program runs as expected But I want to debug and print backtraces so I define GCDEBUG In gdb I put a breakpoint at GCfinishcollection when it breaks I print info about a certain object The debugger shows me that it is reachable by printing a trace when I do print GCprintbacktraceobject address and shows me that it is marked as when I do GCismarkedobject address gdb p GCprintbacktrace x ffff e a b x ffff e a b examplesresnet imagenetc sz NORMAL Call chain at allocation homeahmed bdwgclibslibgcso x fae x fffeb ebfae homeahmed checkpointvladexamplesresnet imagenet x x e homeahmed checkpointvladexamplesresnet imagenet xa ca x f ca homeahmed checkpointvladexamplesresnet imagenet x adaf x dedaf homeahmed checkpointvladexamplesresnet imagenet x be x d be homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef Reachable via levels of pointers from offset in object x ffff ec a examplesresnet imagenetc sz NORMAL Call chain at allocation homeahmed bdwgclibslibgcso x fae x fffeb ebfae homeahmed checkpointvladexamplesresnet imagenet x da x aada homeahmed checkpointvladexamplesresnet imagenet x be x d be homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef Reachable via levels of pointers from offset in object x ffff ec examplesresnet imagenetc sz NORMAL Call chain at allocation homeahmed bdwgclibslibgcso x fae x fffeb ebfae homeahmed checkpointvladexamplesresnet imagenet x abc x abc homeahmed checkpointvladexamplesresnet imagenet x be x d be homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef Reachable via levels of pointers from offset in object x ffff ec b examplesresnet imagenetc sz NORMAL Call chain at allocation homeahmed bdwgclibslibgcso x fae x fffeb ebfae homeahmed checkpointvladexamplesresnet imagenet xee x homeahmed checkpointvladexamplesresnet imagenet x be x d be homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef Reachable via levels of pointers from offset in object x ffff ec d examplesresnet imagenetc sz NORMAL Call chain at allocation homeahmed bdwgclibslibgcso x fae x fffeb ebfae homeahmed checkpointvladexamplesresnet imagenet x ce c x c homeahmed checkpointvladexamplesresnet imagenet x be x d be homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef homeahmed checkpointvladexamplesresnet imagenet x b x ef Reachable via levels of pointers from root at x fffffffc gdb p GCismarkedGCbase x ffff e a b But when then I do gdb p GCdumpfinalization Disappearing short links Disappearing long links Finalizers Finalizable object x ffff e a b Finalizable object x ffff e e void It shows that the object is finalizable And I hit continue and that object gets collected instantly Although there is references to it as shown by the print backtrace Host Cygwin Windows x Source master a Occurence always How to reproduce gcc I include I libatomicopssrc O D GCASSERTIONS D GCTHREADS D NOEXECUTEPERMISSION D THREADLOCALALLOC g teststestc extragcc GCENABLEINCREMENTAL aexe Output Switched to incremental mode Emulating dirty bits with mprotectsignals nothing else exit is called from pthreadexit which is invoked threadinitwrapper newlibcygwinwinsupcygwinthreadcc if InterlockedDecrement MTINTERFACEthreadcount exit Not observed if no incremental mode or if no threadlocalalloc