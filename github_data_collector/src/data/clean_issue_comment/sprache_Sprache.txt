Hi there I want to use Sprache referenced from an strong named assembly No I get an error because the assembly has not a strong name signature Is it possible to get the assembly in a short time with a strong name thanks a lot Exponentiation is right associative so InnerTerm should be declared with ChainRightOperator instead of ChainOperator I m handling some nested IOption results Unfortunately OptionExtensions does not offer Select so I wanted to write that extension myself Unfortunately since SomeNone are internal I would have to implement my own classes This seems like unnecessary overhead to overcome the IsDefined and Get cascades Can we make at least Some and None public Then I can do cs public static IOptionU SelectTthis IOptionT o FuncT U f oIsDefined IOptionU new SomeUfoGet new NoneU Many thanks It often happens that a parser needs to advance the input by more than just position A good example of such builtin parser is ParseRegex but I also have some of my own could make use of it Calling Advance multiple times in a loop causes a lot of completely unnecessary allocations that can be easily avoided I implemented this in the least obtrusive way in my opinion There are also options to use an optional parameter instead of an overload not backwards compatible or make an extension method that uses the internal constructor of Input dirty hack SAMPLE PROJECT Whats the reason of this line throw new ParseExceptioniMemos p ToString It broke my parser When I changed it to return IResultTiMemos p everything started work as expected What if I dont have delimiter but only flatfile style fixedlength string Imagine getting data from a Tcp stream like this for example j vT A BOSH APV I cannot reliably rely on a delimiter here The string above represents a message received from a server with following meaning byte long message length j THIS IS HEX value byte long message id v THIS IS HEX value the rest of values below are ASCII byte long message type T byte long message sequence byte long car Id A byte long part price byte long part manufacturer BOSH byte long part byte long part price byte long part manufacturer APV byte long part How to parse message like this When do we have to use ParseRef I looked at the exmples but could not understand the use case of ParseRef Does it make the parsing faster or slower Does it save space Implemented DelimitedBy with optional minimum and maximum count parameters Also refactored Repeat method a bit Tests are done