I am trying to write NAPI rust wrapper for nodejs native bindings and when I poll future in libuv async callback Segmentation fault happened core dump error need to add support for DWTAGbasetype encoded with DWATE x bitsize thread stop reason signal SIGSTOP frame x b c frame x d a testmodulenodeLTcoretaskwakeWakeru asu corecloneCloneGTcloneh d f b c cf self x ffeefbfd at wakers frame x d fe testmodulenodefuturescoretaskinternalatomicwakerAtomicWakerregisterh db c a f self x b e waker x ffeefbfd at atomicwakerrs frame x d a testmodulenodeLTfutureschannelmpscReceiverLTTGTu asu futurescorestreamStreamGTpollnexth e af d f selfPin mut futureschannelmpscReceiverusize x ffeefbf af cx x b f at modrs frame x d a da testmodulenodeLTfutureschannelmpscUnboundedReceiverLTTGTu asu futurescorestreamStreamGTpollnexthbd e b eselfPin mut futureschannelmpscUnboundedReceiverusize x ffeefbf ba cx x b f at modrs frame x d a e testmodulenodeLTfuturesutilstreamstreamforeachForEachLTStCFutCFGTu asu corefuturefutureFutureGTpollha cbb c e selfPin mut futuresutilstreamstreamforeachForEachfutureschannelmpscUnboundedReceiverusize futuresutilfuturereadyReady closure x ffeefbf c cx x b f at foreachrs frame x d testmodulenodefuturesutilfuturefuturechainChainLTFut CFut CDataGTpollh fb a d selfpointer x b f cx x b f fclosure x ffeefbf e at chainrs frame x d testmodulenodeLTfuturesutilfuturefuturethenThenLTFut CFut CFGTu asu corefuturefutureFutureGTpollh de b b b selfPin mut futuresutilfuturefuturethenThenfuturesutilstreamstreamforeachForEachfutureschannelmpscUnboundedReceiverusize futuresutilfuturereadyReady closure futuresutilfuturereadyReady closure x ffeefbf cx x b f at thenrs frame x d f c testmodulenodenapirsexecutorpollfutureh e bd daf dhandle x b e at executorrs frame x bc nodeuvasyncio frame x a a nodeuviopoll frame x ffe nodeuvrun frame x b nodenodeNodeMainInstanceRun frame x c nodenodeStartint char frame x fff d f fd libdylddylibstart frame x fff d f fd libdylddylibstart It could reproduce in napirs macos cargo build cp targetdebuglibtestmoduledylib testmodulenode node testmoduletestsjs linux cargo build cp targetdebuglibtestmoduleso testmodulenode node testmoduletestsjs windows cargo build cp targetdebuglibtestmoduledll testmodulenode node testmoduletestsjs Follow up from This adds two impls implR AsyncWrite AsyncWrite for BufReaderR implW AsyncRead AsyncRead for BufWriterW The motivation is that you often want to do something like BufReadernewBufWriternewsocket If you have two futures and just want to get the result of whichever resolves first and drop the other you can use futuresfutureselect but its a little verbose It may be worth adding a simple wrapper that does this naming inspired by asyncstds function of the sameish signature rust pub async fn raceTa impl FutureOutput T b impl FutureOutput T T futurespinmuta futurespinmutb futuresfutureselecta bawaitfactorfirst Making a minimal example took a while because I could not reproduce it at first due to the very narrow circumstances that triggers this error I dont know exactly what these circumstances are but my best guess is asserteq inside futuresselect however only when asserting equivalence of bools and not Strings as explained further down Cargotoml toml package name reproduce version authors Erlend Langseth rledhlgmailcom edition dependencies Actix actixweb actixrt actixhttp Serde serde version features derive serdejson Other futures srcmainrs rust use actixhttphttpStatusCode use futuresFutureExt select use serdeSerialize Deserialize use actixweb testTestServer App use std timeDuration deriveSerialize Deserialize struct Foo a String impl Foo pub fn getid self str selfa pub fn issuccess self bool true macrorules responsetostring responseexpr stdstrfromutf responsebodyawaitunwrapasref unwrap tostring macrorules assertstatus responseexpr expectedstatusexpr if responsestatus expectedstatus panic Expected status got nBODY expectedstatus responsestatus responsetostringresponse macrorules createtestserver srvident let srv actixwebteststart move Appnew async fn polloperationuntildoneid String srv TestServer Foo loop now poll operation let mut response srvgetformatadminv operations id send awaitunwrap match responsestatus StatusCodeOK return responsejsonFooawaitunwrap StatusCodeNOTFOUND ok not finished yet status panicUnexpected HTTP status code status assertstatusresponse StatusCodeOK actixrttimedelayforDurationfrommillis await actixrttest async fn testdeletearticles createtestserversrv macrorules runtest shouldsucceedexpr let mut response srvpostapiv lala sendjson Foo a abctostringawaitunwrap assertstatusresponse StatusCodeOK let id responsejsonFooawaitunwrapgetidtoowned select opinfo polloperationuntildoneid srvfuse asserteqopinfoissuccess shouldsucceed line actixrttimedelayforDurationfromsecs fuse panictimeout reached runtestfalse fn main Running it with cargo c tests we get the error error E cannot find value id in this scope srcmainrs runtestfalse not found in this scope in this macro invocation note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info help possible candidate is found in another module you can import it into scope use stdprocessid look below for more output Now a small change I found that could fix this error is to replace line annotated with a comment with asserteqopinfoa heyhey So definitely something strange is going on this line doesnt even have anything to do with id Appendix Maybe its useful with the output of RUSTFLAGSZ externalmacrobacktrace cargo c tests error E cannot find value id in this scope futuresutilasyncawaitselectmodselect macros procmacro tt derive crate procmacrohackselect enum ProcMacroHack not found in this scope in this expansion of procmacrocall Nested stringify procmacro crate procmacrocallselect procmacro in this macro invocation in this expansion of crateinnermacroselect srcmainrs macrorules runtest shouldsucceedexpr let mut response srvpostapiv lala sendjson Foo a abctostringawaitunwrap select opinfo polloperationuntildoneid srvfuse asserteqopinfoissuccess shouldsucceed actixrttimedelayforDurationfromsecs fuse panictimeout reached in this macro invocation in this expansion of runtest runtestfalse in this macro invocation procmacronesteddispatch macros bang tt crate count bang in this macro invocation first tt rest tt bang tt crate dispatch first rest bang in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation first tt rest tt bang tt crate dispatch rest bang in this macro invocation in this macro invocation first tt rest tt bang tt crate dispatch rest bang in this expansion of crateprocmacrocallselect in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this expansion of cratedispatch in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation in this macro invocation procmacronestedcount macros procmacrocall procmacrocall procmacrocall procmacrocall in this macro invocation procmacrocall procmacrocall procmacrocall procmacrocall in this expansion of cratecount futuresselect macros tokens tt crate innermacro select futurescratepath futures tokens in this macro invocation in this expansion of select help possible candidate is found in another module you can import it into scope use stdprocessid error aborting due to previous error For more information about this error try rustc explain E error could not compile reproduce Operating as a Linux Vendor its desirable for many many reasons to be able to execute tests on published crates For instance when publishing a new rust version as a vendor being able to reexecute all the tests for everything currently packaged to identify new compile errors or functional regressions helps make sure that all vendorized crates will be errorfree at the time of user consumption But anything relying on path dependencies pretty much screws this See also Which are all closed and sill relevant but I cant actually reopen a bug The filer of those bugs does appear to be potentially a fedora rep confirming that multiple vendors have this as a complaint Though our obligation is really only to make sure you know theres an issue and know were applying nasty hacks to get around it and all such hacks are always better to be fixed upstream In part because it means a given vendor freshly trying to package this doesnt have to stumble upon the problem and DIY their own hack around it and ensures closer vendor tracking of crates vs upstream As a side note A dozen or so crates having the same repository and the same bug tracker seems very suboptimal because its hard to directly map crate patches to git patches and viceversa and hard to find issues pertaining to a specific crate when there are a dozen crates using the same issue tracker which github seems very suboptimal for Finished test unoptimized debuginfo targets in s Running targetdebugdepsfuturescorea b d c fee running tests test result ok passed failed ignored measured filtered out Doctests futurescore running tests test srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWaker line FAILED test srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWakerregister line FAILED failures srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWaker line stdout error E failed to resolve use of undeclared type or module futures srctaskinternalatomicwakerrs use futuresfutureFuture use of undeclared type or module futures error E failed to resolve use of undeclared type or module futures srctaskinternalatomicwakerrs use futurestaskContext Poll AtomicWaker use of undeclared type or module futures error E failed to resolve use of undeclared type or module AtomicWaker srctaskinternalatomicwakerrs waker AtomicWakernew use of undeclared type or module AtomicWaker error E failed to resolve use of undeclared type or module Poll srctaskinternalatomicwakerrs return PollReady use of undeclared type or module Poll error E failed to resolve use of undeclared type or module Poll srctaskinternalatomicwakerrs PollReady use of undeclared type or module Poll error E failed to resolve use of undeclared type or module Poll srctaskinternalatomicwakerrs PollPending use of undeclared type or module Poll error E cannot find type AtomicWaker in this scope srctaskinternalatomicwakerrs waker AtomicWaker not found in this scope help possible candidate is found in another module you can import it into scope use futurescoretaskinternalAtomicWaker error E cannot find trait Future in this scope srctaskinternalatomicwakerrs impl Future for Flag not found in this scope help possible candidates are found in other modules you can import them into scope use corefutureFuture use futurescoreFuture use futurescorecorereexportfutureFuture use futurescorefutureFuture and other candidate error E cannot find type Context in this scope srctaskinternalatomicwakerrs fn pollself Pin mut Self cx mut Context Poll not found in this scope help possible candidates are found in other modules you can import them into scope use coretaskContext use futurescorecorereexporttaskContext use futurescoretaskContext use stdtaskContext error E cannot find type Poll in this scope srctaskinternalatomicwakerrs fn pollself Pin mut Self cx mut Context Poll not found in this scope help possible candidates are found in other modules you can import them into scope use coretaskPoll use futurescorecorereexporttaskPoll use futurescoretaskPoll use stdtaskPoll error aborting due to previous errors Some errors have detailed explanations E E E For more information about an error try rustc explain E Couldnt compile the test srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWakerregister line stdout error E failed to resolve use of undeclared type or module futures srctaskinternalatomicwakerrs use futuresfutureFuture use of undeclared type or module futures error E failed to resolve use of undeclared type or module futures srctaskinternalatomicwakerrs use futurestaskContext Poll AtomicWaker use of undeclared type or module futures error E failed to resolve use of undeclared type or module Poll srctaskinternalatomicwakerrs PollReady use of undeclared type or module Poll error E failed to resolve use of undeclared type or module Poll srctaskinternalatomicwakerrs PollPending use of undeclared type or module Poll error E cannot find type AtomicWaker in this scope srctaskinternalatomicwakerrs waker AtomicWaker not found in this scope help possible candidate is found in another module you can import it into scope use futurescoretaskinternalAtomicWaker error E cannot find trait Future in this scope srctaskinternalatomicwakerrs impl Future for Flag not found in this scope help possible candidates are found in other modules you can import them into scope use corefutureFuture use futurescoreFuture use futurescorecorereexportfutureFuture use futurescorefutureFuture and other candidate error E cannot find type Context in this scope srctaskinternalatomicwakerrs fn pollself Pin mut Self cx mut Context Poll not found in this scope help possible candidates are found in other modules you can import them into scope use coretaskContext use futurescorecorereexporttaskContext use futurescoretaskContext use stdtaskContext error E cannot find type Poll in this scope srctaskinternalatomicwakerrs fn pollself Pin mut Self cx mut Context Poll not found in this scope help possible candidates are found in other modules you can import them into scope use coretaskPoll use futurescorecorereexporttaskPoll use futurescoretaskPoll use stdtaskPoll error aborting due to previous errors Some errors have detailed explanations E E E For more information about an error try rustc explain E Couldnt compile the test failures srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWaker line srctaskinternalatomicwakerrs taskinternalatomicwakerAtomicWakerregister line test result FAILED passed failed ignored measured filtered out error test failed to rerun pass doc I noticed that recently sendall signature was updated to require TryStream bound on passed stream I wonder if there is a reason for this restriction Consider the following code that I have type TestData HashMapString usize let sink SinkTestData let msg HashMapnew let msg HashMapnew let mut msgs futuresstreamitervec msg msg sendersendall mut msgsawait This fails with following error error E type mismatch resolving futuresutilstreamiterIterstdvecIntoIterstdcollectionsHashMapstdstringString usize as futurescorestreamStreamItem stdresultResult examplesbasicrs sendersendall mut msgsawait expected struct stdcollectionsHashMap found enum stdresultResult note expected type stdcollectionsHashMapstdstringString usize found enum stdresultResult note required because of the requirements on the impl of futurescorestreamTryStream for futuresutilstreamiterIterstdvecIntoIterstdcollectionsHashMapstdstringString usize Took me some time to decrypt that this happens because streamiterIter does not implement TryStream and gets automatic implementation only if streams item is stdresultResult So in simple code above I have to wrap each message into Ok like futuresstreamitervec Okmsg Okmsg which looks weird Shouldnt it be possible to send streams that produce items for sure and cant fail Unless I am missing something obvious that makes it undesirablenot possible I think sinking collection of values is rather often use case Use assertfuture and assertstream annotations in almost all FutureExt TryFutureExt StreamExt and TryStreamExt trait fns My own style of working with thirdparty code is doing CmdClick in Idea and look at signatureimplementation I found these existing assert annotations very helpful in understanding what this particular function does what it expects what it returns much faster than reading documentation or opening actual futurestream implementation For example theres TryStreamExtandthen function fn andthenFut Fself f F AndThenSelf Fut F where F FnMutSelfOk Fut Fut TryFutureError SelfError Self Sized What does it do Does it return a future or a stream Is stream item original stream item or returned from future Is error converted Is it even Try object returned from this function Now with the function body assertstreamResultFutOk FutError its easier to infer that function returns a stream with the same items as provided future So this diff extends assert function to almost all functions of these four traits when I begin project I choose futures But then I will use Tokioasyncstd instead od futures and no back because it lack net api I dont know why here isnt the net API