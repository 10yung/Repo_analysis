 Treat Unit as a regular Kotlin object which Unit is Ensure SerialDescriptor invariants in ObjectDescriptor Also fixes What is your usecase and why do you need this feature I have multiple classes with field id When I get a serialization error its pretty time consuming to understand where exactly is the problem Here is an example kotlinxserializationMissingFieldException Field id is required but it was missing at SharedCode x a fd kfunkotlinRuntimeExceptioninitkotlinStringkotlinThrowablekotlinRuntimeException at SharedCode x a kfunkotlinxserializationSerializationExceptioninitkotlinStringkotlinThrowablekotlinxserializationSerializationException at SharedCode x a d kfunkotlinxserializationSerializationExceptioninitkotlinStringkotlinThrowablekotlinIntkotlinnativeinternalDefaultConstructorMarkerkotlinxserializationSerializationException at SharedCode x a kfunkotlinxserializationMissingFieldExceptioninitkotlinStringkotlinxserializationMissingFieldException at SharedCode x a f d kfunpodlodkamppmodelCategoryinitkotlinIntkotlinStringkotlinStringkotlinStringkotlincollectionsListpodlodkamppmodelShortEpisodekotlinxserializationSerializationConstructorMarkerpodlodkamppmodelCategory at SharedCode x a f cb kfunpodlodkamppmodelCategoryserializerdeserializekotlinxserializationDecoderpodlodkamppmodelCategory at SharedCode x a kfunkotlinxserializationjsoninternaldecodeSerializableValuePolymorphickotlinxserializationruntimekotlinxserializationjsonJsonInputkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a ef kfunkotlinxserializationjsoninternalStreamingJsonInputdecodeSerializableValuekotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fc kfunkotlinxserializationElementValueDecoderdecodeSerializableElementkotlinxserializationSerialDescriptorkotlinIntkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fff kfunkotlinxserializationinternalListLikeSerializerreadElementkotlinxserializationCompositeDecoderkotlinIntGENERICkotlinBoolean at SharedCode x a efaa kfunkotlinxserializationinternalAbstractCollectionSerializerreadElementdefaultkotlinxserializationCompositeDecoderkotlinIntGENERICkotlinBooleankotlinInt at SharedCode x a e kfunkotlinxserializationinternalAbstractCollectionSerializerpatchkotlinxserializationDecoderGENERICGENERIC at SharedCode x a eb kfunkotlinxserializationinternalAbstractCollectionSerializerdeserializekotlinxserializationDecoderGENERIC at SharedCode x a kfunkotlinxserializationjsoninternaldecodeSerializableValuePolymorphickotlinxserializationruntimekotlinxserializationjsonJsonInputkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a ef kfunkotlinxserializationjsoninternalStreamingJsonInputdecodeSerializableValuekotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fc kfunkotlinxserializationElementValueDecoderdecodeSerializableElementkotlinxserializationSerialDescriptorkotlinIntkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a c kfunpodlodkamppmodelEpisodeserializerdeserializekotlinxserializationDecoderpodlodkamppmodelEpisode at SharedCode x a kfunkotlinxserializationjsoninternaldecodeSerializableValuePolymorphickotlinxserializationruntimekotlinxserializationjsonJsonInputkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a ef kfunkotlinxserializationjsoninternalStreamingJsonInputdecodeSerializableValuekotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fc kfunkotlinxserializationElementValueDecoderdecodeSerializableElementkotlinxserializationSerialDescriptorkotlinIntkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fff kfunkotlinxserializationinternalListLikeSerializerreadElementkotlinxserializationCompositeDecoderkotlinIntGENERICkotlinBoolean at SharedCode x a efaa kfunkotlinxserializationinternalAbstractCollectionSerializerreadElementdefaultkotlinxserializationCompositeDecoderkotlinIntGENERICkotlinBooleankotlinInt at SharedCode x a e kfunkotlinxserializationinternalAbstractCollectionSerializerpatchkotlinxserializationDecoderGENERICGENERIC at SharedCode x a eb kfunkotlinxserializationinternalAbstractCollectionSerializerdeserializekotlinxserializationDecoderGENERIC at SharedCode x a kfunkotlinxserializationjsoninternaldecodeSerializableValuePolymorphickotlinxserializationruntimekotlinxserializationjsonJsonInputkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a ef kfunkotlinxserializationjsoninternalStreamingJsonInputdecodeSerializableValuekotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a fc kfunkotlinxserializationElementValueDecoderdecodeSerializableElementkotlinxserializationSerialDescriptorkotlinIntkotlinxserializationDeserializationStrategyGENERICGeneric at SharedCode x a d a kfunkotlinxserializationinternalMapLikeSerializerreadElementkotlinxserializationCompositeDecoderkotlinIntGENERICkotlincollectionsMutableMapGENERICGENERICkotlinBoolean at SharedCode x a efaa kfunkotlinxserializationinternalAbstractCollectionSerializerreadElementdefaultkotlinxserializationCompositeDecoderkotlinIntGENERICkotlinBooleankotlinInt Describe the solution youd like Print out the class name in error message like Field id is required in Category but it was missing What is your usecase and why do you need this feature For object classes it should be a way to find a serializer Currently both KClassserializer and serializerT do not work The reason why we need this is that we should somehow serialize objects that is accepted to be allowed However it is not possible if an object is a serialization root What is your usecase and why do you need this feature Unfortunately I have a json string like this value hello value To serialize this types I use a sealed class with two implementations StringValue and IntValue The default serializer adds the class with a type property which is critical when a property is named type and the receiver did not expect this additional attribute during desialization Describe the solution youd like class TestValuesTest Serializable sealed class TestValues Serializable data class StringValueval value String TestValues Serializable data class IntValueval value Int TestValues private val json JsonJsonConfigurationStable private val expected value hello value trimIndent Test fun incomingJson val values jsonparseTestValuesserializerlist expected assertEqualshello values as TestValuesStringValuevalue assertEquals values as TestValuesIntValuevalue Test fun outgoingJson val testString TestValuesStringValuehello val testInt TestValuesIntValue val outgoing jsonstringifyTestValuesserializerlist listOftestString testInt assertEqualsexpected outgoing What is your usecase and why do you need this feature As described here sometimes apis will return a json value which could contain a single object or a list of objects Also see the data json values in the jsonapi example jsonapi example links self next last data type articles id attributes title JSONAPI paints my bikeshed relationships author links self related data type people id comments links self related data type comments id type comments id links self included type people id attributes firstName Dan lastName Gebhardt twitter dgeb links self type comments id attributes body First relationships author data type people id links self type comments id attributes body I like XML better relationships author data type people id links self Describe the solution youd like Maybe use of vararg or an SingleToArray annotation like in that moshi example to read single objects into a list I am attempting to write a custom serializer to handle this case but is there an example anywhere of how to do this in a clean way It seems that protobuf wellknown types are not supported outofthebox with kotlinxserialization It could be nice to have outofthebox serializationdeserialization support for at least some protobuf wellknowntypes ie in my case comgoogleprotobufTimestamp Ie following example code would work without custom serializer or some workaround Serializable data class Moment SerialId val time Timestamp List of Wellknown types can be found in here Is there any plans to add some kind of support into kotlinxserialization for these types in future Describe the bug If I have an abstract class with a field and other classes which extend this abstract class the field from the abstract class will have the same property name as the first field from the concrete class To Reproduce Serializable abstract class Snippet SerialNameobjectFieldName val objectFieldName String Serializable data class TestSnippet SerialNameexperiments val experiments ListKrakenExperiment Snippettest Serializable data class ScreenSnippet SerialNamename val name String SerialNameuuid val uuid String null SerialNamesource val source String null Snippetscreen val snippetModule SerializersModule polymorphicSnippetclass ScreenSnippetclass with ScreenSnippetserializer TestSnippetclass with TestSnippetserializer val json Json configuration JsonConfigurationStable context snippetModule val testSnippet TestSnippetemptyList val screenSnippet ScreenSnippetone two three println jsonstringifyTestSnippetserializer testSnippet println jsonstringifyScreenSnippetserializer screenSnippet Outputs experimentstestexperiments namescreennameoneuuidtwosourcethree Expected behavior It should output objectFieldNametestexperiments objectFieldNamescreennameoneuuidtwosourcethree Environment Kotlin version Library version Kotlin platforms JVM android this code is in kotlin MP common source set Gradle version IDE version Android Studio Canary Other relevant context AdoptOpenJDKbuild b Porting a project using the Java ProtoBuf library to kotlinxserialization can become quite hard since optional properties are not supported in the same way On the one hand it is not possible to omit optional properties during serialization this is possible by not setting an optional property while building the message in Java On the other hand it is not possible to check if a property has been omitted by the sender during deserialization this is possible via MessagehasA in Java Allowing to set ProtoBufshouldEncodeElementDefault to false allows to create Serializable data classes that support optional properties during serialization and deserialization Additionally it makes null values possible for optional properties as well Closes Make skipping null values default behavior for protobuf Closes NULLs are not supported when writing to protobuf I created a libraryA that uses Kotlin Serialization and Kotlin Reflect This lib uses api instead of implementation for both dependencies The problem is I am having to add manually the serialization dependency to the project that wants to use the libraryA if not I got javalangClassNotFoundException kotlinxserializationjsonJson If I am using api the correct behavior should be I dont need to add the serialization dependency to the project because it is as api dependency Environment Kotlin version Library version Kotlin platforms JVM 