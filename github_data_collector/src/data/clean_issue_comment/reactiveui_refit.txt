 Please be sure to read the Contribute section of the README What kind of change does this PR introduce Its fixing by making ApiResponse implement interface IApiResponse and IApiResponseT The rationale behind it is that IApiResponse interface allows to access the ApiResponses various properties without requiring a strongly typed variable IApiResponseT gives the additional access to the content and easiersimpler testing What is the current behavior ApiResponseT with no interface What is the new behavior ApiResponseT has IApiResponseT an IApiResponse implemented What might this PR break Cant think of anything Please check if the PR fulfills these requirements Tests for the changes have been added for bug fixes features Docs have been added updated for bug fixes features Other information Not sure what tests or docs should be update since its a fairly minor change Anyways not attached the naming of the interfaces While simple the feature would be really practical in situations where you use a form of dynamic proxy which right now forces you to use reflection Is your feature request related to a problem Please describe Per discussion on Twitter Reddit recently I believe we should switch the codebase from using spacebased indentation to tabbased Describe the solution youd like Tabs used in source code instead of spaces with a editorconfig update to enforce it in each IDE Describe alternatives youve considered NA Describe suggestions on how to achieve the feature With each PR ensure that modified files use tabs instead of spaces Ideally fail the build if spaces are used unsure how to enforce maybe a Stylecop rule Additional context Describe the bug Locations provided to endpoints on a refit interface should seamlessly be appended to the HttpClient provided as long as the result is a valid URL when combined with that clients BaseAddress Instead refit throws an ArgumentException when calling RestServiceForThttpClient if the endpoint is not prefixed with This is a problem because if your remote API has a base URL that includes a path for example HttpClient strips the api location from its BaseAddress if it does not include a trailing This is in conformance with the URI standard and is therefore rather an issue on refits end Steps To Reproduce Create a refit endpoint Getfoobar async Task FooAsync Configure an HttpClients BaseAddress to be in the URI standard a trailing is the correct way to indicate directories HttpClient will strip out any trailing location for example Attempt to call RestServiceFor on your interface ArgumentException is thrown Expected behavior Request should be addressed to Hi guys Im trying to port some code from retrofit to refit The retrofit version is like this POSTuserme Multipart ObservableUserResponse getProfilePart MultipartBodyPart part Part MultipartBodyPart part If I use multipart with strings in my c code the request is different that retrofit request Also by copy pasting retrofit request in postman generates an error Bellow can find some screenshots Thanks Screenshot Gallery MicrosoftExtensionsHttp MicrosoftExtensionsDependencyInjection ServiceCollection services new ServiceCollection servicesAddTransienttypeofIDisposable typeofAuthenticatedParameterizedHttpClientHandler servicesAddRefitClientIApiServicesettings ConfigureHttpClientc cBaseAddress new Uri iLab cDefaultRequestHeadersAddContentType applicationjson charsetUTF AddHttpMessageHandlerAuthenticatedParameterizedHttpClientHandler SetHandlerLifetimeTimeSpanFromMinutes var serviceProvider servicesBuildServiceProvider object httpClientFactory serviceProviderGetRequiredServicetypeofIApiService on the above last statement the exception is thrown says no type for AuthenticatedParameterizedHttpClientHandler registered Does it support for protobuf serialization STOP Please note although we cant commit to any timeline priority will be given to those who are Contributors to the project If this is a question please ask on StackOverflow Describe the bug A clear and concise description of what the bug is If there were different version refit on my machine dotnet build will throw the error below shell error MSB The RefitGeneratorTasksGenerateStubsTask task could not be loaded from the assembly UsersNamenugetpackagesrefit buildTransitivenetstandard buildMSBuildCore InterfaceStubGeneratorBuildTasksdll Assembly with same name is already loaded Confirm that the UsingTask declaration is correct that the assembly and all its dependencies are available and that the task contains a public class that implements MicrosoftBuildFrameworkITask UsersNameProjectsSolutionsrcInfrastructureRosterServiceAgentRosterServiceAgentcsproj Steps To Reproduce Provide the steps to reproduce the behavior Go to Click on Scroll down to See error It may be caused by dotnet cache I have to restart my machine or restart all dotnet processes to avoid this error However if an other project with different version refit still throw the error Expected behavior A clear and concise description of what you expected to happen I want to know the reason of this error and fixed this bug will be more excited Screenshots If applicable add screenshots to help explain your problem Environment Please complete the following information OS MacOS Device MBP Version Working Version dotnetcore Additional context Add any other context about the problem here Retrofit do like this public interface TaskService FormUrlEncoded POSTtasks CallTaskObj createTaskFieldtitle String title Fieldmessage String message while in Refit we have to do like this public interface TaskService Posttasks TaskTaskObj createTask BodyBodySerializationMethodUrlEncoded RequestObj which require extra object or dictionary object that seems a bit complex for such simple case so I think it is better refit could support similar thing like Retrofit STOP Please note although we cant commit to any timeline priority will be given to those who are Contributors to the project If this is a question please ask on StackOverflow Is your feature request related to a problem Please describe A clear and concise description of what the problem is Currently there isnt a nice way to pass data to your pipeline of DelegatingHandler classes Describe the solution youd like A clear and concise description of what you want to happen What I would like to see is the ability to place data into HttpRequestMessageProperties dictionary on a perrequest basis It should function basically the exact same way the Headers and Header attributes do except you pass in key value pairs and they get stored in the HttpRequestMessageProperties Describe alternatives youve considered A clear and concise description of any alternative solutions or features youve considered I currently am using the Headers and Header attributes to accomplish this goal but its a nasty hack It works but its not a nice solution Its not what HTTP headers are intended for I currently have very different logging concerns that I take care of using a series of DelegatingHandler classes and each pulls out the headers its looking for and logs the contents if certain criteria are met For example I need to log a friendly error message in a user facing log so there is one handler for that and the exception message if the result is non is stored in a header that I pull out and throw an exception which bubbles up to the client I also need to log a success message in a user facing log if the request succeeded so there is a header for that Plus some diagnostics information for instrumenting performance and tracing metrics on the whole pipeline etc Describe suggestions on how to achieve the feature A clear description to how to achieve the feature It looks like its not too hard to do and if you agree with the approach Id be happy to submit a PR How I would implement it is add two new attributes PropertiesAttribute and PropertyAttribute and in the constructor of RestMethodInfocs extract the values present on the MethodInfo and MethodParams pretty much exactly the same as Headers and Header attributes do it and store them on the RestMethodInfo class Then inside RequestBuilderImplementation take the Properties we saved in RestMethodInfo and populate them into the HttpRequestMessageProperties The one problem I can see is that all the building of those request objects is currently cached So youd need to be able to optout of caching either manually with an attribute or automatically if Property attribute is detected or update the cache key to include Property parameters key AND value pairs Please be sure to read the Contribute section of the README What kind of change does this PR introduce Bug fix feature docs update Fixes What is the current behavior You can also link to an open issue here What is the new behavior If this is a feature change Allows any casing in the parameter binding to the object What might this PR break Please check if the PR fulfills these requirements x Tests for the changes have been added for bug fixes features Docs have been added updated for bug fixes features Other information 