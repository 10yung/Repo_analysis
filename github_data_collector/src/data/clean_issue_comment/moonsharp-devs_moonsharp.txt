Some people asked for maybe a more windowsfriendly version of the sync projects script Couldnt hash out a bat version off hand quickly but this should work on any currently supported windows OS powershell As a PATCH because work is still figuring out how this whole github thing works Got OK to continue publishing as PATCH for now though even though it is unfun for all of us From f c fc e cde c fc a a d c f Author Eric Driggers EricDriggerstoppanmerrillcom Subject PATCH powershell version of syncunityprojectsps diff git asrcsyncunityprojectsps bsrcsyncunityprojectsps devnull bsrcsyncunityprojectsps powershell Quick and dirty port of rsyncunityprojectssh to powershell Thus keep somemost of the semantics of that instead of more native posh styleformatting means updatessync is easier if the other script changes echo rm mkdir are all powershell aliases ish or wrappers built in to modern posh hosts For this I am assuming reasonably up to date powershell of since win win usage is so low or no longer supported They do require better quoting though on spacing BASEDIRPSScriptRoot DO NOT CHANGE ORDER OTHERWISE WE RISK COPY OVERS echo Cleaning echo Unity rm R BASEDIRUnityMoonSharpAssetsTests rm R BASEDIRUnityMoonSharpAssetsPluginsMoonSharpInterpreter rm R BASEDIRUnityMoonSharpAssetsPluginsMoonSharpDebugger mkdir BASEDIRUnityMoonSharpAssetsTests mkdir BASEDIRUnityMoonSharpAssetsPluginsMoonSharpInterpreter mkdir BASEDIRUnityMoonSharpAssetsPluginsMoonSharpDebugger echo Copying files NB the biggest diff from shell no rsync so we use poshnative CopyItem stuff Reminder that order of filescopies is important for reasons function betterCopy RootPath DestPath Ignore generated files under obj per old rsync only cs files were copied so simplifies the search srcFiles getchilditem Recurse Path RootPath Include cs FullName notmatch obj powershells copyitem does NOT like doing a destination filetree without effort So instead use a pipeline object and convertmask the destination output path param KB KB srcFiles copyOper pscustomobject PathFullName DestinationFullNameReplaceRootPathDestPath null NewItem Path copyOperDestination Type File Force Forces file tree creation at least copyOper CopyItem Force echo Unity interpreter betterCopy BASEDIR MoonSharpInterpreter BASEDIR Unity MoonSharp Assets Plugins MoonSharp Interpreter echo Unity vscode debugger betterCopy BASEDIR MoonSharpVsCodeDebugger BASEDIR Unity MoonSharp Assets Plugins MoonSharp Debugger echo Unity unit tests betterCopy BASEDIR MoonSharpInterpreterTests BASEDIR Unity MoonSharp Assets Tests lua code for kv in pairs do local my return my end Expected result my nil Actual result my is a table I am using MoonSharp for Unity For our uses of moonsharp we have some strong controls forcing sandboxing and total execution cycleswall time constraints These include and require us to attach a debugger to every script instance we create and to create thousands of new script instances loading our whole lua library each time As one might guess this means we strain some odd hotpaths that normally arent much of a concern This specific patch has the ScriptSignalByteCodeChange private function check if the debugger actually even cares about bytecode at that point in time via GetDebuggerCaps I am willing to discuss other options since this does mean there isnt a simple way for the debugger to change its mind after everything has already loaded We employ either two work arounds to this issue Simply load any noop Lua source such that a new Signal and thus new Caps check is sent which then does feed the debugger This is our method when we know ahead of time eg when developer debugging not just part of our sandboxing constraints In our case we can simply reinitialize the entire M Script instance at a higher level that is giving us problems and rewind and rerun with a more capable tracinglogging debugger for postmortem analysis This is our preferred method when inproduction SREs are thrown to add more detail for logging Note Still having work figure out how to OK publishing our full fork and internal patches such that proper PRs could be submitted since we dont use github or any public git service For now going through our older PATCH process for the smaller things that were real nice to haves From e b a d e c fa From Eric Driggers EricDriggerstoppanmerrillcom Subject PATCH Debugger Only signal bytesource changes if DebuggerCaps says to Performance numbers via ORE at cores of total CPU vs now of of total CPU srcMoonSharpInterpreterScriptcs file changed insertions deletions diff git asrcMoonSharpInterpreterScriptcs bsrcMoonSharpInterpreterScriptcs index e bb faf d asrcMoonSharpInterpreterScriptcs bsrcMoonSharpInterpreterScriptcs namespace MoonSharpInterpreter private void SignalByteCodeChange if mDebugger null if mDebugger null mDebuggerGetDebuggerCaps DebuggerCapsCanDebugByteCode mDebuggerSetByteCodemByteCodeCodeSelects sToStringToArray namespace MoonSharpInterpreter private void SignalSourceCodeChangeSourceCode source if mDebugger null if mDebugger null mDebuggerGetDebuggerCaps DebuggerCapsCanDebugSourceCode mDebuggerSetSourceCodesource If you do the following in lua lua function f end i f printtypei it prints nil in both normal lua and Moonsharp However if you do lua function f end local i f printtypei It still works in normal lua but with Moonsharp it throws the error bad argument to type value expected Using Moonsharp version inside Visual Studio seems like any json containing fails with an unexpected token error however jsonlinter says it is valid jsonthe string in question draw recordsFiltered recordsTotal data Private sPrivate s Private sPrivate s and here is the error PM chunk Unexpected token Private sPrivate s Private sPrivate s I have two functions lua usage stringtoHex stringtoHex abc stringtoHex abc function stringtoHexstr separator return strgsub functionc return stringformat X separator or stringbytec end end usage stringfromHex stringfromHex abc function stringfromHexhex local hex hexgsub sp upper return hexgsubxx functionc return stringchartonumberc end end when I used in nlua or some other such as elua I got right results lua local bytes fffffromHex printbytestoHex result FFFF but when I use those code in moonsharp its wrong lua local bytes fffffromHex printbytestoHex result F F The autogenerated code from hardwiring throws errors under Unity f and C Im not sure if Im doing something wrong or if this is just a bug Its errors in my case This seems to be easily fixable and This seems to be trying to hardwire an implicit operator and failing I have some problems with a line scriptGlobals newscript Funcstring string string scriptingnewscript I get somewhere the error ScriptRuntimeException cannot convert clr type executescripting I rewrote it now to remove scripting as return value I dont really know how it would look otherwise It would be great to have a frequently found errors page where you describe how to deal with such errors MoonSharp already has an extension for executing scripts asynchronously However that extension allows pretty much no control over the scripts execution Currently the only way to do so is through coroutines which involves writing a bunch of boilerplate every time and which also makes it more difficult to implement say a Cland binding that needs to pause the script thread imagine a sleep function Coroutines also dont really allow scripts to be run in the background They are still run in the foreground but pause every once in a while In order to actually run them in the background AND be able to control their execution one has to add more control code Lua thread running coroutine and checking every x instructions for abort main thread creating that separate Lua thread and controlling it via a reset event Right now we want to be able to stop the script without forcing an abort be able to pause the script without a ThreadSleep which makes the script thread unresponsive to any kind of abort code run a Lua script in the background and continue with the normal flow of the program Additional functionality could obviously be added like pausing then resuming execution from within the main flow of the program Having support for this in the library makes sense considering it already has async methods It is also better because it makes everyone elses code cleaner and requires less boilerplate to be written This is implemented as follows csharp namespace MoonSharpInterpreter public class ExecutionControlToken public ExecutionControlToken public void Terminate ExecutionControlToken provides control of the execution of a script Calling Terminate will raise a ScriptTerminationRequestedException from the thread that is running the Lua script All exceptions can be caught in the same way as with the existing async methods csharp namespace MoonSharpInterpreter public class Script public TaskDynValue DoStringAsyncExecutionControlToken ecToken string code public TaskDynValue DoStreamAsyncExecutionControlToken ecToken public TaskDynValue DoFileAsyncExecutionControlToken ecToken other existing async methods public TaskDynValue CallAsyncExecutionControlToken ecToken The first three methods are modified from the original MoonSharp They have an additional parameter in the st position which is an ExecutionControlToken This ExecutionControlToken becomes associated with the execution of the code specified and it can be associated with multiple scripts is parameters from the nonasync methods Because ecToken is added as a first parameter to these async methods this will break compatibility with current x version csharp namespace MoonSharpInterpreter public class ScriptExecutionContext public void PauseExecutionTimeSpan timeSpan PauseExecution is added to ScriptExecutionContext so that Cland bindings can pause the script thread This function responds to abort requests so any call to PauseExecution wont block the normal flow of the program Although async extensions are only supported on NET PauseExecution works on NET as well On that platform it simply calls ThreadSleep That is because there is no async support anyway so the script execution is already blocking the thread This is simply for uniformity Update as of I still have some doubts regarding this pull request particularly about how the following I have to pass the token around everywhere in internal code Pausing execution of a script from outside a CLR function binding did not seem useful to me at the time I did this Im now reconsidering Calling ScriptLoadLoadAsync on the same Script instance being used by a script running asynchronously might fail since there is an attempt to access the processor from multiple threads meaning loading code has to be done before executing the script Im not completely sure this is a problem havent looked at the code in a while but probably is It doesnt look like moonsharp has an equivalent of this 