Has anything changed in Rust which could be done better in this repo to make it more idiomatic of the current version of Rust format will already return a String therefore the call to tostring is meaningless This is achieved by eliminating two global variables and making the code work nicely with ownership analysis This is possible because AudioDeviceNesCallback has a lock method that returns an object that dereferences to NesCallback we can store the output buffer directly in NesCallback and then safely access it to update the raw sound data The resulting code is easier to follow and contains fewer unsafe blocks Without this the project cant be built on Mac Apparently the APU is the bottleneck Because when you disable it the emulator is blazingly fast way too fast in fact Ill see if I can optimize it sprocketnes gitmaster cargo build Updating registry Downloading libc v Downloading lazystatic v Downloading sdl v Downloading time v Downloading bitflags v Downloading rand v Downloading num v Downloading libc v Downloading sdl sys v Downloading advapi sys v Downloading winapi v Downloading winapibuild v Downloading rustcserialize v Downloading kernel sys v Compiling winapibuild v Compiling winapi v Compiling libc v Compiling sdl sys v Compiling rustcserialize v Compiling libc v Compiling bitflags v Compiling lazystatic v error E patterns arent allowed in methods without bodies Usersmecargoregistrysrcgithubcom ecc db ec rustcserialize srcserializers fname str Compiling advapi sys v Compiling kernel sys v error aborting due to previous error For more information about this error try rustc explain E error Could not compile rustcserialize warning build failed waiting for other jobs to finish error build failed sprocketnes gitmaster rustc explain E error no extended information for E For example heres how inc is implemented Increments and decrements fn incAMAddressingModeM mut self am AM let val amloadself let val selfsetznval amstoreself val This is setzn fn setzn mut self val u u selfsetflagZEROFLAG val selfsetflagNEGATIVEFLAG val x val I cant see how this would handle a increment of value without panicking Seeing that theres been no commits in years perhaps Rust handled overflows differently back then Just getting started writing an emulator in Rust to get to know the language So far Ive been finding these by playing a game until it crashes To find all of them Id probably need to do a thorough linebyline audit or run a fuzzer I might try using aflfuzz to catch the rest of these sometime 