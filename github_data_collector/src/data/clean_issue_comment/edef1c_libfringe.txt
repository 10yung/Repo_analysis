 The website and the cratesio package docs are out of sync Please enable multiversion support similar to docsrs for docs so that it is easy to use the project There have been several changes over time since the last release Please publish the new changes to cratesio if everything is green on the current master Below is the output sh cargo test release Compiling fringe v filehomeubuntuProjectrustlibfringe Finished release optimized targets in secs Running targetreleasedepsfringecfa e d b running tests test archtestscontext ok test archtestscontextsimd ok test archtestsswap ok error process didnt exit successfully homeubuntuProjectrustlibfringetargetreleasedepsfringecfa e d b signal SIGILL illegal instruction cargo test release s user s system cpu total rustc version rustc nightly a dcecff seems that could not hanle panic properly See previous discussion in When running the example from the readme or anything else that uses libfringe like tokiofibers im getting a segmenetation fault Heres the stacktrace x e a in fringearchimpinittrampoline at homearturocargoregistrysrcgithubcom ecc db ec fringe srcarchx rs x fffffffd in x e in fringearchimpinittrampoline at homearturocargoregistrysrcgithubcom ecc db ec fringe srcarchx rs x c in at checkoutsrclibcoreoptionrs x in Using a move closure inside a structfn which borrows a struct field results in corrupted memory when that closure is not move Example extern crate fringe use stditerIterator use fringegeneratorYielder use fringeOsStack Generator struct Gpx creator String type GeneratorT fringeGenerator T fringeOsStack impl Gpx pub fn eventsa a self Generator a str let stack OsStacknew unwrap Generatornewstack ctx broken Generatornewstack move ctx working ctxsuspendselfcreatorasstr fn main let data Gpx creator Stringfromxyz println dataeventsnext Unfortunately I dont know if its a problem with type checking or the unsafe portion Given some pointers I will try to debug it myself I notice that theres no Drop implementation for Generator and so it looks like its owned stack wont get unwound and so any resources owned by a Generators stack will get leaked So it seems that that the only way currently to forcefully unwind a generators stack is to pass in a value that asks it to panic such as in this example Is that right I notice that contextrs has the ability to spawn a function on top of a recovered stack which might be an option for future implementation But that seems quite risky The Stack trait allows returning arbitrary raw pointers which can be used to write to arbitrary addresses using only safe code Id like to have some form of automated verification that were not unintentionally modifying processor state that were not declaring as clobbered Preferably we would automatically generate a list of processor state from a thirdparty source such as Capstone and use this to generate our clobber lists Additionally we could patternmatch the stackswap code in real programs and use this to statically check for state being carried across contexts 