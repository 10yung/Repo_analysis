This library looks very cool Really exciting to see this possibility D How does it differ from Sodium given the workinprogress pushpull Rust port Tried to implement something that accumulates all the stream values into a Vec using Streamfold but found that it clones the accumulator values multiple times during its operation Example code Rust extern crate carboxyl use carboxylSink use stdfmtDebug deriveDebug struct StorageT vec VecT implT StorageT fn new Self Storage vec Vecnew fn pushmut self item T Self selfvecpushitem self implT Clone Debug Clone for StorageT fn clone self Self printlnstorage cloned selfvec Storage vec selfvecclone fn main let sink Sinknew let signal sinkstreamfoldStoragenew Storagepush sinksend sinksend sinksend printlnresult signalsample output storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned storage cloned result Storage vec Dont know if Im using it wrong but this seems pretty inefficient A fold operation shouldnt require cloning the accumulator The result of creating new events and signals in Carboxyl depends on when it is done This is necessary to avoid spaceleaks ie memorizing the entire history of these objects By design of the implementation Carboxyl cannot memorize this as it does not rely on a garbage collector to clean it up but rather only has one memory location where the current value of a signal is stored However this behaviour could be expressed more explicitly At the moment the semantics of an expression implicitly depend on when it is executed which is somewhat undesirable The API would have to be changed to allow this so this is something to be considered for version The main offender is snapshot In the paper on FRPNow see below it is argued that this could be alleviated by not returning the streamsignal directly but rather a signal containing it to make the dependence on evaluation time explicit Background infos FRP Dynamic Event Switching Heinrich Apfelmus Practical Principled FRP FRPNow Atze van der Ploeg Koen Claessen Essentially implT FromIteratorT for StreamT It should be clear that this will not consume the iterator directly but rather spawn a background thread to do so Currently it is a bit hacky to return an intermediate value from inside the defining closure passed to Signalcyclic There should be a more convenient alternative API method to do this This is currently a fairly significant limitation of this crate Only types T static are allowed for streams and signals It should in principle be possible to lift this restriction but it might require some tweaks to the implementation Also not all parts of the API can work that way For instance one cannot feed a sink nonstatics in a detached background thread But the borrow checker should take care of such limitations It is currently not well tested how the primitives behave when functions panic x Looping of streams Looping of signals How is this supposed to be defined Edit terminology cell stream stream signal