 Description This is the same as but for the GetSigniature extension method csharp class A class BD class CE typeofABintCstringGetSigniature typeofABCGetSigniature It either throws an InvalidOperationException or returns too many generics for the nested generic signiature Description Just FYI your TypeGetDeclaration extension fails for nested generic types Example csharp class A class BD class CE typeofABintCstringGetDeclaration It currently throws an InvalidOperationException Im not sure what you would want to do in these cases since it is a nested type and the declaration requires the parent type as well In my opinion it should probably return the declaration for only that nested class and not the parents But that is up to you of course At a minimum you should probably throw a custom ArgumentException with a custom message If you remove types csharp typeofABCGetDeclaration It returns csharp CD E And that is definitely incorrect Made a slight update to the Regex Pattern to conform more to the rules of RFC which obsoletes RFC I ended up updating the regex pattern because the built in NET MailAddressParser conforms to RC and did not want to reimplement to conform to RC The supplied regex pattern should match of valid emails More tests have been implemented Old regex pattern Valid Email List True emailexamplecom True firstnamelastnameexamplecom True emailsubdomainexamplecom False firstnamelastnameexamplecom True email True email True examplecom True emailexampleonecom True examplecom True emailexamplename True emailexamplemuseum True emailexamplecojp True firstnamelastnameexamplecom Invalid Email List False plainaddress False com False examplecom False Joe Smith emailexamplecom False emailexamplecom False emailexampleexamplecom True emailexamplecom True emailexamplecom True emailemailexamplecom False emailexamplecom Joe Smith False emailexample True emailexamplecom False emailexamplecom True Abc examplecom New regex pattern Valid Email List True emailexamplecom True firstnamelastnameexamplecom True emailsubdomainexamplecom True firstnamelastnameexamplecom True email True email True examplecom True emailexampleonecom True examplecom True emailexamplename True emailexamplemuseum True emailexamplecojp True firstnamelastnameexamplecom Invalid Email List False plainaddress False com False examplecom False Joe Smith emailexamplecom False emailexamplecom False emailexampleexamplecom False emailexamplecom False emailexamplecom False emailemailexamplecom False emailexamplecom Joe Smith False emailexample False emailexamplecom False emailexamplecom False Abc examplecom For curiosities sake MailAddress constructor trycatch Valid Email List True emailexamplecom True firstnamelastnameexamplecom True emailsubdomainexamplecom True firstnamelastnameexamplecom True email True email True examplecom True emailexampleonecom True examplecom True emailexamplename True emailexamplemuseum True emailexamplecojp True firstnamelastnameexamplecom Invalid Email List False plainaddress False com False examplecom True Joe Smith emailexamplecom False emailexamplecom False emailexampleexamplecom False emailexamplecom True emailexamplecom True emailemailexamplecom True emailexamplecom Joe Smith True emailexample True emailexamplecom True emailexamplecom True Abc examplecom Fixes String extension method IsValidEmail is incorrectly reporting emails such as usernamesomethingdomaincom as invalid This is a valid RFC email address and one recommended by Google to alias existing inboxes Description cs summary Filters a sequence of values based on a predicate if the judgement is matched summary typeparam nameTSourceThe type of the elements of sourcetypeparam param namesourceAn see crefIQueryableT to filterparam param namejudgementThe judgement to decide whether the filter should take affectparam param namepredicateA function to test each element for a conditionparam returns An see crefIQueryableT that contains elements from the input sequence that satisfy the condition specified by predicate returns public static IQueryableTSource WhereIfTSourcethis IQueryableTSource source bool judgement ExpressionFuncTSource bool predicate if judgement return source return sourceWherepredicate Currently the DateTimeOffset extension method has the unexpected behavior of changing the offset to match that of the current system timezone and does not just set the time as suggested by the name This change copies the offset to the new DateTimeOffset Default value processing when database is not returned This issue is a proposal to add SplitOnChunkSize to FileInfo that would split a file into multiple files and return an array of the newly created files The challenge with this one will be handling line breaks if the breakOnNewlines is true and also taking into account large files means buffering a chunk of data at a time so as not to overload system resources summary Splits a file into multiple files based on the specified chunk size of each file summary param namefileThe fileparam param namechunkSizeThe maximum number of bytes to store in each file If a chunk size is not provided files will be split into MB chunks by default The breakOnNewlines parameter can slightly affect the size of each fileparam param nametargetPathThe destination where the split files will be savedparam param namedeleteAfterSplitif set to ctruec the original file is deleted after creating the newly split filesparam param namebreakOnNewlinesif set to ctruec break the file on the next newline once the chunk size limit is reachedparam returns An array of references to the split files returns exception crefArgumentNullExceptionfileexception exception crefArgumentOutOfRangeExceptionchunkSize The chunk size must be larger than bytesexception public static FileInfo SplitOnChunkSize this FileInfo file int chunkSize DirectoryInfo targetPath null bool deleteAfterSplit false bool breakOnNewlines true if file null throw new ArgumentNullExceptionnameoffile if chunkSize throw new ArgumentOutOfRangeExceptionnameofchunkSize chunkSize The chunk size must be larger than bytes if fileLength chunkSize return new file var buffer new byte chunkSize var extraBuffer new Listbyte targetPath targetPath fileDirectory var chunkedFiles new ListFileInfointMathAbsfileLength chunkSize using var input fileOpenRead var index while inputPosition inputLength var chunkFileName new FileInfoPathCombinetargetPathFullName fileNameCHUNKindex chunkedFilesAddchunkFileName using var output chunkFileNameCreate var chunkBytesRead while chunkBytesRead chunkSize var bytesRead inputReadbuffer chunkBytesRead chunkSize chunkBytesRead if bytesRead break chunkBytesRead bytesRead if breakOnNewlines var extraByte buffer chunkSize while extraByte n var flag inputReadByte if flag break extraByte byteflag extraBufferAddextraByte outputWritebuffer chunkBytesRead if extraBufferCount outputWriteextraBufferToArray extraBufferCount extraBufferClear if deleteAfterSplit fileDelete return chunkedFilesToArray I was unable to get ExtractGZipToDirectory working It just created an empty file when I tried to decompress it I ended up creating this method which did work private static FileInfo DecompressGZipFilethis FileInfo compressedFilePath using var fs compressedFilePathOpenRead using var zipStream new GZipStreamfs CompressionModeDecompress var buffer compressedFilePathNameSplit var buffer buffer buffer var filePath PathCombinecompressedFilePathDirectoryName buffer using var fOutStream new FileStreamfilePath FileModeCreate FileAccessWrite var tempBytes new byte int i while i zipStreamReadtempBytes tempBytesLength fOutStreamWritetempBytes i return new FileInfofilePath The WebClient class defines DownloadFileTaskAsync as public Task DownloadFileTaskAsyncstring address string fileName Which is nice but it does not return a reference to the file that was downloaded An extension method like the following would be helpful possibly good to do for the nonasync version as well summary Downloads the specified resource to a local file as an asynchronous operation using a task object summary param namewebClientThe web clientparam param nameaddressThe URI of the resource to downloadparam param namefileNameThe name of the file to be placed on the local computerparam returns Returns see crefSystemThreadingTasksTasksee The task object representing the asynchronous operation returns exception crefTSystemArgumentNullExceptionThe paramref nameaddressaddressparamref parameter is null or The paramref namefileNamefileNameparamref parameter is nullexception exception crefTSystemNetWebExceptionThe URI formed by combining see crefSystemNetWebClientBaseAddresssee and paramref nameaddressaddressparamref is invalid or An error occurred while downloading the resourceexception exception crefTSystemInvalidOperationExceptionThe local file specified by paramref namefileNamefileNameparamref is in use by another threadexception public static TaskFileInfo DownloadFileInfoTaskAsyncthis WebClient webClient string address string fileName return webClientDownloadFileTaskAsyncaddress fileName ContinueWithtask new FileInfofileName 