Minimal reproducible example you may have to run it a few times before it triggers its random cpp include stdioh include SDL SDLh define CUTESOUNDIMPLEMENTATION define CUTESOUNDFORCESDL include cutesoundh cscontextt context void audioinitvoid context csmakecontextNULL NULL csspawnmixthreadcontext csloadedsoundt loaded csloadwavhumwav csplayingsoundt hum csmakeplayingsound loaded csinsertsoundcontext hum cssleep int mainvoid audioinit char buf FILE f fopenhumwav rb if f long size fseekf SEEKEND size ftellf rewindf buf mallocsize freadbuf size f fclosef else putsFailed to open file return return Heres a gdb session gdb run Starting program Thread debugging using libthreaddb enabled Using host libthreaddb library lib libthreaddbso New Thread x ffff cb LWP New Thread x ffff c LWP New Thread x ffff LWP New Thread x ffff c LWP Thread CuteSoundThread received signal SIGSEGV Segmentation fault Switching to Thread x ffff c LWP csmix ctx x eba at cutesoundh playingloadedsoundplayingcount gdb bt csmix ctx x eba at cutesoundh x in csctxthread udata x eba at cutesoundh x ffff dac ec in from usrlib libSDL so x ffff e f in from usrlib libSDL so x ffff c d in startthread from lib libpthreadso x ffff bf f f in clone from lib libcso Doesnt happen without the freadbuf size f call I can also hear an audible pop in the audio at the end of the sleep when when I have the fread not present otherwise Seems like a very specific circumstance but I encountered exactly this issue when trying to integrate cutesound into a larger game engine I zipped and attached the sound file I was using humwav humzip My original strategy was to copy paste large swaths of code into big and individual ifdef sections This worked quite well but isnt scaling as well as I hoped After working on an ALSA implementation I think a little too much code was duplicated Instead Ill refactor a lot of duplicated code into helper functions and platform independent structs In general there is too much platform independent code duplicated inside of the platform dependent sections I definitely dont want to devolve into a tangled mess of a million ifdef everywhere There will still be big sections one for each platformimplementation just smaller sections with less code duplication across them A while ago I made an attempt to use lookup table accelerator for decoding and use the binary search decoder as a fallback if the code bitlength was beyond the lookup tables maximum size I was attempting to mimic the lookup logic found in stbimageh but somehow I ended up introducing some bugs and the lookup table is now unused Open up cutepngh and search for lookup without casesensitivity to easily find all the lookup table code The lookup table should be fixed up and used eventually This is a low priority task so who knows when I will get around to it if ever but Im writing it down here just so I dont forget If anyone else is interested in trying feel free to take over and submit a pull request Hello I think If the character line is not in the file it falls into an infinite loop This causes an overflow PoC karasubuntucuteheadersexamplescutesid cat crashbc SID crash gdb log Program received signal SIGSEGV Segmentation fault x e in sidpreprocess path x fffffffd c inbc outpath x a inbcpreprocessed at cutesidh if ptr gdb bt full x e in sidpreprocess path x fffffffd c inbc outpath x a inbcpreprocessed at cutesidh ptr x error Cannot access memory at address x h bytes data x hi n size fp x c out x f outOriginal x f fileWasModified x ccd in CBDoPreprocess file x fffffffd c udata x at mainc out x a inbcpreprocessed x e in cftraverse path x fffffffe ad in cb x c CBDoPreprocess udata x at cutefilesh file path inbc EUUUU b repeats times k T Y repeats times QZ repeats times T EUUUU P name bc T H Xe k Xe T W T g i Xe ext c repeats times isdir isreg size info stdev stino stnlink stmode stuid stgid pad strdev stsize stblksize stblocks statim tvsec tvnsec stmtim tvsec tvnsec stctim tvsec tvnsec glibcreserved dir path in repeats times hasnext dir x entry x a x d in main argc argv x fffffffe at mainc No locals Asan Log ERROR AddressSanitizer heapbufferoverflow on address x d at pc x c e bp x fffddae sp x fffddae READ of size at x d thread T x c d in sidpreprocess homekarascuteheadersexamplescutesidcutesidh x e in CBDoPreprocess homekarascuteheadersexamplescutesidmainc x d in cftraverse homekarascuteheadersexamplescutesidcutefilesh x ea in main homekarascuteheadersexamplescutesidmainc x f a c in libcstartmain buildglibcCxtIbXglibc csucsulibcstartc x c b in start homekarascuteheadersexamplescutesidsid x c b x d is located bytes to the right of byte region x x d allocated by thread T here x d a in malloc homekarascuteheadersexamplescutesidsid x d a x bb b in sidpreprocess homekarascuteheadersexamplescutesidcutesidh x e in CBDoPreprocess homekarascuteheadersexamplescutesidmainc x d in cftraverse homekarascuteheadersexamplescutesidcutefilesh x ea in main homekarascuteheadersexamplescutesidmainc x f a c in libcstartmain buildglibcCxtIbXglibc csucsulibcstartc SUMMARY AddressSanitizer heapbufferoverflow homekarascuteheadersexamplescutesidcutesidh in sidpreprocess Shadow bytes around the buggy address x c fff fb x c fff fc x c fff fd x c fff fe x c fff ff x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa x c fff fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa Shadow byte legend one shadow byte represents application bytes Addressable Partially addressable Heap left redzone fa Freed heap region fd Stack left redzone f Stack mid redzone f Stack right redzone f Stack after return f Stack use after scope f Global redzone f Global init order f Poisoned by user f Container overflow fc Array cookie ac Intra object redzone bb ASan internal fe Left alloca redzone ca Right alloca redzone cb ABORTING Thanks The stack and frame allocators return unaligned memory Even though the header says it doesnt have any special alignment support it still should have some basic alignment support Currently using the header asis will crash on certain platforms due to unaligned memory In C code this is undefined behavior Writing wrappers around the stack allocator to handle basic alignment breaks freeing Possible fix would be to align each allocation to at least stdmaxalignt mirroring the behavior of malloc Simple program to show unaligned memory compiled with g alloctestcpp m stdc o alloctestout include cstdlib include cinttypes include cstdio define CUTEALLOCIMPLEMENTATION include cutealloch int mainint argc char const argv sizet size void stackchunk mallocsize void framechunk mallocsize castackt stack castackcreatestackchunk size caframet frame caframecreateframechunk size push stack ptr by sizeofchar to mess up alignment for next allocation char c charcastackallocstack sizeofchar int i intcastackallocstack sizeofint bool aligned uintptrti alignofint printfMemory from stack is s n aligned aligned not aligned push frame ptr by sizeofchar to mess up alignment for next allocation char c charcaframeallocframe sizeofchar int i intcaframeallocframe sizeofint bool aligned uintptrti alignofint printfMemory from frame is s n aligned aligned not aligned return Output from program Memory from stack is not aligned Memory from frame is not aligned Ive been treating tuShortentuWiden as a stringish conversion between UTF and UTF so I recommend this Heres the code add it to the end of every tuShortentuWiden function if out originalout outlen out I think theres an extra endif in tinyfilesh Around line theres this if defined TINYPATHIMPLEMENTATION endif TINYPATHIMPLEMENTATION That endif doesnt look like it should be there I get compilation errors about the final endif having no matching if The win API has been used to implement high resolution integer timers but implementations for AppleLinux are still missing See I am having issues with playing the following pitch setting Substituting the following resolved the issue m phase mmatan ps imag real float phasef float phase float realf float real float imagf float imag for int i i i phasef i smbAtan imagf i realf i I suspect there is an issue with mmatan ps related to the edge cases From Even if Im a windows user the geek in me knows that an ALSA backend would be a great addition FYI PD 