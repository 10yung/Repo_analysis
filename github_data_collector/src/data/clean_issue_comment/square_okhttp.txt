Based on this issue If were throwing exceptions inside interceptor they should inherit IOException to be properly handled without crashing the app But theres some situations in which you dont want to inherit IOException One of this cases we are handling errors of API Not HTTP errors API returns some templated entities with statuscode which can be checked to detect some errors like invalid parameters that was passed And one of error handling solutions is to create interceptor that checks all of requests responses and throwing domain exceptions if status code indicates error I suggest to add some parameter to OkHttpClientBuilder that will allow us to disable canceling requests if some NonIOException was thrown inside interceptor EAndroidRuntime FATAL EXCEPTION OkHttp Dispatcher kotlinKotlinNullPointerException at okhttp internalhttp Http ExchangeCodecFixedLengthSourcereadHttp ExchangeCodeckt at okhttp internalUtilskipAllUtilkt at okhttp internalhttp Http ExchangeCodecskipConnectBodyHttp ExchangeCodeckt at okhttp internalconnectionRealConnectioncreateTunnelRealConnectionkt at okhttp internalconnectionRealConnectionconnectTunnelRealConnectionkt at okhttp internalconnectionRealConnectionconnectRealConnectionkt at okhttp internalconnectionExchangeFinderfindConnectionExchangeFinderkt at okhttp internalconnectionExchangeFinderfindHealthyConnectionExchangeFinderkt at okhttp internalconnectionExchangeFinderfindExchangeFinderkt at okhttp internalconnectionTransmitternewExchangeokhttpTransmitterkt at okhttp internalconnectionConnectInterceptorinterceptConnectInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalcacheCacheInterceptorinterceptCacheInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalhttpBridgeInterceptorinterceptBridgeInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalhttpRetryAndFollowUpInterceptorinterceptRetryAndFollowUpInterceptorkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainkt at okhttp RealCallgetResponseWithInterceptorChainRealCallkt at okhttp RealCallAsyncCallrunRealCallkt at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava Getting error because tunnel creating val tunnelCodec Http ExchangeCodecnull null source sink and in function Http ExchangeCodecread realConnection not nullable realConnectionnoNewExchanges The server didnt supply the promised content length RetryAndFollowUpInterceptor indefinitely retries StreamResetException with error code CANCEL Its possible that an HTTP connection is established with server immediately sending back stream cancels upon receiving requests thats how we encountered this issue This can be reproduce by a nodeexpress server and within request handler do resconnectiondestroy From examining code this appears to be obvious as CANCEL events are intentionally kept out from renewing connections Should there be a global retry count of some sort as a final guard in the interceptor to avoid infinite retries as such Id like to be able to limit the retry count in Authenticator to At the moment it appears to be I dont see anything to do this and didnt get an answer in StackOverflow so assuming its not possible at the moment Task samplesslacktestClasses UPTODATE Task samplesslacktest NOSOURCE Task samplesstaticservercompileKotlin Task okhttptlstest okhttp tlsHandshakeCertificatesTest platformTrustedCertificates FAILED javalangStringIndexOutOfBoundsException begin end length at javabasejavalangStringcheckBoundsBeginEndStringjava at javabasejavalangStringsubstringStringjava at okhttp tlsHandshakeCertificatesTestplatformTrustedCertificatesHandshakeCertificatesTestjava okhttp tlsHeldCertificateTest decodeMalformed FAILED javautilNoSuchElementException at javabasejavautilArrayListItrnextArrayListjava at okhttp tlsHeldCertificateCompaniondecodePemHeldCertificatekt at okhttp tlsHeldCertificateCompaniondecodeHeldCertificatekt at okhttp tlsHeldCertificateCompaniondecodeHeldCertificatekt at okhttp tlsHeldCertificatedecodeHeldCertificatekt at okhttp tlsHeldCertificateTestdecodeMalformedHeldCertificateTestjava closeReasonMaximumLength okhttp internalwsWebSocketHttpTest orgjunitComparisonFailure expected but was at okhttp OkHttpClientTestRuleensureAllConnectionsReleasedOkHttpClientTestRulekt at okhttp OkHttpClientTestRuleapply evaluateOkHttpClientTestRulekt serverCloseThenClientClose okhttp internalwsRealWebSocketTest javalangAssertionError Expecting empty but was Closed Hello at okhttp internalwsWebSocketRecorderassertExhaustedWebSocketRecorderjava at okhttp internalwsRealWebSocketTesttearDownRealWebSocketTestjava Seeing the following crashes on Android with Okhttp v not happening on v Using http rest endpoints with retrofit and rxjava Fatal Exception m a at okioBufferwritableSegmentokioBufferjava at okioBufferwriteByteBufferjava at okioRealBufferedSinkwriteByteRealBufferedSinkjava at okhttp internalUtilwriteMediumUtiljava at okhttp internalhttp Http WriterframeHeaderHttp Writerjava at okhttp internalhttp Http WritersettingsHttp Writerjava at okhttp internalhttp Http ConnectionstartHttp Connectionjava at okhttp internalhttp Http ConnectionstartdefaultHttp Connectionjava at okhttp internalconnectionRealConnectionstartHttp RealConnectionjava at okhttp internalconnectionRealConnectionestablishProtocolRealConnectionjava at okhttp internalconnectionRealConnectionconnectRealConnectionjava at okhttp internalconnectionExchangeFinderfindConnectionExchangeFinderjava at okhttp internalconnectionExchangeFinderfindHealthyConnectionExchangeFinderjava at okhttp internalconnectionExchangeFinderfindExchangeFinderjava at okhttp internalconnectionTransmitternewExchangeokhttpTransmitterjava at okhttp internalconnectionConnectInterceptorinterceptConnectInterceptorjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalcacheCacheInterceptorinterceptCacheInterceptorjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpBridgeInterceptorinterceptBridgeInterceptorjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRetryAndFollowUpInterceptorinterceptRetryAndFollowUpInterceptorjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp internalhttpRealInterceptorChainproceedRealInterceptorChainjava at okhttp RealCallgetResponseWithInterceptorChainRealCalljava at okhttp RealCallAsyncCallrunRealCalljava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava and Fatal Exception m a at okioSegmentpopSegmentjava at okioBufferskipBufferjava at okioRealBufferedSourceskipRealBufferedSourcejava at okhttp internalhttp Http ConnectionReaderRunnabledataHttp Connectionjava at okhttp internalhttp Http ReaderreadDataHttp Readerjava at okhttp internalhttp Http ReadernextFrameHttp Readerjava at okhttp internalhttp Http ConnectionReaderRunnablerunHttp Connectionjava at javalangThreadrunThreadjava Need to catch Android regressions due to code changes or new OS releases Forked from 