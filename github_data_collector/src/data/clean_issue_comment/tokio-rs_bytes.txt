This example diff git aexamplesrrrrs bexamplesrrrrs index e de de aexamplesrrrrs bexamplesrrrrs use bytesBytes fn main let mut bytes Bytesfromvec bytestruncate dropbytes diff git asrcbytesrs bsrcbytesrs index ab b af asrcbytesrs bsrcbytesrs impl FromVecu for Bytes let slice vecintoboxedslice let len slicelen let ptr sliceasptr printlndismantling a vec of cap len dropBoxintorawslice if ptr as usize x unsafe fn promotableodddropdata mut AtomicPtr ptr const u len usi unsafe fn rebuildvecbuf mut u offset const u len usize Vecu let cap offset as usize buf as usize len printlnrebuilding vec with cap cap Vecfromrawpartsbuf cap cap diff git asrclibrs bsrclibrs index df fb d b asrclibrs bsrclibrs denywarnings missingdocs missingdebugimplementations rust idioms dochtmlrooturl nostd Provides abstractions for working with bytes cargo run example rrr Finished dev unoptimized debuginfo targets in s Running targetdebugexamplesrrr dismantled a vec of cap rebuilding vec with cap So we are allocating bytes but when calling deallocation we are passing hint parameter which causes deallocation by RawVec which calls GlobalAllocdealloc which violates the spec layout must be the same layout that was used to allocate that block of memory I suspect it may crash deallocation or cause memory leaks although I could not reproduce either I tried this program globalallocator static ALLOC jemallocatorJemalloc jemallocatorJemalloc use bytesBytes fn main loop let mut bytes Bytesfromvec bytestruncate dropbytes After a few seconds of run macOS Activity Monitor shows Gb of memory usage by this program which is a sign that something doesnt work as expected I have been looking for a zerocopy way of sharing mmap content via Bytes I noticed the vtable feature added by and didnt find followups I wonder if bytes is interested in getting a ArcmemmapMmap version implemented probably gated by a mmap feature that is default off Or if other approaches are preferred ex expose the vtable interface and implement the mmap support in other crates I personally think there are very limited types that meaningfully fit the vtable interface I can hardly think of another aside from the mmap one So it seems easier for endusers if bytes just implements them all use features to keep the default deps slim But I can see concerns about memmap being unmaintained If the next steps are clear I can help implementing them merge hexrs and debugrs into the mod fmt merge BsDebug and BytesRef BsDebug is deleted separate impl Debug from bytesrsbytesmutrs fix a dead link in the comment beautify the code Use case let bytes Bytes let subbytes bytessliceab where a b let slice subbytes let slicebytes bytesslicerefslice Last line should not panic because slice object is derived from the original Bytes object Before this commit it panics because Bytesslice returns a fresh Bytes object when begin end The documentation of BufMutadvancemut states the following about panics Panics This function may panic if cnt selfremainingmut Implementer notes It is recommended for implementations of advancemut to panic if cnt selfremainingmut If the implementation does not panic the call must behave as if cnt selfremainingmut A call with cnt should never panic and be a noop Currently the impl for Vecu will reserve to accommodate the advance This seems to be in conflict with If the implementation does not panic the call must behave as if cnt selfremainingmut These are eg traitBufhtml should be traitBufExthtml and traitBufMuthtml should be traitBufMutExthtml Hi I created a BytesBuf with some data and removed the leading n bytes with advancen After some more computations I converted the result to an immutable Bytes value My expectation was that the content of the BytesMut and Bytes would be identical Instead the Bytes still contained the discared bytes Example program rust use bytesBytesMut Buf BufMut fn main let mut x BytesMutnew xput bhello let mut y BytesMutnew yput bhello yadvance println x y bhello bllo assertnex y assertne x y let x xfreeze let y yfreeze println x y bhello bhello expected bhello bllo asserteqx y asserteq x y As a workaround I use splitto instead of advance and ignore the return value Just a few things I noticed in the BytesMut docs Is the new inability to roundtrip between Bytes and BytesMut intentional The inability to do so somewhat diminishes the usefulness of the reference counting feature this crate offers if it means that freeze renders a chunk of memory permanently immutable with no way to reclaim borrowed ranges and start over again without reallocating I understand that Bytes is now unaware of the existence of BytesMut at this time but it should still be possible to update the BytesMut api to recover memory whose ref count has reached zero I was all set to path BytesMut to add a version of freeze that looked like this rust pub fn freeze Bytes Unfreeze where Unfreeze is a struct with a single function rust pub fn unfreeze BytesMut with Unfreeze itself containing a weak reference to the same shared memory used by Bytes instances but then I discovered that Bytes doesnt use Arc but rather a custom implementation that does not support weak references The reason for having BytesMut return an Unfreeze rather than adding eg an unfreeze trymut method to Bytes is that the latter would require Bytes keeping track of whether it was instantiated from readonly memory or not which the current vtable mask isnt capable of distinguishing between My use case involves reading some bytes into a buffer sending the refcounted read bytes to another thread for processing then reclaiming them when an event is set and the Bytes have been dropped to reuse the buffer for the next cycle