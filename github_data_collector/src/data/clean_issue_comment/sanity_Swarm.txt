None I follow the instructions in the readme but when I visit I get the following error HTTP ERROR Problem accessing Reason javaxservlethttpHttpServletResponsegetStatusI Caused by javalangNoSuchMethodError javaxservlethttpHttpServletResponsegetStatusI at orgscalatraservletRichResponsestatusRichResponsescala at orgscalatraScalatraContextclassstatusScalatraContextscala at orgscalatraScalatraServletstatusScalatraServletscala at orgscalatraScalatraBaseclassrunActions ScalatraBasescala at orgscalatraScalatraBaseanonfunexecuteRoutes applymcVspScalatraBasescala at orgscalatraScalatraBaseanonfunexecuteRoutes applyScalatraBasescala at orgscalatraScalatraBaseanonfunexecuteRoutes applyScalatraBasescala at orgscalatraScalatraBaseclassorgscalatraScalatraBasecradleHaltScalatraBasescala at orgscalatraScalatraBaseclassexecuteRoutesScalatraBasescala at orgscalatraScalatraServletexecuteRoutesScalatraServletscala at orgscalatraScalatraBaseanonfunhandle applymcVspScalatraBasescala at orgscalatraScalatraBaseanonfunhandle applyScalatraBasescala at orgscalatraScalatraBaseanonfunhandle applyScalatraBasescala at scalautilDynamicVariablewithValueDynamicVariablescala at orgscalatraDynamicScopeclasswithResponseDynamicScopescala at orgscalatraScalatraServletwithResponseScalatraServletscala at orgscalatraDynamicScopeanonfunwithRequestResponse applyDynamicScopescala at scalautilDynamicVariablewithValueDynamicVariablescala at orgscalatraDynamicScopeclasswithRequestDynamicScopescala at orgscalatraScalatraServletwithRequestScalatraServletscala at orgscalatraDynamicScopeclasswithRequestResponseDynamicScopescala at orgscalatraScalatraServletwithRequestResponseScalatraServletscala at orgscalatraScalatraBaseclasshandleScalatraBasescala at orgscalatraScalatraServletorgscalatraservletServletBasesuperhandleScalatraServletscala at orgscalatraservletServletBaseclasshandleServletBasescala at orgscalatraScalatraServlethandleScalatraServletscala at orgscalatraScalatraServletserviceScalatraServletscala at javaxservlethttpHttpServletserviceHttpServletjava at orgmortbayjettyservletServletHolderhandleServletHolderjava at orgmortbayjettyservletServletHandlerhandleServletHandlerjava at orgmortbayjettyservletSessionHandlerhandleSessionHandlerjava at orgmortbayjettyhandlerContextHandlerhandleContextHandlerjava at orgmortbayjettyhandlerHandlerWrapperhandleHandlerWrapperjava at orgmortbayjettyServerhandleServerjava at orgmortbayjettyHttpConnectionhandleRequestHttpConnectionjava at orgmortbayjettyHttpConnectionRequestHandlerheaderCompleteHttpConnectionjava at orgmortbayjettyHttpParserparseNextHttpParserjava at orgmortbayjettyHttpParserparseAvailableHttpParserjava at orgmortbayjettyHttpConnectionhandleHttpConnectionjava at orgmortbayjettybioSocketConnectorConnectionrunSocketConnectorjava at orgmortbaythreadQueuedThreadPoolPoolThreadrunQueuedThreadPooljava Swarm requires that every Swarm node be running the same codebase I think this can be achieved by hooking into the JVMs classloader and making it retrieve packages ondemand as they are needed This concept is inspired by the Zero Install package management system This would probably involve having some kind of public crypto key in the package name as a unique identifier eg package swarmbR Z h wombat Just porting over Google Code issues Ian proposed examining software transactional memory as a way to prevent threads from interfering with eachother in bad ways This spawned a discussion on the pros and cons of various approaches Read the thread here Swarm must find a way to adaptively arrange data on servers to minimize the number of times a thread must jump from one computer to the other Mailing List Threads one two Sample implementation by Ian The Twitter demo is meant to be deployed for public consumption so it needs a way for user accounts to be secured from unauthenticated access The Twitter demo is meant to be deployed for public consumption so it needs a way for users to create accounts for themselves The current unit tests rely on the InMemTest class which is a bit of a hack to simulate continuation serialization transport It would be much better to create a test framework which can be run as a usual unit test ie with sbt test that kicks off two real InetTransporterlisten threads on different local ports and tests actual serialization and transportation over sockets This might be doable with some advanced sbt trickery or within a class via some clever class loading Scala collections do not use Swarm references internally which means that they cannot be split across multiple machines We need to create Swarmful versions of these collections that do use Swarm Refs internally The ideal Swarm web framework would treat the open HTTP connection to the web browser as just another Swarm object referenced through a Ref but of course tied to a specific computer This would mean that a HTTP request could come in and the resultant continuation could move around to other computers before coming back to the original computer in order to send the HTTP response Most existing Java and Scala web frameworks are unsuitable for this as typically theyll call a method with HTTP request and response objects but they expect that when this method returns that the response is ready to be sent Unfortunately this method will not typically be within a continuation reset block 