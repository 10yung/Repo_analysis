I think in general this is guide might be a bit out of date but lets start here with fixing it I noticed on a diff and in some other new code that we are writing moduleexports sometimes I believe the policy is to use exports default whenever possible If not then Ill at least learn something by making this PR Just wondering I am used to nextjs which has a getInitialProps function to AJAX on server render Trying to write best practices at our company so just wanted that clarification I believe its safe to say after the internal vote that people prefer js import React Component from react class Thing extends Component over js import React from react class Thing extends ReactComponent The examples in reactmd all use the ReactComponent style so we should update them to just extend Component We can also add a blurb about the import convention cc kevinbarabash replace propTypes with props Props how to type children properly eg string ReactElementany ReactElementany describe order that we current lint against remove sorting of requireimport statements blocks continues to be the same with the addition of a new block flow type imports which should come last prefer ES import syntax over require destructuring should happen on the same line as the import eg import React Component from react The preferred ternary style is the following if it can fit on a single line put it on a single line eg const color selected green orange if it cant fit on a single line put the and at the start of each line eg const result reallyVeryLengthConditional superLongComputationOfPositiveResult superLongComputationOfNegativeResult const style selected color green fontWeight bold color orange The fromimport section of the Python style guide says Rationale This is the single best and easiest way to avoid the circularimport problem To simplify when you say import x Python executes the xpy file but doesnt need to get any attributes from it When you say from x import foo Python needs xpy to be executed enough that foo is defined in it When x does a fromimport from y and y does a fromimport from x the circular import can succeed if a partial module is enough as it will be with import x but it can fail if the circularity happens before the needed attribute is defined as it might be with from x import foo I had trouble proving this to myself with manual testing I think this section could really benefit from a link to some concrete example code that showcases a successful example of this behavior That way everything regarding stylesbest practices in the same place I dont know if you have ES object restspread properties enabled but if you do heres an easy ES idiom for creating a new object with all the same own properties of a given object Specification Sorry for the rapid fire comments needed to get it out before jumping into a meeting and forgetting Continuing the feedback from There are a couple of methods that are sufficiently complicated and dont have a direct equivalent so instead we have a custombuilt copy of lodash containing only those specific methods You can find this file at thirdpartyjavascriptkhansrclodashlodashjs along with instructions on how to build it and exactly what methods are included In addition Lodash is totally modular works great with browserify webpack to create smaller bundles Theres even a babel plugin to avoid mucking with module paths js var cloneDeep requirelodashclonedeep or var cloneDeep requirelodashlangcloneDeep Objectassignjson thismodeltoJSON extendjson thismodeltoJSON It would be better to compare to assign as thats closer to Objectassign iterating only own properties of source values instead of owninherited in extend for const key val of Objectentriesobj eachobj fn In Lodash theres forOwn and forIn for object iteration too defer setTimeoutfn deferfn delay setTimeoutfn delayfn The useful bit for defer and delay is they allow partially applying arguments to the deferreddelayed function which older environments lacked in setTimeout may be worth noting bindAll objmethod objmethodbindsomeObj Typo fix to objmethod objmethodbindobj once js method if thisinitDone return thisinitDone true This will assign initDone to the outer this so not really appropriate for per method state 