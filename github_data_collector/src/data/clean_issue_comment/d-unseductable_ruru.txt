Closes as per I havent been able to find any documentation about how worker threads which dont interact directly with ruby objects are handled in terms of Drop In my case I have existing rust code which establishes a longrunning thread worker to handle incoming jobs via a channel The thread lives in a struct that implements Drop which tells the thread to stop waiting for new messages and terminate when its dropped glossing over details here In this case my expectation is the rustruru interface to ruby can cleanly send data perhaps copied data from ruby over the channel to the thread worker Would the thread worker need to be setup with the Thread struct in ruru Threadcallwithoutgvl Or could I use stdthread Will Drop be called when the parent struct is destroyed Thanks for any help you can provide Ruru has been inactive for some time so an official fork has been made called Rutie Much additional work and development has been done now in Rutie and its actively maintained Resolves My understanding is that Rubys strings are sequences of arbitrary bytes even if the associated encoding is UTF So the natural mapping to Rust would be as u and Vecu instead of str and String for most purposes A couple of helpers using str should be fine eg the fromutf function Functions which convert a ruby string to str or String without verifying UTF validity must be marked unsafe otherwise theyre unsound The docs recommend inheriting from Data following this idiom let dataclass ClassfromexistingData ClassnewMyClass Some Datadefine On Ruby this prints warning constant Data is deprecated every time Data is accessed I guess that there is some way to access this via the C extension API but I havent found it yet This accompanies Basically a reexport of a rubysys feature I added to conditionally link libruby when its needed for running Rust tests Normally libruby isnt needed due to how the interpreter dynamically loads cextensions see The rbstrnew method we have is good for making C strings in to Ruby string objects From here we can go further and implement the string with rbstrinitialize to help also set the encoding c VALUE rbstrinitializeVALUE str const char ptr long len rbencoding enc STRSETLENstr rbencassociatestr enc rbstrcatstr ptr len return str So I believe we should add the method rbencassociate to rubysys Well also likely need to implement encoding structs and have a C rbencoding type mapped to ruruEncoding h typedef const OnigEncodingType rbencoding The obvious places to look are stringc encodingc and encodingh But the OnigEncodingType onigmoh is a C Regex thing for helping with encodings so I dont know how complex that would be I believe this is good to go except for most of the documentation was copied from the Ruby doc So Ill likely need to revise it I dont mind if you merge it This doesnt effect any current systems implementations or behavior The fullmessage method is commented out as it would cause a panic if used as is In Ruby it outputs e mTraceback e mmost recent call last nirb in fullmessage e msomething went wrong e mStandardError e m e m n e m TODO x Update documentation x Add alternative to raise for rbexcraise which works best with this Wait for rubysys update and update Cargotoml Ive put comments through numerous issues on this and it doesnt make sense to me to leave any of this discussion so scattered so Im opening this issue to discuss the merits of designing the default behavior where ever AnyObject would return to be ResultAnyObject AnyException Pros For anyone developing a Rust app and using Ruby from it then this would allow for The Rust Way of handling Ruby exceptions to be well written and used As well as have the advantage of Rusts question mark syntax let val someresult Cons Implementing this behavior would require the majority of features to be run through Rubys rbprotect which will catch exceptions and allows us to build the Result This adds cost to the performance When writing a Ruby program and using Rust to gain performance you dont necessarily want this added cost in performance as the major draw to use Rust in Ruby is all about performance probable rewrite major version change Exceptions to the Rule Some scenarios wont ever cough cough call for an exception to be raised like when doing equality checks Equality checks simply make sense to return the bool type for convenience Although any method that can be monkeypatched and rewritten may raise exceptions in which case that should use protect The choice for design and usage would then come down to how strict to adhere to The Rust Way pattern in case of risk or provide the end user more of a choice My thoughts on this point is to be more relaxed on enforcing the return type and trust the developers to understand the risks and choose there own implementation decisions Alternatives Looking at a Helix PR withprotect example gave me the idea to have an impl WithProtect on FnOnce trait Its just a rough idea but it would be something like lazily produce a FnOnce closure and have that take self for the method definition in the WithProtect trait to route the code through something like my protectsend method So we could do myclosurewithprotect to run it Strictness If the need for safety comes first and we choose a relaxed stance on enforcing Result return types then it would come down to where we choose to draw the line Like for example when instantiating a new object both new and initialize methods are highly likely to raise an exception if the startup standards for that object are not met However the alternative method allocate is nearly guaranteed to never do anything that would raise an exception so this would be one method not needing the Result return type Choosing a form of this as a relaxed standard will require a more case by case decision on implementing it That would likely be the sole choice of the author of this project on his beliefs and weighting on the likeliness of any particular method to raise an exception My Stance Im not too picky about this change being implemented With protectsend and eval developers should have enough to take the risk out of most scenarios But this will require programmers to be more defensive and more on guard with their code when working with ruru Perhaps the easiest solution would be the alternative Ive proposed here above I leave this RFC here open for discussion