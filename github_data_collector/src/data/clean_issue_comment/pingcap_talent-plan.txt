When doing this homework I found make testexample drained my disk space and then panicked due to no space left on device After understanding the test code I found the test code never cleanup the data generated after each testcase In my opinion since the size of the data each test case generated is not ignorable the test should remove them after each case Something like that go tidbmapreduceurltop testgo func testURLTopt testingT rounds RoundsArgs for k range dataSize for i gen range gens generate data prefix dataPrefixi dataSize k nMapFiles k added code here clean up or cleanup only when the case has passed osRemoveAllprefix Is there any good reason not doing this Or is the cleanup part of the homework make testexample mrhomework no space left on device panic testcase make cleanup testcase testcase pass go tidbmapreduceurltop testgo func testURLTopt testingT rounds RoundsArgs for k range dataSize for i gen range gens generate data prefix dataPrefixi dataSize k nMapFiles k clean up pass osRemoveAllprefix Now that we have mentioned the mapbased implementation in part why is our requirement in the project spec to return unimplemented I am confused I think it is better to return mapbased results OS Windows bit version build Rust I didn t implement compaction feature for my own KvStore at all however after I ran all tests it showed that my own KvStore passed the compaction test Then I found the way of detecting the size of a directory seemed to be the problem Actually it is risky to find out the size of an opened file by inspecting its metadata When we dump data into an opened database log file it is possible that the metadata won t be updated immediately The related code is shown as follows rust let dirsize let entries WalkDirnewtempdirpathintoiter let len walkdirResultu entries mapres resandthenentry entrymetadata mapmetadata metadatalen sum lenexpectfail to get directory size let mut currentsize dirsize currentsize for iter in for keyid in let key formatkey keyid let value format iter storesetkey value let newsize dirsize newsize as metadata is not updated if newsize currentsize false compaction triggered not currentsize newsize continue Compaction triggered dropstore let s say the first call of dirsize returns which is assigned to currentsize And then keyvalue pairs are put into store Unfortunately the second call of dirsize will still return because there is only one log file and its metadata is not updated Therefore the statement newsize currentsize is false because they are equal actually finally the test function claims compaction triggered which is not true If we do system call like fsync or something as we write to file metadata will be updated of course but it is too heavy Here we just want to know file size so why not just open the file seek the file pointer to the end and record its position Like this rust let dirsize u let size ioResultu WalkDirnewtempdirpath intoiter filtermape eok filtere epathisfile filtermape Fileopen epathok mapmut f fseekSeekFromEnd sum sizeexpectfail to get total size of logs By this way the compaction test fails if KvStore doesn t deal with file compaction Any ideas Signedoffby Muhammad Falak R Wani falakreyazgmailcom There were some redundantclone I guess this rule is added to clippy recently Firstly very thanks to your great jobs Im reaching to project and trying to preview bb but it says coming soon Are there any plans for it The previous buildblocks have tought me many backgrounds and they are awesome BB s exercise points to Custom Serialization The exercise consists of using serde to serialize and deserialize redis protocol messages For this purpose its necessary writing a new serdes data format making it able to serialize and deserialize redis protocols messages This commit updates BB s exercise mentioned above and points the helping link for serdes documentation about writing a data format Discussed on tikvwg slack on I always get the output like this error E unresolved import kvsKvStore teststestsrs use kvsKvStore no KvStore in the root error aborting due to previous error For more information about this error try rustc explain E error Could not compile kvs To learn more run the command again with verbose so i cant run the test correctly when i write nothing in my file On slack QuRyu reported some problems completing the project benchmarks The two main problems They ran into ulimits for open socks I believe this benchmark describes opening many sockets at once For simplicity it might be best to pick a number that is lower than the default ulimits This could be an opportunity to discuss ulimits which are something that plague networked programs and their test suits but also this section is already super complicated adding a ulimit digression would just make it more so They needed to search for an unbound port for the server This seems to indicate that criterion is running benchmarks in parallel which is surprising