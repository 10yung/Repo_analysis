Hi Im investigating an error that is raised when making http request to one of the remote APIs I dont want to post that request as there are some secrets used but I think I was able to create minimal reproducible example ruby require socket Threadnew do server TCPServeropen clientconnection serveraccept body HTTP OK r nContentLength r nContentType applicationjson r nMyHeader body val r n r n clientconnectionwritebody clientconnectionwritebody end require http HTTPget Here is the error that is returned Traceback most recent call last from homeboniasrvmrubiesruby binirb in main from homeboniasrvmrubiesruby binirb in load from homeboniasrvmrubiesruby librubygems gemsirb exeirb in top required from irb from homeboniasrvmgemsruby gemshttp prelibhttpchainablerb in get from homeboniasrvmgemsruby gemshttp prelibhttpchainablerb in request from homeboniasrvmgemsruby gemshttp prelibhttpclientrb in request from homeboniasrvmgemsruby gemshttp prelibhttpclientrb in perform from homeboniasrvmgemsruby gemshttp prelibhttpconnectionrb in readheaders from homeboniasrvmgemsruby gemshttp prelibhttpconnectionrb in readmore from homeboniasrvmgemsruby gemshttp prelibhttpresponseparserrb in add HTTPConnectionError error reading from socket Could not parse data Error is not returned when using http version Added documentation for calling parameters I had to research Im trying to troubleshoot a problem with my HTTPrb requests Specifically we use a set of proxies for our retrieving from our API We have a use case where we are doing HEAD requests to handle URL resolution for shortened URLs It seems like HEAD requests are NOT proxied even with a configured via on the HTTP client Maybe thats by design Or maybe Im doing something wrong Or maybe its never been tested and Im doing something unique which I doubt This is likely a support problem versus a code problem But I thought Id reach out if nothing else for others that might hit this problem later and search the issues for a solution To test I created a bitly shortened URL that redirects to httpbinorg Then Im using HTTPlog to check what happens This is what I see D T DEBUG httplog Connecting bitly D T DEBUG httplog Sending HEAD D T DEBUG httplog Data D T DEBUG httplog Status D T DEBUG httplog Benchmark seconds D T DEBUG httplog Response D T DEBUG httplog Connecting httpbinorg D T DEBUG httplog Sending HEAD D T DEBUG httplog Data D T DEBUG httplog Status D T DEBUG httplog Benchmark seconds D T DEBUG httplog Response There is nothing in the logs that indicate a proxy connection Thoughts Im using HTTP with Savon and Im getting intermittent timeout errors HTTPTimeoutError Read timed out after seconds I can assure you Im not setting the readtimeout to but the problem is the API Im connecting to is private and can only be accessed on whitelisted servers so Im not able to submit example code that reproduces the issue Ive now told Savon to use NetHTTP and the issue is gone but felt I should still see if there is some way for me to help debug and fix the issue Autodetection is based on standard ENV variables used in a UNIX system Some documentation can be seen here The most common and used are schemaproxy and noproxy but it also supports other nonrecommended formats covered by Ruby URI library Fix This library is generating a segfault for me when I do this HTTPgets objectpublicurlbodytos This is on our Heroku workers they keep crashing with Segfault Please see details below Its starts with the following error T app workera pid tidgrp a ox WARN HTTPConnectionError couldnt read response headers T app workera pid tidgrp a ox WARN appvendorbundleruby gemshttp libhttpconnectionrb in readheaders T app workera appvendorbundleruby gemshttp libhttpclientrb in perform T app workera appvendorbundleruby gemshttp libhttpclientrb in request T app workera appvendorbundleruby gemshttp libhttpchainablerb in request T app workera appvendorbundleruby gemshttp libhttpchainablerb in get Versions gem http gem rails ruby Deployed on Heroku Segfault T app workera Control frame information T app workera c p s e CFUNC httpparserexecute T app workera c p s e METHOD appvendorbundleruby gemshttpparser libhttpparserparserrb T app workera c p s e METHOD appvendorbundleruby gemshttp libhttpresponseparserrb T app workera c p s e METHOD appvendorbundleruby gemshttp libhttpconnectionrb T app workera c p s e METHOD appvendorbundleruby gemshttp libhttpconnectionrb T app workera c p s e METHOD appvendorbundleruby gemshttp libhttpresponsebodyrb I recently upgraded my http gem version recently and the upgrade broke lots of webmock tests recording our outgoing http calls simply because the UserAgent header of my http gem had changed from httprb to httprb Needing to manually update web mocks between HTTP gem updates is cumbersome and what would be nice is if the http gem had a class level method like HTTPuseragent to get the default UserAgent headers the http gem uses so that web mocks could be written to futureproof them from http gem version updates Eg in my tests I have webmock testing code like this ruby def stubconfirmationsapiresponsecode stubrequestpost myurlconfirmations with headers AuthId ENVfetchAUTHID AuthToken ENVfetchAUTHTOKEN Connection close Host localhost UserAgent httprb toreturnstatus responsecode body nil headers end When I updated my http gems version UserAgent httprb needed to be manually updated to UserAgent httprb ruby def stubconfirmationsapiresponsecode stubrequestpost myurlconfirmations with headers AuthId ENVfetchAUTHID AuthToken ENVfetchAUTHTOKEN Connection close Host localhost UserAgent httprb toreturnstatus responsecode body nil headers end The way these webmock tests fail is not easy to debug and this maintenance burden could be avoided if for UserAgent I could just invoke a UserAgent method from the http gem to get its default useragent eg HTTPuseragent every time Eg ruby def stubconfirmationsapiresponsecode stubrequestpost myurlconfirmations with headers AuthId ENVfetchAUTHID AuthToken ENVfetchAUTHTOKEN Connection close Host localhost UserAgent HTTPuseragent toreturnstatus responsecode body nil headers end so that upgrading this gem never breaks webmocks for no other reason than the fact that the gems version was updated Basically I want to stream HTTP body to a file I tried to do this but sadly it doesnt work ruby Fileopenfiledatw do file body HTTPgeturibody IOcopystreambody file end usrlibrubygems gemshttp libhttpresponsebodyrb in readpartial usrlibrubygems gemshttp libhttpconnectionrb in readpartial wrong number of arguments given expected ArgumentError It happens because HTTPConnectionreadpartial doesnt accept nd argument of buffer which is expected by IOcopystream In some rare cases the method def contentlength raises TypeError instead of nil or Fixnum For example you can check the following scenario Reproduction code ruby url response HTTPgeturl responsecontentlength Expected behavior Expected nil or Fixnum instead I get TypeError cant convert Array into Integer The response object is HTTPResponse OK AcceptRanges bytes bytes Age CacheControlpublic maxage ContentLength DateFri Sep GMT Etag dc ec ecf bc c aa a ExpiresThu Dec GMT LastModifiedMon May GMT Serverimagery Via varnish XVarnish XAmzId H BrRPBmJ AKray LxApTdXlP cVEXJ DnDMEYVPcmaWJCGpzs DTNiRez xSuLsQxZcUfI XAmzRequestId ED CC AA FCF ConnectionClose The value of ContentLength is ContentLength which is suspicious HTTPgetnil HTTPRequestUnsupportedSchemeError unknown scheme HTTPget HTTPRequestUnsupportedSchemeError unknown scheme HTTPget HTTPRequestUnsupportedSchemeError unknown scheme HTTPget AddressableURIInvalidURIError Cannot assemble URI string with ambiguous path Ideally it should return InvalidURI exceptions if the URL is invalid instead of UnsupportedSchemeError as it is less confusing Ideally also it should return the same exception for all these cases