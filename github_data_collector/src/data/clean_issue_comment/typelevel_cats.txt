addresses Right now the Scalajs FutureTests use the runNow execution context which was deprecated in Scalajs and removed in In I replace runNow with an equivalent implementation since I want to unblock compatibility but this isnt a real solution see eg this issue for discussion addresses The analogous function on Free is simply foldMap but FreeT has an extra monadic suspension functor which cannot be manipulated through the same mechanism mapK already exists this simply provides a way of doing a mapKlike transformation where the resulting N is itself a FreeT This can be useful when you want to manipulate the structure of the interpretation in a composable fashion Followup on a rebased We also add some unused and deprecated methods with the Ord as a nonimplicit which avoid source ambiguity but keeps binary compatibility Closes I was surprised to see binary compatibility errors when I put the instance inside InvariantMonoidalInstances sbtcats coreJVMmimaReportBinaryIssues info Compiling Scala source to UserskubukozIdeaProjectscatscorejvmtargetscala classes info Compiling Scala sources to UserskubukozIdeaProjectscatscorejvmtargetscala classes error abstract synthetic method catsinstancesInvariantInstancessettercatsInvariantNumericcatsInvariantUnit in interface catsinstancesInvariantInstances is inherited by class AllInstances in current version error filter with ProblemFiltersexclude InheritedNewAbstractMethodProblem catsinstancesAllInstancescatsinstancesInvariantInstancessettercatsInvariantNumeric error abstract method catsInvariantNumericcatsInvariant in interface catsinstancesInvariantInstances is inherited by class AllInstances in current version error filter with ProblemFiltersexclude InheritedNewAbstractMethodProblem catsinstancesAllInstancescatsInvariantNumeric error abstract synthetic method catsinstancesInvariantInstancessettercatsInvariantNumericcatsInvariantUnit in interface catsinstancesInvariantInstances is inherited by class InvariantMonoidalInstances in current version error filter with ProblemFiltersexclude InheritedNewAbstractMethodProblem catsinstancesInvariantMonoidalInstancescatsinstancesInvariantInstancessettercatsInvariantNumeric error abstract method catsInvariantNumericcatsInvariant in interface catsinstancesInvariantInstances is inherited by class InvariantMonoidalInstances in current version error filter with ProblemFiltersexclude InheritedNewAbstractMethodProblem catsinstancesInvariantMonoidalInstancescatsInvariantNumeric error stack trace is suppressed run last coreJVM mimaReportBinaryIssues for the full output error coreJVM mimaReportBinaryIssues Cats core Binary compatibility check failed error Total time s completed Dec PM So I added a workaround another trait If anyone has a better idea Im open for suggestions Heres a ready instance one can use scala implicit val invariantNumeric Invariant Numeric new Invariant Numeric def imap A B fa Numeric A f A Bg B A Numeric B new Numeric B def comparex B y B Int facomparegx gy def plusx B y B B ffaplusgx gy def minusx B y B B ffaminusgx gy def timesx B y B B ffatimesgx gy def negatex B B ffanegategx def fromIntx Int B ffafromIntx def toIntx B Int fatoIntgx def toLongx B Long fatoLonggx def toFloatx B Float fatoFloatgx def toDoublex B Double fatoDoublegx Feel free to grab it if you have time before I do NonEmptyMap is a bit annoying to use due to some inconsistencies Although it has a keys method like Map does it doesnt have a corresponding values method Theres something similar possible with toNonEmptyList from NonEmptyTraverse but thats not very discoverable I suggest we add def values NonEmptyList A thistoNonEmptyList It has a toNel method that produces a NEL of pairs This is inconsistent with toList and which is especially silly with toNonEmptyList I suggest we rename toNel to pairs or something like that It seems like it should be possible for reduceLeftM to shortcircuit since eg foldLeftM does scala scala import catsdataNonEmptyStream catsimplicits import catsdataNonEmptyStream import catsimplicits scala def fi Int Either Int Int if i Righti else Lefti f i IntEither IntInt scala val s NonEmptyStream Streamfrom s catsdatapackageNonEmptyStream Int OneAnd Stream scala sfoldLeftM b a famap b res scalautilEither IntInt Left scala sreduceLeftMfb a famap b hangs forever This is probably related to which isnt itself a bug but if we had a working reduceLeftM we could write reduceMapM in terms of it