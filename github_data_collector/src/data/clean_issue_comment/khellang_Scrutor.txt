Ive been having some problems with Lamar working with Rebus I got things working ok with Autofac but what I actually wanted was ServiceProvider with the ability to scan and some kind of service module concept ie StructureMapLamar ServiceRegistry or Autofac Module I found Scrutor which gave me the scanning and knocked up a quick version that does what I want csharp Add Registries servicesAddRegistriesProgramr rNameStartsWithOverlord A registry then looks something like this csharp public class OverlordRegistry ServiceRegistry public override void LoadIServiceCollection services servicesScanWithDefaultConventionsOverlordRegistry servicesAddTransientIAppNameProvider HostEnvironmentAppNameProvider The code works but isnt tested yet proof of concept to substitute Lamar Any plans to have any basic module support such as this It would be great if I didnt have to maintain this code Scrutor API provides an easy way to actually replace service instead of decorating it For example servicesDecorateISeederseeder provider providerCreateInstanceNoMigrationsAppSeeder where CreateInstance is extension around ActivatorUtilities public static T CreateInstanceTthis IServiceProvider serviceProvider params object parameters ActivatorUtilitiesCreateInstanceTserviceProvider parameters and NoMigrationsAppSeeder uses default constructor Unfortunately this approach sometimes lead to stack overflow since Scrutor tries to resolve implementation instance even so its not needed in this case My suggestion is to provide Replace extension methods which wont resolve previous implementation and provide callbacks with IServiceProvider only I understand that this could be done manually but existing Scrutor infrastructure makes it much easier to implement Hi Im running into an issue with Scrutor when multitargeting Net and Net Core The offending code is occurring in a Net Standard library c var collection new ServiceCollection Scanscan scanFromApplicationDependencies AddClassesclasses classesAssignableToIMyInterface AsSelfWithInterfaces WithTransientLifetime This code works fine for the Net Core runtime but fails on with a Value cannot be null ArgumentNullException Are there possibly additional explicit Scrutor dependencies I need to add for Net Framework The source for this project is here The multitargeted test project contains the following xml PropertyGroup TargetFrameworksnetcoreapp net TargetFrameworks PropertyGroup the exception details with partial stack trace are below SystemArgumentNullException HResult x MessageValue cannot be null Parameter name assembly SourceScrutor StackTrace at ScrutorPreconditionsNotNull T T value String parameterName at ScrutorTypeSourceSelectorFromAssemblyDependenciesAssembly assembly at ScrutorTypeSourceSelectorFromApplicationDependenciesFunc predicate at ScrutorTypeSourceSelectorFromApplicationDependencies at VtsMonteCarloDetectorInputProvidercgetServiceProviderb ITypeSourceSelector scan in C Projects dcucciavts src Vts MonteCarlo DataStructures DetectorInputProvidercsline at MicrosoftExtensionsDependencyInjectionServiceCollectionExtensionsScanIServiceCollection services Action action Im quite new to this tool so its likely Im just not setting things up properly Let me know if theres more information I can provide to help resolve Thanks David Scans of nonpublic classes result in registrations of compilergenerated classes on C closures Eg cs internal class Foo public void Barint i async Task Baz i i And then cs servicesScans sFromCallingAssemblyAddClassesfalse This results in the following unexpected registration ServiceType Name BargBaz d FullName MyAppFoocDisplayClass BargBaz d ImplementationType Name BargBaz d FullName MyAppFoocDisplayClass BargBaz d If I derive Foo from a new empty interface IFoo and add AsImplementedInterfaces to the Scan call I get the following unexpected registration instead ServiceType Name IAsyncStateMachine FullName SystemRuntimeCompilerServicesIAsyncStateMachine ImplementationType Name BargBaz d FullName MyAppFoocDisplayClass BargBaz d I am a fairly inexperienced developer who might benefit from a wiki page explaining when youd use this library and what it solves that the base net framework does not I was under the impression that Net core had assembly scanning already Does this just make it more userfriendly or is it something else When the implementation class is a generic class that is implementing a generic interface as below its not able to detect IEventHandlerCustomEvent and IEventHandler from ActionableEventHandlerCustomEvent csharp class CustomEvent interface IEventHandler interface IEventHandlerTEvent IEventHandler class EventHandlerTEvent IEventHandlerTEvent class ActionableEventHandlerTEvent EventHandlerTEvent Possible fix can be csharp public static bool HasMatchingGenericAritythis Type interfaceType TypeInfo typeInfo if typeInfoIsGenericType var interfaceTypeInfo interfaceTypeGetTypeInfo if interfaceTypeInfoIsGenericType var interfaceArgCount interfaceTypeGenericTypeArgumentsLength var implementationArgCount typeInfoGenericTypeArgumentsLength return interfaceArgCount implementationArgCount return false return true This PR adds extension methods for defining cutom dependencies on specific services I came up with this idea because a lot of people didnt like the approach MS have taken with the generic ILoggerT and the named IOptionsTOptions If you have multiple IOptionsTOptions of the same type you have to retrive the correct instance by name inside of the costructor of the service where they are being injected Common usages Inject the desired service when multiple implementations are registered csharp var services new ServiceCollection servicesAddSingletonSomeService servicesAddSingletonSomeService servicesAddWithDependencies servicesAddSingletonMainService typeofSomeService public interface ISomeService public class SomeService ISomeService public class SomeService ISomeService public class MainService public MainServiceISomeService someService someServiceGetType typeofSomeService Avoid injecting the generic ILoggerT csharp var services new ServiceCollection servicesAddLogging servicesAddWithDependencies servicesAddSingletonSomeService servicesAddSingletonSomeOtherService serviceProvider injectionContext new serviceProviderGetRequiredServiceILoggerFactoryCreateLoggerinjectionContextCreatingServiceType public class SomeService public SomeServiceILogger logger loggerGetType typeofLoggerSomeService public class SomeOtherService public SomeOtherServiceILogger logger loggerGetType typeofLoggerSomeOtherService Hello I stumbled upon this but this project is pretty much dead I use scrutor and some kind of feature like typed factory would be cool addition this is the basic idea of this feature you can define interface c public interface ITestServiceFactory ITestService Createstring factoryParam this feature auto generates implementation of this interface on the fly that creates ITestService with dependencies from service provider and also those from Create method itself this project uses castle dynamic proxy castle has this feature built in but SystemReflectionDispatchProxydll works also what do you think Hi I have a generic mediatr request handler which looks like this public class GetOneByIdHandlerT IRequestHandlerGetOneByIdRequestT T where T IBaseEntity private readonly IAsyncRepositoryT asyncRepository public GetOneByIdHandlerIAsyncRepositoryT asyncRepository asyncRepository asyncRepository public async TaskT HandleGetOneByIdRequestT request CancellationToken cancellationToken return await asyncRepositoryGetOneByIdAsyncrequestId Right now I have to add the handler for every DTO manually How can I automate this with Scrutor Thanks servicesAddTransientIRequestHandlerGetOneByIdRequestMyDto MyDto GetOneByIdHandlerMyDto Ive created a method of registering adaptors I basically took your decorator implementation and augmented it for Adaptors It works for my use case but I havent written tests for it 