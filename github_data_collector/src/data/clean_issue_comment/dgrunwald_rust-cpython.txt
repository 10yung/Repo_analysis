It is not used in Python core should not be used in user code and will be removed in Python METHNOARGS functions should have type PyCFunction instead of PyNoArgsFunction and take NULL as the second argument This PR implements the append method for the PyList class because using the insert method is twice lower I also added test for this The first form macro is called by pyfn and calls pymethoddef again with a default value for the docstring But it didnt bear the localinnermacros modifier so that fails Adding that modifier forces us to rewrap concat as done before with stringify Reference As part of developing PyOxidizer I needed to force python sys to statically link against a Python library on Windows in a downstream crate of python sys This requires the unstable staticnobundle link type so Cargo leaves symbols as unresolved when python sys is built Currently the static linkage type verifies referenced symbols are present at crate build time See for more Look for comments by me indygreg to describe the issue in more detail This commit teaches python sys a pair of new build features which enable more explicit control over the linker directives emitted by its build script If no directive is specified linkmodedefault is used and the existing logic for linker directive emission is used If linkmodeunresolvedstatic is used and were on Windows we emit a staticnobundlepythonXY linker directive and omit the location of the library This effectively says I depend on a static pythonXY library but dont resolve the symbols when you build me and require someone else to specify the location to that library What PyOxidizer does is emit its own linker directive that defines the location of a static pythonXY library satisfying the linker constraint and enabling the build to work If a downstream create doesnt do this the build should fail due to a missing library or symbols I have purposefully designed the crate features to be extensible If we want to add additional mutually exclusive features in the future we could do that eg we could add a linkmodestatic that force emits a rustclinklibstaticpythonXY directive to force static linking even if a shared library is detected But I have no need for this today and dont want to complicate the code so I havent added it To round out the new feature features have been added to the cpython crate to toggle the new features Because Python is end of life in a few weeks I have not implemented the new feature for Python I suspect very few people will use this feature anyway and Im pretty confident that nobody will request this feature on Python I concede that adding this feature to the crate to support PyOxidizers esoteric use case is a bit unfortunate I really wish Cargo allowed a crate to wholesale replace the build script output of a dependency as PyOxidizer could statically resolve the Python settings for python sys since it brings its own Python library But Cargo doesnt have this feature So Im stuck having to land this feature in the upstream crate to avoid having to maintain a permanent fork of rustcpython Sorry The struct and function are documented at and defined in source code in CPython master at It is unclear whether PyImportInittab is part of the official API as it isnt clearly documented But the static has been shipping for years and is still in CPython master I need to use this variable in PyOxidizer in order to modify the set of extensions at runtime Putting it behind PyLIMITEDAPI should be safe So Ive had experience before creating python bindings with the C library pybind where Im able to return python buffers but I cant figure out how to do the same with rustcpython This was originally developed for the Mercurials Rust extension It allows us to implement a Python iterator over a Rust iterator relatively safely The problem is that a Rust iterator typically has a reference to the collection behind and thus cannot be a data member of a Python object We get around this problem by casting a to static and add runtime validation instead The basic idea is described in the following blog post In order to make the referencesharing business safe we have the following structs PySharedRefCell defines a storage holding a value to be shared PySharedRef is a lifetimebound reference to the value above which provides a safe interface on top of the PySharedRefCell and its owner PyObject UnsafePyLeaked is the reference not bound to the real lifetime and its validity is checked at runtime PyLeakedRefPyLeakedRefMut are borrowed references from UnsafePyLeaked In order to create PySharedRef in safe manner we plan to add pyclass macro like this pyclassclass List py shareddata vec Veci the storage type is PySharedRefCellVeci but its accessor returns PySharedRefa Veci It makes sure that the right owner PyObject and its data member are paired The macro extension is not included in this PR since well probably need some bikeshedding There are a couple of unsafe business in this module and some public functions are unfortunately unsafe Please refer to the inline comments why some of them can be safe and some cant Thanks to gracinet for the basic ideas and experiments Alphare for the core implementation markbt for the generationcounter idea and Mercurial developers for reviewing the original patches Is there any chance we can build python sys or rustcpython with target wasm unknownunknown I have a webapp built in Rustwasm and I would like to be able to use Python as the scripting language for the Rust webapp I am getting error error failed to run custom build command for python sys v stderr thread main panicked at called Resultunwrap on an Err value failed to run python interpreter python c import sys import sysconfig printsysexecutable printsysversioninfo printsysconfiggetconfigvar LIBDIR printsysconfiggetconfigvar PyENABLESHARED printsysconfiggetconfigvar LDVERSION or ss sysconfiggetconfigvar pyversionshort sysconfiggetconfigvar DEBUGEXT or printsysexecprefix No such file or directory os error srclibcoreresultrs note run with RUSTBACKTRACE environment variable to display a backtrace Thanks for the great project Without this patch the example were not working on my computer with Python I hope its OK Is it possible to specify the interpreter to use ie its path at runtime Something like use stdenv use cpython fn main let path envcurrentexeunwrap let interpreter pathwithfilenamerpython pythonwexe Pythonsetinterpreterinterpreterunwrap use cpython as normal The reason for this is if Im distributing a rust python app I want to include a python subdir and have rust use that python with all the extra dependencies I need rather than any that might happen to be on the system And of course this means that my users dont need to have their own python eg on windows 