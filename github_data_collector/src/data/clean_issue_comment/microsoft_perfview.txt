Im trying to use trace event to collect structured logs from a running process and I noticed that some data is being exposed from the wrong payload names As an example heres an MVC project that logs using ILogger HasStackTrue ThreadID ProcessorNumber Level FactoryID LoggerNameMicrosoftAspNetCoreHostingDiagnostics EventId EventNameRequest starting HTTP GET FormattedMessage HasStackTrue ThreadID ProcessorNumber Level FactoryID LoggerNameMicrosoftAspNetCoreRoutingEndpointMiddleware EventId EventNameExecutingEndpoint FormattedMessageExecuting endpoint Index HasStackTrue ThreadID ProcessorNumber Level FactoryID LoggerNameMicrosoftAspNetCoreMvcRazorPagesInfrastructurePageActionInvoker EventId EventNamePageExecuting FormattedMessageRoute matched with page Index Executing page Index Notice that the first event has EventName as Request starting HTTP GET and FormattedMessage as empty string It seem as though theres an issue when event name is null or empty then the formatted message becomes the event name This also reproduces with other logging events so Id imagine its the same bug Heres the code that produces one of the events cc brianrob noahfalk shirhatti On a piece of code that generates background GC collections every time it runs adding mil int values to an ArrayList Im seeing different outcomes whether the NET Alloc checkbox in the Advanced Options is set or not First NET Alloc checkbox is NOT set as follows The corresponding output is below Note background GCs B happening Next GC Collect Only is unchecked and NET Alloc is set Notice the outcome and the fact that this time theres no longer any B instance The results above are reproducible every time Platform specifics PerfView v Windows v build NET Framework bit LegacyJITv This event is large but unused Removing it allows for a substantial increase in the amount of GC allocation data that can be analyzed in one trace Can anyone verify DotNetCalls actually work I cant see any CallEnter events even though I start my processes after the collection This change ensures the GC finalization table contains type information alongside the existing object counts This PR is currently a work in progress the remaining work required for this change is commented in the code as TODO This PR has a brother PR in the runtime repo here so that the information recorded here is decoded The PR is meant for fixing the decoding aspect of When the GC decide which generation to condemn it uses generationtocondemn However after that we have another call to joinedgenerationtocondemn which could potentially veto the decision because of various reasons this PR is meant to record them so that we can use those information to diagnose the decision better maoni vsadov ivdiazsa Add a CPU samples view of various runtime operations and a hierarchical text view The current runtime ops captured are JIT R R and Assembly load events The Assembly load events do not capture startstop data so they are invisible in the CPU samples Future work should add type load events to the runtime and tweak the placement of the R R entrypoint event for better view of loading behavior Hi all I have a Windows x system where Im trying to debug a managed memory leak I can only observe it in production over a fairly long time so Id like to use PerfView to get a heap dump of the situation while the problem is happening The problem is if I attempt to get a heap dump with ETL no file is generated and PerfView displays a message saying error HeapDump failed with exit code What does that mean Is there anything I can do to get a heap dump with ETL Im using The dump works with no ETL but then Im missing crucial information ie within ReferredFrom many objects appear to only be referenced by not reachable from roots not sure why Im following along with the sample code included in the dotnetDiagnostics repository This code uses an EventPipe attachment to a second process to monitor events in real time Im experiencing a problem where the events that appear do not resolve to EventNameTaskName and instead display Task cd f dffa e d b which is the GUID for the Task GarbageCollection the sample utilizes I expected to see actual event names such as GCStartGCEnd Having opened and been redirected to this repository Im wondering if you can offer some insight into this behavior Note that subscribing to EventPipeEventSourceClrAll as shown in samples here does not exhibit this issue Only EventPipeEventSourceDynamicAll Additionally resolving names works fine with custom EventSources but not with CLR sources It sounds like there was an issue with DyamicAll here but it looks like it was resolved I have used these methods to get a list of providers on my machine logman query providers providers TraceEventProvidersGetPublishedProviders providers TraceEventProvidersGetRegisteredOrEnabledProviders providers fluctuates consistently around this number The documentation for GetRegisteredOrEnabledProviders states This is a relatively small list less than unlike GetPublishedProviders I am not getting a small list What is causing this inconsistency Its also worth noting that calling TraceEventProvidersGetProviderName on each of these provider GUIDs only yields names that can be mapped