Hello how are you I want to ask for guidance on what I want to achieve if its possible Until now I use Joi to validate the requests my server receives This week I set up a new TS project from scratch and use iots to declare my interfaces I want to use that interfaces as a single source of truth but also I want to kind of extends those declarations to validate the requests like I do with Joi For example some numbermin max Pseudocode javascript typests export const IUserInput tinterface username tstring password tstring Middleware to validate the input request const UserInputValidate username IUserInputusernamemin password IUserInputpasswordmin max Regarding the simple pseudocode example it would apply for validations of arrays or even custom validations like an array of unique values My goal is to have that one source of truth and avoid rewriting as much code as possible for those exact validations I have been surfing the iots and related libraries but I didnt find some clear way to achieve something like I want Let me know if you have questions on my doubt If you can guide me to the right path to use this awesome library to perform exactcustom validations would be nice Best regards Feature request Current Behavior No bigint codec Desired Behavior Having a bigint codec available like theres for other primitives string number etc Suggested Solution Add a bigint codec to the library Who does this impact Who is this for People who would like to implement codecs on top of bigint or at least thats my case Describe alternatives youve considered Using my own implementation Your environment Software Versions iots fpts TypeScript Node I see that function types are deprecated since I often use iots in libraries to ensure that passed configuration is valid even if consumer is not using typescript and if not fail with a clean error early For this usage having the Function type available is handy So I am curious what is the reason for deprecating the Function type And is it likely to be removed in future in which case Ill probably need to publish a library that exports this I am using iots in a project with a complex data model and Im experiencing severe performance issues with the TypeScript compiler Im wondering if there is a way to help the compiler out and simplify the types without sacrificing correctness or copypasting code Essentially the data model is a structured definition of form fields and corresponding mathematical computations The definitions essentially consist of UI properties calculation metadata and an array of fields The fields themselves are a tagged union type of several intersection types there is a BaseField and various fields that extend it each with required and optional properties I serve these form definitions to my UI over REST and Im using iots to validate the schema The problem is that the generated type output from iots appears to be right at the edge of what TypeScript can handle Either that or Im doing something stupid and I dont see it I have reached a complexity level where the TypeScript compiler hangs indefinitely sucks up all my CPU and makes all my computer fans kick on Here is the definition of my CalculatorField type export declare const CalculatorFieldC tUnionC tIntersectionC tIntersectionC tTypeC name tStringC variable tStringC type tStringC tPartialC columns tNumberC row tNumberC tTypeC type tLiteralCinteger tPartialC initialvalue tRefinementCtNumberC placeholder tStringC tIntersectionC tIntersectionC tIntersectionC tTypeC name tStringC variable tStringC type tStringC tPartialC columns tNumberC row tNumberC tTypeC type tLiteralCdropdown tPartialC initialvalue tStringC tTypeC options tArrayCtStringC tPartialC groups tRecordCtStringC tArrayCtStringC tIntersectionC tIntersectionC tIntersectionC tTypeC name tStringC variable tStringC type tStringC tPartialC columns tNumberC row tNumberC tTypeC type tLiteralCdropdownorcustom custominputoption tStringC custominputfield tIntersectionC tIntersectionC tTypeC name tStringC variable tStringC type tStringC tPartialC columns tNumberC row tNumberC tTypeC type tLiteralCinteger tPartialC initialvalue tRefinementCtNumberC placeholder tStringC tPartialC initialvalue tStringC tTypeC options tArrayCtStringC tIntersectionC tIntersectionC tTypeC name tStringC variable tStringC type tStringC tPartialC columns tNumberC row tNumberC tTypeC type tLiteralCorigindestination Obviously thats not a handwritten definition its the composed result of the various component types This type itself does not have problems However in my UI I use the same type to represent the state of the form in the UI The UI state is an intersection of the Field union type and a value which is a union string number null Defining the following type causes VSCode to stop processing types and causes webpack to hang indefinitely const CalculatorFieldStateC tintersection CalculatorFieldC ttype value tunion tstring tnumber tnull Any ideas Am I doing something stupid and causing an infinite loop without seeing it Is there a way to collapse these types without declaring the full type of every Field by hand I can workaround the problem in the UI I was only defining the above codec to validate state after rehydrating it from browser storage since the structure is likely to change between versions of the app However the complexity of these fields is only going to increase as the app grows with more field types etc The structure stored in the database actually extends from the above Field type because the database contains coefficients and other information that the server uses to perform the calculations that the UI doesnt see It would be an absolute disaster to declare all of the necessary types separately Id appreciate any help Can I somehow reuse already existing TS types to use it at runtime For instance I have TS type type TUser id string name string and I would like to get something like that ttype id tstring name tstring My point is I want to use iots in an existing project and I would not like to rewrite all types Current Behavior ts const C tintersection trecordtliteralfunky tstring trecordtstring tunknown type C tTypeOftypeof C type C funky string x string unknown const lit C funky key more nope Compiles fine Cdecode funky hey more nope Left Expected behavior ts Cdecode funky hey more nope Right PLEASE FILL THIS OUT Software Versions iots fpts TypeScript Currently you cant create an exact recursion type RecursiveType doesnt satisfy the HasProps type even if the type its wrapping does This is easy to fix by adding a HasPropsRecursive type to HasProps and then extending getProps to return getPropscodectype for recursive codecs But now we have another problem calling exact on a RecursiveType forces the lazy evaluation that makes RecursiveType work This causes issues if youre trying to have the exact be part of the recursion For example this fails because the function runs before T is defined const T texacttrecursionT tpartial rec T I fixed this by having exact delay its evaluation of props until forced by someone calling validate or encode on the result I added some tests with a few more examples of things that didnt work before this pullreq Also I bumped the version to since I needed an since for the new types Feature request Current Behavior We get an error that describes the error with respect to the type Desired Behavior Given a stringified version of the input provide a linecolumn position to allow us to provide syntax error highlighting Suggested Solution An optional flag to include a linecolumn The flag might have params for the whitespace assumed for the stringified input Who does this impact Who is this for People who are using iots to validate JSON input fields Sorry if this does not fit the exact issue type format Im struggling to find a way to cleanly use a type that is built from an iots definition which respects the nature of the way iots works where it WILL allow additional properties but will simply ignore them or strip them if exact is used Especially when it comes to more deeply nested structures For example we have some database entities which almost totally match what we define in our iots contracts however they do have some additional properties We want to be able to emit these entities as validated by iots however we get pushback from the interfaces built with iots if those additional properties are present despite that not being the actual behavior of iots itself Any suggestions or examples you all have that could get me a type which more closely matches how iots decode works Documentation Hi Im revisiting iots after being away for a while Im experimenting with it in an express app and Im not sure of the best code style approach Heres an example ts import Router from express import ash from expressasynchandler import isLeft from fptslibEither import as t from iots const ID tbrand tnumber i any i is tBrandednumber readonly ID unique symbol NumberisSafeIntegeri i ID type ID tTypeOftypeof ID const router Router routergetid ashasync req res const idResult IDdecodeNumberreqparamsid if isLeftidResult return resstatusHttpStatusBADREQUESTjson message Invalid User ID const id idResultright const userResult await getUserByIDid return isRightuserResult resjsonuserResultright resstatusHttpStatusNOTFOUNDjson message User not found for this ID I looked at using pipe and fold but the code seems to get very verbose and very indented I also needed to use async callbacks I wasnt sure if errors would be caught properly by Express Is there a better way to write this 