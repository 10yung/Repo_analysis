Describe the bug Getting this warning when building prod webpack config and running it You are currently using minified code outside of NODEENV production This means that you are running a slower development build of Redux You can use looseenvify for browserify or DefinePlugin for webpack to ensure you have the correct code for your production build I think this was already mentioned and resolved but is still happening To Reproduce Steps to reproduce the behavior clone run yarn yarn buildprod and then start with yarn startprod and you would see the warning Expected behavior Warning should not be there as NODEENV is correctly set hello everyone Describe the bug Ive tried to reset the store by following this And I found that the value types from rematch loading plugin have been changed from boolean to integer I have an example based on an nextjswithrematch example using this snippet below to reset the store const store init models redux devtoolOptions rootReducers RESETAPP undefined To Reproduce Steps to reproduce the behavior Clone my custom code Run yarn Run yarn dev Access to Click on the incrementAsync button Click on the Reset App button Observe the Redux devtools Expected behavior The value of loadingeffectscounterincrementAsync changes from false to It should keep that boolean value Screenshots Desktop OS macOS Mojave Browser Chrome Version No references to Redux Toolkit Redux Toolkit seems to have many parallels to this project It is an official redux project The documented rationale of this project seems to target conceptual and painpoints with classic redux that are equally addressed by the Redux Toolkit So the question is How this project differs from Redux Toolkit I think this should be added to the docs On a more critical note For sure there are some api differences between rematch and rtk rtk is also more opinionated eg immer thunks by default But given it brand pitch is The Redux Toolkit package is intended to be the standard way to write Redux logic and given that it should get quite some traction one may ask is it really worth maintaining this project in light of rtk Describe the bug Ive tried some examples from docs ts import createModel Models init RematchRootState RematchDispatch from rematchcore const model createModel state reducers increment state number payload number state payload effects dispatch Dispatch incrementAsync async await new Promiseresolve setTimeout resolve dispatchmodelincrement interface RootModel extends Models model typeof model const rootModel RootModel model typeof model const store init models rootModel type Dispatch RematchDispatchtypeof rootModel type State RematchRootStatetypeof rootModel And this code gives me an error in effects field of my model No overload matches this call Overload of model ModelConfignumber number ModelConfignumber number gave the following error Type dispatch RematchDispatchRootModel incrementAsync Promisevoid is not assignable to type ModelEffectsany dispatch RematchDispatchvoid ModelEffectsany undefined Type dispatch RematchDispatchRootModel incrementAsync Promisevoid is not assignable to type dispatch RematchDispatchvoid ModelEffectsany Types of parameters dispatch and dispatch are incompatible Type RematchDispatchvoid is not assignable to type RematchDispatchRootModel Type key string key string RematchDispatchervoid void RematchDispatcherAsyncvoid void args any Actionany any action Actionvoid void DispatchActionvoid void action Action Dispatch Dispatch is not assignable to type RematchDispatchRootModel Type key string key string RematchDispatchervoid void RematchDispatcherAsyncvoid void args any Actionany any action Actionvoid void DispatchActionvoid void action Action Dispatch Dispatch is not assignable to type ExtractRematchDispatchersFromModelsRootModel args any Actionany any action Actionvoid void DispatchActionvoid void action Actionvoid void Dispatch Dispatch Property model is missing in type key string key string RematchDispatchervoid void RematchDispatcherAsyncvoid void args any Actionany any action Actionvoid void DispatchActionvoid void action Action Dispatch Dispatch but required in type ExtractRematchDispatchersFromModelsRootModel Overload of model ModelConfigany any ModelConfigany any gave the following error Type dispatch RematchDispatchRootModel incrementAsync Promisevoid is not assignable to type ModelEffectsany dispatch RematchDispatchvoid ModelEffectsany undefined Type dispatch RematchDispatchRootModel incrementAsync Promisevoid is not assignable to type dispatch RematchDispatchvoid ModelEffectsany I assume this might be because of RematchDispatchvoid type It is incompatible with RematchDispatchRootModel Expected behavior Work without any errors Desktop please complete the following information OS Window Browser Chrome Additional context TypeScript version Describe the bug When using storemodel to add a model to an existing store the store types dont include the new model Expected behavior After using storemodel and add a new model the storedispatch didnt recognize the new model in the store Is expected that types are working properly and the new model can be recognized This is a big one sorry about that and still work in progress a couple of things left those are listed at the bottom It includes Moving the packages to lerna Unifying the building and testing process by using tsdx Moving tests to TypeScript All the tests were updated and should be passing Moving from TSLint to ESLint as the former will be deprecated now there is one eslint config for all the repository Improving and probably breaking a little bit typescript definitions primarily for the core package Im not using TypeScript much therefore this was a challenge I tried to see in the issues what problems are with TS but this definitely still requires work to make it perfect I also tried to improve types that are used only internally in plugins or the core package to make the life of people maintaining the repo easier To make the code a little bit easier to understand and extend I tried to limit the usage of this binding and instead replace it with passing an instance of Rematch class to functions Besides that I did some code cleanup Its still not perfect though so Im open to suggestions Adding new plugins hooks onReducer and onRootReducer Changing middleware hook to createMiddleware it is a function that returns the same thing as before but now accepts Rematch instance as the input Improving the plugins it is now possible to use both persist and immer plugins Persist was updated to v and it is also now possible to use nested persisted reducers Immer plugin has now additional config its possible to whitelistblacklist reducers Removing deprecated things there are some breaking changes therefore I believe its safe to remove stuff that makes the code dirty For example Im not sure we need the exposed property in plugins The dispatch and effects plugins could actually not be plugins even though it makes perfect sense but just the integral part of the Rematch class since they are always there anyway This way the properties like dispatch or createDispacher are part of Rematch class Other plugins whenever they want to expose something they can just assign property in Rematch class using plugins onInit hook or add stuff to store in onStoreCreated This would make the plugins api easier and more typesafe I believe Todos Update the documentation readme changelogs Checkfix the examples Update travis configuration Im not sure exactly how to change it would appreciate some help with it Im open to any critique and suggestions Hi I love rematch and typescript and currently Im using the persist immer and navigation plugins The navigation plugin doesnt have a indexdts file when importing it I manually added it in my nodemodules and was going to make a pull request to add it to the plugin but wasnt sure how to approach it Its probably a quick fix and is more of a convenience than an issue One important purpose for loading handling is to avoid calling one effect the second time when there is already another call undergoing for same effect Before using rematch this logic is done like below with reduxthunk ifstatesomeReducerloading check loading flag dispatchsomeActionStart set loading flag to true api fetch dispatchsomeActionComplete set loading flag to false By using rematch loading plugin the code looks like const loading stateloadingeffectssomeModelsomeEffect ifloading api fetch Now the problem is that I found when the effect is been called Loading flag for that effect is directly changed to true So the api is not called even once I found that this loading is correct if the check is put directly in component But I insist this logic should be in the effect because the only job for component is to call the effect Whether effect will trigger a new fetch or wait for the data of current fetch to return they are all about api handing The api effect should be responsible to handle it I would like to know if there are any good ways to use loading plugin in effect Thank you very much All the examples I see show the following type exported from the store file js export type Dispatch typeof storedispatch My issue is Im creating my store in a function like the below js export function createStoreinitialState unknown RematchStore return init models redux initialState The reason for this is so it can be created fresh each time when server rendered as seen in the Next example Is there a way for me to achieve the same typing without accessing the return value from init Ive studied the typings but not found an obvious answer This same issue also seems to apply to accessing getState Breaking changes with v Global imports of dispatch and getState have been removed Instead you can export and import your store capturing storedispatch storegetState Again Im struggling with not having store as a singleton I can export Any help appreciated Edit Ive had some success with the following when using Hooks but not connect js const models channel cms export type Dispatch RematchDispatchtypeof models Does this seem correct