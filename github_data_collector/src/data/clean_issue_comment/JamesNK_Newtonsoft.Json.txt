 Sourcedestination types csharp readonly struct ReadOnlyTestValue IEquatableReadOnlyTestValue public readonly int Item public readonly string Item public ReadOnlyTestValueint item string item Item Item item item sealed class ReadOnlyTestValueMessage IEquatableReadOnlyTestValueMessage public readonly string Item public readonly ReadOnlyTestValue Item public ReadOnlyTestValueMessagestring item in ReadOnlyTestValue item Item Item item item Sourcedestination JSON javascript typeMyUnitTestsReadOnlyTestValueMessage MyUnitTestsItem value Item typeMyUnitTestsReadOnlyTestValue MyUnitTestsItem Item value Expected behavior The json should be deserialized back without exceptions Actual behavior It throws only when TypeNameHandlingAll or Auto is set for the JsonConvertDeserializeObject call the deserializion is working with TypeNameHandlingNone NewtonsoftJsonJsonSerializationException Type specified in JSON MyUnitTestsReadOnlyTestValue MyUnitTests Version Cultureneutral PublicKeyTokennull is not compatible with MyUnitTestsReadOnlyTestValue MyUnitTests Version Cultureneutral PublicKeyTokennull Path Item type line position Steps to reproduce csharp Fact public void readonlyvaluemessagewithtypemetashouldbeserializable var v new ReadOnlyTestValue value var p new ReadOnlyTestValueMessagevalue v var settings new JsonSerializerSettings TypeNameHandling TypeNameHandlingAll var s JsonConvertSerializeObjectp settings var p JsonConvertDeserializeObjectReadOnlyTestValueMessages settings AssertEqualp p If you execute NewtonsoftJsonJsonConvertSerialize on a custom object defined in an assembly in a collectible AssemblyLoadContext the AssemblyLoadContext can no longer be unloaded It obviously happens because of using a number of different caches like ConvertUtilsCastConverters with strong references and without any possibility to remove them but reflection which seems like a bad workaround Existing implementation does not treat numbers in any special way Theyre treated most closely to lowercase characters This change provides an options numbersAsWords that permits viewing numbers as capable of starting and stopping a word Closes JamesNKNewtonsoftJson If you have questions about how to use JsonNET please read the JsonNET documentation or ask on Stack Overflow There are thousands of JsonNET questions on Stack Overflow with the jsonnet tag GitHub issues are only for reporting bugs not questions or help Im integrating an API using kebab casing and views numbers as their own words For example for a C property name of Street of an Address object the serialized member name needs to be street Now this is easily achievable using the JsonProperty syntax if you have access to the model type and if not a custom NamingStrategy to take matters into your own hands Another option is updating StringUtilsToSnakeCase and StringUtilsToKebabCase to support an optional numbersAsWords parameter and adding SeparatedCaseStateNumber to the enum along with an accompanying case handler in the ToSeparatedCase helper method Sourcedestination types csharp public class Address public string Street get set public string Street get set Sourcedestination JSON javascript street Hickory Street street Suite D Expected behavior The jsonnet provides options to support the above naming strategy outofthebox Actual behavior The jsonnet API does not support viewing numbers as their own words via the provided NamingStrategy implementations Sorry if this is the wrong venue but I did not know where to ask this question Can someone tell me how I Can deserialize the following array of project info into a container object with a list The reason I need to have a container object is because when there is an error the response changes from array to Json error The Json response appears to be an array without a name projectcodeTNTPHTESTtitleTNTPHTEST projectcodePOIPROJtitlePoinsettia ProjectsprojectcodeDOLASSETtitleDolphin Facility In case of error the Json will appear like the following errorcode errorNot FounderrordescriptionNo projects data found My Classes definition Container Class Definition public class AssaiProjectCodeInfoResponse JsonPropertydata public ListAssaiProjectInfo Data get set JsonPropertyerrorcode public string ErrorCode get set JsonPropertyerror public string ErrorTitle get set JsonPropertyerrordescription public string ErrorDescription get set Array Item class Definition public class AssaiProjectInfo JsonPropertyprojectcode public string ProjectCode get set JsonPropertytitle public string Title get set When I call JsonConvertDeserializeObjectAssaiProjectCodeInfoResponseJsonString I get Exception Cannot deserialize the current JSON array eg into type AssaiApiClientAssaiObjectsAssaiProjectCodeInfoResponse because the type requires a JSON object eg namevalue to deserialize correctly To fix this error either change the JSON to a JSON object eg namevalue or change the deserialized type to an array or a type that implements a collection interface eg ICollection IList like ListT that can be deserialized from a JSON array JsonArrayAttribute can also be added to the type to force it to deserialize from a JSON array Path line position input json ErrorMessageTransaction has been authorized successfully ControlId Authorizations RMATranUUID c a f d cf ae d ba e d fe Payments PaymentNumber TotalPaymentsNumber AmountDue AmountPaid Term OTBReleaseAmountnull RMATranUUIDb ba c dbd ec afbafbe OTBReleaseAmountnull Output json After parsing JObject jsonPacket JObjectParseinputString Line no second changes to ErrorMessage Transaction has been authorized successfully ControlId Authorizations RMATranUUID c a f d cf ae d ba e d fe Payments PaymentNumber TotalPaymentsNumber AmountDue AmountPaid Term OTBReleaseAmount null RMATranUUID b ba c dbd ec afbafbe OTBReleaseAmount null Thank you Summary JsonConvertDeserializeObject throws an error The readers MaxDepth of has been exceeded when I try to deserialize objects only with levels of depth MaxDepth of is the default value for AddNewtonsoftJson in AspNetCore Environment Im using NuGet in my AspNetCore project IncludeMicrosoftAspNetCoreMvcNewtonsoftJson Version Type NewtonsoftJsonJsonConvert Assembly NewtonsoftJson Version Cultureneutral PublicKeyToken ad fe b a aeed Assembly location C Users MyUser nuget packages newtonsoftjson lib netstandard NewtonsoftJsondll Sourcedestination types csharp public class FolderCopy Required public string Property get set Required public string Property get set Range intMaxValue public int Property get set Range intMaxValue public int Property get set Required MinLength public FolderCopyItem Roots get set public class FolderCopyItem Required public string Property get set Required public string Property get set Range intMaxValue public int Property get set Range intMaxValue public int Property get set public string Property get set public string Property get set public string Property get set Required MinLength public FolderCopyItem Children get set Sourcedestination JSON javascript The readers MaxDepth of has been exceeded Path Roots Children Children Children Children Children Children Children Children Children Children Children Children Children Children Children line position Expected behavior Successful deserialize Actual behavior The readers MaxDepth of has been exceeded Steps to reproduce csharp var json JsonConvertSerializeObjectnew FolderCopy Roots ReproduceOnly LevelsparentChildren here we reproduce levels of tree Property parentProperty Property parentProperty Property parentProperty Property parentProperty here is okay levels parent object levels JsonConvertDeserializeObjectFolderCopyjson new JsonSerializerSettings MaxDepth here is error JsonConvertDeserializeObjectFolderCopyjson new JsonSerializerSettings MaxDepth works well The following queries provide results that do not match those of other implementations of JSONPath compare Input first second third Expected output third Error Index was out of range Must be nonnegative and less than the size of the collection Parameter index key Input key value Expected output value Error Unexpected character while parsing path indexer Input key value another key complex string primitives Expected output string value complex string primitives Actual output string value complex string primitives another key complex string primitives key value Input null Expected output null Actual output null null Input some string int object key value array Expected output string key value Actual output Input string key value Expected output string key value Actual output For reference the output was generated by the program in If you have questions about how to use JsonNET please read the JsonNET documentation or ask on Stack Overflow There are thousands of JsonNET questions on Stack Overflow with the jsonnet tag GitHub issues are only for reporting bugs not questions or help It seems like that custom value converters failed to handle nullable values when serializing objects Sourcedestination types csharp public sealed class MyValueConverter JsonConverter public override void WriteJsonJsonWriter writer object value JsonSerializer serializer serializerSerializewriter MyValueConverter value public override bool CanRead false public override object ReadJsonJsonReader reader Type objectType object existingValue JsonSerializer serializer throw new NotSupportedException public override bool CanConvertType objectType return objectTypeIsEnum public enum Bar Hello World public sealed class Foo public Bar SomeValue get set public Bar SomeOtherValue get set Were going to serialize Foo with the custom json converter MyValueConverter Sourcedestination JSON javascript SomeValueMyValueConverter HelloSomeOtherValue Expected behavior What did you expect to happen Both of SomeValue and SomeOtherValue should be serialized as MyValueConverter Hello Actual behavior But SomeOtherValue is serialized by the default behavior of serializing enum types Steps to reproduce csharp var data new Foo SomeValue BarHello SomeOtherValue BarHello var converter new MyValueConverter ConsoleWriteLineJsonConvertSerializeObjectdata converter Sourcedestination types csharp using var reader new StreamReaderinputStream using var jsonReader new JsonTextReaderreader DateParseHandling DateParseHandlingNone DateTimeZoneHandling DateTimeZoneHandlingUtc var json JObjectLoadjsonReader json value ValueDateTimeKind Is Local should be Utc json value Value as DateTimeKind Is Local should be Utc Sourcedestination JSON javascript value T Z Expected behavior Kind property to be UTC Actual behavior Instead of passing a pointer to the parsing settings into the JTokens created and then using DateTimeUtils there is usage of ConvertToDateTime which uses some default implementation does not consider other supported parsing formats and does not consider specified parsing behavior This introduces inconsistent behavior Could also be address without significant overhead by wrapping the settings of JsonReader in a settings object and passing a pointer to it into JTokens created by it or by simply passing a pointer to the JsonReader itself 