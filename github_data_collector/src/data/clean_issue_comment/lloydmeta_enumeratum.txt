Were using enumeratum successfully when dealing with enum values both with Circe and with Quill We define something like this sealed abstract class TopicTypeval value String extends StringEnumEntry object TopicType extends StringEnum TopicType with StringCirceEnum TopicType with StringQuillEnum TopicType object Info extends TopicTypeinfo object Warning extends TopicTypewarning val values immutableIndexedSeq TopicType findValues case class representing our MySQL payload table case class Payloadid String topic TopicType and use Payload when decoding encoding mysql and json using Quill and Circe With Quill and MySQL this works fine with the following table create table payload id varchar not null primary key topictype enum info warning not null However I cannot for the life of me figure out how to make this work when using optional fields for our enumeratum type We want to be able to use the payload class like this case class Payloadid String topic Option TopicType When trying to use an optional topic and read from our database using Quill with run query Payload filterpayload payloadid liftsomeId we get javautilNoSuchElementException null is not a member of ValueEnum warning info ValueEnumscala Same thing happens if I do a leftJoin to a table that holds an Enum in it eg case class Payloadid String case class PayloadDatapayloadId String topic TopicType run query Payload leftJoinquery PayloadData onp pd pid pdpayloadId Could it be that we need to specify some custom decoder encoder to handle options null values Passing an invalid name to namesToValuesMap returns an unhelpful NoSuchElementException with no message to indicate what the invalid value was domainDocTypenamesToValuesMapGreg javautilNoSuchElementException at scalacollectionimmutableBitmapIndexedMapNodeapplyHashMapscala at scalacollectionimmutableHashMapapplyHashMapscala elided Compare to withName which gives a much nicer message but this doesnt help as enumeratumslick uses namesToValuesMap so you could optionally consider this as a bug in SlickEnumColumnSupport warn Emitted value instead of an instance of Error Cannot find source file lloydDocumentsskalaenumeratumenumeratumcoresrcmainscalaenumeratumEnumEntryscala Error Cant resolve lloydDocumentsskalaenumeratumenumeratumcoresrcmainscalaenumeratumEnumEntryscala in UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermain warn NonErrorEmittedError Emitted value instead of an instance of Error Cannot find source file lloydDocumentsskalaenumeratumenumeratumcoresrcmainscalaenumeratumEnumEntryscala Error Cant resolve lloydDocumentsskalaenumeratumenumeratumcoresrcmainscalaenumeratumEnumEntryscala in UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermain warn at emitWarning UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemoduleswebpacklibNormalModulejs warn at UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulessourcemaploaderindexjs warn at onError UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at runAfter UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at innerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibUnsafeCachePluginjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at runAfter UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at innerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at innerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at resolverdoResolvecreateInnerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibDescriptionFilePluginjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at afterInnerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at afterInnerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at runAfter UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at innerCallback UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs warn at loggingCallbackWrapper UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibcreateInnerCallbackjs warn at next UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulestapablelibTapablejs warn at runAfter UsersdevCodeScalascalajsprojectclienttargetscala scalajsbundlermainnodemodulesenhancedresolvelibResolverjs I think that val profile slickjdbcProfile has changed it is not found Also when extending from SlickEnumSupport many other slick implicit mappings are no longer found Is it possible to check if an update is needed to the slick integration part of the README My frontend expects enums to be in the style of JAVAENUMS the current converters didnt do the trick for me so I created this one import enumeratumEnum EnumEntry import playapilibsjson trait PlayFromToJavaEnum A EnumEntry self Enum A def entryNameToEnumNamein String String incharAt insubstring replaceAll AZ toUpperCase Map of A object names to A s lazy val nameLikeEnumToValueMap Map String A valuesmapv entryNameToEnumNameventryName vtoMap Optionally returns an A for a given name assuming the value is upper case def withNameLikeJavaEnumOnlyOptionname String Option A nameLikeEnumToValueMapgetname def readsJavaEnumLikeOnlyenum Enum A Reads A case JsStrings withNameLikeJavaEnumOnlyOptions match case Someobj JsSuccessobj case None JsErrorerrorexpectedvalidenumvalue case JsErrorerrorexpectedenumstring def writesJavaEnumLikeOnlyenum Enum A Writes A v JsStringentryNameToEnumNameventryName implicit val jsonFormat Format A FormatreadsJavaEnumLikeOnlyself writesJavaEnumLikeOnlyself Not sure this is worth to be included in the main distribution or if u see issues with it Would be happy about a discussion I couldnt find any examples of how to implement inheritance beyond the Animals test but that didnt look complete This appears to work but I just wanted to check this is the correct approach Thanks for the library import enumeratum sealed trait Greeting extends EnumEntry object Greeting extends Enum Greeting val values findValues CasualGreetingvalues PoliteGreetingvalues object CasualGreeting extends Enum Greeting val values findValues case object Hey extends Greeting object PoliteGreeting extends Enum Greeting val values findValues case object Hello extends Greeting printlnGreetingwithNameHello printlnGreetingwithNameHey Hi Im using akkahttp with SprayJsonSupport it would be awesome to add spray json support out of box Enum gives you withName which throws whether you like it or not It also gives you safe versions but it discourages you from using them because they have longer names It would be nice to be able to make the opposite choice to have only the safe methods Eg def withNamename String Try A and variants Or Option not Try People who really want to force the Try could call FoowithNamebarget which would be visible to eg wartremover in user code I ran into an issue with ValueEnumMacros I want to write something like this with binary notation It was important for me to make sure all of them are different and form an enumeration but seeing the binary values is important I dont want to write them as base integers scala sealed abstract class MacroEvalval value Int extends IntEnumEntry case object MacroEval extends IntEnum MacroEval import spiresyntaxliteralsradix case object Zero extends MacroEvalx case object One extends MacroEvalx case object Two extends MacroEvalx val values findValues The x notation is done with macros from Spire and expands into a integer at compile time Except it wont work with Enumeratum as is because the macros for ValueEnum wont evaluate the expression they receive and rather expect a Literal I implemented something that seems to not break stuff and work for my use case I had to mess with the SBT build a bit I dont understand why the sub projects depend on external binaries and not the code It would be nice to have some pointer on how to develop on the project Anyway I wanted to post something that works and can be tested Let me know what you think Before merging I will revert those changes off course Hey Nice project I would like to have a bit of syntactic sugar it would be nice to select the value field by an annotation to avoid the overhead of overriding the value method Here is an example sealed abstract class CodeValue val value Int val door String extends IntEnumEntry Is it realizable