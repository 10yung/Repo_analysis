Play since we switched to Sbt we have duplicate test reports for all the play modules in our multimodule build the ones with enablePluginsPlayScala for those modules the targettestreports looks like this orgfooXSpecxml orgfooYSpecxml TESTorgfooXSpecxml TESTorgfooYSpecxml where for nonplay modules we only have the TESTprefixed files The sbt release notes mention a change in the junit reporting output The play plugin must be changing some test options that cause the reports to be generated twice Play Version A build off of the x branch current HEAD is da a d e c a fe df e e d eed Operating System macOS JDK java version ea JavaTM SE Runtime Environment build eab Java HotSpotTM Bit Server VM build b mixed mode Library Dependencies sbt Expected Behavior Running run the server is started the code is compiled file watching is started Actual Behavior The execution of the Compile run task fails with error javalangNoSuchMethodError comsunjnaNativeloadLjavalangStringLjavalangClassLcomsunjnaLibrary error at iomethvinwatchservicejnaCarbonAPIclinitCarbonAPIjava error at iomethvinwatchservicejnaCFStringReftoCFStringCFStringRefjava error at iomethvinwatchserviceMacOSXListeningWatchServiceregisterMacOSXListeningWatchServicejava error at iomethvinwatchserviceWatchablePathregisterWatchablePathjava error at iomethvinwatcherDirectoryWatcherregisterDirectoryWatcherjava error at iomethvinwatcherDirectoryWatcherregisterAllDirectoryWatcherjava error at iomethvinwatcherDirectoryWatcherinitDirectoryWatcherjava error at iomethvinwatcherDirectoryWatcherBuilderbuildDirectoryWatcherjava error at playdevfilewatchDefaultFileWatchServicewatchDefaultFileWatchServicescala error at playdevfilewatchFileWatchServiceanon watchFileWatchServicescala error at playrunsupportReloaderinitReloaderscala error at playrunsupportReloaderreloaderlzycompute Reloaderscala error at playrunsupportReloaderplayrunsupportReloaderreloader Reloaderscala error at playrunsupportReloaderstartDevModeReloaderscala error at playsbtrunPlayRundevModeServerlzycompute PlayRunscala error at playsbtrunPlayRundevModeServer PlayRunscala error at playsbtrunPlayRunanonfunplayRunTask PlayRunscala error at playsbtrunPlayRunanonfunplayRunTask adaptedPlayRunscala error at scalaFunction anonfuncompose Function scala error stack trace is suppressed run last Compile run for the full output error Compile run javalangNoSuchMethodError comsunjnaNativeloadLjavalangStringLjavalangClassLcomsunjnaLibrary Reproducible Test Case publishLocal Play x Take current HEAD Update Play to the published version Optional Update sbt from to start sbt run run Hello Sorry if this is a duplicate but I havent found such an issue I have an API that provides CRUD operations for some entities Read and write models are almost the same ie they have same sets of fields but different constraints on them case class PersonReadname String age Option Int case class PersonWritename Option String age Option String What Im trying to do is to define a single case class for both models sealed trait Mode type Required T type Optional T object Mode trait Read extends Mode override type Required T T override type Optional T Option T trait Write extends Mode override type Required T Option T override type Optional T Option T case class Person m Mode name mRequired String age mOptional Int In reality I have more complex models plus some other modes other than Read and Write and more constraint types other than Required and Optional so such a solution will help me a lot The problem is that I cant use Play json marcos with such case classes implicit val writes Reads Person ModeRead Jsonreads Person ModeRead I get the following error at compile time Error No instance of playapilibsjsonReads is available for controllersModeRequired javalangString controllersModeOptional scalaInt in the implicit scope Hint if declared in the same file make sure its declared before implicit val writes Reads Person ModeRead Jsonreads Person ModeRead Im using Play Is there any trick that can make it work Thanks Play Version Play with sbt API Scala Operating System Windows Pro JDK openjdk version OpenJDK Runtime Environment AdoptOpenJDK build OpenJDK Bit Server VM AdoptOpenJDK build mixed mode Expected Behavior git clone gitgithubcomplayframeworkplaysamplesgit cd playsamplesplayscalahelloworldtutorial sbt run Make a change to source code Recompilation is triggered when files are changed Actual Behavior Recompilation is not triggered Refreshing the browser window making a request to the app does trigger recompilation but AFAIK this should happen already when files change Downgrading to sbt makes triggered execution work again as expected Triggered execution for the compile task works using any version of sbt I have tried so this issue is only about the run command with sbt x on Windows I have tried different fileWatchService implementations but the issue persists Improve the Play documentation of forms nested values to better illustrate multiple nested values At the moment the documentation illustrates a single nested value at the end of the form val userFormNested Form UserAddressData Form mapping name text address mapping street text city text AddressDataapplyAddressDataunapply UserAddressDataapplyUserAddressDataunapply Here AddressDataapplyunapply directly precedes the UserAddressDataapplyunapply What isnt clear for those that dont know is Where do the apply unapply calls go Do they go last overall as it seems to be illustrated in the documentation or do they belong at the end of each mapping Perhaps something along the lines of the following would be better to illustrate the applyunapply is directly after the matching mapping Ie val userFormNested Form UserAddressData Form mapping name text homeAddress mapping street text city text HomeAddressDataapplyHomeAddressDataunapply workAddress mapping street text city text WorkAddressDataapplyWorkAddressDataunapply UserAddressDataapplyUserAddressDataunapply Play Version Updates orghibernatejavaxpersistencehibernatejpa api from Final to Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orghibernatejavaxpersistence artifactId hibernatejpa api details labels libraryupdate Pull Request Checklist x Have you read How to write the perfect pull request x Have you read through the contributor guidelines x Have you signed the Lightbend CLA x Have you referenced any issues youre fixing using commit message keywords x Have you added copyright headers to new files x Have you checked that both Scala and Java APIs are updated x Have you updated the documentation for both Scala and Java sections x Have you added tests for any changed functionality Helpful things Fixes Fixes Purpose What does this PR do To support both null and in playfilterscorsallowedOrigins to allow any origin to access the resource playfilterscorsallowedOrigins null OR playfilterscorsallowedOrigins Background Context This is my first commit to Play be happy to hear your advices References NO incurs some amount of maintenance and were considering removing it After speaking with Ethan who has put in a lot of time working on sbt s file watching he suggests looking at sbtios Glob FileTreeRepository and FileEventMonitor which is a wrapper for the repository aggregating callbacks as the replacement for the usage of playfilewatch A much bigger project would be to remove Plays overriding of run and hijacking of run to use sbts own run file watching and classloader improvements Topics also touched were Lagoms reloadwithoutrefresh feature migrating to sbtrevolver instead working with the sbt team to bring playlagoms dev mode needs in sbt proper and of course forked dev mode The last release was Play Updates junitjunit from to Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId junit artifactId junit details labels libraryupdate play version api java os x GNULinux java version openjdk version I make reference to create a websocket framwork running at three aws c large instance each have connections in average there are channels the problem is after about one week or two one channel stoped without any exception data producer like this initial SourceTicker SourceQueueWithCompleteTicker sourceQueueWithCompleteSource SourcequeueconfiggetIntqueuebuffersize OverflowStrategybackpressure PairSourceQueueWithCompleteTicker SourceTicker NotUsed sinkSourcePair sourceQueueWithCompleteSourcelogtickerQueue toMatBroadcastHubofTickerclass configgetIntbroadcastbuffersize Keepbothrunthismat inputQueue sinkSourcePairfirst source sinkSourcePairsecond drain for not accumulate sourcerunWithSinkignore thismat schedule gain data from pubsub mediator and push these data into queue tickerMapvaluesforEachp try QueueOfferResult result inputQueueoffernew TickerpgetTicker TICKER toCompletableFutureget TimeUnitSECONDS catch Exception e exceptionTimes handle ws processor request and response the source to the ws sendertellnew MessagesWatchTickerResulttickersymbol sourcebackpressureTimeoutbackPressureTimeout self when channel stoped inputQueueoffer cannot push any element forever so the channel stopped pub element I have tried to solve this for a long time finally have to monitor exceptionTimes somenumber and restart data producer to recover but seems ugly is there something wrong 