When working on libp pquic I found many bugs that did not reproduce unless I ran the test case thousands of times This is not practical to do by hand but is trivial to automate so it might be beneficial for some tests Fixes Currently reading from a stream in a closed connection can sometimes return Blocked which makes no sense Is it possible to avoid using unbounded channels My attempts to do so have lead to intermittent deadlocks that I have not successfully been able to debug Ive been working on this H interop server to deploy on h stammweu Im not sure well want to merge this into quinn as it may be out of scope The reasons why I think we need to separate h interop from the example code are Interop already needs will need a different set of features For example transfer tests are based on urls like The example code will be kept simple It may be interesting to implement remote logging for people running their interop client against this endpoint They could filter by IP or CID with a simple web app served via h h For the moment Im stuck on a bug where requesting more than M results in the client missing the tail of a Data frame Receiving the start of a fresh Data frame instead This PR also contains fixes for critical bugs in data writing management parsing incomplete frame headers quinnproto is difficult to use and one of the reasons is that there is no example code provided outside of its own test cases Would it be possible for quinnproto to support nostd Quinn currently errors out if I try to connect to an IP address presumably because webpki does not support them However my code uses a custom certificate verifier that does not use webpki Presently every application write produces at least one stream frame This can add significant bandwidth overhead for very small writes While repeated very small writes are not optimal in any case we should do better One approach would be to maintain a buffer of pending data for each open outgoing stream from which stream frames can be computed on demand For efficiency a list of streams with nonempty buffers should also be maintained A simple implementation could leave retransmits to the existing logic while a more advanced one might take responsibility for those as well Allowing only idempotent methods to be sent before the handshake has finished And replace expect in quinnh clientConnectinginto rtt by a proper error type