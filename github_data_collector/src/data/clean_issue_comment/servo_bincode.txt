rust fn main let orig Vecu vec let coded bincodeconfiglimit serialize origunwrap println coded let res Vecu bincodeconfiglimit deserialize codedunwrap The above program runs without errors Size limits seem to mostly work when encoding but they fail to prevent the attacks they are meant to protect from It looks to me like the size of chars isnt counted either when decoding Maybe size limits should be removed At least my usecase doesnt want a size limit If they are kept the code should be refactored so that it is impossible to read bytes without advancing the size counter That would be fairly easy especially if the dependency on ioRead in demodrs is replaced with BincodeRead Based on it may be a good idea to avoid readexact for performance anyway I did some cleanup while studying the source of bincode I was getting a bunch of warnings like this warning use of deprecated item try use the operator instead bincodesrcsermodrs tryselfaddvaluevariantindex With the latest compiler cargo bc e c be This change tries to fix them As far as I can see bincodeserialize cannot actually return an Err If it cannot maybe this could be documented and hopefully the return type changed to Vecu ifwhen v gets out If it can hopefully the ways in which it can return an Err could be documented as there is no obvious case I could think of Anyway thank you for bincode Im still starting using it but it looks really neat This strips tests from the published crate but all the devdependencies are still listed This means consumers eg Linux Vendors such as debian gentoo fedora are unable to run any useful tests for Quality Assurance purposes but the Cargo configuration will still require dependencies to be fetched and built in order to run no tests The tests themselves dont seem problematic or bloaty so I dont see any good reason to be avoiding a mere k If publishing with the whole test suite is undesirable perhaps split the test suite into and then only strip some of it not all of it It seems like using Configwithserializer bypasses the Config checks for some reason Using the branch I can reproduce this issue rust struct AcceptorT value T implT AcceptorT fn newvalue T Self Self value impla T SerializerAcceptor for AcceptorT where T Serialize type Output StdResult Error fn acceptSself serializer S SelfOutput where S SerializerOk Error Error selfvalueserializeserializer test fn toobigserializeacceptor let acceptor Acceptornew u let mut buf vec This doesnt error assertconfiglimit withserializer mut buf acceptoriserr let acceptor Acceptornew u assertconfiglimit withserializer mut buf acceptorisok Which produces this error thread toobigserializeacceptor panicked at assertion failed configlimit withserializer mut buf acceptoriserr This allows the user to retreive concrete types from the serializer deserializer output This closes Currently its not possible to return any meaningfull error type from the SerializerAcceptor trait This is because the accept method is generic so you cant know ahead of time the SError type of the Serializer rust pub trait SerializerAcceptor The return type for the accept method type Output Accept a serdeSerializer and do whatever you want with it fn acceptT serdeSerializerself T SelfOutput edit Removed dumb stuff In the documentation is says str is encoded as u u where the u is the number of bytes contained in the encoded string I am looking for a way around this to explicitly control how the length is serialized This is similar to and I could not find a good way to implement this even manually I can create a custom type and implement Serialize but calling serializebytes adds a length prefix and there doesnt appear to be any other way to induce a call to writeall Would it be possible to do this by adding a Bincode specific trait extending Serialize perhaps If that can be solved Deserialization seems like it should be straight forward 