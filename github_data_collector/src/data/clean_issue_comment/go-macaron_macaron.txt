Hi The init method for macaron causes a panic if the current working directory cannot be read Because this runs on init even if macaron is not going to be started if it is linked to a binary it will prevent the binary from starting if it is started in a nonreadable working directory A workaround is possible but its not ideal Is there any way to avoid panicking here At the moment the IfNoneMatch header is ignored whereas it should be checked to be the same as the ETag of the file being served by the static handler Currently the static content is always served even when Macaron should close the connection with a Not Modified response Ive added this functionality to Gitea in this PR Id be very glad to port it over to the official macaron repo if Unknown is available to review merge the PR Nowadays every webserver must run over HTTPS TLS Golang Autocert automatically generates and manages Lets Encrypt certs The method below is a suggestion to include to Macaton struct to be very easy to all GoMacaron users run their web applications over HTTPS RunWithAutoCert the http server with Lets Encrypt Cert automatically generated Listening by default func m Macaron RunWithAutoCert host port GetDefaultListenInfo port addr host comToStrport logger mGetValreflectTypeOfmloggerInterfacelogLogger server httpServer Addr addr Handler m certManager autocertManager Prompt autocertAcceptTOS Cache autocertDirCachecerts serverTLSConfig tlsConfig GetCertificate certManagerGetCertificate loggerPrintflistening HTTPS on s s n addr safeEnv loggerFatallnserverListenAndServeTLS about http push reference HTTP Server Push httpHandleFunc funcw httpResponseWriter r httpRequest if pusher ok whttpPusher ok Push is supported if err pusherPushappjs nil err nil logPrintfFailed to push v err below is my code m macaronNew mGet funcctx macaronContext if push ok ctxResphttpPusher ok logPrintlnok push else logPrintlnno mGetpushTest funcw httpResponseWriter r httpRequest if pusher ok whttpPusher ok logPrintlnok pusher else logPrintlnno logPanichttpListenAndServeTLS servercrt serverkey m output is always noDo not support it Real and serious web applications need to run over HTTPS So how could I start a Macaron instance over HTTPS I didnt find any docs explaining how to do it It seems the Macaron has this lack of functionality Am I right My team had to create the following workaround macarongo Run the http server Listening on osGetEnvPORT or by default func m Macaron Runargs interface host port GetDefaultListenInfo var fullchain privateKey string if lenargs switch arg args type case string host arg case int port arg else if lenargs if arg ok args string ok host arg if arg ok args int ok port arg if arg ok args string ok fullchain arg if arg ok args string ok privateKey arg addr host comToStrport logger mGetValreflectTypeOfmloggerInterfacelogLogger loggerPrintflistening on s s n addr safeEnv if lenfullchain loggerFatallnhttpListenAndServeTLSaddr fullchain privateKey m return loggerFatallnhttpListenAndServeaddr m maingo if port appRun port getFullchainPemFilePath getPrivatekeyPemFilePath return Is there an alternative Or should we send a PullRequest with a new RunOverTLS function to be added into macaron package Well be glad to help the project We just want to avoid duplicated work if an existent solution already have been in place Cheers Macaron PANIC reflect call of reflectValueInterface on zero Value usrlocalgosrcruntimepanicgo x a d gopanic reflectcallnil unsafePointerdfn deferArgsd uint dsiz uint dsiz usrlocalgosrcreflectvaluego x a fa valueInterface panic ValueErrorreflectValueInterface usrlocalgosrcreflectvaluego x a ValueInterface return valueInterfacev true homesimongosrcgithubcomgomacaronbindingbindinggo x ec b validateField sliceValue sliceValInterface homesimongosrcgithubcomgomacaronbindingbindinggo x e fe validateStruct errors validateFielderrors zero field fieldVal fieldValue homesimongosrcgithubcomgomacaronbindingbindinggo x e a validateStruct errors validateStructerrors fieldValue homesimongosrcgithubcomgomacaronbindingbindinggo x d Validatefunc errors validateStructerrors obj usrlocalgosrcruntimeasm s x da call CALLFN call usrlocalgosrcreflectvaluego x ecdb Valuecall callframetype fn args uint frametypesize uint retOffset usrlocalgosrcreflectvaluego x dcfc ValueCall return vcallCall in homesimongosrcgithubcomgomacaroninjectinjectgo x b fd injectorInvoke return reflectValueOffCallin nil homesimongosrcgithubcomgomacaronbindingbindinggo x e validateAndMap ctxInvokeValidateobjInterface homesimongosrcgithubcomgomacaronbindingbindinggo x ed Jsonfunc validateAndMapjsonStruct ctx errors ifacePtr usrlocalgosrcruntimeasm s x da call CALLFN call usrlocalgosrcreflectvaluego x ecdb Valuecall callframetype fn args uint frametypesize uint retOffset usrlocalgosrcreflectvaluego x dcfc ValueCall return vcallCall in homesimongosrcgithubcomgomacaroninjectinjectgo x b fd injectorInvoke return reflectValueOffCallin nil homesimongosrcgopkginmacaronv contextgo x bd Contextrun vals err cInvokechandler homesimongosrcgopkginmacaronv contextgo x bc ContextNext crun homesimongosrcgopkginmacaronv recoverygo x ada b Recoveryfunc cNext usrlocalgosrcruntimeasm s x da call CALLFN call usrlocalgosrcreflectvaluego x ecdb Valuecall callframetype fn args uint frametypesize uint retOffset usrlocalgosrcreflectvaluego x dcfc ValueCall return vcallCall in homesimongosrcgithubcomgomacaroninjectinjectgo x b fd injectorInvoke return reflectValueOffCallin nil homesimongosrcgopkginmacaronv contextgo x bd Contextrun vals err cInvokechandler homesimongosrcgopkginmacaronv contextgo x bc ContextNext crun homesimongosrcgopkginmacaronv loggergo x aca e Loggerfunc ctxNext usrlocalgosrcruntimeasm s x da call CALLFN call usrlocalgosrcreflectvaluego x ecdb Valuecall callframetype fn args uint frametypesize uint retOffset usrlocalgosrcreflectvaluego x dcfc ValueCall return vcallCall in homesimongosrcgithubcomgomacaroninjectinjectgo x b fd injectorInvoke return reflectValueOffCallin nil homesimongosrcgopkginmacaronv contextgo x bd Contextrun vals err cInvokechandler homesimongosrcgopkginmacaronv routergo x aef RouterHandlefunc crun homesimongosrcgopkginmacaronv routergo x a bd RouterServeHTTP hrw req p homesimongosrcgopkginmacaronv macarongo x a f MacaronServeHTTP mRouterServeHTTPrw req usrlocalgosrcnethttpservergo x a serverHandlerServeHTTP handlerServeHTTPrw req usrlocalgosrcnethttpservergo x a connserve serverHandlercserverServeHTTPw wreq usrlocalgosrcruntimeasm s x goexit BYTE x NOP jwt jwtgo Like gorestful builtin Swagger integration Autogenerated documentation with Swagger is pretty awesome And you can autogenerate API clients for lots of different languages Further on it is possible to generate code with Swagger json defines 