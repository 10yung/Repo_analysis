For bugtracking and aggregation purposes we would like to put the service name and method called client side into the error meta This turns out to be a little tricky Does anyone have thoughts on how this can be done Possible changes that could be made to twirp to make this possible Solution Add ability to return error from client hooks go hooks twirpClientHooks Error funcctx contextContext e twirpError if sn ok twirpServiceNamectx ok e eWithMetatwirpservicename sn if sn ok twirpMethodNamectx ok e eWithMetatwirpmethodname sn return e we cant return from this hook with new error Solution Add a SetMeta method to Error This would allow us to easily mutate the existing error but this feels a little wrong I cant see any concurrency issues but I dont know the codebase very well go hooks twirpClientHooks Error funcctx contextContext e twirpError if sn ok twirpServiceNamectx ok eSetMetatwirpservicename sn if sn ok twirpMethodNamectx ok eSetMetatwirpmethodname sn Solution Write it out in the generated code I dont really like the look of this its pretty gross as people who dont use would be allocating these maps on errors But errors are pretty rare and its likely meta is sent to their bugtracking Could end up helping someone else out manshrugging go func c compatServiceJSONClient Methodctx contextContext in Req Resp error ctx ctxsettersWithPackageNamectx twirpclientcompat ctx ctxsettersWithServiceNamectx CompatService ctx ctxsettersWithMethodNamectx Method out newResp err doJSONRequestctx cclient coptsHooks curls in out if err nil twerr ok errtwirpError if ok twerr twirpInternalErrorWitherr twerr twerrSetMetatwirpservicename CompatService twerr twerrSetMetatwirpservicename Method callClientErrorctx coptsHooks twerr return nil err callClientResponseReceivedctx coptsHooks return out nil Thoughts Im happy to PR if we can decide on a way forward A recent change has been causing a bit of grief for our team Hoping to start a discussion on bringing back prior functionality Specifically prior to a client would get back an error message containing the raw unmarshalling error We found these errors to be very useful especially during development So the suggestion is to return unmarshalling errors for malformed requests Current hooks can only inspect metadata the cant be used for logging or validation Add RequestDeserialized and ResponsePrepared hooks that have access to raw Go request and response objects Issue if available Description of changes Added two more server hooks By submitting this pull request I confirm that my contribution is made under the terms of the Apache license Wed like to log request and responses from Twirp services and also to validate the input parameters using Right now this is not possible because the callbacks have no access to deserialized request body My proposal it to add ServerHooksExtended that would have two additional functions RequestUnmarshalledcontextContext interface error and ResponseReadycontextContext interface error Issue if available Description of changes These are some subtle changes to how we map proto files to package names It should resolve the bug in by correctly identifying when an imported proto file has the same Go import path as the file were generating By submitting this pull request I confirm that my contribution is made under the terms of the Apache license Command used for generating twirpgo protoc I usrlocalinclude I GOPATHsrc I GOPATHsrcgithubcomgrpcecosystemgrpcgatewaythirdpartygoogleapis I I tvservice gooutpluginsgrpcpathssourcerelative grpcgatewayoutlogtostderrtruegrpcapiconfigurationtvservicetvserviceyamlpathssourcerelative twirpoutpathssourcerelative tvservicetvserviceproto When i am trying to build project this error occurs import cycle not allowed package gitlabsweettvgotvservice imports gitlabsweettvprototvservice imports gitlabsweettvprototvservice The reason is in generated file which contains this line but it should not because the package name is identical in both cases tvservice import tvservice gitlabsweettvprototvservice If i remove pathssourcerelative the generated file does not contain this import line Ill keep this pretty short for now I also know we discussed this very briefly spenczar but just to get the conversation going since this is on my nearterm radar It would be nice to be able to have twitchtvtwirp generated code in a different package than the golangprotobuf generated code This in theory would allow you to have separation of your Protobuf definitions and the specific RPC protocol you use For example Id love to have foobarpb Protobuf messages for package foobar footwitchbarpb Twirp clientservers for package foobar foogrpcbarpb gRPC clientservers for package foobar Im not sure if this is will be allowed with the new protocgengogrpc via but we can leave this out of it foomagicbarpb My custom magical RPC implementation not in reality but as an example What this would require is protocgentwirp recognizing when it was generating code in a different package than the package of the golangprotobuf generated code and then generating imports ie go all shorthand not even importing context import barpb githubcomalicebobfoobarpb type EchoService interface EchocontextContext barpbEchoRequest barpbEchoResponse error This might be able to be implemented with some combination of the Mkeyvalue which would be annoying importpath and importprefix options but honestly it would be so much easier if there was just a definitionpathgithubcomalicebobfoobarpb option or something similar to just denote this easily There are Golang Protobuf plugin libraries that handle this kind of behavior so theres a lot of work to pattern off of Thoughts Twirp version It seems like that the generated python client does not allow us to pass custom http headers See the following excerpt def makerequestself body fullmethod req Request urlselftarget twirp fullmethod databody headersContentType applicationprotobuf Do you plan to add that feature or accept PR Thank you The current v prerelease branch changes the URL scheme It goes from twirppackageservicemethod to just packageservicemethod Unfortunately this is difficult to upgrade into Consider a service which has generated v code today and which has a client which vendors that generated Go code The service wants to upgrade to generating v code and they currently register their Twirp service like this If they regenerate their code and dont tell the client to upgrade their vendored copy then all client calls immediately start failing since the client is hitting the old URL which s If the client upgrade first same thing all s The client and server need to deploy an upgrade version simultaneously Thats unacceptably painful We need something better What are the options Document code changes the service owner can make We could tell service owners that they must run their service on two URL path prefixes if they are upgrading at least until all their clients are updated For example theyd need to do this go mux httpNewServeMux muxHandleHaberdasherPathPrefix svc muxHandletwirp HaberdasherPathPrefix httpStripPrefixtwirp svc This is not very pleasant Its gross legacy code and hard to know you need to do this I dont like solutions that require manual action from our users Its hard to know when you can remove this code as well And if users already have a mux they could get confused We could make this more visible by renaming the PathPrefix constant That way code wont compile and hopefully the user goes and looks up whats wrong and learns that they need to make a code change But this is a bad option upgrading should be painless Leave twirp as a default prefix but allow it to be customized We could change the branch to default to using the twirp prefix But if the user specifies we could remove the prefix in generated code This would make upgrading easy the user would only run into trouble if they enabled a custom prefix which is kind of their own fault Most upgrades would be painless But I already rejected this approach in really My argument there was that noncustomizability is a feature not a bug It makes thirdparty generators harder to get right and complicates the spec a bit That said its worth looking at how wed do this Protobuf files support options We could have something like this protobuf this path depends on your local machine import pathtotwitchtvtwirpgenconfigproto service Haberdasher option twitchtvtwirpgenconfigprefix whateveryouwant rpc MakeHatSize returns Hat The challenge is really that the option must be defined in some other proto file which gets imported by the user Twirp would have to distribute that proto file somehow and provide instructions on how to import it This is tricky protoc is not a friendly tool But perhaps this is alright since we hope that custom prefixes are the exceptional case not the common one so its alright for them to be a little difficult Go back to requiring twirp prefix Finally we could revert this change entirely This is appealing to me it keeps Twirp simple and the upgrade is really clean I like that no thirdparty generators become incompatible since the protocol remains the same But there are a few people who are using the prerelease branch today because they hate that prefix Id like to hear from them on their needs once again We kind of touched on them in but that covered other topics and I dont think we have good written reasons that removing the twirp prefix specifically is worth the cost Id like to hear those arguments I lean towards option in absence of clear reasons the twirp prefix needs to be removed Twirp should be able to support Go Modules for a few reasons Pinning dependencies correctly when GO MODULE will be set to on by default in the next release of Go It will make the onboarding experience to twirp a little bit easier because youll be able to get binaries such as protocgentwirp at an exact version without having to use retool For example go get githubcomtwitchtvtwirpprotocgentwirpv There will be no need to vendor dependencies on both the twirp side as well as the users side I noticed that there was already an issue about adding gomodgosum and the reason for closing it was this comment In particular the transition will involve quite a bit more than just adding gomod and gosum files as import paths will need to change For that reason I created a tool to automatically upgrade import paths I have a draft PR to demonstrate that all import paths are upgraded and that the tests past at least locally for me The PR is in draft because A Im not familiar with Twirps roadmap and B I imagine a lot of documentation needs to be updated to show the new flow of getting started Please feel free to keep this open until Twirp officially supports module and also feel free to add all the TODOs that need to be accomplished before rendering this issue resolved 