Hi there Id love to use the context functionality mentioned in But it seems as if release that contains the relevant changes omit introspection of the Context type has never been build pgutkowski can you help here Cheers Martin I have a class that has an id field but I dont want to use it directly Instead I want to replace its implementation with a derivative function and type with another type I want to do this by just adding a replacement field of the same name But this requires to ignore the original property which is strange My expectation is that if creating a new field with the same name that it would automatically ignore the original property Allows reusing the same kotlin type with a different name attribute in a gql type and a gql inputType Avoids many useless kotlin type duplication to circumvent GraphQL constraint that output types cannot be input types even when its totally legit Example use val schema KGraphQLschema inputTypeMyKotlinType nameTypeAsInput typeMyKotlinType nameTypeAsObject Many times a project already has Services with methods These methods can have many arguments and it is tedious to expose them with the lambda style that is currently supported These changes allow using KFunction method references which include all argument information and reduce boilerplate For example kotlin val mlService MovieLensServiceMovieRepository GenresRepository OccupationRepository RatingRepository UserRepository val schema KGraphQLschema queryallUsers resolver mlServicegetAllUsers querygetUser resolver id Int mlServicegetUserid mutationcreateUser resolver age Int gender String occupationId Long zipCode String mlServicecreateUserage gender occupationId zipCode becomes kotlin val mlService MovieLensServiceMovieRepository GenresRepository OccupationRepository RatingRepository UserRepository val schema KGraphQLschema queryallUsers mlServicegetAllUserstoResolver querygetUser mlServicegetUsertoResolver mutationcreateUser mlServicecreateUsertoResolver when creating val appSchema AppSchemauserServiceImpl get error somth wrong with coroutines syntax Error appear when we try to create schema val schema KGraphQLschema Exception in thread main javalangreflectInvocationTargetException at sunreflectNativeMethodAccessorImplinvoke Native Method at sunreflectNativeMethodAccessorImplinvokeNativeMethodAccessorImpljava at sunreflectDelegatingMethodAccessorImplinvokeDelegatingMethodAccessorImpljava at javalangreflectMethodinvokeMethodjava at kotlinreflectjvminternalcallsCallerImplMethodcallMethodCallerImplkt at kotlinreflectjvminternalcallsCallerImplMethodStaticcallCallerImplkt at kotlinreflectjvminternalKCallableImplcallDefaultMethodkotlinreflectapiKCallableImplkt at kotlinreflectjvminternalKCallableImplcallByKCallableImplkt at ioktorserverengineApplicationEngineEnvironmentReloadingcallFunctionWithInjectionApplicationEngineEnvironmentReloadingkt at ioktorserverengineApplicationEngineEnvironmentReloadingexecuteModuleFunctionApplicationEngineEnvironmentReloadingkt at ioktorserverengineApplicationEngineEnvironmentReloadinginstantiateAndConfigureApplicationApplicationEngineEnvironmentReloadingkt at ioktorserverengineApplicationEngineEnvironmentReloadingcreateApplicationApplicationEngineEnvironmentReloadingkt at ioktorserverengineApplicationEngineEnvironmentReloadingstartApplicationEngineEnvironmentReloadingkt at ioktorservernettyNettyApplicationEnginestartNettyApplicationEnginekt at ioktorservernettyNettyApplicationEnginestartNettyApplicationEnginekt at ioktorserverengineApplicationEngineDefaultImplsstartdefaultApplicationEnginekt at ioktorservernettyEngineMainmainEngineMainkt at comfashionApplicationKtmainApplicationkt Caused by javalangNoClassDefFoundError kotlinxcoroutinesexperimentalCommonPool at comgithubpgutkowskikgraphqlschemadslSchemaConfigurationDSLinitSchemaConfigurationDSLkt at comgithubpgutkowskikgraphqlschemadslSchemaBuilderinitSchemaBuilderkt at comgithubpgutkowskikgraphqlKGraphQLCompanionschemaKGraphQLkt at dbgraphqlAppSchemainitAppSchemakt at webUserRoutesKtusersUserRouteskt at comfashionApplicationKtmodule invokeApplicationkt at comfashionApplicationKtmodule invokeApplicationkt at ioktorroutingRoutingFeatureinstallRoutingkt at ioktorroutingRoutingFeatureinstallRoutingkt at ioktorapplicationApplicationFeatureKtinstallApplicationFeaturekt at ioktorroutingRoutingKtroutingRoutingkt at comfashionApplicationKtmoduleApplicationkt at comfashionApplicationKtmoduledefaultApplicationkt more Caused by javalangClassNotFoundException kotlinxcoroutinesexperimentalCommonPool at javanetURLClassLoaderfindClassURLClassLoaderjava at javalangClassLoaderloadClassClassLoaderjava at sunmiscLauncherAppClassLoaderloadClassLauncherjava at javalangClassLoaderloadClassClassLoaderjava more Implement DataLoader style Ive been thinking about a structure like this kotlin data class Treeval id String val parentId String typeTree String defines the key that will be sent from the prepare into loader ListTree defines the return type that the loader is required to return the loader is then required to return it in a map format like MapString ListTree dataPropertyString ListTreechildren Step This will only be called once loader keys ListString keysmap id id to listOfTreeSomeId id toMap Step This will be called for each node in the list or only once if its not a list prepare parent Tree parentid Anyone is welcome with some input on how this could be achieved It should be possible to use suspendable unionproperty resolvers also With a few more lines of code this should be possible to fix alongside There are a number of variables and functions that are declared at top level and leak through since they are not marked as internal An example could be the val OPERANDS in RequestPreProcessingkt There are many more This pollutes the global scope I ran into an exception when trying to send a query with windows line endings This PR adds r to the ignored characters Defining variables that either have an array or required array didnt get parsed correctly This fixes both ids Int and ids Int 