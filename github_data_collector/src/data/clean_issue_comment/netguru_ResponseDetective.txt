Currently there is a method available to filter logged requests ignoreRequestsmatchingPredicate predicate NSPredicate The goal here is to create a method with the same idea to filter responses that are logged into console Motivation Ive integrated the library into the app and instantly deintegrated it due to amount of logged stuff that became totally unreadable Single logs are really useful and readable but I want to filter only responses that failed for some reason to investigate possible bugs As libxml cannot be imported to Swift directly ResponseDetective currently uses RDTBodyDeserializer RDTXMLBodyDeserializer and RDTHTMLBodyDeserializer types thus making its unwanted ObjectiveC nature public Ideally Id like to remove all traces of ObjectiveC files from the project This could be achieved in a couple of ways Use an ObjectiveC libxml wrapper as an external framework and import it directly in Swift This is the worst solution because it adds an unwanted thirdparty dependency to ResponseDetective Create a projectprivate libxml wrapper as a separate framework and import it directly in Swift This is better than the st solution but adds a lot of unwanted complexity especially with header search paths linking and module maps Use a projectprivate module not to be mistaken with framework that exposes needed libxml functionalities internally to ResponseDetective but no further This is the best solution Assuming the rd solution is chosen the proposed implementation would consist of the following files A m file that uses libxml and contains implementation of XML and HTML prettyprinting A nonpublic h file that contains interface of above implementation A modulemap file that defines a module including the above header As a result ResponseDetective could import XMLPrettyPrinting exemplary name of module directly and use refinedforSwift APIs without them leaking to the outside world Currently ResponseDetective prints none for bodies in the following situations when the body is empty ie has bytes and when the body cannot be deserialized ie has an unsupported contenttype The nd situation might be confusing as none might suggest that a request has an empty body The proposal is to improve handling of empty and nondeserializable bodies in the following way for empty bodies print empty for nondeserializable bodies print unrecognizable x bytes In addition other nonraw bodies such as px px image for image contenttype should also be wrapped in triangular brackets ie px px image so that it can be distinguished from plain text bodies with similar contents ResponseDetective should support multipartformdata requests deserializing each data segment as if they were at the root level The output of body section should provide information on all segments none Segment Headers ContentType imagepng ContentDisposition formdata namefoo filenameimagepng Body px px image Segment Headers ContentDisposition formdata namebar Body baz Segment Headers ContentType applicationoctetstream ContentDisposition formdata namequx Body none Logging long requestresponse bodies may block the main thread significantly Logging should be moved to background thread Using a custom URLProtocol subclass to intercept HTTPS traffic surely results in being a good citizen but as a way to debug apps it comes with disadvantages First of all the architecture of URLProtocol requires the subclasses to operate on static levels essentially making them singletons This has an implication that only one interception mechanism can exist at a time even when using multiple URLSessions Using URLProtocol that internally uses another URLSession prevents users of ResponseDetective from using their custom URLSession subclasses or even URLSessionDelegates Since URLProtocol doesnt have access to the custom delegates issues line emerge The alternative to using a custom URLProtocol is to use swizzling to create a trampoline of URLSessionDelegate that would have the following advantages There can be multiple instances of interceptors one per each URLSession instance This makes them more configurable and even more testable This resolves the first problem of URLProtocol Since the trampoline of URLSessionDelegate would bounce back to the original delegate set by user users will still be able to customize the behavior of URLSession directly even by subclassing it This resolves the second problem of URLProtocol and Swizzling doesnt require users to pass custom URLSessionConfigurations to URLSessions during initialization which enables them to inject ResponseDetective at any time to any existing instance of URLSession Swizzling can optionally be done globally during application launch which would enable users to inject ResponseDetective to URLSession instances they do not own This would enable them to debug traffic in thirdparty dependencies As seen above using swizzling may eventually be a better more customizable and safer implementation of ResponseDetective I have to use server with invalid SSL certificate for development So I set up Alamofire manager to skipping SSL verification with this code applicable for NSURLSession too managerdelegatesessionDidReceiveChallenge session challenge in if challengeprotectionSpaceauthenticationMethod NSURLAuthenticationMethodServerTrust return UseCredential NSURLCredentialforTrust challengeprotectionSpaceserverTrust return PerformDefaultHandling nil When I try to use your library with this setup communication is interrupted and this line is printed out NSURLConnectionCFURLConnection HTTP load failed kCFStreamErrorDomainSSL So is possible to use your library with skipped certificate verification 