Hey guys Ive tried reading all the docs reverse engineering the source code etc but I cant figure this out I would really appreciate it if you could point me in the right direction A have a model subclass of ActiveRecordBase that encapsulates a Statesman state machine I would like to test this model class which requires me to be able to configure the state of the model including its internal state machine How can I create a new model object in a particular initial state I know I can create a new model with its state implicitly set to the initial state and manually push it through a series of state transitions but that triggers call backs wastes time and ruins the isolation of the test After initial gem setup with tjson metadata default field Ive got this error ActiveRecordAttributeMethodsSerializationColumnNotSerializableError Column metadata of type ActiveRecordTypeJson does not support serialize feature Usually it means that you are trying to use serialize on a column that already implements serialization natively from homeglebrbenvversions librubygems gemsactiverecord libactiverecordattributemethodsserializationrb in block in serialize Environment Ruby Rails Postgres Updates the requirements on pg to permit the latest version details summaryChangelogsummary pemSourced from a href changelogaemp blockquote p v Michael Granger a hrefmailtogedFaerieMUDorggedFaerieMUDorgap pRepositoryp ul liOur primary repository has been moved to Github a href Most of the issues from a href have been migrated a href ul pAPI enhancementsp ul liAdd PGResultfieldnametype and siblings to allow symbols to be used as field names a href liAdd new methods for error reporting ul liPGConnectionseterrorcontextvisibilityli liPGResultverboseerrormessageli liPGResultresultverboseerrormessage aliasli ul li liUpdate errorcodes and error classes to PostgreSQL li liNew constants PGDIAGSEVERITYNONLOCALIZED PQERRORSSQLSTATE PQSHOWCONTEXTNEVER PQSHOWCONTEXTERRORS PQSHOWCONTEXTALWAYSli ul pType cast enhancementsp ul liAdd PGTextEncoderRecord and PGTextDecoderRecord for endecoding of Composite Types a href a href liAdd PGBasicTypeRegistryregistercoder to register instances instead of classes This is useful to register parametrized endecoders like PGTextDecoderRecord li liAdd PGBasicTypeMapForQueriesencodearrayas to switch between various interpretations of ruby arraysli liAdd Time ArrayTime ArrayBigDecimal and ArrayIPAddr encoders to PGBasicTypeMapForQueriesli liExchange sprintf based float encoder by very fast own implementation with more natural format a href liDefine encode and decode methods only in endecoders that implement it so that they can be queried by respondto li liImprove PGTypeMapByColumninspectli liAccept Integer and Float as input to TextEncoderNumeric a href ul pOther enhancementsp ul liAllocate the data part and the ruby object of PGResult in one step so that we dont need to check for valid data This removes PGResultallocate and PGResultnew which were callable but without any practical use a href liMake use of PQresultMemorySize of PostgreSQL and fall back to our internal estimatorli liImprove performance of PGResultstreameachtuple li liStore client encoding in data part of PGConnection and PGResult objects so that we no longer use rubys internal encoding bits a href liUpdate Windows fat binary gem to OpenSSL d and PostgreSQL li liAdd support for TruffleRuby It is regulary tested as part of our CIli liEnable frozenstringliteral in all pgs ruby filesli ul pBugfixesp ul liUpdate the license in gemspec to quotBSD Clause quot It was incorrectly labeled quotBSD Clause quot a href liRespect PGCoderflags in PGCodertohli liFix PGResult memsize reporting after clearli liRelease field names to GC on PGResultclearli liFix double free in PGResultstreameachtuple when an exception is raised in the blockli liFix PGResultstreameachtuple to deliver typemapped valuesli liFix encoding of Arrayunknown with PGBasicTypeMapForQueriesli ul pDeprecatedp ul liAdd a deprecation warning to PGConnectionsocket li ul pRemovedp trtable truncated blockquote details details summaryCommitssummary ul lia href Update the ignorefileli lia href Update my gemsigning certli lia href Bump the minor version set history dateli lia href hgignore gt gitignoreli lia href Update the license in the Rakefileli lia href Merge pull request a href from larskanistypecastoverviewli lia href Fix and improve Coder docsli lia href Remove old PostgreSQL version info from docsli lia href Replace if by an ordinary commentli lia href Add an overview about coders and type maps to READMEli liAdditional commits viewable in a href viewali ul details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details Ive recently implemented the approach recommended in the readme for storing the current state on my mode aftertransition do model transition modelstate transitiontostate modelsave end Very pleased with the results based on benchmarks Ive seen a improvement in my queries In doing so I had to change a lot of code which was using Modelinstatefoo to use the new column Modelwherestate foo and ended up doing some meta programming to automatically create the scopes based on the state machine states I was wondering if you had ever considered incorporating something like this into the gem and supporting this usage in a more robust way Given the performance gains we have seen I feel like it could be of interest In terms of what Im thinking would be ideal In the State Machine class you would specify the column on the model which should be used to store the current state If declared the column value is automatically set after a transition If declared the instate method would automatically use this column for querying Thoughts If we feel this is useful happy to work on a PR The current index provided to ensure only one mostrecent transition per object by the migration generator does not work with ORACLE As a result its not possible to have more than transitions in the database When trying to create the third transition on the same order I was getting the error OCIError ORA unique constraint violated To make it work with Oracle I used the function NVL when creating the unique index ruby addindexordertransitions NVL MOSTRECENT ORDERID null mostrecent unique true name idxordertransmostrecent Original Migration generated ruby addindexordertransitions iorderid mostrecent unique true name idxordertransmostrecent Ref The issue wasnt that straight forward to identify Shall we add this info somewhere Maybe having this issue closed is enough to work as documentation Adds a commit to Im not a maintainer so couldnt do it from within that PR Context Dependabot is using statesman and we are running the Dependabot service using MySQL at GitHub After some load testing the system we found out some increasing number of deadlocks coming from states man This fixed the problem for us This is a lockfree solution for Probably also fixes Short problem description When we were trying to call armodeltransitionto we would get a Deadlock error if the system was under pressure lots of concurrent transitions happening at the same time Detailed problem and root cause analysis Some context When doing a transitionto statesman will do mainly two operations in the database inside the same transaction Update the old transitions to mark them as nonmostrecent Insert the new transition with a mostrecent set to TRUE Also the transitions table usually have two unique indexes parentidsortkey and parentidmostrecent the second index is there to guarantee we only have one mostrecent transition for the parent entry Thus we need the update before the insert Problem MySQL default transaction isolation level is REPEATABLE READ and thats what we use at DependabotGitHub It states This is the default isolation level for InnoDB Consistent reads within the same transaction read the snapshot established by the first read What means is if in a loop we do the same SELECT within a db transaction even if other clients have committed data between the runs it will ALWAYS see the first results it saw the first time That is also respected when doing writes UpdateDelete so UPDATE transitions SET mostrecentNULL where parentid AND mostrecenttrue will put an exclusive lock on the row for that unique index as it cannot allow other transactions to change the data However if there is no row to update MySQL will have to create a nextkey lock to also prevent others from changing this data as the transactions view of the snapshot didnt include any rows as the UPDATE returned rows changed The issue is two independent transactions can put the nextkey lock on the table even if they reference different columns values on the index and when it tries to do the next operation the insert it will lock waiting for the nextkey lock to be released Therefore if two updates happen first and two inserts after they will deadlock for better understanding see Simulation However if the Update would have changed at least one row there would be no locking as for REPEATABLE READ that would be our current snapshot of the data Thus no need for a gap locking See If id is not indexed or has a nonunique index the statement does lock the preceding gap This is also explained on this issue by the people that wrote InnoDB and on a few articles Solution There are a few different ways to fix this The easiest is just to retry on deadlock another one would be to change the transaction isolation level for that transaction to READ COMMITTED which means SELECTS within the transaction are not consistent and will always return committed data thus MySQL will not create the gap lock as it is safe to update without the lock The problem of is that we would still need to limit the number of retries and eventually can still have the deadlocks and number would require us to always use ROW based replication as statement base replication wants REPEATABLE READ Also not advised to change the transaction isolation level inside a library Instead we can tackle the root problem First I thought in doing a select and if transition data had to be updated do the update However that is race prone The actual fix is reorder the operations and always do the insert before so we know the next Update will at least touch one row and make our latest transition mostrecent after Thus no nextkey lock will happen and less contention will be created To simulate this Simulation SQL A and B are different MySQL clients CREATE TABLE transitions id bigint NOT NULL AUTOINCREMENT tostate varchar NOT NULL sortkey int NOT NULL parentid bigint NOT NULL mostrecent tinyint DEFAULT NULL PRIMARY KEY id UNIQUE KEY indexparentsort parentidsortkey UNIQUE KEY indexparentmostrecent parentidmostrecent ENGINEInnoDB AUTOINCREMENT DEFAULT CHARSETutf mb A START TRANSACTION B START TRANSACTION A UPDATE transitions SET mostrecentNULL where parentid AND mostrecenttrue B UPDATE transitions SET mostrecentNULL where parentid AND mostrecenttrue A INSERT INTO transitionstostate sortkey parentid mostrecent values pending TRUE B INSERT INTO transitionstostate sortkey parentid mostrecent values pending TRUE cc greysteil hmarr Closes Before previousstate projecttransitionswheremostrecent falselasttostate projectinitialstate After projectlasttransitionfromstate Weve found that these queries are causing a lot of latency so Im hoping they can be optimized by just JOINing instead of LEFT JOINing See also When I run rails g statesmanactiverecordtransition Order OrderTransition the migration created includes ttext metadata default This line causes the migration to fail with the error TypeError cant quote Hash Changing the line to tjson metadata default allows the migration to complete Seems the migration generator shouldnt be defaulting the column to type text Rails Statesman 