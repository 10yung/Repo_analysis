Hello I am new to this library and after searching through the issues and through the code I did not find any solution to this question I am using JSONKeyMapper mapperForSnakeCase to map dictionary keys to the class properties and was wondering if there is a method where I can convert the class properties back to snakecase dictionary to send the data with the same keys the server sent initially before mapping in snakecase Thank you Weird situation here Im using the snake case mapping already and need to rename one particular field We want the code we write to be easy to read and consistent but the API has a legacy spelling error that we need to support interface Object JSONModel propertyone in JSON property nonatomic NSString propertyOne propertytwo in JSON property nonatomic NSString propertyTwo SPELLING ERROR porpertythree in JSON property nonatomic NSString propertyThree end implementation JSONKeyMapper keyMapper return JSONKeyMapper mapperForSnakeCase end Ive added three methods to the implementation but dont know a way to get JSONModel to call them voidsetPorpertyThreeWithNSStringNSString string propertyThree string voidJSONObjectForPropertyThree We dont want to return propertythree we want to return porpertythree return nil voidJSONObjectForPorpertyThree return propertyThree The second method is called when I convert my object to JSON removing the propertythree key but the first and last methods arent called Im looking for something like NSArrayNSString extraProperties return porpertythree Given a model defined like so interface Parent JSONModel property Child child end interface Child JSONModel property NSString requiredField property nullable NSString Optional optionalField end if you try to instantiate the following NSString json child optionalField asdf NSError error Parent test Parent initWithStringjson The console will log out a validation error namely that the field requiredField was missing from Child but youll find that test is actually set but testchild is nil and error is nil This means that only the top level is actually being validated by the error we pass in and I cant use it to tell if a child model had a validation problem It seems to me like the default behavior should be if any model fails to validate error is set Im hitting an API whose return value is a JSON array containing multiple objects with the same properties like so title A description Item A title B description item B Is there any way to read in such a structure using JSONModel Given a single item I can say Item initWithStringsingleItem error error but I cant exactly say NSArrayItem initWithStringitems error error If there is currently no way to handle this could one be added For instance a class could contain only a single property which is an NSArray then some predefined method could declare how to handle root collections interface ItemList JSONModel property NSArrayItem items end implementation ItemList void handleJSONRootCollectionNSArray collection items collection end Alternatively along with initWithString an initWithStringCollection or similar could be added which returns an NSArray of the parent type NSArrayItem items Item initWithStringCollectionstring Im not sure how easy this would be to implement or how common of a problem it is but its something I ran into Hi I want to map object in which some keys contains a digits like addressline addressline Now using mapperForSnakeCase it return nil Any help in this scenario Hard to write a unit test for this but it looks like there was already code that was trying to address this in the unit tests that were running This just extends that to run always and to keep moving up the class hierarchy in case there are intermediate classes between the class passed in and JSONModel Problem is I have one main model I have two submodels interface UserModel JSONModel property nonatomic NSInteger Id property nonatomic NSInteger SponsorId end interface FinanceModel JSONModel property nonatomic NSInteger Id property nonatomic NSInteger Money end interface BaseModel JSONModel property KullaniciModel Result property NSInteger Status property NSString ErrorMessage end interface BaseModel JSONModel property FinanceModel Result property NSInteger Status property NSString ErrorMessage end How do I get a Single Base Model for example interface BaseModel JSONModel property JsonModel BaseClass Result property NSInteger Status property NSString ErrorMessage end UserModel Json Result Id SponsorId Status ErrorMessage FinanceModel Json Result Id Money Status ErrorMessage How do I import a User and Finance model in a Base model These are just examples I have submodels and I need to create a Base Model for all of them Help Me I noticed there was an inconsistency with how optionalignored values are determined In one case we directly inspect the class that the property belongs to to determine if the property conforms to the respective protocol In the other case which is addressed in this PR we query a method that may not necessarily belong to the class were inspecting which requires subclasses to query their superclasses for properties that dont belong to them its has conflict info display on lldb when I use po object at swift closures breakpoint if i rename the protocol name Optional to other name it will be ok po responseJson error EXPR error Optional is ambiguous for type lookup in this context extension Optional where Wrapped lldbcontext SwiftOptional note found this candidate public enum OptionalWrapped ExpressibleByNilLiteral JSONModelOptional note found this candidate public protocol Optional error EXPR error value of type OptionalSKHomeViewModel has no member lldbwrappedexpr lldbinjectedselflldbwrappedexpr Im using JSONModel and on iPad there is crash on line if self importDictionarydict withKeyMapperselfkeyMapper validationYES errorerr Logs show nothing but Uncaught exception NSCFConstantString charValue unrecognized selector sent to instance x f For some reason dict value is nil and crash does not repeat on other devices I tested iPad Air or any iPhones Have no data to show that Is there any way you could help me