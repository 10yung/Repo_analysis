Just hit which is strangely closed while the issue itself is still active Took me some time to figure it out while we wait for Mostly mechanical changes so I probably missed something Thoughts lnicola carllerche Currently towerweb fits the niche of being the only Rust web framework that is async macro based compiles on stable There is a space for it to evolve I have also mentioned in the past the plan to merge with Warp At a high level the goal for that would be to update the macros to generate warp filters However reality is that I dont have time to focus on this right now My time is going to be entirely consumed on updating Tokio Tower mio bytes etc to stdfuture and release the next major version of those libraries So until that is done I cant spend any dev time on towerweb Given that I see two options a deprecate towerweb and suggest to use warp and revisit come the end of if time becomes available b pull in additional contributors who would be able to do the development significant and I can focus on mentoring that group I would like to see b happen but that would require people to step up as it would be significant work The default option would be a to deprecate towerweb If any are interested in taking on development please comment in here and we can see if something can get going Missing value dont always assume Bad Request status code For instance in case of authorization it would be more appropriate to return Forbidden if access token is required by the application At the same time some applications may want to process requests from anonymous users along with authorized ones rust implweb impl Resource getfoo fn foo self t Token ResultString OkStringfromuser fn bar self t OptionToken ResultString match t Some OkStringfromuser None OkStringfromanonymous Currently that is impossible to specify status code or any additional details of the extracterrorError rust struct Token implB BufStream ExtractB for Token type Future ImmediateToken fn extractcontext Context SelfFuture match contextrequestheadersgethttpheaderAUTHORIZATION Some ImmediateokToken None ImmediateerrErrormissingargument The proposal is to change the extracterrorError to make such error customization possible rust implB BufStream ExtractB for Token type Future ImmediateToken fn extractcontext Context SelfFuture match contextrequestheadersgethttpheaderAUTHORIZATION Some ImmediateokToken None ImmediateerrErrormissingforbidden fn forbidden towerwebError towerwebErrorfromStatusCodeFORBIDDEN This commit updates the asyncawaitpreview feature to use the compatibility layer provided in futurespreview This was necessary since tokio stopped tracking nightly Please forgive me if I ended up doing something silly Im still piecing together the state of the futures ecosystem Thanks with the message attempted to run an executor while another executor is already running It seems like towerweb should run synchronous handlers without a running executor possibly using threadpoolblocking and executorexit The following code fails to compile deriveDebug Serialize Deserialize deriveExtract deriveResponse LINE pub struct Example proststring tag LINE pub data String with this error message error E The attribute prost is currently unknown to the compiler and may have meaning added to it in the future see issue srclogicrs proststring tag error aborting due to previous error And If we comment LINE it compiles fine If we comment LINE it compiles fine That implies Response doesnt work when prost is present Ill try my best to summarize this because apparently its not as obvious as I thought to see where the use case and problem lies Problem Its hard to write something that returns multiple types of Responses structs different status codes without manually defining a multitude of webeither or turning everything into Strings Moreover the webeither approach doesnt work with setting the status code Use case You have multiple REST apis that return something depending on the outcome One might have for example something like this in pseudocode rust postfoobaz contenttypeapplicationjson fn playbackstart self body MyStruct FailureFoo match dosomething selfstate bodyid Somev vxy SuccessStruct httpstatuscode or leave it out because should be default body None ErrorStruct httpstatuscode body So depending on the outcome of the operation we return a different Struct that has to be serialized and send back and we want to set the http status code differently Problem Details Setting the httpstatus code can be done directly with one Struct as documented in the docs But setting it from multiple Structs in one return gives headaches For this one example one might come up with an enum like so rust deriveResponse webeither enum MyResponse SuccessA FailB deriveResponse struct SuccessStruct webstatus customstatus u body String deriveResponse struct ErrorStruct webstatus customstatus u body String But it doesnt work for three reasons A We cant define Response more than once so MyResponse would have to handle the status already B We cant make this generic due to So we cant make this enum generic to allow multiple success and for example one error type We end up with having to do an enum for every possible state C Even if A would work this doesnt scale for more different types due to B We also cant just return a httpresponseResponseT due to T not being allowed as generic and the enums serialization striking back again so we cant use an enum approach Also we still would have to create a Response via the builder Things to keep in mind We dont want to get the enum itself serialized Succes is not a desired json return We probably still want to allow FailureMyResult because there is a difference in specifically designed returns and blatantly internal server errors When doing a try over a result thats supposed to work Current workaround One can currently work around by returning FailureResponseString and adding some helpers to build a response and serialize their structs Example of actual code in use Im not sure if the stable macros are flexible enough to be able to dispense with implweb but it should probably be tracked somewhere The Response derive isnt handing down debug derives For example the following wont work rust deriveDebug Response pub struct ApiResponseT where T Serialize Debug pub value OptionT pub msg OptionString Will throw log error E T doesnt implement stdfmtDebug srcmodelsrs deriveDebug Response T cannot be formatted using because it doesnt implement stdfmtDebug I was told that serde is handling this via attributes which towerweb probably also would have to implement