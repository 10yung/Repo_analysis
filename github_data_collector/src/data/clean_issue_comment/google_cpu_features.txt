To test all code paths of apps that use cpufeatures to select between different implementations of an algorithm it would be useful to be able to mock having a CPU with fewer features than actually supported While this can be done in wrapper layer which uses cpufeatures to query the real feature set little prevents direct use of cpufeatures functions that would break the purpose of the wrapper Hence I think it would be useful if this was a core feature of cpufeatures itself One complication is that for tests to be able to run concurrently this would have to be threadlocal assuming the tests are singlethreaded For multithreaded tests a global mutex could be used to prevent concurrent execution from the point where cpufeatures is provided with override options to the point where theyre removed Multiple users of cpufeatures have to deal with this themselves currently so having it as a core feature instead avoids duplicate effort and incompatible solutions which might have subtle bugs that are best fixed centrally There was already a debate in if cpus that do not set the XCR properly related to the xmm os support should be supported or not I stumpled across a CherryTail Atom that explicitly has this issue XCR bit for xmm not set but providing SSE register set Now on the one hand the debate above depicted wont fix as there wont be that many cpus with this issue This is odd because on the front page of it is clearly depicted that a dev needs to take care about poor hardware implementations example with SNB and AVX in hisher own code But in this case cpufeatures tries to take control in case the bit in XCR for xmm os support is not set Id suggest to make the XCR xmm os support bit explicit to the dev so heshe can decide as well Hence this patch removes so far the burden of not properly indicating SSE on cpus that didnt set the XCR register properly but still support SSE Just an idea adding cpufeatures would be a great addition to to Thread safe no memory allocation and raises no exceptions cpufeatures is suitable for implementing fundamental libc functions like malloc memcpy and memcmp The README claims the above But while grepping through the code memcpy and memcmp are at least used already in the code from the libc library Hence when implementing such based on cpufeatures one would create a loop of dependencies I assume that cpufeatures requires a rework to not utilize libc functions internally ie this should be a tiny bit faster than getauxval when it is supported Thanks for the cpufeatures library It looks like the library is missing a define for ARMv ARMv is important for some hand tuned algorithms For example one might bundle Andy Polyakovs Cryptogams AES and SHA algorithms and make the baseline ARMv with marcharmv a There are several reasons to make ARMv the baseline ARMv is mostly the de facto standard nowadays so using ARMv addresses the common case out of the box ARMv ISA also enjoys a performance boost over older ISAs and provides additional loads and stores not available in ARMv and below However ARMv and ARMv will show up on occasion like old devboards and iPads so a fallback is needed on occasion At runtime user code may do something like the following if HasARMv CRYPTOGAMSaesencryptdata blocks subkeys else CXXaesencryptdata blocks subkeys We cant really use ARMNEON as a proxy for ARMv because some ARMv devices have NEON And some ARMv devboards lack NEON It looks like Mozilla synthesises it from proccpuinfo on Linux see Changeset ff Crypto library utilizes a SIGILL probe using movw and movt because getauxval does not provide a define movw and movt are part of ARMv ISA int a asm volatilemovw n movt n ra i x hasARMv a x Unfortunately SIGILL probes have several of shortcomings First they are expensive when compared to getauxval and friends Second they only work with the GNU Assembler GAS or compatible assemblers Third they trash a program on Apple platforms Apple does not restore the context properly when a longjmp is taken so they cant be used on iPhones and iPads So setting features true does not comply with standards They can either be or However getting them is not a problem since is true is true but true might not always be Some proposed changes are in this pull request There are demo snippets in the README showing how to use the library at the source level and there is a building with cmake part about building it but it would be nice to have a section that explains how to actually to add the library to your build eg do you need to link against any binary or just include the header You cover how a project using cmake should consume this but a large number of projects arent using cmake so even though theyll build cpufeatures itself with cmake they should be able to then integrate the output into their own build system I guess one or two lines about that scenario would suffice ART on Android works around quirksbugs in proccpuinfo and aux vector has support for cross compilation detection of features via C preprocessor CPUID instructions undefined instruction exceptions supports MIPS ARM Intel and etc Android NDK has something simple V CPU feature detection As there are OSCPU bugs that cause issues standardizing on library makes sense As an author of the ART code Im have a bias 