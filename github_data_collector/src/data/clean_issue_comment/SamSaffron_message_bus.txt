 Im interested in doing some backandforth with someone who has retrofitted messagebus to an old legacy Rails app v Is there a forum or channel on a discourse site that I should join Dewayne o In its error function the object passed to MessageBusajax checks to see if statusText abort If it is then a relatively low value gets used for the poll interval Compare and It looks like setting statusText to abort is something that jQuery does not the browser Which results in a potentially long delay between when a request is aborted eg by subscribing to or unsubscribing from a channel and when the subscriber receives new messages I think the messagebusajaxjs fallback should somehow make sure to pass abort as the value for statusText or alternatively the error function could use a different way to determine whether or not the XHR has been aborted We have configured message bus in our platform it has been observed when redis is down our logs files are getting populated with following message It tries to connect redis after regular interval of time is there any way we can increase time interval so that there would be less occurrence in log file Error connecting to Redis on localhost ErrnoECONNREFUSED subscribe failed reconnecting in second Call stack homexrvmgemsruby gemsredis libredisclientrb in rescue in establishconnection homexrvmgemsruby gemsredis libredisclientrb in establishconnection homexrvmgemsruby gemsredis libredisclientrb in block in connect homexrvmgemsruby gemsredis libredisclientrb in withreconnect homexrvmgemsruby gemsredis libredisclientrb in connect homexrvmgemsruby gemsredis libredisclientrb in withsockettimeout homexrvmgemsruby gemsredis libredisclientrb in callloop homexrvmgemsruby gemsredis libredissubscriberb in subscription homexrvmgemsruby gemsredis libredissubscriberb in subscribe homexrvmgemsruby gemsredis libredisrb in subscription homexrvmgemsruby gemsredis libredisrb in block in subscribe homexrvmgemsruby gemsredis libredisrb in block in synchronize usrsharervmrubiesruby libruby monitorrb in monsynchronize homexrvmgemsruby gemsredis libredisrb in synchronize homexrvmgemsruby gemsredis libredisrb in subscribe homexrvmgemsruby gemsmessagebus libmessagebusbackendsredisrb in globalsubscribe homexrvmgemsruby gemsmessagebus libmessagebusrb in globalsubscribethread homexrvmgemsruby gemsmessagebus libmessagebusrb in block in newsubscriberthread Lets say youre building a chat app Slack clone that triggers a new Notification when a new message arrives With the default MessageBus js configuration messages do arrive instantaneously when tabs are in foreground but take up to seconds to arrive when tab is not focused due to lib falling back to a regular polling strategy instead of long polling because it polls using backgroundCallbackInterval which defaults to I know the lib is smart enough to immediately start a new long poll as soon as the browser tab comes to focus which has the effect of immediately displaying the new data but it doesnt fix the issue of needing that data in realtime in the background tabs for the browser notification to happen in a timely fashion One way to change this behavior would be to change alwaysLongPoll to true which works fine in my tests but documentation states that this should be used for debugging only So The reason to fallback to regular polling in background tabs is just to avoid hitting the server every seconds the value of longpollinginterval in messagebusrb using a more relaxed seconds default If thats the case would you welcome a pull request that updates documentation explaining this reasoning and removes the indication that alwaysLongPoll should be used for debugging purposes only Last but not least Id like just to point out that since longpollinginterval is currently hardcoded in messagebusrb to seconds setting the backgroundCallbackInterval to anything will post to the server more often in the background tabs than if one just used long polling right Noticed that if siteidlookup returns an Integer instead of the string you will think everything works but messages will be retrieved only on the start of the request after the client establishes the connection Publishing new message will not transfer them in long polling chunked mode To explain better once a client connects clientbacklog is called to get all existing messages that calls busbacklog which encodes siteid into a string and theres no issue there Works as expected But later MessageBusConnectionManager is used to push out new messages it uses subscriptions msgsiteid to look up any clients which is string even if the message was published with siteid set to an integer but addclient uses clientsiteid established by siteidlookup which if it returns anything else than a string will break lookup in connectionmanagerrb Leaving for anyone scratching their heads Generally would be great to either assert returned type from siteidlookup or convert it to a string in connectionmanagerrb That was my fault but would be great if API helped diagnose problems like that Hello I have configured baseurl in my application js file like MessageBusbaseUrl fa MessageBusstart MessageBussubscribenotificationchannel windowwsConfigsessionId functiondata consolelogdata I keep getting following error in my Rails application ActionControllerRoutingError No route matches POST famessagebusfc dd b bb a fd e a fa dpoll I tried exploring libmessagebusrackmiddlewarerb file but could not find any code handling response with custom baseurl Please help Thanks But will it scale is an important concern for everyone that considers this gem since ActionCable itself is pretty bad unfortunately when we hit thousands of subscribers as AnyCable benchmarks shows Right at the beginning of the readme it states that MessageBus can handle thousands of concurrent long polls on all popular Ruby webservers but I wish to improve it with some numbers so we can have a ballpark idea of how many concurrent connections it could actually handle And honestly Im ignorant on how exactly that can be done If it uses by default a longpolling stategy with streaming which keeps the connection open for the configured longpolling interval seconds by default Im quoting from the README doesnt it mean that for every subscriber there will be an open connection that remains open all the time If you have a Puma server with threads and workers cant it only handle concurrent requests By the connections remain open during the long poll intervall I assumed that thread would not be available for responding to any other requests like for instance if it was a regular rails request that took very long to respond the thread is stuck until that request finishes I commit myself to make a pull request to improve the readme on this part but of course I need to understand how this works first I read the how it works section but couldnt find these answers there a Typescript file for typescript users Id like to revisit this in isolation It was unclear in if the objection was to execution in the default task which perhaps people run when working on messagebus or execution in CI CI is the quietest most stable environment we have available in which to execute these Development hardware is noisy and we have no other environment readily available Sam mentioned the possibility of using but from that site I found no evidence that it is an option at this time