for example this does not work import comgithubsalomonbryskotson import comgooglegson fun main args Array String val objJsonObject jsonObject name to kotson files to println obj class Personpublic val obj JsonObject val name String by objbyStringname val files Int by objbyIntfiles val personGsonfromJsonobjPerson classjava It would be nice if there was a option or if it was the default behavior to evaluate delegates when serializing objects For example val jumps by jsonbyInt would serialize to something like jumps This would extremely helpful when using a class that generated from json using the json delegates byInt etc Right now using these requires a custom serializer to be serializable properly Does this support Kotlins default values With Gson when deserializing if a value does not exist it becomes null Since this is supposed to support Kotson does that value now get set to default value if it does not exist I have a json like this kotlin val JSONLISTSTRING code msg Success subcode data test trimIndent model like this kotlin data class TestObjectval test Int public class ApiResultT private int code private int subcode private String msg private T data public int getCode return code public void setCodeint code thiscode code public String getMsg return msg public void setMsgString msg thismsg msg public T getData return data public void setDataT data thisdata data public boolean isOk return code Override public String toString return ApiResult code code msg msg data data public int getSubcode return subcode public void setSubcodeint subcode thissubcode subcode test code like this kotlin Test fun testFunListGson val result dataListTestObject assertThatresultdata testisEqualTo Test fun testDirectListGson val result gsonfromJsonApiResultListTestObjectJSONLISTSTRING assertThatresultdata testisEqualTo fun T data ApiResultT return gsonfromJsonJSONLISTSTRING Expect testFunListGson will pass but it failed like this javalangClassCastException comgooglegsoninternalLinkedTreeMap cannot be cast to comxxxGsonTestTestObject It looks like its not getting past the underneath generic type Would be nice to map directly to Array of Strings if possible Might be missing how to do this but this is my current way of doing so private val modes by objbyNullableArrayMODES val modes ArrayString by lazy modesmap itstring toTypedArray Hi What Kotlins field modifier that compatible with Java ModifierPRIVATE ModifierPROTECTED ModifierPUBLIC I tried with the following class Configactivity Activity var remoteUrl String ABC var localUrl String DEF protected val preferences SharedPreferences activitygetPreferencesContextMODEPRIVATE fun save val gson GsonBuilderexcludeFieldsWithModifiersModifierPROTECTEDcreate Loge SAVE gsontoJsonthis But preferences field still included on the json output Thanks I have this class kotlin class Project val nameProperty SimpleStringPropertyfoobar val name by nameProperty I use FxGSON library to serialize JavaFx Properties When I serialize it to JSON I get this json nameProperty foobar namedelegate foobar But when I deserialize it back to the object of type Project the name and nameProperty are different objects How to make name property delegate to the new nameProperty Update to Kotlin Gradle wrapper and to newer Spek From the readme Attention gsonfromJsonMyType will return a nonnullable type whereas gsonfromJsonMyType will return a nullable type Therefore the code gsonfromJsonMyTypenull is correct and will throw a nullpointer exception But it is not possible to use MyType Kotlin says the following Type argument not within its bounds which its expected since its expecting Any nonnullable