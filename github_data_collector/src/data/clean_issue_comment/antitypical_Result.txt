This code compiles without issue where generatedEvents is of type EKEvent and eventStore is an EKEventStore swift for thisEvent in generatedEvents let result Resulttry eventStoresavethisEvent span thisEvent commit false printresult However when I rewrite it as a map to generate an array of Results swift let results generatedEventsmap thisEvent Result AnyError in let result Resulttry eventStoresavethisEvent span thisEvent commit false printresult return result I receive the compiler error Call can throw but it is not marked with try and the error is not handled However looking at the Result initializer it looks like the error is handled in a docatch block references swift references materializedematerialize which are deprecated I have a few situations where I need to convert a Result to a common type and looking at other languages fold seems to exist Essentially this swift public extension Result Convert either a success or failure into type U public func foldUsuccess Value throws U failure Error throws U rethrows U switch self case successlet value return try successvalue case failurelet error return try failureerror Good idea bad idea Im pretty new to using Result so perhaps this is possible by another concise means A variant of dematerialize that doesnt throw if the error type is NoError would be nice to have I typically avoid try throughout my code and use SwiftLint to warn against its use My options here are to use a magic comment to disable the SwiftLint rule or docatch neither is particularly appealing Thoughts When using Result in my project I needed to use initattempt in several places but I wanted to use my own wrapper for arbitrary Errors The existing initializer only works with AnyError so Ive modified the code to allow using any Error which conforms to the ErrorInitializing protocol Hi I have another Result structure in my code and its conflicting with this one How can I use ResultResult for this enum Im getting the error Reference to generic type Result requires arguments in as if it thinking its the enum not the namespace Thanks for the work on this type I try to replace Swift throws with Result in one of my projects but on every higher order function Im stopped The project depends on the behavior of map and that its transform function can throw So I wrote a map that can do this with Result Here is my implementation not that functional swift extension Sequence Returns an array containing the results of mapping the given closure over the sequences elements Parameter transform A mapping closure transform accepts an element of this sequence as its parameter and returns a transformed value of the same or of a different type wrapped in a Result Returns A Result containing an array of the transformed elements of this sequence or the error of the first failure that occured by applying transform func tryMapT Etransform SelfIteratorElement ResultT E Result T E var transformedElements T for element in self switch transformelement case successlet transformed transformedElementsappendtransformed case failurelet error return failureerror return successtransformedElements So without a Result version of all these standard library functions that can throw I doubt that I can use the Result type to its full extend Is there some library that can help me out here MapFilter Return a array of V by applying transform to all elements of array U and filtering out failure ones MapM Return a Result with an array of Vs if all Results of applying transform are Successes or return the error of the first Failure We ve had a few PRs along the lines of where someone has submitted a scratch for a notuncommon itch We ve been turning them down mostly thus far but maybe we should instead be finding them a better home As I understand it this is the sort of thing that git s contrib dir exists to enable Maybe we should consider something similar Some ideas a Contrib subframework encapsulating conveniences and experiments a section of the readme linking to gists with these things just including them in the framework and being done with it Not sure how well this would work in practice but hopefully we can come up with something thats better than doing it manually at every callsite 