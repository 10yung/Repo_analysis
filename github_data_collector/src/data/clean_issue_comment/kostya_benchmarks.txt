This is a wonderful find and Halvak is the longest code and I dont understand what it does Was the code in Based on this with modified code I can still compile original code from on Golang without any modifications rscs Havlak havlak go with pool took seconds MB memory Kostyas Havlak in this repo took seconds MB memory Russ Cox works on Go language Have a great holiday I compared Rust and Cpp versions and I found out that most of performance difference is branch misprediction It also drastically changes from CPU to CPU becuase it relies on CPU internals I found that changing match op on if let chain fixes this problem Although Im notsure if it follows your Used data structures are idiomatic I mean its more idiomatic to use match in these cases but what makes Rust itself is you could rewrite your code a bit to get better performance What do you think On my machine Ive got rust vs cpp Today I came across mimalloc probably the most stable malloc replacement and think its wise to use it for all languages to avoid sensitivity to unstable performance behavior in different workloads benchmarks Feel free to use the LDPRELOAD hack from mimallocs README for all tests in the Docker image Adding the size in bytes for the executable binaries or VM bytecode generated by the compiler would be very interesting Bonus points for also mentioning size sum of ldd library dependencies Theres the dom binarysize repo showing that executables produced by Nim are much leaner than Crystal Rust D Haskell and Go for a Hello World example Adding this column to this benchmark would show the difference for nontrivial examples and many more languages with very little extra effort if automated Thanks I made it faster and memory efficient by using ets tables Below is a statistical report generated by Benchee Name ips average deviation median th ets min min min original min min min Comparison ets original x slower min Memory usage statistics Name Memory usage ets GB original GB x memory usage GB system availablememory GB cpuspeed IntelR XeonR Platinum CPU GHz elixir erlang numcores os Linux Vala language Better code style use Kotlin stdlib rather than Javas where possible Avoid unnecessary allocations Removed warming On my machine with Oracles JDK I observed an improvement when running the warming program from seconds to seconds This is extremely fast much faster than Go for example even including the JVM startup time Even the Java optimised implementation I submitted on running with the GraalVM JIT is not as fast This PR implements brainfuck in Java that runs much faster than the current implementation The code is still pretty clean and very readable besides being more testable On my system here are the figures I am getting comparing the new implementation with the current one as well as with the Kotlin current fastest in the project README implementation in seconds Java current Java new Kotlin The Kotlin implementation is also not optimal I will make a PR offering a faster implementation for it as well Like perl I would add a base module for encodedecode function to get better performance for python Factor for python is available