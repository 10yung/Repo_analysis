How would one set it up so gitsh doesnt keep asking for passphrase Normally one would use the following commands bash eval sshagent sshadd but running it as follows inside the gitsh bash eval sshagent Started agent succesfully sshadd Could not open a connection to your authentication agent I recently upgraded my MacOS to Catalina and I can no more use gitsh When I type gitsh it gives me following error gitsh Traceback most recent call last from usrlocalCellargitsh sharegitshrubygitshrb in main from usrlocalCellargitsh sharegitshrubygitshrb in require from usrlocalCellargitsh sharegitshrubylibgitshenvironmentrb in top required from usrlocalCellargitsh sharegitshrubylibgitshenvironmentrb in require from usrlocalCellargitsh sharegitshrubylibgitshlineeditorrb in top required usrlocalCellargitsh sharegitshrubylibgitshlineeditorrb in require dlopenusrlocalCellargitsh sharegitshrubylibgitshlineeditornativebundle x dependent dylib SystemLibraryFrameworksRubyframeworkVersions usrliblibruby dylib not found for usrlocalCellargitsh sharegitshrubylibgitshlineeditornativebundle usrlocalCellargitsh sharegitshrubylibgitshlineeditornativebundle LoadError A feature request I have all my repos in a common parent directory so I often switch between them with cd newRepo Current behavior laptopmyRepo chris gitsh myRepo master cd newRepo newRepo master exit laptopmyRepo chris echo now I am confused This always breaks my brain Upon exiting I am yanked back to the directory I was in when I entered gitsh For some reason I consistently expect this laptopmyRepo chris gitsh myRepo master cd newRepo newRepo master exit laptopnewRepo chris echo sweet consistency What do you think of adding support for installation via Linuxbrew for Linux WSL What This PR is a large refactor which replaces dependency injection with the registry pattern for shared instances or direct references to class names that were previously passed as constructor arguments Previously we had a lot of classes that looked like this ruby class Foo def initializeenv barfactory GitshBar bar barfactorynewenv env env end private attrreader bar env end Now those same classes look like this ruby class Foo extend RegistryClient useregistryfor env def initialize bar GitshBarnew end private attrreader bar end The objects moved to the registry are the shared instances of GitshEnvironment GitshGitRepository GitshLineEditorHistoryFilter decorating GitshLineEditor Why The nature of gitsh means that some amount of longlasting global state is inevitable Unlike a Web application which needs to handle multiple concurrent requests from different users a gitsh process only runs a single command at any given time and does so for a single user in a single session We get a lot of benefits from this approach which include Fewer redundant arguments There were several classes which held a reference to the shared GitshEnvironment instance only because they needed to pass it along to some other object that needed to use it Easier to break up GitshEnvironment The GitshEnvironment has become a bit of a junk drawer The main reason is that it was the one object that was available everywhere so access to any shared state was easiest if it went through this object Introducing the registry means we are able to drop all of the GitshEnvironmentrepo methods which delegated directly to a GitshGitRepository instance and instead share both the GitshEnvironment and GitshGitRepository via the registry The remaining responsibilities of GitshEnvironment IO variable access and access to some global config can be broken out in future PRs Easier to share other instances The final straw in doing this refactor was starting work on globbing patterns and realising we will need to access the tab completion automaton while evaluating variable values Adding yet another thing to the environment was not appealing nor was passing another instance around through the whole system or building multiple instances of a pretty large tab completion graph After this refactor well be able to use the registry to share the tab completion automaton instance and easily access it directly from where its needed Code review This diff is very large changed lines but many of the changes are very similar and reviewers should probably focus on The GitshRegistry implementation in libgitshregistryrb The new test helpers in specsupportregistryrb Im not sure what the exact cause or error is but here are some test cases Works gitsh ekadddocstoreadme FOOfoo git log oneline n eeb HEAD ekadddocstoreadme originekadddocstoreadme Add note about man gitsh to Readme gitsh ekadddocstoreadme gitsh ekadddocstoreadme echo hi there hi there gitsh ekadddocstoreadme Fails gitsh ekadddocstoreadme FOOfoo bar git log binsh bar command not found gitsh ekadddocstoreadme In my case git is an alias to hub though I have tested without hub and the above behavior is still exhibited gitsh version git version hub version Supersedes thoughtbothomebrewformulae Adds a head configuration block to the Homebrew formula to support topoftree builds Additionally adds a VERSIONSUFFIX variable to configureac which is appended to PACKAGEVERSION on configure This is used to produce a SemVercompatible version number such as head d d in order to differentiate prerelease builds from official releases eg echo hiop produces hip hop The implementation differs from GNU Bash and other general purpose shells in a few ways First there are a few deliberate things that I think improve the consistency of the language Singleoption expansions behave like strings eg x is like x Zerooption expansions behave like empty strings eg is like Unclosed braces cause a parse error not a literal brace Spaces inside of expansions dont need to be escaped Quotes inside of expansions are literals not string delimiters which mirrors the fact that braces inside of quoted strings are literals not expansion delimiters There are also a couple of differences that we might want to consider changing Expansions cant be used inside of variable names eg in GNU Bash echo FOO is like echo FOO FOO but echo FOO FOO is an error To support this new behaviour this PR also updates all of the various GitshArguments classes value methods to produce Arrays instead of single values The GitshArgumentList class takes on the responsibility of flattening the results Begins to address If I have originfoobranch but not foobranch I can do this myrepo master checkout foobranch Branch foobranch set up to track remote branch foobranch from origin Switched to a new branch foobranch Id like to be able to do the same thing but with tab completion myrepo master checkout foo mash that tab key Branch foobranch set up to track remote branch foobranch from origin Switched to a new branch foobranch eg I thought I had tracked down the cause of the problem in ed ee bf ea d fe e ebe but its still failing sometimes The supposed fix did do something because prior to that commit I could reproduce the failure locally by running RSpec with the same seed but after that commit I cant reproduce the issue reliably 