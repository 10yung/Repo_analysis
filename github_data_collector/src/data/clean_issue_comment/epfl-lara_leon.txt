Since the bash binary is not always located in bin the leon script doesnt always run This change makes the script more portable so leon will run on more systems scala import leoncollection for List import leonlang for holds object Example def rightUnitAppend T l List T Boolean l Nil l holds In If you try to verify this last example youll face a delicate situation Leon runs indeterminately until it is either killed or times out But why does this happen The proposition doesnt seems more complicated than appendContent Perhaps even more surprisingly Leon is able to verify the following However it actually compiles Fixes I use the leon library in another project where I compile it with these settings scalacOptions Seq deprecation encoding UTF yes this is args feature languageexistentials languagehigherKinds languageimplicitConversions unchecked Xfatalwarnings Xlint Ynoadaptedargs Ywarndeadcode NB doesnt work well with the hole Ywarnnumericwiden Ywarnvaluediscard Xfuture Ywarnunusedimport only Ynoimports no automatic imports at all all symbols must be imported explicitly Most of the refactoring is to due to moving classes and objects that were defined in a package object file to a separate compilation unit I was surprised that Ynoimports helps readability of the library where an unqualified type name could be misunderstood to refer to a type in leons library instead of the scala library For example in leonlangBag the unqualified List type needs to refer to scalacollectionimmutableList instead of leoncollectionList I like to compile my scala code with these flags scalacOptions Seq deprecation encoding UTF yes this is args feature languageexistentials languagehigherKinds languageimplicitConversions unchecked Xfatalwarnings Xlint Ynoadaptedargs Ywarndeadcode NB doesnt work well with the hole Ywarnnumericwiden Ywarnvaluediscard Xfuture Ywarnunusedimport only Ynoimports no automatic imports at all all symbols must be imported explicitly The le n library defines many objects classes in a package object This results in a warning with scalac that with the above flags becomes an error Is it possible to refactor the library eg instead of file libraryleonannotationpackagescala package leon import scalaannotationStaticAnnotation package object annotation ignore class library extends StaticAnnotation Each of the objectsclasses would be defined in a corresponding compilation unit eg library would be defined in libraryleonannotationlibraryscala Is it possible to publish the leon library as a maven jar with sources such that one could write scala code with a dependency on the leon library maven jarsource and use leon to analyze such source code verification synthesis etc I tried to compile Leon code using the generic copy method for generic case classes see here but it seems that it is not yet in the Leon library Is it possible to provide support for this construct scala import leonlang import leonlangxlang import leonutilRandom import leoncollection object DataRacing case class Coreval rBigInt val choiceCore val nbtasksBigInt case class SharedStateval progressBigInt val coresBigInt Core case class AtomicInstrinstr Core SharedState Core SharedState implicit def toInstrinstr Core SharedState Core SharedState AtomicInstr AtomicInstrinstr abstract class Runnable case class RunnableConsinstr AtomicInstr tail Runnable extends Runnable case class RunnableNil extends Runnable def executeOneinstr AtomicInstr coreBigInt stateSharedStateSharedState val newCore newState instrinstrstatecorescore state SharedStatenewStateprogress statecores ensuringres true Results in a Error Z exception latest build Any idea on how to debug that Thanks The following program make verification crash apparently in RecursionCountInstrumenter but the bug might be due to some other component scala Copyright EPFL Lausanne import leonannotationextern object Aliasing case class MutableIntegervar x Int def scope var x def hoom MutableInteger toto foo m def fooy Int m MutableInteger toto x barm mx y foo MutableInteger val m MutableInteger hoom def gooy Int fooy m goo mx ensuring def barm MutableInteger mx def toto def main Int if scope else ensuring extern def mainargs Array String Unit main Stacktrace looks like this javautilNoSuchElementException key not found def foo y Int m MutableInteger Unit MutableInteger var m m toto x val res bar m m res res m MutableInteger y m at scalacollectionMapLikeclassdefaultMapLikescala at scalacollectionAbstractMapdefaultMapscala at scalacollectionmutableHashMapapplyHashMapscala at leoninvariantdatastructureDirectedGraphsuccessorsGraphscala at leoninvariantdatastructureGraphclasssearch Graphscala at leoninvariantdatastructureGraphclassprocessNeighbor Graphscala at leoninvariantdatastructureGraphanonfun applyGraphscala at leoninvariantdatastructureGraphanonfun applyGraphscala at scalacollectionTraversableOnceanonfunfoldLeft applyTraversableOncescala at scalacollectionTraversableOnceanonfunfoldLeft applyTraversableOncescala at scalacollectionimmutableSetSet foreachSetscala at scalacollectionTraversableOnceclassfoldLeftTraversableOncescala at scalacollectionAbstractTraversablefoldLeftTraversablescala at leoninvariantdatastructureGraphclasssearch Graphscala at leoninvariantdatastructureGraphanonfunsccs applyGraphscala at leoninvariantdatastructureGraphanonfunsccs applyGraphscala at scalaOptionforeachOptionscala at leoninvariantdatastructureGraphclasssccsGraphscala at leoninvariantdatastructureDirectedGraphsccsGraphscala at leontransformationsRecursionCountInstrumenterinitRecursionCountInstrumenterscala at leontransformationsInstrumentationPhaseanonfun applySerialInstrumentationPhasescala When this is fixed srctestresourcesregressiongencunverifiedAliasing scala should be moved to srctestresourcesregressiongencvalidAliasing scala ATM only available on topicgencv branch The following program makes Leons ImperativeCodeElimination crash scala object Dummy case class Mvar value Int def barMm M mvalue mvalue def foom M m match case n M barMn Stacktrace looks like javalangAssertionError assertion failed at scalaPredefassertPredefscala at leonxlangImperativeCodeEliminationleonxlangImperativeCodeEliminationtoFunctionImperativeCodeEliminationscala at leonxlangImperativeCodeEliminationanonfun applyImperativeCodeEliminationscala at leonxlangImperativeCodeEliminationanonfun applyImperativeCodeEliminationscala at scalacollectionimmutableListanonfunfoldRight applyListscala at scalacollectionLinearSeqOptimizedclassfoldLeftLinearSeqOptimizedscala at scalacollectionimmutableListfoldLeftListscala at scalacollectionimmutableListfoldRightListscala at leonxlangImperativeCodeEliminationleonxlangImperativeCodeEliminationtoFunctionImperativeCodeEliminationscala at leonxlangImperativeCodeEliminationleonxlangImperativeCodeEliminationtoFunctionImperativeCodeEliminationscala at leonxlangImperativeCodeEliminationanonfun applyImperativeCodeEliminationscala at leonxlangImperativeCodeEliminationanonfun applyImperativeCodeEliminationscala When this is fixed srctestresourcesregressiongencunverifiedInheritance scala should be moved to srctestresourcesregressiongencvalidInheritance scala