Hey folks I was wondering if someone had already extracted a JsonSchema or similar from encoders For example case class Dataid UUID a Option String object Data implicit val encoder EncodeJson Data jencode Lm Data mid ma id somefieldname Is it possible to extract the JsonSchema from this encoder that could look like title Data type object properties id type uuid somefieldname type string optional true It seems a bit hard to extract all this information from the current state of the code Do you have any clue Cheers Hi I have a private library and webapp both using Argonaut With the library no and the webapp using I get the following error I believe this is a binary compatibility issue Caused by javalangNoSuchMethodError argonautArgonautToJsonIdentityLjavalangObjectLargonautJsonIdentity Running scala Does it make sense to scala sealed abstract class CodecJson A override def mapJsonf Json Json CodecJson A CodecJsonderived EncodermapJsonf Decoder Ive been programming with Scala for a few months now but I still dont understand how and if can I get a better error messages from Argonaut Currently I have a codec and I use it as this val json String val parsed ParsedecodeEither MyClass json val checks if parsedisRight parsedrightget else syserrorUnable to parse MyClass json parsedleft However I never get any useful error messages when I use this All I get is javalangRuntimeException Unable to parse MyClass json LeftProjectionLeftString CursorHistoryList What is the proper way to handle decoding errors Subquadratic decreasing of throughput when number of JSON object fields with keys that have the same hash code is increasing On contemporary CPUs parsing of such JSON object with a sequence of fields like below that is Mb can took more than seconds sjyehenull sjyeiFnull sjyejnull sjyfIenull sjyfJFnull Below are results of the benchmark where size is a number of such fields info REMEMBER The numbers below are just data To gain reusable insights you need to follow up on info why the numbers are the way they are Use profilers see prof lprof design factorial info experiments perform baseline and negative tests that provide experimental control make sure info the benchmarking environment is safe on JVMOSHW level ask for reviews from the domain experts info Do not assume the numbers tell you what you want them to tell info Benchmark size value Mode Cnt Score Error Units info ExtractFieldsBenchmarkreadArgonaut null thrpt opss info ExtractFieldsBenchmarkreadArgonaut null thrpt opss info ExtractFieldsBenchmarkreadArgonaut null thrpt opss info ExtractFieldsBenchmarkreadArgonaut null thrpt opss info ExtractFieldsBenchmarkreadArgonaut null thrpt opss info ExtractFieldsBenchmarkreadArgonaut null thrpt opss Reproducible Test Case To run that benchmarks on your JDK Install latest version of sbt andor ensure that it already installed properly sbt about Clone jsoniterscala repo git clone Enter to the cloned directory and checkout for the specific branch cd jsoniterscala git checkout argonautDoSbyhashmapcollisions Run benchmarks using a path parameter to your JDK sbt nocolors jsoniterscalabenchmarkjmhrun jvm usrlibjvmjdk binjava wi i ExtractFieldsBenchArgonaut In the section DecodeJson maintaining is spelled as mainting This document replaces RFC RFC obsoleted RFC which originally described JSON and registered the media type applicationjson Lots of instances that has are missing in DecodeResult for example scalazPlus and scalazMonoid Currently its possible to encode a Map with a potentially arbitrary key if EncodeJsonKey is implemented but its not possible to decode in reverse Would be nice if there was a combinator that can descend into a JSON string as if it were JSON For example with the JSON field subField Be able to navigate a cursor like this c field subFieldas Int Heres some example code as proof of concept scala implicit class ACursorOpsself ACursor def fieldName String ACursor self fieldNameparsed def parsed ACursor selfas String result match case Left history selfhistoryfailedACursorselfanycursor case Righttext Parseparsetext match case Leftmessage selfhistoryfailedACursorselfanycursor case Rightjson selfhistoryacursorjsoncursor implicit class HCursorOpsself HCursor def fieldName String ACursor self fieldNameparsed 