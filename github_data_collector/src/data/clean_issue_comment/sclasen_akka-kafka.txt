We get an occasional NullPointerException in the BatchConnectorFSM and then all consuming halts There is no obvious way to setup a supervisor to restart ERROR OneForOneStrategy loaderakkaactordefaultdispatcher null javalangNullPointerException null at orgI IteczkclientZkConnectionwriteDataReturnStatZkConnectionjava at orgI IteczkclientZkClient callZkClientjava at orgI IteczkclientZkClientretryUntilConnectedZkClientjava at orgI IteczkclientZkClientwriteDataReturnStatZkClientjava at orgI IteczkclientZkClientwriteDataZkClientjava at orgI IteczkclientZkClientwriteDataZkClientjava at kafkautilsZkUtilsupdatePersistentPathZkUtilsscala at kafkaconsumerZookeeperConsumerConnectorcommitOffsetToZooKeeperZookeeperConsumerConnectorscala at kafkaconsumerZookeeperConsumerConnectoranonfun applyZookeeperConsumerConnectorscala at kafkaconsumerZookeeperConsumerConnectoranonfun applyZookeeperConsumerConnectorscala at scalacollectionimmutableHashMapHashMap foreachHashMapscala at scalacollectionimmutableHashMapHashTrieMapforeachHashMapscala at kafkaconsumerZookeeperConsumerConnectorcommitOffsetsZookeeperConsumerConnectorscala at kafkaconsumerZookeeperConsumerConnectorcommitOffsetsZookeeperConsumerConnectorscala at comsclasenakkakafkaBatchConnectorFSManonfun applyOrElseBatchActorsscala at comsclasenakkakafkaBatchConnectorFSManonfun applyOrElseBatchActorsscala at scalaruntimeAbstractPartialFunctionapplyAbstractPartialFunctionscala at akkaactorFSMclassprocessEventFSMscala at comsclasenakkakafkaBatchConnectorFSMprocessEventBatchActorsscala at akkaactorFSMclassakkaactorFSMprocessMsgFSMscala at akkaactorFSManonfunreceive applyOrElseFSMscala at akkaactorActorclassaroundReceiveActorscala at comsclasenakkakafkaBatchConnectorFSMaroundReceiveBatchActorsscala at akkaactorActorCellreceiveMessageActorCellscala at akkaactorActorCellinvokeActorCellscala at akkadispatchMailboxprocessMailboxMailboxscala at akkadispatchMailboxrunMailboxscala at akkadispatchMailboxexecMailboxscala at scalaconcurrentforkjoinForkJoinTaskdoExecForkJoinTaskjava at scalaconcurrentforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava at scalaconcurrentforkjoinForkJoinPoolrunWorkerForkJoinPooljava at scalaconcurrentforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava Pardon me for English is not my primary language We have size limitation on the messages so that StreamFSMhasNext will receive a MessageSizeTooLargeException when encountering a too large message The default SupervisorStrategy behavior is simply restart the process Since nothing changed the process gets stuck with this ill message forever Wed like to recover this error by moving offset to next so that we can skip this message and restart the process However we could not find a way to set SupervisorStrategy for the framework and change the default behavior I am wondering if there is a way for us to do so Simple fix of a typo atrecievetimeout in batch actor Im using the version from Sonatype resolvers Sonatype OSS at and getting some weird errors However when I build my own SNAPSHOT version everything works find Looking the at the commit history nothing has changed between the two versions Any idea whats wrong with the Sonatype build Would it make sense to allow passing a Map of Topic Stream to create a consumer for multiple topics Its currently possible to do that by passing a TopicFilter but it would be nice to have controlle over the number of streams for each topic Were seeing the following message in our logs WARN EventServiceakkaactordefaultdispatcher csakStreamFSM akkaEventServiceuserbstream unhandled event StartProcessing in state Draining Is this an error we should be concerned about How should we go about debugging Thanks in advance There are many stream consumer actors created FSMStreams but only one worker actor this essentially turns any nontrivial worker into a bottle neck would it make sense to have a consumer actor per stream Is there any plan to make this work with the consumer I know the architecture of that consumer is much different I would like to have a common base for akka consumers to allow for a generic way to process cleanup ex private this val consumerRegistry new ConcurrentHashMap String AkkaConsumerBase String scala def shutdown loggerinfoShutting down Event Bus producerclose AwaitreadyFuturesequenceconsumerRegistrymape e stop minute Thoughts coreyauger check out the last commit here 