I found myself wanting to pass structured data from Wren to C but I didnt want to define a foreign class specifically to do that so I thought having access to Maps from the C slot API made sense Doent make on bsd darkoNomadBSDGitHubwren gmake gmake Entering directory homedarkoGitHubwren cc srcoptionalwrenoptrandomc O stdc fPIC cc srcoptionalwrenoptmetac O stdc fPIC cc srcvmwrenprimitivec O stdc fPIC cc srcvmwrenvmc O stdc fPIC cc srcvmwrendebugc O stdc fPIC cc srcvmwrenvaluec O stdc fPIC cc srcvmwrencorec O stdc fPIC cc srcvmwrencompilerc O stdc fPIC cc srcvmwrenutilsc O stdc fPIC cc liblibwrenso O stdc fPIC Wlsonamelibwrenso ar liblibwrena rcu run utilbuildlibuvpy Unsupported platform FreeBSD gmake utilwrenmk buildlibuva Error gmake Leaving directory homedarkoGitHubwren gmake Makefile release Error Using bash to redirect Stdin from a file seems to fail Here is the simplest example test wren import io for Stdin Stdout var line StdinreadLine Systemprintline line When I run interactively it works chrisWINFE HG BFASB wrenwren test wren fred line fred chrisWINFE HG BFASB However when I redirect stdin to read from a nonempty file it fails chrisWINFE HG BFASB wrenwren test wren salestxt Aborted chrisWINFE HG BFASB head salestxt PostgreSQL database dump Dumped from database version Dumped by pgdump version Debian pgdg SET statementtimeout SET locktimeout SET idleintransactionsessiontimeout Using Ubuntu on WSL on Windows I wanted to try wren out in a real problem but found that I could not create directories This PR adds some basic file opertions to the io package Directorycreatepath which returns true on success and false when the folder already exists Directorydeletepath Filerenameoldpath newpath wrenGetVariable used to return void and failed an ASSERT when the VM was compiled in debug mode This isnt helpful for regular applications when it is useful to know that a variable isnt defined Therefore this breaks the API a little so that wrenGetVariable now returns an int to indicate success or failure It returns a for success and a for failure There is a surpringly elegant random sampling algorithm described in Programming Pearls which outperforms the current implementation on almost every case especially with mediumsized say sqrttotal samples I have also updated tests to treat samples taken as unordered sets In rare cases where a randomly taken and permuted list is desired the shuffle function can always be used That aside Algorithm R can still be used for sampling from an iterator of unknown length but that probably belongs to another PR Below are benchmark results on my machine for reference Operations are repeated arbitrary times to amplify the differences Total Samples Before After e e e e e e e e Code import random for Random var r Randomnew var run Fnnew n m its var a Listfilledn var t Systemclock for i in its rsamplea m SystemprintSystemclock t runcall e e runcall e e runcall e e runcall e e runcall e e runcall e e runcall e runcall e runcall e runcall e Would be glad to hear your opinions Ive verified that this test fails without the fix in change a c c b d db d abd bf See issue This PR fixes I am not sure if this causes memory leaks or not As far as I know the fiber should somehow be freed but I cant tell how Valgrind does report some problems but they seem unrelated to this issue This does not include any tests because I have no idea how the test system works If anyone can explain it to me Id be more than happy to create a test for this Description c WrenConfiguration config wrenInitConfiguration config WrenVM vm wrenNewVM config lets allocate some slots for later use wrenEnsureSlotsvm then lets execute a Wren script wrenInterpretvm main myScript now however we face a problem while the fibers stack got updated the API stack aka slot array didnt so were stuck with the old slots that got allocated during the first wrenEnsureSlots call Calling wrenEnsureSlots at this point will not yield any effect because of how slots are ensured c void wrenEnsureSlotsWrenVM vm int numSlots If we dont have a fiber accessible create one for the API to use if vmapiStack NULL problematic line vmfiber wrenNewFibervm NULL vmapiStack vmfiberstack int currentSize intvmfiberstackTop vmapiStack if currentSize numSlots return Grow the stack if needed int needed intvmapiStack vmfiberstack numSlots wrenEnsureStackvm vmfiber needed vmfiberstackTop vmapiStack numSlots In this case vmapiStack is not null but vmfiberstack is also a completely different stack than vmapiStack Updating vmapiStack through wrenSetSlotT calls will not have any effect because internally these functions update vmapiStack which now points to some unrelated stack That by itself wouldnt be a problem unless we try and wrenCall a method c wrenEnsureSlotsvm wrenGetVariablevm main MyClass will succeed and get us the correct variable WrenHandle classMyClass wrenGetSlotHandlevm WrenHandle methoddoThings wrenMakeCallHandledoThings wrenSetSlotHandlevm classMyClass will trigger a bug because the old stack is used WrenInterpretResult result wrenCallvm methoddoThings uh oh the above call will fail because we updated the old stack instead of the new one the VM will try to read from the new stack and the value read is null which causes the call to fail unexpectedly Possible fix Im no expert at the internals of the VM but I feel like a simple vmapiSlots update at the end of wrenInterpret would do the job just fine The overhead would be practically unnoticable so it wouldnt matter much If its not possible to update vmapiSlots with a correct value we can at least invalidate it by setting vmapiSlots NULL which would cause subsequent wrenEnsureSlots calls to allocate a new stack and use it in any VM invocations But as I said I am no expert so I dont know if it would even work That is to say numbers like e This was found as a result of porting a benchmark from another language to Wren This case is already handled by strtod so we only need to teach the tokenizer that its ok