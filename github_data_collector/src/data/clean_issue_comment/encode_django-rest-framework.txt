 Removed section that said to add import line from djangoconfurls import include Reasoning Tutorial already had user add from djangourls import include in part Alternatively mention that either import will link to the same module function The implication was that this new include import had different functionality or that maybe one of the imports were deprecated or something Added clarification to open browser at snippets endpoint Reasoning there are a lot of possible endpoints at this point in the tutorial and user hasnt been given a browser URLendpoint for a while Neither the index or the newly added apiauth give the described Login button potentially leading user to believe code was enterered incorrectly at some point Note Before submitting this pull request please review our contributing guidelines Description Please describe your pull request If it fixes a bug or resolves a feature request be sure to link to that issue When linking to an issue please use refs in the description of the pull request Checklist x I have verified that that issue exists against the master branch of Django REST framework x I have searched for similar issues in both open and closed tickets and cannot find a duplicate x This is not a usage question Those should be directed to the discussion group instead x This cannot be dealt with as a third party library We prefer new functionality to be in the form of third party libraries where possible x I have reduced the issue to the simplest possible case I have included a failing test as a pull request If you are unable to do so we can still accept the issue Steps to reproduce link to issue explaining pause on maintenance Expected behavior Actual behavior Discussion Should the DRF documentation point to projects no longer maintainedon pause Given the critical nature of authentication I think it would be good to either remove the project from the documentation or display its maintenance status Especially as it is just mentioned in an issue Fixes SearchFiltermustcalldistinct incorrectly exits early if it encounters an annotation Any subsequent m m fields are ignored instead of causing the method to return true By continuing the annotations still bypass the distinct check and will return false at the end if no m m fields are encountered This fixes which was caused by related changes in Model serializers will now correctly use serializer field names that map to the field sources in uniquetogether If there are multiple fields that use the same source seems unlikely but doesnt hurt to check then an error is raised instead Note that the error is raised somewhat late during validation but thats when the validators are generated We could createcache them on init maybe cache fields and validators but that seems like a separate discussion Adjusts the related field pkonly optimization check to also handle properties Should fix as well as Tests were adapted from but didnt include the hyperlink tests since I dont think theyre necessary here In regards to Im not too worried about the tests model changes since the rest of the test module fairly heavily relies on them Im not worried about impact either since the methodprop wont have an impact on other model serializer tests Thoughts Consider this useless serializer python class MySerializerserializersSerializer randomnumber serializersSerializerMethodField def getrandomnumberself Chosen by fair dice roll Guaranteed to be random return Assuming you added this serializer in an endpoint and generated the OpenAPI schema the serializer would look like this yaml properties randomnumber type string required randomnumber The issue here is there is no way to tell DRF to use type number here I thought of a few possibilities An outputfield attribute like serializersSerializerMethodFieldoutputfieldserializersIntegerField similarly to Djangos Query Expressions A decorator like openapitypeserializersSerializerMethodField serializersIntegerField An attribute similarly to setting descriptions on admin actions python randomnumber serializersSerializerMethodField def getrandomnumberself return getrandomnumberoutputfield serializersIntegerField Simply something DRF does not support which probably should be documented somewhere as a possible caveat Instead of copying over a select few fields from the schema generation for ListField we are now copying over the entire generated schema and trusting our schema generation to produce the right subschema for the child field This fixes This closes Request Method GET AssertionError Using OpenAPIRenderer but pyyaml is not installed homeadminDEVPYTHONFrameworksdjangoHighEndSalesEnvlibpython sitepackagesrestframeworkrendererspy in init line homeadminDEVPYTHONFrameworksdjangoHighEndSalesEnvbinpython homeadminDEVPYTHONFrameworksdjangoHighEndSalesEnvbackend usrlibpython zip usrlibpython usrlibpython libdynload homeadminDEVPYTHONFrameworksdjangoHighEndSalesEnvlibpython sitepackages Fri Jan Why this error again when this issue is already resolved in Adds failing test for Checklist x I have verified that that issue exists against the master branch of Django REST framework x I have searched for similar issues in both open and closed tickets and cannot find a duplicate but I think it might be related to the work here x This is not a usage question Those should be directed to the discussion group instead x This cannot be dealt with as a third party library We prefer new functionality to be in the form of third party libraries where possible x I have reduced the issue to the simplest possible case x I have included a failing test as a pull request If you are unable to do so we can still accept the issue Steps to reproduce First check Django behaviour Given a simple Model with a single IntegerField when working with SQLite Im running version which is officially supported by Django it is possible to generate an overflow error Model py class OverflowModelmodelsModel value modelsIntegerFielduniqueTrue Test py def testmodelself OverflowModelvalue fullclean Gives an OverflowException py teststestmodelserializerpy in testmodel OverflowModelvalue fullclean toxvenvspy django libpython sitepackagesdjangodbmodelsbasepy in fullclean selfvalidateuniqueexcludeexclude toxvenvspy django libpython sitepackagesdjangodbmodelsbasepy in validateunique errors selfperformuniquechecksuniquechecks toxvenvspy django libpython sitepackagesdjangodbmodelsbasepy in performuniquechecks if qsexists toxvenvspy django libpython sitepackagesdjangodbmodelsquerypy in exists return selfqueryhasresultsusingselfdb toxvenvspy django libpython sitepackagesdjangodbmodelssqlquerypy in hasresults return compilerhasresults toxvenvspy django libpython sitepackagesdjangodbmodelssqlcompilerpy in hasresults return boolselfexecutesqlSINGLE toxvenvspy django libpython sitepackagesdjangodbmodelssqlcompilerpy in executesql cursorexecutesql params toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in execute return selfexecutewithwrapperssql params manyFalse executorselfexecute toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in executewithwrappers return executorsql params many context toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in execute return selfcursorexecutesql params toxvenvspy django libpython sitepackagesdjangodbbackendssqlite basepy in execute return DatabaseCursorexecuteself query params E OverflowError Python int too large to convert to SQLite INTEGER However using MaxValueValidator allows us to protect SQLite from this overflow So if we change the model and test then Django raises a ValidationError complaining that value is too large Model py class OverflowModelmodelsModel value modelsIntegerFielduniqueTrue validators MaxValueValidator Test py def testmodelself with selfassertRaisesValidationError OverflowModelvalue fullclean In this way we can use Django to protect SQLite from the overflow all is good at the Django level DRF behaviour Now we make a ModelSerializer for this updated model with the MaxValueValidator in place and test it with the large int py def testself class TestSerializerserializersModelSerializer class Meta model OverflowModel fields all serializer TestSerializerdatavalue with selfassertRaisesserializersValidationError serializerisvalid Expected behaviour This test should pass The DRF model serializer should raise a ValidationError that complains that value is too large something like restframeworkexceptionsValidationError value ErrorDetailstringEnsure this value is less than or equal to codemaxvalue Actual behaviour However the test fails with an OverflowError which arises from the uniqueness check py teststestmodelserializerpy in test serializerisvalid restframeworkserializerspy in isvalid selfvalidateddata selfrunvalidationselfinitialdata restframeworkserializerspy in runvalidation value selftointernalvaluedata restframeworkserializerspy in tointernalvalue validatedvalue fieldrunvalidationprimitivevalue restframeworkfieldspy in runvalidation selfrunvalidatorsvalue restframeworkfieldspy in runvalidators validatorvalue self restframeworkvalidatorspy in call if qsexistsqueryset restframeworkvalidatorspy in qsexists return querysetexists toxvenvspy django libpython sitepackagesdjangodbmodelsquerypy in exists return selfqueryhasresultsusingselfdb toxvenvspy django libpython sitepackagesdjangodbmodelssqlquerypy in hasresults return compilerhasresults toxvenvspy django libpython sitepackagesdjangodbmodelssqlcompilerpy in hasresults return boolselfexecutesqlSINGLE toxvenvspy django libpython sitepackagesdjangodbmodelssqlcompilerpy in executesql cursorexecutesql params toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in execute return selfexecutewithwrapperssql params manyFalse executorselfexecute toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in executewithwrappers return executorsql params many context toxvenvspy django libpython sitepackagesdjangodbbackendsutilspy in execute return selfcursorexecutesql params toxvenvspy django libpython sitepackagesdjangodbbackendssqlite basepy in execute return DatabaseCursorexecuteself query params E OverflowError Python int too large to convert to SQLite INTEGER Thoughts Ignore as appropriate It looks to me like the check for uniqueness happens before the field level validation that happens as a result of the MaxValueValidator because when I dump the fields validators I get UniqueValidatorquerysetOverflowModelobjectsall djangocorevalidatorsMaxValueValidator object at x f eff f This means that roundtripping the database happens before checking the max value This is unexpected behaviour and I was surprised when I found it I would expect as much validation as possible to take place before the database hit I also experimented with adding a fieldlevel validatevalue function to the serializer but it appears that runvalidators happens before that is trigged so its no help in preventing the overflow