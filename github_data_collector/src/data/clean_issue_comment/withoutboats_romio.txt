As proposed in cc Ralith I am not a native English speaker so any help with grammar will be appreciated There is no way to convert stream objects to their underlying type but in some cases its useful to be able to perform blocking IO such as when wrapped in stream that handles WouldBlock error in some way The specific use case for this is which works around the issue using CompatS where S AsyncRead AsyncWrite which implements Futures Stream However this wont work outside of executor eg Tokio which makes the usage with Romio awkward Im not sure whats the best solution here but I would assume reexporting mio interfaces is acceptable This would allow the depending library to use Read Write directly This allows setting various socket options eg SOREUSEPORT before binding to the socket and also socket passing from the service supervisor eg systemd Hi there I read through some of the other issues on timers in romio but it seemed slightly different than changing the underlying mionet settings I want to open a large number of TCP connections to different hosts which may or may not respond In order to prevent an excessive number of open files on the client I want to configure aggressive connection timeouts to prune connections that dont respond quickly Id be happy to try to submit a PR to add a Builder object or something to make TcpStream more configurable but Im not sure if there is somewhere I should be looking for an example of this Im digging into the Rust asyncawait story and Im not experienced in it yet Heres a brief snippet that shows the code Im using I appear to be hanging onto connections that fail for some time and if there is an alternate path to fix Id be happy to try that out instead rust fn main ioResult let delay e as u REQUESTSPERSECOND executorblockonasync for in TOTALREQUESTS juliexspawnasync move let addr randomaddr match TcpStreamconnectaddrawait Okmut stream streamwriteall REQUEST await expectFailed to write to socket streamclose await expectFailed to close socket printlnSuccess addr Erre eprintlnFailed to connect e Ok Thanks Ryan This library doesnt look active Can it be move to Rustasync organization It may will be better for it First access of CURRENTREACTOR would run a reactor in a background thread Does it mean for threadpoll executor each thread local reactor would be running in a paired background thread Why not run the reactor via unpark just like tokio the runtime setup would init the reactor directly Why exists socalled fallback way Please help to clarify it removed the vectored implementations because mio doesnt support stds ioslice yet which is used in the current AsyncRead and AsyncWrite traits We should restore these implementations once mio supports it Refs This is very similar to Running the following test program hangs and doesnt notice that the client has closed the write side of the TcpStream rust featurefuturesapi asyncawait awaitmacro use stdio netIpAddr use futuresStreamExt ioAsyncReadExt AsyncWriteExt use romioTcpListener use romioTcpStream fn main futuresexecutorblockonasync let ip IpAddr parseunwrap let mut listener TcpListenerbind ip intounwrap let port listenerlocaladdrunwrapport let mut incoming listenerincoming let rx mut tx awaitTcpStreamconnect ip portintounwrapsplit let mut rx tx awaitincomingnextunwrapunwrapsplit printlnConnection established printlnClosing tx awaittxcloseunwrap printlnWait for server to notice connection was closed let mut byte let res awaitrxreadexact mut byte assertresiserr asserteqresunwraperrkind ioErrorKindUnexpectedEof By adding in a wrapper around the clients TcpStream that implements pollclose to call shutdownShutdownWrite the server notices that the client has closed the TCP connection rust struct FixTcpStream impl AsyncRead for Fix fn pollread mut self waker Waker buf mut u PollioResultusize self pollreadwaker buf impl AsyncWrite for Fix fn pollwrite mut self waker Waker buf u PollioResultusize self pollwritewaker buf fn pollflush mut self waker Waker PollioResult self pollflushwaker fn pollclose mut self waker Waker PollioResult readyselfpollflushwaker PollReadyself shutdownstdnetShutdownWrite For some reason in the linked Tokio issue they dont want to apply this change to TcpStream itself I cant see any reason not to just change it though From talking with withoutboats it would make sense to create a timer implementation on top of OS timers Im not quite sure yet how this should work but a cursory search shows that theres multiple options available on unix through timercreate and epoll with a timeout parameter Im not sure yet about Windows References I was trying to make a supervisor app with asyncawait and failed I can express my thoughts in Python as following code but i dont know how to do it in Rust python import asyncio class App def initself selfapi ControlServiceself selfbusiness MyBussinessService async def serveself await asynciowait selfapiserve selfbusinessserve class ControlService def initself app selfapp app async def serveself while True print ControlService Waiting for user cmd cmd await simulateuserrequest print ControlService Received user cmd formatcmd if cmd reset here we need to mutate the business and get the result ok selfappbusinessreset if ok pass else pass else pass class MyBussinessService def initself selfvalue def resetself selfvalue return True async def serveself while True print BussinessService Business value formatselfvalue selfvalue await asynciosleep async def simulateuserrequest await asynciosleep return reset if name main app App loop asynciogeteventloop looprununtilcompleteappserve loopclose 