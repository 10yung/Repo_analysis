AES GCM is rightfully becoming very popular perhaps an example would be useful to include somewhere in the project As an aside Ive created a Gist for GCM with this library Something odd I noticed while working on this PR In the OS kernel dll depends on ntdlldll and not the other way around In the PInvoke library PInvokeNTDll depends on PInvokeKernel which was somewhat confusing for me There are functions in Kernel dll which are simple forwards into ntdlldll For eg dumpbin exports kernel dll findstr i ntdll AcquireSRWLockExclusive forwarded to NTDLLRtlAcquireSRWLockExclusive AcquireSRWLockShared forwarded to NTDLLRtlAcquireSRWLockShared AddVectoredContinueHandler forwarded to NTDLLRtlAddVectoredContinueHandler AddVectoredExceptionHandler forwarded to NTDLLRtlAddVectoredExceptionHandler CancelThreadpoolIo forwarded to NTDLLTpCancelAsyncIoOperation CloseThreadpool forwarded to NTDLLTpReleasePool CloseThreadpoolCleanupGroup forwarded to NTDLLTpReleaseCleanupGroup CloseThreadpoolCleanupGroupMembers forwarded to NTDLLTpReleaseCleanupGroupMembers CloseThreadpoolIo forwarded to NTDLLTpReleaseIoCompletion CloseThreadpoolTimer forwarded to NTDLLTpReleaseTimer CloseThreadpoolWait forwarded to NTDLLTpReleaseWait CloseThreadpoolWork forwarded to NTDLLTpReleaseWork D DecodePointer forwarded to NTDLLRtlDecodePointer E DecodeSystemPointer forwarded to NTDLLRtlDecodeSystemPointer DeleteCriticalSection forwarded to NTDLLRtlDeleteCriticalSection DisassociateCurrentThreadFromCallback forwarded to NTDLLTpDisassociateCallback EncodePointer forwarded to NTDLLRtlEncodePointer EncodeSystemPointer forwarded to NTDLLRtlEncodeSystemPointer EnterCriticalSection forwarded to NTDLLRtlEnterCriticalSection ExitThread forwarded to NTDLLRtlExitUserThread A FlushProcessWriteBuffers forwarded to NTDLLNtFlushProcessWriteBuffers B FreeLibraryWhenCallbackReturns forwarded to NTDLLTpCallbackUnloadDllOnCompletion D GetCurrentProcessorNumber forwarded to NTDLLRtlGetCurrentProcessorNumber E GetCurrentProcessorNumberEx forwarded to NTDLLRtlGetCurrentProcessorNumberEx HeapAlloc forwarded to NTDLLRtlAllocateHeap HeapReAlloc forwarded to NTDLLRtlReAllocateHeap HeapSize forwarded to NTDLLRtlSizeHeap E InitOnceInitialize forwarded to NTDLLRtlRunOnceInitialize F InitializeConditionVariable forwarded to NTDLLRtlInitializeConditionVariable InitializeCriticalSection forwarded to NTDLLRtlInitializeCriticalSection InitializeSListHead forwarded to NTDLLRtlInitializeSListHead InitializeSRWLock forwarded to NTDLLRtlInitializeSRWLock C InterlockedCompareExchange forwarded to NTDLLRtlInterlockedCompareExchange InterlockedFlushSList forwarded to NTDLLRtlInterlockedFlushSList InterlockedPopEntrySList forwarded to NTDLLRtlInterlockedPopEntrySList InterlockedPushEntrySList forwarded to NTDLLRtlInterlockedPushEntrySList InterlockedPushListSList forwarded to NTDLLRtlInterlockedPushListSList InterlockedPushListSListEx forwarded to NTDLLRtlInterlockedPushListSListEx D IsThreadpoolTimerSet forwarded to NTDLLTpIsTimerSet C LeaveCriticalSection forwarded to NTDLLRtlLeaveCriticalSection C LeaveCriticalSectionWhenCallbackReturns forwarded to NTDLLTpCallbackLeaveCriticalSectionOnCompletion QueryDepthSList forwarded to NTDLLRtlQueryDepthSList B ReleaseMutexWhenCallbackReturns forwarded to NTDLLTpCallbackReleaseMutexOnCompletion B ReleaseSRWLockExclusive forwarded to NTDLLRtlReleaseSRWLockExclusive B ReleaseSRWLockShared forwarded to NTDLLRtlReleaseSRWLockShared B ReleaseSemaphoreWhenCallbackReturns forwarded to NTDLLTpCallbackReleaseSemaphoreOnCompletion C RemoveVectoredContinueHandler forwarded to NTDLLRtlRemoveVectoredContinueHandler C RemoveVectoredExceptionHandler forwarded to NTDLLRtlRemoveVectoredExceptionHandler CC ResolveDelayLoadedAPI forwarded to NTDLLLdrResolveDelayLoadedAPI CD ResolveDelayLoadsFromDll forwarded to NTDLLLdrResolveDelayLoadsFromDll CF RestoreLastError forwarded to NTDLLRtlRestoreLastWin Error D RtlMoveMemory forwarded to NTDLLRtlMoveMemory D RtlZeroMemory forwarded to NTDLLRtlZeroMemory SetCriticalSectionSpinCount forwarded to NTDLLRtlSetCriticalSectionSpinCount A SetEventWhenCallbackReturns forwarded to NTDLLTpCallbackSetEventOnCompletion SetThreadpoolThreadMaximum forwarded to NTDLLTpSetPoolMaxThreads A SetThreadpoolTimer forwarded to NTDLLTpSetTimer B SetThreadpoolTimerEx forwarded to NTDLLTpSetTimerEx C SetThreadpoolWait forwarded to NTDLLTpSetWait D SetThreadpoolWaitEx forwarded to NTDLLTpSetWaitEx StartThreadpoolIo forwarded to NTDLLTpStartAsyncIoOperation SubmitThreadpoolWork forwarded to NTDLLTpPostWork A TryAcquireSRWLockExclusive forwarded to NTDLLRtlTryAcquireSRWLockExclusive A TryAcquireSRWLockShared forwarded to NTDLLRtlTryAcquireSRWLockShared AA TryEnterCriticalSection forwarded to NTDLLRtlTryEnterCriticalSection C VerSetConditionMask forwarded to NTDLLVerSetConditionMask DC WaitForThreadpoolIoCallbacks forwarded to NTDLLTpWaitForIoCompletion DD WaitForThreadpoolTimerCallbacks forwarded to NTDLLTpWaitForTimer DE WaitForThreadpoolWaitCallbacks forwarded to NTDLLTpWaitForWait DF WaitForThreadpoolWorkCallbacks forwarded to NTDLLTpWaitForWork E WakeAllConditionVariable forwarded to NTDLLRtlWakeAllConditionVariable E WakeConditionVariable forwarded to NTDLLRtlWakeConditionVariable I havent analyzed to check whether any of these have public documentation for each of the kernel and ntdll exports respectively which would in turn make it plausible to imagine a scenario where only an ntdll PInvoke needs to be written and the corresponding PInvokeKernel implementation would simply become a call into the PInvokeNTDll PInvoke method Even without necessarily invoking the possibly dubious optimization suggested above the architectural inversion caught my eye Originally posted by vatsanmadhavan in Microsofts longterm support for NET Core x and are over Customers targeting these versions are in a really bad place due to no security patches being offered and thus there are likely few to none out there Similarly such a critical mass of customers already have net on their machines that many apps and libraries now support it PCLs eg portablenet win wpa have not been createable in VS for years as well This means we can likely target just netstandard and UWP to retain our Store app compliance As of RS kernel dll now has the following three methods CreatePseudoConsole ResizePseudoConsole ClosePseudoConsole The CreatePipe method should output SafeFileHandles intead of SafeObjectHandles By outputting SafeFileHandle directly it makes it easier to wrap these up in FileReader and FileWriter classes Hi Some of the missing pinvoke APIs from Kernel which is useful CreateThread CreateRemoteThread CreateRemoteThreadEx Doing overlapped IO with the transition between managed and unmanaged code is significantly difficult While the overlapped structure is recreated and several methods have been provided without additional work the process for actually using them is unclear and extremely error prone The NET framework and NET core both contain facilities that make this process easier Examples are OverlappedNativeOverlapped and ThreadPoolBoundHandle Since NativeOverlapped shares the same layout as the provided OVERLAPPED struct using a pointer cast works but seems to me a bit messy Id like to start a discussion about how this library should handle this particular area Our SafeHandle classes usually expose a public static readonly Null field which is initialized to a null handle Is this safe What if someone sets a structs SafeHandle field to one of these instances and pass the struct into a pinvoke function call that initializes that handle Would it not set the null instance to a nonnull value Further if the same instance is used multiple times in a single pinvoke call wouldnt that cause all of the parametersfields to be set to the same value since theyre sharing the same instance I realized this potential problem while authoring a fix for Our README points to a downloadable html file that appveyor produces to report on our API coverage This is a clunky UX This stylecopanalyzers experience is much better and is similarly produced in part by appveyor sharwell developed this We should do something nice like that 