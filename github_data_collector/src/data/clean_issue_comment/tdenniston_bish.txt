 ranlib is a thing of the past and all major ar implementations have s to do it while it makes the archive the extra invocation takes plenty of time on my Cygwin pipe tells gcc to use memory instead of temp files less IO means faster build the warnings are there just there to make things safer Wreorder seems to complain a lot but since most member initializers are pure it feels okay to turn it off Try printlna b c You will get a commnadnotfound for a because it actually tried to run it I tried to work this around by implementing the magical POSIX quote C void CodeGenBashoutputescapedstringconst stdstring s stream stdptrdifft current previous current sfind while current stdstringnpos stream ssubstrprevious current previous previous current current sfind previous stream ssubstrprevious current previous stream combined with disabling the keeping behavior in Parser for quoted strings to handle cases like literal and not enabling the escape for the ExternCall code path The problem is it also kills legit backslashes like n I tried changing the backslash handling for the lexer as well but it is too late in midnight for my brain to come up with a sensible solution Basically I want the new scanuntil to discard all backslashes that do escape some token have backslashes selfescape that is n backslashes turn into n in the actual string have the boolean parameter decide how to handle the lone odd slash requires rewriting the lookahead part to resemble something like find token match if foundpreliminary if escape emit n result stdstringbackslashes n else break away from while But I am just too tired to try it srcTokenizercpp in line never used variable c Ive been thinking of something like this for a while but I always focused on the idea of automating the autocompletion scripts It would be really cool to come up with a declarative syntax for defining function arguments that could be compiled into programmable completion in bash Here is a contrived example of how a function in bish could be annotated python def lsfileNone kwargs file File the name of the file to ls l enable long output a include hidden files longopt longer option for example return binls file kwargs This would enable the following behavior bash ls Tab file the name of the file to ls l enable long output a include hidden files longopt longer option for example ls Tab l enable long output a include hidden files longopt longer option for example ls longTab ls longopt ls longoptTab longopt longer option for example You can see a real world example of this type of autocompletion with tmux Start some sessions and type tmux attachsession Tab Im not sure if it would work to this degree in bash as Ive only seen it in zsh but it does offer some level of programmable autocompletion The following snippet complains that newval is not defined however it is def slicelinesval start nlines numlinesval if nlines printlnError quit newval for curr in nlines line getlineval curr if curr start printlnGot line line if curr start newval printfnewval nchompline return newval Error Bish error Undefined variable newval Abort Here is a snippet that works correctly when run as a standalone bash script but fails in bash r def readline y exec head n return y val readline printlnGot val This seems to me to be because of runon in bishcpp I propose we create a temporary file somewhere and run it using system rather than trying to mimic the semantics of this Thoughts Id be willing to fix this issue This adds information on how to get bish through Homebrew sparkles As discussed here File globbing is considered one of the main benefits of shell scripts versus other scripting languages Bish should support globbing as a firstclass feature Example of how this might look for f in txt printlnText file f Bash supports lots of string manipulation Bish should unify the functionality covered in that page and provide a saner syntax 