I noticed that isflagsupported detects failure by looking for output on stderr I was wondering if this might be unreliable sometimes It looks like it currently requires a tricky workaround to remove the v flag on Clang for example Would it be possible to check the return code of the compiler instead to see if its nonzero Or maybe theres some known case where that doesnt work As I understand the default target value comes from RustCargo It ends up as something like x unknownfreebsd Passing that to clang breaks everything causes it to look for gnu stdc not to look for C headers in the default location etc clang only handles versioned FreeBSD targets eg x unknownfreebsd correctly Who is to blame is a hard question should llvmclang be fixed to accept unversioned targets should Rust report versioned targets both but Im not sure if the target should be passed at all when not crosscompiling This issue was originally filed as but alexcrichton helped me understand that it is more likely an issue with the cc crate itself Thanks for filing a bug report Problem Using fresh installations of Rust installed on x unknownlinuxgnu Debian via the rustup method compiling packages for Android with newer versions of the NDK does not work without overriding a number of tool paths manually It seems like the Android targets expect older NDK toolchain binary name patterns It also seems like rustc expects the host linker to be able to link target binaries which seems wrong Steps sh rustupinitsh fresh install for the local user rustup target add aarch linuxandroid Create the hello world example from the documentation cat Cargotoml package name helloworld version authors Your name youexamplecom cat srcmainrs fn main printlnHello world Compile for the host x Linux and all is well cargo build Compiling helloworld v homebspencersandboxhello Finished dev unoptimized debuginfo targets in s targetdebughelloworld Hello world Compile for aarch linuxandroid and it fails to link because it tries to use the host linker instead of the Android NDK linker cargo build target aarch linuxandroid Compiling helloworld v homebspencersandboxhello error linking with cc failed exit code note cc Wlasneeded Wlznoexecstack Wlallowmultipledefinition L homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidlib homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a w efdyklh hkqbrcguo homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a x o sb humiwdrcguo homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a tjohv q sq oh rcguo homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a xzbcgkopcdgl qwrcguo homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a d w t x lz znrcguo o homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a xa pa xhw nyrcguo Wlgcsections pie Wlzrelro Wlznow nodefaultlibs L homebspencersandboxhellotargetaarch linuxandroiddebugdeps L homebspencersandboxhellotargetdebugdeps L homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidlib Wlstartgroup WlBstatic homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibstd ed a e e c barlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibpanicunwinda erlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibhashbrown daf d rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibrustcstdworkspacealloc daf b a brlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibbacktrace d d ce rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibbacktracesys acfc a rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibrustcdemangleeb e f fe b b rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibunwind e ddd a rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibcfgifaf e c fd d rlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidlibliblibc f a b d crlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidlibliballocad c a erlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibrustcstdworkspacecore bd cb c ferlib homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibcorefc e a rlib Wlendgroup homebspencerrustuptoolchainsstablex unknownlinuxgnulibrustlibaarch linuxandroidliblibcompilerbuiltinsebe ded f e rlib WlBdynamic ldl llog lgcc lc lm note usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM usrbinld homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo Relocations in generic ELF EM homebspencersandboxhellotargetaarch linuxandroiddebugdepshelloworld ab e cae a epep ugdczvg yqrcguo error adding symbols File in wrong format collect error ld returned exit status error aborting due to previous error error could not compile helloworld To learn more run the command again with verbose By specifying the location of the r c NDK linker we can avoid this problem CARGOTARGETAARCH LINUXANDROIDLINKERANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang cargo build target aarch linuxandroid Compiling helloworld v homebspencersandboxhello Finished dev unoptimized debuginfo targets in s file targetaarch linuxandroiddebughelloworld targetaarch linuxandroiddebughelloworld ELF bit LSB shared object ARM aarch version SYSV dynamically linked interpreter systembinlinker not stripped Telling cargo and rustc where the Android NDK tools are seems reasonable but its odd that they default to using the system linker which isnt going to work Using PATH isnt enough because the Android NDK doesnt call its linker or compiler driver cc However if you try to use JNI support which is necessary for many Android projects even specifying the linker isnt enough Consider this trivial JNI project which is from the docs with some parts deleted cat Cargotoml package name jni version authors Your name youexamplecom edition dependencies jni lib cratetype cdylib cat srclibrs use jniJNIEnv use jniobjectsJClass nomangle pub extern system fn JavaHelloWorldhelloenv JNIEnv class JClass It builds fine for the host but fails when targeting Android even with the environment variable from above CARGOTARGETAARCH LINUXANDROIDLINKERANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang cargo build target aarch linuxandroid Compiling libc v Compiling cc v Compiling cfgif v Compiling byteorder v Compiling versioncheck v Compiling memchr v Compiling samefile v Compiling rustcdemangle v Compiling void v Compiling log v Compiling either v Compiling ascii v Compiling jnisys v Compiling cesu v Compiling unreachable v Compiling walkdir v Compiling errorchain v Compiling jni v Compiling combine v Compiling backtracesys v error failed to run custom build command for backtracesys v Caused by process didnt exit successfully homebspencersandboxjnitargetdebugbuildbacktracesysfa a e edabuildscriptbuild exit code stdout OPTLEVEL Some TARGET Someaarch linuxandroid HOST Somex unknownlinuxgnu CCaarch linuxandroid None CCaarch linuxandroid None TARGETCC None CC None CFLAGSaarch linuxandroid None CFLAGSaarch linuxandroid None TARGETCFLAGS None CFLAGS None CRATECCNODEFAULTS None DEBUG Sometrue running aarch linuxandroidclang O ffunctionsections fdatasections fPIC g fnoomitframepointer targetaarch linuxandroid Wall Wextra E srcandroidapic stderr error occurred Failed to find tool Is aarch linuxandroidclang installed It seems that cargo is now looking for the actual Android NDK C compiler Using PATH isnt enough because even though the newer NDKs come with already standalone toolchains and in fact the scripts that one used to use to copy the toolchains warn you not to basically the names of the compiler and linker drivers include the triplet and the API level integer So the next iteration is to tell cargo via a different set of environment variables where the Android NDK C compiler is CCaarch linuxandroidANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang CARGOTARGETAARCH LINUXANDROIDLINKERANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang cargo build lib release target aarch linuxandroid This gets further but then it chokes on aarch linuxandroidar instead running aarch linuxandroidar crs homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outlibbacktracea homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracealloco homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracedwarfo homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracefilelineo homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktraceposixo homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracereado homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracesorto homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktracestateo homebspencersandboxjnitargetaarch linuxandroidreleasebuildbacktracesysd dc ff a outsrclibbacktraceelfo stderr error occurred Failed to find tool Is aarch linuxandroidar installed This time the PATH will help because at least cargo is trying to invoke the tool with the right name PATHANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binPATH CCaarch linuxandroidANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang CARGOTARGETAARCH LINUXANDROIDLINKERANDROIDNDKHOMEtoolchainsllvmprebuiltlinuxx binaarch linuxandroid clang cargo build lib release target aarch linuxandroid Thats pretty awkward Questions Have I misunderstood how to configure for Android cross targets Is there some unified way of specifying where the build tools should find the appropriate CC AR LD for the target instead of using three different kinds of environment variables Note that I purposely didnt use cargoconfig or similar approaches because they didnt work for all of the required tools required by such builds and those files cant use a variablylocated Android NDK Note how I am using ANDROIDNDKHOME to find the NDK in all instances Should the host linker really be used by default for cross target linking Have the Android targets been updated to be aware of the newer Android NDK toolchain naming conventions Thanks Notes Output of cargo version cargo version cargo c ec d rustc version rustc ea cat ANDROIDNDKHOMEsourceproperties PkgDesc Android NDK PkgRevision Currently when cc uses the EnumSetupInstances COM API to locate VS installations it just picks whatever is first without any attempt at finding the newest version This results in issues where it will select to use VS instead of VS which is really bad when statically linking to CC libraries that were built using VS This is also a general symptom of not having a single centralized place to dictate which VS version to use Tracking issue I had an installation of the sdk that did had files in Lib but not in Include vcvars handled this correctly but ccrs did not This issue is derived from creates a new process reads its output as a byte stream then proceeds to reemit each line via stdiostdoutwriteall Unfortunately this may not just work on Windows Thats because on Windows Rusts stdio streams enforce that written bytes from Rust are UTF when things are operating in console mode If we invoke a process that emits bytes that arent UTF say clexe emitting a localized warning message when the system code page isnt UTF spawn will proxy these non UTF bytes to Rusts stdio handler which will summarily reject the bytes The impact of this bug is that Windows users not using a system code page and localization that doesnt emit UTF will not be able to use the cc crate under certain use cases The workaround is for spawn to convert the output bytes to UTF to placate Rusts standard library luser has pointed me at as an example of such code withfeatures in Tool uses the name of the path to determine compiler family in It appears that for modern Macs running Mojave c is symlinked to clang but cc doesnt follow the symlink and treats it as a gnu compiler Current workaround is to manually set CXXwhich clang but the right solution should look at the output of c v instead of the path name The change in this PR c bf b a b a c dd ade cd seems to be the right choice to make clangclang should be considered the default on macOS and it allows the ToolFamily to be chosen correctly based on the name Many tests fail however and I believe thats because a they are duplicated for Linux and macOS targets and b each uses the same target and host For example consider this test from teststestrs rust test fn gnux for vendor in unknownlinuxgnu appledarwin let target formatx vendor let test Testgnu testgcc target target host target filefooc compilefoo testcmd musthavefPICmusthavem So first is my premise about choosing the default compiler on macOS is correct If so how should the tests change This is an evolution of That PR was too naive with duplicate flag checking and ended up causing problems This change organizes flags into two groups flags that do not carry a value and are mutually exclusive m m and flags that carry a value that should only be set once march mcpu Both groups are handled separately