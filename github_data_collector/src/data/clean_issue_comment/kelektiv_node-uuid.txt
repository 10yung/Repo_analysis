This is a collection of a few more cleanup and tooling commits in preparation of a first alpha release The UUID generator can be built to a browser application using browserify webpack rollup or similar other bundler However if the application is built from pure JavaScript modules or AMD modules this package cannot be used without an additional bundling work Scripts published from the NPM package cannot be loaded by the script element on a web page How about including UMD modules in the NPM package so that browser applications could load them directly without each of them building such module themselves internally For example by importing the UUID generator function globally html script src script var id uuidv consolelogid script Another example requiring the UUID generator as an AMD module using RequireJS for example html script src script requireconfig paths uuidv require uuidv functionuuid var id uuid consolelogid script AMD RequireJS UMD Umbrella issue to give an overview of whats planned for v ESM Build for the browser x Platform Support matrix Browser tests x Automated Release Changelog generation Was already mostly there Full automation is maybe not a goal given that this library doesnt change so often at the moment Improved TypeScript definitions node Nodejs dep for Browser Insecure RNG OptIn Rename package script to build As of ECMAScript Module ESM support in Nodejs is still experimental and there is not yet a stable way of offering an ESM build for Nodejs The authors of the Nodejs module working group even urge developers not to release dual CommonJSESM packages to npm yet see which states Dual CommonJSESM packages Either support packages with both CommonJS and ESM sources that can be used in either environment or decide to specifically not support dual CommonJSESM packages Status quo at time of possible unflagging main points to exactly one file and all file extensions are mandatory by default so there is no possibility of an import specifier pointing to different files in ESM versus CommonJS Recommended practice for dual packages is to have main point to the CommonJS entry point and have users use a deep import eg modulemjs to access ESM entry point There is ongoing work within Nodejs to support multiple exports for npm packages which will eventually solve this issue We will support this feature once it becomes stable in node ie once its no longer hidden behind an experimental flag Corresponding Nodejs issues Ive spent some time continuing the work started in I have the following highlevel objectives x Modernize the code base x Provide a CommonJS build for nodejs x Provide an ESM ECMAScript Module build for use in BrowserBundlers like webpack rollup etc x Provide an ESM build for direct use in the browser x Provide an ESM build for direct use in node Still unclear ifwhen Nodejs will remove the experimental flag Wont do as of Oct Changelog So far I have tried to build a hybrid npm package that contains both a CommonJS build and an esm build I followed the pattern that uses This works fine for CommonJSusage in Nodejs and esmusage with bundlers like webpack for the browser However it does not play nice with pure esm usage For webpack and other bundlers were saved by the module esmindexjs property in packagejson so far so good For Nodejs if we wanted true esm wed have to publish the package with type module in packagejson and have the main property point directly to the esm build the module property as mentioned above does not seem to work This could be something like uuides similar to For native esm usage in Browsers we run into yet another problem We currently rely on the browser map in packagejson to overwrite certain libraries in the browser context This is again respected by webpack and other bundlers but obviously not by the browsers themselves So here wed maybe have to release another uuidesbrowser package with rngsha md libraries swapped by the respective browser counterparts Still have to check on TypeScript At this point Im not certain how to move forward and any feedback would be highly appreciated broofa defunctzombie Unfortunately Im trying to use this library with Typescript so I need to use typesuuid but that contains a reference to Buffer in globalsdts which means it pulls in typesnode which breaks my build Im writing code for browsers not node There would be a few possible fixes for this including just removing the reference to Buffer and just using Array ArrayLike or creating an interface for Buffer instead of pulling in the one from node Hi I see the bufferarray support was added I would again see propose to add the option to pass encoded in particular binary data to the CLI Previously you considered the CLI a convenience for simple use cases and binary names would not fall into that category When working with unique hardware ids or serial numbers arbitrary byte sequences occur that would have be to be transformed otherwise beforehand Although for such cases custom scripts may exist but this feature might still be a nice to have outofthebox convenience in particular when having to manually test or verify other processing steps Merely proposing and as well as some of the work were doing over at have had me playing around with what this module might look like if it was rewritten using modern ES features ES modules BigInt and with a UUID class for parsingunparsing and validation This is the workinprogress result Posting this mostly because my laptops logic board decided to crap out and enough work went into it Id rather not risk losing it while dealing with Apple repair process Feel free to comment with the caveat that I dont have a concrete plan yet for merging to master here New option for v and v allowInsecureRng Require to be true if rnginsecure true Closes Heres my attempt at closing please let me know if a different approach is preferred Right now this module will automatically fall back to Mathrandom in browser environments that dont support CSPRNG use essentially failing open To operate securely it should instead fail hard with an error and only allow falling back to an insecure random source if the developer explicitly indicates that this is acceptable