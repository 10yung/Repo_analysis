I have an application which drives a bunch of i c chips on the same bus I create an instance of I cDevice for each chip Sometimes I experience that the trycatch around I CDeviceWrite logs exception and sometimes I can kill the whole panel I need to power cycle it So the question is the implementation of write method threadsafe or I have to ensure it manually Some devices are connected using Bluetooth Low Energy BLE This is supported in Xamarin for example on the diverse platforms Is there any plan to have similar support for NET Core It doesnt seem to be used anywhere and breaks Stylecop Ive just run Linux Release CI tests times in a row and out of runs failed with following failures x Fix pending SystemDeviceGpioTestsRaspberryPiDriverTestsInputPullResistorsWork FAIL AssertEqual Failure Expected Low Actual High Stack Trace srcSystemDeviceGpioTestsRaspberryPiDriverTestsLinuxcs at SystemDeviceGpioTestsRaspberryPiDriverTestsInputPullResistorsWork x SystemDeviceGpioTestsSysFsDriverTestsAddCallbackFallingEdgeNotDetectedTest FAIL AssertFalse Failure Expected False Actual True Stack Trace srcSystemDeviceGpioTestsGpioControllerTestBasecs at SystemDeviceGpioTestsGpioControllerTestBaseAddCallbackFallingEdgeNotDetectedTest cc pgrawehr joperezr We should try to understand the failures and if this is by design then retry or remove the test This might not actually be a bug but its something that we might need to discuss I was testing the framework and created the following scenario Have an app that deals with turning a light on and off Have another app that checks if a led is on and if so do something else Essentially we will have controllers that will use the same pin From my understanding controller should only work with a set of pins and it should not play around with pins used by another controller Steps to reproduce csharp using System using SystemDeviceGpio using SystemThreading namespace temp class Program static void Mainstring args GpioController controller new GpioController controller OpenPin PinModeOutput controller Write PinValueHigh ThreadSleep GpioController controller new GpioController controller OpenPin PinModeInput controller Read controller ClosePin controller ClosePin Expected behavior I would expect to be able to read the value and the pin keep the same state High meaning the led is on Actual behavior The LED turns on but when I read the value from it it reports as LOW and the LED turns off although it was expected to be HIGH If I try to simplify this might actually be another issue let me know if I should create another and do First app turns ON the LED and exits closes the pin and ends As soon as I close the Pin the LED turns off because the state is set to LOW why does this even happen Second app will always read low since the first app set it to LOW when closed the pin Versions used Add following information dotnet info on the machine being used to build NET Core SDK reflecting any globaljson Version Commit c f f Runtime Environment OS Name Windows OS Version OS Platform Windows RID win x Base Path C Program Files dotnet sdk Host useful for support Version Commit b e ae NET Core SDKs installed C Program Files dotnet sdk NET Core runtimes installed MicrosoftAspNetCoreAll C Program Files dotnet shared MicrosoftAspNetCoreAll MicrosoftAspNetCoreApp C Program Files dotnet shared MicrosoftAspNetCoreApp MicrosoftNETCoreApp C Program Files dotnet shared MicrosoftNETCoreApp dotnet info on the machine where app is being run not applicable for selfcontained apps It was not possible to find any installed NET Core SDKs Did you mean to run NET Core SDK commands Install a NET Core SDK from Host useful for support Version Commit d f NET Core SDKs installed No SDKs were found NET Core runtimes installed MicrosoftAspNetCoreApp homepidotnetsharedMicrosoftAspNetCoreApp MicrosoftNETCoreApp homepidotnetsharedMicrosoftNETCoreApp To install additional NET Core runtimes or SDKs Version of SystemDeviceGpio package Version SoftwarePwm implementation is currently failing on Windows The implementation is platform independent and when I tried it locally on Linux against it was passing all tests possibly they were flaky Ive tried maybe times On Windows the values on ADC input or PWM output after low pass filter were close to expected value but slightly outside of the expected range We should try to improve the implementation as much as possible I know at minimum room for improvement frequency is slightly lower than the set frequency ie setting freq to kHz actually produces around kHz possibly duty cycle is not exactly accurate we should verify how much off we are and if there is something we can do to improve As part of this work pwm should be reenabled on Windows or in simpler words following lines should be removed Note hardware PWM is currently not supported by default by Windows IoT Core on Raspberry PI its possible to do it with external libraries only DCMotor should have namespace which is different than the type name Having same name causes that in many scenarios its required to type DCMotorDCMotor in order to make sure the expression is nonambigious Perhaps DCMotor and Servo should be in the same namespace IotDeviceMotors By default SoftwarePwm does not use precision timer precise while loop which is causing that you cant exactly get reliably frequency that is fine for servo motors but not exactly for any other use Under oscilloscope Im getting around Hz shifts between Hz Hz with most time spent exactly on Hz by default even though it should be Hz We should consider removing this argument and automatically pick the right method based on the passed in frequency since for anything other than servo motor this is likely not satisfactory cc Ellerbach Describe the bug The variable at will never be in pressed state as the waitResultEventTypes does not returns the type of the current event but it returns the events were listening to so its value is a Flag value PinEventTypesRising PinEventTypesFailing see For starters is there a HOW TO PDF For anyone interesting in any button event keep this in mind pressing and releasing the button will fire both events some HW might behave weird like mine is able to fire one of the events twice if pressed in quick sequence but the touch sensor works as expected A clear and concise description of what the bug is Just a wrong output to console but its a misleading stuff for starters Steps to reproduce Just see the console output when pressingreleasing the button Expected behavior So while the current code does behave as expected and just the output is not correct expectations from some lines in the code are simply not fulfilleda proper way to check if button was just pressed can be achieved with a callback see code below csharp controllerRegisterCallbackForPinValueChangedEvent buttonPin inputEvents object sender PinValueChangedEventArgs pinValueChangedEventArgs DebugWriteLineDateTimeNowToStringyyyyMMdd HHmmssfff Btn event pinValueChangedEventArgsChangeType if pinValueChangedEventArgsChangeType PinEventTypesRising isOn isOn controllerWriteledPin isOn PinValueHigh PinValueLow Actual behavior Just wrong output and well bad expectations badly set pressedOrReleased variable Versions used Latest RPI B NET Core After upgrading SystemDeviceGpio and IotDeviceBindings from prerelease to I noticed my Ssd no longer resets the position correctly when attempting to use the SendMessage method like I was using before First call should just be the time with milliseconds but notice the odd leading character Second call should have again just been the time with milliseconds written over the first call but it was instead appended with an odd character prefix even though Column and Page addresses were set Looking closer at the supplied sample it appears the use of SendMessage has been commented out which leads me to the following questions Will this be resupported at some point My assumption is this was broken when Ssd support was added but I could be wrong I noticed DisplayClock uses SixLaborsFonts SixLaborsImageSharp packages to render with more than the basic font While Im not overly keen on using another package is this the approach I should use now to rendering text to the OLED It does enable more functionality more fonts graphics etc Btw I can run the full sample as is and get expected results but if I uncomment the SendMessage calls I get shifted results for the full demo images etc 