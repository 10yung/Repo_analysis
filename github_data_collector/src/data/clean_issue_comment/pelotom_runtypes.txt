 implements asReadonly which is awesome Would be great to have it mentioned in the README so the next dev doesnt miss it cc googol Cheers I have the following Runtype which I use as part of an ElasticSearch query typescript import Dictionary Lazy Literal Number Partial Record as RtRecord Runtype String Union from runtypes export interface ElasticSearchFieldMapping type boolean date double integer keyword text analyzer string fields Recordstring ElasticSearchFieldMapping ignoreabove number export const ElasticSearchFieldMapping RuntypeElasticSearchFieldMapping Lazy RtRecord type Union Literalboolean Literaldate Literaldouble Literalinteger Literalkeyword Literaltext AndPartial analyzer String fields DictionaryElasticSearchFieldMapping string ignoreabove Number When I use checkinput to throw an exception the code that tries to describe the expected input ends up in a stack overflow RangeError Maximum call stack size exceeded at Arraymap anonymous at optnodejsnodemodulesruntypeslibshowjs at Arraymap anonymous at optnodejsnodemodulesruntypeslibshowjs at optnodejsnodemodulesruntypeslibshowjs at optnodejsnodemodulesruntypeslibshowjs at Arraymap anonymous at optnodejsnodemodulesruntypeslibshowjs at Arraymap anonymous at optnodejsnodemodulesruntypeslibshowjs How can I describe the result of an async function For example ts const fetchSignIn t Contract Login Password best place for type declaration here we need possibility to describe runtype SignInResponse tInstanceOfPromise enforceasync login password const response await requestsignin login password inline check unreliably if we has a few result branches return SignInResponsecheckresponse The better way then RecordAndPartail I has an error but dont know why error I wanted to get your thoughts on a potential feature if its something that you are open to I would be more than happy to work on it Overview Add stringifyparse methods to Runtype These methods would work somewhat similar to JSONstringify using the replacer parameter and JSONparse using the reviver parameter to whitelist However the runtypes version of stringifyparse would recurse through the given Runtype and use that to whitelist which properties get serializeddeserialized Use Case Currently runtypes supports enforcing object structure aligns with type expectations This is incredibly useful when sendingreceiving data over the wire It would make runtypes more powerful if it could also be used to enforce that serializationdeserialization works as expected When using JSONstringify its very easy to accidentally include fields that should not be returned or were not even defined on the runtype If implementing an endpoint that sends an User object typescript import Record String from runtypes const User Record userName String displayName String async function getUserreq res next Promisevoid const rawUser await getUserFromDataBase const typedUser UsercheckrawUser resbodyJSONstringifymyUser DANGER DANGER could include property socialSecurityNumber This could be very dangerous if the object returned by getUserFromDataBase looked like this typescript userName maclockard displayName Mac socialSecurityNumber DANGER DANGER since JSONstringify would include the entire object and I would have thought I was safe given I checked it was a User using runtypes There are multiple different ways to solve this such as using the replacer parameter or explicitly constructing a new object everytime however these become increasingly unwieldy and error prone for complex large or deeply nested objects It also doesnt make sense to change check to throwing on unexpected fields since the object is still a valid User So instead I propose adding a stringify method to the Runtype itself that would handle this whitelisting automatically based on how it was defined Example typescript import Record String from runtypes const User Record userName String displayName String const rawUser userName maclockard displayName Mac socialSecurityNumber DANGER DANGER still preserves extraneous properties check as socialSecurityNumber const typedUser UsercheckrawUser creates a json string payload const stringUser UserstringifytypedUser userName maclockard displayName Mac This allows one to confidently send the user over the wire without needing to worry about extraneous properties An inverse parse method could also be made Comparison Cases typescript import Record String Number from runtypes const User Record userName String displayName String dog Record name String age Number const rawUser userName maclockard displayName Mac socialSecurityNumber DANGER DANGER age DANGER might be sensitive dog name pluto age JSONstringify const dangerUser JSONstringifyrawUser userName maclockard displayName Mac socialSecurityNumber DANGER DANGER age DANGER might be sensitive dog name pluto age const incorrectUser JSONstringifyrawUser userName displayName userName maclockard displayName Mac dog missing everything const dangerUser JSONstringifyrawUser userName displayName name age userName maclockard displayName Mac age DANGER might be sensitive dog name pluto age runtypes stringify const safeUser UserstringifyrawUser userName maclockard displayName Mac dog name pluto age Should Runtypes leverage TypeScript s new assertions feature The TLDR for this feature is that you can mark a function as an assertion meaning that it always throws unless a particular condition is true Its like an imperative type guard function Should we add an assert method to Runtype thats an alias for check but with an assertion void or throw signature as opposed to the checks return the static type signature For example ts current checkx any A possible in TS checkx any A assertx any asserts x is A current usage function foox unknown const y Stringcheckx return ytoUpperCase possible in TS function foox unknown Stringassertx return xtoUpperCase Looks like Tuples match for arrays with a length to the component length Shouldnt tuples need to match the length exactly See Also any reason not to have a Tuples of length and Since arrays dont have a constraint on length it seems like a Tuples is better for these cases 