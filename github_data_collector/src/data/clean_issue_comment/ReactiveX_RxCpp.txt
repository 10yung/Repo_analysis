I am curious about an optimization problem When a stream is not used directly will it be compressed to the next stream This problem comes from the following code observableMessagePtr getMessage return mclientChangedgetobservable scan observableMessage observableMessagePtr sendMessage stdpairClient bool client if clientsecond sendMessage sendMessagemerge clientfirstgetMessage else sendMessage sendMessagefilter MessagePtr message return messagegetMessage getTo clientfirstgetServer return sendMessage switchonnext I worry that this code will cause more and more nesting of merge and filter due to the increase of time causing performance problems I have the following code stdcout start stdendl stdvectoruint t in items auto obs rxcppobservableiteratein obswindow map rxcppobservableuint t w return wreduce stdvectoruint t auto v auto b vpushbackbreturn v auto v return v map auto v stdcout a vsize stdendl return stdvectorvbegin stdnextvbegin asdynamic merge subscribe auto v stdcout b vsize stdendl stdexceptionptr ep stdcout c rxcpprxuwhatep stdendl stdcout d stdendl stdcout end stdendl What I expected to see start a b a b d end What I do see is start a b a b a and then a segmentation fault on the stdnextvbegin part If I have an in of size though I see my expected result of start a b a b a b d end hello im a little new to cpp and rxCpp community i was wondering if i could perform operators on a dynamic number of observables it seems that these operators only accept Variadic arguments which i couldnt work dynamically with to elaborate my problem with an example how to merge a stdlist of observables Thanks in advance Hello Is there currently a way to be notified of an unsubscribe call For my use case I am connecting to a websocket and using rxcpp to stream incoming messages to subscribers What I would like to achieve is disconnecting the websocket when there are no longer any subscribers I would like this to happen whenever the last subscriber calls unsubscribe as opposed to waiting for the next message to arrive and checking if there are any more subscribers at that point Is this possible with RxCpp pseudocode to illustrate what I am trying to do cpp rxcppobservablecreatemessage const rxcppsubscribermessage s websocketonMessage const message message sonnextmessage return unsubscribe callback return close websocket if there are no longer any subscribers websocketclose Is this behavior intentional Calling stdthreaddetach in the newworker constructor will always throw stdsystemerror if keepAliveworkerjoinable keepAliveworkergetid stdthisthreadgetid guardunlock keepAliveworkerjoin else keepAliveworkerdetach always throws systemerror The above detach could get executed when joinable returns false but according to if joinable returns false then systemerror is always thrown Should lines be changed to add an if joinable else if keepAliveworkerjoinable keepAliveworkerdetach Im used to RxJS and loved the concept so I wanted to use it in C as well Seeing I thought this would be a good opportunity for me to get a little deeper into understanding the implementation of RxCpp This is mostly a copy paste of the debounce operator implementation edited to implement throttle semantics ref RxJS The throttle operator reemits the first value emitted by the source then swallows all following emissions until the specified timeout has occurred After that the next value emitted by the source is emitted again and the cycle continues The RxJS implementation also supports emitting the last value emitted by the source when the timeout completes If this is a feature you would like to see I can add support for that as well This is a possible fix for the issue based on my own explanations and suggestions I encountered a strange behavior when using a behavior subject no pun intended D to spread a state change Sometimes the subscriber wont get a state change by an onnext call although you get the value from before the call when you subscribe This then results in heavilly unwanted behavior because in my example you could endlessly wait for a state change to a certain value which you should always get by concept I tracked this down and came to the understanding that this can happen due to the implementation of behaviorgetobservable in rxbehaviorhpp observableT getobservable const auto keepAlive s return makeobservabledynamicT subscriberT o if keepAlivegetsubscriptionissubscribed oonnextgetvalue keepAliveaddsgetsubscriber stdmoveo after getvalue is called there is a gap until the subscriber is properly added where the state of the behaviorobserver could be updated by a parallel occuring onnext The new subscriber o then wont get the new value A quick fix that works for me and stays local would be that you change the mutex of the behaviorobserverstate into a recursive mutex and then make it properly accessible and lock it in the lamba function above see the following pseudo sample implementation class behaviorobserver public detailmulticastobserverT class behaviorobserverstate mutable stdrecursivemutex lock public stdrecursivemutex mutex const return lock public stdrecursivemutex mutex const return statemutex class behavior public observableT getobservable const auto keepAlive s return makeobservabledynamicT subscriberT o stdlockguardstdrecursivemutex guardkeepAlivemutex if keepAlivegetsubscriptionissubscribed oonnextgetvalue keepAliveaddsgetsubscriber stdmoveo But maybe some of you have a better solution for this If desired i can provide a little test example that can reproduce the problem Some side questions while having a deeper look into the implementations in rxbehaviorhpp Why using uniquelock instead of lockguard in behaviorobserverstate Isnt lockguard for this case to prefer in general because uniquelock is the complexer object even though it may be optimized away that it wouldnt matter but this is not ensured in the current implemantation of behaviorgetobservable the keepAlive object seems to be unnecessary redundant and this code would also do the trick or am i missing something compare with the first code section observableT getobservable const return makeobservabledynamicT subscriberT o if sgetsubscriptionissubscribed oonnextgetvalue saddsgetsubscriber stdmoveo BR Paul Hi Im trying to integrate rxcpp into libuv utilizing its timers thread pool etc through the rxcpp constructs Im currently trying to make a scheduler which delegates the scheduling over to libuv As part of this I guess I need to implement different versions of logic for either timer operations and interval operations How would you recommend me to go about that Im kind of new to the library and still struggling to grasp these concepts and their relations Thank you Hi I know issues is not the best place for asking any technical doubts But in this matter Ive searched everywhere e tried lots of approaches to solve my problem that is I am writing a custom operator to serialize Protobuf messages to json The Protobufs API has a helper method to do that and it uses inheritance polymorphism to do so cpp stdfunctionobservableprotobufMessageobservablestdstring prototojson googleprotobufutilJsonOptions opt optalwaysprintprimitivefields true stdstring jstr googleprotobufutilMessageToJsonStringreferee jstr opt return jstr Im used to sharedptr but this was my first attempt to just test the functionality Sounds like a good place to start But when I attempt to compile an error issuing the type of my function raises I have the following code in my main function cpp int main Constructing an object to receive datagrams in the groupip port and buffermaxsize MulticastReceiver mr auto refstream mrdatagram a stdstring observable with received datagram ok parsereferee parses string to a shraedptrSSLReferee proto message ok prototojson compile error I omitted the rest of the code for brevity I also tried using a different approach with runtime polymorphism writing a type jsonserializablet to encapsulate the method tojson and also a static method tojsoncont T then I write my own implementation of tojson with a const reference to SSLReferee cpp templatetypename T stdstring tojsonconst T x class jsonserializablet public templatetypename T jsonserializabletT x selfstdmakesharedmodelTstdmovex friend stdstring tojsonconst jsonserializablet x return xselftojson private struct conceptt virtual conceptt default virtual stdstring tojson const templatetypename T struct model final conceptt modelT x datastdmovex stdstring tojson const override return tojsondata T data sptrconst conceptt self And then cpp stdstring tojsonconst SSLReferee referee googleprotobufutilJsonOptions opt optalwaysprintprimitivefields true stdstring jstr googleprotobufutilMessageToJsonStringreferee jstr opt return jstr stdfunctionobservablestdstringstdsharedptrjsonserializablet serializetojson return observablestdsharedptrjsonserializablet object return object operatorsmap stdsharedptrjsonserializablet object return tojsonobject Any of those approaches give me the following error with different signatures maincc error no match for operator operand types are rxcppobservablestdsharedptrSSLReferee rxcppdynamicobservablestdsharedptrSSLReferee and stdfunctionrxcppobservablestdcxx basicstringchar rxcppobservablestdsharedptrfurgbolmodelsjsonserializablet observablesptrSSLReferee referee refmrdatagram parsereferee serializetojson Then am stuck at this for like two weeks and still didnt find any helpful material to help me with that although Ive learned a lot of other things on the way whats a very good thing The only thing that I didnt tried yet was writing something to use with the lift operator which I cant find much about but saw an example that looked like could implement what Im trying Well I apologize for any spelling errors and atrocities with the C usage although its one of my favorite languages and I am really engaged into learning everything as possible Also its the first time Im writing anything on the web even to ask something in a large community like that Am I giving to little information Or already know the answer asking in the wrong place But anything will help even if it is to learn to behave in the community smiley Thank you for your time 