This pull request is for parsing generics in the library macro I tried to limit the scope but it turned out a bit more comprehensive than anticipated There are still some rough corners here and there and there are no logic that deals with trait resolution so the output from the compiler is incorrect when dealing with generics I also have yet to support parsing of associated types in traits Other than that I think the parsing works as intended There are cases where type inference is impossible even when fully qualified paths to every methodfunction is given In those cases the macro author need to specify the type Consider this function Rust fn cmpstr bool let v stdstrFromStrfromstrstr let v stdresultResultunwrapv let v stdstringToStringtostringstr let v stdcmpPartialEqeq v v v In this case it cant infer the type of v since it cant know what the Self type of FromStr is This instance could be fixed if we allowed specifying the Self type We could then change the first line to Rust let v stdstringString as stdstrFromStrfromstrstr A separate issue can arise if we invoke a trait function with generic parameters and one of the parameters needs to be specified Im not sure what would be a good interface to deal with this issue We might generate INVOKEWITHSELF where the first parameter is a Type or RuntimeType parameter and the rest works like regular INVOKE We might alternatively have a setself function that deals with this that can be used after a normal INVOKE Unfortunately this only deals with the Self issue and not generics in general Any suggestions here would be helpful Before introducing a threadlocal WipFunction in the only way for us to attach literals into the right WipFunction was by constructing them through methods of MakeFunction as in funit and fstring Now that we have a threadlocal way to track what goes where these literal constructors would make more sense as plain functions rather than methods of MakeFunction reflectunit and reflectstring Currently the library macro does not support cross referencing types and traits It would be nice to be able to do something like this Rust library extern crate Crate mod Mod type Type fn funsuperMod mod Mod type Type fn funCrateMod fn dynamic dyn crateTrait trait Trait This is a build script that finds libcore stdlib sources and produces outrs with libcore definitions as library macro Mostly broken due to unsupported generic and Self parameters in arguments or return type position See outrs file in this PR as an example of the output dtolnay this is just for you to see my approach and to verify whether its feasible to continue or not Suppose we have rust reflectlibrary extern crate demo trait Demo fn f self trait SomeTrait fn dynamicdispatch dyn SomeTrait fn staticdispatchT SomeTrait T and our users deriveDemo macro is being invoked on rust deriveDemo struct ST field T Then if they do rust let field receivergetfieldfield RUNTIMEdemodynamicdispatchINVOKEfield OR RUNTIMEdemostaticdispatchINVOKEfield then reflect needs to identify that these INVOKEs require a trait bound and emit the right bound on the impl we generate rust implT demoDemo for ST where T demoSomeTrait inferred fn f self demodynamicdispatch selffield The reflectlibrary macro currently only accepts functions as trait functions or associated functions Well also need to work with free functions like strfromutf that are not part of a trait or impl block rust reflectlibrary extern crate std mod str fn fromutf u Result str Utf Error rust let result RUNTIMEstdstrfromutf INVOKEbytes The user shouldnt have to write out their own reflectlibrary description of extern crate std A complete definition of everything in std should be built in to the reflect crate because practically all users will need it We still need to keep reflectlibrary so that users can provide definitions of crates other than std for example if serdederive were implemented using reflect then it would need to contain a reflectlibrary providing all the relevant signatures from the serde crate The current IR based on WipFunction for functions and ValueRef ValueNode for values just barely works for simple macros but is probably not going to be pleasant to work with internally as the compiler gets more interesting Basically the entire current implementation in the src directory is just supposed to be a proof of concept that we can stack enough RefCells on top of each other to get something reasonably convenient from the users perspective smilingimp I am open to completely replacing it as needed This part of the current generated code would be better expressed as a match which would be able to work equally well against enums later rust let v v x let v v y rust match v Point x v y v 