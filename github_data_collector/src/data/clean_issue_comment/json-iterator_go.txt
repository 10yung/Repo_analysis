 easy for custom iterReadMapCB we need to use NextToken to check is there more token for example we check token to know the end ChangeId Ia df f bf b fe I believe that WriteMore should not call Flush for these reasons This is surprising for users because of inconsistency Why call Flush in WriteMore and not in WriteObjectEnd It is not necessary callers are free to call Flush if their use case demands it It harms performance in the common case by flushing the buffer much more frequently than it needs to be flushed The stream benchmark shows a benefit to removing the Flush call and I observed a similar speedup in my realworld use case benchmark old nsop new nsop delta BenchmarkencodestringwithSetEscapeHTML Benchmarkjsoniterlargefile Benchmarkjsonlargefile Benchmarkstreamencodebigobject benchmark old allocs new allocs delta BenchmarkencodestringwithSetEscapeHTML Benchmarkjsoniterlargefile Benchmarkjsonlargefile Benchmarkstreamencodebigobject benchmark old bytes new bytes delta BenchmarkencodestringwithSetEscapeHTML Benchmarkjsoniterlargefile Benchmarkjsonlargefile Benchmarkstreamencodebigobject Backwards compatibility I believe there is little to no risk that this breaks callers WriteMore does not leave the JSON in a valid state so it must be followed by other Write methods To get the finished JSON out the caller must already be calling Flush Speeds up the example Stream usage in the benchmark by StreamFlush copies the contents of the streams buffer to the output but instead of resetting its buffer to reuse the allocation it keeps appending to the end of the buffer For large JSON objects this results in much more allocation than necessary go Flush writes any buffered data to the underlying ioWriter func stream Stream Flush error if streamout nil return nil if streamError nil return streamError n err streamoutWritestreambuf if err nil if streamError nil streamError err return err streambuf streambuf n HERE return nil I think the marked line above should instead be go streambuf streambuf Am I missing something Add unit test for iteratorReadAny function Now the bufSize is bytesmakeSlice will happen when the json size is larger than bufSize If most of my json are larger than I want to set it to a larger size lets say to avoid alloc space Could you support this feature jsoniterator Stream buf M K buf M gc stream pool QPS K K QPS M M string M Reset buf JSON standard does not allow NaN or Infinity but some applications produce output that contains such values One example of such application would be TensorFlow Serving An example of JSON parser that accepts NaN and Infinity is the one that comes with Python This commit introduces a new configuration parameter AllowNaN that enables jsoniter to unmarshal input containing NaN and Infinity If a structs type is anonymous the decoder should not return an error message with its definition when it meets an error