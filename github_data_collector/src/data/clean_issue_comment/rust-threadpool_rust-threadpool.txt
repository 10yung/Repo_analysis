This can be considered an RFC patch to gauge interestacceptance This adds a queuelen option to the builder This will limit the number of concurrent pending jobs that can be queued attempts to queue a job when the queue is full will block until a slot becomes free The main purpose of this feature is to allow backpressure in the case where pending jobs use up limited resources memory filehandles etc In order to do this this in the simplest manner Ive moved the pool to use crossbeamchannel which has a dropin bounded channel implementation There is a probably a strong case for also providing a tryexecute function that will return an error or false if the queue is full but Ive skipped that until this feature has been discussed This is a first draft for where I tried to incooperate my thoughts on several of the open issues I would like to get some feed back over the next week Eg no opinion or overloaded or looks good or anything else Maybe some of the functionality should reside outside of this crate like the detection of pinning Cheers Stefan ping frewsxcv It would be great to provide a mechanism to terminate all pending tasks and wait for the current one to complete Essentially complete the current executing jobs since Im not sure its possible to terminate spawned threads And then dont proceed doing any more work At the moment this is not possible I am trying to create a threadpool as static So that I dont have to pass this variable across multiple functions lazystatic pub static ref TABLESLOADPOOL ThreadPool setupthreadpool fn setupthreadpool ThreadPool let threadpool ThreadPool threadpoolBuildernew numthreads threadnameTableLoadinto build threadpool I get the following error stdsyncmpscSenderstdboxedBoxdyn threadpoolFnBox stdmarkerSend static cannot be shared between threads safely rustthreadpool use channel for receiving jobs that means if the number of jobs is very large it will consume lots of memory So Id like to know if it is a good idea or not to use syncchannel instead of sync I googled and found a post that address this issue and a commit that replace channel with syncchannel Not sure why the author hadnt submitted a PR Hi I was looking for a thread pool and found this repo Thanks for working on this I was browsing the dependencies and saw that you use numcpus to decide how many worker threads to use by default rust let numthreads selfnumthreadsunwraporelsenumcpusget Would it not be better to look into the affinity mask to get this default The system may have cores but have the process pinned to eg cores This would cause contention I found this crate which might help disclaimer Ive not used it and Im not sure how portable it is Thanks add struct ThreadPoolBuilder add ThreadPoolBuilder fn new uses numcpu crate to default num of threads to num of cpus remove ThreadPool fn newnumthreads usize ThreadPool add ThreadPool fn new ThreadPool uses numcpu to default num of threads to num of cpus add ThreadPoolBuilder fn numthreadsself num usize ThreadPoolBuilder set the number of threads for the pool that the builder will construct remove ThreadPool fn withnamename String numthreads usize ThreadPool add ThreadPoolBuilder fn nameself name String ThreadPoolBuilder add ThreadPoolBuilder fn stacksizeself size usize ThreadPoolBuilder In summary remove all constructors off of ThreadPool except a new new constructor If you want to finetune your threadpool youd use a ThreadPoolBuilder I wonder if it would be useful to have a scoped function similar to the scopedthreadpool crate Advantages could come from the design Like dedicate only a certain part of the pool to the scoped work add the scoped jobs in random order but join the whole pool at the end of the scoped function add the scoped jobs in random order but join only the scoped jobs One could also state that the resources would be wasted since such a crate already exists Maybe something that searches for all jpeg in a directory starts a thread pool and in each thread converts them to png