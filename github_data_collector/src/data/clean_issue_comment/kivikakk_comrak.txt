When I have the urge to format a Markdown table I generally have one of two outcomes in mind optimize for storage optimize for readability Currently comrak defaults to optimizing for storage That is a table input with extra spaces or dashes loses in output any unnecessary spaces or dashes in cells Id like to see an option to optimize for readability That is a table input will have its cells padded with spaces or dashes to fit the longest cell in that column Example input h h h data data wide cell data data data data longerdata data data Comrack output optimized for storage h h h data data wide cell data data data data longerdata data data Output optimized for text readability by markdowntablecom src h h h data data wide cell data data data data longerdata data data This latter format is better for static files like READMEs that are just as often read in text format as they are consumed in HTML format and other places where editing the table is more important than reducing the byte size of the table time python c print a targetreleasecomrak devnull real m s user m s sys m s time python c print a targetreleasecomrak devnull real m s user m s sys m s time python c print a targetreleasecomrak devnull real m s user m s sys m s time python c print targetreleasecomrak devnull real m s user m s sys m s time python c print targetreleasecomrak devnull real m s user m s sys m s time python c print targetreleasecomrak devnull real m s user m s sys m s time python c print a u n targetreleasecomrak devnull real m s user m s sys m s time python c print a u n targetreleasecomrak devnull real m s user m s sys m s time python c print a u n targetreleasecomrak devnull real m s user m s sys m s time python c print t u targetreleasecomrak devnull real m s user m s sys m s time python c print t u targetreleasecomrak devnull real m s user m s sys m s time python c print t u targetreleasecomrak devnull real m s user m s sys m s console python c print time comrak devnull user system elapsed CPU avgtext avgdata maxresidentk inputs outputs major minorpagefaults swaps python c print time comrak devnull user system elapsed CPU avgtext avgdata maxresidentk inputs outputs major minorpagefaults swaps python c print time comrak devnull user system elapsed CPU avgtext avgdata maxresidentk inputs outputs major minorpagefaults swaps python c print time comrak devnull user system elapsed CPU avgtext avgdata maxresidentk inputs outputs major minorpagefaults swaps From the title you can probably tell that this is related to The documentation for extfootnotes has this example rust let options ComrakOptions extfootnotes true ComrakOptionsdefault asserteqmarkdowntohtmlHi x n n x A greeting n options pHisup class footnoteref a href fn id fnref asupp nsection class footnotes nol nli id fn npA greeting a href fnref class footnotebackref ap nli nol nsection n However this does not work when you also have extsuperscript enabled rust use comrak fn main let options ComrakOptions extsuperscript true extfootnotes true ComrakOptionsdefault asserteqmarkdowntohtmlHi x n n x A greeting n options pHisup class footnoteref a href fn id fnref asupp nsection class footnotes nol nli id fn npA greeting a href fnref class footnotebackref ap nli nol nsection n Instead of the expected string you just get pHi x p n Rust typically protects you from iterator invalidation by not allowing you to modify a collection while you are iterating over it When you use constructs like RefCell the Rust compiler wont complain but these checks are still performed when the program is running I found out the hard way today that there is a case where you can cause an iterator over nodes to become invalidated and instead of panicking it will fail silently and just stop iterating In Rust pseudocode heres what I was doing rust let root comrakparsedocument for node in roottraverse if wanttomodifynodenode continue for child in nodechildren if wanttomodifychildnode child continue childdetach By detaching the child during traverse I inadvertantly invalidated the iterator This didnt result in any memory unsafety Instead the iterator just never continues past the node whose child I detached This wasnt immediately obvious to me because I assumed that since I was deleting a child the original node could still be iterated further Furthermore the only reason I figured this out is probably because I am quite experienced in other languages where iterator invalidation is an issue I imagine a newer programmer might not have come to the same conclusion If it isnt possible to panic in these situations with a helpful error message we should at least add some documentation to all of the iterator methods that can be invalided by a detach An even better solution would be to make it so you can detach and still continue traversing the rest of the tree Im specifically asking to be able to detach a node that hasnt been traversed yet I dont expect detaching a parent during traverse to ever work A workaround for this as with any case of iterator invalidation is to store the nodes you want to detach and detach them all at once after youre done traversing Comrak contains code that turns header text into IDs that are ostensibly compatible with the IDs that GitHub creates Id like to be able to use that code without generating HTML Ive written a proofofconcept PR to do this My desire for this functionality is due to having written a tiny program that looks for broken internal links in Markdown files It currently only looks to see that the local files referenced in links are present but Im adding additional functionality One of the first things Im adding is the ability to verify that if a location contains a fragment then the target file contains markdown that will cause the corresponding anchor to be created So if comrak exposes this functionality Ill use it and also contribute PRs to increase compatibility For example the current comrak code appears to let periods and question marks pass from headers into anchors whereas GitHubs special sauce appears not to I realize that any additional functionality exposed also increases maintenance so I fully understand why you might not want to do this but I figure its worth asking especially since a single implementation is probably better for the community than parallel similarbutslightlydifferent implementations is valid in URLS but as a postprocessing pass strings that should probably get autolinked end up superscripted mangling the link run through comrak with e autolink e superscript comes out as pa href The link gets chopped off to become superscript text There may be other syntax that interacts similarlywierdly with the autolinker I dont have any ideas for how to fix this beyond integrating the autolinker into the inline parser FWIW snudown miraculously autolinks that URL as one might expect