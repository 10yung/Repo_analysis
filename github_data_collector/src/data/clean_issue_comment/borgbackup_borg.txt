 Thank you for reporting an issue IMPORTANT before creating a new issue please look around Borgbackup documentation FAQ and open issues in Github tracker If you cannot find a similar problem then create a new issue Please fill in as much of the template as possible Have you checked borgbackup docs FAQ and open Github issues Yes Is this a BUG ISSUE report or a QUESTION QUESTION System information For clientserver mode post info for both machines Your borg version borg V borg Question I have a client that backups to a remote location server in append only mode borg serve is run with append only flag This means prunes do not actually free disk space everything is fine Now on the server I can access that repository too and see the transaction log How can I apply the transaction log so files are actually deleted disk space is freed etc Is there a command for this Something like everything what the client requested in append only mode is fine lets commit it now Have you checked borgbackup docs FAQ and open Github issues Yes Is this a BUG ISSUE report or a QUESTION BUG System information For clientserver mode post info for both machines Your borg version borg V Operating system distribution and version Raspbian Hardware network configuration and filesystems used raspberry pi How much data is handled by borg lots Full borg commandline that lead to the problem leave away excludes and passwords borg prune v list stats dryrun keeplast keepdaily keepweekly keepyearly sshpi mediapiRaidDriveBorgoctoPi Describe the problem youre observing Message usage borg h V command borg error unrecognized arguments keeplast Can you reproduce the problem If so describe how If not describe troubleshooting steps you took before opening the issue Yes I can reproduce the problem with keeplast keepsecondly and keepminutely It begins to work with keephourly The same command launched locally on the server borg prune v list stats dryrun keeplast keepdaily keepweekly keepyearly mediapiRaidDriveBorgoctoPi works The server and the client have the same borg version Include any warningerrorsbacktraces from the system logs None Thank you for reporting an issue IMPORTANT before creating a new issue please look around Borgbackup documentation FAQ and open issues in Github tracker If you cannot find a similar problem then create a new issue Please fill in as much of the template as possible Have you checked borgbackup docs FAQ and open Github issues Yes And I discussed it in borgbackuppythonorg ldquoIsnt locking broken because stale lock removal doesnt comply with the locking protocol rdquo with the confirmation that the issue most probably exists Is this a BUG nbsp ISSUE report or a QUESTION BUG I did not yet observe any event resulting from it and I dont know if anybody did However the risk of repository damage definitely exists Furthermore the requirement for the filesystem on which the repository residessupa namecite usercontentfootnote sup mkdir should be atomic since it is used for locking is useless because of this bug System information For clientserver mode post info for both machines The bug is basical and affects all platforms and file systems However what I observed in order to confirm it is how the implementation deals with the file system in order to acquire and to release a lock and to kill stale locks The information below relates to these observations Your borg version borg V and nbsp Operating system distribution and version Linux nbsp generic Ubuntu nbsp nbspLTS Hardware nbsp network configuration and file systems used ext mounted rwrelatime tmpfs mounted rwnosuidnodevrelatime How much data is handled by borg empty and almost empty repository Full borg commandline that lead to the problem leave away excludes and passwords The exact commandline doesnt matter I tried the commands borg list and borg mount as processes creating a shared lock and borg withlock and borg create as processes creating an exclusive lock See also Can you reproduce the problem nbsp hellip reproduce Describe the problem youre observing The removal of stale locks violates the locking procedure as described in the documentationsupa namecite usercontentfootnote sup supa namecite usercontentfootnote sup If the process can create the lockexclusive directory for a resource it has the lock for it If creation fails because the directory has already been created by some other process lock acquisition fails Lets assume two concurrent borg processes A and B A gets the lock B sees the lockexclusive directory thinking it be stale removes it and recreates it now thinking it owns the lock too Apparently in order to prevent this situation Inside the lock directory there is a file indicating hostname process id and thread id of the lock holder So it seems that another process would be able to reliably check whether the process which holds the lock is alive or dead But this is not the case because creating the lockexclusive directory and creating this process identifier is not an atomic operation There is still a chance that a concurrent process sees an empty hence an apparently stale directory ie after directory creation and before process identifier creation So the requirement of atomicity of mkdir I would call it consistency what is needed here is useless mdasheven when the lock initially doesnt exist a namereproduceCan you reproduce the problem If so describe how If not describe troubleshooting steps you took before opening the issue The bug can be seen like this for example export BORGHOSTIDhostname borg init e none testrepo mkdir testrepolockexclusive touch testrepolockexclusiveBORGHOSTID strace e tracefile f o borglog borg list testrepo Killed stale lock hostname A stale lock same host id nonexistent process id is created in a repository Then borg list is called wrapped by a strace command In the strace output borglog one finds the following system calls dealing with file system IO stathomeusertestrepo stmodeSIFDIR stsize mkdirhomeusertestrepolockexclusive EEXIST File exists stathomeusertestrepolockexclusivehostname x ffdab fc ENOENT No such file or directory openatATFDCWD homeusertestrepolockexclusive ORDONLYONONBLOCKOCLOEXECODIRECTORY unlinkhomeusertestrepolockexclusivehostname rmdirhomeusertestrepolockexclusive mkdirhomeusertestrepolockexclusive openatATFDCWD homeusertestrepolockexclusivehostname OWRONLYOCREATOTRUNCOCLOEXEC In line nbsp borg tries to create the lockexclusive directory mdashunsuccessfully because the lockexclusive directory already exists Then borg looks if its own process identifier is in the directory I dont know why However the stale lock removal can be observed in lines ndash The directory is read and the stale process identifier is found line nbsp After having checked that there is no process nbsp the process identifier is deleted in line nbsp It is finished with the removal of the lockexclusive directory in line nbsp In line nbsp the lock acquisition is tried again mdashthis time successfully After that the own process identifier is created This confirms the documented and assumed logic Now if a concurrent process would make its lock acquisition between line nbsp and nbsp or between line nbsp and nbsp both processes would think they have the lock Suggested approach ldquorenaming strategy rdquo In order to eliminate that chance and to make the lock acquisition a safe operation as a whole one can create a randomly named temporary directory within the repo directory then create the process identifier within this temporary directory this is not atomic but isolated and without any race condition and then rename the temporary directory to ldquolockexclusive rdquo The locking protocol has to be changed to this renaming being successful The stale lock removal procedure can then remain as it is and it can be applied when the lock acquisition fails as already implemented Requirements For this strategy in order to work it is required that the renaming of a directory to ldquolockexclusive rdquo is only successful if ldquolockexclusive rdquo did not exist before or was empty So if multiple concurrent processes call this at a time only that call may be signaled success whose source directory becomes the destination directory and all the other consistencies are required which are taken as granted such as that the inode of the directory and its contents dont change during the renaming This is the requirement which replaces the requirement usercontentfootnote The atomicity of the renaming operation such as described in renamesupa namecite usercontentfootnote sup of Unixlike platforms is not required If the lockexclusive directory existed before but was empty we have no problem with any time gap during which ldquolockexclusive rdquo does not exist Which Python function can be used With regard to almost POSIX compliant operating systems the system call rename is the candidate of choice It will only succeed if the name did not exist before or was an empty directory With regard to Windows the system call MoveFilesupa namecite usercontentfootnote sup or MoveFileX is the candidate of choice It will only succeed if the name did not exist before As far as I can see the Python function osrenamesrc dst srcdirfdNone dstdirfdNonesupa namecite usercontentfootnote sup is the one which has to be used for the renaming strategy because it uses rename on Unix like platforms and MoveFileX on Windows And what is even more important Its behaviour is specified exactly as stated here Comparison Is renaming a directory as consistent as creation of a directory concerning the OS system calls or could the situation get worse by changing the locking strategy to renaming I tried to prepare a comparison beyond the specification level ie looking at real implementations but I couldnt sorry I looked at the glibc source code where the rename method is implemented together with a colleage As soon as I find crucial details I will catch up with it here However the situation cannot be made worse in effect by replacing the current strategy with the renaming strategy because the current strategy is not safe already But it would be a waste of time if the change wouldnt be an improvement So we have to require that osrenamesrc dst srcdirfdNone dstdirfdNone works as specified to the same extent as directory creation since this is what the bug will fix Can we rely on that mdashNo of course not There is no way of guaranteeing that already because of the big number of the supporting platforms But we should rely on that Reasons The two functions mkdir and rename are part of the same API on Windows its the same situation do similar things and use the same functionality themselves eg link nbsp unlink on Unix like systems so we can expect them to be treated with the same attention This API is very very old and mature A colleague sent the Win hlp file Footnote nbsp usercontentfootnote shows a screenshot of a page of it to me which is a documentation of the Windows system calls The file is a quarter of a century old Concerning our question it didnt change since then I found a man page of rename basically saying the same as the current one written in the last millenium This API stems from the seventies The oldfashioned way of implementing a lock file protocol or similar things by this writereplace nbsp rename technique which makes use of the atomicity nbsp consistency of one or the other function is a common and wellknown patternsupa namecite usercontentfootnote sup Prominent applications rely on itsupa namecite usercontentfootnote sup It would be considered a very serious bug if one could delete a nonempty directory by mkdir or rename It would be a bug of the operating system At the moment it is Borg which has the bug Some remarks about network file systems To be added hellip x f Peace and long life a namefootnote sup sup uarr usercontentcite ensp a namefootnote sup sup uarr usercontentcite enspI will call it ldquolocking protocol rdquo here because it is a protocol irrespective of whether it is intended to be a public protocol or not a namefootnote sup sup uarr usercontentcite ensp a namefootnote sup sup uarr usercontentcite enspfor example see a namefootnote sup sup uarr usercontentcite ensp MoveFile a namefootnote sup sup uarr usercontentcite ensp a namefootnote sup sup uarr usercontentcite enspfor example see or or a namefootnote sup sup uarr usercontentcite enspI remember that I learned this technique from qmail Have you checked borgbackup docs FAQ and open Github issues Yes Is this a BUG ISSUE report or a QUESTION Probably a bug System information For clientserver mode post info for both machines Your borg version borg V repository was initially create with version Operating system distribution and version Debian stretch Hardware network configuration and filesystems used Local directory on ZFS Hardware is a crummy multislot USB disk enclosure but ZFS shows IO errors on the pool How much data is handled by borg to TiB Describe the problem youre observing Backstory I have a repository which was originally created using Borg and most data in the repository has been inserted using that version Then for some reason the chunk index was lost when running borg create it started rebuilding it Knowing that Im using an older version and that this might be an issue which has already been solved I upgraded to version from the official Debian repository stretchbackports and let it run again and rebuild the chunk index All output shown below are from version Now the repository is in a state where borg create fails with No such file or directory srvbackupapuborgdata see full log below This is the full output of the first time the error appeared It beging by finishing rebuilding the chunk index and then terminated with the error jan apu borgbackupsh Creating archive at srvbackupapuborgnowYmdHMS jan apu borgbackupsh Synchronizing chunks cache jan apu borgbackupsh Archives w cached Idx w outdated Idx wo cached Idx jan apu borgbackupsh Reading cached archive chunk index for jan apu borgbackupsh Merging into master chunks index jan apu borgbackupsh Fetching and building archive index for jan apu borgbackupsh Merging into master chunks index jan apu borgbackupsh Fetching and building archive index for jan apu borgbackupsh Merging into master chunks index jan apu borgbackupsh Reading cached archive chunk index for jan apu borgbackupsh Merging into master chunks index jan apu borgbackupsh Fetching and building archive index for jan apu borgbackupsh Merging into master chunks index jan apu borgbackupsh Done jan apu borgbackupsh Local Exception jan apu borgbackupsh Traceback most recent call last jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in main jan apu borgbackupsh exitcode archiverrunargs jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in run jan apu borgbackupsh return setecfuncargs jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in wrapper jan apu borgbackupsh return methodself args repositoryrepository kwargs jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in docreate jan apu borgbackupsh createinnerarchive cache jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in createinner jan apu borgbackupsh readspecialargsreadspecial dryrundryrun stst jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh readspecialreadspecial dryrundryrun jan apu borgbackupsh File usrlibpython distpackagesborgarchiverpy line in process jan apu borgbackupsh status archiveprocessfilepath st cache jan apu borgbackupsh File usrlibpython distpackagesborgarchivepy line in processfile jan apu borgbackupsh selfchunkfileitem cache selfstats backupioiterselfchunkerchunkifyfd fh jan apu borgbackupsh File usrlibpython distpackagesborgarchivepy line in chunkfile jan apu borgbackupsh itemchunksappendchunkprocessordata jan apu borgbackupsh File usrlibpython distpackagesborgarchivepy line in chunkprocessor jan apu borgbackupsh chunkentry cacheaddchunkselfkeyidhashdata data stats waitFalse jan apu borgbackupsh File usrlibpython distpackagesborgcachepy line in addchunk jan apu borgbackupsh selfrepositoryputid data waitwait jan apu borgbackupsh File usrlibpython distpackagesborgrepositorypy line in put jan apu borgbackupsh selfpreparetxnselfgettransactionid jan apu borgbackupsh File usrlibpython distpackagesborgrepositorypy line in preparetxn jan apu borgbackupsh selfrebuildsparsesegment jan apu borgbackupsh File usrlibpython distpackagesborgrepositorypy line in rebuildsparse jan apu borgbackupsh selfcompact segment selfiosegmentsizesegment jan apu borgbackupsh File usrlibpython distpackagesborgrepositorypy line in segmentsize jan apu borgbackupsh return ospathgetsizeselfsegmentfilenamesegment jan apu borgbackupsh File usrlibpython genericpathpy line in getsize jan apu borgbackupsh return osstatfilenamestsize jan apu borgbackupsh FileNotFoundError Errno No such file or directory srvbackupapuborgdata jan apu borgbackupsh Platform Linux apu amd SMP Debian deb u x jan apu borgbackupsh Linux debian jan apu borgbackupsh Borg Python CPython jan apu borgbackupsh PID CWD jan apu borgbackupsh sysargv usrbinborg create verbose stats exclude proc exclude sys exclude dev exclude tmp exclude run exclude mnt exclude media exclude varswap exclude varlibdocker exclude srvbackup exclude rootcache exclude homecache exclude homemic hitransmission srvbackupapuborgnowYmdHMS jan apu borgbackupsh SSHORIGINALCOMMAND None The missing file does indeed not exists ls d srvbackupapuborgdata ls cannot access srvbackupapuborgdata No such file or directory But I have hourly snapshots of the filesystem containing the repository and the file did exist at some point in the past but was somehow deleted I assume by Borg itself So I can easily restore this specific file rootapu ls srvbackupzfssnapshotapuborgdata srvbackupzfssnapshotsnappy apuborgdata srvbackupzfssnapshotsnappy apuborgdata To find out whether more files have gone missing I ran borg check without first restoring the missing file But to my surprise it did not find any problems borg debug check repositoryonly srvbackupapuborg using builtin fallback logging configuration self tests completed in seconds Starting repository check Read committed index of transaction Segment transaction is Determined transaction is Found segments Starting repository index check Completed repository check no problems found Running borg create after that still produces the same error message as above borgbackupsh Creating archive at srvbackupapuborgnowYmdHMS Local Exception Traceback most recent call last File usrlibpython genericpathpy line in getsize return osstatfilenamestsize FileNotFoundError Errno No such file or directory srvbackupapuborgdata Platform Linux apu amd SMP Debian deb u x Linux debian Borg Python CPython PID CWD root sysargv usrbinborg create verbose stats exclude proc exclude sys exclude dev exclude tmp excluderun exclude mnt exclude media exclude varswap exclude varlibdocker exclude srvbackup exclude rootcache exclude homecache exclude homemichitransmissionsrvbackupapuborgnowYmdHMS SSHORIGINALCOMMAND None Should I not have used repositoryonly with borg check I feared that it would take even longer the borg check command above ran for about h I would like to know how to either fix the repository eg know which files are missing and that the existing ones are in good shape or know that it cant be fixed because there are files missing I cant restore Can you reproduce the problem If so describe how If not describe troubleshooting steps you took before opening the issue Im not sure how to reproduce this The problem seems to have been caused by an older Borg version Make the buzhash chunker more resistant to fingerprinting by introducing a permutation of the buzhash table as discussed at BORGSECURITYDIR Added Will move with BORGCONFIGDIR variable unless specified BORGSECURITYDIR repositioned immediately below BORGCONFIGDIR BORGCACHEDIR moved to precede CONFIGDIR and SECURITYDIR Took a cue from For issue From a mailing list post of mine The borg user asking copied existing data to a new filesystem Should I move to filescachemtimesizeinode Modify to avoid long initial backup times when I resume my daily backups over ssh The problem is that ctime and inode number of all files have changed due to the copying to a new filesystem So whats left is only size which if it is the only criteria used is rather weak If you are absolutely sure that all the files are identical as before so even a weak filescachesize would be no problem you could use that for the first backup Note it is also important that the absolute paths of the files do not change The code there deals with a change of the inode number in case of cache hits read the comment above that line It does not deal with the ctime change though but we could think about whether it makes sense to add some C and M modes that ignore the ctimemtime for change detection but update the cmtime value in the cache to either the current ctime C or the current mtime M of the file With that the nd backup from the new filesystem could go back to the usual filescachesizectimeinode without triggering a full backup Sadly without that change and in a situation like yours you could not enable ctimemtime for change detection without triggering a full backup but only filescacheinodesize which also is a bit weak This is a question a request to update the documentation and a feature request all in one Question What happens when borg create cant read a file Does it act as if the file didnt exist Feature request Assuming that is indeed what happens could we have an option that makes borg treat the broken filefolder as if it wasnt modified since the last backup Documentation This doesnt seem to be documented anywhere so the docs should be updated with this information Have you checked borgbackup docs FAQ and open Github issues Yes Is this a BUG ISSUE report or a QUESTION BUG System information For clientserver mode post info for both machines Your borg version borg V borg V borg a dev gfc fc b Operating system distribution and version Arch Linux Hardware network configuration and filesystems used borg host btrfs RAID on HDD borg client btrfs on SSD borg create over SSH borg recreate locally on host How much data is handled by borg du hs mntdataBackupsHostsableborg G mntdataBackupsHostsableborg Full borg commandline that lead to the problem leave away excludes and passwords export BORGPASSCOMMANDpass miscborg export BORGREPOmntdataBackupsHostsableborg borg recreate excludecaches keepexcludetags progress stats able Describe the problem youre observing Using borg recreate excludecaches on a single specific archive in my repository raises a KeyError Can you reproduce the problem If so describe how If not describe troubleshooting steps you took before opening the issue The problem can be reproduced on this specific archive of the time Include any warningerrorsbacktraces from the system logs export BORGPASSCOMMANDpass miscborg export BORGREPOmntdataBackupsHostsableborg borg recreate excludecaches keepexcludetags progress stats able recreate is an experimental feature Type YES if you understand this and want to continue YES Local Exception Traceback most recent call last File usrlibpython sitepackagesborgarchiverpy line in main exitcode archiverrunargs File usrlibpython sitepackagesborgarchiverpy line in run return setecfuncargs File usrlibpython sitepackagesborgarchiverpy line in wrapper return methodself args repositoryrepository cachecache kwargs File usrlibpython sitepackagesborgarchiverpy line in dorecreate if not recreaterrecreatename argscomment argstarget File usrlibpython sitepackagesborgarchivepy line in recreate selfmatcheraddtaggeddirsarchive File usrlibpython sitepackagesborgarchivepy line in matcheraddtaggeddirs file openitemarchive cachedirmasters itemsource KeyError archvarlibflatpakrepoobjects d f a b c d e afb bb f aba e d bcb b a a f file Platform Linux stratofortressnexusiintelfxname arch SMP PREEMPT Tue Dec x Linux Unknown Linux Borg a dev gfc fc b Python CPython msgpack PID CWD mntdataBackupsHostsableborg sysargv usrbinborg recreate excludecaches keepexcludetags progress stats able SSHORIGINALCOMMAND None Additional notes Mounting the problematic archive reveals that archvarlibflatpakrepoobjects d f a b c d e afb bb f aba e d bcb b a a f file contains valid cachedir tag contents and adding a print to the crash site reveals that this file is a hardlink destination for a properly named cachedir tag borg recreate excludecaches keepexcludetags progress stats able recreate is an experimental feature Type YES if you understand this and want to continue YES XXX going to crash itempatharchvarlibflatpakruntimeorgfreedesktopPlatformx d f cf cfb a c e a ebb d fb abfd b filescachefontconfigCACHEDIRTAG itemsourcearchvarlibflatpakrepoobjects d f a b c d e afb bb f aba e d bcb b a a f file Local Exception As I understand the situation the crash occurs when a CACHEDIRTAG is a hardlink to another file that is not named CACHEDIRTAG which can and will happen with deduplicating contentaddressable stores such as flatpak ostree etc I have worked around this issue locally by simply skipping tag content verification when the hardlink cannot be resolved but I dont see a good way to fix this properly without either loading the whole archive contents into the hashmap or making matcheraddtaggeddirs quadratic Any ideas