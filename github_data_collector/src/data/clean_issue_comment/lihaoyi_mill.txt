I am trying to use an ivyDep included via dependencies comhelger phjaxbpom In its pomxml file at it has the following section near the bottom dependency groupIdorgglassfishjaxbgroupId artifactIdjaxbbomartifactId versionjaxbversionversion typepomtype scopeimportscope dependency which gives orgglassfishjaxbjaxbbomjaxbversion not found homedennisivy localorgglassfishjaxbjaxbbomjaxbversionivysivyxml not found download error Caught javanetURISyntaxException Illegal character in path at index Illegal character in path at index while downloading I dont know enough about maven to say if the problem is in the generated pomxml file or if mill should be able to resolve this Making my project directly depend on the latest version of orgglassfishjaxb jaxbcom which is fetched succesfully does not solve the problem as it will still try to fetch jaxbversion Mill has a convenient task to check for the availability of newer versions of dependencies millscalalibDependencyupdates Unfortunately this task only prints the output in human readable form but does not persist it in a machinereadable format This makes it very difficult to reuse the output in other tasks essentially requiring regex parsing of strings The changes proposed here change the updates task to expose the underlying data structures representing the upgrade path An additional task showUpdates is added implementing the original human readable output of updates This first popped up in gitter The initial stack trace frameworkrmfAppallSourceFiles targets failed frameworkrmfAppallSourceFiles javaniofileFileSystemException redactedframeworkrmfappsrcmainjava Zu viele offene Dateien sunniofsUnixExceptiontranslateToIOExceptionUnixExceptionjava sunniofsUnixExceptionrethrowAsIOExceptionUnixExceptionjava sunniofsUnixExceptionrethrowAsIOExceptionUnixExceptionjava sunniofsUnixFileSystemProvidernewDirectoryStreamUnixFileSystemProviderjava javaniofileFilesnewDirectoryStreamFilesjava oswalkstreamanon generateListOpsscala genyGeneratorMappedgenerateGeneratorscala genyGeneratorforeachGeneratorscala genyGeneratorforeachGeneratorscala genyGeneratorMappedforeachGeneratorscala genyGeneratortoBufferGeneratorscala genyGeneratortoBufferGeneratorscala genyGeneratorMappedtoBufferGeneratorscala genyGeneratortoArrayGeneratorscala genyGeneratortoArrayGeneratorscala genyGeneratorMappedtoArrayGeneratorscala oswalkapplyListOpsscala millscalalibJavaModuleanonfunallSourceFiles JavaModulescala scalacollectionTraversableLikeWithFilteranonfunflatMap TraversableLikescala scalacollectionIteratorforeachIteratorscala scalacollectionIteratorforeachIteratorscala scalacollectionAbstractIteratorforeachIteratorscala scalacollectionIterableLikeforeachIterableLikescala scalacollectionIterableLikeforeachIterableLikescala scalacollectionAbstractIterableforeachIterablescala scalacollectionTraversableLikeWithFilterflatMapTraversableLikescala millscalalibJavaModuleanonfunallSourceFiles JavaModulescala milldefineTaskMappedDestevaluateTaskscala A short run of lsof p on Linux on the mill server process after mill client finished suggests that mill keeps all metajson files open Run in mill repo with mill lefouworkopensourcemill master mill assembly lsof p wc publishVersion devsources lefouworkopensourcemill master mill assembly lsof p wc publishVersion devsources lefouworkopensourcemill master mill assembly lsof p wc publishVersion devunmanagedClasspath Exception in thread MillServerActionRunner lefouworkopensourcemill master mill assembly lsof p wc javaioFileNotFoundException outmillworkerto CVwVb b Ba wrrtQIqC I run Zu viele offene Dateien at javaioFileInputStreamopen Native Method at javaioFileInputStreamopenFileInputStreamjava at javaioFileInputStreaminitFileInputStreamjava at javaioFileInputStreaminitFileInputStreamjava at millmainServerhandleRunMillServerMainscala at millmainServeranonfunrun MillServerMainscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at millmainServerlockBlockMillServerMainscala at millmainServeranonfunrun MillServerMainscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at millmainServertryLockBlockMillServerMainscala at millmainServerrunMillServerMainscala at millmainMillServerMainmainMillServerMainscala at millmainMillServerMainmainMillServerMainscala Exception in thread main javaioIOException comsunjnaLastErrorException Zu viele offene Dateien at orgscalasbtipcsocketUnixDomainServerSocketinitUnixDomainServerSocketjava at orgscalasbtipcsocketUnixDomainServerSocketinitUnixDomainServerSocketjava at millmainServeranonfunrun MillServerMainscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at millmainServerlockBlockMillServerMainscala at millmainServeranonfunrun MillServerMainscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at millmainServertryLockBlockMillServerMainscala at millmainServerrunMillServerMainscala at millmainMillServerMainmainMillServerMainscala at millmainMillServerMainmainMillServerMainscala Caused by comsunjnaLastErrorException Zu viele offene Dateien at orgscalasbtipcsocketUnixDomainSocketLibrarysocketNative Method at orgscalasbtipcsocketUnixDomainServerSocketinitUnixDomainServerSocketjava more This does not happen with mill and f fab Sets flag pinentrymode to loopback to prevent gpg from interactively asking for the gpg passphrase This flag is necessary for newer versions of gpg The flag has been available in gpg since version so this patch should be compatible with gpg versions and up See import mill import scalalib import publish import ivycomlihaoyimillcontribbspMILLVERSION object myproj extends ScalaModule def scalaVersion override def ivyDeps Agg ivycomlihaoyioslib ivycomlihaoyiupickle object tests extends Tests def ivyDeps Agg ivycomlihaoyiammoniteops ivycomlihaoyiutest def testFrameworks SequtestrunnerFramework ammonite and utest can not be accessed by Intellij Hey lihaoyi I spoke to you on gitter about remote caching maybe a month or so ago and heres my attempt I have a remote caching server implementation and a write up here This was a fun exercise Let me know how I could improve this In addition to the information found in the readme linked above on the mill front I wrote A remote caching client that talks to my remote caching server RemoteCacher It uses some dependencies that are only there for the proof of concept I could do it differently if youd like It checks what tasks are cached uploads tasks in a gzipped tar and fetches tasks by uncompromising it and moving it to its proper place in out You mentioned I should first make mill work with relative paths I did struggle with that a bit but another method I thought about was just making it relative when I upload it There are probably some problems with that approach Ill mention it later Not sure if I should use apache commons compress or call our to tar with ammoniteops This only upgrades Mills core modules a lot of the worker modules are left on which is fine because theyre classloader isolated anyway Most of the fooapi modules needed to be crossbuilt so they can be used with both the foo modules running on and the fooworker modules running on Document purpose users and who defines them Eg MILLVERSION MILLBUILDLIBRARIES I have forked the a Maven project that demonstrates the use of the GraalVM It also includes a set of tests that confirm that the GraalVM JS engine is faster than the Nashorn engine These tests work correctly I setup the same project using Mill The example executes correctly Nashorn is nearly twice as slow as Graaljs However the tests fail due to class loading In order for this to work we need to pass parameters to the JVM and add the libraries to the classpath Due to issue I created both a JUnit version and a uTest version The former uses the same directory structure as the original project intended for contribution the latter uses the Mill standard directory structure I tried to track the issue that leads me to the test call which then executes a subprocess call that ends in the call to TestRunner I see that this last execution takes the classpath passed to it as an argument and sets it according However when I print the classpath see this example it does not list the required libraries Nevertheless I have confirmed that the classpath argument is passed on correctly Because the problem manifests itself in both test frameworks I suspect the problem is in the TestRunner and not for example in the JUnitRunner I have also seen issues and that seem to be related These class loading issues seem to be tricky and at this point I do not know what other steps can be taken to diagnose and solve the problem Any suggestions are welcome If you pass invalid parameters to the test command it fails silently no tests are executed For example mill i graaljstest error gives me Test run started Test run finished failed ignored total s However this will work correctly mill i graaljstest v Tested with Mill JDK Linux 