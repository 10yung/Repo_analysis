Hi It looks like JSON CRDT described in the paper suffers from kinds of unbounded growth problems Tombstones in listssets Applied operations Are there any ways to garbagecollect At some point I want to commit current state and clear operations But then it is unclear how a newly added replica will converge with old replica paper only describes transmission of messages Same thing goes for tombstones For an actively edited document the amount of tombstones may get out of hand A possible solution that comes to mind define some kind of Commit type of the operation that will signal to replica to perform tombstone GC Commit Op is emitted arbitrarily by the programmer Please share your thoughts on the subject Hi Thanks for awesome library It is quite difficult for a regular developer like me to figure out how to use the library Could you please add some usage examples that would demonstrate convergence of two replicas with serializationdeserialization tofrom JSON in between merges Something like p initial state q initial state psomeops qsomeops pserString pserialize qserString qserialize here it would be interesting for app developer to actually see JSON text as if it is transmitted over network pmergedeserializeqser qmergedeserializepser Thanks Im currently using the amazing LSEQ CRDT in a collaborative editor and the newish JSON CRDT has me really excited Im trying to start on a port to JavaScript but Im afraid despite my CS background the papers notation is beyond me I would love to include this in an upcoming talk Im giving on Collaborative Editing Since Im basically a n b to Scala and Haskell what resources would you recommend for wrapping my head around this Or better yet would you or someone else really familiar with the datatype be interested in collaborating on a JS port The JSON CRDT paper was updated we have slightly refined the API improved the clarity of explanations and added some more examples It would be great if the crjdt code will be updated to the paper I want to discuss whether MapNode key ie StrKstr String should encode operation id ie Idc BigInt p ReplicaId Current implementation of StrK does not contain operation id Id Semantically it means that any concurrent operations can be distinguished and preserved even if its string key is the same For example following operations scala val p Replicaemptyp val q Replicaemptyq val p p applyCmddocdownFieldkey val q q applyCmddocdownFieldkey mergep q currently result in MapNode Map MapTDocK MapNode Map MapTStrKkey MapNodeMapMap MapStrKkey SetId p Id q MapDocK SetId p Id q If StrK encodes Id let StrK to be case class StrKstr String id Id above operations may result in MapNode Map MapTDocK MapNode Map MapTStrKkey Id p MapNodeMapMap MapTStrKkey Id q MapNodeMapMap Map StrKkey Id p SetId p StrKkey Id q SetId q MapDocK SetId p Id q The first reason StrK should encode Id is lemma in the paper refers to operation ID for ASSIGN operation with nonprimitive values If oa and oc are assignments to the same cursor we use the commutativity of updates to a partial function child id val id val child id val id val provided that id id Since operation IDs Lamport timestamps are unique two concurrent assignments add two different keys to the mapping and their order is immaterial The second reason is that overriding causally dependent primitive value with nonprimitive values creates an empty register viewed as present in document state as reported in If StrK has operation ID the two operation is distinguishable and empty register will not be present because presSets has different entries for each values One negative reason StrK should not encode operation ID may be that the same value assigned by different operation will now be distinguished and may evolve with completely different histories For example in Figure of the paper grocery key is initialized with an array independently by each replica Following insertion is done against different ListNodes so I wonder two ListNode can be converged to the same array Overriding causally dependent primitive value with empty list or map creates an empty register in document state scala val p Replica emptyp applyCmddocdownFieldkey A applyCmddocdownFieldkey applyCmddocdownFieldkeyiterinsertA MapNode Map MapTDocK MapNode Map RegTStrKkey RegNodeMap ListTStrKkey ListNode Map RegTIdKId p RegNodeMapId p StrA MapIdKId p SetId p MapHeadR IdRId p IdRId p TailR MapStrKkey SetId p Id p MapDocK SetId p Id p Id p Converting documents that contain empty resister with lastwriterwins conflict resolver causes Exception javalangUnsupportedOperationException emptymax This is because the empty register is viewed present as presSets has key key so JSON converter tries to convert the empty register to JSON value which is impossible By the way Nodevalues query works correctly against empty register because it returns registers values that is empty An implementation depends on Node states and does not use its query interface may hit this problem Document state to JSON conversion introduced from does not handle duplicate key as reported at this comment Duplicate key can be made when MapNode is updated with different type values other than primitive For example concurrently updating to the same key key with object and string scala val p p applyCmddocdownFieldkey applyCmddocdownFieldkeydownFieldkey D val q q applyCmddocdownFieldkey C mergep q results in duplicate keys RegTStrKkey and MapTStrKkey MapNode Map MapTDocK MapNode Map RegTStrKkey RegNodeMapId q StrC MapTStrKkey MapNodeMapRegTStrKkey RegNodeMapId p StrDMapStrKkey SetId p MapStrKkey SetId p Id p Id q MapDocK SetId p Id p Id p Id q 