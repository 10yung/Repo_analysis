Every exported function in a program should have a doc comment The first sentence should be a summary that starts with the name being declared From effective go PR generated by CodeLingo Install here to drive Continuous Higher Standards In Single strategy setEnvs error in mac error message panic reflect call of reflectValueInt on zero Value goroutine running reflectValueInt usrlocalgosrcreflectvaluego solution Replace with below code will solve this problems v reflectValueOflElemFieldByNamefdElemFieldByNamepfd fd uintptrvFieldByNameSysfdInt Drop resolving listener file descriptor by reflecting private struct fields Instead we duplicate listener file descriptor which handles closeOnExec syscalls The current implementation uses reflect package and is prone to break actually as of go it WILL break because the netFD struct fields have been moved around and sysfd field does not exist anymore and is reachable instead by pfd pollFD field Fixes a rogue close that happens whenever the GC next runs after Listen NewFile takes responsibility for the fd it is passed but Listen then proceeds to manually syscallClose the fd anyway So when the file object gets finalized it is closed a second time either causing an EBADF or closing some other random file I agree with and that logging should not forced upon users of this library But I also agree with rcrowley that the logging is useful and needed This PR doesnt change the default logging functionality but adds a Logger var on the package that can be set to override where log messages go This can be useful for applications that already have a logger setup and want the goagain logs to go to the same place You just set go myLogger logNewmyWriter err logLstdFlags goagainLogger myLogger Or if you wanted to disable logging altogether you can set go goagainLogger nil by default in go the quit signal is used to print stacktraces of running go programs type ctrl or use kill QUIT pid this is a very useful feature but goagain overrides the quit signal Im experiencing an odd issue after issuing a USR signal to my process Ive got an OnSIGHUP handler which opens some files and reloads data from them On the first HUP after USR I get read filetxt bad file descriptor if I HUP the process again it all works fine Ive been able to hack around this by setting a global variable after USR and if its the first HUP after a USR and doing go f err osOpenosDevNull if err nil defer fClose and then running the code to reload the data from the files Is this anything youve seen before is there likely to be anything common Ive not done correctly My use of goagain effectively matches the examplessimplemaingo example with the addition of the OnSIGHUP handler Ill try to replicate the issue with the simple example Would it be possible to wrap some of the complexity of the handoff setup code With a similar signature as netListen it should either resume the previous connection or set up a new one This could be performed by calling goagainListener and depending on whether it succeeds either kill off the parent or other appropriate cleanup or return a new netListener by calling netListennet laddr Basically handling all of examplesimplesimplegoL but just returning the listener This would make the library a near dropin replacement of the standard netListener It could be named goagainListen akin to netListen goagainListenAgain or maybe goagainReListen I have multiple listeners like two listening on port and and one listening to https on port That means I have now three listeners However the nature of goagain doesnt allow to use it with several listeners I can split my app that it runs like three binaries but this would be not a good choice Ive hacked a little on goagain to support for multiple listeners a sneak code for addr l range listeners a reflectValueOfl v aElemFieldByNamefdElem fd uintptrvFieldByNamesysfdInt if err osSetenvGOAGAINFDaddr fmtSprintfd nil err return err if err osSetenvGOAGAINNAMEaddr fmtSprintftcps lAddrString nil err return err fmtPrintlnFD number is fd files fd osNewFilefd stringvFieldByNamesysfileString However I dont like the way the file descriptors are created Because I have to create the array earlier to append the FDs to the files arary like files make osFile Here is just an integer thats large enough Ive tried to use append on files array However when I use append its breaking goagain with this err forkexec gobintestgoagain bad file descriptor It seems it is working quite well Do you have any plans to support multiple listeners 