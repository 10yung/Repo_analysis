Posted this in but referencing here for visibility Minimal reproducible example and details are here This issue is also present in the reduction operation in CUB v Hi First of all thank you for developing and maintaining this amazing library It makes CUDA programming drastically easier and fun Today I found a problem When I defined a function that returns thrustfuture like the following cpp include thrustfutureh include iostream the definition is in a cu file and will be linked later thrustsystemcudauniqueeagerfutureint dosomething int main auto f dosomething stdcout fget stdendl return and compiled with gcc nvcc also shows the same result the compilation fails with an error message like this console g stdc O c maincpp Iusrlocalcudainclude In file included from usrlocalcudaincludethrustsystemcudadetailfutureinl from usrlocalcudaincludethrustsystemcudafutureh from usrlocalcudaincludethrustfutureh from maincpp usrlocalcudaincludethrustdetaileventerrorh error explicit specialization of templateclass T struct thrustsystemiserrorcodeenum outside its namespace must use a nestednamespecifier fpermissive template struct iserrorcodeenumeventerrc truetype I also found that this error can be avoided by applying the patch Im now sending I have tested it only with thrust that is installed with CUDA because it is the version installed in my environment If the same problem has already been reported and solved please just close this Could you please check it Judging by the name of the functor predicatetointegral and the explicit construction of IntegralType in the function the return type should be IntegralType instead of bool Obviously the primary goal of the examples is to show how one uses the library However they are also adding to the overall C knowledge people using thrust are very likely to also learn the standard library algorithms and take over the style presented if not even copypasteadapt the examples So there would be value in making the example code exemplary modern C Some instances of example code that could be modernized thrustdevicevectorint stencil stencil stencil could make use of stdinitializerlistint to direct initialize the vector stdcout found indicesend indicesbegin Should really use stddistancebeginindices indicesend reduce a pair of bounding boxes ab to a bounding box containing a and b struct bboxreduction public thrustbinaryfunctionbboxbboxbbox Is a poor choice of name it tells you what function its going to be used in reduce not what it does bounding box of bounding boxes it may be replaced by a lambda expression I think it would be a good idea to set up an examplewide code review and try to exemplify that code cf also the very limited pull request thrustdevicevectorint aa int finalindices Any way copy a aa to a cuda memory address Please can you tell me if is there a way to visualize which specific assertions in an unit test failed Both uninitializedfill and uninitializedcopy as well as their n versions use the copy constructor to copy elements to the provided range of memory While the basic implementation is rather straightforward and compliant thrust seems to use an optimization for certain typesclasses In particular it tries to detect whether the underlying type T is trivially copy constructible and then calls the regular fill and copy algorithms same for n versions However the latter functions use the copy assignment operator to copy the elements which may lead to compilation failures in case a class has a trivial copy constructor but no copy assignment operator Consider this example using T thrustpairconst int float T x f thrustdevicevectorT dv thrustuninitializedfilldvbegin dvend x May fail to compile To be more precise the optimization uses the type trait thrustdetailhastrivialcopyconstructor which is incorrect in above case as T obviously has a trivial copy constructor but no copy assignment operator so the executed fill operation will fail to compile Even worse this error only triggers if the OpenMP and maybe also TBB backend is used because the implementation is compilerdependent ie contains additional checks for GCC Clang and MSVC For the default CUDA backend and the nvcc compiler the error does not occur At first glance the solution would be to use thrustdetailhastrivialassign which is also provided However this also does not work for the above example using the OpenMP and TBB backend CUDA backend still not affected using T thrustpairconst int float true does not trigger false positive staticassertthrustdetailhastrivialassignT C thrust implementation false triggers as expected staticassertstdistriviallycopyassignableTvalue C standard implementation The reason for this lies in the fact that it uses the compilerspecific type trait hastrivialassign which is used only for GCC Clang and MSVC and has a too permissive behavior causing false positives see eg Therefore there as several possibilities to fix this issue which I would like to discuss first before going ahead and providing a fix Remove the optimization This is the easiest and most reliable solution to make the implementation compliant for all use cases and also works for C The downside of this solution is that there might be performance regressions I have not measured the performance difference between the uninitialized and the regular algorithms Note that thrustdetailhastrivialassign still needs to be fixed to avoid false positives see Use thrustdetailhastrivialassign and remove the unreliable and compilerdependent hastrivialassign expression which makes it equal to thrustdetailispod and the version used for the CUDA backend This keeps the optimization at least for POD types and stills works as expected As for the performance may degrade Use and conditionally define thrustdetailhastrivialassign to be equivalent to ie make use of stdistriviallycopyassignableT if C or a higher standard is detected This is probably the fastest solution although there might be still performance regressions however in C only Solution is probably a good compromise if the optimization should be kept The last solution also takes advantage of the more recent C standard which most users probably already use As a final remark Although this example may look like an uninterestingartificial corner case there are realworld uses cases for this An example is the stdgpu library and its stdgpuunorderedmap container which uses thrustpairconst Key T To circumvent this issue it currently implements a workaround which is equivalent to solution see Hi all In The trait hastrivialdestructor is implemented as ispod But in c theres dedicated function for it called stdistriviallydestructible Being POD is a stricter requirement than being trivially destructible In my case I expect thrustdetaildestroyrange as a noop when input type is trivially destructible but with a user defined constructor This way I can have a library XGBoost compiled with CUDA and uses thrustdevicevector but run on CPU without error as long as I dont call any cuda function in the code path But with thrust shipped with CUDA I got the following error in devicevectors destructor terminate called after throwing an instance of thrustsystemsystemerror what foreach failed to synchronize cudaErrorNoDevice no CUDAcapable device is detected Aborted core dumped It maybe worth mentioning that data size is stdcomplex guarantees arrayoriented access behavior For any object z of type complexT reinterpretcastT z is the real part of z and reinterpretcastT z is the imaginary part of z For any pointer to an element of an array of complexT named p and any valid array index i reinterpretcastTp i is the real part of the complex number p i and reinterpretcastTp i is the imaginary part of the complex number p i The intent of this requirement is to preserve binary compatibility between the C library complex number types and the C language complex number types and arrays thereof which have an identical object representation requirement See Does thrust provide such behavior This would allow casting between stdcomplex and thrustcomplex at zero cost using reinterpretcast Currently the casting between stdcomplex and thrustcomplex is hostonly C host complex const stdcomplex T z host operator stdcomplex T const Trying to compile the following example C include thrustdevicevectorh int mainvoid thrustdevicevectorfloat A return with Clang or Clang yields the following error usrlocalcuda includethrustsystemcudadetailcoreagentlauncherh error use of undeclared identifier vaprintf usrlocalcuda includethrustsystemcudadetailcubdevicedispatchutildebugcuh note expanded from macro CubLog define CubLogformat vaprintf block ddd thread ddd format VAARGS Compiling with nvcc works Checking the code after preprocessing shows that the vaprintf function indeed lives under thrustcudacubcub while in agentlauncherh it is called from within thrustcudacubcore