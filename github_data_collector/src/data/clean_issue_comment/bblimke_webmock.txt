This one is pretty strange and I cant figure out whats going on The gist If you have a spec like this ruby require railshelper describe home js true do it foo do WebMockenable WebMockdisablenetconnectallowlocalhost true visit rootpath WebMockdisable end it bar do WebMockdisablenetconnectallowlocalhost false end it baz do visit rootpath end end and run it in order rspec order defined then you get two failures in baz WebMockNetConnectNotAllowedError Real HTTP connections are disabled Unregistered request POST with body url with headers Acceptapplicationjson AcceptEncodinggzipq deflateq identityq ContentLength ContentTypeapplicationjson charsetUTF UserAgentselenium ruby macosx WebMockNetConnectNotAllowedError Real HTTP connections are disabled Unregistered request GET with headers Acceptapplicationjson AcceptEncodinggzipq deflateq identityq CacheControlnocache ContentTypeapplicationjson charsetUTF UserAgentselenium ruby macosx If we remove the first test and only keep the last two ruby require railshelper describe home js true do it foo do WebMockenable WebMockdisablenetconnectallowlocalhost true visit rootpath WebMockdisable end it bar do WebMockdisablenetconnectallowlocalhost false end it baz do visit rootpath end end and run the specs with rspec order defined the tests pass Note that in both cases when we reach baz WebMock is disabled and configured to disallow net connections but in the first case it fails I dont know why but it seems that allowing localhost and visiting the first path somehow affects what happens with subsequent test Where is the problem The problem seems to be a weird interaction of WebMock RSPec Selenium and Capybara Maybe the problem is not in WebMock Also if we remove js true from the first snippet it works fine so maybe Capybara is setting up something that eventually messes up the way WebMock works But maybe you have an idea of why this is happening Full steps to reproduce The short method You can download this zip file testcapybarawebmockzip uncompress it and inside that directory run bundle exec rspec specfeatureshomespecrb The long method rails new testcapybarawebmock T cd testcapybarawebmock Add this to the Gemfile ruby group test do gem rspecrails gem capybara gem seleniumwebdriver gem geckodriverhelper gem webmock end Run bundle Create a specfeatureshomespecrb file with the contents of the first snippet in this post Run bundle exec rspec specfeatureshomespecrb and see it fail The End Let me know if something is not clear Im happy to help figuring out whats going on and fixing it if possible Thank you This is an attempted fix for this issue NOTE FaradayErrorConnectionFailednew is deprecated use FaradayConnectionFailednew instead It will be removed in or after version FaradayErrorConnectionFailednew called from rbenvversions librubygems gemswebmock libwebmockresponserb I was recently working on mocking out some requests and ran into an issue where I was using webmock to forward mocked requests to a rack app I had wrapped a bunch of specs like Rspecconfigure do config configaroundeach do example somemockingsetup examplerun makes a bunch of requests to the mocked endpoints somemockingteardown uses some of my mocked requests to tell the rack service to reset end end And was surprised when somemockingteardown was throwing errors about me attempting my mocking teardown I am able to successfully accomplish what I need by doing Rspecconfigure do config configbeforeeach do example somemockingsetup examplerun makes a bunch of requests to the mocked endpoints end configaftereach do example somemockingteardown uses some of my mocked requests to tell the rack service to reset end end I would expect either option to work I have included a proposed pr to only reset webmock after the configaroundeach in the webmock configuration Thoughts on this A common mistake when testing APIs is accidentally including a in a url in one place while omitting that in another endpoint Effectively the endpoint works yet WebMock will say they are different Eg writing wwwexamplecomfoo in assertrequested when the actual API hits When POSTing to an endpoint with parameters this imperceptible difference is easy to miss and can lead to many hours of frustration as developers parse the long comparison output between the two requests to figure out what they did wrong in their API call versus the test case My suggestion is that WebMock treats URLs ending in the same as urls without the last slash For those wanting the old behaviour the gem could add a flag to reenable it for the few oddball projects actually treating calls to and differently This stub chained with with will never match its intended request ruby stubrequestpost urlmatcher withheaders SOAPAction because the stubs HeadersPattern has been normalized and no longer matches the given header Note Soapaction instead of SOAPAction WebMockHeadersPattern x fe db b patternSoapaction Ive put in a PR to fix up a lot of the deprecation warnings but I havent the time or understanding to dig into the actual failures Looks like CI has been red for a while tho ETA comes out in mere weeks Is there a recommended way to verify the order stubbed requests were called in This is useful to ensure stubs are called in a correct order due to API limitations Stubbing an AsyncHTTPClient or AsyncHTTPInternet does not return any response for me but hangs for ever Using asynchttp webmock rspecrails rails Heres some sample code to illustrate ruby RSpecdescribe AsyncHTTP do before WebMockdisablenetconnect context with Internet do class InternetClient def initializehttp http http host headers ProtocolHTTPHeaders contenttype applicationjson accept applicationjson end attrreader http host headers def poststuffbody response httpposthoststuff headers body if responsesuccess true responseread else false responseread responsestatus end end end subject InternetClientnewAsyncHTTPInternetnew specify do stubrequestpost withbody request body toreturnbody response body expectsubjectpoststuffrequest bodyto eq true response body end end context with Client do class HttpClient def initializehttp http http headers contenttype applicationjson accept applicationjson end attrreader http headers def poststuffbody response httppoststuff headers body if responsesuccess true responseread else false responseread responsestatus end end end subject HttpClientnewAsyncHTTPClientnewAsyncHTTPEndpointparse specify do stubrequestpost withbody request body toreturnbody response body expectsubjectpoststuffrequest bodyto eq true response body end end end I recently ran into an annoying issue with WebMock when implementing stubs the way the gem recommended Ie the gem recommends copying over the UserAgent header of each request when pasting in what to stub Since most ruby http gems append their gem name and version number as the UserAgent in requests this means that WebMock will automatically break whenever you update your http client even if nothing else about the request has changed These breaks from updates are difficult to debug Rather than need to hack my HTTP gem to find way to keep my UserAgent stable in WebMock across gem updates it dawned on me that it might be a lot simpler for most developers if WebMock by default just excluded the useragent altogether from what it recommends stubbing so that developers using this tool dont see their tests break in confusing ways when they inevitably update their http client gems This will make WebMock tests less brittle developers more productive and if people need the UserAgent recommended in their stubbing output they should just add it to their web mock tests manually It may also be worth thinking about ways to reduce HTTP boilerplate in what webmocks mock If so I would recommend removing the Connection header also