Hello This is not a bug report but a short note to describe how to compile a project using the rustzmq crate on Windows with cargo It ended up being easy but took me a while to figure out so I thought I would share Install vcpkg instructions on Install zeromq usign vcpkg vcpkg install zeromq Create a copy called zmqlib of the libzmqmtlib file created your path to vcpkg installed x windows lib directory Create an environment variable called LIBZMQPREFIX pointing to path to vcpkg installed x windows You can now build your project using rustzmq using cargo PS I am using an x environment if you are not you will probably have to readjust the path to the vcpkg libraries mentioned above This should be quite simple to add so Ill leave this open in case someone feels like trying their hand Now that we require libzmq zmqhas always returns Somebool so it should return a plain bool without wrapping it in an option This is a breaking change so it needs to be done in the next APIbreaking release ie at the time of writing The flag is ZMQINVERTMATCHING While MQ has its own design it is tailored for C and requires passing in the socket parameters as a string We could do better We have SocketAddr and all sorts of other cool ways to make the API less stringly Functions like setsubscribe logically change the state in a Socket Doesnt that mean that it should be declared like fn setsubscribe mut self value u Result I understand that the rust type checker might not force you to do that because youre mutating state behind a native pointer but logically shouldnt it More importantly are there optimizations that the compiler might make that are incorrect because its assuming nothing related to the socket is changing Im attempting to write wrappers around this library for use with Tokios event loop and there are certain cases where it is important that the Message not be destroyed If Sendablesend in or Socketsendmsg in fail to send with EAGAIN it just means the socket is currently busy and we can try again however these methods both consume the Message and dont give it back making it impossible to try again With my wrappers current logic this state should be impossible but it is still possible to express this state with code so Id like to be able to properly handle it A possible solution could be to make ErrorEAGAIN into ErrorEAGAINOptionT T could be Message but I havent looked around ZeroMQ enough to know if there are other situations where this could be important How difficult would it be to allow creation of a ZMQ context with more than one IO thread I dont know if Rust has any special considerations though I would expect it is just a different call to the context initialization I was able to setup an encrypted connection with but I couldnt find anything on how to do actual authentication Currently only the server is authenticated but any client can connect and send messages It would be nice if itd be possible to add a list of public keys which I trust to send messages A had an idea about a possible improvement and Id like to know what people think about it I was wondering if it made some sense to provide an intoiter method for the socket Especially if there was a corresponding sendall or something for the receiving socket I think it would be more comfortable to use an iterator like this rust let src contextsocketzmqPULLunwrap srcbindtcp let dst contextsocketzmqPUSHunwrap dstbindtcp let processed srcfiltermapmsg unimplemented mapotherconversion dstsendalldst instead rust loop let msg srcrecvmsgunwrap unimplemented if haveanswer dstsend answerunwrap On the other hand it doesnt follow the original C api and once ready the tokiozmq would provide something very similar with streams and sinks which is basically where the idea comes from anyway so Im not sure if its worth trying to implement it What do you think should I try putting some code together or is it a daft idea and I better spend the time somewhere else And no I havent yet thought about all the details like what to do with multipart messages