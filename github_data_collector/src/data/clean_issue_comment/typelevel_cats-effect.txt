Looking at it seems this issue have been fixed at least once scala import catseffectIO Sync import catsimplicits object Boo def mainargs Array String Unit def app F Sync c Int F Unit for Sync F delayif c printlnc appc yield def app F Sync c Int F Unit Sync F delayif c printlnc flatMap app c app IO unsafeRunSync app works fine app leaks memory object ApiStarter extends IOApp def runargs List String IO ExitCode ResourcemakeIOSystemexit IOuse Hangs forever clean exit expected It seems that it deadlocks on finalizer in IOAppPlatform catseffect cats val cs IOcontextShiftExecutionContextglobal throws exception IOthrow new OutOfMemoryError csshift IOunsafeRunSync hangs forever csshiftproductRIOthrow new OutOfMemoryError IOunsafeRunSync catseffect cats First prototype for parallel resource acquisition Please only look at the implementation I intend to expose this as a Parallel instance rather than the parZip function Needs proper testing as well Motivation I found an open good first issue while reading about MVar This branch contains an attempt to implement it Modification add tryRead F Option A similar to ControlConcurrentMVartryRead add a test and a line into the docs I wonder does it do what is it intended to do I am happy to amend it if Ive missed something suggestions are welcome Thank you Megachange of doom This PR does a couple of things Adds an implementation of SystemFws maskpoll combinator called uncancelable for now as described in Random note I chose to keep bracketCase primitive despite the slight overlap with uncancelable This is mostly because of inversion of control between Bracket and Concurrent There is no way that Im aware of to define bracketCase in Bracket in terms of onCase and guarantee without making it aware of cancelability And if we dont make it aware of cancelability then we can define it but we would need to override it in every Concurrent with Bracket implementation which seems very annoying So instead I made bracketCase primitive while guarantee and onCase are derived from it and well have a law which codifies the relationship between uncancelable and the bracket Pushes F A into the Completed case of ExitCase This has the interesting sideeffect of making ExitCase kind of behave like a monad transformer but only when F forms a Traverse When it doesnt form a Traverse ExitCase is only Applicative Fixes Rewrite PureIO as PureConc names are hard on top of Eventually if this works Ill move coop under the Typelevel org The last point is an important one PureConc is now the following scala type PureConc E A Kleisli ThreadT Kleisli ExitCase Id E FiberCtx E MVarUniverse A The type seems imposing but its actually relatively easy to deconstruct Taking it one stage at a time The ability to use MVar from coop Cooperative multithreading implemented with FreeT A lexicallyscoped context for the currently running fiber Final results produced by an effect The nesting is actually somewhat arbitrary we could have put ThreadT on the outside and even merged the two Kleislis together into one if we wanted to Laws are currently not passing presumably because of bugs Im working on that and in the process working on making ThreadT structures a bit more introspectable for debugging purposes but this is good enough to get some review eyes on it Also getting it into the upstream branch allows everyone else to pitch in and help out Currently MVar offers read put take as well as tryPut and tryTake It seems to me that an atomic nonblocking tryRead is missing Updates orgscalametascalafmtcore from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgscalameta artifactId scalafmtcore details labels semverminor 