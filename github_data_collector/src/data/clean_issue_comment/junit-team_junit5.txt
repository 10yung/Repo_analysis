 Overview Closes I hereby agree to the terms of the JUnit Contributor License Agreement Definition of Done There are no TODOs left in the code Method preconditions are checked and documented in the methods Javadoc Coding conventions eg for logging have been followed Change is covered by automated tests including corner cases errors and exception handling Public API has Javadoc and API annotations Change is documented in the User Guide and Release Notes All continuous integration builds pass Please provide us the version of JUnit you are using and if possible a failing unit test with your bug report Dont forget to describe the rationale for this issue eg expected vs actual behavior Steps to reproduce The change lead to invalid version ranges in ImportPackage statements For example in junitplatformrunner we see instead of the desired ImportPackage orgjunitplatformcommonslogging version statusINTERNAL orgjunitplatformcommonsutil version orgjunitplatformengine version orgjunitplatformenginediscovery version orgjunitplatformenginereporting version orgjunitplatformenginesupportdescriptor version orgjunitplatformlauncher version orgjunitplatformlaunchercore version orgjunitplatformsuiteapi version orgjunitrunner version orgjunitrunnermanipulation version orgjunitrunnernotification version Please insert a code snippet or a link to another repo along with instructions how to reproduce the issue here The example should be minimal complete and verifiable see Context This occurs in the current master branch Deliverables The solution will be change change the versions in the build scripts from versionVersionsjunit Min to version Versionsjunit Min Currently there is no good way to discover and execute a single test when using a file based test system like Cucumber So I would like to request support for a file position in UriSelector FileSelector and ClasspathResourceSelector Deliverables Support for a file position when using URI selectors File selectors Classpath resource selectors Motivation Cucumber executes feature files written in Gherkin A feature file consists of multiple scenarios organized in a hierarchical structure A project may contain multiple feature files typically organized in some directory structure For example srcmainjavacomexample Appjava srctestjavacomexample StepDefinitionsjava srctestresourcecomexample singlefeature rulefeature outlinefeature Contents of outlinefeature feature Feature A feature with scenario outlines Scenario A scenario Given a scenario When it is executed Then is only runs once Scenario Outline A scenario outline Given a scenario outline When it is executed Then example is used Examples With some text example A B Examples With some other text example C D outlinefeature contains tests in a hierarchy A feature with scenario outlines A scenario A scenario outline With some text Example Example With some other text Example Example Now suppose I would like select both tests Example Example nested under the example With some text on line Currently JUnit discovery selectors ClasspathRootSelector ClasspathResourceSelector PackageSelector FileSelector DirectorySelector only allow me to discover all tests in a single directory or file The UniqueIdSelector could be used to select the With some text container but requires reproducing the unique id which is rather complicated and quite possibly an implementation detail that should not be relied upon Cucumbers currentTestEngine implementation currently allows for a line query parameter to be added in when parsing using the UriSelector For example classpathcomexampleoutlinefeatureline filehomempkorstanjeprojectscucumbersrctestresourcescomexampleoutlinefeatureline Since this is not formalized I suspect other test engines that consume the UriSelector may crash on the query parameter and so I would like something safer For IDEs being able to use a FileSelector with a file position would also simplify the complexity of providing support for file based test engines Naively allowing the user to select any line in a file and execute the discovered tests for that line would provide for a minimal implementation without knowing any details about the underlying implementation of the test engine The same reasoning applies to ClasspathResourceSelector We have one test that changes the global state for example java Test void localeTest LocalesetDefaultLocaleFRENCH assertEqualsBunjour getMessage and hundreds of tests that reads the state java Test void someTest assertEqualsHello getMessage After enabling parallel test execution our tests start to fail at random locations with messages like that ERROR message expectedAnnotationjava Annotation AnnotationAnnotation have incorrect indentation level expected level should be but wasAnnotationjava Die Annotation AnnotationAnnotation hat eine unerwartete Einr ckungstiefe von erwartet ExecutionExecutionModeSAMETHREAD for the test localeTest wont help us since the all other tests are able to run concurrent with every other test and with localeTest too This can be solved with ResourceLock java Test ExecutionExecutionModeSAMETHREAD ResourceLockvalueglobal modeREADWRITE void localeTest LocalesetDefaultLocaleFRENCH assertEqualsBunjour getMessage Test ExecutionExecutionModeCONCURRENT ResourceLockvalueglobal modeREAD void test Test ExecutionExecutionModeCONCURRENT ResourceLockvalueglobal modeREAD void test but this is error prone since adding a new Test without this annotation will produce a flaky tests which may fail It will be much better to mark some tests as incompatible with parallel execution at all java Test ExecutionExecutionModeALONE no other this will be executed in parallel void localeTest LocalesetDefaultLocaleFRENCH assertEqualsBunjour getMessage As a workaround it is possible to turn such a test into Junit test which will be executed in other universe isolated from all other Overview This new implementation supports WildCardType and type hierarchy thanks to the usage of TypeUtilsisAssignable provided by apache commons lang Drawback it adds a new dependency to JUnit Jupiter I hereby agree to the terms of the JUnit Contributor License Agreement Definition of Done x There are no TODOs left in the code x Method preconditions are checked and documented in the methods Javadoc x Coding conventions eg for logging have been followed x Change is covered by automated tests including corner cases errors and exception handling x Public API has Javadoc and API annotations x Change is documented in the User Guide and Release Notes x All continuous integration builds pass When selecting multiple modules eg via selectmodule abc within a console launcher run users cant quickly infer from which module a test class read container originates By appending that information to the default display name its origin is presented in plain sight Example Without module names With module name prepended Implementation Questions What about package names Is it better to generate logical nodes for container modules and packages like we do for classes and engines Like can be seen at the API of JDK javadoc supports creating a modular overview page At the moment we prevent that page from being created via nomoduledirectories JUnits overview page could look like All Modules Jupiter Platform Vintage Module Description orgjunitjupiter The aggregator module of the JUnit Jupiter API orgjunitjupiterapi JUnit Jupiter API for writing tests Might supersed Deliverables x Drop nomoduledirectories and get the overview page generated and uploaded With reference to this thread It would be nice to have the ability to add tags during runtime especially for DataDriven Testing Use Case We are using different test data for a test case We want to group all the positive test data as a smoke suite and add negative test data to the Regression suite Model Test Data testName Sample tagsmoke testDataTD testName Sample tagRegression testDataTD Let me know if this is feasible Hi Im using CLion with a c project cmake which starts a jvm The java part is built with gradle The project works but Im having a problem with debugging When I start the JVM I immediately get a SIGSEGV I understand that its normal it comes from the jvm itself and theres no workaround except ignoring SIGSEGV A bit annoying but not too bad as it only happens once per session BUT after that I continue debugging and I get constant SIGBUS signals with this stack trace unknown x f unknown x dca unknown x dca unknown x da unknown x da unknown x da unknown x da unknown x dae unknown x da unknown x dae unknown x da unknown x dae unknown x da unknown x JavaCallscallhelperJavaValue methodHandle const JavaCallArguments Thread x bf a StackWalkfetchFirstBatchBaseFrameStream Handle long int int int objArrayHandle Thread x c cac StackWalkwalkHandle long int int int objArrayHandle Thread x c fc JVMCallStackWalk x bfb a unknown x unknown x da unknown x da unknown x da unknown x da unknown x da unknown x da unknown x da unknown x da unknown x dae unknown x da unknown x da unknown x JavaCallscallhelperJavaValue methodHandle const JavaCallArguments Thread x bf a InstanceKlasscallclassinitializerThread x bf af InstanceKlassinitializeimplThread x bf f ReflectioninvokeconstructoroopDesc objArrayHandle Thread x c ebdbb JVMNewInstanceFromConstructor x bfc f unknown x unknown x da unknown x da unknown x dae unknown x da unknown x da unknown x dae unknown x dae unknown x dcec unknown x da unknown x da unknown x dae unknown x da unknown x da unknown x dae unknown x da unknown x da unknown x da unknown x da unknown x da unknown x da unknown x JavaCallscallhelperJavaValue methodHandle const JavaCallArguments Thread x bf a jniinvokestaticJNIEnv JavaValue jobject JNICallType jmethodID JNIArgumentPusher Thread x bf e af jniCallStaticVoidMethodV x bf c JNIEnvCallStaticVoidMethodjclass jmethodID jnih main maincpp start x fff f d start x fff f d It doesnt stop in my code I dont understand why this is happening or if its possible to avoid them aside from ignoring all SIGBUSs I minimized my code and created the most simple example which reproduces the issue Basically I created a cpp project which starts a jvm with orgjunitplatformconsoleConsoleLauncher as main with one simple test class And the SIGBUS happens It happens before my test even run If I put my code as main instead of JUnit it doesnt happen You can get a simple project which demonstrate the issue here Another thing I noticed This example gives a single SIGBUS If I put two test classes I get two SIGBUSes if I put I get Thus I suspect something within JUnit My environment MacOS Clion Java LTS JUnit versions I tried M Thanks Seems to be feature we wanted This use case triggered the question Deliverables Working as intended Bug 