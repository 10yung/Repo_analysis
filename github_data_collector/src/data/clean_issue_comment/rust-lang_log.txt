The only problem on the build is on the dependency cfgif It would be really nice to have a specialized way of logging errors that implement stderrorError This would allow automatically capturing detailed information about an error including the Display and Debug representations and especially backtraces via the new Errorbacktrace which has an open PR The main purpose is to give the backend implementation the option to extract all desired information about an error and use it as appropriate for the output Not sure how this could fit into the current design but Id imagine an additional method on Log and a macro rust trait Log The record serves the purpose of providing the location and optionally an additional error message metadata Question Should the record be optional or required fn error self error dyn stderrorError record Option Record Plus a macro Naming for that macro would of course be somewhat awkward considering error exists Maybe witherror Also there could be a variant of error that allows specifying an error value One could of course ask if this is really necessary since you could already write a custom macro or method that captures the required information as a Record But Id like to see a standardized way of doing this that gives the logger implementation the power to do what it wants without forcing the user to make a decision here upfront Since log can provide static string if its available so x can utilize it to avoid annoying unknown string when they are using together Found by clippy Continuation of Description kvunstable is available in log and provides a keyvalues field on the Record to capture keyvalue pairs However currently in order to write data to loggers Record types need to be constructed manually rather than being able to use the log macros As per RFC we should experiment with logging macros out of tree and use it to inform how to add keyvalue logging to logs macros Constraints tbi KodrAus could you perhaps clarify what the constraints are Prior Art Slog The slog crate uses key value pairs in the macros rust macrouse extern crate slog fn main let drain slogDiscard let root slogLoggerroot drain okey value key value inforoot test info log logkey true Tracing tracing supports two kinds of log styles a message keyvalue pairs and only keyvalue pairs rust use tracingfield let addr Ipv Addrnew let conn Connection port speed info port connport connected to addr info target connectionevents ip addr connport connspeed Update this section with more examples Creating a manual record For reference this is how to create a manual record with keyvalue pairs rust use logkvError Visitor Source struct Pair val String impl Source for Pair fn visit self visitor mut dyn Visitor Result Error visitorvisitpairsome keyinto selfvalinto logloggerlog logRecordbuilder argsformatargshello world keyvalues Pair val some valuetostring levellogLevelInfo targetmodulepath modulepathSomemodulepath fileSomefile lineSomeline build Conclusion We should experiment with logging macros that can capture keyvalue pairs and report back with our findings in this issue Itd be great if we could discuss their tradeoffs and eventually come up with a design thats suitable for an RFC When writing command line programs I often find myself wanting two distinct infolike log levels one for regular output and one when a verbose flag is requested by the user Then implementing verbose is simply a matter of changing the log level I think the Debug level is wrong for this purpose because its oriented towards developers whereas verbose is typically intended for troubleshooting by users There would be two ways to go about it Warn Notice Info Debug Warn Info Verbose Debug I realize that similar things have been requested before but I think my use case is actually a quite helpful one If your consideration is to keep the number of builtin log levels low I actually dont find a distinct Trace level to be useful seems like debug output to me But perhaps other people do What was the justification for that in the first place The corefmt have a big impact on code size and japaric has developed a smaller and faster alternative ufmt Can log consider supporting it Tracking issue for the implementation of See also x Initial implementation Integration with frameworks and loggers slog Zeroallocation conversion between slogValue and logkvValue We should be able to do zeroallocation conversion from log to slog but may need to allocate from slog to log tracing x Zeroallocation conversion between tracingValue and logkvValue in the event macro fern asynclog stdlogger x Some way to tell whether a Source has any keyvalue pairs femme envlogger antlog an experimental wrapper to prove out requirements x A way to get specific values Please suggest others to track Explore macro support x logmsg interpolated key value Integration with serialization frameworks serde x Conversion between serdeSerialize and stdfmtDebug See serdefmt x sval Micro benchmarks Documentation and examples Stabilization review Open questions Should Sourcecount return a Resultusize instead of a plain usize Hello all I was wondering if this crate would be open to a PR that adds pub fn deinitialize Option static Log The goal is that Id like to be able to write a crate for composing loggers but currently loggers arent constrained to expose the loggers they generate publicly so the only way to reliably compose them would be to have some means of pulling them out of your static mut LOGGER there is nothing prints out warnbut this is not implemented yet i got nothing on terminal