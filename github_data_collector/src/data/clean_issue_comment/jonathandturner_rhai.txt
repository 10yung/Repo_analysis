tried to use registerfn code compiles without errors but when i use the function i registered in code i got an error from the engine saying there is no such a function same error as when i ran it without the registerfn statement Tried doing it like this too RegisterFnregisterfn mut engine name func but still same results Also could not get the eval to return array from the script something about no clone for f might be a rust problem but work around should be built in the language for returning arrays The idea of the language and the syntax and the way you use it in code looks super cool and lightwieght and perfect for what Im trying to do but honestly without a working registerfn or returning arrays there really isnt any way to get useful output from this engine thus rendering it useless Thanks for making it but just thought id let you know my experience Sadly Engine is neither Sync nor Send which makes it difficult to use in things like game engines where theres a lot of concurrency Im not sure if thats easily doable because rhai seems to heavily depend on boxed closures and just requiring a F Sync Send would probably break a lot of code Sorry if this question already asked but I cant understand how can I put for example string to the scope Im trying to make something like string parser that will get strings as input and parse them by user script in rhai Thanks UPDATE So it is finally works As I understood I can write a function in user script and eval this script by the engine After that the function will be available to be called by the callfn with my params Hello I got an error at compile time Here are the details rustc version rustc fc f b cargo version cargo d a a Cargotoml package name grokls version authors Anton D Stavinsky edition dependencies grok serdejson rhai Compile error Compiling rhai v error E multiple applicable items in scope homestavinskycargoregistrysrcgithubcom ecc db ec rhai srcanyrs let boxed selftypeid multiple typeid found note candidate is defined in the trait anyAny homestavinskycargoregistrysrcgithubcom ecc db ec rhai srcanyrs fn typeid self TypeId help to disambiguate the method call write anyAnytypeid self instead note candidate is defined in the trait stdanyAny help to disambiguate the method call write stdanyAnytypeid self instead error aborting due to previous error For more information about this error try rustc explain E error Could not compile rhai To learn more run the command again with verbose I hit this one while experimenting with forloops rust for a in hellodolly if a hello break Which one would expect to work from exposure to other dynamic languages However is not defined for integerstring so we get a complaint I feel that needs special treatment if the types are different then it will always return false otherwise match the desired type exactly Not a difficult thing to do and faster than checking the whole overloaded set of functions but deserving of discussion The other option is to move towards strict static typing but that would take a good deal of work Not having error handling other than panicking is a problem when integrating nontrivial Rust code with Rhai This proposal basically adds unchecked exceptions so that functions can terminate script execution with a clean error First EvalAltResult gets a new variant ErrorRuntimeString A userdefined function may throw a Rhai exception by returning a ResultTEvalAltResult a Rhai function may call a predefined throw function Implementation is fairly straightforward We keep a map of type ids for all ResultTEvalAltResult of interest providing a closure that can match this for each specific T and return a ResultBoxAnyEvalAltResult which Rhai passes on These closures are created in registertype finally no longer a noop There will be some overhead with doing a hash lookup on all returned values and with reboxing exception values This is implementable now as an incremental step towards either Ruststyle explicit result handling or catchable exceptions Ive been playing with generating better error messages examples cargo run example repl f error Function not found f array x error Variable not found x error Function not found i f Fairly minimal changes mostly to how errors are displayed Any interest in a PR in the first case could indicate that there is no such function f We can dump all the overloaded functions matching a name but that might be too noisy Is it like a stack I see documentation on how to define structs in Rust and then make them available for use in Rhai These structs can have fields that are accessible with dot notation eg let foo newts newts is a Rustdefined fn that returns a Rustdefined struct foobar Is there any way to create an object in Rhai without first having to define it in Rust Im looking for something like Javascripts objects which allow you do something like this var foo bar foobar Is this on the roadmap for Rhai Just a tracking issue for projects Apparently Ive got the first published crate that uses Rhai as a dependency 