My XML request looks like this ns MyRequest ns referenceA request to my endpointreference ns MyRequest I believe it should be modeled in SwaggerOpenAPI spec as follows MyRequest type object properties reference type string xml name reference xml prefix cs namespace Is it possible to annotate my MyRequestjava class appropriately using JAXB or Swagger annotations to get the prefix and namespace entries in the generated OpenAPI spec I tried this but the namespace is not appearing in the generated OpenAPI spec Further I cant use that the XmlRootElement annotation to specify the prefix XmlRootElementnamespace public class MyRequest omitted Home type object properties homeaddress description its the home address ref componentsschemasAddress Office type object properties officeaddress description its the office address ref componentsschemasAddress This is a kind of swagger I want to generate with annotations where I can have specific descriptions for home and office addresses Is there anyway swaggerui will read this description for ref This is one of the solution I found but there is no way to generate it with annotations Thanks Hi there I am working with the annotations How to create operations that refers to an implementation of some class like Schemaimplementation offering the ID field in case of a PUT and hiding the ID field in case of a POST Since ID generation in POST should be up to the server A PUT should result in representation with GET so ID management is up to the client processing a create or update at server side A successful PUT of a given representation would suggest that a subsequent GET on that same target resource will result in an equivalent representation being sent in a OK response For POST I like to have something like SchemaimplementationMyClassclass hiddenid for PUT the full SchemaimplementationMyClassclass is ok I know that I can set Hidden in MyClassjava but this will disable the field in both PUT and POST I cant set it to ReadOnly on MyClass level as well since PUT needs to write the field Ive two JsonNode in each endpoint Each of those two can be anyof two other DTOs being all four DTOs different from each other My problem is that the JsonNode in all class is mapped for the first DTO pair it reads So all other endpoints have a reference to this two DTOs and the others are disregarded How can I correct this Hello Is there any method to hide extended parameters of a superclass I cant change superclass because it is third party dependency So I can change only my class My class public class AA extends BB private String feald public String getFeald return feald public void setFeald String feald thisfeald feald Third party class public class BB private String feald private CC cc public CC getCc return cc public void setCcCC cc thiscc cc public String getFeald return feald public void setFeald String feald thisfeald feald I want to ignore parameter cc Could you help me pls Seems that some classes are duplicated from swaggerjaxrs to swaggerjaxrs servletinitializer ioswaggerv jaxrs integrationJaxrsAnnotationScanner ioswaggerv jaxrs integrationJaxrsApplicationAndAnnotationScanner ioswaggerv jaxrs integrationJaxrsApplicationAndResourcePackagesAnnotationScanner ioswaggerv jaxrs integrationJaxrsApplicationScanner ioswaggerv jaxrs integrationJaxrsOpenApiContext ioswaggerv jaxrs integrationJaxrsOpenApiContextBuilder ioswaggerv jaxrs integrationOpenApiServlet ioswaggerv jaxrs integrationServletConfigContextUtils ioswaggerv jaxrs integrationServletOpenApiConfigurationLoader ioswaggerv jaxrs integrationServletOpenApiContextBuilder ioswaggerv jaxrs integrationServletPathConfigurationLoader ioswaggerv jaxrs integrationSwaggerLoader ioswaggerv jaxrs integrationXmlWebOpenApiContext I dont see any configuration of shading or jarjaring in modulesswaggerjaxrs servletinitializerpomxml and there the sources for this are missing in the swaggerjaxrs servletinitializer sourcesjar so that makes me thing this was done manually Any explanation as to why was this done and what purpose does it serve To generate the appropriate mapping for a discriminator of a parent class we are required to add the discriminatorMapping property to Schema which is almost always redundant if the class already has a JsonSubTypes annotation As the discriminatorProperty is read from the JsonTypeInfoproperty can the discriminatorMappings also be read from the JsonSubTypes if available As a workaround I have registered a CustomModelResolver and extended the method resolveDiscriminator as follows java Override protected Discriminator resolveDiscriminatorJavaType type ModelConverterContext context Discriminator discriminator superresolveDiscriminatortype context if discriminator null discriminatorgetPropertyName null discriminatorgetMapping null discriminatorgetMappingisEmpty JsonSubTypes jsonSubTypes typegetRawClassgetDeclaredAnnotationJsonSubTypesclass if jsonSubTypes null ArraysstreamjsonSubTypesvalueforEachsubtype discriminatormappingsubtypename RefUtilsconstructRef contextresolvenew AnnotatedTypetypesubtypevaluegetName return discriminator Additional Info Using the swaggermavenplugin v for generating the OAS files during the compile phase The JsonIgnoreProperties hides the variables from appearing in the swagger document which is expected But in cases where the variable has allowGetters true property set shouldnt the variable be displayed in response example values NOTE JsonIgnoreProperties was added not for swagger purposes in my code but for functional use to avoid deserialization therefore I cant use JSONVIEW instead of JsonIgnoreProperties Can this feature be supported Given an object like this java public class PlanetName JsonValue private final String value JsonCreator private PlanetNameString value thisvalue value public static PlanetName valueOfString value return new PlanetNamevalue public String getValue return value Override public String toString return value Using it as a parameter of another object java public class Planet private PlanetName name public PlanetName getName return name public void setNamePlanetName name thisname name I expect a schema like this yaml components schemas Planet type object properties name type string Instead I get a schema like this yaml components schemas Planet type object properties name ref componentsschemasPlanetName PlanetName type object properties value type string The resulting schema is incorrect and misleading I am running my APIs with servlet path restapis and Swagger UI with servlet path My autogenerated restapisopenapijson renders in Swagger UI but the paths are wrong Rendered URL Expected URL How to fix it so my APIs are rendered as restapisresource instead of resource Should I somehow override Swagger Core to autogenerate restapisopenapijson with full paths containing restapis prefix Should I somehow override Swagger UI to autorender restapisopenapijson with full paths containing restapis prefix Some other solution I am launching Jetty v from a POJO Context path is and there are two servlets restapis Jersey Servlet with init parameter jerseyconfigserverproviderclassnamesioswaggerv jaxrs integrationresourcesOpenApiResourcecomexamplerestResource Jetty Default Servlet with welcome files indexhtml and context base unpacked Swagger UI directory The unpacked indexhtml is modified to replace the default URL similar to how is substituting it Original url Replacement url In Swagger UI I expect to see restapisresource but it shows resource instead If I use Swagger UI to try to execute that API Swagger UI displays HTTP response from the API