Hi Thank you for your amazing book I have learned a lot from it When I read the code in httpserverv I found the use of RWMutex was wrong In the method RecordWin we need to modify the value of the store so it should be unsafe in concurrency and use a write lock In the method GetPlayerScore we just read the data so we can use a read lock The situation was also mentioned in I have fixed it now Nice repo great attention to detail Mostly Go file names should be withunderscoresgo eg filesystemstorego not FileSystemStorego Block comments should be full sentences ie include trailing punctuation Hi great tutorialbook thank you so much Anyways about into the page on Maps I think the code in gitbook doesnt acknowledge necessary chage to assertError if got nil part needs to go Github version is fine Once again thank you for the wonderful Go intro Probably another way of synchronizing access that is worth mentioning here would be using syncatomic package which is arguably more suitable for given problem and is more performant by its nature compared to the mutex Inc the count func c Counter Inc atomicAddInt cvalue The course states Pointers let us point to some values and then let us change them So rather than taking a copy of the Wallet we take a pointer to the wallet so we can change it func w Wallet Depositamount int wbalance amount func w Wallet Balance int return wbalance The difference is the receiver type is Wallet rather than Wallet which you can read as a pointer to a wallet Try and rerun the tests and they should pass Now you might wonder why did they pass We didnt dereference the pointer in the function like so func w Wallet Balance int return wbalance and seemingly addressed the object directl However in this example it seems that you only need the pointer in Deposit which is changing the balance and not in Balance which is merely returning it Indeed if you take out the asterisk in the former it breaks but if you take it out in the latter it still passes Given you highlight the pointer in Balance rather than in Deposit this could do with explainingrevising Thank you so much for a brilliant course Not sure whether you want to mention this as a strategy but in the arrays and slices section you have Its important to note that reflectDeepEqual is not type safe the code will compile even if you did something a bit silly To see this in action temporarily change the test to func TestSumAllt testingT got SumAll int int want bob if reflectDeepEqualgot want tErrorfgot v want v got want What we have done here is try to compare a slice with a string Which makes no sense but the test compiles So while using reflectDeepEqual is a convenient way of comparing slices and other things you must be careful when using it That is really good to know but it might be worth adding that if instead of using v you had used the stricter d in tErrorf then the test would not compile as it was expecting integers but got a string So type checking your fmt output may be a good practice to recommend when testing numerical slices and arrays particularly when using reflectDeepEqual Totally new to Go and working through your brilliant curriculum Let me know if I missed something obvious or using d has a gotcha I dont know about The issue I have is with the code sample at this step in the Roman Numerals kata I have go type RomanNumeral struct Value int Symbol string type RomanNumerals RomanNumeral func r RomanNumerals ValueOfsymbol string int for s range r if sSymbol symbol return sValue return later func ConvertToArabicroman string int total for i i lenroman i symbol roman i if i lenroman symbol I nextSymbol roman i potentialNumber string bytesymbol nextSymbol value RomanNumeralsValueOfpotentialNumber if value total value i else total else total return total I get an error that not enough arguments in call to method expression RomanNumeralsValueOf have string want RomanNumerals string Why does the RomanNumberalsValueOf method require a RomanNumerals as the first argument The problem is fixed when I pass a variable of the type RomanNumeral as the first argument go var allRomanNumerals RomanNumeral M CM D CD C XC L XL X IX V IV I value RomanNumeralsValueOfallRomanNumberals potentialNumber When I do this the tests still fail Shouldnt syncRWMutexRLock be used in the GetPlayerScore method and syncRWMutexLock in the RecordWin method Can not open the link above Should be parallelized Great book btw jbirmslearngowithtestsmaster ag paralell concurrencymd We have paralellized the part of the code that we wanted to make faster while 