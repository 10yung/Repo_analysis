I have recently realized while working on a small testing tool one cannot specify full endpoint URLs for the API I had to use other available APIs and copy over encoding flow as a workaround I hope I havent missed any other existing way to do this Endpoints are defined as constants and exposed public APIs use those Since now we have other projects such as Thanos Context one can put a proxy in front of these APIs that implements the same API Id like to have the ability to configure endpoints to use client library against compatible APIs Im happy to contribute to the project to make this happen beorn cc squat OpenMetrics makes the info metric pattern explicit as its own type In v we can add the type and emulate it for the existing Prometheus format by creating the usual info metrics with value OpenMetrics has the option of marking creation times of metrics As this doesnt happen as part of some st class metadata but as an additional time series with a magic suffix created we cannot just transparently support it but have to make it configurable Either dont use them at all or opt in use them but error out if a name collision happens OpenMetrics offers units as part of the metadata We can easily add them in the various Opts next to Help They would only be used if OpenMetrics is negotiated as the output format but they will also implicitly show up in protobuf cf OpenMetrics names counters without the total but adds the suffix in the metricname We need to come up with certain compatibility modes configurable somewhere TODO Copy the thoughts from me head into this issue Since v is using metricsproto as its internal data model we have to update it to include exemplars See for details This issue is more about the interface part Histograms and Counters need a good way of adding an exemplar connected to an Observe Inc or Add without adding much cruft to the interfaces TLDR Prometheus counters use atomic primitives which is slow If I didnt do something stupid the buffered counter implementation gives potenial speedup of x in hot loops across multiple goroutines and up to x speedup for local use The buffered version approaches you cant do it faster version Also may apply to other things like gauges Full version plus benchmarks duration levelinfomsgMetrics updatedtime T http superfluous responseWriteHeader call from githubcomprometheusclientgolangprometheuspromhttphttpError httpgo demonstrated problems if the compression middleware from the echo framework was used see The promhttpHandler his its own gzip handling Perhaps its inevitable to then not work with other middlewares handling compression which then should be clearly documented But perhaps there is also something middlewareunfriendly that could be fixed in promhttpHandler Purpose of this issue is to investigate how promhttpHandler interacts with certain middlewares echo framework but also others eg the NYTimes gzip handler and also find out if problems happen with other noncompressing middlewares In v we might be able to fix problems if there are any in the handler For v we might consider separating out compression if there are established middlewares handling compression nicely On the other hand the result could as well be that it is impossible to handle compression as a middleware without problems in certain situations and thus handling it in the current way might be just right The series call doesnt require a time it would be nice if we had some mechanism in the go API to not set a time I had opened towards this but Im not sure this is a great approach maybe we instead make the timeTime pointers