 Summary We should migrate the build from Travis CI to GtiHub Actions now that they are GA Steps to reproduce the behavior gosec version Go version output of go version Operating system Environment Expected behavior Actual behavior Summary Add some rules for regular expressions like Especially can introduce some security issues when validating data Summary If a source file imports C gosec doesnt analyse it Its the same issue as Steps to reproduce the behavior see file in attachment gosec gosec Including rules default gosec Excluding rules default gosec Import directory gosrcgaspackagereprorepro gosec Checking package repro gosec Checking file gosrcgaspackagereproreprotargetgo Results Golang errors in file gosrcgaspackagereproreprotargetgo line column undeclared name testFunction Summary Files Lines Nosec Issues gosec version gosec version Version Git tag v Build date T Z Go version output of go version go version go version go linuxamd Operating system Environment docker image from golang rootee aa afgosrcgaspackagereprorepro lsbrelease a No LSB modules are available Distributor ID Debian Description Debian GNULinux buster Release Codename buster rootee aa afgosrcgaspackagereprorepro uname a Linux ee aa af generic Ubuntu SMP Tue Sep UTC x GNULinux Expected behavior CGO must be supported Actual behavior all files which have import C are ignored gaspackagereprotargz Summary Go Modules are fun Reference issues Steps to reproduce the behavior With go outside of GOPATH go get githubcomsecuregogosecv go finding githubcomsecuregogosec v go finding githubcomsecuregogosec v go get githubcomsecuregogosecv githubcomsecuregogosecv invalid version module contains a gomod file so major version must be compatible should be v or v not v module contains a gomod file so major version must be compatible should be v or v not v As per The go wiki If the module is version v or higher the major version of the module must be included as a vN at the end of the module paths used in gomod files eg module githubcommymodv require githubcommymodv v and in the package import path eg import githubcommymodv mypkg This includes the paths used in go get commands eg go get githubcommymodv v Note there is both a v and a v in that example One way to think about it is that the module name now includes the v so include v whenever you are using the module name So I think it is that everything is not in a v folder but the tags are at v or the mod file doesnt have v and v import statements in the file Summary Gosec does not appear to respect build tags passed via the tags flag I have confirmed that my code can be built but gosec sees an error when building the codebase Steps to reproduce the behavior Code Samples hellogo package main import fmt func main fmtPrintlnhello from the vulnerable app DBUSER configprodgo build prod package main const DB localhost DBUSER prod DBPASSWORD hhend dyyydbh psNSSZJSM Just to note the above password isnt real I am simply trying to trigger gosec into a issuing a finding gosec version Head of master Go version output of go version go darwinamd Operating system Environment OSX Expected behavior It successfully uses the build tag Actual behavior buildtagsgoapp gitsupportgosecoptions gosec tagsprod gosec Including rules default gosec Excluding rules default gosec Import directory somepathbuildtagsgoapp gosec Checking package main gosec Checking file somepathbuildtagsgoapphellogo Results Golang errors in file somepathbuildtagsgoapphellogo line column undeclared name DBUSER Summary Files Lines Nosec Issues If I run go build tags dev I get a successful build Summary I tested this for G but inspected the code for G and believe it has the same issue G will detect SQL string formatting when I have fmtSprintfSELECT FROM TEST UNION s SELECT FROM test in my code However it will not detect when I have fmtSprintfselect from test union s select from test in my code I believe this is a bug See and Steps to reproduce the behavior Create a file sqlgo with the following content package main import fmt func sqlConstructionLowercase string return fmtSprintfselect from test union s select from test func sqlConstructionUppercase string return fmtSprintfSELECT FROM TEST UNION s SELECT FROM test func main fmtPrintlnsqlConstructionLowercase fmtPrintlnsqlConstructionUppercase Run gosec on it vagrantct testdevgosecsql gosec gosec Including rules default gosec Excluding rules default gosec Import directory homevagrantdevgosecsql gosec Checking package main gosec Checking file homevagrantdevgosecsqlsqlgo Results homevagrantdevgosecsqlsqlgo G SQL string formatting Confidence HIGH Severity MEDIUM fmtSprintfSELECT FROM TEST UNION s SELECT FROM test Summary Files Lines Nosec Issues vagrantct testdevgosecsql Only the uppercased version is shown as a problem Both should be gosec version VERSION GIT TAG BUILD DATE T Z Go version output of go version go version go linuxamd Operating system Environment Ubuntu LTS Expected behavior Lowercased SQL keywords are still inspected for SQL string formatting and SQL string concatenation problems Actual behavior SQL strings composed of lowercase SQL keywords are not inspected for SQL string formatting and SQL string concatenation problems Summary The sql rule is using only a regexp expression to identify when is a SQL query into a constant string This generates quite some false positives See issues and It would be great to improve its accuracy There are various options to achieve this Improve the heuristic of the rule by checking more acuratly the context see gcmurphys suggestions in the comments below Investigate if a SQL parser can validate additionally the syntax in certain use cases when the query can be reconstructed possible SQL parse Steps to reproduce the behavior gosec version Go version output of go version Operating system Environment Expected behavior Reduce the number of false positive warnings generated by the rule Actual behavior It doesnt really differentiate between a plain string starting with a SQL keyword eg SELECT and a valid SQL query Summary The problem I encountered is when I am scanning this code with Gosec package main import log osexec func RunCmdcommand string cmd execCommandcommand err cmdStart if err nil logFatalerr logPrintfWaiting for command to finish err cmdWait func main RunCmdsleep Gosec thinks there is command injection and I launched the process with a variable but the command variable in the function RunCmd is nothing but a hardcoded string I get an error from Gosec G Subprocess launched with variable Confidence HIGH Severity MEDIUM execCommandcommand gosec version Go version output of go version go version go darwinamd Operating system Environment macOS Mojave Expected behavior The problem I noticed here is that Gosec doesnt traverse the three back to the RunCmd function call but instead tries to resolve the command variable only in the context of the function Actual behavior It would be great if Gosec understands better the context not only of the function but the function call with its arguments Summary In the resolvego file there is the TryResolve function which is described as follows TryResolve will attempt given a subtree starting at some ATS node to resolve all values contained within to a known constant The problem is that when its resolving an astIdent it calls the resolveIdent function Then in the resolveIdent function if the object type is a variable the function looks at the object declaration and then it checks if its a known constant by calling TryResolve The problem is that this is a variable which can be changed multiple times For example in this code package main import log osexec func getConstant string return top func main run getConstant run top cmd execCommandrun err cmdStart if err nil logFatalerr logPrintfWaiting for command to finish err cmdWait logPrintfCommand finished with error v err the run variable is not a constant because it was initialized by the result of a function even though its value is changed to a hardcoded string Another example package main import log osexec func getConstant string return top func main run top run getConstant cmd execCommandrun err cmdStart if err nil logFatalerr logPrintfWaiting for command to finish err cmdWait logPrintfCommand finished with error v err Here run will be considered as a constant even though its value is changed by the return of a function Steps to reproduce the behavior gosec version Go version output of go version go version go darwinamd Operating system Environment macOS Mojave Expected behavior In the best scenario TryResolve when resolving a variable TryResolve will be called again on the last value of the variable or on the last assignment That way Gosec will know if its truly a constant Summary Some imports are currently blacklisted by hardcoding them in various balcklist rules I think that it would be nice to define a generic blacklist rule which is able to parse the blacklisted import paths from the rule config Steps to reproduce the behavior gosec version Go version output of go version Operating system Environment Expected behavior Actual behavior 