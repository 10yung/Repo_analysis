Hi I was just wondering how hard is to implementexpose some sort of mechanism to be able to create idling resources that wait for the coroutines to finish I can try sending you a PR if you point me in the right direction on what you think is the best way to do it I think itd be a great addition to the library Given a situation where UI elements depend on the AsyncController like progress bars while having to cancel tasks its necessary to know when a task was cancelled in order to hide progress and such Id like to suggest having the ability to cancel AsyncControllers individually Currently we need to cancel all the async on destroying Activity override fun onDestroy superonDestroy asynccancelAll With the new component called Lifecycle Reference link below we can skip it and the library can itself take care of it by understanding the lifecycle Refer Lifecycle Architecture Component When I try to execute several tasks in parallel my code looks ugly async await async await async await val it SystemcurrentTimeMillis while SystemcurrentTimeMillis it LogwExecuting coroutine Task val it SystemcurrentTimeMillis while SystemcurrentTimeMillis it LogwExecuting coroutine Task val it SystemcurrentTimeMillis whileSystemcurrentTimeMillis it LogwExecuting coroutine Task LogwExecuting coroutine All tasks completed Is any way to make parallel execution looks more elegant Something like this async awaitParallel val it SystemcurrentTimeMillis while SystemcurrentTimeMillis it LogwExecuting coroutine Task awaitParallel val it SystemcurrentTimeMillis while SystemcurrentTimeMillis it LogwExecuting coroutine Task awaitParallel val it SystemcurrentTimeMillis while SystemcurrentTimeMillis it LogwExecuting coroutine Task LogwExecuting coroutine All tasks completed Fragments from the supportv library are recommended for usage over native Fragments given they are always uptodate on bug fixes and when new features are added Plus it is more likely that someone will be using Support Fragments in their app rather than native Fragments WarningcometalabasyncawaitRetrofitExtensionsKt cant find referenced class retrofit Call WarningcometalabasyncawaitRetrofitExtensionsKtawaitSuccessful cant find referenced class retrofit Call WarningcometalabasyncawaitRetrofitExtensionsKtawaitSuccessful cant find referenced class retrofit Response WarningcometalabasyncawaitRetrofitExtensionsKtawaitSuccessful cant find referenced class retrofit Call WarningcometalabasyncawaitRetrofitExtensionsKtawaitSuccessful cant find referenced class retrofit Response WarningcometalabasyncawaitRetrofitExtensionsKtawaitSuccessful cant find referenced class retrofit Call WarningcometalabasyncawaitRetrofitHttpError cant find referenced class retrofit Response WarningcometalabasyncawaitRxExtensionsKt cant find referenced class rxObservable WarningcometalabasyncawaitRxExtensionsKtawait cant find referenced class rxObservable WarningcometalabasyncawaitRxExtensionsKtawait cant find referenced class rxobservablesBlockingObservable WarningcometalabasyncawaitRxExtensionsKtawait cant find referenced class rxObservable Warningthere were unresolved references to classes or interfaces WarningException while processing task javaioIOException Please correct the above warnings first ErrorExecution failed for task apptransformClassesAndResourcesWithProguardForRelease Job failed see logs for details There is a conflict when you include an AndroidManifestxml in your library release ErrorExecution failed for task appprocessDebugManifest Manifest merger failed Attribute applicationallowBackup valuefalse from AndroidManifestxml is also present at cometalabasyncawaitasyncawait AndroidManifestxml valuetrue Suggestion add toolsreplaceandroidallowBackup to application element at AndroidManifestxml to override It would be nice if there was an easy builtin way to await on another async coroutine As is possible in C with Task and TaskT