 wslocalhost data XSHE data XSHE PATHPARAM data XSHE IOUHttp HttpBindserver localhost var wsUri wslocalhost data XSHE websocket new WebSocketwsUri Great library thank you I need the ability to from an outside source perhaps HTTP or some RPC call given an ID that matches with the session send a message to the WebSocketServerWorker actor This is quite similar to this issue I see two obvious ways of accomplishing this Upon connection when the HttpRequest comes in we disect the request perform auth etc and create the actor with its name set to whatever session ID we decide We could then lookup an actor via its path and send it messages This has proved impossible so far Here is my sample code scala class WebSocketHttpServer extends Actor with ActorLogging def receive case HttpConnectedremoteAddress localAddress val conn contextactorOfPropsclassOf WebSocketSessionWorker client sender HttpRegisterconn which I modified to become scala class WebSocketHttpServer extends Actor with ActorLogging def receive case request HttpRequest val client sender disect the request and create a session ID we can associate with val conn contextactorOfPropsclassOf WebSocketSessionWorker client name ABC conn request case HttpConnectedremoteAddress localAddress self HttpRegisterself The issue is that when the request is forwarded to the WebSocketSessionWorker when it executes the Handshake it sends the UpgradeServer message BACK to the WebSocketHttpServer not the WebSocketSessionWorker Not sure why Gave up Edit I have solved this issue i didnt know about the forward method on ActorRefs Retains the sender reference correctly The second approach would be to construct WebSocketSessionWorkers with some sort of ActorCommunication actor that it then registers with and inside this ActorCommunication actor Communication would then go through this actor as it would maintain state around all WebSocket sessions currently going on Thoughts I want to respond to a PingFrame manually The current implementation auto responds with a PongFrame Id like to respond with extra status information At the moment I can achieve this just using my own case classes wrapped around TextFrames Please consider the following scenario users could decide to create their ActorSystem passing a Config object different than the applicationconf simply because Akka allows it scala implicit val system ActorSystemmySystem ConfigFactoryloadmySystemconf spraywebsocket package object is actually loading the default applicationconf file regardless the above decision and without considering the ActorySystem could have been configured with a different Config object scala package object websocket val config ConfigFactoryloadgetConfigspraywebsocket That will certainly lead to a misconfiguration making users notice unexpected behaviour of spraywebsocket By reading The WebSocket Protocol specification at section Subprotocols Using the WebSocket Protocol I can understand the client CAN optionally request that the server use a specific subprotocol by including the SecWebSocketProtocol field in its handshake If it is specified the server NEEDS to mandatory include the same field and one of the selected subprotocol values in its response for the connection to be established Unfortunately neither the most recent tag actually v nor the master branch are compliant with that piece of specification As quick test if you try the following Javascript in your HTML page javascript new WebSocketwindowlocationhost aSubprotocol your browser will almost certainly throw an exception which could look like the following WebSocket connection failed Error during WebSocket handshake Sent nonempty SecWebSocketProtocol header but no response was received I deployed the sample web sokcet server code in cloud foundry My web socket client is not able to connect following is the url used to connect to web socket server wsscfAppInstance Basically handshake is not happening It would be great if there were a means to name the connection handler actor based on some information available in the upgrade request Im thinking for example of a custom header that provides an ID and that ID presumably URL encoded can be used as the name of the connection handler actor The problem of course is that the connection handler actor already exists and I dont think theres a way to name the actor after the fact So presumably the implementation would create a new connection handler with the right name register it as the handler and stop the existing connection handler The goal is for clients to be able to identify themselves and for the application to be able to use Akka routers ActorSelections etc to communicate with specific clients Im assuming thats what the send methods are for Does this make any sense Is there a straightforward way to do it Running into a strange issue Ill try to summarize as briefly as possible I have two servers Monitor Server M is receiving data from S once per second over a spraywebsocket connection Browser client connects to M over another web socket connection As S pushes data to M its pushed out to the browser client If the browser client disappears I simulate it by quitting my VPN client that browser connects to M over the data from S fails to be written at M over the web socket connection it had with the browser client Brower websocketvpn Monitor websocket Server Spray logs warnings endlessly it doesnt appear that the connection gets cleaned up WARN ReportingActorSystemakkaactordefaultdispatcher scsHttpServerConnection Slf jLoggerscala CommandFailed for TcpWrite text frame node uptruemetricsbuildI WARN ReportingActorSystemakkaactordefaultdispatcher scsHttpServerConnection Slf jLoggerscala event pipeline dropped CommandFailedWriteByteString NoAcknull I dont get any unhandled messages at my WebSocketServerConnection worker or my web socket server actor that created the worker no indication that the connection is unavailable Have you witnessed this issue 