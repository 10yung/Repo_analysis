Hi Emily thanks for creating the package What if the funnel join only matched events within groups The reason I ask is because in my domain Im more interested in funnels with deadlines rather than funnels with gaps Let me give you an example Lets say I only want to count the firstafter event if it occurs in the same calendar week r librarydplyr Attaching package dplyr The following objects are masked from packagestats filter lag The following objects are masked from packagebase intersect setdiff setequal union librarytidyr librarypurrr librarylubridate Attaching package lubridate The following object is masked from packagebase date libraryfunneljoin Attaching package funneljoin The following object is masked from packagestats filter logs tribble date event upload print upload print upload mutatedate asDatedate mutateuser Following the business constraint about the same week deadline the upload should not convert to a print because there is no firstafter within the same calendar week I hoped this might work r logs mutatedeadline floordatedate week groupbydeadline funnelstart momenttype upload moment event tstamp date user user funnelstep momenttype print type anyfirstafter Adding missing grouping variables deadlineupload A tibble x Groups deadlineuploadx dateupload user deadlineupload deadlineupload dateprint date dbl date date date with more variable deadlineprint date My thought was that since I did groupbydeadline it would only join on the firstafter events within the same deadline value Unfortunately thats not the case because dateupload is being joined to dateprint In fact Im not sure whats it is doing Maybe its useful in some other way Heres my workaround r logs mutatedeadline floordatedate week nestevents deadline mutateconversions map events funnelstart momenttype upload moment event tstamp date user user funnelstep momenttype print type anyfirstafter summarizeconversionsdateprint unnestconversions selectevents A tibble x deadline nbusers nbconversions pctconverted date int int dbl supCreated on by the reprex package v sup Its not bad but a little messy What are your thoughts with funnelstart and funnelstep s only matching events within the group Is it even possible Does it match how you think it should work Current example has outdated arguments For example you have a courseid and want to link notification to course page view to course start robinsones First off great package It makes creating and analyzing funnels clean and easy Based on my navigation of the packages API I had some suggestions You might want to make landed and registered datasets in the package so users can get started with the examples without having to define them This can be extended to define outofmemory versions of the data by taking advantage of dbplyrsrcdbi The notion of a join type is great and factors in the multiple scenarios that one might run into However I had trouble visualizing the execution and how each type results in a different output compared to the pure version of the join function So I put together a helper function that allows one to visualize the differences Based on this here is my understanding of the working of afterjoin Join the tables using the regular version of modejoin Filter out all records where eventx occurs before eventy For each userid only retain versions of events specified by type anyany will retain all records in Step firstfirst firstfirstafter and lastbeforefirstafter will retain only ONE record per user Is my understanding correct It might be useful to add something like this to the documentation so it is really clear to users how these afterjoins work details summaryafterjoinallsummary r afterjoinall functionx y by mode inner types c firstfirst firstfirstafter lastbeforefirstafter anyfirstafter anyany bytype functiontype afterjoinx y mode mode type type mutatetype Y joinfun matchfunpaste mode join alltypes types purrrmapbytype joinfunx y by by Reduceleftjoin alltypes init details useridtimestampx timestampy firstfirst firstfirstafter lastbeforefirstafter anyfirstafter anyany whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark NA NA NA NA NA NA whitecheckmark whitecheckmark whitecheckmark whitecheckmark NA NA NA NA NA NA NA NA NA NA whitecheckmark whitecheckmark whitecheckmark whitecheckmark whitecheckmark NA NA NA NA NA whitecheckmark whitecheckmark NA whitecheckmark whitecheckmark NA NA NA NA whitecheckmark NA NA whitecheckmark whitecheckmark whitecheckmark NA NA NA NA whitecheckmark Sorry to open an issue for this but I just wanted to highlight a project with similar goals in traildb trck from AdRoll Both are written in C but have mature python bindings so it would be possible to write an R interface with reticulate Traildb is neat because it allows for complex queries against timestamped events in a highly compressed data format and being written in C its pretty fast Well need to take out datacampr tests before submitting to CRAN The remote table join returns rows while when collected it returns more than librarytidyverse librarydatacampr libraryfunneljoin regs tblviewssnowplowexperimentstarts afterinnerjointblviewssnowplowregistrationevents byuser domainuserid bytime croottstamp registeredat type withingap dt asdifftime units days filterroottstamp regs collect mutateuserid asintegeruserid afterjointblmainuserexercises filtercompletedat mutateuserid asintegeruserid collect byuser userid bytime croottstamp completedat type anyfirstafter mode inner count regs afterjointblmainuserexercises filtercompletedat byuser userid bytime croottstamp completedat type anyfirstafter mode inner count Another pattern I do is filter for users who saw the homepage and then completed at least three exercises Does it make sense to build support for making a minimum number of event s happening We could default to just one 