When we want under the same process execution time to reset reuse an already used remote Under our usage of ProtoActor this FIX a bug You may remove comments if you wish while merging back on your repo side if you validate the PR Thanks Hello Im trying to use ProtoActor in a WPF application targeting net core I created a RootContext in the app startup and spawn an actor When the actor gets the Started message it arrives on a thread pool thread thread as expected Then I spawn another actor WithDispatchernew ProtoMailboxCurrentSynchronizationContextDispatcher That actor receives Started on the UI thread thread as expected then sends a message using contextSend to the first actor The first actor receives the message on the UI thread instead of thread pool When I receive the message and inspect the context in the debugger it shows contextpropsDispatcher is ThreadPoolDispatcher yet ThreadCurrentThread shows that were in the main thread thread Any idea why the first actor would receive on the UI thread and not the thread pool I cannot seem to figure out how to make actors receive messages on the thread pool Ive even tried WithDispatchernew ProtoMailboxThreadPoolDispatcher but that has no effect Basically it seems any message sent from a UI actor always gets received on the UI regardless of the dispatcher the receiver was spawned with I wonder if Props class should be actually sealed In my case I have some custom spawn logic where it would be nice to intercept Props when using ISpawnContext I would like to narrow down my Props just to specific class type so to have something like this class MyPropsTActor Props where TActor IActor So when I intercept Spawn call I could cast props against MyProps to see if my custom logic can be executed and to get custom parameter So I can process the response on the same scope of the sendercaller pidTellmessage delegate oncomplete or in Go contextSendpid message func oncomplete the problem I was facing was Im using Unity D on the callerclient and Go on the server side From the server side I cant contact the client if they doesnt use real IP which leads to few solution whether callback exists create my own proxy using other protocol TCP or others which have nd Actor that receive the response of the st Actor and send back to the client I am considering using headers to store a bearer token for the user who is responsible for a particular message I have used a similar approach in Orleans and it works well Each ActorGrain can check the token to see if the user is authorised to perform the action or enable features I am wondering if there is a different way to handle this in the protoactor world It would be very useful to have these headers available to the Started message too so there is context around who started the actor and a decision can be made about where to retrieve persisted data from It seems at least for Actors spawned by ClusterGetAsync there isnt a way to pass headers would it be acceptable to pass any headers that are available on the sender context by default or is this an antipattern in your opinion I made a simple test kit to help me test some of my actors It might not be perfect but i thought it might be a good start Its very similar to the Akkanet kit in terms of what you can test with it although some names might be slightly different Hi there Would you appreciate if I create some F examples My personal target is to learn photoactor and popularize wonderful programming language Already learned that actor goes to the endless Restart loop on unhandled errors I recently started looking into whats upcoming in NET Core in particular the new ability to host gRPC services within ASPNET Core I did a small requestreply PoC with a normal ProtoRemote client application and an ASPNEThosted server application see and while I did get it to work there are a few things which dont feel natural A few thoughts that occured to me that might be interesting to discuss The biggest pain of all is the way ProtoRemote is designed RemoteStart is not usable at all since it will spin up a separate gRPC server One thing this highlights is the fact that the concerns of hosting ProtoRemote and of wiring it up are completely mixed into the static Remote class Perhaps we should pick up again and see how we can simplify the design as well as make it naturaleasy to use in the NET Core hosting infrastructure The static ProtoLog class goes very much against the typical way of handling logging mainly due to the fact that its static and not injected As I recall we were never quite happy with this design originally but went with it because going the injection route might force too much of a change on the rest of the API surface The MicrosoftExtensions packages do seem to be part of the core infrastructure of NET Core nowadays We made the decision some time ago that we did not want to depend on those in ProtoActor in order to keep it as lightweight as possible Is this a decision we might want to reevaluate given how the landscape looks today Is the Net version of ProtoActor dead The reason I ask Gitter chat goes unresponded An issue opened here almost a month ago goes unresponded No commits in months Large swaths of documentation pages are skeletons Releases Orleans community seems vibrant in comparison but its also very heavy compared to ProtoNet Akka is out of the question for usa s the system screams for virtual actors Ive have a LoveHate relationship with Service Fabric I love to hate it I plan on evaluating both ProtoNet and Orleans but if this is dead and none of the original contributors are planning on coming back to it Ill probably bail public async Task ReceiveAsyncIContext context throw new Exception when exception occurs on the IActorReceiveAsyncIContext context how can I catch this exception or message contextMessage deliver only restarting no reason thanks