Perhaps as part of the CI Something like this as suggested by eastlondoner docker run e NEO JLABSPLUGINS apocgraphqlgraphalgorithms neo jNEO J VERSION echo success if it runs without error exit code all good running that once a day in TC should not be tricky Hi Im trying to get Map to work as a parameter type MutationType test typequery String id ID weights Map W X String cypherstatement RETURN weights I get the error javalangIllegalArgumentException Unknown field type Map any advice Thanks Expected feature example type Query getUserRankedCategoriesuserName String Path cypher statement MATCH path userUsername userName ratedRATED categoryCategory RETURN path with something like type Path user User category Category rated Rating type User name String type Category name String type Rating relation name RATED from User to Category value Int but I get this error when I put a relationship type in another type like this type Path user User category Category rated Rating throw new ErrorThe concatfieldnamevalue field on the concattypeName type uses the concatrelatedAstNodenamevalue n but concatrelatedAstNodenamevalue comes from concatfromName and goes to concattoName ReferenceError field is not defined at validateRelationTypeDirectedFields homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at handleRelationTypeDirective homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at handleRelationFields homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at ArrayforEach anonymous at augmentTypeMap homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at makeAugmentedExecutableSchema homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistaugmentjs at makeAugmentedSchema homemaieulDesktopdevnexusbackendapinodemodulesneo jgraphqljsdistindexjs at Objectanonymous homemaieulDesktopdevnexusbackendapisrcindexjs at Modulecompile internalmodulescjsloaderjs I havent found any way to return paths yet using the cypher directive and even custom resolvers since we must specify a returned object in the typedefs Im not very experienced with neo j in general but I feel that the power of neo j and of graph databases in general comes from the ability to create merge update delete and query a certain patternpath made of nodes and relationships consistently It seems like right now I can get nodes on their own relationships on their own but not them linked together So it takes many queries or different tricks to get the paths that I want which I fear might be hard to keep consistent when trying to use filter or Ordering and seems a lot less performant than being able to return a path directly I might be doing it wrong but I havent found any solution in the docs Any solution right now is more than welcome But if there are none could it be added to the list of future features I think it would be very useful and a greater developer experience PS Ill post what Ive been able to achieve below even if it doesnt work properly or even at all if it can help towards achieving this feature Currently when creating a relationship with properties using the syntax below It is only possible to add the relationship or to remove it through autogenerated mutations I think it would be nice to be able to MERGE and UPDATE these kinds of relationships with properties through autogenerated queries type Rating relation name RATED from User to Category value Int It seems to me that currently autogenerated update mutations can update nodes in the neo j database only by retrieving the first item set in the schema Here is an example of my schema type Business id ID name String address String city String state String reviews Review relationname REVIEWS direction IN categories BusinessCategory relationname INCATEGORY direction OUT and how the mutation works UpdateBusiness So here the update would be possible only by providing an id But what if I dont have access to the id in my application Currently I have to create a custom resolver to solve the issue Wouldnt it be nice if we could run updates according to filters and not only to the first property in the type definition Is there a way to disable autogenerated query types and autogenerated mutations I created a readonly user on Neo j It could read data but not write data in Neo j browser it couldnt run call graphqlidl either However I could use this user in a GraphQL client like Insomnia then do a POST to graphqlidl with schema payload and successfully updated schema on the server Its very serious issue please fix this ASAP thanks I would like to keep some information as property on relations is it possible without using custom cypher queries or is it in the roadmap and how far We are seeing some strange behavior with null fields and fragments Here is an example graphql fragment ChildPackage on Package qid nonnull field name address qid And this is the query graphql query Recipient qid name packages ChildPackage packages ChildPackage packages ChildPackage In this particular example we expect to get two items in the top level packages response and then the follow up packages to be empty However what we get are in the top level packages is an array with two null values in it However when we expand fragment into the query like this graphql query Recipient qid name packages qid nonnull field name address qid packages ChildPackage packages ChildPackage Then we get the expected response two Package entities with empty packages arrays returned in them Why is the response between a fragment and its exact same fields different Also the double null response seems incorrect maybe it is related to the null expansion issue in Any thoughts Schemas with typed relation queries are not parsed properly when published to the Neo j graphql endpoint using CALL graphqlidl Given a graphql schema schema query Query type Person name String born Int movies ActedIn type Movie title String released Int tagline String actors ActedIn type ActedIn relationname ACTEDIN from Person to Movie roles String type Query movieByTitlesearchTerm String Movie cypherstatementMATCH nMovie WHERE ntitle CONTAINS searchTerm RETURN n and a graphql query query SearchMovies movieByTitlesearchTerm Polar Express title actors Person name roles When the schema is published via neo jgraphqljs eg grandstackstarter we get the expected result returning relationship properties roles data movieByTitle title The Polar Express actors Person name Tom Hanks roles Hero Boy Father Conductor Hobo Scrooge Santa Claus when the schema is published via the plugin using CALL graphqlidlschema the query fails data null errors message Validation error of type FieldUndefined Field Person in type ActedIn is undefined movieByTitleactorsPerson locations line column sourceName null description Field Person in type ActedIn is undefined validationErrorType FieldUndefined queryPath movieByTitle actors Person errorType ValidationError path null extensions null modifying the query to query SearchMovies movieByTitlesearchTerm Polar Express title actors from name roles passes validation but returns a null array for the relation type and its properties data movieByTitle title The Polar Express actors 