 on Plus some minor fixes proposal OCLint is another static analysis tool that focuses on reducing complexity confusion and redundant code It has a ton of rules This PR knocks out some of the simpler ones The tool also handles analyzing cyclomatic complexity and npath complexity which could help identify places that could probably use a refactor or reduction in complexity Many of the rules are conventional but could also be useful method length line length class length etc Create a collection view layout in the collection view factory when we create the collection view and absolve the view controller of that responsibility The VC now also doesnt need to create a temporary UICollectionViewLayout class for the collection view cerihughes and I discussed the fact that subclassing HubViewController in order to define a contract ie act as a protocol was a bit strange The argument against it was that Swift will look at UIViewControllerHubViewController as just a UIViewController and there will be lots of casting in the Swift code Thats true for now However Swift looks at idHubViewController as a HubViewController protocol Going with this approach theres only one line of casting in the Swift code and thats only to make UIKit happy I think thats acceptable Traversing the view hierarchy in search of specific class that handle touches is not really scalable This is an alternative solution Fixes There are several things going on here Made HubFramework compile for tvOS lots of compile flags Added support for the focus engine a little trickier than expected especially with nested collection views Added a HubComponentWithFocusState protocol so that a component can update its view when in focus Added a tvOS test target Updated the podspec Missing I did not update the CI setup Im not super familiar with using fastlane for this often use a simple shell script and wanted to avoid breaking something A tvOS demo app to come in a separate PR later on Always use XCTAssertEqualObjects when comparing objects for equality XCTAssertEqual was causing some issues with NSIndexPath equality on bit architectures possibly because bit architectures pool instances that are equal