Im working on the notary package for debian In Debian unstable lately we updated the prometheusclientgolang package to v x This new version removes all deprecated APIs hence brings several breaking changes as mentioned in the release note In Debian we dont build go packages with the vendor tree instead we use the go libraries as packaged in Debian In short it means that for Debian every packages that depend on prometheusclientgolang must now be built against the v x series Right now building Notary against prometheusclientgolang v x fails as such githubcomtheupdateframeworknotaryserver srcgithubcomtheupdateframeworknotaryserverservergo undefined prometheusInstrumentHandlerWithOpts srcgithubcomtheupdateframeworknotaryserverservergo undefined prometheusHandler The second failure is actually easy to fix as far as I can tell See The first failure however seems to require more work I have too little knowledge of notary or prometheus to fix that myself so I open an issue here asking for help if ever anyone has timeinterest looking into this issue Thanks NightTsarina onlyjob use go modules to makes dependency version information explicit and easier to manage For private registries one must be able to provide basic auth creds via NOTARYAUTH env var or interactively However the code assumes that all readOnly operations can be anonymous which in turn suppresses sending the auth header We discovered this problem because made lookup a readOnly operation so now notary lookup cannot be used with private registries even if NOTARYAUTH is set Reverting fixes the problem for us though I believe the real issue is that readOnly is synonymous with anonymous It would be great if the notary client could be integrated with Hashicorp vault as a storage location for the keys Use case CI and CD to release docker images runs in different servers and locations For each repository we need to be able to create the target keys and authorize developers ci to sign the docker images As we dont want these root and target keys to live on a developers machine we would like to integrate with Hashicorp Vault so keys can be managed centrally and backups can also be managed in a centralized location I managed to upgrade the codebase to use Go Modules In this PR I kept the Go version at to not interfere with other PRs I created and to limit the risk of breaking things Folllowing PR should make the image for the crossDockerfile available Running the buildimagesh from that PR should create it locally on your machine for testing purposes Depending on the other PR we might also take out that change for the crossDockerfile so this PR doesnt remain open for ages Ive had a bit of a nightmare trying to get notary running with certificates on OpenShift I tried to use ecdsa keys because thats whats documented in the serverconfigjson json trustservice type remote hostname notarysigner port tlscafile rootcacrt keyalgorithm ecdsa tlsclientcert notaryservercrt tlsclientkey notaryserverkey No matter what I did I just got tls bad certificate logged by the server I was able to make a connection to the signer using openssl sclient connect notarysigner CAfile certsserverrootcacrt cert certsservernotaryservercrt key certsservernotaryserverkey which showed a successful TLS connection then an error logged by the signer that I hadnt sent a valid http preface which is fair enough I suspect this is an issue with the Go TLS library rather than Notary but it would be really helpful if the example config file used the same key algorithm as the test certificates you generate Im happy to submit a PR for this if somebody can confirm my thinking is correct I think itll help people in the future Theres also the issue that the field is then probably ignored by Notary Its also not possible to set this field in the signer which doesnt then seem like you can generate ecdsa keys for the signer Running notary on a GUN that contains a port number eg the in dockerio libraryubuntu on Windows fails because the colon is an invalid character in a directory name notary v D s lookup dockerio libraryubuntu mDEBU m Configuration file not found using defaults mDEBU m Using the following trust directory C Users d notary fatal mkdir C Users cfiderer notary tuf dockerio The directory name is invalid This makes it impossible to run the notary client with private registries that use nonstandard ports Hello there My notary cli version on MacOS installed via brew notary Version Git commit d e f notaryserver and notarysigner latest version deployed using the Helm Chart levelinfomsgVersion Git commit d e time T Z levelinfomsgUsing local signing service which requires ED Ignoring all other trustservice parameters including keyAlgorithmtime T Z levelinfomsgUsing memory backendtime T Z levelinfomsgStarting Servertime T Z levelinfomsgEnabling TLStime T Z levelinfomsgStarting on time T Z While trying to run a notary init command with the following flags notary D p v s d dockertrust tlscacert rootcacrt init registrytesttestalpine Ive encountered the following error fatal unable to reach trust server at this time Eventhough I could see in the notaryserver logs that the request arrived and that the server answered a code json goversiongo httprequestcontenttypemultipartformdata boundarybaad b d e c d cec a dc ee b e a f httprequesthostnotaryserver httprequestid e e fc a a e c f httprequestmethodPOSThttprequestremoteaddr httprequesturiv registrytesttestalpinetrusttufhttprequestuseragentGohttpclient httpresponseduration mshttpresponsestatus httpresponsewritten levelinfomsgresponse completedtime T Z After a day and a half of debugging and redoing everything from scratch several times Ive figured out that the problem was the trailing slash in the notary server url I think that the error message could be improved ie it doesnt say that is an HTTP error code or even better follow the redirect Adding or not the final slash is an easy error to do and easy to fix codeside Could you please consider sanitizing the server url As you know Notary is a complex beast I the last thing I thought to be doing wrong was that slash Ive even copied and pasted the server URL into a curl command to check and it succeded of course Thanks 