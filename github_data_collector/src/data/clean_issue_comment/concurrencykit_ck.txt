In Gentoo Linux we compress all documentation Since ck already does the compression it would lead to double compression Would it be possible to pass an argument to configure whether we want documentation compression Thank you Could someone look into adding support for riscv and riscv There are Fedora Debian OpenSUSE Gentoo etc distributions available for QEMU virt machine orand SiFive Unleashed dev board usrbincc DXOPENSOURCE DBSDSOURCE DDEFAULTSOURCE stdgnu pedantic Wall W Wundef Wendiflabels Wshadow Wpointerarith Wcastalign Wcastqual Wwritestrings Wstrictprototypes Wmissingprototypes Wnestedexterns Winline Wdisabledoptimization fstrictaliasing O pipe Wnoparentheses DCKCCBUILTINS fPIC Ihomesbahrackinclude Ihomesbahrackinclude c o homesbahracksrcckeco homesbahracksrcckecc In file included from homesbahracksrcckecc homesbahrackincludeckech warning no previous prototype for ckec addepilogue Wmissingprototypes homesbahrackincludeckech warning no previous prototype for ckecadd epilogue Wmissingprototypes Old infrastructure is not as actively maintained Comments from pkhuong and cota Monday July MST pkhuong cota I think ckbytelocks design is known to be broken Monday July MST cota pkhuong thx wont report it then Monday July MST pkhuong actual breakage is good to know maybe we should just get rid of it Monday July MST pkhuong IIUC at the time the design was broken according to the memory model but seemed to work fine in practice on amd Monday July MST cota Waiting for threads to finish correctness regressionERROR RD On ppc make Entering directory homekev ckregressionsckbytelockvalidate validate Creating threads mutual exclusiondone Waiting for threads to finish correctness regressionERROR RD ERROR WR ERROR WR This is something a few users have expressed interest in when using perCPU structures or amortizing across a large number of threads cognet I can take this on pending remote access to MIPS box Requires test coverage and retesting on target platforms Sectionful invocation needs to make sure that no sectionless invocations exist Taking epoch reclamation principles SPSC usecase can be made efficient pkhuong dumped the following which is a good starting point for the facility This is a concept below from Paul include asserth include stddefh include stdinth include ckprh struct bufferindex uint t byte We can obv offset everything for init but lets keep things clear define BUFFERINDEXINIT Not clear on the fencing check ckepoch static inline sizet bufferindexreadindexconst struct bufferindex index uint t byte ckprload indexbyte return byte static inline void bufferindexreaddonestruct bufferindex index sizet nextreadindex readindex writeindex uint t byte ckprload indexbyte readindex byte writeindex byte xF nextreadindex readindex if nextreadindex nextreadindex if nextreadindex writeindex sizet prevwriteindex writeindex assertprevwriteindex nextreadindex ckprfenceloadstore ckprstore indexbyte nextreadindex writeindex return static inline sizet bufferindexwriteindexconst struct bufferindex index uint t byte ckprload indexbyte return byte xF static inline sizet bufferindexwritestartstruct bufferindex index sizet nextwriteindex readindex writeindex uint t byte ckprload indexbyte readindex byte writeindex byte xF nextwriteindex writeindex if nextwriteindex nextwriteindex if nextwriteindex readindex return writeindex assertreadindex nextwriteindex ckprstore indexbyte readindex nextwriteindex ckprfencestore return nextwriteindex 