i is now stable The following code doesnt work rust use gcTrace use gcderiveFinalize Trace deriveTrace Finalize struct XBoxdyn Trace This is because gcderive doesnt support dyn keyword Similar to stdcellRefmap Hi it would be really neat if some more arrays sizes than just the numbers to implemented Trace and Finalize Would you be open to adding the next few powers of two as well I actually only need T having to wrap these in a newtype when the crate supports arrays up to is oddly frustrating And T T etc are probably more common than say T Can you wrap a trait object in a Gc I would like to be able to write something like this As a workaround I am currently creating a GcBoxdyn MyTrait but I dont really like the indirection I am trying to use Gc the way you would use a Box or Rc with trait objects Is there a way to ergonomically add impls for other crates Possibly via optional deps on eg either void smallvec etc Ive got a type ExprC where C is a phantom type that Im trying to GC The derive generates rust unsafe implC static Context gcTrace for ExprC where GcExprC gcTrace C gcTrace VecGcExprC gcTrace GcArgsC gcTrace GcValueC gcTrace The C gcTrace bound is incorrect Id like there to be an attribute to disable it for example rust deriveFinalize Trace gcderivephantom C pub enum ExprC static Context I think this is a case of because it used to work while now I get a compiler stack overflow EDIT Confirmed as a regression from gcderive setting the Cargotoml version to resolves this as a short term fix error E no function or associated item named newunchecked found for type stdptrShared in the current scope homekevincoxcargoregistrysrcgithubcom ecc db ec gc srclibrs ptrroot CellnewSharednewuncheckedptrasptr error E no function or associated item named newunchecked found for type stdptrShared in the current scope homekevincoxcargoregistrysrcgithubcom ecc db ec gc srclibrs Sharednewuncheckedptr error E no function or associated item named newunchecked found for type stdptrShared in the current scope homekevincoxcargoregistrysrcgithubcom ecc db ec gc srclibrs selfptrrootsetSharednewuncheckedptr error E no function or associated item named newunchecked found for type stdptrShared in the current scope homekevincoxcargoregistrysrcgithubcom ecc db ec gc srcgcrs stboxesstart Someunsafe Sharednewuncheckedgcbox error E no function or associated item named newunchecked found for type stdptrShared in the current scope homekevincoxcargoregistrysrcgithubcom ecc db ec gc srcgcrs unsafe Sharednewuncheckedgcbox I started using this crate for my prolog interpreter its great thank you for making it Id to make my interpreter do hash consing of the terms Actually I already made this change but since there is no weak version of the Gc type my interpreter now never collects anything The reason is because the HashSet I use to store terms has a strong reference so once a term is inserted into my heap it lives forever Normally when implementing hashconsing you store weak references in the hashset Basically I want to write code like this rust type TermSet HashSetWeakGcTerm pub struct Heap terms TermSet Check if t is already in the HashSet If it is then return a strong reference to it if t is not in the HashSet add it and return a strong reference to it fn insertthingAheap mut HashSetGcA t A GcA where A Trace GcA Eq GcA Hash let gcthing Gcnewt match heapget gcthingdowngrade Somegc return gcupgradeunwraporgcthingclone None heapinsertgcthingdowngrade gcthing impl Heap pub fn new Self Heap terms HashSetnew pub fn insertterm mut self t Term GcTerm insertthing mut selfterms t I tried something similar using Rc and Weak from std even though cycles would cause issues but I noticed Weak doesnt implement Hash and Eq so they cant be used as keys in a HashMap and by extension a HashSet I dont know if that is due to the way dereferening Weak works or what Perhaps Ill also need a custom collection type Anyway do you think that would be an issue here as well Would a weak version of Gc be hard to add I havent looked at the code yet but if its not too hard I might try adding one Would there be significant downsidesdangers to having methods rust fn intorawgc GcT const T unsafe fn fromrawptr const T GcT analogously to Rcintoraw Rcfromraw I want to store a Gcd value across an FFI boundary for use in a callback while keeping it rooted are there any huge dangers here versus doing the same with an Rc The alternative would be boxing up the Gc then going BoxGcT const GcT and converting it back to a BoxGcT once Im on the Rust side I suppose Either way itd be nice to have the intofromraw functions