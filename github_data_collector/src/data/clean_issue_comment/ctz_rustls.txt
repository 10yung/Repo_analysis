Running openssl ecparam genkey name prime v gives output like this BEGIN EC PARAMETERS BggqhkjOPQMBBw END EC PARAMETERS BEGIN EC PRIVATE KEY MHcCAQEEIMAEBTzAWcOIlF WsrwnGjRedsqi yRkDACA I qnoAoGCCqGSM AwEHoUQDQgAEx fZWcozQkJM RxdtZmYRsRCfRPPMZDgxUWcDqqUnIoWPgYpRCFf s AWKN DoGigIC lxXODamfN mcZPBg w END EC PRIVATE KEY The contents of the BEGIN EC PRIVATE KEY block are defined in RFC The BEGIN EC PARAMETERS block just contains the OID of the curve and is redundant with the parameters field of the ECPrivateKey block It would be helpful if rustls exposed a function that can parse this Right now the user has to convert it to PKCS via openssl pkcs topk nocrypt before rustls can consume it I couldnt tell if this was possible from scanning the docs All of the client examples appear to take a DNSNameRef Lots of m m environments eg industrial dont use DNS at all in favor of static IP addresses and therefore dont use DNS names as the CN or provide the SubjectAlternativeName extension at all Is it possible to use Rustls wo the client performing hostname validation via the server CN andor extensions I also have a requirement to parse a custom X extension that contains authz info Is this possible as well Hi when I was browsing through the code base my IDE showed a lot of duplicated code Is this intentional libp p needs to be able to verify certificates that would normally be considered invalid they contain a critical extension that webpki does not and should not know about It also needs to return data from this process to the application The easiest way to do this is for rustls to not even try to parse the certificate itself Instead it should just treat it as bytes This client almost worksit has a few interoperability problems with some servers but the handshake extension it sends seems credible Its based on draft of the spec There are newer ones but Firefox and Cloudflare ship for now I think there will be some fresh movement around in a few weeks I thought I would create this as discussion point since I found it difficult to guess how youd like this feature factored into the existing code I tried to keep most of the ESNIspecific stuff in esnirs for now and I think the stuff in msgshandshakers should be uncontroversial Im sure youll want to change what Ive done to sessions configs etc edit I see Ive slightly broken the contribution rules here by starting without opening an issue although there is one already issue anyway theres lots of work to do yet this is just a small start still need a server side some work on what other messages need to be in the handshake a tool for generating the DNS record and updates to newer drafts Pretty straightforward I want to have the SNI saved earlier so that I can access it even if something later down the handshake fails My use case is a little complicated but here it goes I have a multitenant TLS proxy meaning multiple domains can use me to proxy their TLS connections I use SNI to determine which server cert my proxy will present using ResolvesServerCertUsingSNI Alternatively users of this proxy can have the TLS session be endtoend specifically that my TLS proxy is really just a TCP proxy and I forward every byte between the two parties including the bytes that I read as part of the ClientHello So if the handshake fails mostly due to ResolvesServerCertUsingSNI not finding a pair I check to see if the SNI is present in the endtoend endpoint list If it is I just forward the client hello through to the other connection which does the TLS handshake Without this change I was unable to get to the SNI value in the case the ResolvesServerCertUsingSNI comes up empty which in my application does NOT mean we should drop the connection and completely stop doing things Let me know if you have any other questions or if you would like me to add tests Note I manually tested this using the proxy service I am working on and it works fine This is a workinprogressdraft pull request for adding Ed support See for more information Notes Some bogo related tests are still failing The OpenSSL related commands like testcabuildapkish depend on OpenSSL version On macOS for example prefixing cargo test commands with OPENSSLDIRbrew prefix openssl will allow the tests to pass Fullduplex mode should allow us to perform both read and write and they wont block each other I believe that there is not much in TLS that prevents us from implementing fullduplex mode The renegotiation has been removed in TLS we can ignore it or throw error like ktls You can see some related discussions in tokio Instead of exposing the raw PRKs the QUIC API should expose an API that limits which HKDF info is allowed to be used for each key In particular it the API should prevent nonQUIC labels from being used I suggest in particular that for each type of key that needs to be derived for QUIC use there should be a function which hardcodes the parameters to the HKDF expansion This would help make it clearer that nonQUIC keys wont be leaked from Rustls when no key log is being used This completes the trifecta of configurability requests we run a sever that uses rustls and would like to only enable P and X to reduce CPU usage Relates to and but unlike them there is a big gap between TLS and TLS in this regard