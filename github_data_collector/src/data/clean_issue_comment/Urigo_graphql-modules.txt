This PR contains the following updates Package Type Update Change graphqltoolkitschemamerging dependencies patch Release Notes details summaryardatangraphqltoolkitsummary v Compare Source Do you want The Guild to keep your codebase up to date and run your build on each GraphQL Toolkit commit so we will make sure not to break your app Contact us here theguilddevconnectedbuild Chat with us on discord Check for HTTP URI specifically in URL Loader Make toolkit browser friendly Use nodejs builtin modules dynamically Use fixed bob GraphQL JS v compatibility Keep comments while fetching schema using URL Loader Fix babel typings details Renovate configuration date Schedule At any time no schedule defined verticaltrafficlight Automerge Enabled recycle Rebasing Whenever PR becomes conflicted or if you modify the PR title to begin with rebase nobell Ignore Close this PR and you wont be reminded about this update again rebasecheck If you want to rebaseretry this PR check this box This PR has been generated by WhiteSource Renovate View repository job log here This PR contains the following updates Package Type Update Change graphqltoolkitcommon dependencies patch Release Notes details summaryardatangraphqltoolkitsummary v Compare Source Do you want The Guild to keep your codebase up to date and run your build on each GraphQL Toolkit commit so we will make sure not to break your app Contact us here theguilddevconnectedbuild Chat with us on discord Check for HTTP URI specifically in URL Loader Make toolkit browser friendly Use nodejs builtin modules dynamically Use fixed bob GraphQL JS v compatibility Keep comments while fetching schema using URL Loader Fix babel typings details Renovate configuration date Schedule At any time no schedule defined verticaltrafficlight Automerge Enabled recycle Rebasing Whenever PR becomes conflicted or if you modify the PR title to begin with rebase nobell Ignore Close this PR and you wont be reminded about this update again rebasecheck If you want to rebaseretry this PR check this box This PR has been generated by WhiteSource Renovate View repository job log here As discussed at add more logger method and change log method interface Im experiencing the same symptoms previously reported with Issue that was tagged as being fixed in version I attempted version and also explored with version alpha bbc that was recommended here Both of which were incompatible with our Production running code After trying out version latest stable per npm I have reverted back to our Production version In both cases my attempt to inject a context mock into a GraphQL module fails to expose the object in my resolver functions Expected behavior In resolver functions contextcurrentUser should be set to the mocked object via ResearchModulemock Observed behavior contextcurrentUser is undefined in my resolver functions and the mocked object is nowhere to be found while running unit tests Without a user all my downstream authorization and filtering code fails due to the lack of a user contextprofile that it relies on This causes erroneous test results My code follows and is functionally equivalent and very similar to what was outlined in Issue file packagejson name apollographqlgatewayserver private true version description main indexjs scripts build webpack config webpackproductionjs dev nodemon r graphqlimportnoderegister start nodemon distserverjs lintgraphql graphqlschemalinter srcgql keywords file researchModulets this Research Module imports the Auth Module to gain access to the context that contains the user profile associated with the access token that comes from the HTTP header import GraphQLModule from graphqlmodulescore import ResearchResolvers from resolvers import ResearchApi from providersresearchApi import AuthModule from auth export const ResearchModule new GraphQLModule imports AuthModule typeDefs requireschemagql resolvers ResearchResolvers providers ResearchApi file authModulets contains HTTP request header extraction and access token handling code to create a User Profile from the output of createContext function below import GraphQLModule from graphqlmodulescore import createContext from context NOTE This GraphQLModule by design does not expose any operations or types It exists as a base module for creating the currentUser context so other GraphQLModule instances can import it for authentication authorization export const AuthModule new GraphQLModule name auth context createContext file contextts import getUserProfile from identity import log from logger interface PerCallContext key string any const createContext async req req any PromisePerCallContext const context PerCallContext session req currentUser if reqheadersauthorization const token reqheadersauthorization splitBEARER const identityProviderProfile await getUserProfiletoken contextcurrentUserprofile identityProviderProfile contextcurrentUserpreferredInitials contextcurrentUserprofilesubsubstring contextcurrentUserprofilesubindexOf TODO build an appropriate dictionary of business unitsinvestment group access array else contextcurrentUserprofile null const identityProfile Objectfreezecontext logdebug identityProfile return identityProfile export PerCallContext createContext And alas my test spec that attempts to inject the mocked context to allow my resolver functions to run with the fabricated hardcoded User Profile import reflectmetadata WARN required for DI Injectable decorators to work import ResearchModule from srcdomainsresearch import graphql from graphql import ResearchApi from srcprovidersresearchApi import ResearchPublication from srctypestypes import testResearchEntities from fixturesdata const schema ResearchSchema injector ResearchInjector ResearchModule Add the context mock since we dont have an interactive user that has signed on for the authentication context ResearchModulemock contextBuilder async ses any exclude any contextBuilder async return await x currentUser preferredInitials MGD NOTE by design for this set of tests this user has CII unit level access businessUnits CII RO CRGI NA CWI NA describeResearchModule Queries apply filtering when requests are made by unauthenticated unknown or invalid users beforeAll Setup Provider mock for entire ResearchApi so we can run an isolated test wo needing to call the real APIs ResearchInjectorprovide provide ResearchApi overwrite true useValue async getResearchByIdid any const research testResearchEntities researchid id TODO create a factory for this return research async searchResearch query page pageSize sortBy string return total testResearchEntitieslength page pageSize hits testResearchEntitiesmapr score entity r it ResearchgetResearchById should include Research Publication intended for CII audience async const query query getResearchByIdid inlineMockPub id researchType audience const result await graphql getResearchById ResearchPublication ResearchSchema query consolelogFrom it by filtering out all Research Publications consolelogresult expectresultdatagetResearchByIdtoBeTruthy file researchResolverts these are the resolver functions that at runtime is able to get the access token and derive an actual user profile via contextcurrentUser While running my tests through Jest however my reference contextcurrentUser or thiscurrentUser is undefined and I am unable to see where currentUser is stashed Main callout here is that contextcurrentUser is defined when requests are made by a logged in user but in the course of running unit tests through Jest contextcurrentUser is undefined and causes erroneous failed test results const disaggregatedResult applyDisaggregationpublication contextcurrentUser import ResearchApi from providersresearchApi import Resolvers QueryResolvers ResearchPublication from typestypes import moment from moment import log from logger import applyDisaggregation from filtersdisaggregation const queryResolvers QueryResolvers async searchResearchparent args context logdebug ResearchResolversearchResearch invoked at momentformat const researchApi contextinjectorgetResearchApi const searchResult await researchApisearchResearch argsquery argspage undefined argssize undefined logdebug ResearchResolversearchResearch exiting at momentformat TODO Ensure Disaggregation rules const disaggregatedResults applyDisaggregationsearchResult contextuser return disaggregatedResults return searchResult async getResearchByIdparent args context PromiseResearchPublication undefined logdebug ResearchResolvergetResearchByIdargsid const publication await contextinjector getResearchApi getResearchByIdargsid TODO Ensure Disaggregation rules const disaggregatedResult applyDisaggregationpublication contextcurrentUser return disaggregatedResult const resolvers Resolvers Query queryResolvers Entity resolveTypeparent context info return ResearchPublication export default resolvers Hi I am using graphQL modules fastify and apollofastify trying to do something like this const AppModule requiregraphQLappmodule const apolloServer new ApolloServer modules AppModule context session session customProperty test While customProperty is some arbitrary data that needs to be available inside the resolvers of all Modules and submodules that are imported in my appModule I have absolutely no clue how to achieve this since it seems that I cant access anything that isnt part of my session Its not very clear to me on how to pass any global context and even less what GraphQL modules expects me to do in order to make this work It seems like the context given to the constructor of the ApolloServer has zero effect and nothing to do with anything that happens within the modules and their contextbuilders Can somebody make this a bit more clear All I want to do is making a static value that exists when the ApolloServer is created eg a specific connectionstring available through all modules and their resolvers Thanks in advance Instead of providing official logger plugin graphqlmodules give logger interface now I see that we could pass logger functions when initiating module But I have no idea how to call logger in my resolvers or providers Could you give some hints about whats the best practice in your design I have experience with Express Apollo server and related technologies separately but have never used graphqlmodules or nestjs Do these two combine If they dont how can one decide which one to use I have been trying to get a base app up and running using apollo server and graphqlmodules I have gone through the development environment setup steps using the tsnode method This all works fine and I create a super simple Module from the examples typescript import GraphQLModule from graphqlmodulescore import gql from graphqltag export const AppModule new GraphQLModule typeDefs gql type Query myData Data type Data field String But when I try to follow the graphqlcodegen steps to generate the typings I get the error bad indentation of a sequence entry in D projects bootstrap server codegenyml at line column graphqlmodulescoreModuleContext The indentation seems fine and when I change that line to contextType graphqlmodulescoreModuleContext it passes that step but I then get an error saying that it cannot find my schema file Failed to load schema from srcschemats Unable to load from file D projects bootstrap server src schemats Cannot find module Dprojectootstrapserversrcschemats No idea where to go from here But I have tried starting again a few times with a blank slate each time thinking that I have messed something up in the setup instructions but I keep coming across the same issue With resolvers composition we can easily do query level permission but how do you add field level permission For example resolversComposition Userpassword isAuthenticated hasRoleEDITOR Doesnt seem to work I am following along with this example and TypeDefs keeps giving error Is there a working example some where that shows how to load multiple files for Types and Revolvers for a module Thanks Brian Davis 