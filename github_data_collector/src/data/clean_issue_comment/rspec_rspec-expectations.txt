 See To match ruby hash OpenStructnewvalue special true a workaround had to be used ruby expecthashtoa to containexactly haveattributesvalue special true This change makes it simpler ruby expecthash to includehaveattributesvalue special true Found here See Subject of the issue Custom matchers with keyword arguments cause the following warning rbenvversions librubygems gemsrspecexpectations librspecmatchersdslrb warning Using the last argument as keyword parameters is deprecated maybe should be added to the call Your environment Ruby version rspecexpectations version Steps to reproduce ruby require rspec RSpecMatchersdefinebefoo do bar nil match expecttrueto be true end RSpecdescribe Foo do it works do expectfooto befoobar qux end end RSpecExampleGroupsFoorun Expected behavior No warning is emitted Actual behavior A warning is emitted The purpose of this rather controversial change is to discourage the usage of a socalled implicit block expectation syntax ruby subject dosomething it isexpectedto changesomethingtonewvalue In case this syntax is being used a deprecation warning will be printed This syntax was referenced to as pretty obtuse and not something I d recommend generally We should mention they re not supported This is a less strict followup to which was released as part of a patch release and later reverted in due to a number of complaints Even though workarounds are possible for the most desperate usages of this syntax introducing a deprecation warning in pre version of RSpec and removal coincidental but still of support for the implicit block syntax in a major release makes more sense than removal of it in a minorpatch version since its used quite often across different codebases Ive seen Example Deprecation Message Deprecation Warnings You must pass a block rather than an argument to expect to use the provided block expectation matcher change or the matcher must implement supportsvalueexpectations Im not quite certain its the best one possible since it does not refer to the code that led to this deprecation message Appreciate any hint how to make it better Additional Things to Notice According to the following works with no disruptions ruby RSpecdescribe introspect do it do expect to beaProc end end Related Links Example fix for matcher libraries that are forced to keep the interface to provide the syntax for their users Subject of the issue When a duplicate matcher is introduced a warning should be produced by RSpec Your environment Ruby version rspecexpectations version Steps to reproduce ruby RSpecMatchersDSLMatchernewduplicatematcher self nil RSpecMatchersDSLMatchernewduplicatematcher self nil Expected behavior It should create a warning Actual behavior There is no warning for the user about the duplicate matcher New Behavior Introduces a warning when a duplicate matcher is introduced into the testing system Issue link Expecting a hash to include another when using composable matchers gives a misleading diff for the subset of the hash that did match includes should include a b bar FailureError expect a b foo to includea b bar expected a b foo to include b bar Diff a b bar a b foo Notice that diff a a is in the diff despite being matched by this can make it harder to determine what the problem is with a larger hash Nb that the expected a b foo to include b bar part of the failure message is good and does indicate the problem this issue is only about the Diff part Your environment Resolving dependencies Using bundler Using difflcs Using rspecsupport Using rspeccore Using rspecexpectations Using rspecmocks Using rspec Ruby version is Steps to reproduce ruby frozenstringliteral true begin require bundlerinline rescue LoadError e stderrputs Bundler version or later is required Please update your Bundler raise e end gemfiletrue do source gem rspec Activate the gem and version you are reporting the issue against end puts Ruby version is RUBYVERSION require rspecautorun RSpecdescribe includes do it do expect a b foo to includea b bar end end Expected behavior The diff does not highlight matched entries as different diff a b bar b foo Actual behavior The diff does highlight matched entries as different diff a b bar a b foo Previous Behavior The aliased matcher implementation of a description currently replaces all instance of the old matchers name in the new matchers name If it happens that the expected values include the old matchers name these also get overwritten In the examples below the string include is replaced in both the outputs by the new matchers name ruby it overwrites data for astringincluding do mystring a string with include expectsome random stringto matchastringincludingmystring end expected some random string to match a string including a string with a string including ruby it overwrites data for ahashincluding do myhash mystring a string with include expectto matchahashincludingmyhash end expected to match a hash including mystring a string with a hash including New Behavior This change makes it so it only replaces the first instance of the original name so none of the expected data is also overwritten The two above error outputs would be the following expected to match a hash including mystring a string with include expected some random string to match a string including a string with include I saw this in Subject of the issue I would like to write a spec where I assert that a value should not be included in an enumerable that is lazy and infinite For example ruby expectfibonaccisequencenotto include or expect notto include However the rspec include matcher goes into an infinite loop and never returns for these specs despite the fact that include does return false immediately for fibonacccisequence it would depend on your implementation Your environment Ruby version rspecexpectations version Steps to reproduce Ive created a simple test case on github here which reproduces the issue using an infinite range Its run on travis here Expected behavior If include returns false the expectation should fail Actual behavior It goes into an infinite loop and the expectation never completes It looks like this is because the matcher calls any after include and that does never return