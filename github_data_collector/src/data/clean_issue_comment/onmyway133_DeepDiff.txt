I gets crash Terminating app due to uncaught exception NSInternalInconsistencyException reason attempt to delete item from section which only contains items before the update My changes First Changes insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert Second Changes insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert insert update was Crash I think changes update should be update Maybe collection view sees the changed items before inserted I would love to use this library but I cant build it for Mojave It seems like a fairly simple pureswift library is there any reason it couldnt support older versions of macOS Hi It would be honest to add Swifts CollectionDifference to the Performance project and to the Among different frameworks section in Readme Of course its iOS only but why not What do you think In your list of examples you have this piece of code swift let old Arrayabcd let new Arrayadbc let changes diffold old new new Move d from index to index Is this indeed correct or was this before introducing the Heckel algorithm Havent verified this but doesnt Heckel produce all three moves in this case Ie swift Move d from index to index Move b from index to index Move c from index to index For example in my code i have a very common case protocol BaseClassProtocol class ConcreteClass BaseClassProtocol class ConcreteClass BaseClassProtocol Anywere in my codebase there is only BaseClassProtocol being used For example let array BaseClassProtocol this array contains various classesstructs with the same protocol How can I apply DeepDiff library and DiffAware protocol to compare various arrays of BaseClassProtocol objects Initial state sections the first one contains one row other contain rows Destination state all the sections except of the first one are removed Error attempt to delete row from section which only contains rows before the update Additionally how diffoldnew works if it tries to delete and reinsert the first section extra action Could you explain why we need to use DiffAware protocol when Hashable do the same thing and there is a lot of helper functional outofthebox like Hasher etc For example we have a simple struct struct SomeStructT DiffAware U DiffAware var value T var valuesArray U And if we want to conform DiffAware protocol we need to calculate diffId something like this var diffId Int let valueIds selfvaluesmap diffId var hasher Hasher hashercombineselfvaluediffId hashercombinevalueIds return hasherfinalize And if all the objects conformed Hashable protocol I will not need to use map in this case and it will affect the performance As I remember map complexity is On I made a PR to this end It can be useful when looking at changes while hiding private implementation See Mapping changes can be useful when inspecting and acting on changes without revealing private types to internal or public interfaces Wondering what the impact is of replicating the reload logic from the UICollectionViewExtensions with the corresponding sectionupdating methods reloadSections deleteSections insertSections moveSections I could submit a PR for this if this change hasnt been scoped out or hasnt been intentionally omitted