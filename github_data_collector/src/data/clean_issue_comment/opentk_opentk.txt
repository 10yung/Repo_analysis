In the current implementation of OpenTK x that is available via NuGet there is code running in GameWindowcs that consumes of a single core Since the main while loop executes infinitely as fast as possible it locks up resources I implemented a FixedTimestep with ThreadSleep to mitigate this issue Reproduce Create an empty class and inherit from GameWindow run the using statement and look at the CPU usage Before grafik After grafik Proof of concept and a reference is the Monogame implementation of FixedTimesteps I would highly suggest to implement this behaviour and make it optional Purpose of this PR Implement the rest of the GLFW Window functions glfwGetWindowContentScale glfwSetWindowUserPointer glfwGetWindowUserPointer glfwSetWindowMaximizeCallback glfwSetFramebufferSizeCallback glfwSetWindowContentScaleCallback While studying the new build pipeline I came across a few difficulties with the current documentation that I believe might be improved Here are my thoughts Build instructions can currently be found both in READMEmd and CONTRIBUTINGmd Some of the git instructions seem outdated in CONTRIBUTINGmd for example it still recommends doing work against the develop branch which no longer exists None of the instructions mention the F code generation pipeline or how to get it to work so I had to bump a bit against it until I figured it out The batch scripts on the commandline are useful for this but they also seem to be outdated Specifically the SpecificationOpenGL project requires the glxml file which has to be obtained externally from the khronosorg website There are two files updatespecificationsbat and updatebindingsbat that mention a Generators folder and two subprojects GeneratorBind and GeneratorConvert which no longer seem to exist Its unclear in the build documentation what these projects are used for eg which ones are for testing and which ones for building The file buildcmd does not seem to get called correctly as a prebuild event on my machine using VS Furthermore calling it manually from CLI always starts downloading the dotnet tool manually even if it is already installed so detection of latest version might not be implemented correctly Currently had to manually call dotnet fake run buildfsx t UpdateBindings myself to actually generate the bindings I imagine the project is maintained by a regular team who is already familiar with these procedures so just wanted to share a bit of the perception that a complete outsider might have when coming into the code base I was eventually able to build all projects by manually downloading glxml from the khronosorg website and placing it where the SpecificationOpenGL project was looking for it If someone is willing to walk me over the expected pipeline including the purpose of the FAKE scripts and code generators I would be happy to offer pull requests to improve the docs I have just come back to updating OpenTK dependencies and prototype the new version and just realized the full extent and implication of the decisions around the namespace change I believe this is a profound mistake for this project but one which I hope we can still prevent Allow me to elaborate OpenTK has a year history the first commit harks back to when I first started programming professionally Since then I and many other developers have relied on it systematically for years and years The presence and impact of the OpenTK in the community is sheer testament to this This impact has led OpenTK to be appropriated by the mono project and consequently official bits of documentation are now lingering in Microsofts own support website I have just unrolled the events of the past year and I understand how painful it must be for the maintainers to have undertaken the decision to change the namespace I dont want to reopen old wounds but in the name of protecting this community I believe that I must This is not about binary and source compatibility anymore the sheer impact and extent of the OpenTK brand has now implications for SEO when people look for help Documentation will be far more important than findreplace operations especially for new users who will establish and represent the future of OpenTK I know Xamarin feels like the big shark who are entitled to hold their ground and just shut off but on behalf of at least my community of indirect OpenTK users extensive in openscience and visualization I urge you not to concede this ground If I understand correctly the problem stems from a particular distribution of OpenTK the one that clashes with MonoXamarin official distro that is shipped with their platform If this is the case why not generate a specific distribution just for this scenario until they come around and decide to remove the OpenTK assemblies as per their XAMCORE audit The rationale is that if this use case didnt work before then there are really no users which are depending on it working at the moment This means that if you introduce a renamed OpenTK just for Xamarin you will not harm any existing user base and more importantly by keeping the root namespace intact you will keep the important documentation identity for OpenTK Again this is NOT just about root namespace child namespace For nonEnglish speaking users OpenTK is a completely different word from OpenToolkit and should not be changed lightly Especially changing the name of the assembly and nuget packages is a mistake the ID change will take years to sort out The OpenTK community is not huge and marketing communication is bandwidth limited so this risks fragmenting it even further into oblivion Please do not do this As for implementation given that code generation tools are starting to be incorporated extensively in the OpenTK build process it doesnt seem like it would be too hard to automate the publishing process for this temporary platform release I am happy to help directly with this and allocate however many work hours are needed for me to familiarize myself with the build pipeline and make it happen As for a proposal for what name to use for the specific deployment NuGet namespace for Xamarin platforms I suggest OpenTKXamarin In light of everything that has happened I feel it is only right but would accept better suggestions Description Enum OpenTKGraphicsOpenGL TextureTarget d does not contain a definition for TextureCubeMapArray According to wiki the glTexStorage D OpenTKGraphicsOpenGL GLTexStorage D functions one possible target is GLTEXTURECUBEMAPARRAY However GLTexStorage D target is TextureTarget d enum and it has no member similar to GLTEXTURECUBEMAPARRAY Example Im trying to create CubeMap array texture this way c using System using SystemDrawing using SystemDrawingImaging using OpenTKGraphicsOpenGL using PixelFormat SystemDrawingImagingPixelFormat using GLPixelFormat OpenTKGraphicsOpenGL PixelFormat public int CreateCubemapArraystring imagePaths int count Generate an array texture int texture GLGenTexture GLBindTextureTextureTargetTextureCubeMapArray texture GLTexStorage D TextureTarget dTextureCubeMapArray does not work SizedInternalFormatRgba count Load images for int i i count i LoadImageimagePaths i TextureTargetTextureCubeMapPositiveX i i Setting behavior GLTexParameterTextureTargetTextureCubeMapArray TextureParameterNameTextureMinFilter intTextureMinFilterLinear GLTexParameterTextureTargetTextureCubeMapArray TextureParameterNameTextureMagFilter intTextureMagFilterNearest GLTexParameterTextureTargetTextureCubeMapArray TextureParameterNameTextureWrapS intTextureWrapModeClampToEdge GLTexParameterTextureTargetTextureCubeMapArray TextureParameterNameTextureWrapT intTextureWrapModeClampToEdge GLTexParameterTextureTargetTextureCubeMapArray TextureParameterNameTextureWrapR intTextureWrapModeClampToEdge Generate Mipmaps GLGenerateMipmapGenerateMipmapTargetTextureCubeMapArray return texture void LoadImagestring path int width int height TextureTarget textureTarget int depth using Bitmap image new Bitmappath BitmapData imageData imageLockBits new Rectangle imageWidth imageHeight ImageLockModeReadOnly PixelFormatFormat bppArgb GLTexSubImage D textureTarget level offsets width height depth GLPixelFormatBgra PixelTypeUnsignedByte imageDataScan imageUnlockBitsimageData Related information OpenTK NET Core Description I write a very simple shader and using opengl API to render it When I use gtx it works fine but when I use a WX or RX the shader does not work The driver is updated to the latest version Have I do something wrong How to make it work on a AMD graphic card The project is attached Waiting for your kind reply I pass the paras to the shader using GLUseProgramprogram add shader attributes here GLVertexAttrib time GLDrawArraysPrimitiveTypePatches SwapBuffers The vertex shader version core layout location in float time layout location in vec position out vec fragcolor void mainvoid glPosition position fragcolor vec sintime costime the frag shader version core in vec fragcolor out vec color void mainvoid color fragcolor opengl testzip Description Creating shaders with empty source codes will create invalid memory addressing and ultimately results in crashes when later accessingcompilingwriting to these on certain version of windowsRadeon drivers Reproduction Create two shaders immedaitely after one another both with sources assigned to a null stream Then attempt to compile the first The debugger will the catch the exception in the call Note the violation occurs in the call not in the formation of the call itself Windows version This problem does not persist on version NET Framework Purpose of this PR Merge all OpenAL extensions into a single assembly Testing status None Comments As requested by varon Description SwapBuffers GLFlush or GLFinish takes a while to finish when a compute shader has been used even though the compute shader is already finished on Win NVIDIA with Drivers Thus causing the UI thread to completely freeze during this time It can take upwards of ms for SwapBuffers GLFlush or GLFinish to complete I have not tested with SDL backend due to using GLControl It is more apparent on compute shaders with large sizes But it can also happen on compute shaders with only DispatchCompute and no for loops in a simple compute shader where a variable is assigned as output to a Persistent Mapped ShaderStorageBuffer It seems any time the underlying OpenTK CPU code must sync with the GPU after a compute shader is used causes a huge spike in wait time before returning Repro steps Please provide the steps required to reproduce the problem Note The worker size is set to in the shader Use a DispatchCompute Use GLFlush GLFinish or SwapBuffers called later Expected behavior SwapBuffers GLFlush or GLFinish should not be taking ms Since the compute shader is already complete by the time these are called Actual behavior SwapBuffers GLFlush or GLFinish can take upwards of ms to complete after a compute shader is launched Even though the compute shader is finished by the time these are called This can even happen on small compute shaders that have no for loops and are DispatchCompute Related information Win pro Latest Build Nvidia with Drivers Native Backend OpenTK from Nuget Net Framework No workarounds currently available that I have found Purpose of this PR Cooperative work with jvbsl and realvictorprm to improve the OpenGL bindings generator This mostly includes a general cleanup and a new tool to diff our legacy API against the current one