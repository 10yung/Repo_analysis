When moving the serialize method to the implementation I get the following warning dataserializear Wundefinedfunctemplate warning instantiation of function DataserializecerealJSONInputArchive required here but no definition is available The compilation works because the template is instantiated To solve the warning we just have to add an extern template declaration in the header file c extern template void DataserializecerealJSONOutputArchivecerealJSONOutputArchive extern template void DataserializecerealJSONInputArchivecerealJSONInputArchive Maybe this is something we can add to the documentation Cheers boostrtree does not provide stable code for serialization and it only has some experimental codes So can cereal support serialization for boostrtree The LICENSE file only talks about the license for cereal itself However cereal bundles rapidjson and rapidxml each with their own licenses Users should be made aware of this bundling by specifying it in the LICENSE file either by pointing to the respective license files for rapidjson and rapidxml although such file is not present for rapidjson or by copying that info into the main LICENSE file Same comment is actually true for the base hpp file Could we change the Cereal documentation to reflect the below information please Im talking specifically of the second Important remark at The remark says If you are building a dynamic library on Windows registration must occur within the header file Source file registration will not properly occur outside of the DLL This issue is not present on Linux or Mac This following is also shared by a reply at The problem of using CEREALREGISTERTYPE across DLLs can be solved with cereal should work with too by having the following statements in an hpp in a DLL at the bottom of a DLL dependency chain Lets call it coredll In that DLL one will have a file called confighpp with the following traditional macro CMake will define coreEXPORTS when generating the build scripts for coredll This is all very familiar to Windows developers Im sure if definedMSCVER definedMINGW definedMINGW if definedcoreEXPORTS define COREDECL declspecdllexport else define COREDECL declspecdllimport endif endif Then in another exporthpp in coredll have the following namespace cereal namespace detail these declspecs will ensure that the polymorphic loadersaver registrations will all happen against the binding maps in coredll template class COREDECL StaticObjectInputBindingMapPortableBinaryInputArchive template class COREDECL StaticObjectInputBindingMapJSONInputArchive template class COREDECL StaticObjectOutputBindingMapPortableBinaryOutputArchive template class COREDECL StaticObjectOutputBindingMapJSONOutputArchive add similar statements for other archive types as needed template class COREDECL StaticObjectVersions namespace detail namespace cereal All other cpp files no need to include in hpp in the other dll projects will include coreexporthpp thereby telling the linker to use the cereal StaticObjects in coredll If you debug the InputBindingCreator constructor you will notice that every class is now being registered in the same binding map Hope this helps Regards I found a particular MB bin file CarveObjk rgbThreshold triangleCameraMatchesbin in minimal example where cereal fails to load throwing exception Failed to read bytes from input stream Read The respective MB XML file CarveObjk rgbThreshold triangleCameraMatchesxml in minimal example built from the same data loads normally The XML file was produced by stdofstream outFilebase triangleCameraMatchesxml cerealXMLOutputArchive oarchiveoutFile oarchivemtriangleCameraMatches and the binary version was produced by stdofstream outFilebase triangleCameraMatchesbin cerealBinaryOutputArchive oarchiveoutFile oarchivemtriangleCameraMatches Minimal example Version of Cereal used MSVS Windows We have been having some trouble with polymorphic types using ICC as installed at NERSC on Cori Trying to serialize a derived class by pointertobase results in an exception about an unregistered polymorphic type A very small test case can be found here ultraminimal branch The error is Trying to save an unregistered polymorphic type MyClass where MyClass is a derived type serialized by pointer to MyClass its parent If serialized through a pointer to type MyClass everything works fine Im writing a CMake project to Deserialize an XML schema xsd to an C class I have read the document and most of them are covered with Serialization I hope someone can help me to find out if cereal can use for Deserialize or not If yes which part of the document is used for it Thanks in advance Im a newbie Im seeing this with Visual Studio The access violation happens at includecerealtypesmemoryhpp line because of the following code Allocate our storage which we will treat as uninitialized until initialized with placement new using NonConstT typename stdremoveconstTtype stdsharedptrNonConstT ptrreinterpretcastNonConstT new ST NonConstT t if valid tT delete reinterpretcastST t The access violation occurs when evaluating Px PxWptrexpired in the following method of stdsharedptr I actually added a memset call to zero out the alignedstorage block but the debugger still shows all the base class objects incl enablesharedfromthis as Unable to read memory The Px pointer looks fine template class Ux void SetptrrepandenablesharedUx const Px Refcountbase const Rx noexcept take ownership of Px thisPtr Px thisRep Rx if HASIFCONSTEXPR if constexpr conjunctionvnegationisarrayTy negationisvolatileUx CanenablesharedUx if Px PxWptrexpired PxWptr sharedptrremovecvtUxthis constcastremovecvtUxPx else HASIFCONSTEXPR HASIFCONSTEXPR vvv Enablesharedfromthis this Px boolconstant conjunctionvnegationisarrayTy negationisvolatileUx CanenablesharedUx endif HASIFCONSTEXPR At the moment the only thing that seems to work is constructing the object before the sharedptr Which means object loops will fail to deserialize It does seem like the C runtime Im using is no longer working with the EnableSharedStateHelper mechanism c inline stduint t islittleendian static stdint t test return reinterpretcaststdint t test Here we are dereferencing pointer via unrelated type This violates strict aliasing rules and UB See this The fix is to do this c inline stduint t islittleendian static stduint t test return reinterpretcastunsigned char test Here I avoid the problem of signedness and use unsigned char that can alias other types