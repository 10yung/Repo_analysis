Fixes I arrived a this change in the second commit by trialanderror with good guessing Or said another way I didnt really know what I was doing but I found this solution that seems to work In particular the parsing error message for the test case Jmaharman gave in when trying to parse digits but only given is error at line column unexpected end of stream expecting digit I think that is the correct error message The code I deleted allowed the manyn parser to return after processing fewer than n things I think this bug is partially due to copying and pasting the nearly identical code for the many and manyn parsers which do not have a minimum number of items they need to parse in order to return success The thing I understood the least was what error message to return I knew I wanted to return a parser error created from the function EmptyError but I am totally guessing that the parser error to pass into that call should be mergeErrorerror tReplyError It does seem like a good guess though because the example error message that I shared above looks good to me Ive found that manyn isnt failing if the input string isnt long enough to reach n by more than away I added this test to ParsecTests and it fails Fact public void ParseNTimesFailIfMoreThan Away var p asStringmanyndigit var r parsep ToEither AssertTruerIsLeft I believe its all down to this line although I cant understand why its doing what its doing to give any more pointers eerr return count n ConsumedErrorSeqTmergeErrorerror tReplyError EmptyOKSeqresults current mergeErrorerror tReplyError PS Great library thank you I am heavily using Validation right now to do some encoding and decoding of binary data and I am running into some missing functions I can explain via the existing validation test code Consider this part of the validation test code This code is not ideal because it only returns a validation error for expMonth when it is invalid even when expYear is also invalid My first instinct is to refactor this code to C var monthYear ToIntexpMonthBindValidMonth ToIntexpYearBindPositiveNumber Applym y validTodaym y Flatten not defined but Flatten isnt defined for Validation My second instinct is to refactor this code to C var monthYear ToIntexpMonthBindValidMonth ToIntexpYearBindPositiveNumber Sequence Bindt var m y t return validTodaym y which works in this case because ValidationSequence is defined in ValueTuple Extensionscs However in my case at work I have a ValueTuple of arity seven There happens to be a file called ValueTuple Extensionscs but it doesnt contain the corresponding Sequence extension method My third instinct is to refactor this code to C var monthYear ToIntexpMonthBindValidMonth ToIntexpYearBindPositiveNumber ApplyVTupleint int Bindt var m y t return validTodaym y which works in my case because the function VTuple of arity seven exists In fact this form is how the aritytwo Sequence is implemented after replacing the lambda expression a b a b with the predefined function VTupleA B which I only recently learned exists Can we add the missing Flatten and Sequence methods There has been such a vast number of significant improvements lately that I have been unable to keep up I am interested in using the new Union attribute but I am a bit confused I was expecting there to be a way to exhaustively handle cases especially by a method named Match There isnt a method by that name and I dont see any other method that fits that description Is there a way to exhaustively handle all the cases in a Union type I have a chain of functions which have the same signature Optionobject getNext some code return getInnernext Optionobject getInnerNext some code so whatever is returned from getInnerNext is returned by getNext as SomeSomex or SomeNone Even the Map functions arent really helping and for each function we have to do Match how do we avoid an Option becoming another Option when returned in chain Hi Im having some difficulties with customizing the equality logic that is generated with the Record attribute Is it possible to easily customize the logic to perform a structural comparison of any IEnumerable fields I tried to include a custom OrdImmutableListMyType in my project which delegates all calls to OrdEnumerable so that it would be used by EqDefault After some trial and error I actually got that to work but unfortunately only while my application is running The same code running in an NUnit test does not use the custom Ord either because Im doing something wrong or because theres a bug in ClassInstancesAssembly or both From what I can figure the ClassInstancesAssembly does not properly detect my referenced assemblies and so they are not scanned when running from NUnit Was I on the right track to begin with Is there an easier way The EqAttribute in Attributescs seemed very promising but Im either missing something or that attribute is no longer used Any help would be vastly appreciated Thanks There is no parseEnum wrapper for EnumTryParsestring value bool ignoreCase out TEnum result Ill submit a PR shortly Just checking Question Shouldcould generated classes be partial or otherwise be more customizable I read that you decided against this but sometimes could be nice to add eg attributes to generated classes or overwrite ToString etc I see that opening the classes might create new problems but maybe there are other ways to reduce problem surface like letting the codegenerator check for existing properties of possible or require that the custom class has some IKnowWhatImDoingHere attribute Question Could two union types be compatible like this Union public interface ShapeWithCorners ShapeWithCorners Rectanglefloat width float length ShapeWithCorners Prismfloat width float height Union public interface EasyShape EasyShape Rectanglefloat width float length EasyShape Circlefloat radius At the moment this will result in conflicting code But technically it should be possible for the generated classes to implement both interfaces see I personally would avoid this style but I see no point in having IfSomeAction without having IfNoneAction leads to a not found page