It would be nice if IsEqualTocollection and IsEquivalentTocollection allowed a collection of constraints to be specified not exact values For example AssertThatlist IsEquivalentTonew IsEqualTo IsGreaterThan Would require that list contains exactly two items one of which is equal to and the other of which is greater than in an unspecified order Of course its more useful with more complex constraints than these Implementation for EqualTo ought to be straightforward EquivalentTo might be trickier in the event that a constraint matches multiple items its probably a combinatorial problem to avoid falsely failing something that would have worked with a different constraintactual matchup ordering But I think Google Test allows these sorts of things Sometimes it is needed to verify value type against default value Common use case verify that value in rest response is not empty eg Guid not empty or enums not Undefined value Current alternative using EqualConstraint eg IsNotEqualToGuidEmpty IsNotEqualTodefaultMyEnumTypeName which is not always convenient Details If actual is nonnullable value type should pass if actual default If actual is nullable value type should pass if actual is equal to default value of underlying type so the following code could be possible MyValueType actual AssertThatactual IsNotNull IsNotDefault Open question what the expected behavior if nullable actual is null Technically it is default value for nullable value type but I think would make sense to fail it in this case ie only account for underlying type default value Not sure about the behavior for reference types Not sure it should be allowed at all Another option allow passing when null and provide roslyn analyzer with warning if used against reference type Creating a custom attribute that derives from TestActionAttribute then using that attribute from a test library that uses a newer version of NUnit will result in NUnit not executing the test because it could not load the older NUnit library Using an appconfig to redirect to the newer NUnit version fixes the issue and tests then run as expected The issue is nonobvious because normal tests appear to not run status inconclusive This was the cause of NUnitApplicationDomain Issue Unable to run with VS test runner and I discovered the root of the problem only because one of the parameterized test fixtures gave the following stack trace An exception was thrown while loading the test SystemIOFileLoadException Could not load file or assembly nunitframework Version Cultureneutral PublicKeyToken cd eb or one of its dependencies The located assemblys manifest definition does not match the assembly reference Exception from HRESULT x File name nunitframework Version Cultureneutral PublicKeyToken cd eb at SystemModuleHandleResolveTypeRuntimeModule module Int typeToken IntPtr typeInstArgs Int typeInstCount IntPtr methodInstArgs Int methodInstCount ObjectHandleOnStack type at SystemModuleHandleResolveTypeHandleInternalRuntimeModule module Int typeToken RuntimeTypeHandle typeInstantiationContext RuntimeTypeHandle methodInstantiationContext at SystemReflectionRuntimeModuleResolveTypeInt metadataToken Type genericTypeArguments Type genericMethodArguments at SystemReflectionCustomAttributeFilterCustomAttributeRecordCustomAttributeRecord caRecord MetadataImport scope Assembly lastAptcaOkAssembly RuntimeModule decoratedModule MetadataToken decoratedToken RuntimeType attributeFilterType Boolean mustBeInheritable Object attributes IList derivedAttributes RuntimeType attributeType IRuntimeMethodInfo ctor Boolean ctorHasParameters Boolean isVarArg at SystemReflectionCustomAttributeGetCustomAttributesRuntimeModule decoratedModule Int decoratedMetadataToken Int pcaCount RuntimeType attributeFilterType Boolean mustBeInheritable IList derivedAttributes Boolean isDecoratedTargetSecurityTransparent at SystemReflectionCustomAttributeGetCustomAttributesRuntimeType type RuntimeType caType Boolean inherit at NUnitFrameworkInternalTypeWrapperGetCustomAttributes T Boolean inherit at NUnitFrameworkInternalBuildersDefaultSuiteBuilderGetFixtureBuilderAttributesITypeInfo typeInfo at NUnitFrameworkInternalBuildersDefaultSuiteBuilderBuildFromITypeInfo typeInfo WRN Assembly binding logging is turned OFF To enable assembly bind failure logging set the registry value HKLM Software Microsoft FusionEnableLog DWORD to Note There is some performance penalty associated with assembly bind failure logging To turn this feature off remove the registry value HKLM Software Microsoft FusionEnableLog Exception doesnt have a stacktrace The underlying issue referencing an older version of NUnit for attributes might be closed as willnotfix but I think it might be useful for users to have some sort of error message rather than having the tests seemingly refuse to execute Ive created a reproduction solution over repoNUnitAttributesTargettingDifferentVersion There appears to be an issue with the prefiltering in NunitLite If there is a a namespace ab which contains a SetupFixture and a namespace abc which has a test method abcTestMethod and only the test abcTestMethod is specified the setup fixtures OneTimeSetup and OneTimeTearDown methods are never run Apparently the prefiltering excludes the ab namespace from consideration It would seem that prefiltering should examine all parent namespaces for a SetupFixture even if tests in those namespaces are excluded by the prefiltering Maybe there needs to be a simple way to turn prefiltering off entirely As far as I can tell there are no assertions in either model that allow the use of an existing Regex in the assertion All of the Regex assertions take a string containing the regex pattern It would be quite useful to have constraints which take an existing Regex in place of the string pattern but function identically Annotating any more than a class at a time will be overwhelming to review Im starting with the mostseen types The intent with all annotations is to reflect current behavior If null is tolerated Im marking the parameter as nullable If it causes ArgumentNullException NullReferenceException etc Im marking as nonnullable Weve had these four methods as far back as NUnit source history goes The double overloads are the same as the first two overloads except that they throw InvalidOperationException if you pass null Since they cant be used to pass null they dont do anything that the safer double overloads dont do Should we obsolete them or fix them What would fixing them look like cs namespace NUnitFramework public abstract class Assert public static void AreEqualdouble expected double actual double delta string message params object args public static void AreEqualdouble expected double actual double delta public static void AreEqualdouble expected double actual double delta string message params object args public static void AreEqualdouble expected double actual double delta SystemCollectionsImmutableImmutableArray implements both reference equality and structural equality via IStructuralEquatable I want to be able to check two arrays for structural equality but only some of the overloads of EqualConstraintUsing work as expected The two overloads that take IEqualityComparer or IComparer dont use the correct comparison whereas the versions that take delegates do The attached code which was built with packages NUnit and SystemCollectionsImmutable fails the last two tests C using System using SystemCollections using SystemCollectionsImmutable using NUnitFramework namespace NUnitStructural TestFixture public class Test Test public void ImmutableArrayNotReferenceEquality var x ImmutableArrayCreate var y ImmutableArrayCreate AssertThatx y Test public void ImmutableArrayWithStructuralEqualityComparison var x ImmutableArrayCreate var y ImmutableArrayCreate ComparisonImmutableArrayint comparison a b StructuralComparisonsStructuralComparerComparea b AssertThatx IsEqualToyUsingcomparison Test public void ImmutableArrayWithStructuralEqualityComparerEquals var x ImmutableArrayCreate var y ImmutableArrayCreate var del new FuncImmutableArrayint ImmutableArrayint boola b StructuralComparisonsStructuralEqualityComparerEqualsa b AssertThatx IsEqualToyUsingImmutableArrayintdel Test public void ImmutableArrayWithStructuralComparerEquals var x ImmutableArrayCreate var y ImmutableArrayCreate var del new FuncImmutableArrayint ImmutableArrayint boola b StructuralComparisonsStructuralComparerComparea b AssertThatx IsEqualToyUsingImmutableArrayintdel Test public void ImmutableArrayWithStructuralEqualityComparer var x ImmutableArrayCreate var y ImmutableArrayCreate AssertThatx IsEqualToyUsingStructuralComparisonsStructuralEqualityComparer Test public void ImmutableArrayWithStructuralComparer var x ImmutableArrayCreate var y ImmutableArrayCreate AssertThatx IsEqualToyUsingStructuralComparisonsStructuralComparer Case Without reflection In this case even if we are throwing the exception in catch the NUnit only shows that there was one assert Test public void Test try Method catchException ex throw public void Method AssertFailAssertion Test TearDown public void TearDown Result Error Assertion Test at NunitTestsClass KuchNai in C Users Documents Visual Studio Projects SameMessageTest NunitTests Class csline at NunitTestsClass Test in C Users Documents Visual Studio Projects SameMessageTest NunitTests Class csline Case With Reflection In this case we are using reflection inside the test if there is failureAssert inside the method getting called using reflection Nunit shows that there were two assertions as shown in the result below Test public void Test try Calling the method using reflection Type magicType TypeGetTypeNunitTestsClass ConstructorInfo magicConstructor magicTypeGetConstructorTypeEmptyTypes object magicClassObject magicConstructorInvokenew object MethodInfo magicMethod magicTypeGetMethodMethod object magicValue magicMethodInvokemagicClassObject new object catchException ex throw public void Method AssertFailAssertion Test TearDown public void TearDown Result Error NunitTestsClass Test Error Assert at NunitTestsClass KuchNai in C Users Documents Visual Studio Projects Class csline Error NunitTestsClass Test SystemReflectionTargetInvocationException Exception has been thrown by the target of an invocation NUnitFrameworkAssertionException Error Assert at SystemRuntimeMethodHandleInvokeMethodObject target Object arguments Signature sig Boolean constructor at SystemReflectionRuntimeMethodInfoUnsafeInvokeInternalObject obj Object parameters Object arguments at SystemReflectionRuntimeMethodInfoInvokeObject obj BindingFlags invokeAttr Binder binder Object parameters CultureInfo culture at SystemReflectionMethodBaseInvokeObject obj Object parameters at NunitTestsClass Test in C Users Documents Visual Studio Projects Class csline Sometimes it is necessary to unittest the code which relies on a static state or even worse on the type initializers execution order Even after fixing this kind of nonsense the problem doesnt entirely go away because now you need to test it against different scenarios to avoid false positives My solution is intended to solve this problem for NET Core users who doesnt have full AppDomain functionality It relies on AssemblyLoadContext and IFixtureBuilder extension point to achieve the result I have basically copypasted TestFixtureAttribute code and changed BuildFrom methods to use the type from the newly created AssemblyLoadContext This approach have a few limitations It doesnt support isolation of test methods only test classes It doesnt support AssemblyLoadContext unload because as of now it is not supported by the runtime but it is planned The design is poor It can look better as a property of existing TestFixtureAttribute But in general it works my tests are no longer sharing static variables So I request you to add this killerfeature to the NUnit to make more users happier