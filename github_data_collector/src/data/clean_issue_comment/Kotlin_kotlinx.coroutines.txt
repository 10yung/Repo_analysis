Can we have a zipWithNext operator for Flow Could you help me implement one Hi I use asFlow to convert rxjava Flowable to Flow kotlin suspend fun main FlowablecreateInt emitter repeat emitteronNextit printlnemit it Threadsleep BackpressureStrategyBUFFER onErrorReturnItem subscribeOnSchedulersio asFlow collect printlncollect it The producer is slower than consumer but the result is strange emit collect emit emit emit emit collect collect collect collect If I use BackpressureStrategyLATEST the consumer will only get and the first and the last emit collect emit emit emit emit collect I finally figure out that it may be related to the onErrorReturnItem call If I comment it out the result seems as expected emit collect collect emit collect emit collect emit collect emit kotlin version kotlinxcoroutines version Hi I found that PublisherAsFlow ignores the CoroutineContext when created It always uses an EmptyCoroutineContext instead kotlin private class PublisherAsFlowT Any private val publisher PublisherT capacity Int ChannelFlowTEmptyCoroutineContext capacity Just ignore the context use EmptyCoroutineContext for ChannelFlow override fun createcontext CoroutineContext capacity Int ChannelFlowT PublisherAsFlowpublisher capacity So if I call flowOn on it nothing happens kotlin FlowablecreateInt run on ui thread io thread expected asFlow flowOnDispatchersIO will be ignored launchInmainScope See by ThomasVos Ive a bit minimized it to this test Test fun testFlowCombine runTest withContextDispatchersDefault val flow flowOf val combo combineflow flow a b a b assertEquals combofirst It crashes due to freezing on coroutines state machine inside implementation of combine See The awaitClose function currently throws a JobCancellationException if the job was canceled before calling the function I would have personally expected that the block passed to awaitClose gets executed without throwing this exception Sample code kotlin internal fun SensorManagerconsumeValuesAsFlow sensor Sensor measureInterval Duration L with TimeUnitMilliSeconds FlowFloatArray return callbackFlow val sensorEventListener object SensorEventListener override fun onAccuracyChangedsensor Sensor accuracy Int Unit override fun onSensorChangedevent SensorEvent catch offereventvalues registerListener sensorEventListener sensor measureInterval TimeUnitMicroSeconds toInt sensorHandler try awaitClose unregisterListenersensorEventListener catch t Throwable LogeSensorManager consumeValuesAsFlow t called with JobCancellationException Coroutines version Kotlin version In our current codebase we are using ArrayBroadcastChannels to perform detailed logging This works great since it does not conflate anything which is what we need for our logs to be complete Our problem is that we want to use the same BroadcastChannels to update our UI If the UI subscriber is created after the BroadcastChannel is first initialized the UI will never show values unless another broadcast would take place This is where the ConflatedBroadcastChannels would solve our UI problem when it delivers new subscribers with the latest or even last value Currently I do not see any possible path forward except having duplicate BroadcastChannels one being an ArrayBroadcastChannel for logging and one being ConflatedBroadcastChannel for the UI I was considering extending one of those classes our creating my own class to handle this situation but it seems this would be a difficult path forward with classes that I would need being marked private Please let me know if anyone has found a solution to a similar situation Maybe I am missing something and this can easily be accomplished Thanks in advance for reading this Fixes Introduces the BroadcastChannelAsFlow internal class to accumulate onStart callbacks and only invoke them inside collect after openSubscription has been called In the docs we have this example of onStart Kotlin flowOfa b c onStart emitBegin collect printlnit prints Begin a b c Not just with emit this works with sending to a Channel as well Kotlin val channel ChannelString channelconsumeAsFlow onStart channelsendBegin channelsenda etc collect printlnit prints Begin a b c However with a BroadcastChannel we wont get anything Kotlin val channel broadcast send channelasFlow onStart channelsend collect printlnit prints If onStart is primarily a callback to say that were collecting data instead of a fancy way to prepend data to the Flow then this feels wrong The difference is because of how the subscription is created The subscription channel isnt created until the builder is reached which is after onStart Kotlin public fun T BroadcastChannelTasFlow FlowT flow emitAllopenSubscription onStart is being invoked at the same time as always and the value is being sent but the subscriptions ReceiveChannel is created afterwards and never gets it Proposed Solution Make asFlow return its own internal type BroadcastFlow and give it an update function similar to ChannelFlow This function will just accumulate the actions and store itthem until the final collect is called Then make onStart do a type check and just call update if its a BroadcastFlow When its time to start collecting create the subscription then invoke the action then call emitAll Kotlin public fun T BroadcastChannelTasFlow FlowT BroadcastFlowthis internal class BroadcastFlowT private val source BroadcastChannelT private val startAction suspend FlowCollectorT Unit FlowT fun update startAction suspend FlowCollectorT Unit BroadcastFlowT BroadcastFlowchannel startAction startAction override suspend fun collectcollector FlowCollectorT val channel sourceopenSubscription collectorstartAction collectoremitAllchannel public fun T FlowTonStart action suspend FlowCollectorT Unit FlowT if this is BroadcastFlow updateaction else unsafeFlow Note unsafe flow is used here but safe collector is used to invoke start action SafeCollectorTthis coroutineContextaction collectthis directly delegate Issue At the moment the intermediate operators that can extend a Flow like map as an example do not accept references to nonsuspending methods or to properties A function can still be specified as a lambda so say flowmap Stringlength works while flowmapStringlength doesnt Possible Solution We could create additional extension functions accepting KProperty and KFunction and then delegate to the existing one Example fun T R FlowTmapproperty KProperty T R FlowR map propertygetit for properties and fun T R FlowTmapfunction KFunction T R FlowR map functioninvokeit for methods