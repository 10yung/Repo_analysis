Throwing this up to get API feedback Some questions Is it expecteddesirable to have the current value emitted immediately or should emissions only happen on update Should that be comfigurable Is there a channel API that makes sense here so you could write as well as read Or is Flow sufficient CI build will fail due to missing platforms in kotlinxcoroutines Looking for API feedback The idea here is to enable arbitrary datatypes to be encoded inside a Settings instance Some questions Are there serialization edgecases that should be added to the tests One thing currently missing is a test of polymorphic serialization Is it a problem that the delegate APIs talk directly to the encoderdecoder rather than through a format I think that means polymorphic serialization wont work on the delegate but I dont know if thats an important usecase or not Does the public API seem clean enough or are there adjustments I should make The CI build will fail I think its because of missing native platforms in kotlinxserialization Looking for user feedback before removing the ExperimentalJvm annotation and treating JVM usage at the same level of stability as the rest of the library Are both the Properties and Preferences implementations useful or can the Properties implementation be deprecated and removed Is there anything else I havent considered around JVM usage thats worth taking into account No specific timeline on this yet but I want to have an issue to track what work remains before stabilizing Looking for user feedback before removing the ExperimentalListener annotation and treating listeners at the same level of stability as the rest of the library Is the API surface useful asis or would it be better to add typed listeners that pass the current value to the callback Is threading a concern Currently listener APIs do not do any threadrelated work and assume clients are correctly doing all interaction from the main thread in Android and iOS or can deal with multithreaded usage in JvmPreferences where listeners are forced to a background thread Are there other usages or issues I havent considered Note one currentlyunpublished change which is visible in master SettingsremoveListener has been replaced with listenerdeactivate This cleans up the listener internals a little since previously you could pass a listener to a settings instance which hadnt created it which might lead to unexpected usually noop behavior No specific timeline on this yet but I want to have an issue to track what work remains before stabilizing This is just to let everyone know Im working on this Already forgot how interesting it is to work with pointers to pointers in KotlinNative and how awesome is WinAPI Improve publishing configuration to automate publication to Maven Central This way consumers wouldnt need to add a onetimeuse Bintray dependency Kevin called me out in a podcast and said the name Multiplatform Settings isnt catchy enough Ive had this thought as well but I havent yet come up with anything I like better Leaving this here to track the possibility of changing it and potentially source ideas Currently Multiplatform Settings has Android and iOS implementations It could be nice to be able to use it on other platforms as well Ive done some initial explorations here but am interested in hearing others needs and usecases It would be straightforward to do a macOS implementation since NSUserDefaults exists there just like iOS I have also begun to look at using the storage api for a JS implementation What are other platform APIs that would be useful to expose through this library This would look something like android fun entries MapString Any delegateall ios fun entries MapString Any delegatedictionaryRepresentation The difficulty here is that this exposes platformspecific implementation details such as storing Ints as Longs on iOS and Doubles as Longs on Android See prototype in the keys branch Naively this should be pretty straightforward Unfortunately a number of default keys are present on every instance of NSUserDefaults which cant be removed This seems likely to lead to unexpected perplatform differences in behavior in user code I would love to get feedback from someone more familiar with the iOS APIs to better understand what the best way to handle this is