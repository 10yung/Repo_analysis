Coming from The celluloidio code we have isnt detecting serverside disconnects occasionally We could really use some professional help were likely not using celluloidio correctly in Hi I did execute Rspec to use this gem But actorspec failed because the following error happend bundle exec rspec speccelluloidioactorspecrb skip CelluloidIO behaves like a Celluloid Actor raw message sends logs on unhandled messages FailureError Threadcurrent celluloidactorsystem actorsystem raiseError Celluloid is not yet started use Celluloidboot CelluloidError Celluloid is not yet started use Celluloidboot Shared Example Group a Celluloid Actor called from speccelluloidioactorspecrb All error output of above wording Before I running the test I added following to the spechelperrb require rspecretry require celluloidrspec What is this error Regards In my code I changed code from ruby require celluloidio require celluloidautostart to ruby require celluloidcurrent require celluloidio because of following documentation But warning message still poped up Celluloid is running in BACKPORTED mode How can i fix it This debian bug has full log of the test failures Running the following code ruby require celluloidcurrent require celluloidio class Wut include CelluloidIO attraccessor sock def initializehost port sock CelluloidIOTCPSocketnewhost port end end huh Wutnew print huhsock produces an error I T INFO Celluloid is running in BACKPORTED mode E T ERROR Actor crashed IOEINPROGRESSWaitWritable unknown error Operation now in progress connect coreerrnorb in handle usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in writenonblock usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in wrapwritenonblock usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in writenonblock usrlibrubiniusgemsgemsrubyslsocket libsocketsocketrb in connectnonblock usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb in createsocket usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb in initialize corealpharb in new usrlibrubiniusgemsgemscelluloidio libcelluloidiosocketrb in new whatrb in initialize usrlibrubiniusgemsgemscelluloid libcelluloidcallsrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcallsyncrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in task usrlibrubiniusgemsgemscelluloid libcelluloidactorrb in task usrlibrubiniusgemsgemscelluloid libcelluloidtaskrb in initialize usrlibrubiniusgemsgemscelluloid libcelluloidtaskfiberedrb in create coreprocrb in call E T ERROR CLEANUP CRASHED IOEINPROGRESSWaitWritable unknown error Operation now in progress connect coreerrnorb in handle usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in writenonblock usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in wrapwritenonblock usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb in writenonblock usrlibrubiniusgemsgemsrubyslsocket libsocketsocketrb in connectnonblock usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb in createsocket usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb in initialize corealpharb in new usrlibrubiniusgemsgemscelluloidio libcelluloidiosocketrb in new whatrb in initialize usrlibrubiniusgemsgemscelluloid libcelluloidcallsrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcallsyncrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in dispatch usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in task usrlibrubiniusgemsgemscelluloid libcelluloidactorrb in task usrlibrubiniusgemsgemscelluloid libcelluloidtaskrb in initialize usrlibrubiniusgemsgemscelluloid libcelluloidtaskfiberedrb in create coreprocrb in call celluloid in remote procedure call An exception occurred running whatrb unknown error Operation now in progress connect IOEINPROGRESSWaitWritable Backtrace Errnohandle at coreerrnorb in RubySLSocketErrorwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb RubySLSocketErrorwrapwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb RubySLSocketErrorwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb Socketconnectnonblock at usrlibrubiniusgemsgemsrubyslsocket libsocketsocketrb CelluloidIOTCPSocketcreatesocket at usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb CelluloidIOTCPSocketinitialize at usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb Classnew at corealpharb CelluloidIOSocketnew at usrlibrubiniusgemsgemscelluloidio libcelluloidiosocketrb Wutinitialize at whatrb CelluloidCallCelluloidCallSyncdispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcallsrb CelluloidCallSyncdispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcallsyncrb in CelluloidCelldispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in CelluloidCelltask at usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in CelluloidActortask at usrlibrubiniusgemsgemscelluloid libcelluloidactorrb in CelluloidTaskCelluloidTaskFiberedinitialize at usrlibrubiniusgemsgemscelluloid libcelluloidtaskrb in CelluloidTaskFiberedcreate at usrlibrubiniusgemsgemscelluloid libcelluloidtaskfiberedrb Proccall at coreprocrb Caused by Operation now in progress connect ErrnoEINPROGRESS Errnohandle at coreerrnorb in RubySLSocketErrorwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb RubySLSocketErrorwrapwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb RubySLSocketErrorwritenonblock at usrlibrubiniusgemsgemsrubyslsocket librubyslsocketerrorrb Socketconnectnonblock at usrlibrubiniusgemsgemsrubyslsocket libsocketsocketrb CelluloidIOTCPSocketcreatesocket at usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb CelluloidIOTCPSocketinitialize at usrlibrubiniusgemsgemscelluloidio libcelluloidiotcpsocketrb Classnew at corealpharb CelluloidIOSocketnew at usrlibrubiniusgemsgemscelluloidio libcelluloidiosocketrb Wutinitialize at whatrb CelluloidCallCelluloidCallSyncdispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcallsrb CelluloidCallSyncdispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcallsyncrb in CelluloidCelldispatch at usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in CelluloidCelltask at usrlibrubiniusgemsgemscelluloid libcelluloidcellrb in CelluloidActortask at usrlibrubiniusgemsgemscelluloid libcelluloidactorrb in CelluloidTaskCelluloidTaskFiberedinitialize at usrlibrubiniusgemsgemscelluloid libcelluloidtaskrb in CelluloidTaskFiberedcreate at usrlibrubiniusgemsgemscelluloid libcelluloidtaskfiberedrb Proccall at coreprocrb However removing the include CelluloidIO line results in correct functioning but obviously disables Celluloid ruby require celluloidcurrent require celluloidio class Wut include CelluloidIO attraccessor sock def initializehost port sock CelluloidIOTCPSocketnewhost port end end huh Wutnew print huhsock shell CelluloidIOTCPSocket x c rubinius a c ad x linuxgnu celluloidio Looking at here there is a feature missing to wait on more than one socket something like IOselect ios but tailored to celluloidio I was picturing maybe exposing the select method from the reactor selector instance there should be only one per actor therefore something like Actorcurrentselect which doesnt necessarily have to follow the same ruby IOselect API use case netssh v will come with an internal event loop This is supposed to handle the case in which one has to listen to events on the session socket and eventually the forwarding socket the gateway socket etc It would be cool if one could expose the event loop and monitor more than one socket or maybe what one needs is multisocket Monitors nio r Im a bit lost in how this API could look and whether the internals allow this I just wanted to see if theres some limitation Im missing I think this is a bug or a nonfeature Trying to fix In the following code if the connection is forcibly closed serverside I see the EOF but no close or closed event ruby require celluloidcurrent require celluloidio require http require websocketdriver class Connection include CelluloidIO extend Forwardable def initializeurl url url uri URIparseurl port uriport urischeme ws socket CelluloidIOTCPSocketnewurihost port socket SSLSocketnewsocket OpenSSLSSLSSLContextnewTLSv client socketconnect client WebSocketDriverclientself asyncrun end attrreader url def run clientonopen do event puts OPEN event end clientonmessage do event puts MESSAGE event end clientonclose do event puts CLOSE event end clientstart loop do begin clientparsesocketreadpartial rescue EOFError puts EOF break end end end defdelegators client text binary ping close protocol def writebuffer socketwrite buffer end end fail missing token unless ENV SLACKAPITOKEN url JSONparseHTTPget puts connecting to URIparseurlhost conn Connectionnewurl loop do Threadpass end puts done connecting to mpmultiwu slackmsgscom OPEN struct WebSocketDriverOpenEvent MESSAGE struct WebSocketDriverMessageEvent data type hello MESSAGE struct WebSocketDriverMessageEvent data EOF I am also happy to contribute a more thorough CONTRIBUTING doc to replace this paragraph in the README ala LMK if you would like that I must be missing something obvious this is from a clean checkout of celluloidio There was an error parsing Gemfile cannot load such file Usersdblocksourcecelluloidcelluloidiocelluloidculturesync Bundler cannot continue from UsersdblocksourcecelluloidcelluloidiocelluloidGemfile puts Fileexpandpathculturesync FILE require Fileexpandpathculturesync FILE In short what I tried to fix is the following behaviour when trying to resolve a hostname when offline irbmain require celluloidcurrent true irbmain require celluloidio true irbmain CelluloidIOTCPSocketnewwwwgooglecom NoMethodError undefined method u u u u u u u u u u u u u www u google u com u u u u u for nilNilClass from Userseloygemruby gemscelluloidio libcelluloidiodnsresolverrb in resolve from Userseloygemruby gemscelluloidio libcelluloidiotcpsocketrb in createsocket from Userseloygemruby gemscelluloidio libcelluloidiotcpsocketrb in initialize from Userseloygemruby gemscelluloidio libcelluloidiosocketrb in new from Userseloygemruby gemscelluloidio libcelluloidiosocketrb in new from irb from Userseloyrubiesruby binirb in main What happens is that socket remains nil here which means that you end up sending the hostname as a NilClasssend message here With stdlib it raises the following exception although that one is actually not raised by the name resolver but by Socket irbmain require socket false irbmain TCPSocketnewwwwgooglecom SocketError getaddrinfo nodename nor servname provided or not known from irb in initialize from irb in new from irb from Userseloyrubiesruby binirb in main The one raised by Resolv is irbmain Resolvgetaddresswwwgooglecom ResolvResolvError no address for wwwgooglecom from Userseloyrubiesruby libruby resolvrb in getaddress from Userseloyrubiesruby libruby resolvrb in getaddress from irb from Userseloyrubiesruby binirb in main I m not sure which one I should use any thoughts 