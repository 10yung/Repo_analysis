Jetty version Description Would be great to have the thread pool behavior documented so that configurations with too few threads or custom thread pools or bounded queues that cause Jetty to misbehave are outlined and therefore avoided by users Include how ThreadPoolBudget works and how various components could steal threads from the pool Jetty version Java version various flavours of jdk oracle opendjk OS typeversion Windows and Linux Description When using Jetty with a ServerConnector created without specifying the number of acceptors and selectors Jetty does not process any incoming requests This has been observed reliably on a c xlarge in AWS see for an example The symptom of this is that Jetty starts and is listening as shown by netstat but any requests just timeout Note the versions affected range is a tad unreliable The code works with jetty v and fails with later versions from maven central but recompiling later jetty versions from a tag with jdk appears to resolve the issue for an unknown reason the running JVM is the same in all cases So I do not believe that code diff between jetty v and jetty v is of any use in order to bisect this issue Jetty version Java version Question I have been trying out the QoSFilter for the purpose of restricting the number of requests that can be served at a time for a single endpoint so the rest of our API isnt impacted under heavy load of that endpoint in particular However I am running into some difficulties when testing that it is working as expected As I understand it when the max request limit is reached any new requests get suspended and queued by priority When an active request finishes the next highest priority queued request can be resumed as normal and passed along the filter chain If the period of suspension finishes before the request can be processed the request is rejected as unavailable With this in mind I have tried testing this by making a number of requests on different threads so I can verify a response of unavailability In testing I set the following parameters maxRequests suspendMs waitMs I can verify that these values are set on the QoS filter correctly by logging them when the request hits the filter Under these conditions I would expect quite quickly to see requests get rejected However this is not the case Through logging I can see that requests matching the path hit the filter and that they are getting suspended but they never seem to get rejectedresumedaccepted after that Interestingly the requests do still hit the endpoint despite never being accepted and passing down the filter chain The requests that do hit the endpoint do not pass through any filters beyond the QoSFilter An even more contrived example is when I set the maxRequests to My expectation would be that no requests can ever reach my endpoint on the path specified but the behaviour is the same as described above So I guess my question is am I overlooking some part of the configuration or is my understanding of how it should work incorrect I would be interested in knowing how other people are testing that this filter is working as expected Thanks in advance Updated old keystores to new PKCS keystores Removed unused keystores and truststores Signedoffby Simone Bordet simonebordetgmailcom Fixes Close Update to jasper version for jetty Upgrade jasper Closes Issue MessageInputStream now takes a session and uses suspend resume so that we only read the next frame if we have consumed all the data from the previous frame one or we exit from onMessage so all the bytes until the next message are discarded Jetty version v Java version u Description The The Central Maven Repository is updating to https and when pulling and building jetty from the ALPN module pulls from which then fails The update URL should be removed stopTimeout from all abstractLifeCycles It is on GracefulLifeCycle which is only implemented by components that can start a graceful shutdown eg Server ContextHandler and QueuedThreadPool Signedoffby Greg Wilkins gregwwebtidecom Jetty version jetty v Java version OS typeversion Ubuntu LTS Description JSR WebSockets MessageHandlers JavaDoc states Each web socket session uses no more than one thread at a time to call its MessageHandlers This means that provided each message handler instance is used to handle messages for one web socket session at most one thread at a time can be calling any of its methods This has also held for everything Ive tried as long as the registered listener is a Whole String However since Im parsing JSON using Jackson it hit me that I could as well use a Whole Reader and feed that directly into the Jackson ObjectReader All of a sudden I started to get protocol errors from my library It depends on a HELLO message containing auth being sent before any other From the logs it seems that with Whole Reader two threads are delivering messages concurrently and they are even sometimes coming in the wrong order which is what triggers the failure This is a set of log lines showing concurrent processing of messages but at least in the right order HELLO before SEND qtp INFO csmwimplMatsSocketSession WebSocket received message orgeclipsejettywebsocketcommonmessageMessageReader ebd d on MatsSocketSessionId null WebSocket SessionId thisMatsSocketSession cdf ae qtp INFO csmwimplMatsSocketSession WebSocket received message orgeclipsejettywebsocketcommonmessageMessageReader dd f on MatsSocketSessionId null WebSocket SessionId thisMatsSocketSession cdf ae qtp INFO csmwimplMatsSocketSession Messages HELLONEW nulltidMatsSocketstartmJrl bcidGImeQ akra qtp INFO csmwMatsTestWebsocketServer Resolving Authorization header to principal for header DummyAuth qtp INFO csmwimplMatsSocketSession MatsSocket HELLO matssockettypeHELLO matssocketsubTypeNEW qtp INFO csmwimplMatsSocketSession Messages SEND TestsingletidSEND J yypcidnull qtp INFO csmwimplMatsSocketSession SEND to Testsingle reply null msg matssockettypeSEND Heres a different set where they come both concurrent and in the wrong order SEND before HELLO thus the SEND is triggering close of socket even while the concurrent HELLO is being processed qtp INFO csmwimplMatsSocketSession WebSocket received message orgeclipsejettywebsocketcommonmessageMessageReader d ad on MatsSocketSessionId null WebSocket SessionId thisMatsSocketSessionf d qtp INFO csmwimplMatsSocketSession WebSocket received message orgeclipsejettywebsocketcommonmessageMessageReader ad b on MatsSocketSessionId null WebSocket SessionId thisMatsSocketSessionf d qtp INFO csmwimplMatsSocketSession Messages SEND TestsingletidSEND nj E cidnull qtp INFO csmwimplMatsSocketSession Messages HELLONEW nulltidMatsSocketstartOCjlh cidMFSqZtWVXL qtp ERROR csmwimplMatsSocketSession We have not got Authorization header qtp INFO csmwMatsTestWebsocketServer Resolving Authorization header to principal for header DummyAuth qtp INFO csmwimplDefaultMatsSocketServer Closing WebSocket SessionId code VIOLATEDPOLICY reason Missing Authorization header qtp INFO csmwimplMatsSocketSession MatsSocket HELLO matssockettypeHELLO matssocketsubTypeNEW By literally only changing Whole Reader to Whole String and also doing ReaderString in the onMessage method I get these lines for the same test notice how it is a in order b the first message is finished before the next comes in and c it is even the same thread that does the processing for those two messages qtp INFO csmwimplMatsSocketSession WebSocket received message tHELLOclvMatsSocketjsv UserAgent Unknownts anTestAppav authDummyAuth cidWTvoxdiO YtidMatsSocketstartmKnhFAstNEW on MatsSocketSessionId null WebSocket SessionId thisMatsSocketSession d qtp INFO csmwimplMatsSocketSession Messages HELLONEW nulltidMatsSocketstartmKnhFAcidWTvoxdiO Y qtp INFO csmwMatsTestWebsocketServer Resolving Authorization header to principal for header DummyAuth qtp INFO csmwimplMatsSocketSession MatsSocket HELLO matssockettypeHELLO matssocketsubTypeNEW qtp INFO csmwimplMatsSocketSession WebSocket received message eidTestsingletidSENDg BBepmsgtSENDcmcts cmseq on MatsSocketSessionId M Q oSpeow hjY WebSocket SessionId thisMatsSocketSession d matssocketprincipalMr Dummy Auth matssocketsessionIdM Q oSpeow hjY qtp INFO csmwimplMatsSocketSession Messages SEND TestsingletidSENDg BBepcidnull matssocketprincipalMr Dummy Auth matssocketsessionIdM Q oSpeow hjY qtp INFO csmwimplMatsSocketSession SEND to Testsingle reply null msg matssocketprincipalMr Dummy Auth matssocketsessionIdM Q oSpeow hjY matssockettypeSEND