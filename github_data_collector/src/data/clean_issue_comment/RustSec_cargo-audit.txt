cargo audit colornever doesnt respect the color setting since colors are still being printed This might be because the warningcolor function doesnt take that config flag into account While reading Cargolock is straightforward one could easily have a Cargotoml file that would allow semver resolution to pick a vulnerable version of a crate even if cargo didnt happen to pick that version in practice Itd be cool if cargo audit could consume Cargotoml and enumerate the set of every possibly valid choice of crate versions and emit a warning if any of them have known vulnerabilities In response to this the author could tighten the specification of which crate version is required Seems to hang indefinitely when running behind a proxy seidhe gitmaster echo httpproxy seidhe gitmaster echo httpsproxy seidhe gitmaster cargo audit Fetching advisory database from C Network monitor show it makes a request directly to the host instead of to the proxy Despite suggesting using cache cargo to cache cargoaudit the script forcereinstalls it every time Until Z installupgrade is stabilized I have been using a script like this for installing tools using the cache yaml install wasmbindgen version wasmbindgen cargo install force wasmbindgencli version I may open a PR to update this if I get around to setting up cargoaudit on any of my projects CI The latest rustsec crate releases added a notion of advisory collections which are presently CollectionCrates for crates published through cratesio CollectionRust for rustlang components distributed as part of Rust itself The RustSec Advisory Database now contains the following advisories filed in CollectionRust CVE rustdoc Uncontrolled search path element vulnerability in rustdoc plugins CVE std Buffer overflow vulnenrability in VecDequereserve CVE std Buffer overflow vulnerability in strrepeat CVE std Memory safety vulnerabilities arising from Errortypeid CVE cargo Cargo prior to Rust may download the wrong dependency Presently these advisories are ignored by cargoaudit however it might make sense to add features for at least warning if the currently active Rust toolchain is vulnerable This issue is for discussing what might make sense in that regard Running cargo audit targetos linux on suggests that its vulnerable to RUSTSEC on Linux cargo audit targetos linux error Vulnerable crates found ID RUSTSEC Crate memoffset Version Date URL Title Flaw in offsetof and spanof causes SIGILL drops uninitialized memory of arbitrary type on panic in client code Solution upgrade to error vulnerability found Running cargo tree alltargets p memoffset i shows that the only path is as follows memoffset v crossbeamepoch v crossbeam v rustargon v redoxusers v dirs v term v slogterm v srcterm dirs only uses redoxusers when cfgtargetos redox see It looks like targetos linux isnt stripping this dependency despite being specified on the command line Siderophile is a utility for locating unsafe hotspots in Rust programs and fuzzing them Blog post GitHub One of the things it does is a call graph analysis somewhat similar to the ones performed by tools like cargogeiger and RustPr zi see also The RustSec Advisory DB already contains metadata about the paths to impacted functions in an advisory as they relate to versions It would be nice to use Siderophile to compute the call graph across allfeatures of the parent crate then use it to perhaps optionally test whether or not impactedfunctions exist in the call graph Case study memoffset The following is a realworld RustSec case story where this sort of call graph analysis may have been helpful RUSTSEC filed against the memoffset crate was an interesting vulnerability for several reasons High severity memory exposure and potential RCE Furthermore its initial severity was underestimated and the impacted versions also retroactively expanded Low exploitability whether or not a particular project is impacted or not depended entirely on how the parent dependency which depends on memoffset was using it This means that a low number of users received an important advisory about a high severity vulnerability but for many others it was a false positive Unclear resolutions memoffset is used by many highprofile ecosystem crates including crossbeam At the time we published the advisory there was no upgrade path available for many users so they got an alert but it was not actionable This combination of factors is exactly the sort of situation where it would be nice to eliminate false positives via call graph analysis For users who were truly impacted by this advisory it was RCE and they should absolutely be notified but for most users it was just noise and without a call graph analysis tool it was completely unclear which of these buckets a particular program fit into Eliminating false positives is something that must be done correctly we dont want to fail to alert impacted users just to spare nonimpacted users from annoying false positives However I think this sort of call graph analysis can be done precisely to where that is the case It would be nice to have prebuilt binaries of the tool available here This is mostly for CI usage as building the tool in CI inflates build times This is less an issue with caching but is still a concern Shall cargoaudit like cargogeiger track which functions are used and which are unused by the target crate and filter out vulnerabilities in unreferenced functions Otherwise there will be a stream of vulns in seldom used functions in deep dependencies which would train users to shovel them away without much consideration as most of then are not to the point Or if there would be little advisory traffic will penalize crates or authors by figurating in a report even though the vulnerability is just in a tiny experimental dochidden nondefaultfeaturecfg function which almost nobody knows about or be a reason against filing such advisories as insignificant