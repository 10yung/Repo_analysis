This PR implements runtime kernel feature helper detection for bpftrace Kernel support is currently tested at compile time which makes it impossible to ship a single bpftrace build If it is compiled on an older kernel some of the features will be blocked even though the kernel supports it And when using it on an older kernel helpers that are not supported by the kernel will be allowed by bpftrace Ive added a feature tester BPFfeature inspired by the one olsajiri added in It tests kernel support by loading small programs into the kernel All tests are done during object creation which on my test VM takes around us for all We currently rely on the enum bpffuncid shipped by the kernel to do feature detection and the one shipped with libbcc in irbuilder This causes issues like and also limits the features we compile into bpftrace to what the system supports at that moment eg signal By defining this enum ourselves we avoid all those issues and make sure the symbol we need are always present This will cause some issues if the kernel people ever decide to significantly change this enum eg sorting it but that seems unlikely and will cause a lot of issues anyway eg codegen An info command has been added which reports what the kernel supports sudo bpftrace info Kernel helpers getcurrentcgroupid yes sendsignal no Kernel features Loop support no Related to Solves issues with Currently the features provided by the bpftrace binary are a product of the system that bpftrace is built on If the headers available at buildtime have a particular feature then bpftrace uses them This hurts the portability of bpftrace as it means that it has to be built for each system that it runs on Now that has merged to help adress this is more relevant of an issue systems that can potentially run a bpftrace that tries to use features their kernel doesnt support This causes issues like and for various headers to have to be bundled in This issue was first raised by danobi in The alternative paths that a solution might take that Ive thought of so far are We build bpftrace for each kernel version which adds to or modifies the BPF API and users can distribute bpftrace per kernel We teach bpftrace to detect this at runtime and either take fallback paths for compatibility Throw an exception catch whatever exception arises and warn the user that the feature is not supported or perhaps not fully supported I think that is probably going to be a lot of work and a bit of a pain The checks we have at buildtime are still good for ensuring that bpftrace can build the superset of functionality but Id prefer if it were able to still work robustly if it is running against an older kernel For this reason i favor or Im not actually sure what issues well run into Id guess that there will probably be some bugs reported against the semistatic binaries that could give some insight I know that we can at least see cases where we do ifdef in the code now so Id guess that for instance someone trying to use the cgroup builtin on a system that doesnt support it could run into this problem So if we go the path of checking kernel compatibility there will probably be more code complexity as we have to handle fallbacks stubbing functionality warning on older systems So the error handling path might be the best one as it is already a runtime system for handling fallbacks Id guess that we can just design a new exception KernelVersionException or BpfApiException or something to that effect and either warn or throw a fatal error depending on what is appropriate For a lot of users a fatal exception for a script that tries to use unhandled features isnt degrading their experience because they couldnt run the script anyways at least now they know why In other cases if functionality is missing but not critical ie there is a reasonable fallback then a warning message can be printed or the fallback to something less efficient could happen transparently fbs mmarchini danobi any thoughts on how we should tackle this DRAFT to fix ignore May need patches to BCC due to iovisorbcc which appears to also be affecting the ability to do USDT probes in containers This functionality use to work in bpftrace with BCC up to It seems to now be broken This also builds off of To do X Verify there is an underlying issue in BCC and fix it ideally before is released is up Add runtime regression tests that use mountnswrapper to make sure this regression doesnt creep back in The class has gotten too big and does way too many things now We should break it up into smaller components Work items child process management cmd and pid are used and abused too often bc they are public logging Commit cd bc c Add memory watchpoint probe prototype added support for memory watchpoint at absolute addresses That was a good first step but its fairly rare that users are working with fixed memory addresses This patchset adds support for much more powerful and dynamic memory watchpoints Consider the following example cat scratchprintfloopc attributenoinline void saysomethingint i int x i do work int main int i mallocsizeofint i while saysomethingi i random corruption sleep We could watch for the corruption but executing the following bpftrace script sudo bpftrace e watchpointsaysomething w printfsaw a write n c printfloop Attaching probe saw a write C where saysomething is the function to hook into is the argument identical to arg arg etc we treat as the target memory address is the length of the memory watchpoint bytes and w as listen for writes See individual commits for descriptions of the mechanics behind how this feature works For full examples see the attached runtime tests TODO final clang format pass documentation As mmarchini found in there are quite a few type issues which usually work fine but break LLVM segfault oom in edge cases I bumped into these too while trying to implement while loops segfaults in weird place so figured Id give them a go These are just the first there are a lot more of them but once the map ones are out of the way the rest should cause a lot less codegen changes Once everything is done adding llvmas to the testing phase might useful as it spots a lot of these issues for us eg llvmas badll error constant expression type mismatch lookupelem call i inttoptr i to i i i i pseudo i key Typestring value can be non nullterminated andor its length can be less than STRINGSIZE Fix the codes which do not take these into account This fixes errors like the following Target program c include stdioh struct a char v void fstruct a a printfc n av int main struct a a v x x x x f a return error sudo srcbpftrace e struct a char v uaoutf a struct aarg v printfs s n a a Attaching probe error sudo srcbpftrace e struct a char v uaoutf struct aarg v count Attaching uprobe Running C U Similar to as expected USDT probes in containers dont work Im mostly writing this issue as a reminder to myself to fix this similarly to how it was done in I debugged this a little bit with a colleague today clandry trying to attach to USDT probes on a JVM process inside of a container After modifying the semantic analyzer to pass a pid to resolvebinarypath we still got the error ERROR usdt target file proc rootusrshareelasticsearchjdklibserverlibjvmso does not exist or is not executable Despite the file very much existing and being executable It even shows up when you list the USDT probes for the process I dont expect this to be very complicated to fix and we confirmed that it was working in bpftrace but not master so this is clearly a regression A regression runtime test will need to be added to prevent this from regressing again once fixed bpftrace version bpftrace v sudo bpftrace e tracepointblockblockrqissue bytes argsrwbs sumargsbytes Attaching probe C bytes WS bytes R bytes R bytes RA bytes RA bytes R bytes RA bytes R There are duplicates in the string keyed map It seems like maybe the end of the string isnt being zeroed and then the whole buffer gets strcmped but that is just a guess Im running a patched version of Linux Early PR to get feedback on the approach there is still a lot to do but it is functional On a fedora machine the following code runs is a whilea if a break printfd n a exit and compiles into bf r r b r b r b u r r b u r r r map id call bpfgetsmpprocessorid bf r r r bf r r bf r r bf r r b r call bpfperfeventoutputtp r if r x goto pc goto pc b r b u r r r map id call bpfgetsmpprocessorid bf r r r bf r r bf r r bf r r b r call bpfperfeventoutputtp b r exit Ive added a runtime feature tester mostly stolen from olsajiri that tests whether the kernel supports loops But during testing I found that LLVM unrolls quite aggressively replacing with in the above example makes the code run on a kernel instructions LLVM seems to be quite picky about its IR extra branches can lead to loops or segfaults which makes the if quite complex Once this is in I can start on for loops they shouldnt be too hard once we have agreement on the approach Ive added emitir mostly for testing The IR can be passed into LLVM tools to test some manual IR changes Easier than going to a compilerun cycle TODO cleanup code tests docs more tests