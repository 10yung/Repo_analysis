When parsing a JSON file with BOM such as JSONsh gives the following error sh EXPECTED EOF GOT Current workaround is to strip these characters using tool like awk awk NR sub xef xbb xbf jsonfile sh JSONsh It would be nice if parser skip these BOM characters and start parsing after the offset It will save consumers from stripping these characters Running on an embedded system with Busybox any input fails echo JSONsh EXPECTED string GOT EOF egrep version egrep unrecognized option version BusyBox v EEST multicall binary No help available busybox help BusyBox v EEST multicall binary Copyright C Erik Andersen Rob Landley Denys Vlasenko and others Licensed under GPLv See source distribution for full notice Usage busybox function arguments or function arguments BusyBox is a multicall binary that combines many common Unix utilities into a single executable Most people will create a link to busybox for each function they wish to use and BusyBox will act like whatever it was invoked as Currently defined functions adjtimex arping ash awk basename brctl bunzip bzcat cat chgrp chmod chown chroot clear cp crond crontab cut date dd df diff dirname dmesg du echo egrep env expr false fgrep find free garp getty grep gunzip gzip halt head hexdump hostid hwclock id ifconfig init insmod kill killall killall klogd length less ln lock logger login logread ls lsmod md sum mesg mkdir mkfifo mknod mktemp mount mv nc netmsg netstat nice nslookup passwd pgrep pidof ping ping pivotroot pkill poweroff printf ps pwd pwdog rdate realpath reboot reset rm rmdir rmmod route sed seq sh sleep sort startstopdaemon strings switchroot sync sysctl syslogd tail tar tee telnet telnetd test tftp time top touch tr traceroute true udhcpc umount uname uniq uptime uudecode uuencode vconfig vi watchdog wc wget which xargs yes zcat zcip Then I looked at tokenization only Sourcing JSONsh doesnt work still expecting input so I changed the last lines like this sh if BASHSOURCE n BASHSOURCE then parseoptions tokenize parse fi parseoptions tokenize What then happens is echo shincJSONsh echo foo barsomething hi there shincJSONsh Running all tests indeed shows failures Fixes gh Step to reproduce python c print JSONsh Expected behaviour JSONsh should either parse the string or return an error Actual behaviour JSONsh line Done tokenize Segmentation fault parse JSONsh does crash because it lacks a nesting limit Step to reproduce echo x F JSONsh Expected behaviour According to RFC character DEL x F is perfectly valid unescaped JSONsh should parse the string and print x F x F Actual behaviour JSONsh cannot parse the string and prints an error EXPECTED value GOT The issue comes from the fact that JSONsh uses cntrl to recognize control characters in regular expressions and cntrl includes DEL x F while JSON control characters the one that MUST be escaped only go from U to U F and dont include U F Any objection to converting all variables to being local That would make sourcing the file a lot safer At first glance I think this would mostly amount to passing token to a bunch of functions as an argument and having them echo it back though maybe you know of a better way I guess the other option is to just declare it as local in parse and leave it to be set and read by everything else as done today This is an attempt to make it easier to parse JSONsh output from within bash The first thing I looked at was supporting direct assignment to associative arrays declare A not declare a since the native output format is very close to what you need for that That change essentially amounts to piping the original output through egrep v tr t Despite the usefulness of that Im not a fan of it because as far as I can tell the only way to actually interpret that in bash is by using an eval which is dangerous If someone finds a flaw in any of this they could potentially inject any arbitrary code which would then get evald Ill leave it to the reader to figure out what something like eval rm rf would end up doing The next thing I looked at was better support for read r key value Thanks to the tab delimiter that was also pretty easy I just stripped the surrounding the path This seems pretty robust so long as you change IFS to t That works because tabs arent valid in JSON and the script seems to detect that pretty robustly though I didnt exhaustively test that The part I dont like about keyvalue mode is everything stays wrapped in doublequotes Probably not a big deal for keys I guess but Im worried it might cause problems for values Especially values that have escapes in them Maybe theres a clean way to deal with that The remaining modes are simple keyonly and valueonly produce one key or value per line as youd expect The default mode retains the same behavior as today I also added a script of examples Its a bit verbose and ugly but at least it gives a good foundation on using the script It does lean very heavily towards the function interface though which is probably not a good thing to promote since JSONsh makes heavy use of globals i use JSONsh as curl JSONsh l p b s and it work greet and it return result like bash storagemysqludbdatabase dev storagemysqludbusername user storagemysqludbpassword storagemysqludbinternalip storagemysqludbinternalport storagemysqladatabase a storagemysqlausername user storagemysqlapassword a but what if add config param to determine how output look like and go with exporting this variables as env variables like bash storagemysqludbinternalport storagemysqladatabasea storagemysqlausernameuser storagemysqlapassword a which make it easy to be evaluated with eval as environment variable The option s does not work echo str ab str b libJSONsh s still see the and Im using JSONsh in a Cygwin environment and Im getting an error when trying to use it for any kind of JSON EXPECTED value GOT EOF Tried with your example curl registrynpmjsorgexpress JSONsh egrep versions Also tried with echo foo bar JSONsh Maybe related to Or maybe related to CRLF vs LF on Windows vs Linux note Im using Cygwin on Windows 