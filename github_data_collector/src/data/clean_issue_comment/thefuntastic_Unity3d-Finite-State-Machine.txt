I am experiencing a strange issue it seems that the state machine does not wait for the Enter Coroutine to finish its execution before executing the Update function c IEnumerator NextRoundEnter DebugLogNextRound Enter yield return new WaitForSeconds f DebugLogNextRound Enter void NextRoundUpdate DebugLogNextRound Updating see the logs attached img width altScreen Shot at PM src This is a great library and I really wish that this functionality work This is due using dictionary without IEqualityComparer implementation Not sure if its possible to create an generic enum version For some reason this code will load the level instantly on Enter instead of waiting until the MainMenuEnter private AsyncOperation load new AsyncOperation void IntroEnter Preload Level StartCoroutinePreLoadLevel void IntroUpdate introTimer TimedeltaTime if introTimer introLength fsmChangeStateStatesMainMenu void MainMenuEnter Show preloaded level loadallowSceneActivation true IEnumerator PreLoadLevel load SceneManagerLoadSceneAsyncscene LoadSceneModeAdditive loadallowSceneActivation false yield return null Moving the StartCoroutine out into the Start function will work as expected Can this line then be removed StateMachineStateMachinecs warning CS The private field MonsterLoveStateMachineStateMachineTignoredNames is assigned but its value is never used Code like below will rise NullReferenceException because of fsm not yet initialized C public class TestClass MonoBehaviour void Start InitFSM FSM StateMachineStates fsm enum States Init Running void InitFSM fsm StateMachineStatesInitializethis StatesInit void InitEnter fsmChangeStateStatesRunning NullReferenceException InitEnter called before fsm had been initialized And the temporary solution is use C fsm StateMachineStatesInitializethis fsmChangeStateStatesInit instead of C fsm StateMachineStatesInitializethis StatesInit This never evaluates to true so always the next return line is executed which produces undesirable behavior The condition should check if the lastStatestate is null if lastStatestate null return defaultT It seems that when the methods variable gets set in the public StateMachine const it only grabs the methods for the toplevel class I have a class that inherits from another that actually contains the callbacks for the FSM However the inheriting classs methods get set not the actual Initializethis class I see removing the BindingFlagsDeclaredOnly flag will fix this but is there a better way As soon as I open the example project I get this error error CS An assembly MonoCecil with the same identity has already been imported Consider removing one of the references AssetsUnityTestToolsIntegrationTestsFrameworkLibsMonoCecildll Location of the symbol related to previous error CProgram FilesUnity f EditorDataManagedMonoCecildll Location of the symbol related to previous error If I remove that file then I get even more errors If I read the source correct it is forbidden to pass the current state as new state parameter to the ChangeState method if currentState nextState return Any reasons for that I have some kind of waypoint system an actor is patrolling Within the respective Enter method I initialize movement within the respective Exit method I choose the next waypoint So proceed to the next waypoint could be an elegant ChangeState call passing the current state again resulting in calling EnterUpdateExit chain again Any reasons youre not supporting this Thank you Quick PR to add support for OnTriggerEnter and OnTriggerExit to the StateMachine