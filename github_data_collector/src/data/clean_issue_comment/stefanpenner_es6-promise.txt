 Automatically providesreplaces Promise if missing or broken script src script src Minified version of es promiseauto below script src script src What is different between es promisejs and es promiseautojs Is it required to include both scripts in html page What happens if just include either of es promisejs or es promiseautojs Now that PromiseallSettled reached stage of the specification process would it make sense to add a polyfill for it to this project Or would you rather recommend to add a separate shim for it something like esshimsPromiseallSettled IMO thats less convenient but creating yet another implementation also sounds wrong Hello Im using vuecli with es promise babelconfigjs requirees promisepolyfill moduleexports presets vueapp polyfills es promise es symbol and ie crushing project in this place img width altScreenshot at src I saw in yours documentation that catch and finally reserved words in ie How i can fix this Thanks ts import Promise as Promise from es promise export const error Promise void Promiseresolve export const error Promisevoid Promise resolve Sandbox With lib es es promise error fails to compile with the message Property finally is missing in type Promisevoid but required in type Promisevoid Sandbox With lib es es promise es promise error fails to compile with the message Type Promisevoid is not assignable to type importsandboxnodemoduleses promisees promisePromisevoid Types of property catch are incompatible Type TResult neveronrejected reason any TResult PromiseLikeTResult Promisevoid TResult is not assignable to type UonRejected error any U ThenableU PromiseU Type Promisevoid U is not assignable to type PromiseU Types of property then are incompatible Type TResult void U TResult neveronfulfilled value void U TResult PromiseLikeTResult onrejected reason any TResult PromiseLikeTResult PromiseTResult TResult is not assignable to type UonFulfilled value U U ThenableU onRejected error any U ThenableU PromiseU UonFulfilled value U U ThenableU onRejected error any void Promise Types of parameters onfulfilled and onFulfilled are incompatible Types of parameters value and value are incompatible Type void U is not assignable to type U Type void is not assignable to type U Sandbox Using es or newer in place of es above gives the same message for error but adds another failure for error with the message Property SymboltoStringTag is missing in type Promisevoid but required in type Promisevoid The error message was brought up in which was closed without a fix Its really frustrating working with libraries that use es promise and export the type in their signatures because you need to wrap the promises or cast away all type safety Are there any TypeScript lib configurations that are compatible with this librarys typings or are there any plans to update the definitions to be compatible version js Promiseprototypecatch function catchonRejection return thisthennull onRejection if use webpack this loader can solve the problem in some situation One of the overloads for Thenablethen is typescript then U onFulfilled value R U ThenableU onRejected error any void ThenableU However consider this example typescript let promise Promisenumberrejectnew Errorerror let newPromise promisethen value number string valuetoString error any void consolelogerror The type of newPromise based on the overload is Promisestring However because the onRejected function doesnt throw or return a rejected promise newPromise becomes a resolved promise with the return value of onRejected which is void which means that newPromise should be PromiseT void Specifically this code should not compile typescript newPromisethenvalue string value should be string void since it could have a value from the onRejected branch Here we try to get the then method from an undefined thing called promise I think it should look like Promisethen since Promise is defined Ive seen this in IE no Promise there and we always run into the catch branch Iv thought that this is not its intention I just had some trouble with the polyfill Im building a browser app which has a global variable named global This caused the polyfill to add the Promise object to my global object instead of adding it to window The opposite could also happen building a Node app that has a variable named window Not sure if this should be fixed though I reckon it was probably a bad idea by me to have a global variable anyway I renamed it to something else so I can continue to use this polyfill The latest version available on cdnjs is would be great to get the latest version on there In a testing framework that we use Promiseresolve is intercepted among others to implement some bookkeeping for pending promises timers requests etc The intercepting code looks something like this js function const originalResolve Promiseresolve Promiseresolve functionvalue propagate the current call to the original function using the same context and argument let result originalResolvecallthis value bookkeeping is implemented around the original call doesnt matter here return result Recently we tried to upgrade es promise from to to benefit from Promiseprototypefinally But then the above intercepting code failed with a TypeError Constructor is not a constructor at resolve es promisejs The reason seems to be that es promises current Promiseresolve implementation relies on this to allow inheritance but the EnumeratorprototypeeachEntry implementation ignores this fact here in combination with line To cite from IMO applies to resolve as well If you wish to destructure all it can be but must be first bound Well I understand that this applies to our test framework line and binding originalResolve would fix the issue But I think the strategy of calling the originalResolve with the current this and argument line is also fine and a bit more universal It even should work if someone would reuse the wrapped Promiseresolve in a subclass of Promise IMO it would be fair if EnumeratorprototypeeachEntry either would follow the if you wish to destructure it first must be bound rule itself or would call Constructorresolve in line What do you think 