Halide is available as a port in vcpkg a C library manager that simplifies installation for Halide and other project dependencies Documenting the install process here will help users get started by providing a single set of commands to build Halide ready to be included in their projects We also test whether our library ports build in various configurations dynamic static on various platforms OSX Linux Windows x x UWP ARM to keep a wide coverage for users Im a maintainer for vcpkg and here is what the port script looks like We try to keep the library maintained as close as possible to the original library Hi I was able to fix make testapps under Ubuntu Here are the things I did I fixed the parameter passed to protoc in appsonnxMakefile It looks that protopath option is required under ubuntu I fixed the compilation issues on appsonnxonnxconvertercc Mainly I replaced stdvectorstdpairHalideExpr HalideExpr extents with HalideRegion extents Since has not been yet solved Ive commented this line in srcDimensionh HALIDEATTRIBUTEDEPRECATEDextentestimate will be removed soon do not use Before going for a pull request and since still creates problems Im just sending a patch in this way Maybe it could be of some help to someone halidetxt My setup is using Ubuntu g export LLVMCONFIGusrbinllvmconfig these apt packages libatlasbasedev libopenblasdev libeigen dev pybind cloned from revision e ccb db b d f f The halide code used is the one in master a e fd ecd dcc e ef f e ee af Cheers Fabrizio Currently Halide codegen for CPUs doesnt take much of a position on whether fusedmultiplyadd ops are used are not generally we rely on whatever LLVM does for a given target Do we want to revisit this to give more control to the pipeline author In theory FMA is nothing but a win faster and more accurate whee but has some subtle gotchas For instance if you are compiling a pipeline for the multitarget x avx x sse youll get code that runs with FMA if you happen to be on an AVX machine but without on older chips this means that results and test goldens etc need to specialize not just by compiledarch but also by actualruntimemicroarchitecture in some cases Currently the only way to disable FMA operations is by using strictfloat which is a bigger hammer than we really need it disables all of ffastmath but also effectively disables most simplification of FP code Adding more fun to this situation is that AFAICT there isnt a way in LLVM to disable just the FMAstyle ops it seems that enabling any of UnsafeMath FpContract AllowReassoc for LLVM will allow if to emit FMA ops Not sure if there is a right way is to address this Some thoughts If there was a reliable way to disable just FMA in LLVM Id argue the best thing would be to disable that by default then allow optin on either a global basis via a Feature flag or via a perExpr wrapper a la strictfloat or perhaps by an explicit fma suite of operators Alternately for better backwards compatibility invert the logic enable FMA by default allow disabling via feature andor wrapper Add a TargetFeature that is just disable fastmath but that doesnt disable all the FP simplifications as does strictfloat Do nothing and continue the status quo Something else I havent thought of Calls to halidemsancheckbufferisinitialized now emit the name of the buffer that failed msan check this is useful in complex pipelines with many inputs I tried the following code cpp HalideImageParam inputaHalidetypeoffloat inputa inputadim setbounds HalideImageParam inputbHalidetypeoffloat inputb HalideFunc fouta goutb HalideVar i j k fi j k inputai j k gi j k inputbi j k stdvectorHalideFunc fs fspushbackf fspushbackg HalidePipeline pfs paddrequirementinputadim extent inputbdim extent paddrequirementinputadim extent inputbdim extent paddrequirementinputadim extent paddrequirementinputbdim extent foutputbufferdim setbounds HalideTarget targetx linuxsse avxavx stdvectorHalideArgument inputs inputspushbackinputa inputspushbackinputb pcompiletoloweredstmtstdstringtmpexamplestmt inputs HalideText target I expected that all the extents of f and g be fully known For f the first extent would come from the bounds specification on inputa the second from the explicit specification of the bounds of the output buffer and the third from the pipeline requirement For g I was hoping that the pipeline requirements would also be leveraged to derive the bounds However in practice the only known extent in examplestmt is the one specified through foutputbufferdim setbounds All the other extents remain symbolic Of course in this trivial example I could directly set the bounds on f and g but there are cases where this is difficult Is there any way to improve the simplifier to start taking pipeline requirements and input extents into account Im having trouble building the latest master recently The latest working version I found was built several days ago before the LICENSE only contains lines ccache usrlocalbinclang Isrc Itools Iinclude fdebugprefixmaptmpscratchusrlocalsrc g O Wall Wnounusedfunction Wcastqual Woverloadedvirtual Wignoredqualifiers Werror DWITHEXCEPTIONS stdc MD MT utilCMakeFilesHalideTraceDumpdirHalideTraceUtilscppo MF utilCMakeFilesHalideTraceDumpdirHalideTraceUtilscppod o utilCMakeFilesHalideTraceDumpdirHalideTraceUtilscppo c utilHalideTraceUtilscpp usrlocalbincmake E remove liblibusercontextinsanitygeneratorlibrarya usrbinar qc liblibusercontextinsanitygeneratorlibrarya testCMakeFilesusercontextinsanitygeneratorlibrarydirgeneratorusercontextinsanitygeneratorcppo usrbinranlib liblibusercontextinsanitygeneratorlibrarya usrlocalbincmake E remove liblibtiledblurgeneratorlibrarya usrbinar qc liblibtiledblurgeneratorlibrarya testCMakeFilestiledblurgeneratorlibrarydirgeneratortiledblurgeneratorcppo usrbinranlib liblibtiledblurgeneratorlibrarya usrlocalbincmake E remove liblibrdominputgeneratorlibrarya usrbinar qc liblibrdominputgeneratorlibrarya testCMakeFilesrdominputgeneratorlibrarydirgeneratorrdominputgeneratorcppo usrbinranlib liblibrdominputgeneratorlibrarya usrlocalbinclang fdebugprefixmaptmpscratchusrlocalsrc g O fuseldlld rdynamic testCMakeFileshalidelibraryruntimegeneratorbinarydirtoolsGenGencppo o binhalidelibraryruntimegeneratorbinary WlrpathtmpscratchHalidebuildlib lz lrt ldl ltinfo lpthread lm lxml ldl lpthread liblibHalideso lm lxml ldl FAILED binhalidelibraryruntimegeneratorbinary usrlocalbinclang fdebugprefixmaptmpscratchusrlocalsrc g O fuseldlld rdynamic testCMakeFileshalidelibraryruntimegeneratorbinarydirtoolsGenGencppo o binhalidelibraryruntimegeneratorbinary WlrpathtmpscratchHalidebuildlib lz lrt ldl ltinfo lpthread lm lxml ldl lpthread liblibHalideso lm lxml ldl ldlld error liblibHalideso undefined reference to llvmTargetRegistrylookupTargetstd basicstringchar std chartraitschar std allocatorchar const std basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmWriteBitcodeToFilellvmModule const llvmrawostream bool llvmModuleSummaryIndex const bool std arrayunsigned int ul ldlld error liblibHalideso undefined reference to llvmPassManagerBuilderaddExtensionllvmPassManagerBuilderExtensionPointTy std functionvoid llvmPassManagerBuilder const llvmlegacyPassManagerBase ldlld error liblibHalideso undefined reference to llvmEngineBuildersetMCJITMemoryManagerstd uniqueptrllvmRTDyldMemoryManager std defaultdeletellvmRTDyldMemoryManager ldlld error liblibHalideso undefined reference to llvmEngineBuilderEngineBuilderstd uniqueptrllvmModule std defaultdeletellvmModule ldlld error liblibHalideso undefined reference to llvmRTDyldMemoryManagergetPointerToNamedFunctionstd basicstringchar std chartraitschar std allocatorchar const bool ldlld error liblibHalideso undefined reference to llvmRTDyldMemoryManagergetSymbolAddressInProcessstd basicstringchar std chartraitschar std allocatorchar const ldlld error liblibHalideso undefined reference to llvmSectionMemoryManagerfinalizeMemorystd basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmLegacyJITSymbolResolvergetResponsibilitySetstd setllvmStringRef std lessllvmStringRef std allocatorllvmStringRef const ldlld error liblibHalideso undefined reference to llvmLegacyJITSymbolResolverlookupstd setllvmStringRef std lessllvmStringRef std allocatorllvmStringRef const std functionvoid llvmExpectedstd mapllvmStringRef llvmJITEvaluatedSymbol std lessllvmStringRef std allocatorstd pairllvmStringRef const llvmJITEvaluatedSymbol ldlld error liblibHalideso undefined reference to llvmsysDynamicLibrarygetPermanentLibrarychar const std basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmwriteArchivellvmStringRef llvmArrayRefllvmNewArchiveMember bool llvmobjectArchiveKind bool bool std uniqueptrllvmMemoryBuffer std defaultdeletellvmMemoryBuffer ldlld error liblibHalideso undefined reference to llvmrawfdostreamrawfdostreamllvmStringRef std errorcode llvmsysfsOpenFlags ldlld error liblibHalideso undefined reference to llvmLinkerlinkModulesllvmModule std uniqueptrllvmModule std defaultdeletellvmModule unsigned int std functionvoid llvmModule llvmStringSetllvmMallocAllocator const ldlld error liblibHalideso undefined reference to stdstringRepMdestroystdallocatorchar const ldlld error liblibHalideso undefined reference to stdstringRepSemptyrepstorage ldlld error liblibHalideso undefined reference to stdstringassignstdstring const ldlld error liblibHalideso undefined reference to stdbasicstringchar stdchartraitschar stdallocatorchar basicstringchar const unsigned long stdallocatorchar const ldlld error liblibHalideso undefined reference to stdthrowbadfunctioncall ldlld error liblibHalideso undefined reference to stdbasicstringchar stdchartraitschar stdallocatorchar basicstringchar const stdallocatorchar const ldlld error too many errors emitted stopping now use errorlimit to see all errors clang error linker command failed with exit code use v to see invocation usrlocalbinclang fdebugprefixmaptmpscratchusrlocalsrc g O fuseldlld rdynamic testCMakeFilesusercontextinsanitygeneratorbinarydirtoolsGenGencppo o binusercontextinsanitygeneratorbinary WlrpathtmpscratchHalidebuildlib lz lrt ldl ltinfo lpthread lm lxml ldl lpthread Wlwholearchive liblibusercontextinsanitygeneratorlibrarya Wlnowholearchive liblibHalideso lm lxml ldl FAILED binusercontextinsanitygeneratorbinary usrlocalbinclang fdebugprefixmaptmpscratchusrlocalsrc g O fuseldlld rdynamic testCMakeFilesusercontextinsanitygeneratorbinarydirtoolsGenGencppo o binusercontextinsanitygeneratorbinary WlrpathtmpscratchHalidebuildlib lz lrt ldl ltinfo lpthread lm lxml ldl lpthread Wlwholearchive liblibusercontextinsanitygeneratorlibrarya Wlnowholearchive liblibHalideso lm lxml ldl ldlld error liblibHalideso undefined reference to llvmTargetRegistrylookupTargetstd basicstringchar std chartraitschar std allocatorchar const std basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmWriteBitcodeToFilellvmModule const llvmrawostream bool llvmModuleSummaryIndex const bool std arrayunsigned int ul ldlld error liblibHalideso undefined reference to llvmPassManagerBuilderaddExtensionllvmPassManagerBuilderExtensionPointTy std functionvoid llvmPassManagerBuilder const llvmlegacyPassManagerBase ldlld error liblibHalideso undefined reference to llvmEngineBuildersetMCJITMemoryManagerstd uniqueptrllvmRTDyldMemoryManager std defaultdeletellvmRTDyldMemoryManager ldlld error liblibHalideso undefined reference to llvmEngineBuilderEngineBuilderstd uniqueptrllvmModule std defaultdeletellvmModule ldlld error liblibHalideso undefined reference to llvmRTDyldMemoryManagergetPointerToNamedFunctionstd basicstringchar std chartraitschar std allocatorchar const bool ldlld error liblibHalideso undefined reference to llvmRTDyldMemoryManagergetSymbolAddressInProcessstd basicstringchar std chartraitschar std allocatorchar const ldlld error liblibHalideso undefined reference to llvmSectionMemoryManagerfinalizeMemorystd basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmLegacyJITSymbolResolvergetResponsibilitySetstd setllvmStringRef std lessllvmStringRef std allocatorllvmStringRef const ldlld error liblibHalideso undefined reference to llvmLegacyJITSymbolResolverlookupstd setllvmStringRef std lessllvmStringRef std allocatorllvmStringRef const std functionvoid llvmExpectedstd mapllvmStringRef llvmJITEvaluatedSymbol std lessllvmStringRef std allocatorstd pairllvmStringRef const llvmJITEvaluatedSymbol ldlld error liblibHalideso undefined reference to llvmsysDynamicLibrarygetPermanentLibrarychar const std basicstringchar std chartraitschar std allocatorchar ldlld error liblibHalideso undefined reference to llvmwriteArchivellvmStringRef llvmArrayRefllvmNewArchiveMember bool llvmobjectArchiveKind bool bool std uniqueptrllvmMemoryBuffer std defaultdeletellvmMemoryBuffer ldlld error liblibHalideso undefined reference to llvmrawfdostreamrawfdostreamllvmStringRef std errorcode llvmsysfsOpenFlags ldlld error liblibHalideso undefined reference to llvmLinkerlinkModulesllvmModule std uniqueptrllvmModule std defaultdeletellvmModule unsigned int std functionvoid llvmModule llvmStringSetllvmMallocAllocator const ldlld error liblibHalideso undefined reference to stdstringRepMdestroystdallocatorchar const ldlld error liblibHalideso undefined reference to stdstringRepSemptyrepstorage ldlld error liblibHalideso undefined reference to stdstringassignstdstring const ldlld error liblibHalideso undefined reference to stdbasicstringchar stdchartraitschar stdallocatorchar basicstringchar const unsigned long stdallocatorchar const ldlld error liblibHalideso undefined reference to stdthrowbadfunctioncall ldlld error liblibHalideso undefined reference to stdbasicstringchar stdchartraitschar stdallocatorchar basicstringchar const stdallocatorchar const ldlld error too many errors emitted stopping now use errorlimit to see all errors clang error linker command failed with exit code use v to see invocation usrlocalbincmake E remove liblibpyramidgeneratorlibrarya usrbinar qc liblibpyramidgeneratorlibrarya testCMakeFilespyramidgeneratorlibrarydirgeneratorpyramidgeneratorcppo usrbinranlib liblibpyramidgeneratorlibrarya usrlocalbincmake E remove libliboldbuffertgeneratorlibrarya usrbinar qc libliboldbuffertgeneratorlibrarya testCMakeFilesoldbuffertgeneratorlibrarydirgeneratoroldbuffertgeneratorcppo usrbinranlib libliboldbuffertgeneratorlibrarya ccache usrlocalbinclang Iinclude Itools fdebugprefixmaptmpscratchusrlocalsrc g O Wall Wnounusedfunction Wcastqual Woverloadedvirtual Wignoredqualifiers Werror DWITHEXCEPTIONS fnortti stdc MD MT appslinearalgebrasrcCMakeFilesddotgeneratorbinarydirtoolsGenGencppo MF appslinearalgebrasrcCMakeFilesddotgeneratorbinarydirtoolsGenGencppod o appslinearalgebrasrcCMakeFilesddotgeneratorbinarydirtoolsGenGencppo c toolsGenGencpp ccache usrlocalbinclang Iinclude Itools fdebugprefixmaptmpscratchusrlocalsrc g O Wall Wnounusedfunction Wcastqual Woverloadedvirtual Wignoredqualifiers Werror DWITHEXCEPTIONS fnortti stdc MD MT appslinearblurCMakeFilessrgbtolineargeneratorbinarydirtoolsGenGencppo MF appslinearblurCMakeFilessrgbtolineargeneratorbinarydirtoolsGenGencppod o appslinearblurCMakeFilessrgbtolineargeneratorbinarydirtoolsGenGencppo c toolsGenGencpp ccache usrlocalbinclang Iinclude Itools fdebugprefixmaptmpscratchusrlocalsrc g O Wall Wnounusedfunction Wcastqual Woverloadedvirtual Wignoredqualifiers Werror DWITHEXCEPTIONS fnortti stdc MD MT testCMakeFilesmetadatatestergeneratorlibrarydirgeneratormetadatatestergeneratorcppo MF testCMakeFilesmetadatatestergeneratorlibrarydirgeneratormetadatatestergeneratorcppod o testCMakeFilesmetadatatestergeneratorlibrarydirgeneratormetadatatestergeneratorcppo c testgeneratormetadatatestergeneratorcpp specialize lets you schedule a func in different ways To some extent you can schedule things it calls differently too by having them specialize in the same way but this is limited You cant change Funclevel scheduling choices on them eg inlined vs not or different storage layouts or different memory types This would be a useful feature Currently I have a GPU pipeline that uses an amount of shared memory that depends on some parameters I would like it to switch to using global memory for that Func if the parameters are large enough to need it The autoscheduler seems to assume that the bound estimates can always be relied upon and generate out of bounds memory access in the example below which simply tries to compute fx y z t in z where in is a buffer and the estimate for the size of f is but the requested size for f is cpp stduniformrealdistributionfloat dis stdmt rnd HalideBufferfloat in inforeachvalue float f f disrnd HalideFunc f stdvectorHalideVar vars stdvectorHalideExpr indices indices indices vars indices fvars inindices stdvectorHalideFunc fs fspushbackf HalidePipeline pfs HalideMachineParams params HalideTarget targetx linuxsse avxavx When autoscheduling is disabled the code works correctly if stdcout RUNNING WITH ADAMS SCHEDULE stdendl fsetestimates stdvectorHalideInternalFunction funcs funcspushbackffunction HalideInternalAutoschedulerFunctionDAG dagfuncs params target HalideDefaultCostModel costmodel false HalideInternalAutoschedulerStageMapOfScheduleFeatures schedulefeatures HalideInternalAutoschedulerfindandapplyschedule dag funcs params costmodel schedulefeatures else stdcout RUNNING WITH DEFAULT SCHEDULE stdendl endif for int i i i foutputbufferdimisetbounds HalideBufferfloat outputvalues HalideRealization routputvalues prealizer target for int i i i for int j j j for int k k k for int l l l float expected in k EXPECTEQoutputvaluesi j k l expected 