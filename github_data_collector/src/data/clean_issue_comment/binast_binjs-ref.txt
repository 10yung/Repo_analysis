 Context specifies that we can only use bits for a key Were currently using an algorithm that always returns optimalforspace keys and this algorithm may fail by exhausting the bits while less optimalforspace algorithms could succeed We should devise a backup strategy that will work in cases in which we currently fail This is a first step towards decompressing Huffman content In practice with context we have some files which are almost monomorphic But as soon as they have a single field with a different value then we have to use one bit per field for all of the fields If we used entropy codes like ANS we could get more efficient encodings than Huffman in these cases The context file format has one model for a given field Say you have a file where someones pasted two source files together and the first half of the file uses var and the second half uses let and const In context youll end up with a model with a mixture of var let and const and need bits for each symbol to describe variable kinds If instead the file format could have multiple models and switch between them then for the first half of the file it could have a model specifying bits for var and then a switch and a model with bit for let or const and that would be good There are probably fancier ideas where you switch sets of related models at once Brotli does something like this if you look at RFC and the BlockSwitch stuff So sprach dominiccooney The format only shares codes between StaticMemberAssignmentTargetproperty and StaticMemberExpressionproperty more sharing or imputing is probably beneficial Quote from dominiccooney The input AST structure has a number of redundancies which the compressor does not exploit but could exploit for smaller file sizes For example there is a lot of overlap between parameter lists and declared names Note Pretty sure we have tested this specific example already with a previous version of the encoding Need to dig up the results Quoted from dominiccooney The presence of an EmptyCodeTable could suppress encoding the length for a given array which must be zero at that point If I understand correctly the idea is to use EmptyCodeTable for length arrays instead of a UnitCodeTable followed by a bit length Quoted from dominiccooney The format only supports seeking within the decompressed stream With better native compression the Brotli wrapper would not be necessary and the format could seek instead within the compressed stream I believe the primary problem with sizes today is the verbose encoding of code tables I dont understand the last sentence In Context the root is hardcoded as being Script Is there anything that prevents us from using Program as root