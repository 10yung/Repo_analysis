Now that were on the latest cats etc Id like to make sure we minimize binary compatibility breakages going forward Example of adding them to an existing project The doc links go to master branch and I need to add the section Ill still release a milestone build on catseffectfs x but with a warning that theres possibly an issue in this module Im reasonably happy with this approach This version has clear versions that do support the behavior we want to have A dropin replacement for the old version minus type annotations that effectively reimplements the previous unsafe behavior but removing the default Still todo Probably should have some tests It would be nice to add a scalafix migration to eliminate the mechanical work someone needs to do on upgrade The work isnt hard but potentially there might be compile errors that are confusing for people who are newer to scala If we want to keep the single method name instead of split method names well have to implement some dependent type typeclass trickery gitter chat about it October AM The problem Akka streams have materialized values but the default toStream or toSink discard them Ive created race conditions by converting sinks with a materialized Future result and not waiting on that future Adhoc solution I created this scala implicit class RichAkkaSink A B val sink AkkaSink A Future B extends AnyVal Converts an akka sink with a successstatusindicating Future B materialized result into an fs stream which will fail if the Future fails The stream returned by this will emit the Futures value one time at the end then terminate def toSinkWithStatusMat implicit ec ExecutionContext m Materializer Pipe IO A B Fs AkkaCompattoSinkWithStatusMatsink The same as toSinkWithStatusMat but ignoring the materialized value def toSinkWithStatusMat implicit ec ExecutionContext m Materializer Sink IO A in inthroughFs AkkaCompattoSinkWithStatusMatsinkvoid Converts an akka sink with a successstatusindicating Future B materialized result into an fs stream which will fail if the Future fails The stream returned by this will emit the Futures value one time at the end then terminate def toSinkWithStatusMat A B akkaSink AkkaSink A Future B implicit ec ExecutionContext m Materializer Pipe IO A B val mkPromise Promiseempty IO Either Throwable B Sink is just a function of Stream F A Stream F Unit so we take a stream as input in StreamevalmkPromiseflatMap p Akka streams produce a materialized value as a side effect of being run streamzconverters allows us to have a Future Done Unit callback when that materialized value is created This callback tells the akka materialized future to store its result status into the Promise val captureMaterializedResult Future B Unit onComplete case Failureex pcompleteLeftexunsafeRunSync case Successvalue pcompleteRightvalueunsafeRunSync toSink is from streamzconverters convert an akka sink to fs sink with a callback for the materialized values val fs Sink Sink IO A akkaSinktoSinkcaptureMaterializedResult val fs Stream Stream IO Unit fs Sinkapplyin val materializedResultStream Stream IO B Streameval pget Async wait on the promise to be completed IO Either Throwable B rethrow IO Either Throwable B IO B Run the akka sink for its effects and then run stream containing the effect of getting the Promise results fs Streamdrain materializedResultStream The problem with my approach is that the user is still required to realize they need the alternate converter method A more comprehensive solution Id like to make a breaking API change before we make the x release scala currently def toSinkonMaterialization M Unit Proposed scala package streamzconverter For convenience on wildcard imports val Discard M Unit def toSinkonMaterialization M Unit def toSinkimplicit ev M AkkaNotUsed This guarantees that a caller must either provide an explicit onMaterialization for which Discard will be wildcard imported for convenience or if they dont want to pass one that M must be NotUsed I havent tested this yet but I believe the general approach should work If youre willing to take this Ill send a PR implementing it In addition to replying to consumed inout message exchanges also support delayed ack of consumed inonly message exchanges eg by extending the DSL with an ack element Implementation of this features should also cover Stream errors see also difference between errors and failures should be translatable to negative acknowledgements exceptions or faults on individual message exchanges while stream failures should fail all message exchanges that are currently being processed 