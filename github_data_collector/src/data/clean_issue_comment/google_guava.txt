 Add some API for resolving the type parameters of methods in particular when some or all of the argument types for a method invocation are known TypeTokenresolveTypeType is useful for resolving type parameters of classes but I dont see a way to resolve type parameters of methods Take the method ListsreverseList for example Suppose I have obtained the following somehow The javalangreflectMethod object representing ListsreverseList I just have a reference to a Method I dont have static knowledge that its the reverse method specifically The actual Type of the argument Id like to provide to this method such as ArrayListString The actual Type of the variable in which Id like to store the result returned from this method such as CollectionString and I want to answer these questions Is it type safe to provide this argument to that method yes Is it type safe to store the result of this method into this variable yes I dont think there is any API for answering either of those questions right now This code doesnt get there java InvokableLists Object method TypeTokenofListsclassmethod ListsclassgetMethodreverse Listclass Systemoutprintlnmethod public static T ListT reverseListT list TypeToken parameterType methodgetParametersget getType SystemoutprintlnparameterType ListT TypeToken returnType methodgetReturnType SystemoutprintlnreturnType ListT TypeToken argumentType new TypeTokenArrayListString SystemoutprintlnargumentType ArrayListString TypeToken variableType new TypeTokenCollectionString SystemoutprintlnvariableType CollectionString boolean isArgumentSafe argumentTypeisSubtypeOfparameterType SystemoutprintlnisArgumentSafe false but thats not right boolean isVariableSafe returnTypeisSubtypeOfvariableType SystemoutprintlnisVariableSafe false also not right See if using TypeTokenresolveTypeType helps TypeToken wrongResolvedParameterType argumentTyperesolveTypeparameterTypegetType SystemoutprintlnwrongResolvedParameterType ListT nope probably because the arguments T comes from Listclass whereas this T comes from the Listsreverse method TypeToken wrongResolvedReturnType argumentTyperesolveTypereturnTypegetType SystemoutprintlnwrongResolvedReturnType ListT nope Im not sure what such an API would look like Heres one idea java InvokableLists Object resolvedMethod methodwithArgumentTypesargumentType new method SystemoutprintlnresolvedMethodgetParametersget getType ListString SystemoutprintlnresolvedMethodgetReturnType ListString I need to limit the bandwidth of the file downloading and limit the bandwidth to MBs but the real download bandwidth can only reach MBs java RestController class HelloWorldController GetMapping public String sayHello return hello world GetMappingdownload public ResponseEntityResource download throws FileNotFoundException RateLimiter rateLimiter GuavaRateLimitercreate L TimeUnitMILLISECONDS FileInputStream in new FileInputStreamhomehujianxinDownloadsofficesp kb fullfilex enusexe InputStreamResource resource new InputStreamResourcenew InputStream Override public int read throws IOException rateLimiteracquire return inread Override public int readbyte b throws IOException rateLimiteracquireblength return inreadb Override public int readbyte b int off int len throws IOException rateLimiteracquirelen return inreadb off len return ResponseEntityokbodyresource I doubt that anyone has ever hit this in practice I didnt see any bugs filed internally about it anyway nor any mentions of it on the web But I thought it was neat java cat ConcatTsjava import static comgooglecommoncollectObjectArraysconcat public class ConcatTs public static void mainString args String array new String Object concatenated concatarray javac cp HOMEm repositorycomgoogleguavaguava jreguava jrejar ConcatTsjava java cp HOMEm repositorycomgoogleguavaguava jreguava jrejar ConcatTs Exception in thread main javalangArrayStoreException javalangInteger at comgooglecommoncollectObjectArraysconcatObjectArraysjava at ConcatTsmainConcatTsjava Interestingly we got this right in concatT T ClassT which requires a Class to use to create the array back in CL But we got it wrong in the new methods in CL Fixes Fixes As mentioned in this is needed to remove Threadsleep from unit tests of classes that internally use RateLimiter eg Are there collectors that create and populate graphs that I perhaps have missed For example can I easily stream the entries of a MapK K and return a say directed graph that would contain the corresponding edges If so please document on the wiki If not please consider adding a set of nice collectors similar to those available for the guava collection classes Hello In checkstyle project we are adding a new check to detect noarg calls to superclass constructor super We run analysis on your source code and there are several violations that you can see in report Is there some reason to keep this explicit calls to superclass constructor in code in your opinion Or it is just garbage that can be removed I appreciate any feedback There s MultimapsasMap to transform a SetMultimapK V to a MapK SetV but there s no MultimapsasMap to transform an ImmutableSetMultimapK V to a MapK ImmutableSetV it seems Have you considered adding this method Is it already available somehow Currently I copy the content into a new ImmutableSetMultimap which seems unnecessary MultimapsasMapmyImmutableSetMultimapentrySetstreamcollectImmutableMaptoImmutableMape egetKey e ImmutableSetcopyOfegetValue The following piece of code throws an undocumented IllegalArgumentException final SetString products SetsnewHashSetcoffee tea final ListSetString productOf CollectionsnCopies products assert SetscartesianProductproductOfsize IntegerMAXVALUE The fact that SetscartesianProduct will throw an IllegalArgumentException when there would be more than elements in the resulting set is not documented as far as I can see I would like to see one of two solutions Document why this Exception is thrown there may be an implementation detail that prevents even defining such large sets Fix it because javautilSetsize specifies that if the size would be more than IntegerMAXVALUE it would simply be IntegerMAXVALUE I like to see this fixed solution because now I cant even define such a Cartesian product Iterating over so many elements is of course a different issue but I have a piece of code that may very quickly find an element in the product because I know it is in there and due to some ordering on element In order to solve issues like We encountered this crazy issue in production that when setting warmupPeriod the ratelimiter changed the rate from per second to millions if not billions per second Or simply see this issue by running following code as a test Test public void t RateLimiter rateLimiter RateLimitercreate TimeUnitSECONDS while true rateLimiteracquire SystemoutprintlnDone When setting warmupPeriod will trigger some downstream slope calculation with some value divide 