rust pub fn vertexbuilderOutputVertex OutputIndex Input Ctor buffers mut VertexBuffersOutputVertex OutputIndex ctor Ctor BuffersBuilderOutputVertex OutputIndex Ctor The type parameter Input is not used which makes vertexbuilder annoying to use as Rust cant infer its type as there is none so you have to call vertexbuilder like so rust vertexbuilder Changing this would be a breaking change so this would have to go into the next breaking release Im surprised Rust didnt emit a warning for this Maybe it did and it was overlooked When running the wgpusvg example on the contents of openclipartsvg DebianUbuntu package I see multiple occurrences of as well as other errors such as Error during tesselation InternalIncorrectActiveEdgeOrder Since these SVGs are realworld workloads and have already exposed multiple issues in Lyon it seems wise to use them as a robustness and regression test going forward If youre not on one of those distros the dataset can be downloaded here Right now if a path has custom attributes it is possible to iterator over path events with the attributes but the flattening iterator only provides the endpoint and control point positions I noticed a link in the wiki referring to skia path operations Is this a feature that is being considered for the library Im working on a creative coding environment which relies on lyon for much of the rendering pipeline and having boolean operations available would be an awesome addition I did some looking into what it would require to implement such a feature and I think it may be pretty doable especially if the first version just operates on flattened paths and paths which assume no intersections Doing union intersect and difference operations on these paths would be a matter of scanning down the intersection list and comparing winding values as described in this presentation After that initial feature is provided handling intersections and curves would be extensions on the initial version Im just spitballing here Does this make sense What am I missing Do you the maintainers have any hints for where I might look first to implement something like this Thanks in advance Is there an ability to constraint the tessellation threshold to strictly be positive or negative across the path That could be useful for producing tessellations that are either completely within the path or fully contain it The path splitter currently flattens the curves if any itd be great to handle b zier curves directly May or may not be a good idea but crates like pfmt and handlebars have some nice formatting features control over the output of floating point variables etc that could be useful to the commandline tool When several edges of a path overlap the sorting step that happens in the splitter has chances of ordering the two edges correctly This is mostly a problem for paths with several subpaths and edges of two different subpaths overlapping I am experimenting with some tweaks to the way monotone polygons are tessellated to avoid the thin vertical edges that are typically produced by the way monotone tessellators pingpong betwneen each side The main idea is that since the monotone tessellator knows which vertices are on which side it can accumulate vertices on each side as long as the sides are far away and produce a very nice tessellation for inward convex chains The remaining triangles between the two sides are then produced normally using the classical monotone tessellation algorithm As a followup it would be interesting to also refine outward concave chains of vertices but this requires inserting new vertices Im quite happy with how this is shaping up although there a re still a few bugs to iron out and I havent looked at the performance impact yet This is low priority since it only matters for paths with many selfintersections which is uncommon but it shouldnt be very hard to improve and would speed up the fuzzer FillTessellatorupdateintersections is super hot in profiles when there are many self intersections and completely absent from profiles when there are none It currently scans the entire vector of active edges to check that we didnt lose the left to right ordering of active edges due to imprecise intersections To check the ordering it intersects each edge against the horizontal line of the sweep line and the resulting x is used as the sort key Theres a i division in this computation that is particularly costly We can probably figure out a way to do the ordering test without intersection against the sweep line and hopefully avoid the expensive idiv instruction We dont necessarily need to scan the whole set of active edges only the ones adjacent to the edges that were split because of intersections