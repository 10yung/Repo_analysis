You state that the bulk versions of the add and insert are better but how does one deal with a way of inserting a lot of facts that may contain some that are already inserted Can the APIs be extended that do the equivalent of bool noFailIfDuplicatetrue c summaryInserts new facts to the rules engine memorysummary remarksBulk session operations are more performant than individual operations on a set of factsremarks param namefactsFacts to insertparam param namenoFailDo not throw exception if a fact is already in the Sessionparam void InsertAllIEnumerableobject facts bool noFailtrue A situation has arisen where I have a need to calculate a set of facts down to a certain level ie facts are missing thus preventing further rules from firing I then need to take a snapshot of the facts and create a new session add some new facts for new objects and run the new session again As the depth of the facts progress then the number of facts and rules that are being exercised increases thus if I have from the above a number of items requiring a common base at a level iteration number is just for demonstration and I need to run this level a times against additional facts this overhead of just setting up the level becomes onerous What would be be great is for a level session to be duplicated deep clone so that all previous conditions that have been set in the Rete tree etc are kept and thus do not need to be retested and only the new facts and hence the unused rules need to be tested and fired I am about to take on a new project where dynamic business rules are required I have stumbled onto NRules and it looks like a great library The current system is outdated uses custom parsing of plain text to generate c validation rules and it simply doesnt scale well and we want to streamline and modularize the application to be micro service based step functions and server less Putting the rest of the potential design aside I was curious if anyone has come up with a standardized way to load dynamic rules into the RuleBuilder I dont know much about RuleML but that seems to be a standard with some cross community support Has anyone successfully loaded a RulesRepository using JSON RuleML or some standard format One thing that makes our situation a little less dynamic is rules are done prior to the client application being live and it is also acceptable to recompile or reload the application when business validation rules change I envision storing a bunch of rules in a database as rows such as varchar columns and then parsing them in C into expressions in the load method of a RulesRepository is probably clunky and error prone Id love any insight to how people have done production scenarios where rules can be dynamic call functions via Do and how they designed this process Thanks in advance snikolayev Ive found a closed issue labeled wontfix Ive tried to implement the FireAsync as you described and it was quite straightforward BTW I havent replaced Fire with FireAsync but implemented it in parallel So the question is why did you close this issue Were there any hidden issues which I havent faced yet or it was just a decision to put it aside for a while Currently were investigating your project and potentially can collaborate Reduce the number and extent of allocations during fact propagation Also improve performance of Rete graph particularly when joining facts Hello Im a programming freshman Can someone tell me more about how to get the debug visualizer to work Which file exactly do I have to build Unfortunately I only get error messages when I execute the debug visualizer executable file Thank you I m trying to create a ForAll rule using the RuleBuilder API where additional facts are joined onto the fact type used in the ForAll rule This can be achieved with AnyNone rules by using the GroupBuilder but the patterns collection on ForAll does not work in the same way See below using NRulesIntegrationTestsTestAssets using NRulesRuleModel using NRulesRuleModelBuilders using System using SystemLinqExpressions using Xunit namespace NRulesIntegrationTests public class ThreeFactForAllRuleBuilderTest BaseRuleTestFixture Fact public void ThreeFacts Arrange var builder new RuleBuilder builderNameTest Rule var lhs builderLeftHandSide var patternBuilder lhsPatterntypeofFactType fact ExpressionFuncFactType FactType bool fact Join fact fact fact JoinProperty fact TestProperty Adding this makes it work as a workaround but exports a FactType pattern lhsPatterntypeofFactType f var patternBuilder Base new PatternBuildertypeofFactType fact patternBuilder BaseConditionfact Join var patternBuilder Actual new PatternBuildertypeofFactType f Use f to avoid collision of names Fluent also uses different names for BasePattern and Pattern ExpressionFuncFactType bool condition f f TestPropertyStartsWithValid patternBuilder ActualConditioncondition var patternBuilder new PatternBuildertypeofFactType fact ExpressionFuncFactType FactType bool fact Join f fact fact JoinProperty f TestProperty patternBuilder Conditionfact Join var allBuilder lhsForAll allBuilderBasePatternpatternBuilder Base allBuilderPatternpatternBuilder Actual allBuilderPatternpatternBuilder Commenting out this line the test passes ExpressionActionIContext FactType action context fact NoOp builderRightHandSideActionaction Act var rule builderBuild Fact public void ThreeFactsWorksForExists Arrange var builder new RuleBuilder builderNameTest Rule var lhs builderLeftHandSide var patternBuilder lhsPatterntypeofFactType fact var patternBuilder new PatternBuildertypeofFactType fact ExpressionFuncFactType FactType bool fact Join fact fact fact JoinProperty fact TestProperty ExpressionFuncFactType bool condition fact fact TestPropertyStartsWithValid patternBuilder Conditionfact Join patternBuilder Conditioncondition var patternBuilder new PatternBuildertypeofFactType fact ExpressionFuncFactType FactType bool fact Join fact fact fact JoinProperty fact TestProperty patternBuilder Conditionfact Join var groupBuilder new GroupBuilder groupBuilderPatternpatternBuilder groupBuilderPatternpatternBuilder var existsBuilder lhsExists existsBuilderGroupgroupBuilder ExpressionActionIContext FactType action context fact NoOp builderRightHandSideActionaction Act var rule builderBuild public static void NoOp protected override void SetUpRules public class FactType public string TestProperty get set public class FactType public string TestProperty get set public string JoinProperty get set public class FactType public string TestProperty get set public string JoinProperty get set From investigation it appears that the ForAll patterns cannot import parameters from each other and require their dependent patterns to be added to the left hand side of the rule rather than just the ForAllBuilder I m not sure if this is a bug feature request or support issue Am I using the ForAllPattern incorrectly and is there any reason AnyNone take a group but ForAll cant Trying to load the visualizer with Visual Studio Community version Cloned the repository at which appears to be as of this writing Using NRules version in my application Im following the instructions on this page Started up Visual Studio Started up my application Hit a breakpoint after all the facts have been loaded and a magnifying glass shows up over my ISession variable I click on it and get Unable to cast object of type NRulesDebuggerVisualizerSessionVisualizer to type MicrosoftVisualStudioDebuggerVisualizersDialogDebuggerVisualizer Were using NRules in an interactive realtime application that needs to compile the rule factory on application start Were starting to notice that our rule factory compilation is taking a long time seconds and growing so far on my PC and about seconds on the low power device well eventually be supporting Specifically this time is spent in RuleRepositoryExtensionsCompile method Doing some initial profiling the bulk of the time spent seems to be in RuleElementVisitor Visit Drilling into this a bit at first glance I see the bulk of the time spent in ExpressionComparer and LambdaCompiler methods A few screenshots of profiling are attached in case this is helpful img width altScreen Shot at PM src img width altScreen Shot at PM src img width altScreen Shot at PM src img width altScreen Shot at PM src Create an aggregator that supports the following csharp ILookupTKey TValue l IEnumerableTValue e When Query l q q MatchTKey ToLookupt tKey has optional value selector override just like ToLookup in LINQ Let e l someKey This fits well with how programmers will expect ILookup to perform in LINQ Currently this can be implemented as csharp When Query l q q MatchTKey Collect Selectc cToLookupt tKey which is less performant because the Select is not reactively updated and instead created newly each time I intend to implement this so that ToLookup produces ILookupQueryTKey TValue similar to the IOrderedQuery mentioned in issue 