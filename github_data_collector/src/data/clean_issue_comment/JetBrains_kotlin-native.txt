The previous way of handling return expressions is incorrect and gives unexpected coverage results on samples with return inside a nested loop Regions should not intersect with each other correct mapping can contain only nested regions Since changing offsets of an already recorded region can cause intersection Regionoffset mutability is redundant Return expression cuts not only enclosing function but also all of the enclosing statements Corresponding common part review I encountered a new type of exception after update to KotlinNative Usersteamcity buildAgentwork d a c runtimesrcmaincppMemorycpp runtime assert Must be newly frozen Crash appears in the following code Kotlin package ruzenmoneymobileplatform import platformFoundation import kotlinnativeconcurrent import kotlinxserializationSerializable Serializablewith DateSerializerclass actual class Date ComparableDate val date NSDate constructordate NSDate thisdate date freeze HERE exception is thrown Could you explain please is it forbidden to call freeze inside object constructor for some reason or it is a bug of compiler This may just be an incomplete understand on my part so Id appreciate any clarification you can offer Im returning pinned objects from Kotlin to C so had assumed that readonly multithreaded access was allowed However I noticed some crashes when attempting to dispose pointers on different threads than they were created on knlibrarykt package knlibrary import kotlinnativeconcurrentfreeze data class Foo val thing String fun getFoothing String Foo return Foothingfreeze testcpp include thread include knlibraryapih int main knlibraryExportedSymbols lib knlibrarysymbols auto knlibrary libkotlinrootknlibrary auto foo knlibrarygetFooTest auto t stdthread Uncomment to prevent crash printfThing s n knlibraryFoogetthingfoo libDisposeStablePointerfoopinned tjoin return runcmd echo off call kotlincnative g knlibrarykt produce dynamic o knlibrarydll libexe defknlibrarydef outknlibrarylib machinex clexe testcpp knlibrarylib testexe This assumes you have the bit clexe on your path eg using the VS x Native Tools Command Prompt as well as the Kotlin and Java bin directories If you run as is it crashes inside DisposeStablePointer evidently because an address looked up from TLS was null Surprisingly uncommenting the printf line both successfully prints the value and also prevents the crash from occurring After observing this behavior I noticed this line from Note KotlinNative object references do not support multithreaded access Hosting the returned libnativeExportedSymbols pointer per thread might be necessary Does this mean that no access to a Kotlin reference from different threads in C is allowed whatsoever and that the above example is invalid Or is the limitation more narrow I did also try calling knlibrarysymbols on the background thread to get a new pointer in case it had to initialize some threadlocal state but it had the same effect Id appreciate your help in better understanding this case Thanks The crash appears when you define a constant after a static method and use that constant inside the method This should be either caught by the compiler or just work as is right now it crashes at runtime and the error doesnt explain exactly what is going on so its hard to figure it out This is the reproducer kotlin class SomeClass fun authenticate val url AUTHENTICATEURL companion object private val AUTHENTICATEURL private fun getAuthorizeUrl String return private const val PARAM paramvalue I think working on WebAssembly support in KotlinNative is so poor Webassembly will be the first class technology for web developement in the feature and Kotlin despite of is the perfect language for the WebAssemblyit seems it drop behind c blazor or even python pyodide My call for Kotlin as a major frontend language 