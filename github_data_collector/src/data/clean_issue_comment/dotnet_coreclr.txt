The idea is to add attributes to SystemDiagnosticsCodeAnalysis namespace These attribute would be AttributeUsageAttributeTargetsParameter Inherited false sealed class NotNullAfterAttribute Attribute This Attribute would behave in a way similar to NotNullWhenAttribute but would guaranty that the parameter isnt null if the function returns This would be used to handle cases like the following private void ValidateParams NotNullAfter object param if param null throw new Exception Another set of attributes would be similar to NotNullWhenAttribute and NotNullAfterAttribute but would work on members of the class instead of function parameters AttributeUsageAttributeTargetsMethod AllowMultiple true Inherited false sealed class MemberNotNullWhenAttribute Attribute public MemberNotNullWhenAttributestring memberName bool returnValue MemberName memberName ReturnValue returnValue public string MemberName get public bool ReturnValue get AttributeUsageAttributeTargetsMethod AllowMultiple true Inherited false sealed class MemberNotNullAfterAttribute Attribute public MemberNotNullAfterAttributestring memberName MemberName memberName public string MemberName get The reason for such attributes would be to handle very common code like the following pseudocode MemberNotNullAfterfield MemberNotNullAfterfield MemberNotNullAfterProperty private void ValidateState if field null throw new NotInitializedEception if field null throw new ObjectDisposedException if Property null Property new object MemberNotNullWhenfield true MemberNotNullWhenfield true MemberNotNullWhenProperty true private void IsValid if field null return false if field null return false if Property null return false return true With the above the compiler would know in code like void Method ValidateState field DoSomething field DoSomethingElse PropertyDoAgain void Method if IsValid field DoSomething field DoSomethingElse PropertyDoAgain Even if field field and Property may be null as per their definition not to give any warning Another use for this is if there is a method Initialize which initializes all fields such a method could be called from constructors to initialize Non Null references In this case also the compiler shouldnt give any warnings E Downloads coreclr buildcmd BUILD Starting Build at BUILD Searching for Visual Studio or later installation BUILD C Program Files x Microsoft Visual Studio Enterprise Common Tools VsDevCmdbat Visual Studio Developer Command Prompt v Copyright c Microsoft Corporation BUILD Commencing CoreCLR product build BUILD Checking prerequisites BUILD Number of processor cores Exception of type SystemTimeoutException was thrown The SSL connection could not be established see inner exception Unable to read data from the transport connection E Downloads coreclr eng emptycsproj min E Downloads coreclr packages microsoftbuildtasksgit beta build MicrosoftBuildTasksGittargets error E Downloads coreclr eng E Downloads coreclr eng emptycsproj E Downloads coreclr packages microsoftdotnetarcadesdk beta tools Versiontargets error SourceRevisionId is not set which means the SourceLink targets are not included in the build Those are needed to produce a correct sha for our build outputs E Downloads coreclr eng emptycsproj E Downloads coreclr packages microsoftbuildtasksgit beta build MicrosoftBuildTasksGittargets error E Downloads coreclr eng E Downloads coreclr eng emptycsproj E Downloads coreclr packages microsoftdotnetarcadesdk beta tools Versiontargets error SourceRevisionId is not set which means the SourceLink targets are not included in the build Those are needed to produce a correct sha for our build outputs E Downloads coreclr eng emptycsproj Build failed BUILD Error Failed to generate version headers This is the fix for This is a GC hole bug that was found externally The cause is that the JIT was using the target type of the subtract when it needed to make a copy of the source but it needs to use the source type Customer Impact Corruption of state that is nondeterministic and hard to track down Regression Not a recent regression but exposed by UnsafeByteOffset Testing The fix has been verified in the runtime repo Risk Low The fix is straightfoward and only impacts lines of code Code Reviewer jaschook and jkotas Port of dotnetruntime to branch Applications may crash in GC code due to GC heap corruption caused by incorrect padding size calculation on ARM Customer Impact Unexpected and hard to diagnose crashes Regression No Testing The fix has been verified in the runtime repo Risk Low oneline fix of the incorrect calculation Port of dotnetruntime to branch This is the fix for The manifestation is an AV in the JIT Although it isnt SBCG it is difficult for the developer to track down that this is a JIT bug rather than caused by something in their code Customer Impact Unexpected and hard to diagnose crashes Regression No Testing The fix has been verified in the runtime repo Risk Low The fix is straightforward and only prevents the AV case Code Reviewers Authored by saucecontrol reviewed by CarolEidt and swaroopsridhar Port of dotnetruntime to branch This is the fix for dotnetruntime This is a SBCG bug reported externally When a struct is partially written the JIT fails to invalidate assertions in this case that the entire struct had been zerod This results in incorrect optimization The fix is to invalidate the assertions in the partial write case Customer Impact SBCG resulting in incorrect behavior Regression Not a recent regression but exposed by doing more optimizations on structs Testing The fix has been verified in the runtime repo Risk Low The fix is straightforward and kills assertions which only disables optimizations Code Reviewer briansull and BruceForstall SystemThreadingTimer Not Running On Ubuntu server General Created a worker service project used a background service to create a timer function that followed When executing running locally on windows timer events trigger as expected Deployed to ubuntu server timer events are never triggered Verified that the app is running and no issues instantiating the timer it just never actually triggers the timer I was surprised its not handled in morph eg a b b a csharp int M int a int b a b optimize to b a int M int a int b a b optimize to a b int M int a int b a b optimize to a b int M int a int b a b optimize to b a Current codegen asm Method CCM intintintthis GM IG mov eax edx neg eax add eax r d Method CCM intintintthis GM IG mov eax r d neg eax add eax edx Method CCM intintintthis GM IG mov eax r d neg eax sub edx eax mov eax edx Method CCM intintintthis GM IG mov eax edx neg eax mov edx r d neg edx sub eax edx Expected codegen Also csharp int M int a a optimize to a int M int a a optimize to a int M int a a optimize to a int M int a a optimize to a categorycq themebasiccq skilllevelbeginner costsmall I can create a program like this cs using System class App static void Main int a ConsoleWriteLinea but it doesnt give expected output SystemInt I checked online and people suggest to loop through the array Is that really necessary Many other languages dont require that like Go go package main import fmt func main a int fmtPrintlna Nim nim var a echo a D d import stdstdio void main auto a a writeln JavaScript js let a consoleloga Python py a printa I have a NET Core app thats a fairly basic gRPC service unfortunately not open source yet so I cant link to the source at the moment On one particular server its throwing a segmentation fault as soon as I run it ASPNETCOREENVIRONMENTProduction ASPNETCOREURLS TestApp info MicrosoftHostingLifetime Now listening on info MicrosoftHostingLifetime Application started Press CtrlC to shut down info MicrosoftHostingLifetime Hosting environment Production info MicrosoftHostingLifetime Content root path optexampleappworker Segmentation fault In fact Im seeing this for a very basic ASPNET website too just one custom middleware using appRun Backtrace from lldb SOS thread name TestApp stop reason signal SIGSEGV invalid address fault address x frame x ffff b d libcoreclrsoThreadpoolMgrGetRecycledMemoryThreadpoolMgrMemType inlined ThreadpoolMgrRecycledListInfoRemove at win threadpoolh frame x ffff aa libcoreclrsoThreadpoolMgrGetRecycledMemorymemTypeunavailable at win threadpoolcpp frame x ffff e libcoreclrsoUnManagedPerAppDomainTPCountQueueUnmanagedWorkRequestunsigned int void void inlined ThreadpoolMgrMakeWorkRequestunsigned int void void at win threadpoolh frame x ffff e a libcoreclrsoUnManagedPerAppDomainTPCountQueueUnmanagedWorkRequestthis x ffff dd functionlibcoreclrsoThreadpoolMgrAsyncTimerCallbackCompletionvoid at win threadpoolcpp context x void void at threadpoolrequestcpp frame x ffff d libcoreclrsoThreadpoolMgrFireTimers at win threadpoolcpp frame x ffff d libcoreclrsoThreadpoolMgrFireTimers at win threadpoolcpp frame x ffff cd libcoreclrsoThreadpoolMgrTimerThreadFire at win threadpoolcpp frame x ffff cc libcoreclrsoThreadpoolMgrTimerThreadStartpunavailable at win threadpoolcpp frame x ffff c d libcoreclrsoCorUnixCPalThreadThreadEntrypvParam x at threadcpp frame x ffff fb fa libpthreadso startthreadargunavailable at pthreadcreatec frame x ffff bbc cf libcso GIclone at cloneS Debian stable buster apt list installed grep dotnet WARNING apt does not have a stable CLI interface Use with caution in scripts dotnethostbusternow amd installedautomatic dotnethostfxr busternow amd installedautomatic dotnetruntime busternow amd installed dotnetruntimedeps busternow amd installedautomatic 