 Description renderdoccmd crashes on Linuxbased systems when performing simple commands like thumb or extract The problem lies with the fact that all the commands Execute method calls RENDERDOCInitGlobalEnv which starts a new thread which call into graphics driver to enumerate devices and whatnot The main thread may process and quit quickly since extracting a thumbnail or section of rdc file could be relatively fast operation compared to all the work that the thread started from RenderDocProcessGlobalEnvironment is doing When the main thread finishes before the secondary one C runtime starts executing global destructors Some GPU drivers might have global C objects as well and while main thread call global destructors the secondary thread might still be running and still use those globals leading to segfaults Technically we should probably wait for that thread to terminate before exiting renderdoccmd So calling RenderDocSyncAvailableGPUThread before exit would solve the problem but it is not available through public API at the moment Steps to reproduce execute the following command reproduced on Stadia platform renderdoccmd extract sectionrenderdocinternalexthumb fileexthumbbin framerdc Environment RenderDoc version commit ff b f fa ae cb ebd a fe de ea a Operating System Stadia Graphics API Vulkan Hi I have implemented the unit test for the backdoor context I noticed that with my setup of NVidia Quadro P running on Win that wglMakeCurrent would randomly fail After a little bit of trial and error I stumbled upon a solution please let me know if the solution is a good idea or not This implements the backdoor context so that resources created by noncurrent contexts can be retrieved and serialised Description When debugging data layout of cbuffers it could be handy to see the offsets the shader expects for certain cbuffer elements You can view the buffers contents but this is the data that is uploaded by the cpu and can mismatch what the gpu expects I tried finding this feature but I couldnt find it in RenderDoc v Steps to reproduce Open up a cbuffer it would be nice to see a column besides Name Value Type that said Offset Since this is already present in RenderDoc it should be doable to display that since it looks up the memory at that offset in the buffer Environment RenderDoc version v built from Operating System Win Graphics API D D Description This PR merges the ImageLayouts and ImgRefs and additionally Adds support for the VKKHRseparatedepthstencillayouts extension Adds correct imagesubresource queue family tracking Most of these changes are currently behind an offby default compile time flag RDOCNEWIMAGESTATE I intend to do more testing and I would like to add some more explanation for some of the changes here but tests are passing unit tests python tests and manual tests on games and I dont expect to need any more big changes to this code I wanted to get the PR rolling so that it can hopefully make it in time for the next release Description With D D D D the texture viewer overlays referencing a pass span all draws with the same set of render targets Often it is unclear where the beginning of this pass actually is Having a visual andor text indicator to inform where the pass begins would help This could be information in the status bar of the texture viewer or highlighting rows in the event browser that correlate to the draws occurring after the clear Environment RenderDoc version latest from source currently ce bd ea c d b fcee bfeb Operating System Windows API D D D D Description It would be great if I could configure breakpoints in the shader debugger to not break but only increase their hit count I guess with that would come a little debugger UI revamp ie add a little additional breakpoint panel which lists all breakpoints lets me enable and disable them and show me the current hit count I prototyped a hack that replaces textures with checkerboard pattern for DirectX A lot of people showed interest in this and I decided its worth making a feature request The way it works in my hack is by supporting a set of replaced ResourceIds and a cache for ResourceIdSRV and then checking for that mapping in places like this for VS CS and PS The result is that the replacement texture now appears on all render targets and on the thumbnails It doesnt alter the UAVs and RTVs just SRV replacement I dont have enough experience with the sources so I dont know what is the best architecture for such a feature But I do have an approximate list of UI knobs Select the checkerboard parameters st value nd value step in pixels Not sure how to set up values for different types In my example I restricted to bit per pixel Select the checkerboard format ie R FLOAT R G B A UNORM etc A button to remove all replacements A button to update all replacements with new parameters A context menu item for the selected texture A more advanced approach would be to dispatch a compute shader and bind the copied texture as a UAV in that way the user can choose its own pattern or even replace only part of the texture without being restricted to the checkerboard This is similar to the custom visualization shaders with an extra step of replacement Thanks Examplethe captured frame is unrelevant Feature Request Background A lot of times I find myself trying to figure out why something is not rendering when it should or rendering when some other unrelated state is active In order to investigate the issue I take multiple captures and have to manually compare their event browser draw calls andor renderer state This takes time because of the loading and unloading of captures and when there are many events in the browser Feature It would be nice to have a feature that could at the very least compare two captures events or draw calls and list what is different between them Description NOTE Metal or iOS support is not planned at the moment and I cant say anything about when I might look at it Please keep discussion here to GL Vulkan issues as thats the scope for an initial shipping version As found in the survey I ran at the end of there is a noticeable segment of users who strongly want macOS support Ive looked into what would be involved and done some initial work but I have no familiarity with macOS so input and assistance from domain experts would be very helpful here This issue tracks any known problems or missing features on macOS with an aim to stabilising it enough to ship in an official build As of c ffa fdcaacb a ad c the build should be considered early alpha It works well enough for the basics on Vulkan GL etc but certainly requires a lot more work before it ships I currently have no planned timeline for when mac support would ship and it remains medium priority so these things will get fixed aswhen I have time Any help with any of the below particularly the very mac specific issues like sorting out building and packaging would be greatly appreciated The build needs significantly more testing and bugfixing At the moment Ive really only tried it on a handful of demo programs so more realworld testing is desperately needed If you have any nontrivial projects please share them so I can use them for testing This also just means testing the build for any weird UI bugs or strange behaviour on mac Eg I seem to sometimes get sticky context menus where right clicking will pop one up but then left clicking will continue to pop it up This might be a holdover of mac not really having right clicking as a very native concept On GL we always create a core context whenever we need one In theory we should work OK on as well is it necessary to detect what versions are available and downscale or are devicesOSs not relevant anymore Key input in the injected application for triggering captures is not supported yet so the only way to trigger captures is via the UI Im not sure what libraryinput method is best for minimallyintrusive keyboard input in windows created by the application that I dont control HighDPI screens arent handled properly in at least the GL overlay we need to detect the DPI scaling factor and multiply up the detected window bounds and the size of the rendering HighDPI screens may also have issues with sizing widgets in the UI and with rendering displays on at least GL and maybe Vulkan When launching app folders we need to parse the Infoplist to determine the executable to launch A couple of key functions in GL rely on compute shaders which thus arent implemented on macOS Namely minmax texture range histogram and mesh picking The simplest workaround is just to emulate on the CPU and take the performance hit on that but its possible the minmaxhistogram shaders could still run on the GPU with pixel shaders doing a smaller downsample pyramid Performance in the UI seems very slow for some reason I dont know if its because of my hardware though renderdoccmd has some stubs that need to find a way to create a window on apple to display previews Is there a minimum macOS version that should be tested against what about minimum hardware support Currently I only have one apple device a mid macbook air running This is probably close to the minimum end on hardware Id guess but its the latest OS Some dialog boxes in the Qt UI have a large question mark I dont know if thats normal for the OS or if thats a missing resourcesetup on my side to provide RenderDocs icon Currently the Xcode generator in cmake doesnt produce a working build It seems to run into issues with the GLvulkan driver projects and doesnt build them correctly If there is a simpleminimal impact fix to get this working then that would be great but since it compiles fine on the command line this isnt critical Some modern mac programs are likely to require OpenCL interop for compute which would need at least minimal hooking to serialise data at sync points similar to the DX interop x There seems to be an issue with MVK not getting initial contents of PREINITIALIZED linear images which repros with vkcube The memory has the right contents but the image isnt handling properly x Related to the above there are GL warnings that fire when opening a capture that indicate degraded hardware support We should hardcode these to never fire on mac as the support is software related not hardware and will never appear later so theres no point annoying users about it x macOS GL contexts are assumed to be core contexts but its valid and the default to create a legacy context We should be able to detect this from the attributes in a pixel format on creation x Theres no package build process for macOS At the moment the cmake build produces a qrenderdocapp but it also needs to package the vulkan loader and a MoltenVK build as backup and also include android apps I dont know if anything else is expected to be packaged in a macOS binary thats packaged up and I dont know how such a package is typically distributed or constructed Is there an equivalent of an msi installer on macOS x At the moment I dont have any nightly builds set up for macOS and it seems like doing this one way or another would require apple hardware running constantly Possibly the travis builds could be repurposed to store their output on S for macOS which can then be downloaded each night and have the packaging script run from linux instead To build the mac build consult the information in CONTRIBUTINGmd in particular the dependencies To build it is the same cmake build steps as on linux running mkdir build cd build cmake DCMAKEBUILDTYPEDebug make j GL capture should mostly work as expected out of the box Of course bugs are likely and expected Vulkan capture will require a bit more setup If you have vulkan registered with the system properly it should work the same as on other platforms this means libvulkan dylib should be in the dylib search path somewhere I put it in lib Also the driver should be registered in localsharevulkanicdd You can also use VKICDFILENAMES but be sure its set when running qrenderdoc The vulkan layer will be registered as on other platforms when running a loose build which writes its json into localsharevulkanimplicitlayerd On recent mac vulkan SDKs the default install location from the installvulkanpy script should be detected by similarly recent RenderDoc builds Environment RenderDoc build Latest HEAD code Operating System macOS minimum spec to be determined API Vulkan and OpenGL only