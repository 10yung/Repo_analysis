Panics seem to get printed decently by the interpreted runtime but not the JIT runtime To reproduce cherrypick ca a e ecb f cb b fcceb dd b and then console cargo build release target wasm unknownunknown manifestpath demoimplCargotoml cargo run manifestpath democallerCargotoml error procmacro derive panicked democallersrcmainrs deriveDemo help message panicked at oh no srclibrs cargo build release target wasm unknownunknown manifestpath demoimplCargotoml WATTJITgitwasmtimetargetreleaselibwasmtimeapiso cargo run manifestpath democallerCargotoml fatal runtime error failed to initiate panic error error could not compile wattdemocaller In the nonJIT runtime lets time how long each macro call takes and print a message if any one takes too long pointing to the JIT installation instructions and explaining that it would likely improve your compile time Well want the warning to somehow appear only once per compilation if possible Also well want some way to silence it in case the user cant install JIT for some reason Right now theres rudimentary support for executing code in a JIT loaded through a dynamic library which exposes a wasm C API Unfortunately though theres not really a great way to download this runtime for your platform or configure this Itd be good to have a run this command style thing to accelerate macro invocations locally Hello Maybe this is just a paranoia on my side However currently if I want to do an audit of my dependencies I can download and extract the crate source downloaded from cratesio and read it There are even tools promoting such approach like cargocrev But if the crate contains the binary wasm code reading it and understanding what it does gets much harder I understand that the compiled code cant do arbitrary stuff to the system itself but it could still produce malicious code into its output or simply be buggy and produce wrong code So I wonder would it be possible to somehow make it possible by some tooling to automatically bundle both the original source code and the wasm and have a way to opt into the longer compile time but making sure it is indeed from the given sources More than half of the uncompressed wasm file of waserdederive is made up of the debug info section It seems that panic information is still compiled into the wasm file The crate file can be downloaded from this link It contains the wasm file MB uncompressed If you run strings on the wasm file you see some paths included This is caused by panic information still being compiled in Mostly for proc macros such info is irrelevant With a custom panic handler the linker should be able to optimize it out Although Im not sure it might even be wanted This project is brilliant Ive wanted some way to precompile build tools like this for a while Ive got a fairly hefty feature request though Currently Watt is designed to completely sandbox the input However Ive worked on several nonprocmacro build tools that need to access the filesystem eg to locate nonRust input files These projects would still be amenable to precompilation the output binaries dont need to link with them Unfortunately Watt currently cant address this use case since it can only read and write TokenStreams It would be neat if there was a way to invoke Watt from a buildrs file and allow it to access more of the external environment One route to implement this would be through WASI WASI is a wasm syscall ABI a set of functions implemented in the wasm runtime which access the external system Its defined here All that would be needed to support this would be to implement these functions and link them into the Watt runtime Rust code can then be compiled with the wasm wasi target and standard library operations will then be routed through these syscalls in the compiled wasm module So build tools could be written using standard Rust APIs and transparently run through Watt You could still retain some sandboxing since WASI is designed to be explicitly initialized with a set of capabilities for example you could explicitly pass in the paths the build tool is allowed to access in your buildrs file You could also allow using WASI syscalls in the procmacro runtime Im not sure if nondeterministic procmacros are permitted by Rust though Downsides of this approach it would add some compile time to the runtime and it adds some complexity From some rough tests Watt macro expansion when compiling the runtime in release mode is about x faster than when the runtime is compiled in debug mode Maybe we can set it up such that users can run something like cargo install wattruntime and then our debugmode runtime can detect whether that optimized runtime is installed if it is then handing off the program to it Well want to take some representative proc macros to compile to wasm and set up a benchmark that times how long it takes to expand some representative inputs This would be a necessary first step toward beginning to optimize the Watt runtime