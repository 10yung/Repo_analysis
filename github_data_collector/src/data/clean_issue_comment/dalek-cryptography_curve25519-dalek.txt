Hi Ive implemented more table sizes for fixedbase scalar multiplication The motivation here is primarily to allow for memorytime optimisations for signature verifications cf and where a user who needs to verify many signatures with the same public key can dynamically chose to recompute largersmaller tables but its also likely useful for systems which use ChaumPedersen commitments or Okamoto commitments or any other NIZK proofsigma protocol which uses two basepoints Ive benchmarked this see my separate featuredynamictablessizesbenches branch and the results so far on a few different chipsets seem to indicate speedups as long as the table fits in the L D subcache Ive implemented tables up to the limit as selfimposed by Scalartoradix w of radix which are KB tables as commonly used server builds these days such as the Xeon E v s found on AWS and those internal to other large companies often have KB L ID caches This is currently implemented via a new BasepointTable trait which makes them not semver compatible with however I can remove the trait for now and add it back in when were ready for a if thats preferable Id like to be able to start using this now or at least I want it before releasing ed dalek so if we want the trait removed Id like to instead add a marker trait for the different sizes of tables so that the ed dalek code can generalise over them as public keys Another implementation note I opted for implementing these via macros as it required the least amount of changes to existing code Also naming question Should we consider renaming EdwardsBasepointTable to something more generic like EdwardsPrecomputedPointTable etc Please review Now that weve had a series for a while and are about to cut a it might be nice to have tests for the public API to ensure that breaking changes are caught automatically As we continue to add backends it would be handy to have a more modular way to choose which backend is being used and to use a custom backend eg for developers working on hardware that hasnt been publicly released yet which we might not want to or be able to maintain within our crate Would it be feasible to create some sort of backend trait which describes what methods we expect out of the field arithmetic And on that note would it be possible to also separate out the scalar arithmetic so that someone could develop a chipspecific field implementation but reuse the bit serial scalars Im imagining providing a trait thats something like rust featuretraitalias use coreopsAdd AddAssign Sub SubAssign pub trait FieldArithmetic Sized Add AddAssign Sub SubAssign pub trait FieldElement fn zero Self fn one Self fn fromu x u Self pub trait FieldBackend FieldArithmetic FieldElement pub trait ScalarArithmetic Sized Add AddAssign Sub SubAssign pub trait ModularScalar fn zero Self fn one Self fn fromu x u Self pub trait ScalarBackend ScalarArithmetic ModularScalar pub trait Backend FieldBackend ScalarBackend Unfortunately that requires the experimental trait aliases feature Im not sure if theres a better way to do it Thoughts Opinions We should probably enable when available to avoid things like our std feature tramplinggetting trampled by anything using curve dalek with a dependency on an alternative versionimplementation of std let cachedidentity CachedPointfromExtendedPointidentity printlncached identity cachedidentity cached identity CachedPointFieldElement x u x u x u x u x u x The print info above is different from CACHEDPOINTIDENTITY value in srcbackendvectoravx constantsrs The identity element as a CachedPoint pubcrate static CACHEDPOINTIDENTITY CachedPoint CachedPointFieldElement x u x new u x new u x new u x new u x new Moving here from I was trying to test out the avx ifma backend but getting the following error Building with RUSTFLAGSC targetfeatureavx ifma cargo nightly bench nodefaultfeatures featuresstdsimdbackend LLVM ERROR Cannot select x f b v i X ISDVPMADD L x f b b a x f b f x f b c x f b b a v i X ISDVSRLI x f b Constanti x f b v i ch loaddereferenceable load from ir x f b x f b b undefi x f b b i add nuw x f b Constanti x f b i ch CopyFromReg x f b e Registeri x f b i Register x f b i Constant x f b d i undef x f b i Constant x f b f v i X ISDVBROADCAST x f b bc a x f b bc a i ch loadload from constantpool x f b e x f b d undefi x f b d i X ISDWrapperRIP TargetConstantPooli i x f b d i TargetConstantPooli x f b d i undef x f b c v i and x f b x f b b b x f b v i ch loaddereferenceable load from ir x f b x f b undefi x f b i ch CopyFromReg x f b e Registeri x f b i Register x f b d i undef x f b b b v i X ISDVBROADCAST x f b af x f b af i ch loadload from constantpool x f b e x f b c undefi x f b c i X ISDWrapperRIP TargetConstantPooli i x f b b i TargetConstantPooli x f b d i undef In function ZN LTTu asu coreconvertIntoLTUGTGT into hb a d abfd e a E error Could not compile curve dalek warning build failed waiting for other jobs to finish LLVM ERROR Cannot select x fd bae d v i X ISDVPMADD L x fd x fd baea x fd bae x fd v i X ISDVSRLI x fd bc Constanti x fd bc v i ch loaddereferenceable load from ir x fd a x fd bae a undefi x fd bae a i add nuw x fd Constanti x fd i ch CopyFromReg x fd c fd Registeri x fd d i Register x fd a ac i Constant x fd bae i undef x fd bae i Constant x fd baea v i X ISDVBROADCAST x fd ce x fd ce i ch loadload from constantpool x fd c fd x fd a ac undefi x fd a ac i X ISDWrapperRIP TargetConstantPooli i x fd dd i TargetConstantPooli x fd bae i undef x fd bae v i and x fd x fd a a x fd v i ch loaddereferenceable load from ir x fd a x fd undefi x fd i ch CopyFromReg x fd c fd Registeri x fd d i Register x fd bae i undef x fd a a v i X ISDVBROADCAST x fd a a x fd a a i ch loadload from constantpool x fd c fd x fd a a e undefi x fd a a e i X ISDWrapperRIP TargetConstantPooli i x fd bae i TargetConstantPooli x fd bae i undef In function ZN LTTu asu coreconvertIntoLTUGTGT into h aaee c E error Could not compile curve dalek Rust version rustc nightly d f b binary rustc commithash d f b bc c fa d adb ed c c e commitdate host x unknownlinuxgnu release nightly LLVM version Any ideas if this is an error on the rust compiler or the linking code being used in the backend There is a line of research implementing Curve in constant time on CortexM microcontrollers by using multiplyandaccumulate instructions that this microcontroller has To my knowledge this starts in with an implementation which unfortunately has LG copyrights The latest I know of is based on and has no copyright restrictions While blocks this would there be interest in adding support for such a backend Should this happen in this repository 