 choose all that apply Type of issue bug report if the issue is NOT a question fill out the following sections choose one Impact new rtl choose one Development Phase request Other information include detailed explanation stacktraces related issues suggestions how to fix links for us to have context Pipeview is currently broken in boom at least in commit commit a ea e acfd eed e e e be When the trace is generated all of the fetches have a zero for a sequence number which produces a pipeview that only shows the fetches This was happening because the sequence number is trying to be read from the f fetchbundle but the sequence number is not being assigned until the Fetch Buffer I fixed this by instead assigning the sequence number to the f fetchbundle at least it looks fixed to me when I try to generate the pipeview Someone more experienced with BOOM may want to look at it though The change is as follows diff git asrcmainscalaifufetchcontrolunitscala bsrcmainscalaifufetchcontrolunitscala index c f asrcmainscalaifufetchcontrolunitscala bsrcmainscalaifufetchcontrolunitscala class FetchControlUnitimplicit p Parameters extends BoomModule when f fire for i until fetchWidth if i f fetchbundledebugeventsifetchseq fseqreg else f fetchbundledebugeventsifetchseq fseqreg PopCountf fetchbundlemaskasUInti rf req f req rf fetchpc f imemresppc rf taken f taken class FetchControlUnitimplicit p Parameters extends BoomModule fbiostatus iostatus fbiobp iobp for i until fetchWidth if i fbioenqbitsdebugeventsifetchseq fseqreg else fbioenqbitsdebugeventsifetchseq fseqreg PopCountf fetchbundlemaskasUInti FetchTargetQueue Not a functional bug We just want to match the behavior of ISA simulators choose all that apply Type of issue feature request if the issue is NOT a question fill out the following sections choose one Impact no rtl change choose one Development Phase request Other information As stated by jerryz in Confirm how far BOOM gets into Linux simulation without a block device Consider changing Dromajo to have tofromhost addresses be MMIO addresses x Consider changing Dromajo to simulate interactions with the block device The key is that we dont need to simulate the entire device we only need to simulate the sequence of stores the block device writes into RAM Modify DromajoCosimBlackBox so that it can be used as a Firesim bridge Currently the COMMITLOGPRINTF MEMTRACEPRINTF and the DEBUGPRINTF are executed as chisel prints which are emitted to stderr However you can only have one of these at a time since they all go to stderr We should create C DPI widgets that also direct the logs into files Preferably this would be some templated thing since there are lots of things we potentially want to trace out Log of instructions log of branch predictions debug visualization log of cache hitsmisses etc It would be nice if we could build VCSverilator simulator and generate all these different logs at once I just started to study riscvboom several days ago if Im wrong please correct me BTB only stores partial tags for instructions so aliasing could happen for branch instructions But when it happens it seems that you dont correct it in f stage For example if we have fetch packets Fetch boundary of st fetch packet is x it contains RVC instructions x rvc not a jaljalr instruction x rvc not a jaljalr instruction x cbeqz to target x rvc not a jaljalr instruction Fetch boundary of nd fetch packet is x it also contains RVC instructions x rvc not a jaljalr instruction x rvc not a jaljalr instruction x cbeqz to target x rvc not a jaljalr instruction Lets assume that btb has already stored information about st fetch packet and will predict instruction at x as taken But btb hasnt recorded information about nd fetch packet If we begin to execute instructions in nd fetch packet It will point to the same entry in btb because their partial tags are equal and aliasing happens Therefore when fetchpc x btb will also predict that frontend should jump to target In f stage the complex branch predictorgshare or tage maybe also predict cbeqz to target as taken when f valid f btbrespvalid btb made a prediction Make a redirect request if the BPD br comes earlier than the BTBs redirection If both the BTB and the BPD predicted a branch the BPD wins if disagree involves refetching the next cacheline and undoing the current packets mask if we undo the BTs taken branch val btbidx f btbrespbitscfiidx when BpredTypeisAlwaysTakenf btbrespbitsbpdtype f bpdmayredirecttaken iof bpdrespvalid f bpdbrtaken f bpdbridx btbidx assert f btbrespbitstaken elsewhen f btbrespbitstaken does the bpd predict the branch is taken too assuming bpdvalid val bpdagreeswithbtb f bpdpredictionsbtbidx f bpdmayredirecttaken iof bpdrespvalid f bpdbrtaken f bpdbridx btbidx bpdagreeswithbtb f bpdmayredirectnext iof bpdrespvalid f bpdbrtaken assert BpredTypeisBranchf btbrespbitsbpdtype elsewhen f btbrespbitstaken f bpdmayredirecttaken iof bpdrespvalid f bpdbrtaken otherwise BTB made no prediction let the BPD do what it wants f bpdmayredirecttaken iof bpdrespvalid f bpdbrtaken add branch to the BTB if we think it will be taken f bpdbtbupdatevalid f bpdmayredirecttaken We have bpdagreeswithbtb f bpdmayredirecttaken f bpdmayredirectnext when iobtbrespvalid when iobtbrespbitscfitype CFIBR iobtbrespbitstaken bpdpredictedtaken wrongcfi ioisbrbtbidx wrongtarget iobrtargsbtbidx btbtarget elsewhen iobtbrespbitscfitype CFIJAL wrongcfi ioisjalbtbidx wrongtarget iojaltargsbtbidx btbtarget elsewhen iobtbrespbitscfitype CFIJALR wrongcfi ioisjrbtbidx otherwise wrongcfi iobtbrespbitscfitype CFIX iobtbrespbitstaken when iovalid assert iobtbrespbitscfitype CFIX fetch predicted on a noncfi type val nextlinepc nextFetchStartioalignedpc val btbwaswrong iobtbrespvalid wrongcfi wrongtarget ioinstmaskbtbidx val jalidx PriorityEncoderioisjalasUInt val btbhit iobtbrespvalid val jalwins ioisjalreduce btbhit btbwaswrong jalidx btbidx iobtbrespbitstaken Perform redirection Redirect if JAL comes before BTBs cfiidx kill everything behind JAL including BTBs predinfo BTB was wrong if JAL take JAL if valid instructions available if JAL request nextline set all masks to valid No JAL BTB correct do nothing ioreqvalid jalwins btbwaswrong ioreqbitsaddr Muxjalwins iojaltargsjalidx nextlinepc Help mask out instructions after predicted cfi ioreqcfiidx Muxjalwins jalidx fetchWidth U So wrongtarget btbwaswrong reqvalid reqbitsaddr nextlinepc because no jal occurs who wins bchecker or bpd val jaloverridesbpd f hasjal f jalidx f bpdredirectcfiidx f bpdmayredirecttaken val f bpdoverridesbcheck f bpdmayredirect jaloverridesbpd bcheckerioreqvalid f bpdredirectcfiidx bcheckerioreqcfiidx f reqvalid f valid f bpdmayredirect jaloverridesbpd bcheckerioreqvalid f reqbitsaddr Muxf bpdoverridesbcheck f bpdredirecttarget bcheckerioreqbitsaddr Finally it will redirect f stage to fetch the next fetch packet But actually we should redirect f stage to target Such as results of CoreMark and Dhrystone That would be very useful thanks I find a picture from Western Digital but I dont know why SweRV wide superscalar inorder cpu has higher score than BOOM wide outoforder cpu I guess the performance of the latest verison of BOOM should be improved a lot comparing to the picture above Related issue if applicable choose one Type of change new feature choose one Impact no rtl change choose one Development Phase implementation Release Notes This PR adds FireSim FPGA integration to CI to check both Buildroot and Fedora Linux boot on LargeBoom This uses Chipyard to initialize and setup FireSim FireSim runs are started at am on Thursdays weekly only on the master branch In order to start the FPGA image build one of the BOOM developers must click the awsapproval button in the CircleCI UI choose all that apply Type of issue bug report if the issue is NOT a question fill out the following sections choose one Impact new rtl choose one Development Phase request Other information I got an error message when booting linux It passes all RISCV tests Configuration The number of INT Registers Error message sstatus sbadaddr fffffffb b scause d Kernel panic not syncing Attempted to kill init exitcode x b end Kernel panic not syncing Attempted to kill init exitcode x b Other trials INT Reg INT Reg Works fine for Linux Related issue if applicable choose one Type of change enhancement choose one Impact new rtl choose one Development Phase implementation Release Notes Text from here to the end of the body will be considered for inclusion in the release notes for the version containing this pull request The LSU used to attempt to clear busy bits on every addrgendatagen This PR introduces a stqclrhead to the LSU which marks the next store to clear the busy bit for The LSU now uses this head to clear busy bits for stores which should simplify future decoupling of the addrgendatagen pipelines 