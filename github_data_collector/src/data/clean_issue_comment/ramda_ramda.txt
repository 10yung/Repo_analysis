tap run the sideeffect with input first and return the input symb Rtapf a fa a describes what Rtap do more clearly Since ArrayprototypeflatMap has arrived one would perhaps expect that like map filter etc chainfn anArray dispatches to the native implementation anArrayflatMapfn as well That change would allow Ramda to work better on other types which still just expose a flatMap method KefirflatMap BaconflatMap Though the latter is the actually the reason I am asking Because I am too lazy to motivate to add a chain alias to those libraries Of course it would break Ramda code which operates on a user type exposing a flatMap which is not fantasyland chain add lensEq and lensSatisfies js const obj a b c d const dLens RlensPath c d RlensEqdLens obj true RlensSatisfiesn n dLens obj true lens is very useful we should strengthen its capabilities now i have the code below js const tagTypeLens RlensProptagType const lensEq lens value target RequalsRviewlens target value const isNumberType lensEqtagTypeLensnumber can i use propEq with lensProp like this js const tagTypeLens RlensProptagType const isNumberType RpropEqtagTypeLens number i think the lens related apis could be very powerful they could use with any prop path related apis does it make sense CrossEye Optimize partial and partialRight as you suggested related to If I have a function created by partialRight and passing in wrong count of arguments this will lead to wrong behavior of original function For example js const greet salutation title firstName lastName salutation title firstName lastName const greetMsJaneJones RpartialRightgreet Ms Jane Jones greetMsJaneJonesHello Mr Green Hello Mr Green Jones So function created by partialRight should be restricted to the right count of parameters Make propEqpathEq parameters order be consistent to propSatisfiespathSatisfies parameters order related to pathEqs path and propEqs prop is the first parameter but pathSatisfies and propSatisfies is the second parameter should their parameters order be consistent const also func var funcvar var const concurrent fns var appendid flipmapapplyTovar const progress fns var scan acc fn fnacc var alsotoUpper foo FOO foo concurrent toUpper toLower concatBar FooBar FOO foo FooBar progress toUpper concatBAZ split FooBar FOOBARFOOBARBAZ FOO BAR BAZ I feel that a common barrier in writing pipes has been losing information that one later needs Existing solutions using ramdas existing API that I am aware of feel overpowered and difficult to reason about I feel adding simple convenience functions like these provides a much more accessible alternative For example pipe chainhead append pipe aphead append To understand theseone is forced to think at an extra level of abstraction function monad S combinators and one to do it all at once While it can be used I feel the abstraction increases the barrier of entry for endusers and it still lacks the power of concurrentprogress for this case pipe list convergeflipappendlist head list Other solutions are even more unwieldy pipe alsohead applyappend pipe concurrent head applyappend pipe progress head applyflipappend With these functions we can split this into two trivial steps and easily describe the flow of whats going on In general it seems ramda provides a lot of ways of transforming data and converging collections of data into points and I feel it would be nice to provide a simple way of covering the other case that of diverging data into paths I also feel that this is a logical extension of the existing API Ramda already provides a lot of constructs for conditionally branching into different paths when cond ifElse etc whereas this provides unconditional branching Note the symmetry that they share with existing low level ramda functions concurrent apply N functions concurrently to variable with N results map apply function concurrently to N variables with N results progress apply N functions consecutively to variable with N results scan apply function concurrently to variable with N results 