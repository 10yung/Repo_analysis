These changes remove some unnecessary trait restrictions on the functions and also generalize all uses of PartialEq including the set implementation to arbitrary types implementing PartialEqT I think in most cases this introduces no breaking changes and all tests still run and pass as before however a larger corpus or test base may better confirm this The only thing that makes me less sure is things like the change to sym which cause the returned parser to be a different type than types that are inferred from input arguments ie the output type now is inferred from usage rather than from arguments so it may be the case that existing code will need annotations to disambiguate So to be safe it may be appropriate to put this toward a breaking API release Example Im parsing for supported datatype with rust static ref MUSTBEVALIDDATATYPE String format must have a valid data types are SUPPORTEDDATATYPEjoin tagboolmap DataTypeBool tagu map DataTypeU tagu map DataTypeU tagu map DataTypeU expect MUSTBEVALIDDATATYPE I want to display show the symbols that are being processed instead of only the first letter Im trying to generalise the approach found in the whitespace example I think some changes may be needed in pom The following function is illegal fn withindentationa Tp Parsera u T Parsera u T where T a Clone Sized indented emptymap vec repeat map lines linesintoiterfilter line linelen fold vec accum line accumintoiterchain lineintoiterchainvec b n intoiter collect mapmove lines pparse lines expectsubparse The error is like this fn withindentationa Tp Parsera u T Parsera u T lifetime appears in the type of p pparse lines borrowed value does not live long enough expectsubparse argument requires that lines is borrowed for lines dropped here while still borrowed There is a problem map takes Fn not FnOnce so its not possible to guarantee idempotence Following up on the discussion in I created one possible implementation which allows chaining parsers without getting a nested tuple result You can see the result of this at the link below Note that in this example I could have removed the call to map entirely but I wanted to leave it to demonstrate that the hours minutes seconds tuple is not longer nested Unfortunately at the moment Im not sure how this could be extended to tuples of any size without creating all all allN for some reasonable value of N Another downside of this approach is when the user adds a parser to the chain theyd have to switch which version of the all function they are using from allN to allN The upside to this is the result is a not nested tuple of the results of each of the parsers which means this could nicely replace the use of the and combinators allowing users to write these types of combinations in what Id consider to be more idiomatic Rust Thanks again for your work on this crate and feel free to let me know if this isnt something you are interested in