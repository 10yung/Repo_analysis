Since NSURLSession will execute the requests on a background thread we can end up in the situation when the tearDown of a previous unit test stops Nocilla since it no longer needs it and startLoading gets called while in the middle of another unrelated test case thus causing an exception and failing the other test So were early returning from startLoading to prevent this kind of failures Making sure that the correct implementations are restored to NSURLSession and LSNSURLSessionHook Using methodexchangeImplementations mixes up the IMP for both classes to a point where Nocilla no longer responds to stubs This PR Adds an LSURLMatcher class and updates LSStubRequest to use it instead of the regular LSStringMatcher The motivation for this is that LSStringMatcher is not content aware and so creates false negatives when matching URLs that are equivalent but not identical The most common example is when the query parameter order is different eg Query parameter order can be nondeterministic as it depends on things like the order of enumeration of an NSDictionary which is undocumented and changes between iOS versions or when using different enumeration methods Avoid conflicts with The following line parsed and worked fine using Nocilla in Swift stubRequestPOST baseURLhello withHeaders contenttype applicationjson USERID foobarcom withBodytry JSON body serialize How do I spell this in Swift Due to issues with bridging Foundation data types and nullability annotation using Nocilla from a Swift has become extremely cumbersome Is there any chance that this library is going to be updated to provide better Swift support in the near future This adds annotations necessary for normal usage on Swift Without these code must deal with null values that Nocilla never actually returns ie lots of interspersed in Nocilla DSL calls I haven t been able to find an ObjC annotation that gets rid of unused value warnings for the returned function pointers Nocilla uses In Swift it s necessary to do this stubRequest Im trying to stub a request with a specific body im copying it from Charles but im getting always the same error Use this snippet to stub the request stubRequestPUT withHeaders Accept applicationjson AcceptEncoding gzipq compressq AcceptLanguage enUSq ContentLength ContentType applicationjson UserAgent UnknownUnknown Unknown OS Version Build E XdeviceToken deviceToken XplatformId deviceId deviceId languageId withBody matchIds MatchId MatchId values viewed true And this in my test let urlPut stubRequestPUT urlPut withBodyfromJsonFilegetMatchesRequestPUTBody andReturn withHeaders ContentType applicationjson Where getMatchesRequestPUTBody contains matchIds MatchId MatchId values viewed true If i remove the line withBody it works as expected Any ideas Notice im stubbing request in the same method public func fromJsonFilefileName String String return fromFilefileName fileExtension json public func fromTxtFilefileName String String return fromFilefileName fileExtension txt public func fromFilefileName String fileExtension String String let classBundle NSBundleforClass selfclassForCoder let path classBundlepathForResourcefileName ofType fileExtension let absolutePath path do return try StringcontentsOfFile absolutePath encoding NSUTF StringEncoding catch printError trying to read file absolutePath The file does not exist return I have a multiple test set one of them uses nocilla so I execute LSNocillasharedInstancestart when it begin and stop it at the end but when the other test that needs actual internet runs I keep getting NocillaUnexpectedRequest reason An unexpected HTTP request was fired I dont know is it still in your list of priorities but I found out that your library does not want to work with ASIHTTPRequest correctly My AFNetworking requests finished successfully but ASIHTTPRequest request that starts synchronously never leaves this loop ASIHTTPRequest method startSynchronous if self isCancelled self complete self main while complete NSRunLoop currentRunLoop runMode self runLoopMode beforeDate NSDate distantFuture After Nocilla calls requestFinished this local variable complete stays the same 