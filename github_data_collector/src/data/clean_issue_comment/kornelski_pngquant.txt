I think it shows some valid issues Hello I used this code to compress PNG image in IOS project but the data I got failed to pass a transparency judgment I wonder if the compressed PNG is not a true color image How can I modify the codethank you my Code int progresscallbackfunctionfloat progresspercent void userinfo return NSData compressToPNGWithImageUIImage comImg unsigned int width height CFDataRef pixelData CGDataProviderCopyDataCGImageGetDataProvidercomImgCGImage const uint t data CFDataGetBytePtrpixelData width intcomImgsizewidth height intcomImgsizeheight liqattr handle liqattrcreate liqattrsetprogresscallbackhandle progresscallbackfunction NULL liqsetqualityhandle liqsetspeedhandle liqimage inputimage liqimagecreatergbahandle data width height You could set more options here like liqsetquality liqresult quantizationresult if liqimagequantizeinputimage handle quantizationresult LIQOK fprintfstderr Quantization failed n return nil Use libimagequant to make new image pixels from the palette sizet pixelssize width height unsigned char raw bitpixels mallocpixelssize liqsetditheringlevelquantizationresult liqwriteremappedimagequantizationresult inputimage raw bitpixels pixelssize const liqpalette palette liqgetpalettequantizationresult Save converted pixels as a PNG file This uses lodepng library for PNG writing not part of libimagequant LodePNGState state lodepngstateinit state stateinforawcolortype LCTPALETTE stateinforawbitdepth stateinfopngcolorcolortype LCTPALETTE stateinfopngcolorbitdepth forint i i palettecount i lodepngpaletteadd stateinfopngcolor paletteentries i r paletteentries i g paletteentries i b paletteentries i a lodepngpaletteadd stateinforaw paletteentries i r paletteentries i g paletteentries i b paletteentries i a unsigned char outputfiledata sizet outputfilesize unsigned int outstatus lodepngencode outputfiledata outputfilesize raw bitpixels width height state if outstatus fprintfstderr Cant encode image s n lodepngerrortextoutstatus return nil NSData outputdata NSData dataWithBytesoutputfiledata lengthoutputfilesize liqresultdestroyquantizationresult Must be freed only after youre done using the palette liqimagedestroyinputimage liqattrdestroyhandle freeraw bitpixels lodepngstatecleanup state return outputdata judge uint t c imageData getBytes c rangeNSMakeRange if c x NSLogIts not what I want return I try call windows binary from c I use stdin and stdout and everything is works except small images size is less than bytes When I use call with image path everything works fine Code example and image example var startInfo new ProcessStartInfo CreateNoWindow true FileName PngquantPath Arguments speed quality skipiflarger RedirectStandardInput true RedirectStandardOutput true UseShellExecute false using Process process ProcessStartstartInfo using var outputStream new MemoryStream processStandardInputBaseStreamWriteimageBytes imageBytesLength processWaitForExit var err processStandardErrorReadToEnd await processStandardOutputBaseStreamCopyToAsyncoutputStream imageBytes outputStreamToArray testx In the process of making changes to formulae in the Homebrew package manager I noticed that pngquant was one of a handful of Rustrelated applications without a Cargolock file in version control The Cargo book recommends the following source If you re building an end product which are executable like commandline tool or an application or a system library with cratetype of staticlib or cdylib check Cargolock into git More information about the reasoning can be found in the Why do binaries have Cargolock in version control but not libraries section of the Cargo FAQ The Cargolock file helps package managers to keep builds reproducible since cargo install simply uses the latest dependency versions unless the locked flag is added to the command in which case it will use the versions outlined in Cargolock Without a Cargolock file theres a chance that a dependency update will break the build sometime in the future which is something Ive already encountered with other Rust binary projects Would you please consider checking Cargolock into version control where appropriate This is more of a question If I needed a palette output restricted to ARGB and not ARGB is it possible somehow to modify the code to reduce the bit depth available I see the code that handles the IE and alpha and it made me think that if I were to modify the alpha input values to only contains values that could be reduced to bits ie fixed intervals with no alpha values between those intervals would that cause the output to strictly stick to those alphas in the output palette or would it generate blended alpha values beyond the restricted alphas I allowed in order to optimize the palette I know I can go in and force the output palette to only have the alpha values I want but then the palette could end up with wasteful intraalpha values that get reduced to the same alpha value in the end I was quite surprised that after running program for image optimization with defaults I ended up with of smaller images and of larger images and with bigger total skipiflarger must be default setting preparesort function in mediancutc qsortchannels sizeofchannels comparevariance Only the first channel really matters When trying median cut many times with different histogram weights I dont want sort randomness to influence outcome tmp unsigned intchans channels chan unsigned intchans channels chan chans channels chan chans channels chan After qsort operation to channels the variance should be like this channels array and from the comment it says the first channel really matters I think the weight here is about the variance so the weight should be like array and the first could amply its importance and the least makes it does not important So I think the code here should be like below isnt it tmp unsigned intchans channels chan unsigned intchans channels chan chans channels chan chans channels chan If not could you tell me why the code snippet is like original version thanks Lu ASAN reports this memory leak Direct leak of bytes in objects allocated from x d in malloc xccd c in liqalignedmalloc pngquantlibimagequantc xccd in liqimageuselowmemory pngquantlibimagequantc xccd in liqimagecreateinternal pngquantlibimagequantc x ce in readimage pngquantc x ce in pngquantfile pngquantc x a d in pngquant pngquantc Instead of fs Id like to have the extension say which quality level it was saved at It would be pretty cool if there was some kind of dryrun option which would print out the difference in filesize without altering the existing image This would allow you to see what the overall impact would be from different set of optionsimages before committing to writing anything to disk