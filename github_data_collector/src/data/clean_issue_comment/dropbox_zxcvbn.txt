Examples apple apple Score apple apple note the trailing space Score apple apple apple Score Especially the first example seems way off Hi in the script buildkeyboardadjacencygraphspy was put at the end of the second line of the qwerty keyboard however this key is actually at the bottom left of such a keyboard Why was it done this way And we can t just change its location to the bottom left without also changing the code since it uses a shift of position for every new line slant y if slanted so this doesn t work because the last line starts further to the left than the secondtolast line For example assboommoosemargaret seems to work fine showing dictionary matches However if I add another dictionary word it fails on the first word For example assboommoosemargaretlook does not recognize the first word and lumps the first two words into one brute force pattern Whats going on here The dictionary oddly leaves out common words like cow tho cows seems to be in the dictionary I recommend including a much broader dictionary step I would imagine that actual password cracking techniques will go through words in order of assumed commonality This vastly overestimates the security of passwords that contain words this dictionary set doesnt happen to contain It would be best to contain a more realistic set of dictionary words Fast hash threat model assumes hashes per year math In Towards Reliable Storage of bit secrets in human memory the researchers estimate an attacker could hit SHA hashes per year at a cost of US M in pg based off of bitcoin hash rates which seems a very reasonable metric To match that alone the billion second would need to upgrade to trillion second math US style affixes Ive not analyzed the slow hash times to see if Id agree with them but Id gather they can be safely derived from the fast hash times assuming bcrypt et al per the above paper adding bits might be safe Actually using the original per year we have over k second with bits added math or rounding up for pessimism about B second for the year figures math On the other hand your estimates might be entirely reasonable depending on the attacker What are the attackers presumed capabilities In an unrelated note I think second might be equally feasible for an unthrottled online attack given my experiences with negligent server administrators and poor password storage It seems feasible with increasing bandwidth and server speeds that the unthrottled online attack also might change though perhaps more slowly than offline attacks Contrariwise the throttled online attack might well be much reduced from hour in the case of a debit card PIN for example the limit is traditionally just attempts before nontemporal lockout Often systems have a much lower lockout throttle than hour though being pessimistic is better than optimistic Current bitcoin hashrates appear to have peaked at time of this bug report at around THs or over million trillion hashes That was on the nd of October one source Same site estimates an income of per TH for the same date for an approximate cost in late of USD per THs math If an attacker has to spend in for a year of cracking they can crack approximately hashes that year math which is about wolfram alpha finally gave up on my odd equations bits math of entropy in a year Possibly the attacker wants to spread the cracking around to multiple accounts or has less than or more than to spend If we give the attacker times more money to attack accounts both somewhat reasonable pessimistic assumptions the numbers thankfully cancel out reasonably leaving about bits of true entropy cracked for each of accounts in a year with a USD system Can add the log of the ratio between money multiplies and accounts multiplier ie log for M USD and accounts to play with moneyspread easily ie a k rig targeting one account for year would also hit bits of entropy as the ratio is the same Anyway all that to say that I think bits cracked per year per account is too optimistic Around THs seems more reasonable to me or if really needing a strict THs results in about bits in a year or about per user per year I just found out that of the library size is represented by the frequency lists I wonder if it would be useful to create a version of the library that do not implement checks on the frequency list that is anyhow based on english words This would make it possible to reuce the sice of the library from kb to kb We added the example passwords that show on our password form to the userinputs for zxcvbn in an attempt to have these passwords and derivatives of them heavily penalised We observed that if our users copy the password as it appears on the page they will actually get a passing score from zxcvbn This appears to be a result of the example passwords having upper case characters and the user inputs array being converted to lower cased within zxcvbn The benefits zxcvbn applies for using mixed case mitigates a significant chunk of the penalty applied from a match against user inputs Here is an example using the popular XKCD password effectively the same style of password we encourage our users to use Mixed case in userinputs is clearly ignored zxcvbncorrecthorsebatterystaple userinputs correcthorsebatterystaple guesseslog zxcvbncorrecthorsebatterystaple userinputs correctHORSEbatterySTAPLE guesseslog There is a significant bonus applied for mixing case in a password As shown earlier case is ignored in the user inputs so the guesses are unintuitively high for what appears to be an exact match zxcvbncorrectHORSEbatterySTAPLE userinputs correcthorsebatterystaple guesseslog zxcvbncorrectHORSEbatterySTAPLE userinputs correctHORSEbatterySTAPLE guesseslog It is worth being clear that there is still a significant penalty being applied here The guesses where a match has been made are still considerably lower than without a match zxcvbncorrectHORSEbatterySTAPLE userinputs guesseslog We think that case should be considered in user inputs but it is clear that zxcvbn has been written assuming case from dictionaries and user inputs doesnt matter We welcome any speculation about how we could penalise matches against user inputs more or otherwise prevent our example passwords being seen as stronger passwords than they should be The npm commands to build and watch doesnt seem to work properly on Windows They cant find the coffee scripts to compile If I run npm run build I get File not found FULLPATH zxcvbn src coffee If I run nodemodules bin coffee with the same arguments as in the build scripts it works Note that for one of my coworker even this doesnt work and he have to change the coffee to a single file Was it ever working properly on Windows 