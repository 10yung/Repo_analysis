IntelliJ has added a new API to support macro libraries and it seems quite simple and powerful IntelliJ support is blocking me from using scalarecords Now that supporting IntelliJ is easier do you think it will be added in the short term Thanks in advance info Compiling Scala sources to UsersdragosworkspaceSparkscalarecordsbenchmarkstargetscala testclasses error UsersdragosworkspaceSparkscalarecordsbenchmarkssrctestscalarecordsbenchmarkRecordsBenchmarkSuitescala trait Rec takes type parameters error def accessRecSwitchi Int size Int rec Rec Any macro BenchmarkingMacrosaccessRecSwitch error error one error found error benchmarkstestcompileIncremental Compilation failed error Total time s completed Nov AM Probably the SNAPSHOT dependency isnt on Maven anymore warn warn UNRESOLVED DEPENDENCIES warn warn comchuusaishapeless SNAPSHOT not found warn warn warn Note Unresolved dependencies path warn comchuusaishapeless SNAPSHOT UsersdragosworkspaceSparkscalarecordsprojectBuildscalaL warn chepfllampscalarecordsbenchmarks SNAPSHOT trace Stack trace suppressed run last benchmarksupdate for the full output error benchmarksupdate sbtResolveException unresolved dependency comchuusaishapeless SNAPSHOT not found error Total time s completed Nov AM scala val r Record def name String def age Int Recordnewdef name Chris def age See and The only documentation is in the test cases This should be done after we cleanup the syntax in New goal as concluded updated docs and tests to use applyDynamicNamed syntax Superseeded vjovanov gzm what do you think about removing this syntax Both are supported right now The second one highlights the typesafety and looks like case class constructors And no need to have apis PS Slowly finding time again for records Investigating the differences between cvogtcompossible and scalarecords as preparation for a future merge After dicussing with gzm extensively over the weekend we realized that my macros in compossible and scalarecords actually are still quite complimentary in their features rather than competitive We should strongly consider joining forces ie merging I think This requires agreement on first Apart from that we seem to have made the same design decisions or complement each other compossible implements fully blackbox Record create merge and select operations and nicer syntax whitebox alternatives explicit and optional implicit conversions fromto case classes and anonymous classes I have also written a playjson deserializer for these records which will be the first use case for which we will start using them in production at xdotai I am still missing equality comparison hashCode and these things which you guys already have I am also missing pattern matching yet That multibackend feature is nothing I would have implemented for mine but I can see the importance of this for certain use cases Id be happy to merge and join forces I am ok with migrating my stuff into Scala Records if we can agree on all design decisions Also Id like to stabilize and finalize a small core soon so I can use it in production and go form there My Scala Days talk is about my implementation by the way which you might want to check out This should work scala import recordsRec import recordsRec scala Reccrazyname Hannahcrazyname works res String Hannah scala Reccrazyname Hannahcrazyname does not work javautilNoSuchElementException key not found crazyname Note Include test that we can have a record with both a field and a field minus We have the following possibilities Expose disjoint fields in the joined record and leave common fields in nested records r Rec def r Rec def y def r Rec def y def x def z If somebody tries to access ry we can generate a compile time error message that says look in r r Just leave two nested records Slick does something similar r Rec def r Rec def x def y def r Rec def y def z Here we could also have an error message if somebody misses a field Leave both nested records and provide disjoint fields in the joined record r Rec def r Rec def x def y def r Rec def y def z def x def z 