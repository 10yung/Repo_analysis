 Thank you for proposing a contribution to the ANTLR project In order to accept changes from the outside world all contributors must sign the contributorstxt contributors certificate of origin Its an unfortunate reality of todays fuzzy and bizarre world of opensource ownership Make sure you are already in the contributorstxt file or add a commit to this pull request with the appropriate change Thanks This PR introduces Dart target It passes all existing test cases Why Dart IMAO Dart is currently the best language that runs easily on browser Android iOS Windows Linux and MacOS Also it supports AOT compilation which surprised me by passing PerformanceTestDropLoopEntryBranchInLRRule with ease This test case takes ages to run with JITVM but with AOT it finishes within two seconds Acknowledgments This targets runtime is built from scratch by converting the Java target However in many places I referred to tiagomazzutti s port which helped a lot Many thanks to tiagomazzutti and thosakwe for previous attempts Also thank you marcospassos for adding the codegen tweaks which makes building this target a lot easier TODO I will add some documentations if the code looks good Document releasing procedure Add in docdarttargetmd and doctargetsmd Add more information to doccreatingalanguagetargetmd so its easier for future targets Also this is my first open source contribution so please let me know if anything needs to be fixed Fixes The Lexer class provides the setTokenFactory template function but its function signature means that its body cant compile The function is defined as follows templatetypename T void setTokenFactoryTokenFactoryT factory thisfactory factory where thisfactory is declared as a stdsharedptr RefTokenFactoryCommonToken factory The function cant work because stdsharedptrT provides no assignment operator from T nor does it provide an implicitly converting constructor from T ie its T constructor is marked explicit Lexer works with the default CommonTokenFactory only because it assigns its factory using CommonTokenFactoryDEFAULT which is a sharedptr of the same type as factory I believe setTokenFactory on Lexer Parser and TokenSource should be changed to the following signature templatetypename T void setTokenFactoryRefTokenFactoryT const factory and the implementation of LexersetTokenFactory should be templatetypename T void setTokenFactoryRefTokenFactoryT const factory thisfactory stdstaticpointercastTokenFactoryCommonTokenfactory Because of the declared type of Lexerfactory its necessary for the factory argument here to be convertible to a stdsharedptrTokenFactoryCommonToken Before submitting an issue to ANTLR please check off these boxes X I am not submitting a question on how to use ANTLR instead go to antlr discussion google group or ask at stackoverflow X I have done a search of the existing issues to make sure Im not sending in a duplicate Please include information about the expected behavior actual behavior and the smallest grammar or code that reproduces the behavior If appropriate please indicate the code generation targets such as Java C Pointers into offending code regions are also very welcome C Runtime Nuget package version ANTLR version antlr completejar Hello I have two grammar files One is a lexer grammar so I can use modes and the other is a parser grammar I have written a custom token inheriting from CommonToken I created a token factory implementing ITokenFactory I can set the token factory of the lexer just fine using the below code lexerTokenFactory tokenFactory But I cannot set the parsers Token Factory property since it is read only I would expect to be able to use this code parserTokenFactory tokenFactory Is there something I am missing I did search for information and what I found about the Java runtime implies this is possible in general but I cannot see how to do it with the C runtime Thanks in advance Recently I try the Python language with Golang runtime with And in line have a logic need to setText java private void emitint tokenType int channel String text int charIndex getCharIndex CommonToken token new CommonTokentokenFactorySourcePair tokenType channel charIndex textlength charIndex tokensetLinegetLine tokensetCharPositionInLinegetCharPositionInLine tokensetTexttext here emittoken Then I try in Golang but I can setText but GetText will failure and I found in the antlr runtime here is a different logic with Go L go func c CommonToken GetText string if ctext check empty return ctext input cGetInputStream if input nil return n inputSize if cstart n cstop n return inputGetTextFromIntervalNewIntervalcstart cstop return EOF in L is a check but in other target It is null check here is JavaScript version javascript get function if thistext null return thistext var input thisgetInputStream if input null return null var n inputsize if thisstart n thisstop n return inputgetTextthisstart thisstop else return EOF Python version L python property def textself if selftext is not None return selftext input selfgetInputStream if input is None return None n inputsize if selfstart n and selfstop n return inputgetTextselfstart selfstop else return EOF Others Cpp Version C Version I think in the go target should keep same logic with others Trying out this very simple grammar based on examples from ANTLR book cat CommonLexerRulesg lexer grammar CommonLexerRules INT ID azAZ NEWLINE r n WS t skip FLOATLITERAL Digits Digits Digits ExponentPart fFdD Digits ExponentPart fFdD fFdD fragment Digits fragment ExponentPart eE Digits cat LibExprg grammar LibExpr import CommonLexerRules prog stat stat expr NEWLINE printExpr var expr assign NEWLINE blank expr expr op expr ElementWiseMathOp expr op expr ElementWiseMathOp FLOATLITERAL float ID id var var nameID When I try it with a correct program the results are fine grun LibExpr prog diagnostics tree var some some prog stat var var some expr stat n stat expr some n But when adding trailing integer on the first line the parser seems to be a bit lost does not report any errors or ambiguities note the diagnostics option just ignores everything after the first expression grun LibExpr prog diagnostics tree var some some prog stat var var some expr I guess if the grammar is wrong or the program is incorrect Antlr should return some error Simply ignoring the input tokens looks like a bug Antlr Mac OS X Before submitting an issue to ANTLR please check off these boxes X I am not submitting a question on how to use ANTLR instead go to antlr discussion google group or ask at stackoverflow X I have done a search of the existing issues to make sure Im not sending in a duplicate Please include information about the expected behavior actual behavior and the smallest grammar or code that reproduces the behavior If appropriate please indicate the code generation targets such as Java C Pointers into offending code regions are also very welcome Theres a call to ConsoleWriteLine format arg with the string equal to config from pred transition Unfortunately while the corresponding Java code works fine the C runtime calls ConsoleWriteLine which calls SystemConsoleWriteLineformat arg where the string is interpreted as a format Curly braces in C are interpreted as formatting In fact the code between Java C and C are all different hereall executing slight variations IMO Java should be source and C C etc completely and automatically generated by tool never touched by hand otherwise hands get chopped off My temporary solution is to just call SystemConsoleWriteLine directly in the C code like it is in the Java and C code if debug Systemoutprintlnconfig from pred transitionc if debug ConsoleWriteLineconfig from pred transition c if DEBUGDFA stdcout config from pred transition c stdendl endif In file and Both calls perform a cast of start and stop indices from sizet into int for the constructor miscIntervalsizet sizet This code does not compile The casts are not required because theyre already sizet Please remove the explicit casts in functions ParserATNSimulatorreportAmbiguity and ParserATNSimulatorreportAttemptingFullContext Im not making a pull request PR because it seems a previous request I made is being ignored for whatever reason I use the generated file in the project to have the package path The code can be used but the generated class file cannot use the grun command For example javalangNoClassDefFoundError file name wrong name package name Is there any good way Why not filter out the class package The current guide to build ANTLR for Swift is still uptodate although it requires some changes in the docs as some steps do not work and the user have to follow the errors which appear when executing the guide for Swift target stepbystep The guide also mentions that it uses Swift Package Manager to generate the XCode Project and since iOS is not supported there some manual changes are required to make it work under iOS I was able to compile it for iOS and even use the Swift to compile the generated project but that did not work at the end though After doing all suggested steps the app crashes with Library not loaded rpathAntlr framework error Would it make sense to create a Carthage package for ANTLR That would simplify life of devs a lot ANTLR is the only opensource project at the moment which supports Swift target and parsing binary streams so having an iOS support would be a good addition I think has a broken link to Antlr for C with CMake A practical example 