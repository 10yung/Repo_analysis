assign typo correction Bug Report If you pass windowlocation as the draft to produce IE throws an error The error is essentially the same one described in this corejs issue In short IE s native ObjectgetOwnPropertyDescriptor cant work with environment exotic objects which is the cause for this bug You can easily reproduce the issue by pasting this in your IE Dev Tools and hitting enter ObjectgetOwnPropertyDescriptorwindowlocation host Link to repro To Reproduce Clone the repo Install the serve package Run the following command yarn build serve s build Navigate to using IE and see how the app does not load Navigate to using ChromeFF and see how the app loads fine To verify that the app loads fine in IE without this bug Comment out the lines in the srcindexjs file Run yarn build serve s build once again Observed behavior If you pass windowlocation as the draft to produce IE throws an error Expected behavior produce should be able to successfully create a draft from any object in any of the supported browsers Environment Latest version of Windows Latest version of IE Immer Immer version x Occurs with setUseProxiestrue x Occurs with setUseProxiesfalse ES only i have a immature idea if we have a large obj such as var obj a a a a now immer looks like its going to copy the object all key again likeobj its will slow how about just like this var objProto protoobj then we can access property like objProtoa and we can modify property like objProtoa and we Not modify origin data obj Originally posted by zhangenming in Thoughts might safe time and space Might mess up iteration since a lot of properties wont be own Could be an experimental opt in option Bug Report I have three observations about potential issues with Immers bundle size and treeshakeability Immer went from K mingz in x to around K mingz in v x v is a slight improvement over but still bigger than x See for size comparisons I assume this is due to the extra code for SetMap handling Redux Toolkit depends on Immer and weve noted that several of our dependencies prevent RTK from being correctly treeshakeable Someone ran a Webpack report to get indications of why Webpack couldnt treeshake RTK and it report that Immer has a reference to process inside which forces Webpack to bail out of treeshaking Reference The process reference appears to be part of a minification check at This does show up in distimmerjs in the published package Immer does not appear to have a sideEffects false flag in its packagejson which Webpack and other bundlers need to fully calculate shakeability I dont know how much improvement youd get by adding sideEffects false and removing the process reference but it might be worth looking into I also realize that Immers internals may not be entirely shakeable anyway similar to how React is kind of allornothing Still given that v x is bigger than v x itd be nice to see if it can be brought back down Link to repro NA given that this is not a runtime issue See linked items in the report section for details To Reproduce Use Immer as currently published Observed behavior Immers size in v is larger than v and does not appear to be shakeable Expected behavior Webpack would report that Immer is shakeable and hopefully the final included size would be a bit smaller Environment We only accept bug reports against the latest Immer version Immer version v Bug Report Im looking into immerjs as inspiration to make modifying immutable data structures in C less painful While studying the source code I encountered a confusing naming inconsistency The docstring for produce mentions a recipe function The param mentions a producer The actual function parameter name is recipe The Immer documentation calls the parameter producer Just wanted to point this out I dont know if itll get fixed or not Im not actually use immerjs since I dont write JavaScript but I really like the approach used here less painful than transients and I can understand the API unlike lenses I am thinking of porting this library to C or maybe Rust though with setters since I cant intercept assignment Bug Report import produce from immer const a highlight true const next producea draft drafthighlight false drafthighlight true consoleloga next false should be true CodeSandbox Currently produceWithPatches does not support async recipes being passed in Patches are undefined whilst the resulting state is a promise See Bug Report A case where calling produceWithPatches produces a correct next state but incorrect patches To Reproduce import produceWithPatches applyPatches from immer const item id const state item const nextState patches produceWithPatchesstate draft draft id draft item const final applyPatchesstate patches consolelogNext state nextState consolelogPatches patches consolelogFinal final Expected behavior I would expect nextState to deep equal final nextState is correct while the result from applying patches is incorrect The second operation in the patch is incorrect op replace path id value op add path value id Notice how the value of patch is the new value of draft and it is applying it at draft Link to repro Code Sandbox Environment Immer v X Occurs with setUseProxiestrue X Occurs with setUseProxiesfalse ES only Feature Proposal Given the following state tree typescript const state prop hello prop deepNestedTree someKey ANOTHERBIGOBJECTHERE someKey ANOTHERBIGOBJECTHERE someKey ANOTHERBIGOBJECTHERE someKey ANOTHERBIGOBJECTHERE I would like to be able to tell Immer to not scan deepNestedTree and each of its properties and then each properties of those for finalizing since I know that I never mutate them but rather just create the whole tree from scratch myself which comes from an API call So in essence deepNestedTree is a readonly property and its content is never mutated Motivation Idea here is that deepNestedTree could contain hundreds of thousands of records and those records could be quite wide themselves It takes a lot of time to traverse that tree and for my usecase it is pointless as its never mutated Example According to this I can just freeze statedeepNestedTree but is that the intended way to do it Could we perhapse get away with a function that adds a unique symbol to the object to let Immer know it doesnt need to finalize it Something like typescript import ignoreObject from immer producestate draft draftmyBigTree generateBigTree ignoreObjectDraftmyBigTree undefined 