This is partially a continuation from another issue thread but I wanted to open a new issue to gain some attention to the problem and hopefully get a response from the main BTCD developers First of all Im on board with supporting alternative implementations of bitcoin nodes Having multiple implementations interacting with the same blockchain is an essential part of a healthy blockchain ecosystem Right now it appears that bitcoin core runs the vast majority of nodes in the network judging solely based off logfiles describing peer connections to my node This is all well and good however if a critical flaw were to be found in bitcoin core it would cripple most of the blockchain network and potentially impact trust and adoption of cryptocurrency as a whole This is where alternative implementations such as BTCD play an important role we need viable alternatives to turn to in the event that consensus decides the leading node implementation is flawed BTCD very nearly works to solve this problem but after some time testing there exist some critical flaws preventing it from being seriously considered as an alternative node implementation The syncing performance leaves much to be desired Is it true that BTCD only syncs from a single peer to update the blockchain This doesnt sound very decentralized Additionally the time to sync blocks increases exponentially as the block height increases as you can see in the data collected from the logs below the gap in the data was from where I stopped syncing to mess with configs My fear is that the rate that new blocks are generated in the blockchain will exceed the rate at which they can be synced across BTCD nodes which will render BTCD mostly useless in the near future if it cant keep up I would really love to be able to recommend BTCD as a viable alternative node implementation but until these problems are fixed I cant recommend anybody to use it Figure Some wallet methods in the rpcclient library have hardcoded the chaincfgMainNetParams for example the GetNewAddress method calls the Receive method which hardcodes the MainNetParams when decoding the address func r FutureGetNewAddressResult Receive btcutilAddress error res err receiveFuturer if err nil return nil err Unmarshal result as a string var addr string err jsonUnmarshalres addr if err nil return nil err return btcutilDecodeAddressaddr chaincfgMainNetParams This returns an error when talking to btcwalletbtcd in simnet mode Is there a way to tell the rpcclient to use SimnetParams when talking to a simnet server Potential way to fix this would be to allow the user to specify the network type when constructing the client client err rpcclientNew rpcclientConnConfig Host Endpoint User Pass Certificates Network Simnet notificationHandlers Hi all I hope you all are having a good day For a project Im working on I need to modify chaincfg Ideally I am able to migrate a btcd fork to be fully compatible with Divi But for the time being I just need to get chaincfg fully migrated and working properly in our atomic swaps implementation I need two files for the atomic swap implementation to be fully compatible with Divi genesisgo paramsgo Using chainparamscpp as a reference to update these files What exactly do I need to do to make this fully compatible with the Divi chain So far Ive modified genesisgo genesisCoinbaseTx but not TxOutPkScript genesisHash genesisMerkleRoot genesisBlock paramsgo TargetTimespan TargetTimePerBlock MinDiffReductionTime PubKeyHashAddrID ScriptHashAddrID Please note that I am just trying to get testnet to work only for the time being Currently When I try to interact with a Divi RPC client I will get this error error unknown address type code message unknown address type Thank you in advance for the help And if I am able to get this working I am going to create a guide on how to update btcd to be compatible with other Bitcoin forks fixes syndtrgoleveldb supports go module at nowwe could migrate to latest goleveldb libary to improve performance First generate a P SH multisig address including some custom content script txscriptNewScriptBuilder custom content scriptAddOptxscriptOPHASH scriptAddDataHashPreimageR scriptAddOptxscriptOPEQUALVERIFY standard content scriptAddOptxscriptOP scriptAddDataaPubKey scriptAddDatabPubKey scriptAddOptxscriptOP scriptAddOptxscriptOPCHECKMULTISIG return scriptScript Then got an address like Mv R VNdiSzeFiDxs WVxeBZzTScrs Q Sent some test bitcoin to the address above Construct a transaction with btcdtxscript and btcdwire to spend a UTXO of the address above How to write the unlocking script Currently Im using txscriptSignTxOutput reference from signature sigScript err txscriptSignTxOutput chaincfgTestNet Params tx scriptPkScript txscriptSigHashAll mkGetKeymap string addressToKey address EncodeAddress key PrivKey true address EncodeAddress key PrivKey true mkGetScriptmap string byte scriptAddrEncodeAddress custompkScript nil if err nil fmtPrintlnSign has wrong err return txTxIn SignatureScript sigScript But got a error Sign has wrong cant sign unknown transactions Anybody have some idea Thank you very much the RawTxInput struct missing a field Amountthe RPC will return err this error message should read compressed not uncompressed func SignTransactionredeemTx wireMsgTx secret string destination string amount float utxos dtoUtxo error privByte hexDecodeStringprivKey privateKey pubKey btcecPrivKeyFromBytes btcecS privByte fromAddress btcutilNewAddressWitnessPubKeyHashbtcutilHash pubKeySerializeUncompressed chaincfgMainNetParams sourceAddress err btcutilDecodeAddressfromAddress chaincfgMainNetParams destinationAddress err btcutilDecodeAddressdestination chaincfgMainNetParams if err nil return err TODO Calculate fee estimation estimatedFee err btcutilNewAmount if err nil return err satoshiAmount err btcutilNewAmountamount if err nil return err totalSatoshiAmount satoshiAmount estimatedFee TODO optimize for selecting which UTXO to be used totalSum int for i i lenutxos i txValue err strconvAtoiutxos i Value if err nil return err totalSum int txValue sourceUtxoHash chainhashNewHashFromStrutxos i Txid prevOut wireNewOutPointsourceUtxoHash uint i redeemTxIn wireNewTxInprevOut nil nil redeemTxAddTxInredeemTxIn if totalSum int totalSatoshiAmount break Prepare pay to witness public script and add transaction outputs sourcePkScriptForOutput txscriptPayToAddrScriptsourceAddress destinationPkScriptForOutput txscriptPayToAddrScriptdestinationAddress change totalSum int totalSatoshiAmount changeTxOut wireNewTxOutint change sourcePkScriptForOutput redeemTxAddTxOutchangeTxOut redeemTxOut wireNewTxOutint satoshiAmount destinationPkScriptForOutput redeemTxAddTxOutredeemTxOut Signing transaction sigHash txscriptNewTxSigHashesredeemTx witnessSig err txscriptWitnessSignatureredeemTx sigHash int satoshiAmount sourcePkScriptForOutput txscriptSigHashAll privateKey false if err nil return err redeemTxTxIn Witness witnessSig flags txscriptStandardVerifyFlags vm err txscriptNewEnginesourcePkScriptForOutput redeemTx flags nil sigHash int satoshiAmount if err nil fmtPrintlnflag transactionerr err return err if err vmExecute err nil fmtPrintlnvm transactionerr err return err return nil The above is to spend UTXO from a segwit address to a receiving segwit address I am not sure if the issue I am having is with the implement but I keep getting Only uncompressed keys are accepted postsegwit when the code execution gets to vmExecute failing to validate the signature String returns the ban score as a humanreadable string func s DynamicBanScore String string smtxLock r fmtSprintfpersistent v transient v at v v as of now spersistent stransient slastUnix sInt smtxUnlock return r Int returns the current ban score the sum of the persistent and decaying scores This function is safe for concurrent access func s DynamicBanScore Int uint smtxLock r sinttimeNow smtxUnlock return r sInt will cause deadlock So I fixed it 