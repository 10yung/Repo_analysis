The given solution in Python throws a TypeError for the given example and IndexError for other examples A couple of suggested changes Use integer division in line Adjust k only once Something like this def kthlargestl k Shorthand Quicksort Runtime On log n kth largest element is k th element in output def qsortarr pos middle lenarr pivot arr middle smaller i for i in arr if i pivot if pos lensmaller return qsortsmaller pos equal i for i in arr if i pivot if pos lensmaller lenequal return pivot larger i for i in arr if i pivot return qsortlarger pos lensmaller lenequal return qsortl k Awesome repo but I came across the quicksort solution done here and I dont believe its the canonical solution when quicksort is typically described to be an inplace sort The implemented solution allocates new arrays in which values to the left and right are placed into their corresponding auxiliary arrays lists Ive denoted the places that I see them in the code w a comment I believe the implementation should utilize swaps wo allocating auxiliary data structures Lastly the list concatenation also incurs a linear time cost as a new listarray is allocated and all elements in each subarray must be copied over python def sortself data if lendata return data equal extra space left extra space right extra space pivotindex lendata pivotvalue data pivotindex Build the left and right partitions for item in data if item pivotvalue equalappenditem elif item pivotvalue leftappenditem else rightappenditem Recursively apply quicksort left selfsortleft right selfsortright return left equal right On where n is the size of the original input FAMOUS DP PROBLEM WITH EXPLANATION FOR BEGGINNERS Fix typo in the test case description for the mean Sum is number of elements is so the mean is The actual test case is correct I think there are some mistakes in sortstacks pseudocode and test cases description The test cases section says Empty stack None But it should be returning an empty stack not None Under the algorithm section it says While buffer is not empty or buffer top is than temp n but the code says py while not buffisempty and temp buffpeek so that should be an and not an or It also says Our buffer will hold elements in reverse sorted order smallest at the top n but the buffer stores elements in sorted order largest at the top Otherwise how could we return buffer as our answer when the output should have the largest element at the top I also suggest changing Store the current top element in a temp variable n to Pop the current top element of stack into a temp variable n This clarifies that the top element is not just copied to a temp variable but rather popped off into the temp variable Also this happens within the outer while loop not before Heres the code version of the solution for reference py class MyStackSimplifiedStack def sortself buff MyStack while not selfisempty temp selfpop while not buffisempty and temp buffpeek selfpushbuffpop buffpushtemp return buff Ive submitted pull request for this issue Here are some suggestions I have for the wording of sortstackchallengeipynb and sortstacksolutionipynb to reflect the actual code and test cases more accurately Based on the code and the test cases the output given an empty stack should be another empty stack not None Buffer stores elements in sorted order with largest element at top not reverse sorted order with smallest element at top Otherwise how could we return buffer as our answer when the output should have the largest element at the top While buffer is not empty and buffer top is than temp not or Clarify that the top element is not just copied to a temp variable but rather popped off into the temp variable This happens within the while loop not before Should I make a binder Or if there is a binder link its well hidden