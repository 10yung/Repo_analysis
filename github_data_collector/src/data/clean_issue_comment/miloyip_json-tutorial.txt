 Unicode Uniform Transformation Format UTF Unicode Unicode Transformation Format UTF MiloYip LEPTPARSEINVALIDVALUE LEPTPARSEROOTNOTSINGULAR c static int leptparsenumberleptcontext c leptvalue val int parsetype const char test cjson errno if test test if ISDIGITtest if test test if test test if ISDIGITtestreturn LEPTPARSEINVALIDVALUE while ISDIGITtesttest else if test e test E test parsetype LEPTPARSEROOTNOTSINGULAR goto out parse mostly valid text else while ISDIGITtest test if test test if ISDIGITtestreturn LEPTPARSEINVALIDVALUEnum while ISDIGITtesttest if test e test E test if test test test if ISDIGITtest parsetype LEPTPARSEROOTNOTSINGULAR goto out while ISDIGITtesttest else return LEPTPARSEINVALIDVALUE out if parsetype LEPTPARSEROOTNOTSINGULAR int len test cjson char num mallocsizeofcharlen memcpynum cjson len num len valn strtodnum NULL freenum char mod test char ch mod printfs n cjson mod valn strtodcjson NULL mod ch else valn strtodcjson NULL if errno ERANGE valn HUGEVAL valn HUGEVAL return LEPTPARSENUMBERTOOBIG cjson test valtype LEPTNUMBER return parsetype parsetype LEPTPARSEOK static void leptstringifyvalueleptcontext c const leptvalue v case LEPTNUMBER ctop sprintfleptcontextpushc g vun break ctop ctop sprintf ctop sprintf ctop leptcontextpush ctop In testc we compare the equality of two doubles simply with c define EXPECTEQDOUBLEexpect actual EXPECTEQBASEexpect actual expect actual g I dont know whether it works fine for others but it just wont work on my computer Windows with MinGWorg GCC To figure out whats wrong I did a simple test with a seperate C file c include stdioh include stdlibh int mainint argc char const argv if strtod NULL printfNOT EQUAL n else printfEQUAL n return The interesting thing happens the output of this program depends on the C standard I use to compile it If I compile it with gcc stdc gcc stdc gcc stdc or gcc stdc the output of running the executable will be NOT EQUAL If I compile it with gccno standard specified and therefore using stdgnu the output is EQUAL I dont know why this happens but I think wed better write EXPECTEQDOUBLE in a more universal way despite the difference between OS and gcc version Milo tutorial Watcher testcopy leptcopy v v line Mac Milo Assertion failed src NULL dst NULL src dst function leptcopy file UsersionizingDocumentsgithubjsontutorialdrafttutorial answerleptjsonc line leptjsonc leptcopy LEPTARRAY dstuae srcuae malloc Mac fsanitizeaddress Linux asan bytes valgrind testaccessarray if endif block leptsetstring e Hello line valgrind leptsetstring vuss charmalloclen vuss Mac Linux todo Mac macOS clang version tagsRELEASE final by homebrew Linux ArchLinux gcc version by pacman reply memcpy valgrind invalid read invalid write TIM TIM leptparsearray TIM ctrlf Project exe Win C Users jhaom source repos Project Debug Project exe Project exe Win C Windows SysWOW ntdlldll Project exe Win C Windows SysWOW kernel dll Project exe Win C Windows SysWOW KernelBasedll Project exe Win C Windows SysWOW vcruntime ddll Project exe Win C Windows SysWOW ucrtbaseddll x x HEAP Project exe Invalid address specified to RtlValidateHeap F Project exe answer bug asserttop top head ctop head answer bug bug push tutorial json strtod expect e actual e expect e actual e expect e actual e 