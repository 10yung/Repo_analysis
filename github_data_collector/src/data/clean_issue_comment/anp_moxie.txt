Since theres no badge yet linking to it markdown Cratesio Cratesio Currently all arguments have to be passed via the illicit env which has the downside of having to be static and needing to use interior mutability I want to propose a more explicitly defined interface that the mox macro consumes Some of this is based on my own local fork Im using for moxienative Everything Im talking about here is based on my own requirements for moxienative and Id like to know if any of these requirements are too strict for other implementations or if there are other ways of improving this Ill start off with suggesting that as much as possible be moved into a module named moximpl so that we dont pollute the namespace of programs and require a blob import like use moxienativeprelude Inside of this module there will be another namespace for host elements which we will distinguish from user components as Ill detail below There will also be one for attribute names and for event names API Sketch None of the types used here are literal but are just to name the return values so you can match them up to where they get plumbed into rust mod moximpl mod elements Note that this is not a macro fn elementnamehere withbuilder impl FnOncebuilder Builder Builder Node mod attributes fn attrnamehere Attribute mod events fn oneventnamehere Event The builder API has these methods on it again the types are not actual types rust trait Builder fn setattrself key Attribute value AttributeValue Self fn oneventself event Event callback impl FnMutevent Self fn setdataself key static str value DataValue Self fn addchildself child Node Self fn enterfragmentself withbuilder impl FnOncebuilder Self Self Self Changes to syntax User components need to be written in a way that lets them be differentiated from host components This is already true of components that take arguments since you have to use the element syntax Zero argument components need to be written differently from element though element would work if it didnt fail to parse Instead of element onfunc events actually have names so element onfoofunc turns into onmoximpleventsonfoo func Add a concept of data attributes not currently present which are not statically declared element datafoo datafoo Implementation Implementation here is pretty straightforward the biggest unknown is if this new scheme will be difficult for other users of mox Simple implementations can define attribute functions as just a function that returns a string but this might be more manual than desired for something like moxiedom Some implementation hints from moxienative that can come in handy here The builder trait can be implemented per element with a BuilderT generic The element functions can create an instance of this builder and pass it to the input function setattr can be implemented using a trait like this rust trait HasAttributeAttr where Attr Attribute fn setattribute mut self value AttrValue onevent can be implemented the same way using a HasEvent trait The element function and the enterfragment method are both good places to insert topo calls Examples Simple with attributes foo someattr rust moximplelementsfoobuilder builder setattrmoximplattributessomeattr User components bar usercomponent foo bar rust moximplelementsbarbuilder builder addchildusercomponent foo Events and data attributes rust button onclickfunc datafoo rust moximplelementsbuttonbuilder builder oneventmoximpleventsonclick func datafoo Children rust foo bar text children foo rust moximplelementsfoobuilder builder addchildmoximplelementsbarbuilder builder addchildtext addchildchildren Fragments rust foo fragmentchild foo rust moximplelementsfoobuilder builder enterfragmentbuilder builder addchildmoximplelementsfragmentchildbuilder builder Bare fragments Behavior here isnt super clear but adding a createfragment function to moximpl to handle this case seems flexible enough rust fragmentchild rust moximplcreatefragmentbuilder builder addchildmoximplelementsfragmentchildbuilder builder Iterators This one is tricky to support and I currently cant handle it correctly in moxienative without trait specialization I havent thought of any workarounds that dont require modifying the syntax to be like iterator or something like that Any ideas here would be nice rust foo itermapindex mox number valueindex foo rust moximplelementsfoobuilder builder addchild itermapindex moximplelementsnumberbuilder builder setattrmoximplattributesvalue index It would be nice to have a readymade breakdown of where build time is being spent in the dependency graph I think augdom is the only one right now I stumbled on the following peculiar situation When not accessing a key injected via illicitfromenv building results in a ICE The ICE goes away when any access to the key occurs moxie master nightly rust toponested illicitfromenvstate KeyState pub fn whatever UNcommenting this line removes the ICE let statefield mox p Loading p thread rustc panicked at called Resultunwrap on an Err value DistinctSourcesDistinctSources begin Realsrclibrs BytePos end Realsrcviewssomeviewrs BytePos srclibcoreresultrs stack backtrace Further to discussions on Discord With caller tracking being possibly implemented in rustc it is important to understand what this means for spawned threads and parallelism in general In the below by execution context I mean the environment associated with the callsite generated by either toposroot toposcall or toposnested This includes the toposcurrent Id Questions include What if any should the default behaviour be for the execution context in a spawned thread For instance thread with Id spawns a thread should that new thread have any particularly Id What guarantees if any should there be regarding subsequent calls to callsite tracking methods in a new thread For instance thread with Id spawns a thread if it has also by default has Id can there be any guarantee that the id of the first new callsite in that thread would be invariant over consecutive thread spawns Should there be explicit control over the above behaviour and execution context via some kind of spawn threading api if a thread is spawned and then executes a loop which in turn executes several callsite tracked methods with a revisit to each callsite intended How does one ensure that this happens Would a toporoot be sufficient to guarantee this Ie will the below be sufficent to ensure that a and b always refer to the same Id rust threadspawnmove for i in toporoot topocall let a topocurrent topocall let b topocurrent Boolean attributes should create dom nodes that either include the key or exclude it rather than always including it and setting to the Boolean value For example try using disabled on buttons Tried to update two state variables on the same button press let total state let current state elementbutton e e attrtype button on ClickEvent Some current on ClickEvent Some total inner textReset Seems like only the first one is getting updated I even swapped the order and tried again to double check haha