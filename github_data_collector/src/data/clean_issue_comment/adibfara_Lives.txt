This PR changes distinctUntilChanged to allow an initial null value The previous implementation of distinctUntilChanged used a variable kotlin var latestValue T null and a check kotlin iflatestValueit to filter out duplicates This has the problem that an initial null value emitted by the source will be implicitly dropped The new implementation uses a boolean variable to track whether the source has emitted anything In case it hasnt the initial value will be emitted The new implementation also does not keep the previous value in a separate value Rather the previous value is obtained from the returned live data This has the minor advantage that there is no need to allocate space for a separate variable to track the previous value This PR implements startWith in such a way that it can be called from any thread The previous version called kotlin finalLiveDatavalue startingValue in the thread that calls startWith This is problematic because setting the value of a LiveData can only be done from the main thread This implementation avoids that and instead creates startWith as a merge of two LiveDatas the original source and a new live data from which only a single value is taken in case the source has not emitted a value This is a bit more complicated than the original version but allows startWith to be called from any thread Unfortunately this is a breaking change in the sense that an attempt to get the value of the returned LiveData will return null because the initial value will not be set until the returned LiveData is activated Steps to reproduce If I use a nonNull operator observe the nonnull Livedata the data that is not null is emitted Pause app Resume app Data is no longer emitted My fix for this was to restart the observer onActive In doing so I could not see a usecase for the init anymore Also Is it ok to use ObserveForever in a livedata I thought that was a no no class NonNullLiveDataTprivate val liveData LiveDataT LiveDataT private val mediatorLiveData MediatorLiveDataT private val mediatorObserver ObserverT itlet thisNonNullLiveDatavalue it init mediatorLiveDataobserveForevermediatorObserver mediatorLiveDataaddSourceliveData mediatorObserver override fun onInactive superonInactive mediatorLiveDataremoveObservermediatorObserver override fun onActive superonActive mediatorLiveDataobserveForevermediatorObserver mediatorLiveDataaddSourceliveData mediatorObserver As for now null values can be posted into any LiveData Therefore the combine function in zip and combineLatest should have nullable types and should handle those values correctly Be aware that this PR is not backwards compatible and requires minor changes Library users of zipcombineLatest have to change their zipcombine functions to nullable types eg zipFunction T Y X Z changed to zipFunction X Y Z R Nullable types in PairTriple eg zipfirst LiveDataT second LiveDataY LiveDataPairT Y changed to zipfirst LiveDataX second LiveDataY LiveDataPairX Y The implementation of zip and combineLatest assume that the posted value is never null However this is not true kotlin val x MutableLiveDataInt val y MutableLiveDataInt val r zipx yobserveForever xvalue null yvalue CRASH due to null value I am preparing a PR to fix that Fixed issue where removing observer and readding much like doing a rotation change while the LiveData is inside a ViewModel Would call onInactive but keep the same instance of NonNullLiveData that would later call onActive I moved the observeForever inside onActive method 