Bumps wasmparser from to details summaryCommitssummary ul liSee full diff in a href viewali ul details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart If all status checks pass Dependabot will automatically merge this pull request dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details We can get better info about the type parameters that were monomorphized which should make it much easier to debug this stuff Therefore we should suggest building with RUSTFLAGSZsymbolmanglingversionv in the twiggy monos section and also probably the concepts monomorphizations section Bug Description Rust symbols have hashes in them Both the old symbol mangling format and the new one old format demangled weeallocallocfirstfith af b fe cb a f new format demangled core c b e df da a slicesortrecurseFoo Foo sortunstableclosure Note you can enable the new symbol format with RUSTFLAGSZsymbolmanglingversionv when building with cargo In the old format the hash is the only thing differentiating between different monomorphizations of the same generic function Therefore it might make sense to keep the hash for the old symbol format The new format has the type parameters mangled into the symbols name eg Foo in the symbol above In this case it should be fine to strip the hash all the time but perhaps with an option to disable the stripping twiggy version master Test Case rust fn mygenericT Default T Tdefault nomangle pub extern fn foo mut u mygenericusize as fn usize as mut nomangle pub extern fn bar mut u mygenerici as fn i as mut Steps to Reproduce Precise steps describing how to reproduce the issue including commands and flags run For example rustc target wasm unknownunknown cratetype cdylib C optlevel C ltofat testcasers o testcaseoldsymbolswasm rustc Zsymbolmanglingversionv target wasm unknownunknown cratetype cdylib C optlevel C ltofat testcasers o testcasenewsymbolswasm twiggy top testcaseoldsymbolswasm twiggy top testcasenewsymbolswasm Actual Behavior Function names have hashes Expected Behavior New symbols have hashes removed TBD exactly what to do with old symbols hashes The additem function is called two times with the same id In one iteration we call successively DataCountSectionsectionparseitemsitems idx and itemsaddrootirItemnewid name size added irMiscnew with the same idx value That why we have a panic in the additem function Im suppose that id is the same because sections code is also the same I didnt understand further I ran into an assertion when running twiggy top on a multithreaded wasm module attached here twiggy top raytraceparallelbgwasm thread main panicked at should not parse the same key into multiple items homealexcargoregistrysrcgithubcom ecc db ec twiggyir irrs note Run with RUSTBACKTRACE environment variable to display a backtrace raytraceparallelbgwasmgz Feature Description Maybe there is something I am missing but I try running various twiggy commands on a WASM that I know has dozens of imports and I know the code calls them when I check the wasm and I do not see textual representation of those imported function calls in the graph Maybe its because you do not map the function to its imported name Are you interested in implementing this feature Add an X to one of the following Yes Yes if I had a mentor to help me No Feature Description It would be nice if there was an interactive REPL that would allow you to quickly run a number of analyses on a program Currently the workflow for analyzing a wasm binary in depth is running a series of somewhat verbose commands ie twiggy dominators n d pathtomybinary Id love the ability to enter some sort of very basic REPL potentially offering shorter aliases to commands so that I can do something like This could potentially function as a stepping stone to Example Usage Something like this would be great twiggy interactive pathtomybinary top n Output here dominators d and so on The ability to load a different program without leaving the REPL might be a nice feature as would writing the output of a command to a file with one of our CSV JSON etc emission modes Are you interested in implementing this feature Add an X to one of the following x Yes Yes if I had a mentor to help me No Other Notes A part of me is slightly concerned that this should be implemented in another crate altogether I can already imagine that some of the tools in wabt would be great into incorporate into a REPL of this sort which makes me wonder if this is outofscope for twiggy On some level I think there might be a very similar question when eventually tackling Feedback would be greatly appreciated and this might be worth breaking apart into separate issues depending on what we believe makes sense We shouldnt require cargo install to get twiggy we should have prebuilt binaries that we distribute for releases This requires some CI configuring and all that Hi It seems to me that this tool is not capable of producing the output when the wasm file size is biggereven MB However it works well when I use a small size wasm file Do you have any plan to fix this issue and release a new version of twiggyexe Currently we have a fairly thorough test bench It would be nice however if we also had some benchmarks for the different subcommands so that we could reason about how certain changes affect performance