 Motivation When using printSchema its implementation will automatically sort all types by names While for user types scalars and their types this makes sense for very large schemas finding mutation query etc can be challenging without using find Working with that schema layout is also hard as it is usually better to have mutations and queries together I heard opinions from the community that would expect schema to be organized the same way as it was before printing was applied Print schema is often used by some CLI tools where we just want to append some specific object to the schema while operating on ast objects rather than strings Because of the lack of flexibility from reference implementation the most use cases of schema operations I have seen were still stringbased It will be amazing to see print schema being used more for those use cases How this could be done Always put queriesmutations on the bottom of printed schema This is implemented in this PR as I thought that it will be the least controversial change but it looks like it is causing failures to some tests that rely on print schema order I wanted to make sure that the community will get that behavior out of the box without using some advanced functions etc Ideally Scalars and directives could be also reorganized Allow developers to apply their own sorting function Currently the order of the types is not preserved as they are stored in type map What it means is if users organized schema to their liking in DSL and then we parsed that into object original order is lost not sure about this but this is what I see happening To be able to get some organization when printing schema separate sorting function can be applied For example first go scalars and directives Then user types alphabetical order Then Queries Mutations Subscriptions This seems to be a tradeoff This can be done by adding additional parameter and exposing printFilteredSchema for advanced use cases The Coercion functions for Scalars are currently named serialize this is result or output coercion parseValue this is runtime object input coercion parseLiteral this is Ast literal input coercion See serializeAsLiteral this takes an input value and converts it to an Ast literal I dont think the current names align very well with the spec the spec talks about Result Coercion and Input Coercion Also parseValue doesnt parse anything but convert a runtime input value to an internal value In my mental model parseValue and parseLiteral produce a internalInputValue and serializeAsLiteral converts the internalInputValue to a literal First rough idea I am sure we can do better just to start the discussion coerceOutput or coerceResult the spec talks about result coercion but output would mirror input coerceInputValue coerceInputLiteral coerceInternalValueAsLiteral In GraphQL Java we are also thinking about renaming and adding a th one and it would be great to have a discussion about a more clear naming Feature requests Would a canonicalizenode or normalizenode utility be a desirable feature I started working on one to simplify some aspects of astbased code generation though all it does right now is merge duplicate fields I dont think it should inline fragments or anything like that though maybe conditionally Maybe wed need to spec out exactly what a canonical document form would actually look like though Actually a bug fix but since its affect introspection can be a small breaking change At stdibs our GraphQL server is built on top of Apollo Server We were first introduced to the concept of the defer directive through an Apollo blog post detailing an experimental implementation We attempted to resurrect this initiative by creating an uptodate pull request in hopes of that getting merged however it became clear to us over time that support for a defer directive would occur only if it would make its way into the official GraphQL spec There has been discussion on this issue to add defer to the spec but it seems its still in its infancy Since then Relay has added support for defer and stream but there are no open source GraphQL servers that support its implementation This pull request is a proposal for a Relay compatible defer and stream directive The main distinction between the Relay implementation of defer and that of Apollos is that the defer directive is supported on a fragment spread and inline fragment instead of on an individual field Furthermore this pull request is implemented according to our understanding of Relay s support for defer and stream We outlined a few examples here This is a feature we are very passionate about at stdibs and would be interested in working with contributors in any way possible Sketch RFC Hello to all this PR allows to support the defer directive Although the implementation is mostly complete the PR is in draft to discuss it together and evaluate its integration In the PR I also created tests and I performed the integration tests with Relay expressgraphql fetchmultipartgraphql with positive results In summary how I implemented defer defer has two arguments if optional default true the fragment is defer when true label required used to distinguish deferred fragments defer currently provides only FRAGMENTSPREAD INLINEFRAGMENT Relay as location but support for FIELD Apollo is commented in the PR I added resolverResult ResultResolver new property in ExecutionContext which allows the management of the results to be returned at the end of the execution modified execute function now its return type is AsyncIterablePromiseExecutionResult PromiseOrValueExecutionResult Using isAsyncIterable result it is possible to distinguish if there are deferred results fields that are marked as deferred are resolved after the resolution of the previous result I also implemented an optimization to avoid solving the same field multiple times this is a slow motion gif of how it works deferred Let me know if more information is needed Thank you Lorenzo We have some Node specific code in our codebase and it works fine but we cant fallback mechanism For example we use ErrorcaptureStackTrace if available but its always available in Node so we never tested this code Hi IvanGoncharov I just wanted to check in on the roadmap to v I missed the last WG meeting so perhaps this was discussed and I just didnt see it on the notes I know that previously we had discussed releasing quickly last month or so with the existing breaking changes and then releasing v with the TypeScript rewrite in early to corresponding with the next cut of the spec Is this still the game plan There are several pieces sitting in master such as intermediate interfaces that could provide immediate value If were waiting on any other pieces let me know and I can try to get some time over the next couple weeks to work on them