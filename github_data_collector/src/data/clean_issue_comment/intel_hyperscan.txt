Add aarch platform branch which is fully compatible with armv a and at the same time ensure that the use of x platform is not affected The modification can be divided into the following aspects CMakeListstxt add branches to judge x and aaarch platforms simdarmh Use the neon instruction to implement operation functions simdx h Save the original simdutilsh file contents simdutilsh Select different header files simdx h or simdarmh according to the platform judgment results Intrinsic function There are multiple calls to the intrinsic function in the code and the intrinsic function is encapsulated in the modification controlverbscpp ExpressionParsercpp controlverbscpp Parsercpp There are errors in generating these four files under the aarch platform So the files are generated on the x platform and copied to the corresponding directory for use Does not affect the functionality of the x platform On the basis of support the aarch platform we also carried out a large performance optimization The optimization effect also improved the performance of hyperscan on the x platform The currently submitted PR is a successful migration version and we expect to submit a performance version later There seems to be an error in dbcheckplatform function When database is compiled on machine with AVX but without AVX database platform features bitmask equals to HSPLATFORMNOAVX As this is equal to hscurrentplatformnoavx constant such a database passes dbcheckplatform check on any machine including ones without AVX support Pull request fixes this error If I were to change the scratch size in allocscratch in scratchc and compile the library would it have any impact on performance As mentioned in the introduction video of Hyperscan Hyperscan has been integrated into open source projects What are these open source projects Hope to get an answer thank you very much Is freespacing support in the roadmap per chance hscompilelitmulti crashes in strlen when compiled with clang and ASAN on hyperscan Unless Im mistaken hscompilelitmulti can take arbitrary byte arrays which can have a zero byte in the middle or not have any zero bytes at all So it seems like it should use expLength instead of strlen in addLitExpression Minimal repro void strlencrashvoid uint t buf a b c d const char const exprs char buf sizet exprlens unsigned int flags HSFLAGSOMLEFTMOST unsigned int ids struct hsdatabase hsdb NULL hserrort hsrc hscompileerrort hserr NULL hsrc hscompilelitmultiexprs flags ids exprlens HSMODESTREAM HSMODESOMHORIZONSMALL NULL hsdb hserr asserthsrc HSSUCCESS ERROR AddressSanitizer stackbufferoverflow on address x ffcc at pc x fd f bp x ffcc f sp x ffcc e READ of size at x ffcc thread T x fd e in interceptorstrlen vartmpportagesyslibscompilerrtsanitizers workcompilerrt srclibasansanitizercommonsanitizercommoninterceptor sinc x f ed d dc in ue addLitExpressionue NG unsigned int char const unsigned int hsexprext const unsigned int unsigned long usrlib libhsso x dc x f ed cb c in ue hscompilelitmultiintchar const const unsigned int const unsigned int const hsexprext const const unsigned long const unsigned int unsigned int hsplatforminfo const hsdatabase hscompileerror ue Grey const usrlib libhsso x c x f ed cc in hscompilelitmulti usrlib libhsso x x f ea in strlencrash redacted x f ea in redacted x f c e in runtestfromfiles redacted x f a in main redacted x f ece de a in libcstartmain lib libcso x e a x c in start redacted Address x ffcc is located in stack of thread T at offset in frame x f f in redacted This frame has objects streami line scratchi line hserri line bufi line Memory access at offset overflows this variable exprsi line exprlensi line flagsi line idsi line hsdbi line hserri line HINT this may be a false positive if your program uses some custom stack unwind mechanism swapcontext or vfork longjmp and C exceptions are supported SUMMARY AddressSanitizer stackbufferoverflow vartmpportagesyslibscompilerrtsanitizers workcompilerrt srclibasansanitizercommonsanitizercommoni terceptorsinc in interceptorstrlen Shadow bytes around the buggy address x a c x a d x a e x a f x a f f f f f f f f f f f f f f f f x a f f f f f f f f f f x a f f f f f x a x a x a x a Shadow byte legend one shadow byte represents application bytes Addressable Partially addressable Heap left redzone fa Freed heap region fd Stack left redzone f Stack mid redzone f Stack right redzone f Stack after return f Stack use after scope f Global redzone f Global init order f Poisoned by user f Container overflow fc Array cookie ac Intra object redzone bb ASan internal fe Left alloca redzone ca Right alloca redzone cb Shadow gap cc ABORTING void addLitExpressionNG ng unsigned index const char expression unsigned flags const hsexprext ext ReportID id sizet expLength if strlenexpression ccgreylimitPatternLength throw CompileErrorPattern length exceeds limit Would Hyperscan patch for Snort work for I have successfully applied the patch on but its gonna be obsolete by new year and there is no patch available for This is a proposition to add two fuzz targets to be used with libfuzzer or other tools especially for continuous fuzzing such as ossfuzz cf What do you think of it Hi there According the hyperscan website hyperscan follows the regular expression syntax of the PCRE library The regex N rocks is causing an error in rspamd which is using hyperscan The regex N rocks is PCRE compliant according to several check in documentation Match any single character that is NOT a line break character line feed N Match the character literally Match the character string rocks literally case sensitive rocks But I still get the following error with that RE cannot create tree of regexp when processing N rocks N at index not supported Can anyone help with getting the proper syntax for this RE Thanks in advance Hi hyperscan team Im an newbee for hyperscan project Im so excited to have a conversation with you We have a plan to make hyperscan to support ARM function And we will propose a series of PRs to make this happen including hardware platform logical judgement code ARM NEON instruction set support and etc We wont propose intrusive changes to existing code Now the detailed design are still uncertain just a draft Hope community can take part in the detailed feature design at the beginning But before the whole work begins we want to know community attitude about this We hope the kind feedback from your side Thanks very much