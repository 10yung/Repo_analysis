I found this issue porting from to When I run my parser test it get stuck in an infinite loop ie it never terminate This is the reduced test case rust extern crate peg pegparsergrammar p for str pub rule stringliteral String s printlnliteral s stoowned fn main let r pstringliteral literal if let Okl r printlnParsed l else printlnParse failed r Expected either it doesnt compile because its a syntax error ie Im doing the rule wrong with the update syntax or it is a parse error Instead it just get stuck when I cargo run I think it might be a nice addition maybe as a Crate Feature to have some basic defaults such as for matching alphanumerics newlines etc use pegpresetrules at the top of a grammar and have access to a set of primitives so to speak Essentially a very crude and unassuming design for how you might choose to implement The essential stuff grammars can share rules which marks them pubcrate but doesnt produce the wrapper api Since templates are inlined they cant be shared grammars can import other grammars which opens up their shared rules to be used under that grammar name with the syntax grammarnamerulename grammars can import with a converter which is a piece of Rust code which is the arguments to the second grammar written in terms of the arguments of the first if any Rules are actually accessed by assuming that the imported grammars code lives in a module of the same name under the parent module if either of these things are not true you get a cryptic compile error subgrammar types are converted tofrom at need but are not yet persisted by the parent grammar ie a new ParseState is created at each boundary etc This isnt meant to be the final design cache persistence of subgrammars would be good for example and a better buildtime system of catching errors such as by sharing a Compiler maybe but I would appreciate any feedback about how this aligns with what you imagined and what couldshould be improved Hi Id like to stop parsing the string input when a given pattern is matched Ill give example for SMTP helo abc mail frommeexamplecom rcpt tohimexamplecom data The desire is that I could parse all the commands until including the data command There is no point parsing further as there may be binary data there You could add a quit instruction to terminate further processing pub cmddata SmtpCommand datai NL quit SmtpCommandData FYI the full SMTP grammar on github Btw thanks a lot for PEG Rustpeg generates code causing warnings during compilation if repetition count range starts with explicit Given Rustpeg code pub foo Vec a There is a warning during compilation about useless if statement The generated code mind last line fn parsefooinputinput input str state mut ParseStateinput pos usize RuleResultVec allownonsnakecase unused let mut repeatpos pos let mut repeatvalue vec loop let pos repeatpos if repeatvaluelen break let stepres sliceeqinput state pos a match stepres Matchednewpos value repeatpos newpos repeatvaluepushvalue Failed break if repeatvaluelen Matchedrepeatpos repeatvalue else Failed Pointless check causes warnings Other than that the rule works fine This version works exactly same but doesnt cause warning pub bar Vec a I love having features pegtrace but I found it was difficult to read through so ive wrapped the output with a little script that handles indenting to make it easier to understand Then i started thinking it would be event better if I visualized the parser output in one of a couple ways either a collapsable tree or simply through something like graphviz To make this process somewhat straightforward Id like to add support for dumping the peg trace as structured JSON to a file Thoughts Assume I define a few parsers within a module and export the parsing functions similar like the following rust pub use selfparserempty as empty peg parserr pub empty Im wondering if it is possible to reuse the exporter parser in another module in another PEG macro call In general Im interested in reusing parsers defined in different source files Any ideas 