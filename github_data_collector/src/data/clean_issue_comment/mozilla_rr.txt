I think I encountered an unknown ioctl FATAL homephilippinstallrrsrcrecordsyscallcc recprocesssyscallarch task rec at time Assertion tregssyscallresultsigned syscallstateexpecterrno failed to hold Expected EINVAL for ioctl but got result errno SUCCESS Unknown ioctl x c a type x nr x a dir x size addr x ffe Tail of trace dump realtime globaltime eventSYSCALL ioctl stateEXITINGSYSCALL tid ticks rax x rbx x rcx xffffffffffffffff rdx x ffe d rsi x rdi x rbp x fffa rsp x ffe r x ffe r x r x r x r x ffe e r x ffe e c r x r x rip x eflags x cs x ss x b ds x es x fs x gs x origrax x fsbase x f c ab ac gsbase x tid addr x ffe d length x c realtime globaltime eventPATCHSYSCALL tid ticks rax x rbx x rcx xffffffffffffffff rdx x rsi x ffe e rdi xffffff c rbp x ffe e rsp x ffe cd r x ffe f r x a fce r x r x r x r x ffe e c r x r x rip x f c ad fe eflags x cs x ss x b ds x es x fs x gs x origrax xffffffffffffffff fsbase x f c ab ac gsbase x tid addr x f c b f c length x f tid addr x f c ad fe length x tid addr x f c ad fe e length x Complete log This happens when I try to debug a proprietary software which means I cant share the source But maybe this is easy to add if not Is there anything I can do to add support for this myself Or should I try to create a minimal example Even though we now pin counters tests show that multiplexing is still happening NEW Fixes the original commit to use tmpattr properly for the case of INTXCP This reverts commit e cf b abcbba b df f f a Our use case A host is running linux perf now and then to get machine stats in parallel to rr Without this detection rr silently succeeds I get the following when trying to replay a recording of Firefox on Ubuntu FATAL buildrrStwazjrr srcReplaySessioncc checkticksconsistency task rec at time Assertion ticksnow traceticks failed to hold ticks mismatch for SYSCALL munmap expected got Start rr backtrace rrZN rr dumprrstackEv x x cc ebb rrZN rr GdbServer emergencydebugEPNS TaskE x x cc debdd rrZN rr EmergencyDebugOstreamD Ev x x cc dfbe rrZN rr ReplaySession checkticksconsistencyEPNS ReplayTaskERKNS EventE xaa x cc e f a rrZN rr ReplaySession replaystepERKNS StepConstraintsE x e x cc e bf e rrZN rr ReplayTimeline replaystepforwardENS RunCommandEl xce x cc e de rrZN rr GdbServer servereplayERKNS ConnectionFlagsE x x cc deec rr x c a x cc e a rrZN rr ReplayCommand runERSt vectorINSt cxx basicstringIcSt chartraitsIcESaIcEEESaIS EE x x cc e rrmain x x cc da libx linuxgnulibcso libcstartmain xeb x f f bfb b rrstart x a x cc da aaa End rr backtrace Launch gdb with gdb l ex set sysroot ex target extendedremote homejrmuizelrrfirefox mmaphardlink firefox On Ubuntu with rr I get rr snap run gnomecalculator rr Saving execution to trace directory homejrmuizelrrsnap FATAL buildrrStwazjrr srcAutoRemoteSyscallscc checksyscallresult task rec at time Assertion false failed to hold Syscall mmap failed with errno EACCES Start rr backtrace rrZN rr dumprrstackEv x x c c rrZN rr GdbServer emergencydebugEPNS TaskE x x c f dd rrZN rr EmergencyDebugOstreamD Ev x x c e rrZN rr AutoRemoteSyscalls checksyscallresultEli x x c c e rrZN rr AutoRemoteSyscalls infalliblemmapsyscallENS remoteptrIvEEmiiim x x c c d rrZN rr AddressSpace maprrpageERNS AutoRemoteSyscallsE x x c b b rrZN rr AddressSpace postexecsyscallEPNS TaskE x b x c ba db rrZN rr Task postexecsyscallEv x x c a rr xdfd x c d rr xf b x c b rrZN rr recprocesssyscallEPNS RecordTaskE x x c d rrZN rr RecordSession syscallstatechangedEPNS RecordTaskEPNS StepStateE xcf x c rrZN rr RecordSession recordstepEv x c x c c d rrZN rr RecordCommand runERSt vectorINSt cxx basicstringIcSt chartraitsIcESaIcEEESaIS EE x f x c f rrmain x x c b libx linuxgnulibcso libcstartmain xeb x f ec ab b rrstart x a x c b aaa End rr backtrace Launch gdb with gdb l ex set sysroot ex target extendedremote snapsnapd usrlibsnapdsnapconfine It would be great if rr could be used to debug Firefox for Android or other Android applications Since Android can run on an x device or emulator hopefully this is easier to do than supporting ARM cc jrmuizel ifNOT COMPILER BITRESULT EQUAL messageFATALERROR Your toolchain doesnt support bit crosscompilation Install the required packages or pass Ddisable bitON to cmake endif while excute CMake rr appears errors bellow CMake Error at CMakeListstxt message Your toolchain doesnt support bit crosscompilation Install the required packages or pass Ddisable bitON to cmake how can i solve this i would like to either set up github actions myself on this repo or have one of hte current collaborators do it it should start with the requirements and go from the up An assertion failure takes place on a debian VM running on i U when replaying a trace of code that is seemingly waiting on a subprocess to finish The relevant output from rr replay FATAL homerocrrrrsrcTaskcc writebyteshelper task rec at time Assertion nwritten bufsize failed to hold Should have written bytes to x f b ccf but only wrote Start rr backtrace rrZN rr dumprrstackEv x x faa rrZN rr GdbServer emergencydebugEPNS TaskE x x c e rrZN rr EmergencyDebugOstreamD Ev xd x a rrZN rr Task writebyteshelperENS remoteptrIvEElPKvPbj x x rrZN rr ReplayTask setdatafromtraceEv x x f rrZN rr ReplaySession emulatesignaldeliveryEPNS ReplayTaskEi xd x bdc rrZN rr ReplaySession tryonetracestepEPNS ReplayTaskERKNS StepConstraintsE x x e rrZN rr ReplaySession replaystepERKNS StepConstraintsE xe x a rrZN rr ReplayTimeline replaystepforwardENS RunCommandEl xc x rrZN rr GdbServer debugonestepERNS GdbRequestE xe x b rrZN rr GdbServer servereplayERKNS ConnectionFlagsE x c x c c rr x e rrZN rr ReplayCommand runERSt vectorISsSaISsEE x cb x d b rrmain x x libx linuxgnulibcso libcstartmain xf x f ac b e rr x ef End rr backtrace Backtrace of rr from GDB x in x f bf f b ba in rawsyscall at homerocrrrrsrcpreloadrawsyscallS x f bf f cd in tracedrawsyscall callcallentry x f b ccf fa at homerocrrrrsrcpreloadsyscallbufc x f bf f a in syscallhookinternal call x f b ccf fa at homerocrrrrsrcpreloadsyscallbufc syscallhook call x f b ccf fa at homerocrrrrsrcpreloadsyscallbufc x f bf f b a in syscallhooktrampoline at homerocrrrrsrcpreloadsyscallhookS x f bf f b a in morestack at homerocrrrrsrcpreloadsyscallhookS x f bf f b in syscallhooktrampoline d f ffff at homerocrrrrsrcpreloadsyscallhookS x f bf b in waitid idtypePPID id infop x f b bf options at sysdepsunixsysvlinuxwaitidc x cedb d in sharedchildsyssyswaitwithoutreapingh d fc a d handle at homeecargoregistrysrcgithubcom ecc db ec sharedchild srcsysunixrs x ced ca in sharedchildSharedChildwaithbacca a self x f b at homeecargoregistrysrcgithubcom ecc db ec sharedchild srclibrs x ce ab in ductChildHandlewaith c b e e self x f b modeductWaitModeBlocking at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ce b a in ductHandleInnerwaith ec ebc self x f b modeductWaitModeBlocking at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ce bd in ductHandleInnerwaith ec ebc self x f b bf modeductWaitModeBlocking at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ce b in ductHandlewaith cf bb e cc self x f b bf at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ce b a in ductHandleoutputh c b d a self at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ce bba in ductExpressionrunhd a adf e e self x f b bf at homeecargoregistrysrcgithubcom ecc db ec duct srclibrs x ca c in talpidcorepingmonitorimpinternalpingh ac a f ip timeoutsecs interface exitonfirstreplytrue at talpidcoresrcpingmonitorunixrs x ca bb in talpidcorepingmonitorimppingh c e ip timeoutsecs interface at talpidcoresrcpingmonitorunixrs x c in talpidcoretunnelwireguardWireguardTunnelstartu bu bclosureu du dh b c cd at talpidcoresrctunnelwireguardmodrs x ca in stdsyscommonbacktracerustbeginshortbacktraceh e adee f at rustc d e ac f c b a c cedac b a d a srclibstdsyscommonbacktracers x ca in stdthreadBuilderspawnuncheckedu bu bclosureu du du bu bclosureu du dh cbbe at rustc d e ac f c b a c cedac b a d a srclibstdthreadmodrs x c a in LTstdpanicAssertUnwindSafeLTFGTu asu coreopsfunctionFnOnceLTLPRPGTGTcallonceh e d ef cb self args at rustc d e ac f c b a c cedac b a d a srclibstdpanicrs x caaa e in stdpanickingtrydocallhf f ca b data x f b bf f at rustc d e ac f c b a c cedac b a d a srclibstdpanickingrs x da a a in rustmaybecatchpanic at srclibpanicunwindlibrs x caa in stdpanickingtryh c bb aafbd f at rustc d e ac f c b a c cedac b a d a srclibstdpanickingrs x c b in stdpaniccatchunwindh cdec d e b f at rustc d e ac f c b a c cedac b a d a srclibstdpanicrs x ca d in stdthreadBuilderspawnuncheckedu bu bclosureu du dhd cc ad at rustc d e ac f c b a c cedac b a d a srclibstdthreadmodrs x c c in coreopsfunctionFnOncecallonceu bu bvtableshimu du dh c d bc at rustc d e ac f c b a c cedac b a d a srclibcoreopsfunctionrs x da f ff in LTallocboxedBoxLTFGTu asu coreopsfunctionFnOnceLTAGTGTcalloncehcc de eb d at rustc d e ac f c b a c cedac b a d a srcliballocboxedrs x da c in LTallocboxedBoxLTFGTu asu coreopsfunctionFnOnceLTAGTGTcallonceh fb f a at rustc d e ac f c b a c cedac b a d a srcliballocboxedrs stdsyscommonthreadstartthreadh d d a d at srclibstdsyscommonthreadrs stdsysunixthreadThreadnewthreadstarth c e e ae e at srclibstdsysunixthreadrs x f bf b a in startthread arg x f b bfa at pthreadcreatec x f bf e d f in clone at sysdepsunixsysvlinuxx cloneS Could the differences between Ubuntu and Debian be the cause of this Pretty much any debug workflow with rr comes down to rewinding the record back and forth in attempts to narrow the section where a problem or maybe just interesting piece of code manifests itself However when either the record is big or the part of code gets executed many times in irrelevant places narrowing down that section is timeconsuming so one might desire to save the progress If one could truncate the record to start later than the actual start was or finish earlier than the actual end was this would help one to save just the interesting section of code with the problem so one could explore it without having to spend time on narrowing the section down again Similarly to and I can hit this reliably running llvmllvmproject clang master but unfortunately Im going away for a few weeks now Ive run out of time but trying to put as much information here as I can Notably gdb has a problem with what Im doing too Im invoking the clang frontend and trying to put a breakpoint on clangExecuteCompilerInvocation then single step into it LLVMClang is built with DBUILDSHAREDLIBS DLLVMUSESPLITDWARFOn CMAKEEXELINKERFLAGSSTRINGWlgdbindex fuseldlld Interestingly gdb also crashes if I try to step through this call The call itself shows up as clangExecuteCompilerInvocationplt during the breakpoint If I get time Ill try and add more information but no promises I hope there is something useful in what I have written above