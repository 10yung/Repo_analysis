 Refactor to use jvmTarget from to Remove buildToolsVersion to use by default Refactor compile to implementation Refactor provided to compileOnly Modify targetSdk and compileSdk version from to Change kotlinstdlibjre to kotlinstdlibjdk Fix jacoco version to to support gradle above Update gradle tools to Update kotlin plugin version to Update gradle wrapper to Fix inputoutput in the documentation were written on the wrong parameter I have updated Gradle wrapper version to And Gradle version to And Kotlin version to I receive two Kotlin compiler error error no interface expected here public class ViewModelFactory extends androidarchlifecycleViewModelProviderFactory error Binds methods must have only one parameter whose type is assignable to the return type public abstract androidarchlifecycleViewModelProviderFactory bindViewModelFactoryorgjetbrainsannotationsNotNull Full question can be found at Could you help to resolve errors I am a new learner and I am having a hard time trying to figure of the data flow happening in the presentation layer A little more explanation would help a beginner greatly When trying to encapsulate some behavior in a View instead of an Activity or a Fragment I do not have access to the ViewModelProvider What would be the mot appropriate way of having the same architecture when using Views I can see at least options Pass the ViewModelProvider as an argument to the View constructor Pass the already obtained ViewModel as an argument to the View constructor Pass a LifecycleOwner as an argument to the View constructor Hold the ViewModel in the containing FragmentActivity and expose events from the view and consume states Trying run in Emulator Nexus with Android x orgbufferandroidboilerplateui EAndroidRuntime FATAL EXCEPTION main Process orgbufferandroidboilerplateui PID javalangRuntimeException Unable to get provider androidarchlifecycleProcessLifecycleOwnerInitializer javalangClassNotFoundException Didnt find class androidarchlifecycleProcessLifecycleOwnerInitializer on path DexPathList zip file dataapporgbufferandroidboilerplateui apk nativeLibraryDirectories dataappliborgbufferandroidboilerplateui vendorlib systemlib at androidappActivityThreadinstallProviderActivityThreadjava at androidappActivityThreadinstallContentProvidersActivityThreadjava at androidappActivityThreadhandleBindApplicationActivityThreadjava at androidappActivityThreadaccess ActivityThreadjava at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNativeNative Method at javalangreflectMethodinvokeMethodjava at comandroidinternalosZygoteInitMethodAndArgsCallerrunZygoteInitjava at comandroidinternalosZygoteInitmainZygoteInitjava at dalviksystemNativeStartmainNative Method Caused by javalangClassNotFoundException Didnt find class androidarchlifecycleProcessLifecycleOwnerInitializer on path DexPathList zip file dataapporgbufferandroidboilerplateui apk nativeLibraryDirectories dataappliborgbufferandroidboilerplateui vendorlib systemlib at dalviksystemBaseDexClassLoaderfindClassBaseDexClassLoaderjava at javalangClassLoaderloadClassClassLoaderjava at javalangClassLoaderloadClassClassLoaderjava at androidappActivityThreadinstallProviderActivityThreadjava at androidappActivityThreadinstallContentProvidersActivityThreadjava at androidappActivityThreadhandleBindApplicationActivityThreadjava at androidappActivityThreadaccess ActivityThreadjava at androidappActivityThreadHhandleMessageActivityThreadjava at androidosHandlerdispatchMessageHandlerjava at androidosLooperloopLooperjava at androidappActivityThreadmainActivityThreadjava at javalangreflectMethodinvokeNativeNative Method at javalangreflectMethodinvokeMethodjava at comandroidinternalosZygoteInitMethodAndArgsCallerrunZygoteInitjava at comandroidinternalosZygoteInitmainZygoteInitjava at dalviksystemNativeStartmainNative Method I was just working on a similar architecture when I ran into this boilerplate So far I think its great and it completes a lot of the thoughts and inner dilemmas I was having One particular problem I keep running into comes down to what the responsibility of the ViewModel is As in here the architecture component ViewModel presentation layer is responsible for receiving Ui events and return Ui states On the other hand models from other layers get mapped to another kind of ViewModel UI layer which is only a representation of the data to be displayed BrowsBuferoosViewModel BuferooViewModel In my project Im using databinding and so I bind the UI layer ViewModel to list item layouts for example In the case of the whole screen I bind the activityfragment instead of the presentation layer ViewModel But I know a colleague binds the layout directly to the presentation layer ViewModel and might have a RecyclerView adapter directly in the VM Would you agree with me that the two kinds of ViewModel I mention are different Or do you consider them the same If they are different shouldnt we find a better naming for one of them