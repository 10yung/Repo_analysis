Im rendering several PINAnimatedImageView in a UIScrollView As the user scrolls it sets isPlaybackPaused to true when shown on screen and false when off screen Overall I really like this library The performance of my app is meaningfully better than the other two libraries I integrated before this There are three UX issues that Id like to report When PINAnimatedImageView is initially paused it does not display the cover image Whenhow is the cover image displayed Ive noticed that whenever isPlaybackPaused is set to true before the image loads the coverImage is never displayed so the user sees an empty UIView and its sad Expected behavior Even while paused render the cover image once the image loads Pausing playback makes the PINAnimatedImageView display nothing Currently when isPlaybackPaused is false the PINAnimatedImageView displays nothing If theres any delay between pausing and unpausing such as the JS bridge when using this library in a React Native app there are brief moments of black nothingness where the most recently played frame is supposed to go Expected behavior Display the last image rendered before the animation was paused maybe not setting frameImage to nil would work I spent a couple of hours investigating this today I think the image frame is being released here isPlaybackPaused stops instead of pauses stopAnimating which isPlaybackPaused calls causes the PINCachedAnimatedImage to start over from the first frame the next time startAnimating is called This appears to be a deliberate implementation detail Is resume a thing other people care about too or is it just me Its quite likely that and are the same issue Apologies if this already exists but I couldnt find a reference anywhere in the docs and Im unclear as to the order of ops when it comes to loading cached items vs the placeholder images As far as Im aware calling the following swift imageViewpinsetImage from siteimage placeholderImage UIImagenamed Custom Placeholder will cause the library to load the placeholder image and attempt to make a network call If the call succeeds it will use that item otherwise it falls back to the cache Is there any way to configure the PINRemoteImageManager or the PINCache to always check the cache first and load any image found there before going to the network This would greatly reduce the number of times that my placeholder image is shown I can reach into the cache myself but I figure Id check if its natively supported before doing so we estimate the size of one hundred x images as our max memory image cache pt x pt You have to multiply the scale by both width and height The idea behind this optimization was to reduce the number of calls the display link would need for animated images which didnt draw every frame But this has resulted in frames being dropped in certain cases where frameInterval isnt respected see Since the the display link fire method continues if we detect were at the same image index as before lets just remove this optimization Hi They could review the possibility of adding Packageswift manifest to support Swift Package Manager swifttoolsversion The swifttoolsversion declares the minimum version of Swift required to build this package import PackageDescription let package Package name PINRemoteImage products Products define the executables and libraries produced by a package and make them visible to other packages library name PINRemoteImager targets PINRemoteImage dependencies Dependencies declare other packages that this package depends on packageurl package url from targets Targets are the basic building blocks of a package A target can define a module or a test suite Targets can depend on other targets in this package and on products in packages which this package depends on target name PINRemoteImage dependencies path Source its likely theyll have to wrap some of their code in if canImportUIKit import UIKit extension UIImage endif Talked in we can use map to find the task instead may more efficient and readability x Add Changelog x Add test case Currently our frame index search algorithm time complexity for a GIF is ON we can burst it to ONlogN the time saving is distinct for the example url like below old algorithm needs ms but new algorithm only need ms Saving time for main thread test code for int i i animatedImageframeCount i self frameIndexAtPlayHeadPositiondurations i Old s New s The reason I make this PR is I have a requirement to pause the playback of gif before scroll and resume the next frame after scroll stopped to improve the scrolling performance I already make an issue to describe please see I have the requirement to improve the scroll performance when collection view has many GIFs thus pause the playback in scrolling state and resume after scroll finished By setting runloop mode to default mode other than common mode For example a gif has frames frame interval ms collection view not scrolled now its playing th frame and scroll started after scroll finished maybe s passed it started to resume and even s passed it still need to play th frame But in our implementation currently we use absolute timeCACurrentMediaTime to calculate which frame we should play leads to frame skip Another simple example if a gifs loop count is play only once frames frame interval ms after it played th frame scroll started keep runloop mode to default s after that gif would not resume any more because elapsed time already exceed total duration of gif garrettmoon Any reason why we choose absolute time to calculate frame index seems all other third frameworks like YYImageFLAnimatedImage use CADisplayLinkduration