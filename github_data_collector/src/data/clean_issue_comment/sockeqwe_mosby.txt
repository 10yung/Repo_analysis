This fix is based on similar code fragments in this repository as described below Unfortunately Mosby V is not compatable with AndroidX as accessing the backstack to see if a fragment is still in use or presenter can be released is not possible anymore in androidx as the method to get this information is blacklisted and no accessible from the outside anymore it was in supportv days see Any workaround suggested in seems to me fragile Therefore I considering the following What we actually need is a lifecycle callback that tells us when the Fragment is actually destroyed We could get this information by using AndroidX ViewModelonCleared This will not be breaking change rather its a minor implementation detail under the hood What do you think FragmentManagertoString occurs NPE when mHost is null since androidxfragmentfragment beta javalangNullPointerException Attempt to invoke virtual method javalangClass javalangObjectgetClass on a null object reference at androidxfragmentappFragmentManagertoStringFragmentManagerjava at javalangStringvalueOfStringjava at javalangStringBuilderappendStringBuilderjava at androidxfragmentappFragmentdumpFragmentjava at androidxcoreappBackstackAccessorisInBackStackAndroidXBackstackAccessorjava at androidxcoreappBackstackAccessorisFragmentOnBackStackBackstackAccessorjava at comhannesdorfmannmosby mvpdelegateFragmentMvpDelegateImplretainPresenterInstanceFragmentMvpDelegateImpljava at comhannesdorfmannmosby mvpdelegateFragmentMvpDelegateImplonDestroyFragmentMvpDelegateImpljava at comhannesdorfmannmosby mvpMvpFragmentonDestroyMvpFragmentjava So this PR uses reflection instead of Fragmentdump Need help to solve this error javalangIllegalAccessError Method boolean androidxfragmentappFragmentisInBackStack is inaccessible to class androidxcoreappBackstackAccessor I read on release to use BackstackAccessorisFragmentOnBackStackFragment where should I use this line of code Hi I faced with some issue and would be very appriciate if you could help with it I use gradle comhannesdorfmannmosby viewstate This is my Activity class kotlin class MainActivity BaseViewStateActivityMainActivityView MainActivityPresenter MainViewState MainActivityView override fun onCreatesavedInstanceState Bundle superonCreatesavedInstanceState setContentViewRlayoutactivitymain override fun onPostCreatesavedInstanceState Bundle superonPostCreatesavedInstanceState override fun onNewViewStateInstance presenternextPage override fun createPresenter MainActivityPresenter MainActivityPresenter override fun createViewState MainViewState MainViewState and ViewState kotlin class MainViewState RestorableViewStateMainActivityView private val keyState MainViewStateKEY var data ArrayList override fun saveInstanceStateout Bundle outputStringkeyState override fun restoreInstanceStateargs Bundle RestorableViewStateMainActivityView var savedString argsgetStringkeyState return this override fun applyview MainActivityView retained Boolean safeLetview data v data vupdateRecycleViewdata The problem is that restoreInstanceState is never called Could you please explain me the logic in The first time an Activity is started restoreInstanceState is not called because the bundle is null java if bundle null viewState instanceof RestorableViewState RestorableViewState restoredViewState RestorableViewState viewStaterestoreInstanceStatebundle but after rotate the screen the method does not call as the program stops at line where return is called java if mosbyViewId null VS viewState PresenterManagergetViewStateactivity mosbyViewId if viewState null ViewState restored from PresenterManager setViewStateviewState true true if DEBUG LogdDEBUGTAG ViewState reused from Mosby internal cache for view delegateCallbackgetMvpView viewState viewState return why is return called thank you in advance Regards Hi this is just a feature request that will make code a bit cleaner and easier to write lets say we have ifViewAttached val message itgetStringFromIdRstringsomeid showErrormessage This will become val message ifViewAttached itgetStringFromIdRstringsomeid showErrormessage here ifViewAttached returned the value returned by function getStringFromId This works very similar to let function in Kotlin Steps to reproduce bug Create view which is inherited from for example MvpFrameLayout Add view to any ViewGroup Remove from the ViewGroup detachView and destroy methods from MvpPresenter will be called Add view again to ViewGroup Remove view from ViewGroup detachView and destroy methods from MvpPresenter not will be called Allow mosby to support view without activity Reference ticket Alternatively we can just remove the Exception when there is no activity and switch automatically to Windowmode for ViewGroup base DelegateCallback But I guess if we add this feature we would like it to be enforced and managed So the user will need to implement public boolean isViewOnActivity It basically switch to a mod where it does not expect to save a state nor detach a view without destroying From a user perspective a CustomView can be use alternatively by a Activity or a Window directly an easy way to support that would be to implement public boolean isViewOnActivity return PresenterManagergetActivitydelegateCallbackgetContext null Mosby Version SNAPSHOT just upgraded from Expected behavior View should load its content after reusing retained fragment Actual behavior include a stacktrace if crash It does not Hello Im not sure if this is a bug report or a question When i build and install my apk while devices screen is off since my retained fragment creates its viewState calls presenterloadData BUT it is detached before viewsetDatashowContent is called Then when i turn screen on Im stuck on loading state so Id expect it to reload data but applyViewState true applyViewStateFromMemory true so when onViewStateInstanceRestored is called with instanceStateRetainedInMemory true nothing happens Is this a bug If you could confirm it I can start working on solution but Im not sure if I understand problem correctly Thanks Override public void onViewStateInstanceRestoredboolean instanceStateRetainedInMemory if instanceStateRetainedInMemory viewStateisLoadingState loadDataviewStateisPullToRefreshLoadingState Edit Ive just tried to use QueueingPresenter but after long migration it seems like it changes my apps behavior ViewPagers losing index after rotation etc Currently as a hotfix I need to fork to repair BackStackAccessor but maybe you could suggest me a better solution Id be really grateful Edit Ive successfully recreated all needed functionality and will stick to QueuingPresenter for now