I have a C function Im defining like this void thefuncconst stdstring arg const stdfunctionvoidconst stdstring cbarg const stdstring cbarg callbackresult mdefthefunc thefunc Rdoc pyargarg pyargcallbackresult python is calling thefunc into C and then C is calling callbackresult into python Now when the callback arrives in python Id like it to be called with kwargs rather than positional args or atleast have a way to know the name of the argument via inspect Is that possible Hello Just suggesting a small change in the documentation In section Combining virtual functions and inheritance the bindings with trampoline class dont mention the inheritance to parent class It may be straightforward for some people but as a beginner it threw me off for a bit I suggest showing the bindings as they would look in a complete example Issue description When attempting to call the function of an inherited class virtual or otherwise the program immediately terminates with a segfault The problem persists even when switching the parent class around leaving the problem only to be within the binding or the base class However the base class behaves appropriately when constructed by itself therefore I believe something is going wrong during the binding process I have tested this on the latest master commit e ccb db b d f f on both Windows and macOS Catalina Reproducible example code Project link The issue centres around two particular classes both of which can be compiled outside of the project no internalexternal dependencies srccppeventeventemitterh and srccppeventeventh eventh is required by eventemitterh which is the problem file srccpprendercontainerh and srccpprendercontainercpp are examples of inheritance where the generated bindings cause a segfault bindings can be found at the bottom of containerh C Inheritance containerh class Container public virtual EventEmitter containercpp c pyclassContainer EventEmittercontainer Container Constructors defpyinit Functions variables defdestroy ContainerDestroy defsetactive ContainerSetActive defaddchild ContainerAddChild defremovechild ContainerRemoveChild defreadwriteactive Containeractive eventemittercpp c pyclassEventEmittereventemitter EventEmitter Constructors defpyinit Functions variables defon EventEmitterOn defoff EventEmitterOff defonce EventEmitterOnce defaddlistener EventEmitterAddListener defremovelistener EventEmitterRemoveListener defremovealllisteners EventEmitterRemoveAllListeners defemit EventEmitterEmit defemitnow EventEmitterEmitNow Example Python Calls python Prints first argument given def testargs printargs Works as expected selfemitter EventEmitter selfemitterontest test selfemitteremitnowtest hello world Crashes with segfault selfcont Container selfcontontest test selfcontemitnowtest hello world Issue description When trying to return a pylist or PyObject that is a list Im getting a seg fault on Windows This code works on Linux and MacOS On Windows Im using MSVC and Python The other functions that return vector of ints or other values are working fine This only manifests when creating a list of pyobjects I even tried using the native Python C API implementation which ran into the same issue The logic works with SWIG Im porting that code over to pybind My apologies if this is a naive error or trivial mistake I am making Reproducible example code I modified it a little bit for simplicity Lets say pyoutputs is a stdvectorPyObject Im getting that output from an API which I cannot modify pylist result for int i i pyoutputssize i resultappendpycastpyobjectpyoutputs i return result PyObject result PyListNewpyoutputssize if result nullptr PyErrSetStringPyExcMemoryError Failed to create a list throw pyerroralreadyset for int i i pyoutputssize i PyListSETITEMresult i pyoutputsati return pyreinterpretstealpyobjectresult Output Log on Windows Windows fatal exception access violation Received signal BEGIN STACK TRACE POINTERS END STACK TRACE POINTERS x FFA E B CurrentStackTrace x FFA DE F testingInstallStacktraceHandler x FFA CEECFA sehfilterexe x CB D unknown x FFA EE C Cspecifichandler x FFA F chkstk x FFA BEF RtlWalkFrameChain x FFA EE KiUserExceptionDispatcher x FFA F C lambda f d c fba aa d ba operator x FFA F A lambda eba c f d c baoperator x FFA F AD lambda eba c f d c balambdainvokercdecl x FFA F pybind cppfunctiondispatcher x BCE PyCFunctionFastCallDict x PyObjectGetAttr x B E PyEvalEvalFrameDefault x E PyObjectGetAttr x B E PyEvalEvalFrameDefault x PyObjectFree x DF PyCompileOpcodeStackEffect x D B PyObjectIsSubclass x PyEvalEvalFrameDefault x PyObjectFree x PyObjectGetAttr x B E PyEvalEvalFrameDefault x PyObjectFree x PyObjectGetAttr x B E PyEvalEvalFrameDefault x E PyObjectGetAttr x B E PyEvalEvalFrameDefault x PyObjectFree x C PyFunctionFastCallDict x A PyObjectClearWeakRefs x D B PyObjectIsSubclass x PyEvalEvalFrameDefault x PyObjectFree x PyObjectGetAttr x A PyEvalEvalFrameDefault x PyObjectFree x DF PyCompileOpcodeStackEffect x D B PyObjectIsSubclass x PyEvalEvalFrameDefault x PyObjectFree x PyObjectGetAttr x B E PyEvalEvalFrameDefault x PyObjectFree x C PyFunctionFastCallDict x A PyObjectClearWeakRefs x D B PyObjectIsSubclass x PyEvalEvalFrameDefault x PyObjectFree x C PyFunctionFastCallDict x A PyObjectClearWeakRefs x F C PyObjectCall x FB PyUnicodeEqualToASCIIId x A PyObjectGetAttr x B E PyEvalEvalFrameDefault x PyObjectFree x C PyFunctionFastCallDict x A PyObjectClearWeakRefs x D B PyObjectIsSubclass x PyEvalEvalFrameDefault x PyObjectFree x C PyFunctionFastCallDict x A PyObjectClearWeakRefs Calling a method on a class instance works if constructed as below pyobject ret methodcallinstancesomefunctionargument I wonder if there is a constructor variant or other mechanism to make this syntactically sweeter such as shown below this call format passes the instance self as a hidden argument pyobjectinstance ret methodcallsomefunctionargument Just asking MTIA Full snippet of the existing test load the echo module pyobject echomodule pymoduleimportechotest find the Echo class pyobject echo echomoduleattrEcho this calls echoinit if echocall find the integer version in python defechoiargint None pyobject echoi echoattrechoi in this example echo is the self argument which works as expected pyobject ret echoicallecho with the Python module thus class Echo def initself printEchoinit def echoiselfargint None printechoi gotarg Hello everyone First thank you everyone for this great tool Issue description Current system Windows MinGW conda installed on windows python version the one in conda cmake installed on windows compiler MSVC After PR was merged our building pipelines on windows started failing The output message error is fatal error LNK cannot open input file python lib After tracking the problem I found out that PYTHONLIBRARY in file toolsFindPythonLibsNewcmake was not set to the correct path Before PR PYTHONLIBRARY CUsersuserAnaconda libspython lib After PR PYTHONLIBRARY python lib Debugging each step of the previous file resulted that PYTHONLIBDIR is empty After the patch it tries to look in a Linux location for the library PYTHONLIBRARY is set to python lib I found a solution changing some lines in toolsFindPythonLibsNewcmake without changing the behaviour for Linux or Mac I would like to know if youll be interested for a PR if yes the only thing is I dont have many more windows system to test on it To I dont know if other Windows user with their build system could test Or maybe do you have any other suggestion that could help us of course Reproducible example code windows system install mingw install conda for windows import a C project using cmake for building process and of course pybind In the CmakeListstxt file we use addsubdirectory to indicate where the folder of pybind is located Expected error fatal error LNK cannot open input file python lib Let me know if you have any questionssuggestion Cheers Juli n Using include pybind chronoh we can define py defpyinit const stdchronosystemclocktimepoint obj so that we can convert between stdchrono and pythons datetime Is there a similar concept for conversions between stdchrono and numpys datetime I had a look at pybind numpyh but couldnt find anything I am happy implement it and submit a PR if someone could point me in the right direction for how to do it Many thanks Issue description When converting a sequencelike argument to an stdvectorT pybind ignores exceptions raised by lenarg and erroneously calls stdvectorTreserve with a very large value The result is a confusing exception of the following form Traceback most recent call last File pybind repropy line in module mymodulefa ValueError vectorreserve Reproducible example code C code include pybind pybind h include pybind stlh include vector namespace py pybind using namespace pyliterals namespace mymodule void fconst stdvectorint end namespace mymodule PYBIND MODULEmymodule m mdeff mymodulef This C code was compiled with g Wall shared stdc fPIC o mymodulepython config extensionsuffix python config ldflags pybind reprocpp Ipybind include dir Iusrlocalincludepython Python code import numpy import mymodule mymodulef Okay a numpyarray mymodulefa raises ValueError vectorreserve I used a zerodimensional numpy array to demonstrate this problem but it actually occurs with any object that is sequencelike has getitem and raises from len class BadLen def getitemself i return i def lenself raise Exception mymodulefBadLen raises ValueError vectorreserve Result and expected result When running the Python code above a C exception is thrown by stdvectorintreserve pybind propagates this to the Python caller but this is confusing and does not indicate why the operation failed Traceback most recent call last File pybind repropy line in module mymodulefa ValueError vectorreserve This exception occurred because lena in the example above raises a Python exception see Diagnosis section below lena Traceback most recent call last File pybind repropy line in module lena TypeError len of unsized object I think that pybind should propagate this original Python exception to the caller instead of triggering an unrelated exception at a later point in time Diagnosis This occurs through the following steps pybind sequencesize calls PySequenceSizemptr which returns a signed Pyssizet value The pybind member function unconditionally casts this value to sizet If PySequenceSize returns indicating failure pybind sequencesize will return SIZEMAX a very large positive number class sequence public object public PYBIND OBJECTDEFAULTsequence object PySequenceCheck sizet size const return sizet PySequenceSizemptr The return value of size is passed to vectorTreserve The reserve member function can throw stdlengtherror or stdbadalloc if the requested size is too large template typename Type typename Value struct listcaster private template typename T Type enableiftstdissamedecltypestddeclvalTreserve voidvalue int void reservemaybesequence s Type valuereservessize I think this problem could be fixed by checking the return value of PySequenceSize and raising the active CPython exception if that call has failed as indicated by its return value Issue description I have a base pureabstract interface that is extended by another pure abstract interface Then i have an implementation of the base interface and a implementation of the extended interface that derives the extended interface and the base implementation via virtual inheritance diamond Now if i return a reference of type InterfaceExtened i can correctly use it If i however delete the object that is being referenced on the c side then i get an error during program exit I do not get such an error when doing the same using InterfaceBase This happens on both windows and linux Fedora on release Reproducible example code pybind bugcpp cpp include pybind pybind h include memory include iostream class InterfaceBase public virtual InterfaceBase default virtual void foo class InterfaceExtended public virtual InterfaceBase public virtual InterfaceExtended default virtual void bar class ImplementationBase public virtual InterfaceBase public virtual void foo stdcout foo stdendl class ImplementationExtended public ImplementationBase public InterfaceExtended public virtual void bar stdcout bar stdendl class Helper public InterfaceBase createBaseInstance instanceBaseresetnew ImplementationBase return instanceBase void deletebaseInstance instanceBasereset InterfaceExtended createExtendedInstance instanceExtresetnew ImplementationExtended return instanceExt void deleteBaseInstance instanceBasereset void deleteExtendedInstance instanceExtreset private stduniqueptrInterfaceBase instanceBase stduniqueptrInterfaceExtended instanceExt namespace py pybind PYBIND MODULEexample m pyclassInterfaceBasem InterfaceBase deffoo InterfaceBasefoo pyclassInterfaceExtended InterfaceBasem InterfaceExtended pymultipleinheritance defbar InterfaceExtendedbar pyclassHelperm Helper defpyinit defcreatebaseinstance HelpercreateBaseInstance pyreturnvaluepolicyreference defcreateextendedinstance HelpercreateExtendedInstance pyreturnvaluepolicyreference defdeletebaseinstance HelperdeleteBaseInstance defdeleteextendedinstance HelperdeleteExtendedInstance I compile with bash c O Wall shared stdc fPIC python m pybind includes pybind bugcpp o examplepython config extensionsuffix Then i run python import example helper exampleHelper base helpercreatebaseinstance ext helpercreateextendedinstance extfoo extbar deleting a returnvaluepolicyreference on c side for the base nonvirtual inheritance class is fine helperdeletebaseinstance deleting a returnvaluepolicyreference on c side for the extended virtual inheritance class generates a segfault on cleanup when commenting out the next line there is no segfault helperdeleteextendedinstance The Condaforge package is reporting the wrong directory From local testing the standard way of accessing the directory seems to be working correctly its just the injected special logic that is causing issues Is the virtualenv logic needed or could it be removed as well Testing this in Condaforge before making the PR nondraft