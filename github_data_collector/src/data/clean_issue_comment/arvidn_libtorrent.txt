This is a fairly significant change to how listen sockets and outgoing sockets are assigned to network interfaces and source IP addresses The commits all represent mostly independent changes all having the effect that Trackers are only announced from a source IP address where it makes sense eg only if the tracker is running on loopback does it make sense to announce to it from a socket bound to loopback SOCKS UDP tunnels are only set up for listen sockets where it makes sense same logic as for trackers the UDP sockets dedicated for outgoing packets have been removed and folded into the listen sockets for UDP This simplifies things a bit and possibly improves reachability throught NATs when listening on multiple IPv sockets will be opened one for each local IPv address however they will all be restricted to be used for their respective subnet Like the example with the tracker above a socket listening to loopback will only be used for destinations over loopback IPv addresses were already treated this way but not IPv I think this will improve SOCKS support mainly in that only a single UDP tunnel will be opened in the common case But if you have both IPv and IPv connectivity for instance and the SOCKS tunnel resolves to both IPv and IPv two tunnels will be opened This is to take full advantage of all network paths Theres some more discussion on this topic in this ticket Trons BTT cryptocurrency has the potential to reduce leeching and cheating improve fairness and help some make extra money Is it a good standard or good for LT Will it benefit some or most users Will it be hard to add to LT Whitepaper Please provide the following information libtorrent version or branch platformarchitecture compiler and compiler version please describe what symptom you see what you would expect to see instead and how to reproduce it Let s say I have torrents with the same SSL tracker and I just started my client Libtorrent makes asynchronous announces for all of those torrents Now my question is does libtorrent use the same sessionhandshake to perform all these announces Does it take advantage of cached sessions Or it tries to do asynchronous ssl handshakes to the same server Asking this cause it seems like libtorrent is kinda slow when it comes to announcing to SSL trackers Maybe this requires some optimisation pass the whole listensockett object to asyncaccept and onacceptconnection instead of just the acceptor socket Many define are printed out by the command b toolsetmsvc debugbuilding Which is used in vs There is define for compiling every file Compiling samples in vs needs the same define as compiling libtorrent How do you confirm Here is my define for torrent at compile time but in the examples the compilation fails defineBOOSTALLNOLIB defineBOOSTASIOENABLECANCELIO defineBOOSTASIOHASSTDCHRONO defineBOOSTMULTIINDEXDISABLESERIALIZATION defineBOOSTNODEPRECATED defineBOOSTSYSTEMNODEPRECATED defineBOOSTSYSTEMSOURCE defineTORRENTBUILDINGLIBRARY defineTORRENTBUILDINGSHARED defineTORRENTUSEI P defineWIN defineWIN LEANANDMEAN defineCRTSECURENODEPRECATE defineFILEOFFSETBITS defineSCLSECURENODEPRECATE defineWIN defineWIN WINNT x defineUSEW SOCKETS This is my appempt to build Python bindings and provide them as PyPI package Note that it currently doesnt work It closes and This should be done in multiple parts I will try to do all of them but I will probably need some help x Add more details to PyPI package name description readme classifiers keywords license Make building script setuppy that uses Extension by distutilssetuptools instead of bjam and is compatible with PyPI and easy to use Add CI scripts that build and release package Also installation process should be easy both for users which use wheels and users which dont use them Installing with wheels which should be provided for Windows Linux and macOS and for supported Python versions should be normal as with any other Python package Installing without wheels would be a bit more compilated but should be still easy to do Users would need to download and install Boost and set up a few environment variables Then they would just need to run setuppy which would build and install libtorrent and Python bindings When building on CI the root setuppy should be run with python setuppy pypi sdist bdistwheel This would Copy bindingspythonsetuppypipy to bindingspythonsetuppy Copy few project details to bindings folder Copy libtorrent to bindings folder Package bindings source code as well as package details and libtorrent code to sdist Build bindings and libtorrent and package to wheel The reason for copying libtorrent into bindings folder is to make distrubution and instllation of sdist easier which will make instllation easier for users which cant use wheels When users without wheels would want to install package process would be similar but without copying things because they would already been copyied and distributed so they would just need building I managed to build Python bindings with Extension but they dont work The problem is that binaries arent actually linked to libtorrent so they wont work import libtorrent Traceback most recent call last File stdin line in module ImportError usrlocallibpython sitepackageslibtorrent py linuxx egglibtorrentcpython x linuxgnuso undefined symbol ZTIN libtorrent torrentalertE To fix this libtorrent need to be prebuilt into a file However I dont know how to implement this in setuppy in a way that it would be easy to use I also havent tested this yet on Windows but it probably fails because of similar problem We need to collect traits of illegal clients for building a better antileeching algorithm as dicussed in So far I have noticed that progress reported from leechers would be stuck at even after receiving gigabytes of data from me libtorrent version or branch RC Currently if one has multiple network interfaces and listens on which is done by default That address is expanded to all IPv addresses the machine has One reason for having multiple IPv addresses is by running a VPN where theres a tun device with an IPv address assigned to it The current logic opens a listen socket for both the VPN interface and the underlying direct interface I dont think this is intuitive behavior Its explained in the code with this comment To comply with BEP multi homed clients must run separate DHT nodes on each interface they use to talk to the DHT For IPv this is enforced by prohibiting creating a listen socket on Instead the list of interfaces is enumerated and sockets are created for each of them This is not enforced for because multi homed IPv configurations are much less common and the presence of NAT means that we cannot automatically determine which interfaces should have DHT nodes started on them This is why its not done with the IPv counterpart My first thought of making this more intuitive was to only expand it to the single main IPv interface To find the main interface find the first entry in the routing table with as the destination remember the associated device name find the first IP address in the interfaces list associated with this device and whose gateway is specified If no entry in the routing table can be found ignore the entry in the listeninterfaces setting This same algorithm could be used to treat the unspecified IPv address the same as well The idea is that in the presumably rare case of having a machine actually hooked up to two or more internet connections one would have to explicitly add both to the listeninterfaces setting After having implemented this behavior though it occurred to me that it really seems that the behavior Im looking for is to preserve the unspecified listen addresses and let the OS figure it out The question in that scenario is what to do about the DHT nodes Perhaps the DHT node could be made to allow the unspecified IPv address but use the algorithm above to find its concrete IP In either case I should also add a section in the documentation talking about multihomed support and explain this logic in detail to make it clear how it works ssiloti Im hoping you have some thoughts or opinions on this Im not sure what the best solution is but I really hope it involves reducing complexity Please provide the following information libtorrent version or branch platformarchitecture OpenBSDamd compiler and compiler version clang please describe what symptom you see what you would expect to see instead and how to reproduce it I have patches to get testwebseedhttp and testurlseed unit tests to pass unit test report on OpenBSD In libtorrentrasterbar two types of HTTP seeding are supported URL seed implements BEP and HTTP seed implements BEP HTTP seeding is when a HTTP server assists in the seeding Sources testurlseed tries to run urlseedsslkeepalive urlseedssl urlseedkeepalive urlseed urlseedkeepaliverename testurlseed manages to run urlseedsslkeepalive correctly and then once it gets to urlseedssl which does not use keepalive it silently returns I found that it quits at sendheaderConnection close patchtestwebserverpy fixes url seed tests as explained in the diff This allows the testurlseed test to pass but I am very unsure of this patch What does keepalive do Does my patch defeat the purpose of the test Index patchespatchtestwebserverpy RCS file patchespatchtestwebserverpy diff N patchespatchtestwebserverpy devnull Jan patchespatchtestwebserverpy Dec OpenBSD Needed for testurlseed because tests without keepalive urlseedssl and urlseed quit at sendheaderConnection close causing the unit test to fail Index testwebserverpy testwebserverpyorig testwebserverpy class httphandlerBaseHTTPRequestHandler ssendheaderContentLength endrange startrange if filenameendswithgz ssendheaderContentEncoding gzip if not keepalive ssendheaderConnection close if not usessl srequestshutdownsocketSHUTRD sendheaders testwebseedhttp tests fail patchtesthttppy fixes these by making the socket timeout by the default None This makes it blocking I feel more confident about this patch Index patchespatchtesthttppy RCS file patchespatchtesthttppy diff N patchespatchtesthttppy devnull Jan patchespatchtesthttppy Dec OpenBSD Needed for testwebseedhttp and testwebseedhttppw to pass socket has socsettimeoutNone by default Index testhttppy testhttppyorig testhttppy def startserverhostlocalhost port IPv Fal else soctype socketAFINET soc socketsocketsoctype socsettimeout printPROXY Serving on sd host port debug printpython version s sysversioninfostr socbindhost port 