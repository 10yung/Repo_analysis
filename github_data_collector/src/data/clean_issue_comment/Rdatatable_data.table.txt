Closes This bug is really a bug in Microsoft Excel but manifests as a bug in fread This bug is related to Issues Summary of Issue When saving a CSV as a mactype in MS Excel Office from a Windows PC Excel creates a file that has r after every line EXCEPT the final line which ends as r n fread then interprets each line as a separate column Minimal reproducible example You may be able to skip many of these file creation stepstaking a wellformed csv or xls file and saving it as mactype csv is the most critical step Create the following in a notepad application and save as inputcsv Col Col data data data Open inputcsv in Excel usedbut likely applies to other versions FileSave AsSave as type Excel Workbook xlsxintermedxlsx Close Excel Open intermedxlsx in Excel FileSave AsSave as type CSV Macintosh csvfinalcsv Close Excel In R freadfinalcsv data atatable rows and cols Col Col fredTfreadfinalcsvheaderT dimfredT fredF freadfinalcsvheaderF dimfredF fredF V V V V V Col Col r data r data r data Output of sessionInfo sessioninfoplatforminfo setting value version R version os Windows x system x mingw ui RStudio language EN collate EnglishUnited States ctype EnglishUnited States tz AmericaLosAngeles date packageVersiondatatable as discussed with mattdowle recently on slack Referring to the recursive implementation in and It appears that there might a regression introduced since that time late MWE DT datatablern X CHECK X shiftX fill L prev L DT Y s X prev prev X s rn output rn X CHECK Y It seems like expressions in j are not evaluated in sequence If we use prev copyX then it will work as before Closes Maybe not a perfect solution but it gets the job done Probably fair to say people arent nesting SD further than levels down follow up of ready to merge side effect of this PR in rdevel cran linux build we no longer check pdf manual we still do it in rrelease build Closes Note the intentional break vs base for the stated reason x asdatatabletableirisSpecies this implementation rbindx asdatatabletableNULL V N setosa versicolor virginica base implementation rbindx asdataframetableNULL Error in rbindlistl usenames fill idcol Item has columns inconsistent with item which has columns To fill missing columns use fillTRUE asdatatabletableNULL Error in function sorted TRUE unique FALSE attempt to set an attribute on NULL with full traceback function sorted TRUE unique FALSE l list if isFALSEgetOptiondatatableCJnames TRUE if isnullvnames namesl vnames paste V seqlenlengthl else if anytt vnames vnames tt paste V whichtt else vnames namedotsvnames if anytt vnames vnames tt paste V whichtt dups FALSE for i in seqalongl y l i if lengthy next if sorted if isatomicy stopsorted is TRUE but element i is nonatomic which cant be sorted try setting sorted FALSE o fordervy retGrp TRUE thisdups attro maxgrpn exact TRUE L if thisdups dups TRUE if lengtho l i if unique y o attro starts exact TRUE else y o else if unique l i y attro starts exact TRUE else if lengtho l i y o else if unique l i uniquey nrow prodvapply il length if nrow Machineintegermax stopgettextfCross product of elements provided to CJ would result in f rows which exceeds Machineintegermax d nrow Machineintegermax domain Rdatatable l CallCcj l setDTl l setalloccoll setnamesl vnames if sorted if dups setattrl sorted namesl else setkeyl l V NULL sorted FALSE docallCJ cval sorted FALSE datatabledocallCJ cval sorted FALSE N asvectorx key key asdatatabletabletableNULL asdatatabletableNULL Probably we should return datatableNULL here Use case edge case of a code that was returning proper tables the rest of the time I am on my last step of my R session where I got a huge datatable object to be passed on to my clients in CSV format The clients only need several columns of my datatable object But I am running tight on RAM and couldnt afford to create another R object I also cant delete the unnecessary variable as the other client need it Currently my implementation is setseed dt datatable a rnorm e b runif e c sampleletters e T fwritedt fwritedt ac data requested by the first client fwritedt bc data requested by the second client From my inspection and understanding the second and the third fwrite will create a throwaway object that requires additional RAM Is it possible to have select argument for fwrite that doesnt require such temporary object Something like fwritedtselectcac Output of sessionInfo R version Platform x w mingw x bit Running under Windows x build Matrix products default locale LCCOLLATEEnglishSingapore LCCTYPEEnglishSingapore LCMONETARYEnglishSingapore LCNUMERICC LCTIMEEnglishSingapore attached base packages stats graphics grDevices utils datasets methods base other attached packages datatable loaded via a namespace and not attached compiler tools curl When setDT is called on a list there are a series of sanity checks eg the check for homogenous column length l listA B setDTl Error in setDTl All elements in argument x to setDT must be of same length but the profile of input lengths lengthfrequency is The first entry with fewer than entries is However this check is not triggered if we set the class to datatable or dataframe beforehand l listA B classl datatable setDTl l A B int num strl Classes datatable and dataframe obs of variables A int B num attr internalselfrefexternalptr Only the check for multicolumn columns Eg matrix columns is triggered before the check isdatatablex which then simply fixes the key names and internal reference Instead it would be better to proceed with the list sanity checks even when the input has class datatable or dataframe To avoid these checks when a user mistakenly calls setDT on an existing valid datatable we could simply return if selfrefokx L