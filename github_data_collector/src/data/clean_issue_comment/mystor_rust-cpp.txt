C allows the use of selfreferential structures by convention Rust does not Using cppclass to wrap a class that is not trivially relocatable is unsafe because Rust might move the object and break internal references Unfortunately this precludes the use of cppclass for most of the standard library Rust now supports the concept of pinning or preventing an object from being movedrelocated in memory With the pinning API it is now possible to do featureoptinbuiltintraits cppclasspub unsafe struct CppString as stdstring impl Unpin for CppString requires optinbuiltintraits impl CppString pub fn newbox stdpinPinstdboxedBoxCppString allocate memory let mut memory stdboxedBoxpinstdmemMaybeUninitCppStringuninit get address of allocated memory let address mut CppString unsafe memoryasmutgetuncheckedmut asmutptr use placement new to construct a new string at the address cppunsafe address as void new address stdstringcstringptr unwrap the MaybeUninit unsafe stdmemtransmutestdpinPinstdboxedBoxstdmemMaybeUninitCppString stdpinPinstdboxedBoxCppStringmemory The only problem is Rust does not know that struct CppString is not relocatable and will happily move it out of the Pin We must tell Rust that CppString is not Unpin which is achieved in the example above using the nightly feature impl Unpin for CppString Unfortunately this means the above code doesnt compile with stable Rust It is possible to achieve the same effect with stable Rust using the marker type PhantonPinned which implements Unpin and thereby makes any structure containing it also Unpin This would conceptually be used to make a structure MyStruct implement Unpin like this Of note the presence of phantom types does not increase the size of the structure affect is alignment or have any performance drawbacks struct MyStruct mydata i or whatever type we want phantompinned stdmarkerPhantomPinned It would seem that to do this for C classes would require modification of the cppclass macro I confess I have yet to learn much macro programming and had some trouble following all the macrorules and downstream parsing functions for the cppclass macro so I do apologize that this is not a pull request Some ways this could possibly look Option cppclasspub unsafe Unpin struct CppString as stdstring Option struct CppString cppclassdatapub unsafe struct CppString as stdstring phantompinned stdmarkerPhantomPinned Option Automatically detect if C class is relocatable Im building tflite and I got this error error procmacro derive panicked rustcargoregistrysrcgithubcom ecc db ec tflite srcinterpreterbuilderrs cpp handle as InterpreterBuilder delete handle help message rustcpp fatal error Struct metadata not present in target library file NOTE Doublecheck that the version of cppbuild and cppmacros match note this warning originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info error aborting due to previous error Ive included the generated files Im using g gcc cc and c versions on a fedora docker image Interestingly enough this doesnt happen in the travis ci builds which is also on x unknownlinuxgnu or if I cross compile for aarch unknownlinuxgnu using the linaro toolchain rustcpptargz Ill look into working on this tomorrow but its a bit annoying that the whole crate is rebuilt when I run cargo run having not changed anything In theory this would just be a case of Walker detecting include macro calls in its Folder implementation Initially it could be limited to handling includes of the form rust includeconcatenvOUTDIR pathtosourcefilers The main benefit of this is so that files generated from build scripts can contain macros like cpp Im also relying on cppsynmap for embedjs so this would be of use for the js and includejs macros as well Im noticing that of my errors are type errors during calling cpp macro Handle struct Wrap ptr libccvoid pub fn testwrap mut Wrap cpp wrap as Wrap wraptest This compiles but segfaults Correct way is Handle struct Wrap ptr libccvoid pub fn testwrap mut Wrap let wrapptr wrapptr cpp wrapptr as Wrap wrapptrtest My code is littered with ptr variables and other casting It might be nice to have following syntax Handle struct Wrap ptr libccvoid pub fn testwrap mut Wrap cpp wrapptr as libccvoid as Wrap wraptest Thus avoiding temporary variables and making code more type safe if we type by accident wrap libccvoid it will cause type error Note that mutability should still work only with slightly different syntax let y i let mut z i let x i cpp y as int t mut z as int t i as int t z return y z If the C code captured throws an exception it might be nice to have an option for rustcpp to add an exception handler which translates the exception into a rust panic This would have overhead so we may not want it to be the default The readme says that it is not possible to embed the cpp macro in other macros What is needed to make this possible