Add a dockercompose test that spins up postgres and cockroach servers for differential testing Run some sqlsmith on them and verify the output is identical Has already found a few incorrectness bugs The test framework is written in such a way that although a single query is generated per run each connection can have different mutations which shouldnt change the output applied In addition two cockroach servers are started so that they can be configured differently to ensure output doesnt change when say theres different vectorized settings theres no tests yet that do this but the framework is here for them to be added The cmpconn package has been changed to remove its go routines and test rowbyrow instead of fetching all of the rows This is because there was a bug that sometimes messed up the order of the rows It is possibly slower due to not using multiple goroutines for comparison but I have not seen any false positives since this change TODO This PR is a WIP and should not be merged until the following issues are fixed I have run out of time to do this so am leaving this PR and note here so that others can finalize the work if they desire The test is currently written as acceptance but thats just because it needs docker to run Its not really an acceptance test though since it doesnt test for a specific thing It should just run for X minutes per night like the RSG tests but it also needs docker I think we could add like a new pkgcompose directory to dump these kinds of dockercompose nightly tests Or maybe theres some other good way to do this but Im not aware of something that does what we need here that we already have Previously all projecting operators those that append columns were not allowed to shortcircuit ie to exit from Next method when they receive a zerolength batch The problem is that the planning code assigns each operator an output index for the columns and operators would only append a column if the width of the batch they receive equals to their assigned output index In case some projecting operator shortcircuits and doesnt append a column the downstream operator would also not append its output column which would lead to an internal error The problem is solved by allowing operators to append as many unknown zerolength columns until the batch becomes of the desired width and then appending their output column Now all projecting operators track the status of whether the column was appended In a case when a projecting operator that previously shortcircuited wants to add a column but the width of the batch is higher than the operators output index meaning that an unknown column was added in that place that unknown zerolength column is replaced with the fullsized column of the desired type All this logic is placed into the Allocator This behavior allows us to have shortcircuiting logic inplace but also reduces the amount of allocated memory if a projecting operator actually never outputs anything Additionally coldataZeroBatch is now implemented by a special wrapper around coldataMemBatch that prohibits modifications of the zero batch This was prompted by a bug with merge joiner in which we relied on the width of the zero batch to decide whether to unwrap a vector Release note None roachtestsqlsmithsetupemptysettingnomutations failed on master b b c a ef bc d ca f WITH with col AS SELECT FROM VALUES e x bejSTRING eEgf tSTRING AS tab col with col AS SELECT FROM VALUES ARRAY INT ARRAY INT ARRAY INT INT NULL AS tab col with col AS SELECT FROM VALUES OID OID OID OID OID AS tab col SELECT cteref col AS col WITH with col AS SELECT FROM VALUES TIME TIME TIME currenttimeTIMETIME AS tab col SELECT tab col AS col FROM VALUES tab col AS tab col with AS cteref LIMIT INT AS col cteref col AS col FROM with AS cteref with AS cteref VALUES B B NULL B B B AS tab col ORDER BY cteref col ASC LIMIT INT detailssummaryReprosummaryp Artifacts sqlsmithsetupemptysettingnomutations roachdash subpowered by pkgcmdinternalissues if there was a test failure already we dont want to muck with the test cluster because it may be unavailable at that point Its better to fail directly with the first error and start collecting artifacts than run into a hard timeout of the test runner and not be able to collect anything when collecting th artifacts collect the zip after everything else Only the zip is subject to deadlock Everything else can be collected earlier and in a timely fashion Release note None Consider the following test case sql CREATE TABLE t c STRING UNIQUE INSERT INTO t c VALUES a SELECT FROM t WHERE c LIKE a unexpected row is fetched Unexpectedly the query fetches a row When removing the UNIQUE constraint no row is fetched That the predicate should evaluate to FALSE is also demonstrated by the following query sql SELECT c LIKE a FROM t FALSE I built CockroachDB from source commit c e b a e ceaaf b a e b on Ubuntu When dealing with customer issues it is frequently useful to know which release contains a certain PR You can do it manually each time but it is a bit tedious It would be awesome if we had a script that periodically adds a tag or comment to merged PRs with the earliest released version that contains the commits in the PR This issue was autofiled by Sentry It represents a crash or reported error on a live cluster with telemetry enabled Sentry link Panic message errorserrorString safedetailswithSafeDetails unexpected error from the vectorized runtime v errorgo withstackwithStack assertwithAssertionFailure check the extra data payloads details summaryStacktrace expand for inline code snippetssummary in pkgsqlcolexecexecerrorCatchVectorizedRuntimeErrorfunc usrlocalgosrcruntimepanicgoL L in runtimegopanic in pkgsqlcolexecexecerrorVectorizedInternalPanic in pkgsqlcolflowcolrpcInboxNextfunc usrlocalgosrcruntimepanicgoL L in runtimegopanic in pkgsqlcolexecexecerrorVectorizedInternalPanic in pkgsqlcolflowcolrpcInboxNext in pkgsqlcolexecOrderedSynchronizerNext in pkgsqlcolexecfnOpNext in pkgsqlcolexecsortedDistinctBytesOpNext in pkgsqlcolexecsortedDistinctInt OpNext in pkgsqlcolexecboolVecToSelOpNext in pkgsqlcolexecMaterializernext in pkgsqlcolexecMaterializernextAdapter in pkgsqlcolexecexecerrorCatchVectorizedRuntimeError in pkgsqlcolexecMaterializerNext in pkgsqlexecinfraRun in pkgsqlexecinfraProcessorBaseRun in pkgsqlflowinfraFlowBaseRun in pkgsqlDistSQLPlannerRun in pkgsqlDistSQLPlannerPlanAndRun in pkgsqlconnExecutorexecWithDistSQLEngine in pkgsqlconnExecutordispatchToExecutionEngine in pkgsqlconnExecutorexecStmtInOpenState in pkgsqlconnExecutorexecStmt in pkgsqlconnExecutorexecCmd in pkgsqlconnExecutorrun in pkgsqlServerServeConn in pkgsqlpgwireconnprocessCommandsAsyncfunc usrlocalgosrcruntimeasmamd sL L in runtimegoexit details pkgsqlcolexecexecerrorerrorgo in pkgsqlcolexecexecerrorCatchVectorizedRuntimeErrorfunc at line usrlocalgosrcruntimepanicgo in runtimegopanic at line pkgsqlcolexecexecerrorerrorgo in pkgsqlcolexecexecerrorVectorizedInternalPanic at line pkgsqlcolflowcolrpcinboxgo in pkgsqlcolflowcolrpcInboxNextfunc at line usrlocalgosrcruntimepanicgo in runtimegopanic at line pkgsqlcolexecexecerrorerrorgo in pkgsqlcolexecexecerrorVectorizedInternalPanic at line pkgsqlcolflowcolrpcinboxgo in pkgsqlcolflowcolrpcInboxNext at line pkgsqlcolexecorderedsynchronizergo in pkgsqlcolexecOrderedSynchronizerNext at line pkgsqlcolexecfnopgo in pkgsqlcolexecfnOpNext at line pkgsqlcolexecdistincteggo in pkgsqlcolexecsortedDistinctBytesOpNext at line pkgsqlcolexecdistincteggo in pkgsqlcolexecsortedDistinctInt OpNext at line pkgsqlcolexecboolvectoselgo in pkgsqlcolexecboolVecToSelOpNext at line pkgsqlcolexecmaterializergo in pkgsqlcolexecMaterializernext at line pkgsqlcolexecmaterializergo in pkgsqlcolexecMaterializernextAdapter at line pkgsqlcolexecexecerrorerrorgo in pkgsqlcolexecexecerrorCatchVectorizedRuntimeError at line pkgsqlcolexecmaterializergo in pkgsqlcolexecMaterializerNext at line pkgsqlexecinfrabasego in pkgsqlexecinfraRun at line pkgsqlexecinfraprocessorsbasego in pkgsqlexecinfraProcessorBaseRun at line pkgsqlflowinfraflowgo in pkgsqlflowinfraFlowBaseRun at line pkgsqldistsqlrunninggo in pkgsqlDistSQLPlannerRun at line pkgsqldistsqlrunninggo in pkgsqlDistSQLPlannerPlanAndRun at line pkgsqlconnexecutorexecgo in pkgsqlconnExecutorexecWithDistSQLEngine at line pkgsqlconnexecutorexecgo in pkgsqlconnExecutordispatchToExecutionEngine at line pkgsqlconnexecutorexecgo in pkgsqlconnExecutorexecStmtInOpenState at line pkgsqlconnexecutorexecgo in pkgsqlconnExecutorexecStmt at line pkgsqlconnexecutorgo in pkgsqlconnExecutorexecCmd at line pkgsqlconnexecutorgo in pkgsqlconnExecutorrun at line pkgsqlconnexecutorgo in pkgsqlServerServeConn at line pkgsqlpgwireconngo in pkgsqlpgwireconnprocessCommandsAsyncfunc at line usrlocalgosrcruntimeasmamd s in runtimegoexit at line Tag Value Cockroach Release v Cockroach SHA cbd d aeaebbccea d ad fdf db a Platform linux amd Distribution CCL Environment v Command server Go Version go of CPUs of Goroutines sqlcolexecTestRouterOutputNext failed on master af f d fff d df c d a efd RUN TestRouterOutputNext FAIL TestRouterOutputNext s RUN TestRouterOutputNextAddBatchDoesntBlockWhenOutputIsBlocked FAIL TestRouterOutputNextAddBatchDoesntBlockWhenOutputIsBlocked s routerstestgo unexpectedly still unblocked detailssummaryReprosummaryp Parameters GOFLAGSjson make stressrace TESTSTestRouterOutputNext PKGpkgsqlcolexec TESTTIMEOUT m STRESSFLAGStimeout m roachdash subpowered by pkgcmdinternalissues Every new db gets privileges for the root user specifically and the admin group See NewDefaultPrivilegeDescriptor in sqlbase However if there are multiple users in the admin group we probably want the user thats running the CREATE to get the grant instead of root This becomes even more important if CockroachDB is extended to enable other roles than admin to create databases In that case we cant just use the same privileges for all databases The autoinit behavior of cockroach start without join was marked as deprecated in Remove it in Informs and simplifies 