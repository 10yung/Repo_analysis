GeoffreyBooth reopening against master See original PR GeoffreyBooth reopening against master See original PR GeoffreyBooth reopening against master See original PR This allows code passing the output on to other tools to correctly identify the sourceType of the output This PR was started by git wf pr Before making a PR please make sure to read our contributing guidelines For issue references Add a commaseparated list of a closing word followed by the ticket number fixed by the PR It should be underlined in the preview if done correctly All new features require tests All but the most trivial bug fixes should also have new or updated tests Ensure that all new code you add to the compiler can be run in the minimum version of Node listed in packagejson New tests can require newer Node runtimes but you may need to ensure that such tests only run in supported runtimes see Cakefile for examples of how to filter out certain tests in runtimes that don t support them Please follow the code style of the rest of the CoffeeScript codebase Write comments in complete sentences using Markdown as the comments become the annotated source For tests proving a bug is fixed please mention the issue number in the test description see examples in the codebase Describe your changes below in as much detail as possible Fixes Remove error for capital E from lexer Change tests to match Input Code Singleline object literals followed by chaining coffee methods o x f m properties o x a b mixed chaining style o x a b c There are examples with different indentation for chaining entities just because expected behavior for them should be the same once their indentation has reached the level of the corresponding object property or its value if its on a new line or even goes further According to correct behavior examples see below h Singleline object literalsbr ending with a function expression used with parens h these are counterexamples to correct behaviour when used without parens see below coffee parens around function expression o x callt parens around function expression passed as an argument to another function o x f m or parens around the whole property value o x f m Expected Behavior Expected compilation result omitting var js methods o x f m properties o x ab mixed chaining style o x abc js parens around function expression o x function return callt parens around function expression passed as an argument to another function o x ffunction return m or parens around the whole property value o x ffunction return m Current Behavior Current compilation result omitting var js methods o x f m properties o x a b mixed chaining style o x ab c js parens around function expression o x function return callt parens around function expression passed as an argument to another function o x ffunction return m or parens around the whole property value o x ffunction return m Correct Behavior Compare with currently working examples of correct behavior Multiline multi property object literals followed by chaining coffee methods o x f y f m properties o x a y a b mixed chaining style o x a y a b c Multiline single property object literals value is on a new line coffee multiline single property object o x a b same with mixed chaining style o x a b c h Singleline single property object literalsbr ending with a function expression but now without parens h coffee no parens around function expression o x callt no parens around function expression passed as an argument to another function no parens around the whole property value o x f m Compilation result omitting var js methods o x f y f m properties o x a y ab mixed chaining style o x a y abc js multiline single property object o x ab same with mixed chaining style o x abc js no parens around function expression o x function return callt no parens around function expression passed as an argument to another function no parens around the whole property value o x ffunction return m Environment CoffeeScript version Related issues I saw a similar bug in with the same consequences but caused by another case Singleline single property object literals werent investigated there But they were mentioned eg in this comment to another issue I see a lot of mentions and discussions of chaining in general so I understand that this topic is not an easy one for CoffeeScript syntax But I guess there still should be consistency in parsing regardless of the number of object properties or the presence of parens inside them Context Initially I noticed this issue while playing with my class extensions with chaining syntax I encountered a problem with constructor declaration which for some reason is treated here as a singleline object literal instead of a class member declaration maybe this is another bug as well or its caused exactly by chaining And then described issue happens coffee class Example constructor extension private a which produces wrong class declaration js class Example constructor Exampleextension private a And here is rewritten constructor in a multiline notation with a value on a new line coffee class Example constructor extension private a which produces correct result js class Example constructor return ctorapplythis arguments ctor Exampleextensionprivate a But unfortunately this workaround with constructor leads to indent level increase in further chaining lines which sometimes is notably undesirable complex functionsobjectsclasses mixing with native syntax of class member declaration etc details summaryDetailed examplesummary Detailed example of class extension with chaining syntax most implementation omitted coffee extension Class default constructor constructor real constructor ext args constructorapplythis args return this always return class instance extconstructor arg put new constructor constructor arg return ext extpublic arg put public members return ext extprivate arg put private members return ext extprivatestatic arg put private static members return ext extget arg put getters return ext extset arg put setters return ext explicit public getterssetters extpublicget extget extpublicset extset return ext if you dont wanna extend native Function object then put direct call extension extension this in class constructor instead of accessing a property extension ObjectdefineProperty Functionprototype extension configurable true enumerable false get extensionthis class Example constructor extension constructor a private a private static b get a a set a a a a e new Example alert ea details I just stumbled upon this Its a stage proposal which allows js code like js try catch Input Code coffee try obj JSONparse a consolelog obj failed to parse json Current Behavior coffee var obj try obj JSONparsea catch error consolelogobj null obj failed to parse json New Behavior coffee var obj try obj JSONparsea catch consolelogobj null obj failed to parse json Support already looks good too Just dropping this here so it can be looked at whether or not this should be output by CoffeeScript This is more in line with the spec which says the generated code may include a line at the end of the source with the following form sourceMappingURLurl and there exists a sourceURL comment in the generated code It also looks better since the sourceMappingURL is very long This was motivated by mishooUglifyJS While upgrading an application to CS we ran into the following issue in an obscure usage of nested classes Screenshot at As you can see the nested bound method thought its this is the parent class This seems to happen on a parse level because its replaced in the code This lead to tricky to catch bug on our side In what I believe is a bug line numbers in stack traces from errors thrown by CoffeeScript code executed via CoffeeScripteval in NodeJS give the JavaScript line numbers instead of the CoffeeScript line numbers Simple example coffee CoffeeScript require coffeescript CoffeeScripteval if undefinedfoo weird true cause var hoist to shift lines The resulting stack trace and initial message uses a line number of current behavior instead of expected behavior evalmachineanonymous if void foo TypeError Cannot read property foo of undefined at evalmachineanonymous at ScriptrunInThisContext vmjs at ObjectrunInThisContext vmjs at ObjectCoffeeScripteval nodemodules coffeescript lib coffeescript indexjs at repl at repl More real example with filename In my application the evald string actually comes from a coffee file and I can get the filename to appear correctly with enough options to CoffeeScripteval though admittedly I dont understand why so many arguments are needed for this to happen yet the line numbers remain the same coffee CoffeeScripteval if undefinedfoo then weird true filename testcoffee sourceFiles testcoffee inlineMap true results in testcoffee if void foo TypeError Cannot read property foo of undefined at evalmachineanonymous Workaround In my application I constructed a workaround that corrects the line number in the initial message by using CoffeeScriptcompile to get a source map looking upmapping the line number and modifying the errors stack trace Proposed Solution I think it would make sense for CoffeeScripteval to do this kind of mangling of error stack traces The REPL already does mangling of SyntaxErrors via helpersupdateSyntaxError and some of this code can probably be shared It was the inspiration for my workaround Related issues Possibly related to and In particular errors from the REPL seem to start every error with repl whereas repl would make more sense I believe this is the same issue so would also get fixed though REPL seems less important to me Environment CoffeeScript version Nodejs version Operating system Windows 