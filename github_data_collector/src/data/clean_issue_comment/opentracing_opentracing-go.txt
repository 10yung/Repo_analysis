Please provide a solution for authenticating with jaeger collector nodejs and java clients supports some kind of authentication support Use Case has the tag Help Wanted I and others want to help you solve such issues Problem There is currently no contributing guide CONTRIBUTINGmd example which makes it hard to know how this repository accepts contributions what steps to perform and so on Proposal It would be beneficial to have a contributing guide in this repository to explain what steps need to be taken to contribute to the project what issues not project maintainers should consider helping with and so on Questions to address if any Should this repository have a contributing guide What sections should it contain Ive been working on lots of tracing where data is exchanged via a message broker so were always wanting to start spans as followsFrom rather than ChildOf As far as I can see there isnt anything out of the box that deals with this so Ive added the functions that would do it here just in case you think this would be useful hello could i call the spanFinish with a condition for example time span more than second from StartSpan Welcome to the OpenTracing Go repo Please be respectful and considerate of others when commenting on issues Please search for existing issues in order to ensure we dont have duplicate bugsfeature requests If you have a question please ask it on our Gitter chat instead of creating an issue Please provide as much information as possible so we all understand the issue Use Case example code spanLogFieldslogObjectargs args args is a map Problem Because span is sent asynchronously it is possible that this map will also be modified runtimethrow x b b x usrlocalgosrcruntimepanicgo x fp xc d e sp xc d c pc x ca runtimemapiternext xc ccf usrlocalgosrcruntimehashmapgo x c fp xc d sp xc d e pc x aaac reflectmapiternext xc ccf usrlocalgosrcruntimehashmapgo x b fp xc d sp xc d pc x bbcb reflectValueMapKeys x b e xc ae x b x x b e x usrlocalgosrcreflectvaluego x f fp xc d sp xc d pc x b e f fmtppprintValue xc cfc x b e xc ae x b x x usrlocalgosrcfmtprintgo xc fp xc d sp xc d pc x cc fmtppprintValue xc cfc x ffa xc ae x xc x usrlocalgosrcfmtprintgo x ace fp xc d ad sp xc d pc x cd be fmtppprintValue xc cfc x f c xc ae x x x usrlocalgosrcfmtprintgo x fp xc d ca sp xc d ad pc x cd fmtppprintArg xc cfc x f c xc ae xc usrlocalgosrcfmtprintgo x ce fp xc d d sp xc d ca pc x cb e fmtppdoPrintf xc cfc x f b x xc d e x x usrlocalgosrcfmtprintgo x fp xc d e sp xc d d pc x cead fmtSprintf x f b x xc d e x x x e f f c x usrlocalgosrcfmtprintgo x fp xc d e sp xc d e pc x c ec contextvalueCtxString xc e x c e xc cf usrlocalgosrccontextcontextgo xab fp xc d ed sp xc d e pc x b fmtpphandleMethods xc cf x x usrlocalgosrcfmtprintgo x fp xc d f sp xc d ed pc x caf fmtppprintArg xc cf x c e xc e xc usrlocalgosrcfmtprintgo x d fp xc d fd sp xc d f pc x cb dd fmtppdoPrintf xc cf x f b x xc d x x usrlocalgosrcfmtprintgo x fp xc d c sp xc d fd pc x cead fmtSprintf x f b x xc d x x x e f c d b x e f c b c usrlocalgosrcfmtprintgo x fp xc d sp xc d c pc x c ec contextvalueCtxString xc b x c e xc c usrlocalgosrccontextcontextgo xab fp xc d sp xc d pc x b fmtpphandleMethods xc c x x usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x caf fmtppprintArg xc c x c e xc b xc usrlocalgosrcfmtprintgo x d fp xc d sp xc d pc x cb dd fmtppdoPrintf xc c x bafc xd xc d x x usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x cead fmtSprintf x bafc xd xc d x x xc a ff xc db usrlocalgosrcfmtprintgo x fp xc d d sp xc d pc x c ec contextcancelCtxString xc fc x c e xc c usrlocalgosrccontextcontextgo x d fp xc d sp xc d d pc x c d fmtpphandleMethods xc c x x usrlocalgosrcfmtprintgo x fp xc d c sp xc d pc x caf fmtppprintArg xc c x b xc fc xc usrlocalgosrcfmtprintgo x d fp xc d sp xc d c pc x cb dd fmtppdoPrintf xc c x bafc xd xc d b x x usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x cead fmtSprintf x bafc xd xc db b x x xc a ff xc db e usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x c ec contextcancelCtxString xc bdc c x c e xc c c usrlocalgosrccontextcontextgo x d fp xc d d sp xc d pc x c d fmtpphandleMethods xc c c x x usrlocalgosrcfmtprintgo x fp xc d sp xc d d pc x caf fmtppprintArg xc c c x b xc bdc c xc usrlocalgosrcfmtprintgo x d fp xc d d sp xc d pc x cb dd fmtppdoPrintf xc c c x f b x xc d x x usrlocalgosrcfmtprintgo x fp xc d c sp xc d d pc x cead fmtSprintf x f b x xc db x x xc dc xc e usrlocalgosrcfmtprintgo x fp xc d sp xc d c pc x c ec contextvalueCtxString xc d a x c e xc cb usrlocalgosrccontextcontextgo xab fp xc d sp xc d pc x b fmtpphandleMethods xc cb xc xc db d usrlocalgosrcfmtprintgo x fp xc d a sp xc d pc x caf fmtppprintArg xc cb x c e xc d a x usrlocalgosrcfmtprintgo x d fp xc d a sp xc d a pc x cb dd fmtppdoPrintf xc cb x f b x xc d c x x usrlocalgosrcfmtprintgo x fp xc d b sp xc d a pc x cead fmtSprintf x f b x xc db c x x x c a e x f c f c usrlocalgosrcfmtprintgo x fp xc d bd sp xc d b pc x c ec contextvalueCtxString xc d d x c e xc c usrlocalgosrccontextcontextgo xab fp xc d c sp xc d bd pc x b fmtpphandleMethods xc c x c x a usrlocalgosrcfmtprintgo x fp xc d ce sp xc d c pc x caf fmtppprintArg xc c x c e xc d d x usrlocalgosrcfmtprintgo x d fp xc d d sp xc d ce pc x cb dd fmtppdoPrintf xc c x f b x xc d ed x x usrlocalgosrcfmtprintgo x fp xc d e sp xc d d pc x cead fmtSprintf x f b x xc db ed x x x d x e usrlocalgosrcfmtprintgo x fp xc d e sp xc d e pc x c ec contextvalueCtxString xc d x c e xc d usrlocalgosrccontextcontextgo xab fp xc d f sp xc d e pc x b fmtpphandleMethods xc d x a e x c f c c usrlocalgosrcfmtprintgo x fp xc d fa sp xc d f pc x caf fmtppprintArg xc d x c e xc d x usrlocalgosrcfmtprintgo x d fp xc d sp xc d fa pc x cb dd fmtppdoPrintf xc d x f b x xc d x x usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x cead fmtSprintf x f b x xc db x x x d a xc e e usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x c ec contextvalueCtxString xc d f x c e xc f usrlocalgosrccontextcontextgo xab fp xc d d sp xc d pc x b fmtpphandleMethods xc f x xc e e usrlocalgosrcfmtprintgo x fp xc d sp xc d d pc x caf fmtppprintArg xc f x c e xc d f x usrlocalgosrcfmtprintgo x d fp xc d d sp xc d pc x cb dd fmtppdoPrintf xc f x f b x xc d x x usrlocalgosrcfmtprintgo x fp xc d c sp xc d d pc x cead fmtSprintf x f b x xc db x x xc e e xc db usrlocalgosrcfmtprintgo x fp xc d sp xc d c pc x c ec contextvalueCtxString xc db x c e xc e e usrlocalgosrccontextcontextgo xab fp xc d sp xc d pc x b fmtpphandleMethods xc e e xc x usrlocalgosrcfmtprintgo x fp xc d sp xc d pc x caf fmtppprintValue xc e e x c e xc db x x x usrlocalgosrcfmtprintgo x bb fp xc d f sp xc d pc x ce ab fmtppprintValue xc e e x f xc aef c x x x usrlocalgosrcfmtprintgo x ace fp xc d c sp xc d f pc x cd be fmtppprintArg xc e e x f xc aef c xc usrlocalgosrcfmtprintgo x ce fp xc d sp xc d c pc x cb e fmtppdoPrintf xc e e x x xc d ac x x usrlocalgosrcfmtprintgo x fp xc d a sp xc d pc x cead fmtSprintf x x xc db ac x x x xc usrlocalgosrcfmtprintgo x fp xc d a sp xc d a pc x c ec examplecomxxxaaavendorgithubcomuberjaegerclientgotagsEmitObject xc ac x e x x f xc aef c homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgojaegertaggo x fp xc d ae sp xc d a pc xf d examplecomxxxaaavendorgithubcomopentracingopentracinggologFieldMarshal x e x xa x x x x f xc aef c x f xc ac homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomopentracingopentracinggologfieldgo x d fp xc d b sp xc d ae pc xe d examplecomxxxaaavendorgithubcomuberjaegerclientgoConvertLogsToJaegerTags xc bd x x xc efa x x homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgojaegertaggo x fp xc d c sp xc d b pc xf c a examplecomxxxaaavendorgithubcomuberjaegerclientgobuildLogs xc feed x x x xc ac x homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgojaegerthriftspango x fp xc d d sp xc d c pc xf dcd examplecomxxxaaavendorgithubcomuberjaegerclientgoBuildJaegerThrift xc e x homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgojaegerthriftspango x f fp xc d e sp xc d d pc xf d af examplecomxxxaaatraceHTTPTransportWithCacheAppend xc xc e xc db f x x homeadminGOPATHsrcexamplecomxxxaaatracetransportgo x fp xc d e sp xc d e pc xfb examplecomxxxaaavendorgithubcomuberjaegerclientgoremoteReporterprocessQueue xc homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgoreportergo x e fp xc d fd sp xc d e pc xf runtimegoexit usrlocalgosrcruntimeasmamd s x fp xc d fe sp xc d fd pc x bca created by examplecomxxxaaavendorgithubcomuberjaegerclientgoNewRemoteReporter homeadminGOPATHsrcexamplecomxxxaaavendorgithubcomuberjaegerclientgoreportergo x b Proposal Maybe i need to copy one before using it What do you think Welcome to the OpenTracing Go repo Please be respectful and considerate of others when commenting on issues Please search for existing issues in order to ensure we dont have duplicate bugsfeature requests If you have a question please ask it on our Gitter chat instead of creating an issue Please provide as much information as possible so we all understand the issue Use Case Not all requests need to trace and for now you have to mark these requests somehow to avoid new spans creation Even if those spans will be skipped with the sampler Proposal No need to create the new spans from context if there is no parent span go func StartSpanFromContextctx contextContext operationName string opts StartSpanOption Span contextContext return startSpanFromContextWithTracerctx GlobalTracer operationName opts Operation of the creation of root span is always explicit and made in middleware tracerStartSpanoperationName opts with the tracer object And I await that if no parent in the context then it means that we dont have to trace it at all Besides this will allow not to use GlobalTracer at all because we could be sure that it will be at the context in any case and the global tracker could be completely removed as redundant Questions What could be a reason to use StartSpanFromContext to create the root span Can we remove the GlobalTracer singletons If it will really need to someone he can define it in his own module Hi we updated some exported function comments based on best practices from Effective Go It s admittedly a relatively minor fix up Does this help you Hi I have a custom error type which implements Error interface and use it in logError When I was looking at this error through jaegerui I see it is not the errError I see but the struct representation this may be the culprit of this issue func lf Field String string return fmtSprintlfkey lfValue Sprint doesnt call the Error method if the actual interface is an error but a struct representation as I see here I am not sure Marshal formats it differently but as far as I see my trace log doesnt have some of the private info I add through Error method Please guide me if you think it may be because I use the API wrongly fields logField logErrormyCustomError fields appendfields logStringmessage msg fields appendfields logStringlevel info span opentracingSpanFromContextctx spanLogFieldsfields Hello folks Thanks for all the work you did Use Case I would like to expose the traceid out from a Span mainly over HTTP header and I would also like to attach it to the logs that my application generates Mainly for support purpose A developer or a system integrator will be able to communicate the traceid back to the support team and it will easy for them to understand what is going on Problem I looked around and it seems like this information is not accessible from the SpanContext but I had a quick chat with yurishkuro in the mailing list and it looks like the specification now covers this use case Proposal I opened this issue to figure out together how we should update the SpanContext interface to cover this use case golang SpanContext represents Span state that must propagate to descendant Spans and across process boundaries eg a traceid spanid sampled tuple type SpanContext interface ForeachBaggageItem grants access to all baggage items stored in the SpanContext The handler function will be called for each baggage keyvalue pair The ordering of items is not guaranteed The bool return value indicates if the handler wants to continue iterating through the rest of the baggage items for example if the handler is trying to find some baggage item by pattern matching the name it can return false as soon as the item is found to stop further iterations ForeachBaggageItemhandler funck v string bool SpanID string TraceID string We can probably add two simple method SpanID and TraceID to the SpanContext Use Case I am using opentracing for all distributed tracing Problem When I log an error with errorsWithStackerr extErrorSetspan true spanLogFieldslogErrore It just gives the error string rather than stack trace or any supporting information Proposal Treat errors as objects not strings githubcomopentracingopentracinggologfieldgo replace case errorType if err ok lfinterfaceValerror ok visitorEmitStringlfkey errError else visitorEmitStringlfkey nil with case errorType if err ok lfinterfaceValerror ok visitorEmitObjectlfkey err else visitorEmitStringlfkey nil the implementers are then free to use just like is used in jaeger for EmitObject func ml fieldsAsMap EmitObjectkey string value interface ml key fmtSprintfv value Which will give all the information Questions to address if any 