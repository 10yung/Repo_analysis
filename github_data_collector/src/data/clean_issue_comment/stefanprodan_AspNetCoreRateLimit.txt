I cannot manage to get the IpRateLimitPolicies settings to work I would appreciate a second look Ive probably missed something I will post the relevant parts of files ASPNET Core version is Project type is Web API appsettingsjson IpRateLimiting EnableEndpointRateLimiting true StackBlockedRequests false RealIpHeader XRealIP ClientIdHeader XClientId HttpStatusCode QuotaExceededResponse Content message The request threshold has been reached details Quota exceeded Maximum allowed per Please try again in seconds ContentType applicationjson GeneralRules Endpoint Period m Limit IpRateLimitPolicies IpRules Ip Rules Endpoint Period m Limit Startupcs public void ConfigureServicesIServiceCollection services starting off services configurations with IP rate limiter servicesAddOptions servicesAddMemoryCache servicesConfigureIpRateLimitOptionsConfigurationGetSectionIpRateLimiting servicesConfigureIpRateLimitPoliciesConfigurationGetSectionIpRateLimitPolicies servicesAddSingletonIIpPolicyStore MemoryCacheIpPolicyStore servicesAddSingletonIRateLimitCounterStore MemoryCacheRateLimitCounterStore setting up database connection string id stringFormat db GuidNewGuidToString var builder new SqliteConnectionStringBuilder DataSource id Mode SqliteOpenModeMemory Cache SqliteCacheModeShared var connection new SqliteConnectionbuilderConnectionString connectionOpen connectionEnableExtensionstrue servicesAddDbContextWebAPIContextoptions optionsUseSqliteconnection proceding with services configurations servicesAddControllers servicesAddSingletonIHttpContextAccessor HttpContextAccessor servicesAddSingletonIRateLimitConfiguration RateLimitConfiguration Programcs public static async SystemThreadingTasksTask Mainstring args var config new ConfigurationBuilder AddJsonFileappsettingsjson optional false reloadOnChange true AddEnvironmentVariables Build IHost host CreateHostBuilderargsBuild using var scope hostServicesCreateScope var ipPolicyStore scopeServiceProviderGetRequiredServiceIIpPolicyStore await ipPolicyStoreSeedAsync await hostRunAsync I cant manage to hit the IP rate of calls per minute Instead I always hit the General Rules rate of calls per minute I work with custom port numbers could that be the reason Is it by design that you are unable to set an IP WhiteList whilst using the client rate limiting rules Yet when using IP rate limiting rules you are able to set a client ID whitelist Has this been intentionally left out or is this an issue that can be fixed via a PR Hi stefanprodan First of all thanks for the great software you build Im struggling with tests could you help me Ive checked the tests in your repository but they dont cover complex scenarios Lets say I have some rules and limits defined in config how do I write a test which ensures throttling works as indended Its pretty straightforward for simple limits like requests second but what about requests per hour or so Lets say the throttling doesnt work for me as indended misconfiguration or something is there an easy way to understand whats going on Now I have to debug the middleware which is pain if you have many rules defined or concurrent requests are made simultaneously or track cache state changes and it becomes even worse if counters are short living haha Thanks How can I define a policy on run time to effect all IPs for a specific Endpoint I also changed policies in run time but it seems it is not working Here is my code appsettings Logging LogLevel Default Warning AllowedHosts IpRateLimiting EnableEndpointRateLimiting false StackBlockedRequests false RealIpHeader XRealIP ClientIdHeader XClientId HttpStatusCode IpWhitelist EndpointWhitelist ClientWhitelist GeneralRules IpRateLimitPolicies EnableEndpointRateLimiting false StackBlockedRequests false RealIpHeader XRealIP ClientIdHeader XClientId HttpStatusCode IpWhitelist EndpointWhitelist ClientWhitelist GeneralRules main public static void Mainstring args IWebHost webHost CreateWebHostBuilderargsBuild using var scope webHostServicesCreateScope var ipPolicyStore scopeServiceProviderGetRequiredServiceIIpPolicyStore ipPolicyStoreSeedAsyncWait webHostRun Startup public void ConfigureServicesIServiceCollection services servicesAddOptions servicesAddMemoryCache servicesConfigureIpRateLimitOptionsConfigurationGetSectionIpRateLimiting servicesConfigureIpRateLimitPoliciesConfigurationGetSectionIpRateLimitPolicies servicesAddSingletonIpRateLimitOptions servicesAddSingletonIIpPolicyStore MemoryCacheIpPolicyStore servicesAddSingletonIRateLimitCounterStore MemoryCacheRateLimitCounterStore servicesConfigureIpRateLimitOptionsoptions optionsEnableEndpointRateLimiting false optionsStackBlockedRequests false optionsRealIpHeader XRealIP optionsClientIdHeader XClientId optionsHttpStatusCode optionsIpWhitelist new Liststring optionsEndpointWhitelist new Liststring optionsClientWhitelist new Liststring optionsGeneralRules new ListRateLimitRule optionsDisableRateLimitHeaders true optionsRateLimitCounterPrefix webthrottle servicesAddMvcSetCompatibilityVersionCompatibilityVersionVersion servicesAddSingletonIHttpContextAccessor HttpContextAccessor servicesAddSingletonIRateLimitConfiguration RateLimitConfiguration servicesAddSingletonIMyIpRateLimit MyIpRateLimit public void ConfigureIApplicationBuilder app IHostingEnvironment env if envIsDevelopment appUseDeveloperExceptionPage appUseIpRateLimiting appUseMvc my custom class public class MyIpRateLimit IMyIpRateLimit private readonly IpRateLimitOptions options private readonly IIpPolicyStore ipPolicyStore private IpRateLimitPolicies Policies public MyIpRateLimitIpRateLimitOptions options IIpPolicyStore ipPolicyStore options options ipPolicyStore ipPolicyStore public async void AddRuleRateLimitRule rule Policies ipPolicyStoreGetAsyncoptionsIpPolicyPrefixResult if Policies is null Policies new IpRateLimitPolicies if Policies null PoliciesIpRulesCount PoliciesIpRules RulesAddrule else PoliciesIpRulesAddnew IpRateLimitPolicy Ip Rules new ListRateLimitRulenew RateLimitRule rule await ipPolicyStoreSetAsyncoptionsIpPolicyPrefix Policies controller HttpPost public void Post FromBody string value var a new RateLimitRule aEndpoint value aLimit aPeriod s aPeriodTimespan TimeSpanFromSeconds myRateLimitAddRulea I expect it to let get or post data one in every seconds but it doesnt do that When I set Endpoint to it works but when I set to apivalues it doesnt work my Url is localhost apivalues Do I need to set anything else Im having an issue with the global wildcard ruleset overwriting the specific ruleset for a given endpoint Is this a case where I cant have both options at the same time so that if we want specific rules for specific endpoints we need to apply to each and every one IP Rate limiting IpRateLimiting EnableEndpointRateLimiting true StackBlockedRequests false RealIpHeader CFConnectingIP ClientIdHeader ClientIdHeader HttpStatusCode IpWhitelist SHOULD BE EndpointWhitelist getapilicense apistatus ClientWhitelist devid devid GeneralRules Login limit Endpoint getv Authcreatetoken Period m Limit Open contact point Endpoint getv messagingmessagetobyndle Period m Limit Calling notifications every seconds obviously ends up in a lot of queries Endpoint getv notificationsunseen Period h Limit Endpoint getv notificationslatest Period h Limit General everything ever fallbacks Endpoint Period s Limit Endpoint Period m Limit Endpoint Period h Limit GET calls to v notificationsunseen are still being blocked by the h k limit and not by the applied h k limit we have specified for that endpoint apivversionshpbuy my api has version controlling so how should I define the limiting in the appsettings getapivshpbuy seems not work I have the following GeneralRule Endpoint Period m Limit Can I add another GeneralRule or something that overrides this rate limit I want to do something like the following Endpoint Period s Limit Endpoint validate Period s Limit By this I mean that all endpoints except for the validate endpoint should only allow calls per second The validate endpoint should allow calls per second I cant seem to get this to work Hello I have implemented ClientRateLimiting where in GeneralRules am setting to Period s Limit and in ClientRules am setting the Period m Limit But always the GeneralRules gets overriden Also I tried same config by interchanging the rules and I got exactly opposite Results ClientRateLimiting EnableEndpointRateLimiting true ClientIdHeader OcpApimSubscriptionKey HttpStatusCode ClientWhitelist clkeya clkeyb GeneralRules Endpoint Period m Limit ClientRateLimitPolicies ClientRules ClientId f dd d f e a Rules Endpoint Period s Limit ResponseMessage on getting throttled Here GeneralRules got picked up instead of ClientRule API calls quota exceeded maximum admitted per m But when I gave same TimePeriod Format for both Rules it gets executed properly ClientWhitelist also works fine Heres the API call snippet using HttpClient httpClient new HttpClient httpClientDefaultRequestHeadersAcceptClear httpClientDefaultRequestHeadersAcceptAddnew MediaTypeWithQualityHeaderValueapplicationjson httpClientDefaultRequestHeadersAddOcpApimSubscriptionKey f dd d f e a string requestUri var httpResponseMessage httpClientGetAsyncrequestUriResult Can you please look into the issue why giving different TimePeriodFormats is causing the issue Getting the following error when trying to install the package in VS InstallPackage WebApiThrottle Version Restoring packages for C Users Dan source repos WebApplication WebApplication WebApplication csproj Installing NuGet package WebApiThrottle Committing restore Writing lock file to disk Path C Users Dan source repos WebApplication WebApplication obj projectassetsjson Restore completed in ms for C Users Dan source repos WebApplication WebApplication WebApplication csproj Successfully installed MicrosoftAspNetWebApiCore to WebApplication Successfully installed MicrosoftOwin to WebApplication Successfully installed Owin to WebApplication Successfully installed WebApiThrottle to WebApplication Executing nuget actions took sec Time Elapsed PM unInstallPackage WebApiThrottle Version Restoring packages for C Users Dan source repos WebApplication WebApplication WebApplication csproj Committing restore Writing lock file to disk Path C Users Dan source repos WebApplication WebApplication obj projectassetsjson Restore completed in ms for C Users Dan source repos WebApplication WebApplication WebApplication csproj Successfully uninstalled MicrosoftAspNetWebApiCore from WebApplication Successfully uninstalled MicrosoftOwin from WebApplication Successfully uninstalled Owin from WebApplication Successfully uninstalled WebApiThrottle from WebApplication Executing nuget actions took ms Time Elapsed PM InstallPackage AspNetCoreRateLimit Version Restoring packages for E Dev swaytraderio SwayTrader Raptor Core Licensing RaptorLicensingService RaptorLicensingService RaptorLicensingServicecsproj InstallPackage NU Version conflict detected for MicrosoftExtensionsLogging Installreference MicrosoftExtensionsLogging directly to project RaptorLicensingService to resolve this issue RaptorLicensingService AspNetCoreRateLimit MicrosoftExtensionsLogging RaptorLicensingService MicrosoftAspNetCoreApp MicrosoftExtensionsLogging At line char InstallPackage AspNetCoreRateLimit Version CategoryInfo NotSpecified InstallPackage Exception FullyQualifiedErrorId NuGetCmdletUnhandledExceptionNuGetPackageManagementPowerShellCmdlets InstallPackageCommand InstallPackage Package restore failed Rolling back package changes for RaptorLicensingServiceAt line char InstallPackage AspNetCoreRateLimit Version CategoryInfo NotSpecified InstallPackage Exception FullyQualifiedErrorId NuGetCmdletUnhandledExceptionNuGetPackageManagementPowerShellCmdlets InstallPackageCommand Hi stefanprodan When deploying a lots of api servicesuse distributed cache to store counter behind load balance every instance need to get conuter and use process lock to increse count as the code below using await AsyncLockWriterLockAsynccounterIdConfigureAwaitfalse var entry await counterStoreGetAsynccounterId cancellationToken if entryHasValue entry has not expired if entryValueTimestamp rulePeriodTimespanValue DateTimeUtcNow increment request count var totalCount entryValueCount configRateIncrementerInvoke deep copy counter new RateLimitCounter Timestamp entryValueTimestamp Count totalCount stores id string timestamp datetime totalrequests long await counterStoreSetAsynccounterId counter rulePeriodTimespanValue cancellationToken I think it has concurrency issues counter will not work correctly when a lots of requests come in Every instances counter count by themself then save to the cache store the last one will cover the previous one Why not use Token Bucket algorithm to achieve this feature