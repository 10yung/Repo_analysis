Added PubSub Implementation in documentation Issue Labels While not necessary you can help organize our issues by labeling this issue when you open it To add a label automatically simply x mark the appropriate box below hasreproduction x feature blocking good first issue To add a label not listed above simply place label anotherlabelname on a line by itself It would be nice to support returning a promise of an AsyncIterator as the ResolverFn This is also supported in graphqljs This would enable use cases like where we could handle authorization at the topicsresolver level of a subscription rather than within the filter withFilter function is causing memory leak because of Promise spec Related nodejsnode This is a big problem when you have long living subscriber to subscription who skips most of messages all Promises in recursion chain are kept in memory How to reproduce Start a subscriber to a subscription which rejects messages and start publishing messages Youll notice memory keeps increasing Memory profile will confirm Solved by x hasreproduction feature blocking good first issue Im trying to understand how the following three heavily overlapping docs relate to each other this apollographqlgraphqlsubscriptions README this graphqlsubscriptions guide note that the Edit on GitHub link on that page points to a different repo not this one even though this repo is graphqlsubscriptions withFilter function is causing memory leak because of Promise spec Related This is a big problem when you have long living subscriber to subscription who skips most of messages all Promises in recursion chain are kept in memory How to reproduce Start a subscriber to a subscription which rejects messages and start publishing messages Youll notice memory keeps increasing Memory profile will confirm Do the same thing using refactored withFilter and youll notice memory is not increasing Pull Request Labels x hasreproduction feature blocking x good first review Fixes Pull Request Labels While not necessary you can help organize our pull requests by labeling this issue when you open it To add a label automatically simply x mark the appropriate box below hasreproduction feature blocking good first review To add a label not listed above simply place label anotherlabelname on a line by itself Have next check that the async iterator hasnt already completed Issue Labels While not necessary you can help organize our issues by labeling this issue when you open it To add a label automatically simply x mark the appropriate box below hasreproduction x feature blocking good first issue To add a label not listed above simply place label anotherlabelname on a line by itself Hey I would like you to consider using server sent events by default and suggest this approach to the people as we saw here in a lot of liveexamples that using websockets together with async interators in production could be a very explosive mixture Maybe we could together develop a more common solution which is inspired from I am asking myself why we are forced to use asynciterators as a technology which seems to be not really ready for production purposes Is there any alternative Cheers added new subscription package Pull Request Labels While not necessary you can help organize our pull requests by labeling this issue when you open it To add a label automatically simply x mark the appropriate box below hasreproduction feature blocking good first review To add a label not listed above simply place label anotherlabelname on a line by itself The following snippet will result in an iterator promise returned by next that never resolves js const iterator new PubSubasyncIterator const promise iteratornext iteratorreturn await promise will wait forever The trick is that return gets called synchronously while the first call to next is still setting up its subscriptions This appears to be a regression since since I have a test suite that was green and started failing on this issue when I upgraded to I have tried various solutions including monkeypatching emptyQueue like this js PubSubAsyncIteratorprototypeemptyQueue async function if thisrunning thisrunning false thispullQueueforEachresolve resolve value undefined done true thispullQueuelength thispushQueuelength const subscriptionIds await thisallSubscribed if subscriptionIds thisunsubscribeAllsubscriptionIds This one should make sure new next calls while we were awaiting and resolved thispullQueueforEachresolve resolve value undefined done true But interestingly doing so made other tests in my suite fail for reasons Im afraid I dont understand right now Ignore this last part that failure seemed to be caused by me misusing Jests resolves method forgetting to await it