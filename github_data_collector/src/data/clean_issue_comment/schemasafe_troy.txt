The plan is to add Cassandra itself as a compile time dependency where we call the Java code that is responsible to validate and type check the query properly happens you prepare a statement The Java code will be called from a macro Note that the solution must NOT start Cassandra server not even in memory The solutions should provide methods that look something like this Allow us to create Schema representation from schemacql file def createSchemaschemaDefinitionStatements Seq String Either String Schema Allow us to know the signature of the query how many selected rows what are the types how many bind markers what are their types def schemaCheckschema Schema query String Either String QuerySignature These function should call Cassandras source code A proof of concept can be written in a seperate GistRepo Useful links I get the following error bash error homecitrullingitscalatroysrcmainscalamodelPageImpressionByYearMonthscala Cant find schema file schema error val getByYearMonth withSchema Lets take a look into the code scala package model import comdatastaxdrivercoreCluster Session import connectionConnectionProvider import entityPageImpression import troydsl import troydriverDSL import scalaconcurrentFuture class PageImpressionByYearMonthconnection ConnectionProvider import scalaconcurrentExecutionContextImplicitsglobal val cluster connectioncluster implicit val session Session connectionsession val keyspace analytics val tableName pageimpressionbyyearmonth val getByYearMonth withSchema year Int month Int cql SELECT FROM analyticspageimpressionbyyearmonth WHERE year year AND month month preparedexecuteAsyncasPageImpression def getyear Int month Int Future Seq PageImpression getByYearMonthyear month The schema file is in probjectsrcmainresourcesschemacql and projectsrctestresourcesschemacql I also checked probjectsrcmainresourcesschmeaschemacql and probjectsrctestresourcesschemacql I think there is something wrong with the relative path Instead of a relative path it seems like it uses a absolute path Need to tap into Cassandras mechanism for grouping modifications to multiple partitions into a single statement Making some basic calls Im getting exceptions when I compile error ApiKeyscala exception during macro expansion javalangStackOverflowError error def create ApiKey Future ApiKey withSchema error import roottroydriverInternalDsl import roottroydrivercodecsPrimitivesCodecs val prepared implicitly comdatastaxdrivercoreSession prepare n SELECT apikey name active n FROM apiapikeys n WHERE apikey n apiKey javautilUUID def parserrow rootcomdatastaxdrivercoreRow ApiKeycolumn javautilUUID rowas CDTUuid column String rowas CDTText column Boolean rowas CDTBoolean bindprepared paramapiKeyas CDTUuid executeAsyncApiKeyRecordthissession scalaconcurrentExecutionContextImplicitsglobaloneOptionscalaconcurrentExecutionContextImplicitsglobalparseAsparser Heres my schema sql CREATE KEYSPACE api WITH replication class SimpleStrategy replicationfactor CREATE TABLE apiapikeys apikey uuid name text active boolean PRIMARY KEY apikey Heres my calling code thats breaking scala class ApiTokenRecordimplicit session Session def create withSchema token UUID apiKey UUID email String expiration DateTime cql INSERT INTO kikoapitokens apitoken apikey email expirationtime VALUES token apiKey email expiration preparedexecuteAsyncmap true Am I doing something wrong min max avg sum count not to be confused with SELECT COUNT According to Troys CQL Parser should support double quoted identifiers especially column names in select clause and create table lower case identifiers unless they are double quoted 