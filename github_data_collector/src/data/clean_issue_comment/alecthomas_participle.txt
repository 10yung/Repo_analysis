Hi alecthomas here with another use case Im not actually sure whats the best way to solve this so Ill first explain what Im trying to do Im using the peeking lexer to help write error reporting Often I find myself wanting to know what is the cursor position of the unexpected token in the peeking lexer However the peeking lexer counts in number of tokens and the unexpected token only has its file position And when the unexpected token error occurs the token may be ahead or behind the cursor position How do I reliable find the relative cursor position for this token My current solution is binary searching for it using the tokens offset but that requires exposes the peeking lexers Length go func searchTokenlex lexerPeekingLexer tokenOffset int lexerToken int error cursorOffset err binarySearchLexerlex lexLength tokenOffset if err nil return lexerToken err if cursorOffset return lexerToken fmtErrorffailed to find token at offset d tokenOffset n cursorOffset lexCursor token err lexPeekn return token n err func binarySearchLexerlex lexerPeekingLexer l r x int int error if r l mid l r l token err lexPeekmid lexCursor if err nil return err if tokenPosOffset x return mid nil if tokenPosOffset x return binarySearchLexerlex l mid x return binarySearchLexerlex mid r x return nil Using the example TOML parser from the READMEmd go toml TOML err tomlParserParseString int stringa string float toml I get unexpected token It seems the eBNF for Int is capturing the leaving the as unparsable I had a similar problem in an eBNF grammar I was creating I solved it by using regexps but Id prefer to use eBNF if possible Whats the fix to this situation To support more complex languages it should be possible to elegantly define stateful lexers Ideally this would support here docs eg cat EOF nEOF where EOF is a userdefined marker Runtime selected sublexers ala markdowns language blocks this would defer to some external function in order to set the lexer based on language Recursive lexers for eg string interpolation var in this situation a new lexer is pushed onto the state when is encountered and popped when is encountered My hunch is that some kind of stateful EBNF could work but it would need to be extensible programatically and its not clear exactly how this would be expressed In moderately complex grammars its fairly common to see duplicate patterns emerge For example when matching a dotseparated identifier eg foobar the pattern Ident Ident is used repeatedly This can be handled by a Go type alias implementing the Parseable interface but that is quite onerous I propose adding support for grammar aliases Heres an example creating and using an Identifier alias go type Assignment struct Name string IdentifierIdent Ident Variable string Identifier Hi I want to check if the prevoius char is a The exact example code I have is this Prefix I want basicly to be able to check based on if the previous char is a the should get a string and later reuse the look back logic to check if I am inside an array which is defined like in yaml meaning to make sure the last lines of the following example dont get into the array Commands Trigger afk Response user just went afk Trigger joinevent Response Welcome to the Room lastjoineduser Homeserver matrixorg HomeRoom name Commands defines a Array with objects in it which both have two key value pairs in them HomeServer and HomeRoom are outside of that array Generate the structs and tags from EBNFpossible See It would be very handy to be able to export an EBNF representation of the parsed grammar for documentation purposes