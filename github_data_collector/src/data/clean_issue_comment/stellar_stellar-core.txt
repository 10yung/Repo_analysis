Main issue that Ive encountered while running network simulations is our logs being too verbose but not very detailed at the same time This PR attempts to make a few improvements such as tracking life cycle of a txset and consolidating info that used to take multiple logs in different places into a single log entry Also added a new metric to record duration of individual items being fetched problem with scpfetchduration was that if we had outliers that for some reason got stuck and then cleaned up we never surfaced them The ItemFetcher code is kind of messy like we dont actually delete trackers right away so I think there might be some strange edge case where PendingEnvelopes reuses the same tracker object to fetch an item but we can at least surface the outliers with this metric Description Implements Checklist Reviewed the contributing document Rebased on top of master no merge commits Ran clangformat v via make format or the Visual Studio extension Compiles Ran all tests If change impacts performance include supporting evidence per the performance document Description Implements Checklist x Reviewed the contributing document x Rebased on top of master no merge commits x Ran clangformat v via make format or the Visual Studio extension x Compiles x Ran all tests If change impacts performance include supporting evidence per the performance document Description This adds some lowlatency signposts to the transaction processing phases These turn into short writes to the oslog subsystem on MacOS and are surfaced in Instrumentsapp helping to show which parts of a profile do what Theyre noops on Linux or Windows Each signpost costs syscall at about us The finestgrain signpost in this PR is the transaction apply one currently were closing something like txledger at something like ms this would add ms to that close time If thats still too much I can remove the inner pertx signpost Checklist x Reviewed the contributing document x Rebased on top of master no merge commits x Ran clangformat v via make format or the Visual Studio extension x Compiles x Ran all tests x If change impacts performance include supporting evidence per the performance document Description Implements Checklist x Reviewed the contributing document x Rebased on top of master no merge commits x Ran clangformat v via make format or the Visual Studio extension x Compiles x Ran all tests If change impacts performance include supporting evidence per the performance document Ive had synced node running without any problem for several months But suddenly it stopped to sync new blocks and show me the following error message T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDRU History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDRU History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDRU Ledger ERROR Catchup will restart at next close LedgerManagerImplcpp After restarting node several times but I got the same error everytime details summaryErrorsummary T GDQMO History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDQMO History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDQMO History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDQMO History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDQMO History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDQMO History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDQMO History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDQMO History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDQMO History ERROR Bad ledgerheader history entry claimed ledger seq hash c b does not agree with LCL seq hash f VerifyLedgerChainWorkcpp T GDQMO History ERROR Catchup material failed verification hash mismatch propagating failure VerifyLedgerChainWorkcpp T GDQMO History ERROR One or more of history archives may be corrupted Update HISTORY configuration entry to only contain valid ones VerifyLedgerChainWorkcpp T GDQMO Ledger ERROR Catchup will restart at next close LedgerManagerImplcpp details Could not find any solutions so I initialized new DB with newdb command and started to sync my node from scratch Actually I could not realize what was the problem details summaryMy nodes config summary HTTPPORT PUBLICHTTPPORTfalse COMMANDS lllevelERROR ENTRYCACHESIZE BESTOFFERSCACHESIZE LOGFILEPATHsecretpathtolog BUCKETDIRPATHsecretpathtodir NETWORKPASSPHRASEPublic Global Stellar Network September PEERPORT TARGETPEERCONNECTIONS MAXADDITIONALPEERCONNECTIONS MAXPENDINGCONNECTIONS PEERAUTHENTICATIONTIMEOUT KNOWNPEERS coreliveastellarorg corelivebstellarorg corelivecstellarorg austellaribmcom nostellaribmcom ukstellaribmcom castellaribmcom NODEISVALIDATORfalse FAILURESAFETY UNSAFEQUORUMtrue CATCHUPCOMPLETEfalse CATCHUPRECENT DATABASE SECRET MAXCONCURRENTSUBPROCESSES AUTOMATICMAINTENANCEPERIOD AUTOMATICMAINTENANCECOUNT NODENAMES GCKWUQGSVO ZV QK POYL HMFWDKWJVMFVEGUJKCAEVUITUCTQWFSM IBMAustralia GB HF NHRKKFZYFDGD MUENOYROOEK SWYV APYOODP P BUJTLILKIL IBMCanada GDRA H JWXAXWJKOONQOPH JKNSH MQ BO K C X FO G OG BPU IBMNorway GAENPO XRTTMAJXDWM E GAALNLG HVMKJ QF TR RI YPEDULOW IBMUK GCGB S KGYARPVIA HYZXVRM YZUEXA S ZU BUDC THSB LZSTYH sdf GCM QMP DLRPTAZW UZPCPX LF SXWXKPMP GKFZBDSF QZGV G QSTK sdf GABMKJM I XI K U XWMULOUQIQ BCTMLS BYYSOWKTBUXVRJSXHYQ sdf KNOWNCURSORS HORIZON QUORUMSET THRESHOLDPERCENT VALIDATORS sdf sdf sdf QUORUMSET THRESHOLDPERCENT VALIDATORS IBMUKIBMAustraliaIBMNorwayIBMCanada HISTORYsdf getcurl sf o HISTORYsdf getcurl sf o HISTORYsdf getcurl sf o details Environment Linux generic Ubuntu SMP Tue Nov UTC x x x GNULinux Running from command line Did you pass in special parameters when building the app No Description Resolves This PR replaces This PR adds wrapper objects to transaction sets and quorum sets so that herder can keep an exact mapping between those objects and the ones referenced by SCP This is the first step in separating the caching strategy between SCP and herderoverlay this should allow us to be a lot more aggressive in caching data that SCP doesnt strictly need in the future while keeping the strict minimum of data for SCP to continue to function Checklist Reviewed the contributing document Rebased on top of master no merge commits Ran clangformat v via make format or the Visual Studio extension Compiles Ran all tests If change impacts performance include supporting evidence per the performance document It looks like sometimes downloading transaction sets take a very long time even though peers have the data NB this happens around times with slow ledgers so there could be some strange interaction between systems nothing in the logs around dropped peers from what I could see For example I captured this sequence message from LOBSTR Europe received at T and only much later the message is processed T thats seconds just to download a small transaction set T GCM Q SCP DEBUG NominationProtocolnominate SIGNEDsdfwatcher txH e eca ct upgrades T GCM Q Herder DEBUG recvSCPEnvelope from LOBSTR Europe s i aSynced T GCM Q SCP DEBUG NominationProtocolnominate SIGNEDsdfwatcher txH e eca ct upgrades T GCM Q SCP DEBUG NominationProtocolnominate SIGNEDsdfwatcher txH e eca ct upgrades T GCM Q SCP DEBUG new statement i st ENVCOINQVESTFinland i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVCOINQVESTGermany i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVkeybase i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVCOINQVESTHongKong i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVLOBSTR Australia i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVblockdaemon i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVblockdaemon i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG NominationProtocolnominate SIGNEDsdfwatcher txH e eca ct upgrades T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDsdfwatcher txH e eca ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVblockdaemon i NOMINATE D db X SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVCOINQVESTHongKong i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y SIGNEDCOINQVESTHongKong txH b ct upgrades validated true T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDsdfwatcher txH e eca ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVblockdaemon i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y SIGNEDCOINQVESTHongKong txH b ct upgrades validated true T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVCOINQVESTFinland i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y SIGNEDCOINQVESTHongKong txH b ct upgrades validated true T GCM Q SCP DEBUG new statement i st ENVLOBSTR Asia i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVLOBSTR Australia i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVsdfwatcher i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades Y validated true T GCM Q SCP DEBUG new statement i st ENVLOBSTR Europe i NOMINATE D db X SIGNEDLOBSTR Europe txH a ct upgrades SIGNEDCOINQVESTHongKong txH b ct upgrades Y validated true I found edited part to be confusing Maybe because of indentation I understood that one should process fee and then meta of each tx one after another however you should process fee changes of ALL txs first before processing meta changes The TxSetFrame class needs an overhaul Among its problems It is stateful allowing addition and deletion of txs from the set which corrupts its sort order It has methods like trimInvalid or checkOrTrim that implicitly call the deletion method The deletion method is linear in the size of the txset and is called from linear trimming loops over the txset with quadratic results It has a calculated field the content hash thats cached with a validity flag thats flipped when it changes It has a sortForHash method that also does a potentially slightlyexpensive calculation but doesnt track its state with a validity flag meaning it potentially resorts anytime anyone calls it even if its already sorted It has a sortForApply method which doesnt change the order of the members even though the name suggests it does and some tests appear to think it does see herdertestHerderTestscpp It has a somewhat awkward abstract base class with both full TxSetFrame and simulated SimulationTxSetFrame subtypes Its not clear to a reader what the difference is or why there are two As a general sketch hopefully without disrupting its users too much Id recommend the following adjustments Keep the cached calculated content hash but make it mutable and invalidated by a const helper method revalidated in the const hashgetter copy what TransactionFrame does here Make it a documented invariant that a TxSetFrames transactions are always in hashsorted order When constructed from a TxSet offthewire pass a boolean saying whether to sort in the ctor because were just mucking around in a test or whether to require the input is presorted and throw if its not eg for values off the wire which we should reject immediately at PeerrecvTxSet level Either store values in a sorted form thats always sorted stdset Or store them in a sorted stdvector And resort eagerly on each change possibly batching changes Or flip a mutable mSorted bit and resort before observation as with the hash Either way remove the sortForHash function from the public API Callers shouldnt care Remove quadratic filtering loop build a stdvector of txstoremove during the filter loop then sort that vector by hash once unfortuntately its processed in apply order and mergeremove it from the remaining sorted type Remove the AbstractTxSetForApply base type Rename SimulationTxFrame to TxSetInApplyOrder use this in LedgerCloseData Rename TxSetsortForApply to getTxSetInApplyOrder and make it const make this construct a TxSetInApplyOrder Keep TxSetInApplyOrder immutable but change its contents and constructors slightly Replace its mTransactions and mResults members with a stdvectorTransactionFramePtr mTxns member Change its current ctor to take the same args but eagerly expandout the mTxns member Give it a new ctor that takes networkID previousLedgerHash contentsHash and a stdvectorTransactionFramePtr This is called from TxSetFramegetTxSetInApplyOrder Give it a method to produce a TxSetFrame in hash order Let users interconvert but not wonder which is which TxSetFrame is hashsorted TxSetFrameInApplyOrder is applysorted Always The end 