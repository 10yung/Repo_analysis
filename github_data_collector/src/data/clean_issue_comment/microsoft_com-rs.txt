I have cc code that I want to convert gradually to Rust the CC code uses windows headers and uses com interfaces heavily how do you pass compatible pointers to com interfaces between Rust and CC When I try to do this the naive way just passing mut dyn IOleObject through ffi boundary then rustc warns that interface is not ffi safe warning extern block uses type dyn mshtmlIOleObject which is not FFIsafe trait objects have no C equivalent Everything still compiles but my program crashes How do you do this correctly For example I have an AutoCAD COMs TBL file I want to use this tbl file to generate all the interface Continuing conversation that started in it is currently possible to call interface methods after CoUninitialize has been called It is uncertain whether this is actually unsafe or whether the program will be properly aborted once an interface method is actually called One possible solution is to tie the lifetime of the runtime to the lifetime of each interface but this makes the crate much less ergonomic One other solution is to get rid of the explicit runtime struct and simply expose an unsafe CoUninitialize function that requires the user verifies that no active interfaces are still alive when it is called On top of this other constructs could be built that make things easier to handle but might require some sort of runtime cost eg a reference counter construct that only call CoUninitialize when all interface references have been dropped I was looking into adding support for generic types into coclass attribute to enable easy way for a generic class factory implementation for Ironically this causes problems because its impossible to implement a class factory for such classes Ignoring the generic type support The use case for coclass without a class factory is COM classes that the library wants to implement for the purpose of implementing an interface but which do not need to be available for construction through CoCreateInstance they dont even need to have CLSID Currently comrs is a bit ambiguous in this situation with part of the class factory infrastructure being implemented in coclass while the CLSIDs arent defined until the class is exposed through inprocdllmodule Although excluding the generic type scenario the current coclassgeneratesclassfactory implementation doesnt prevent implementing coclasses that are never intended to be constructed by a COM client The class objects are just a bit unneeded in such case So the only scenario that I can think of which is blocked by the current implementation is the generic type support And even that can technically be implemented by conditionally avoiding the class object generation if there are type parameters in the struct The cominterface macro didnt take the unsafety into account when implementing the traits on InterfaceRcInterfacePtr One solution for the safety problem in issue would be to mark the traits themselves as unsafe While this does nothing to the callers it would serve as a hint to the trait impl that the implementation can be called from outside of Rusts usual safety model I was about to even suggest that cominterface might require for the traits to be marked as unsafe Also added a rudimentary compile test for this case It might be worth it to look into an actual compile test crate such as trybuild Any plans to add windows com examples Context menu perhaps The following use case C C COM client CComPtrILogic logic CComPtrIData data logicDoLogicdata C holds reference count This is essentially a borrow rust Rust COM server impl ILogic for CoLogic fn dologic self data mut cvoid Safety requirements for InterfacePtrnew ptr is valid pointer of T ptr must live as long as InterfacePtr let ptr unsafe InterfacePtrIDatanewdata Rust wants ownership and turns the ptr into a Rc This should increment reference count but doesnt currently let rc InterfaceRcnewdata This would increment reference count but is not implemented for InterfacePtr let rc InterfacePtrgetinterfaceIOtherDataptr So couple of needs Provide unsafe InterfacePtr into InterfaceRc without addref method Currently InterfaceRcnew does this but isnt marked as unsafe thus leading to easy doublerelease if the user forgets to manually call addref Provide safe InterfacePtr into InterfaceRc with addref method As long as InterfaceRc does addref there should be no other safety concerns assuming the pointer itself is valid which InterfacePtr seems to imply based on the safety requirements on its new method Implement getinterface on InterfacePtr Currently the user must turn any pointer into Rc type just to call getinterface Maybe look into implementing a lifetime scoped variant of InterfacePtr rust reprtransparent ScopedInterfacePtra TInterface ptr mut cvoid phantom a PhantomDataTInterface This should prevent accidentally moving the pointer somewhere that would outlive the function call rust cominterface C pub trait IUnknown unsafe fn queryinterface self riid winapisharedguiddefREFIID ppv mut mut winapictypescvoid winapisharedwinerrorHRESULT fn addref self u unsafe fn release self u This way of declaring COM interfaces is really convenient but IMO it provides a wrong feeling of safety An erroneous COM server may cause memory errors even in simple functions like addref Further I would argue this functions are all special kinds of FFI calls using the COM ABI so like every normal FFI function they should always be unsafe Currently the easiest way to use the cominterface macro to not use unsafe at all is probably the most dangerous one This extends to the comInterfaceRc type I think constructing this struct should also be unsafe The user should be forced to verify the called COM server or signal their trust by constructing this type within an unsafe block This would lead to a less convenient usage but I think this would still be a better approach because most of the time the COM interfaces will probably not be used directly in idiomatic Rust code Most of the time their will probably be behind another layer of abstraction and I think this should also be the layer providing the safe interface for the COM types However I see that especially in cases where COM is used as a system for pluginlike components it is in general impossible to verify the correctness so their is probably a practical compromise needed I was trying to look through the examples but couldnt find a way to implement something similar to I got as far as constructing the CreatedClass with CreatedClassallocate but got stuck turning it into ICreatedClass in a safe way The only approach I found was going through the raw queryinterface API such as rust let s CreatedClassallocate saddref let rc unsafe let mut ptr mut winapictypescvoid stdptrnullmut squeryinterface IIDICREATEDCLASS as const mut ptr as mut comInterfaceRcdyn ICreatedClassnew unsafe comInterfacePtrnewptr Encountered this as part of my benchmarking effort for Intercom Current results show Intercom as an order of magnitude slower for simple method calls with comrs managing four COM calls and their simple implementation in nsiteration while Intercom spends nsiteration on them nsiter after introducing logging but not using it Makes me reconsider whether I should put logging in Intercom behind a nondefault feature Then again a struct that does nothing but setaddget a u value into a Cellu is a bit extreme benchmark To reduce the amount of generated code we can look to refactor getrelevantregistrykeys out