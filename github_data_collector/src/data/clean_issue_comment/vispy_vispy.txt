When running examplesbasicsplottingexportpy the highresolution render shows only a small part of the plot see screenshot below Screenshot I think the problem is that TransformationSystem uses physicalsize of the canvas which is not updated to the size of the canvas I attached a simple fix that overrides the physicalsize to be that of the currently active fbo I was not sure if it would make more sense to add it to one of the other stacks in SceneCanvas Hi I have a simple question from a beginner I would like to make a function drawcube or drawmesh with a good interactive camera for drawing procedurally several cubes or mesh in the ondraw function I tried with SceneCanvas by deriving the ondraw function without storing the cube in the scene graph see the code bellow An other way would be with appCanvas but with a good interactive camera better than arcball With the code bellow the cube is drawed but it is not turned by the mouse How can I apply the viewcamera matrix to any mesh visuals Is there an example based on appCanvas with a good interactive camera with mouse I mean more complete than examplesbasicsvisualsarcballpy with zoom translation etc An example including a simple but efficient class ViewCamera in appCanvas without the scene graph class MonCanvassceneSceneCanvas def initself sceneSceneCanvasinitself keysinteractive selfunfreeze selfview selfcentralwidgetaddview selfviewcamera scenecamerasArcballCameraparentselfviewscene selfcube scenevisualsCube color edgecolorred selffreeze def ondrawself event printondraw superondrawevent selfcubedraw Thank you very much Alex Hi I am new to vispy and I am trying to scroll the line visual according to the range on the xaxis I know that there is a ScrollingLine available but i cannot represent data on x axis and it is only dependent on the number of pointscorrect me if I am wrong I modified the example to make it look like the line is scrolling but actually I am just moving the viewbox to keep up with the new data It works really well until certain time and the FPS slows down to FPS from FPS Here is an example that you can use to reproduce it coding utf Copyright c Vispy Development Team All Rights Reserved Distributed under the new BSD License See LICENSEtxt for more info Demonstration of animated Line visual import sys import numpy as np from vispy import app scene from collections import deque import random vertex positions of data to draw N pos deque nparray maxlenN xlim ylim color array color npones dtypenpfloat canvas sceneSceneCanvaskeysinteractive showTrue canvasmeasurefps grid canvascentralwidgetaddgridspacing viewbox gridaddviewrow col viewboxcamera scenePanZoomCamera add some axes xaxis sceneAxisWidgetorientationbottom axislabelX Axis axisfontsize axislabelmargin ticklabelmargin xaxisstretch gridaddwidgetxaxis row col xaxislinkviewviewbox yaxis sceneAxisWidgetorientationleft axislabelY Axis axisfontsize axislabelmargin ticklabelmargin yaxisstretch gridaddwidgetyaxis row col yaxislinkviewviewbox add a line plot inside the viewbox line sceneLinenpasarraypos color parentviewboxscene autoscale to see the whole line viewboxcamerasetrange number startingRange def updateev global pos color line number startingRange number posappend number randomrandom linesetdatanpasarraypos color ifnumber startingRange viewboxcamerasetrangestartingRange number timer appTimer timerconnectupdate timerstart if name main and sysflagsinteractive apprun The slow down I m guessing is due to the addition of data to the line but if I can remove the old data like you are doing for ScrollingLineVisual then there wouldnt be any FPS drop as far as I can see Currently if someone generates a line plot with no markers for instance python line sceneLinePlotxy markersize and then later updates the data with python linesetdataxy the markers come back This PR modifies the behavior of LinePlotVisual visual slightly to store the styles set during init or calls to setdata such that styles do not need to be repeatedly given to setdata if one only wants to update the data itself Refer to documentation on the website instead Hi folks despite the documented limitations Im giving vispy under JupyterLab a try having installed both via conda But already the very first statement vispyuseipynbwebgl fails with vispy being unable to find the module vispyglooglwebgl which as far as I understood is indeed inexistent I have attached the traceback as well as the conda package list JupyterLab extensions are app dir usrlocalanaconda sharejupyterlab jupyterwidgetsjupyterlabmanager v enabled OK jupytermatplotlib v enabled OK jupyterlabplotly v enabled OK plotlywidget v enabled OK vispy v enabled OK vispyuseTracebackpdf condalisttxt This PR adds an interpolation property to the Volume visual and exposes a nearest and linear It defaults to the linear behavior which is what is currently supported but provides the option for a nearest which is particularly useful when viewing discrete say integer labeled regions in D Before with linear origlinearinterpolation Now with nearest better Dlabels You can see these in use here too This PR adds documentation for the new property and a test for it This PR improves the isosurface rendering in the volume visual by getting rid of the default greenish tinge that was always being applied and allowing the isosurface to also respond to the changing of the colormaps You can see it in action here and below Original behavior origisosurface Improved behavior betterisosurface I realize this change will change how peoples renderings currently look but I hope the majority of people will find the new behavior and improvement It appears that as currently implemented double press events die at the canvas and must be manually passed to the viewboxes in the canvas by doing canvas MyCanvaskeysinteractive vb ViewBoxparentcanvasscene add a double click emmitter to the viewbox vbeventsaddmousedoubleclickEvent connect the processmouseevent method to the mousedoubleclick emitter in canvas canvaseventsmousedoubleclickconnectcanvasprocessmouseevent where MyCanvas subclasses Canvas and overrides processmouseevent to change the line delivertypes mousepress mousewheel to delivertypes mousepress mousewheel mousedoubleclick Is this an intentional design decision If not the above fix would be easy to implement in the source adding a mousedoubleclick event to the viewboxes by default and connecting the modified processmouseevent to the canvas mousedoubleclick emitter Hi Im performing matrix multiplication on the GPU using pyopencl and pyclblas to reduce a nx matrix to a nx matrix via a x projection matrix Im using the gloo program to draw my visuals Because the vispy Buffer and the pyopencl Buffer are somewhat different I have to transfer the result from the GPU to the CPU through pyopencl and then vispy transfers it back into the GPU Is there anyway I can convert the pyopencl Buffer to the vispy Buffer so that this unnecessary data transfer doesnt happen