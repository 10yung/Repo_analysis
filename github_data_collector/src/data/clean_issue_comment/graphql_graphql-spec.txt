Resolves This change adds the proposed addition by leebyron from It seems to me that forgot to update Interfaces grammar There should be ImplementsInterfaces token like one in Objects The URL no longer works It redirects to which appears identical to There is a Spec link at the top that just continues the same cycle in SQL we can use the SQL IN operator SELECT FROM table WHERE tablekey IN UNNEST keylist where keylist is an array of keys like source the UNNEST operator converts from array to vertical vector the keys are random not adjacent not predictable similar to a serverside pagination cursor so we can say client cursor use case in graphQL parallel pagination broad first search breadthfirst search and dealing with read only servers we cannot change the server schema workaround using a list of N keys we can repeat the same selector subquery for N times and append the key index to all variable names code sample in javascript with the compound key repoOwner repoName js const url basic authentication only for testing const username yourgithubusername const password yourgithubpassword query object const qObj variables repoOwner graphql repoName graphqlspec repoOwner graphql repoName graphqljs query query repoOwner String repoName String repoOwner String repoName String r repository owner repoOwner name repoName nameWithOwner pushedAt createdAt stargazers totalCount r repository owner repoOwner name repoName nameWithOwner pushedAt createdAt stargazers totalCount send query const headers new Headers Authorization Basic btoausernamepassword ContentType applicationjson Accept applicationjson fetchurl method POST headers headers body JSONstringifyqObj thenr rjson thenresponse print response consolelogresponse JSONstringifyresponse null result txt response data r nameWithOwner graphqlgraphqlspec pushedAt T Z createdAt T Z stargazers totalCount r nameWithOwner graphqlgraphqljs pushedAt T Z createdAt T Z stargazers totalCount this selector repository owner repoOwner repoOwner name repoName repoName is not supported by the server List dimension mismatch on variable varname and argument name String String the fields repository repositry must be renamed to r r otherwise i get Field fieldname has an argument conflict on stackoverflowcom i posted some more code to generate such concat queries inspired by Batching queries with GraphQL Python by Julien Danjou questions am i reinventing the wheel here and just too blind to see a better solution are there plans to implement such a feature i could not even find a similar request implementation sketch add a repeat directive pseudoobject block container js const qObj variables repoOwner graphql graphql repoName graphqlspec graphqljs constVar query query repoOwner String repoName String constVar Int repeat this block for all keys for the longest array fill shorter arrays repeat repository owner repoOwner name repoName pushedAt stargazers totalCount sampleobjectarg constVar It would be very useful if we can get an introspection endpoint where we can get a response of the full nested tree object for all used subtypes of a type for example if we have a type called Page and inside we have the id and status which are just scalars but for example we have a title field which can be multilanguage so we create a type called LocaleContent which have subfields like locale and content all good just one stage deep but what if we got a type called Seo and inside we have a field called description which is also multilanguage and so on it would be great to have at least a single point we can recursively fetch the complete data structure of a type without knowing what is inside the type if we cant have that we all are ending up writing an introspection type query which is th of lines long which is a mess I often use GraphQL to make accessing nested data act more similar to the way it is done with object ie objpropsubproptargetValue Unfortunately GraphQL has no way to say give me targetValue or bust so what I end up doing is requesting a big multilayered object then doing lots and lots of checks to make sure the value is there Something like this const resp await queryGQL Userid Storyid Eventtype beginning timestamp if resp respdata respdataUser respdataUserStory respdataUserStoryEvent throw apiErrCould not find Event It would be really nice to be able do say something like const resp await queryGQL Userid Storyid brackets symbolize where data begins Eventtype beginning timestamp if resp respdata throw apiErrCould not find event const event respdata consolelogIt all started in eventtimestamp As long as a query only has one set of request brackets and none of the layers above it request properties it would be valid And it would really help with digging in quickly to a multilayered data structure As an alternative Im thinking of trying to build a query builder and then adding all sorts of features and watching it never take off then become deprecated which is hardly a solution compared to it being added as a core feature of the query syntax Is this schema correct Inadvertently I redefined the type graphql type Query SendEmailmessageDto EmailMessageDtoInput Boolean input EmailMessageDtoInput url String data String input EmailMessageDtoInput url String data String With probability I guess the answer is NO However does the specification speak explicitly about this I spent a lot of time to find the source of error in one of out services running graphqldotnet package It turned out that the error was due to the fact that the type was redefined in the service SDL Now I think where it is worth doing the type check at the graphqldotnet level or at the graphqlparser lower level graphqldotnet uses parsed SDL document from graphqlparser In general I am inclined to do a check in both places I just want to get confirmation that this situation is really unacceptable Im not submitting a detailed proposal or PR because Im not sure if this even makes sense Maybe theres some other way to already alleviate my concern which is the need of creating too many types The basic problem I often create a query that returns an array but has other metadata attached to that array So what I would like to make life is easier is something like graphql type ReportReasons category String reasons id ID title String body String Otherwise I have to always create separate types Or maybe theres a way to create some kind of generic type that I can then reuse for all queries that have a similar structure How do other people deal with queries that return complex structures like array or arrays etc This PR contains the specification changes needed for 