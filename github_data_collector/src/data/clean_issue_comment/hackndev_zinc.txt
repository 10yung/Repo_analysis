I know its early days and other MCU support is coming but the HiFive seems like an awesome potential target platform for something like this At the moment there is a gcc g toolchain you can build binaries for RISCV with and load them onto the HiFive with openocd I was looking through the repository and couldnt find any mentions about other peripherials on the MCU specifically ADC Is it possible to use these now If not how hard would it be to add it and where should I start Fix Obvously k is still a special case but I think this gives a good base on which to build a generator that will work generically accross all supported MCUs We still have to track the k layout in I would make an attempt but I dont have a k board or anything so maybe bgamari could take a look at some additions to this generator I think the way forward is to have like flashconfig Option McuFlashConfig in McuLayout and then struct McuFlashConfig elsewhere but that could be a naive solution that I just came up with at first glance Most of the iomemld stuff can be moved in to native rust I think ping farcaller We can just have them as rust statics that get changed to static references to their actual types This is what I see for a lot of the newer register code Is there a downside to doing this farcaller As for this would allow us to completely do away with mcuspecific linker scripts with the exception of maybe k Also kinda related to as this as long as its cost will help us phase out a huge amount of our extern static usage Well need to comply with the new safeexternstatics lint Its currently set to warn by default but thats going to change Upstream issue in rust rustlangrust Hey farcaller this is only an idea its not for merging What do you think about using features to select not only the chip family but to select the available hardware features The user would use his exact model number as a feature eg mcmk dx vlq and the feature system would use the Cargotoml to select all available hardware parts at least the K family and even the Kxx family are build to be software compatible It would also use the features to select the appropiate linker scripts using the correct flash sizes Also shortcuts for popular boards are possible eg boardteensy That is the one I have D This would also allow to use a special pin number assignment for these arduino like boards since their pins are labeled with a different enumerating system Im using some free time to make my teensy more rust compatible But maybe you have some Ideas for zinc and no time to implement them play with them I would be happy to chat about zinc with you Im not yet an expert with all of this but I am going to be D PS Currently all methods in traits describing hardware classes such as GPIO pins and SPI bus interfaces use nonmutable self pointers This might cause problems with two or more consumers meddling with hardware state at the same time and getting into race conditions for example which are going to be very hard to diagnose at some point I have a suggestion to make the methods require mut self pointers except for those which are generally threadsafe and more importantly guaranteed to not change hardware state What this means is that operations such as send receive since it shifts buffer registers write pin state change pinmux configuration etc should require mutability of the corresponding hardware resource However peek get buffer contents without shifting it read pin state get current time and similar operations may be made to work with nonmutable resources Also in case of devices depending on underlying lowerlevel resources for example most realtime clocks and onboard sensors using buses such as I C or SPI the device driver owning mutable references to those resources may expose methods which dont require mutability for operations which dont change the overall hardware state except for lower level bus registers etc abstracted away by the driver The driver however should ensure thread safety of those methods via locking mechanisms atomicity guarantees and whatnot This is one of the topics I want to discuss as part of RFC party and I finally cleaned up code enough to share it api doc provides a Cargoized hal layer for single MCU family actually only ioregs now Its generated with yasha with some modifications most notably additional renamingcleanup step you can see the modification rules here It also fixes and makes few modifications to the layout most notably it supports sparse peripherals by addressing not the peripheral but individual registers Pinging in bgamari xc bharrisau kvark posborne mcoffin and errordeveloper Are you in for a few hours of discussion on project goals What to discuss switching to rustfmt switching from ioreg macro to pregenerated code Ill try hard to submit the demo tomorrow to show pros and cons zinc as part of cratesio infrastructure do we want to split stuff into crates something else Putting out a feeler I think using the standard style is probably a good idea and makes contributing easier in addition to making my emacs configuration easier rustfmt can probably do a majority of the work although it still needs some handholding in my experience to prevent it from going in the weeds in edge cases With cargo install we can be rustfmting in no time I dont think there are too many major outstanding PRs that would need to be reworked so now seems as good a time as any to make the switch if this suggestion is amenable 