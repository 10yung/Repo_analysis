 I see these codes in the maingo authorRepo authorRepoNewMysqlAuthorRepositorydbConn ar articleRepoNewMysqlArticleRepositorydbConn timeoutContext timeDurationviperGetIntcontexttimeout timeSecond au articleUcaseNewArticleUsecasear authorRepo timeoutContext articleHttpDeliverNewArticleHttpHandlere au I think if articleUcase need articleRepoarticleAuthorRepo and more other repository Dependency management will be terrible it will produce many codes like newAriticleUseaCaseARepoBRepoCRepoSo if it can be more elegant I dont think write in the maingo is a good idea Hello everyone who reads this and maybe who also used my proposed architecture in Go Thank you very much for the feedback that I received so far Just to be honest Im very new here in the architecting software worlds So Id rather call it folder structure rather than architecture As we know software architecture is not just a single application but a whole business that architected into one or many applications Actually for the current version in the master branch when I made this PR nothing wrongs By far this project structure solved many cases of my projects But in this recent months I try several improvements also with looking at other peoples architecture in Go so now I decide to introduce a domain package In my current structure we will find something like this models articlego authorgo errorsgo article delivery http articlehandlergo articletestgo mocks ArticleRepositorygo ArticleUsecasego repository Encapsulated Implementation of Repository Interface mysqlarticlego mysqlarticletestgo repositorygo Repository Interface usecase Encapsulated Implementation of Usecase Interface articleucasetestgo artilceucasego usecasego Usecase Interface So there are will be many packaged module like author article that contains the implementation and also the contract ArticleUsecase ArticleRepository AuthorRepository So just out of curiosity I tried a new improvement that proposed by Ben Johnson here the domain package But instead of to move it into the root project Id rather move it into a single domain just for the sake consistency with my previous layout that using package models So in my previous layout I used models and now I renamed it to domain then move all the interface contract Usecase and Repository into this domain package So it will be more like this domain mocks ArticleRepositorygo AuthorRepositorygo ArticleUsecasego articlego authorgo errorsgo article delivery http articlehandlergo articletestgo repository Encapsulated Implementation of Repository Interface mysql mysqlarticlego mysqlarticletestgo usecase Encapsulated Implementation of Usecase Interface articleucasetestgo artilceucasego I dont know yet is this new layout better than the current layout I used But Ill try to use this new layout for my projects If anything happens then this PR will be closed But if its good and more comfortable for the developer to use it then Ill merge this to the branch master D hr Anyway if youre a Golang Engineer too Id like to hear your opinion about this new proposed layout D Hey thanks for the great work of showing how to apply clean architecture in Go I have a few questions with some more complicated situations and Id like to hear your thought about them Q Who should handle DB transaction According to the answer in you mentioned the transaction must be done in Repository layer However if the use case is When a new article is created a relation between article and author must be created Does article repository also create the junction record Q Who should handle cache Its very common to see that service has a find from cache first or fallback to DB query Does repository handles this logic or use case layer should does this Q Imagine there are other services want to subscribe article created event which layer should be responsible for publishing this event Thanks