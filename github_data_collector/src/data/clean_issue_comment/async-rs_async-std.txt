This was previously discussed in and others as a source of high CPU load when sleeping tasks because of the overhead created by retrying a future in short succession Personally Ive noticed this behaviour as well but wasnt able to recreate test settings since making this change yet Maybe someone else has some good benchmarks to run I was reading through filers trying to figure out how exactly this stuff works on the inside I think I found a couple of problems with reading files and JoinHandle not entirely sure I may be missing a detail or two that explain this all away but it seems possible enough that I found some issues here worth bringing up that Im willing to look stupid if Im completely wrong Im going to ping stjepang and yoshuawuyts as it seems you two are the ones who actually wrote this First off is something suspicious on line Seems like we shouldnt run the following code on isempty Probably should be an immediate return PollReadyOk in that scenario On line a blocking task is spawned and the JoinHandle is immediately dropped It isnt ever properly polled I am assuming we at least dont poll immediately because it will never have been completed anyways so its not worth the cost of pinning it and returning its Poll result because it will always just be PollPending unless a miracle occurs Without the ability for the JoinHandle to actually call wake when its Task is done we have the current situation Basically after we start reading to the cache with spawnblocking were done running pollread so we drop the LockGuard which will unlock the Mutex and wake up everyone who was registered as a listener on the file lock In the case that there isnt anything else going on for our executor to run were then immediately going to be woken back up the lock is going to be attained again and were going to check if there is anything to read from the cache If there isnt we just keep dropping unlocking waking locking and checking repeatedly until there is What it seems should be happening is that when the JoinHandle from spawnblocking is polled it would like the docs say call Wakerwake on the provided Contexts Waker when it has completed The problem is that JoinHandle doesnt do this and doesnt store the waker anywhere like a Future is supposed to It just returns PollPending and thats it Then we could get rid of the waking that occurs when dropping the LockGuard and the blocking task will just do the waking Another possibility would be I think using actual platformspecific events for IO although the issues with JoinHandle would still exist for users of spawnblocking There also seem to be a couple other holes in the file read logic This may be worthy for another issue If you think so Ill move the rest of whats here over Since were setting the caches length and reading into it and the cache is the same for all operations on the file we could be changing this while another read is happening or even writing to the cache two times at once interleaving the data After all we only have mutable access to the cache because the LockGuard has unsafe implementations of Deref With the current way the logic associated with locking works this would be extremely rare because basically another pollread would have to happen before we got to the point of registering ourselves before them The chances of that are very slim but its still possible It would be a much larger issue though if you go the route of having the JoinHandle call wake when its done because the order of the tasks being woken wouldnt just be FRFW First Registered First Woke any more Anyways thanks for your work on the project so far Its a nice codebase I have been able to traverse and understand very easily Its far easier to read this than tokio and asio If not for the structure of this project I wouldnt have been able to find these things in the first place Im a beginner with async and have only been using rust for about a year so the fact that Im able to delve into this codebase should speak volumes about its quality close The following three modules have been changed to work with nostd task future stream Could we keep a list of what libraries work with asyncstds pluggable runtimes In particular the tokio ecosystem seems somewhat closed in that those libraries often require tokio to operate As a user its confusing because many of these libraries are not clear about whether they require tokio For example I asked about using hyper with asyncstds runtime maybe its just me but I found the response hard to understand My use case is that I use a custom runtime for running tests and I want my release binaries to use asyncstds new runtime that automatically handles blocking threads Thanks In the implementation of TcpStreamconnect was switched from using mios nonblocking connect to the blocking stdnetTcpStreamconnect which is performed in a background thread created by spawnblocking May I ask why you decided to no longer use mios nonblocking connect It seems the background thread spawned is unaware of any future cancellation eg due to timeouts but continues to run until all SYN retries have been exhausted which may easily last a couple of minutes This in turn can cause a high number of threads to be created in the background It seems like proc macros dont work in doctests test srclibrs line FAILED test srclibrs line FAILED test srclibrs line FAILED error E failed to resolve could not find main in asyncstd srclibrs asyncstdmain could not find main in asyncstd The problem is visible when running cargo test all Tested on Rust and nightly There is currently no example for stream timeout when it times out I thought it was good to add Consider providing additional methods to configure socket SOREUSEADDR SOLINGER I refrain from using asyncstd due to their absence You can check these options in socket We should pin asynctask to to include and together adding nostd support We should also document how to enable nostd support in asyncstd cc skade jamesmunns 