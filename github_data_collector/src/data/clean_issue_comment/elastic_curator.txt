 To submit a bug or report an issue When doing reindex occasionally in of cases I get Failed to complete action reindex type exceptionsKeyError indices Expected Behavior The task I have is quite simple I get all index names that are readonly and then one by one for each index I create I new index with needed settings I start reindex task I delete source index I do it with AWS Elasticsearch It works as it should but sometimes fails Actual Behavior The task runs fine but sometimes I could only connect it with big number of running reindex tasks I get INFO Trying Action ID reindex Reindex arkr node ERROR Failed to complete action reindex type exceptionsKeyError indices As I have a lot of reindex tasks I get such error times out of and this is oncce in an hour Theres no pattern it could be any index at any time The index could be Mb could be Gb It always reindexes from primary replica to primary replica index Specifications AWS ES Curator Context Environment Can we somehow catch this error and do retry Maybe it is happening because index for reindex is in process of creation and we can add delay option Or maybe theres even a way to catch the verbose output to define the reason Proposed Changes The instructions for installing from source dont specify which github repository or project to download the tarball from theres just a generic usernameproject in the url Changed to show the actual username elastic and the project curator Hi I am creating this ticket for requesting a new feature on the curator side Often there are cases when ElasticSearch indices are converted to readonly mode For cases where indices are rarely queried enabling replicas often seems be a costly option If the snapshotrestore feature is enabled those indices can be easily restored back from the backups Currently I dont see a way to define rules inside curator file to automatically restore indices from the last backup if they move to UNASSIGNED state What are your thoughts about implementing this functionality on the curator end Running the following command curatorcli config curatoryml showindices filterlist filtertypeage sourcefieldstats directionolder unitdays unitcount fieldtimestamp statsresultminvalue I think this is triggered by this check which expects an action Expected Behavior Test the filter with no error shown Actual Behavior I get the following errors while validating the filter DEBUG curatorclisingletonscliactionshowindices checkfilters Validating provided filters udirection uolder ustatsresult uminvalue ufield utimestamp ufiltertype uage usource ufieldstats uunitcount uunit udays DEBUG curatorvalidatorsSchemaCheck init Schema function f at x e DEBUG curatorvalidatorsSchemaCheck init filters config udirection uolder ustatsresult uminvalue ufield utimestamp ufiltertype uage usource ufieldstats uunitcount uunit udays DEBUG curatordefaultsfiltertypes age AGE FILTER direction Anyolder younger msgNone unit Anyseconds minutes hours days weeks months years msgNone unitcount Coerceint msgNone unitcountpattern Anytype basestring msgNone epoch AnyCoerceint msgNone None msgNone exclude Anytype bool AllAnytype basestring msgNone function Boolean at x f msgNone msgNone source Anyname creationdate fieldstats msgNone timestring AnyNone type basestring msgNone DEBUG curatorvalidatorsSchemaCheck init Schema source Anyname creationdate fieldstats msgNone direction Anyolder younger msgNone timestring AnyNone type basestring msgNone exclude Anytype bool AllAnytype basestring msgNone function Boolean at x f msgNone msgNone filtertype AnyIn age alias allocated closed count empty forcemerged ilm kibana none opened pattern period shards space state msgfiltertype must be one of age alias allocated closed count empty forcemerged ilm kibana none opened pattern period shards space state unitcount Coerceint msgNone epoch AnyCoerceint msgNone None msgNone unit Anyseconds minutes hours days weeks months years msgNone unitcountpattern Anytype basestring msgNone DEBUG curatorvalidatorsSchemaCheck init filter config udirection uolder ustatsresult uminvalue usource ufieldstats ufiltertype uage ufield utimestamp uunitcount uunit udays ERROR curatorvalidatorsSchemaCheck result Schema error extra keys not allowed data ustatsresult ERROR curatorvalidatorsSchemaCheck result Schema error Configuration filter Location singleton filter udirection uolder ustatsresult uminvalue usource ufieldstats ufiltertype uage ufield utimestamp uunitcount uunit udays Bad Value could not determine extra keys not allowed data ustatsresult Check configuration file CRITICAL curatorclisingletonscliactionshowindices checkfilters Unable to parse filters Configuration filters Location showindices singleton action filters Bad Value None Configuration filter Location singleton filter udirection uolder ustatsresult uminvalue usource ufieldstats ufiltertype uage ufield utimestamp uunitcount uunit udays Bad Value could not determine extra keys not allowed data ustatsresult Check configuration file Check configuration file The printed schema doesnt include the statsresult while it should be allowed as per documentation Schema source Anyname creationdate fieldstats msgNone direction Anyolder younger msgNone timestring AnyNone type basestring msgNone exclude Anytype bool AllAnytype basestring msgNone function Boolean at x f msgNone msgNone filtertype AnyIn age alias allocated closed count empty forcemerged ilm kibana none opened pattern period shards space state msgfiltertype must be one of age alias allocated closed count empty forcemerged ilm kibana none opened pattern period shards space state unitcount Coerceint msgNone epoch AnyCoerceint msgNone None msgNone unit Anyseconds minutes hours days weeks months years msgNone unitcountpattern Anytype basestring msgNone System Version curatorcli version Platform Python Fixes I am not sure if we support the options it should as they are the default additional options Let me know if I should squash the commits Proposed Changes Addfix examples for freezeunfreeze Add documentation on the action page for freezeunfreeze building escurator without cxFreeze causes Traceback most recent call last File setuppy line in module from cxFreeze import setup Executable ModuleNotFoundError No module named cxFreeze because the tryexcept at matches ImportError not ModuleNotFoundError please extend it to cover both exceptions likely the second comes from a reorg of exceptions in python A common use case when shrinking indices consists of creating aliases of the shrunk indices using the names of the original indices The extrasetting aliases available is not clear in the docs and the purpose of it when using the shrink action to shrink multiple indices is not clear also It would be great if curator is able to create an alias using the original name of the index after having deleted the original index deleteafter True should be mandatory for this to happen This could easily be applied when the action is used to shrink multiple indices as one alias will be created for every shrunk deleted index For usage questions and help Please create a topic at Perhaps a topic there already has an answer for you To submit a bug or report an issue Provide a general summary of the issue in the Title above shrink using curator python never completes and the cluster status goes to unassigned shards AWS support explanation Cause of the issue From ES Elastic deprecated the use of copysettings parameter in the shrink api call and made copysettingstrue as the default value There is no way to modify this parameter anymore Reference copysettings allows users to specify whether they want the target index shrunken index to have the same index settings as the source index Now with copysettings set to true in the shrink api calls for x ES clusters all the index settings from the target index including indexroutingallocationrequirename and indexblocksreadonly are also copied down to the target index The above setting forces ES to assign shards of target index to a specific node that is defined in indexroutingallocationrequirename but with replicas enabled ES cannot allocate replica of a primary shard onto the same datanode So Cluster settings prevent ES from allocating replicas onto the same datanode as primaries and index settings prevent the shards to be allocated to any other node but indexroutingallocationrequirename value Previously these settings were never inherited down to the shrunken indices as they the workaround is to Step Update the source index routing setting to a specific node and block all writes Step Perform Shrink operation Step Remove routing and write block settings from the shrunken index the workaround works but I loose the benefit of using curator shrink DETERMINISTIC option automatically determines the node with most free space anyone successfully ran shrink using curator on x ES AWS cluster without any workarounds Expected Behavior Tell us what should happen single call to shrink method worked on x versions of ES but the same fails on ES x Actual Behavior Tell us what happens instead of the expected behavior the method hangs and the cluster state changes to unassigned shards Steps to Reproduce the Problem Provide a link to a live example or an unambiguous set of steps to reproduce this bug Include code to reproduce if relevant call shrink with DETERMINISTIC option and it the operation never completes Specifications Version x PlatformAWS managed service Subsystem Context Environment How has this issue affected you What are you trying to accomplish we have a shrink and merge python script built on top of Curator and that works for ES x and with x Shrink breaks Providing context helps us come up with a solution that is most useful in the real world Provide a general summary of the issue in the Title above Detailed Description Provide a detailed description of the change or addition you are proposing Expected Behavior During a shrink action curator checks the cluster health If the cluster health is yellow wait for a short period and check if the cluster recovers to continue Actual Behavior During a shrink action curator checks the cluster health once if that fails curator is halted Detailed Description We typically run curator once a day in the early hours and see sporadic failures due to cluster health The majority of the time is bad timing an index was created at the same time a shrink action occurs Were typically shrinking indices in one cluster during one curator run so while its bad timing it does affect us regularly enough to warrant guarding against this I was thinking of changing that health check to use the waitforit health check is this a terrible idea Expected Behavior deletesnapshots action shouldnt fail if theres a readonly snapshotrelated task eg clusteradminsnapshotget Actual Behavior deletesnapshots action fails with the following error Failed to complete action deletesnapshots class curatorexceptionsFailedExecution Unable to delete snapshots because a snapshot is in state INPROGRESS Steps to Reproduce the Problem Execute longneverending readonly snapshotsrelated requests Execute Curator with a deletesnapshots action Specifications Version Platform Docker on Ubuntu Subsystem Python Context Environment We have a scheduled retention job for our ES backups it started to fail on one of our clusters recently with the error mentioned above According to Curators code it might happen if there are snapshots in progress or if theres an active snapshotrelated task In our case there are no snapshots in progress but there are active clusteradminsnapshotget tasks all the time Were still investigating the source of those tasks it didnt happen before but it shouldnt block Curator from deleting snapshots IMO Detailed Description Were able to delete snapshots using the ES API directly so unless theres a good reason to block this action on all snapshotrelated tasks I think its safe to exclude readonly tasks here Not sure if only clusteradminsnapshotget tasks should be excluded or there are more potential tasks worth excluding WDYT 