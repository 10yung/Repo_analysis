This may require some additional code changes due to the changes in the Scala collections API Scala M was already added here But there is no release at this point addresses again This suite produces the following exceptions Reporter completed abruptly with an exception after receiving event TestStartingOrdinal JavaAPITestsscalaconcurrentstmJavaAPITestsSomescalaconcurrentstmJavaAPITestsatomicWithCallableatomicWithCallableSomeMotionToSuppressSomeTopOfMethodscalaconcurrentstmJavaAPITestspublic void scalaconcurrentstmJavaAPITestsatomicWithCallableNoneNonepool thread javautilNoSuchElementException key not found scalaconcurrentstmJavaAPITests at scalacollectionMapLikedefaultMapLikescala at scalacollectionMapLikedefaultMapLikescala at scalacollectionAbstractMapdefaultMapscala at scalacollectionmutableHashMapapplyHashMapscala at orgscalatesttoolsSuiteSortingReporterhandleTestEventsSuiteSortingReporterscala at orgscalatesttoolsSuiteSortingReporterdoApplySuiteSortingReporterscala at orgscalatestCatchReporterapplyCatchReporterscala at orgscalatestCatchReporterapplyCatchReporterscala at orgscalatesttoolsSuiteSortingReporterapplySuiteSortingReporterscala at orgscalatesttoolsFrameworkSbtReporterapplyFrameworkscala at orgscalatestjunitMyRunListenertestStartedMyRunListenerscala at orgjunitrunnernotificationSynchronizedRunListenertestStartedSynchronizedRunListenerjava at orgjunitrunnernotificationRunNotifier notifyListenerRunNotifierjava at orgjunitrunnernotificationRunNotifierSafeNotifierrunRunNotifierjava at orgjunitrunnernotificationRunNotifierfireTestStartedRunNotifierjava at orgjunitinternalrunnersmodelEachTestNotifierfireTestStartedEachTestNotifierjava at orgjunitrunnersParentRunnerrunLeafParentRunnerjava at orgjunitrunnersBlockJUnit ClassRunnerrunChildBlockJUnit ClassRunnerjava at orgjunitrunnersBlockJUnit ClassRunnerrunChildBlockJUnit ClassRunnerjava at orgjunitrunnersParentRunner runParentRunnerjava at orgjunitrunnersParentRunner scheduleParentRunnerjava at orgjunitrunnersParentRunnerrunChildrenParentRunnerjava at orgjunitrunnersParentRunneraccess ParentRunnerjava at orgjunitrunnersParentRunner evaluateParentRunnerjava at orgjunitrunnersParentRunnerrunParentRunnerjava at orgjunitrunnersSuiterunChildSuitejava at orgjunitrunnersSuiterunChildSuitejava at orgjunitrunnersParentRunner runParentRunnerjava at orgjunitrunnersParentRunner scheduleParentRunnerjava at orgjunitrunnersParentRunnerrunChildrenParentRunnerjava at orgjunitrunnersParentRunneraccess ParentRunnerjava at orgjunitrunnersParentRunner evaluateParentRunnerjava at orgjunitrunnersParentRunnerrunParentRunnerjava at orgjunitrunnerJUnitCorerunJUnitCorejava at orgjunitrunnerJUnitCorerunJUnitCorejava at orgjunitrunnerJUnitCorerunJUnitCorejava at orgjunitrunnerJUnitCorerunJUnitCorejava at orgscalatestjunitJUnitWrapperSuiterunJUnitWrapperSuitescala at orgscalatesttoolsFrameworkorgscalatesttoolsFrameworkrunSuiteFrameworkscala at orgscalatesttoolsFrameworkScalaTestTaskexecuteFrameworkscala at sbtTestRunnerrunTest TestFrameworkscala at sbtTestRunnerrunTestFrameworkscala at sbtTestFrameworkanon anonfuninit anonfunapply applyTestFrameworkscala at sbtTestFrameworkanon anonfuninit anonfunapply applyTestFrameworkscala at sbtTestFrameworksbtTestFrameworkwithContextLoaderTestFrameworkscala at sbtTestFrameworkanon anonfuninit applyTestFrameworkscala at sbtTestFrameworkanon anonfuninit applyTestFrameworkscala at sbtTestFunctionapplyTestFrameworkscala at sbtTestssbtTestsprocessRunnable Testsscala at sbtTestsanonfunmakeSerial applyTestsscala at sbtTestsanonfunmakeSerial applyTestsscala at sbtstdTransformanon anonfunapply applySystemscala at sbtstdTransformanon anonfunapply applySystemscala at sbtstdTransformanon workSystemscala at sbtExecuteanonfunsubmit anonfunapply applyExecutescala at sbtExecuteanonfunsubmit anonfunapply applyExecutescala at sbtErrorHandlingwideConvertErrorHandlingscala at sbtExecuteworkExecutescala at sbtExecuteanonfunsubmit applyExecutescala at sbtExecuteanonfunsubmit applyExecutescala at sbtConcurrentRestrictionsanon anonfun applyConcurrentRestrictionsscala at sbtCompletionServiceanon callCompletionServicescala at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentExecutorsRunnableAdaptercallExecutorsjava at javautilconcurrentFutureTaskrunFutureTaskjava at javautilconcurrentThreadPoolExecutorrunWorkerThreadPoolExecutorjava at javautilconcurrentThreadPoolExecutorWorkerrunThreadPoolExecutorjava at javalangThreadrunThreadjava I have no idea how ScalaTest and JUnit interact here but it seems in SuiteSortingReporter there is maintained a slotMap and it should have a put with scalaconcurrentstmJavaAPITests suiteId somewhere that is probably missing Not sure what is causing this Tests seems to run fine nevertheless Do others agree that it would make some amount of sense to not only have such things as TMap and TSet but also TSortedMap and TSortedSet in the library of Transactional Collections I was looking for an STM I could use in Java and originally dismissed ScalaSTM as it did not mention Java anywhere until I later found the JavaAPITestsjava It would be nice to mention the existence of the Java API in the documentation preferably visibly on the welcome page and perhaps under FAQ and to provide an example the JavaAPITests would be a good start Thank you on behalf of all us stuck with Java The current CommitBarrier implementation has complex interactions with CCSTMs contention management and forward progress guarantees and requires separate cycle detectors The fundamental issue is that it violates the atomic block priority assumptions used by the contention management algorithm and blocks transactions after they have become uncancelable Ive put in several workaround for this but this is turning into whackamole and injecting complexity deep into the core As of f ae fd b e a aa a d there can still be deadlock cycles that traverse multiple transactions and multiple commit barriers We need to revamp this design to have simpler correctness reasoning The current implementation isnt robust so it is likely that nobody depends on it Possible strategies run all members at the same priority and roll all of them back if any of them roll back block members in the Preparing state until all of them are ready so that they dont wait in an uncancelable state TxnLocals afterCommit handler provides the user with the last contained value afterRollback and afterCompletion should probably do the same thing Currently you can work around this by explicitly registering a TxnafterCompletion handler inside TxnLocalinitialValue but the API should make this easier This will require a change to the API Not sure if there is a clean backward compatible way Whilecommitting callbacks happen after the commit decision but before the effects of the transaction have become visible We should extend the CommitBarrier semantics so that no effects from any commit barrier member become visible until all of the whilecommitting callbacks have completed One way to do this would be to add another callback method to the ExternalDecider trait perhaps endCommitting The commit barrier implementation would then perform a second barrier at this point Various optimizations are possible if the second barrier only has arrivals for members that are known to have whilecommitting callbacks 