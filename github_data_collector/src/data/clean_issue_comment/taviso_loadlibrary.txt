Does this project support loading custom DLLs to linux Hello can this project be Porting to Windows win System I would like to run the mpclient application on a windows system consol Without Windows Defender Installed Without MsMpEng service on Windows Can I build the mpclient together in Visual Studio if yes how thx When I try to compile it via make I get this error usrbinld skipping incompatible usrlibgccx linuxgnu libgcca when searching for lgcc usrbinld cannot find lgcc GPLlicensed libs are unsuitable for any use in software under other licenses I am trying to load one commercial DLL peloadlibrary successfully mapped Importres dll xf b pelinker import unknown symbol KERNEL dllLoadLibraryA pelinker import unknown symbol KERNEL dllSleep pelinker import unknown symbol KERNEL dllExitProcess pelinker import unknown symbol KERNEL dllTerminateProcess pelinker import unknown symbol KERNEL dllUnhandledExceptionFilter pelinker import unknown symbol KERNEL dllSetUnhandledExceptionFilter pelinker import unknown symbol KERNEL dllIsDebuggerPresent pelinker import unknown symbol KERNEL dllHeapDestroy pelinker import unknown symbol KERNEL dllFreeEnvironmentStringsA pelinker import unknown symbol KERNEL dllGetEnvironmentStrings pelinker import unknown symbol KERNEL dllGetOEMCP pelinker import unknown symbol KERNEL dllGetLocaleInfoA pelinker import unknown symbol KERNEL dllGetConsoleCP pelinker import unknown symbol KERNEL dllGetConsoleMode pelinker import unknown symbol KERNEL dllFlushFileBuffers pelinker import unknown symbol KERNEL dllLCMapStringA pelinker import unknown symbol KERNEL dllWriteConsoleA pelinker import unknown symbol KERNEL dllGetConsoleOutputCP pelinker import unknown symbol KERNEL dllWriteConsoleW pelinker import unknown symbol KERNEL dllSetStdHandle DllMain HeapCreate GetModuleHandleW xf dc KERNEL DLL GetProcAddress FIXME FlsAlloc unresolved GetProcAddress FIXME FlsGetValue unresolved GetProcAddress FIXME FlsSetValue unresolved GetProcAddress FIXME FlsFree unresolved TlsSetValue TlsSetValue x b GetModuleHandleW xf dc KERNEL DLL EncodePointer nil GetModuleHandleW xf dc KERNEL DLL EncodePointer xf e GetModuleHandleW xf dc KERNEL DLL EncodePointer xf c f GetModuleHandleW xf dc KERNEL DLL EncodePointer xf GetModuleHandleW xf dc KERNEL DLL EncodePointer x b GetModuleHandleW xf dc KERNEL DLL EncodePointer x c GetModuleHandleW xf dc KERNEL DLL EncodePointer x b GetModuleHandleW xf dc KERNEL DLL DecodePointer x bcaf f GetModuleHandleW xf dc KERNEL DLL DecodePointer xa e ef TlsSetValue TlsSetValue x c GetModuleHandleW xf dc KERNEL DLL InterlockedIncrement xf c c InterlockedIncrement xf c f InterlockedIncrement xf c b GetProcAddress xf c null test winapiLoadLibraryc GetProcAddress Assertion hModule HANDLE NULL hModule HANDLE LOAD hModule HANDLE MPEN hModule HANDLE VERS hModule HANDLE KERN failed Aborted I added following code to check why I got assertion static PVOID WINAPI GetProcAddressHANDLE hModule PCHAR lpProcName ENTRY key lpProcName item if lpProcName NULL DebugLog p s hModule lpProcName Do you have any idea why hModule points to somewhere allocated inside the process In order to learn how to use the loadlbrary library with the goal of accessing a commercial win library from linux I started off with a simple hello world example Here are my files sayhelloh ifndef SAYHELLOH define SAYHELLOH void sayhello endif SAYHELLO sayhelloc include stdioh void sayhello printfSay Hello n hellomainc For testing the dll with wine include sayhelloh int mainint argc charargv sayhello The build command of the dll i w mingw gcc o hellomainobj c O mmsbitfields hellomainc i w mingw gcc o sayhelloobj c fPIC O mmsbitfields sayhelloc i w mingw gcc o sayhellodll shared sayhelloobj i w mingw gcc o hellomainexe hellomainobj sayhellodll Testing the dll works wine hellomainexe bfixmewinediagstartprocess Wine Staging rc is a testing version containing experimental patches bfixmewinediagstartprocess Please mention your exact version when filing bug reports on winehqorg Say Hello Now I wanted to load this dll into load library and I started at mpclientc sources and removed as much as I could and then tried to call my sayhello function This is what I got ifndef GNUSOURCE define GNUSOURCE endif include stdioh include stdlibh include stdinth include stddefh include stdboolh include stringh include winnttypesh include pelinkerh include ntoskernelh int mainint argc char argv char envp PIMAGEDOSHEADER DosHeader PIMAGENTHEADERS PeHeader struct peimage image entry NULL name sayhellodll Load the mpengine module if peloadlibraryimagename imageimage imagesize false printfYou must add the dll and vdm files to the engine directory return Handle relocations imports etc linkpeimages image Fetch the headers to get base offsets DosHeader PIMAGEDOSHEADER imageimage PeHeader PIMAGENTHEADERSimageimage DosHeaderelfanew Try calling into the library void SayHelloPtr if getexportsayhello SayHelloPtr SayHelloPtr else printfFailed getting pointer to sayhello n return It coompiles the dll loads the sayhello symbol is found but it then crashes at SayHelloPtr What did I miss Thanks Hi Amazing work there mate thanks a lot I was just trying to reproduce the code coverage tool but its not working and im not getting any output from anywhere screenshot its been there more than minutes any ideas why could that be thanks Hello taviso You have a great app unfortunately this app does not have a logo yet may I donate a logo for your app I have a Windows bit DLL PE executable DLL GUI x for MS Windows Will loadlibrary allow me to load this into a bit app built with gcc Or does loadlibrary only work for a bit runtime In winnttypesh both BOOL and BOOLEAN are typedefed as uint t However in actual windows headers BOOL is typedefed as an int and BOOLEAN is an unsigned char so that definition is correct