Hi thanks a great DI container It seems like you might have forgotten to push the newest version to CocoaPods could you do that Thanks Were seeing a crash in DIP when creating the initial view controller which through its references winds up trying to resolve a type which results in a crash This type can be described as such using madeup names to simplify struct Configuration protocol Foo open class SuperClass Foo var configsByUser String Configuration class SubClass SuperClass We register SubClass into the dependency container using the type Foo When we resolve there seems to be a crash at In this specific case it seems to be trying to deal with the property configsByUser above In the debugger I am able to see the following lldb po typeof childvalue SwiftDictionarySwiftString Configuration It seems that the data in the Mirror is neither AutoInjectedPropertyBox nor ImplicitlyUnwrappedOptional Accessing childvalue at all seems to crash as the debugger cannot do anything with it beyond querying the type as far as I can tell I saw that you filed but that doesnt seem to be the same issue Im unsure if this shows a problem with how things are registered or what but I wasnt sure how to chase this further Any input would be greatly appreciated as this error happens very frequently in the simulator which is destroying our automated testing We do not think weve seen this at all on an actual device so that could be another data point Hi enable thread sanitiser in Xcode I used the sample app provided and added this code in application didFinishLaunchingWithOptions after the configure function DispatchQueueglobalqos userInteractiveasync try selfcontainerresolve as PersonProviderAPI i am getting the error below lldb thread info s thread tid xb feba x d libclangrttsaniossimdynamicdylibtsanonreport queue comapplemainthread stop reason Data race detected alladdressesaresame true description Data race instrumentationclass ThreadSanitizer isswiftaccessrace false issuetype datarace locationdescription Location is a byte heap object at x b b locs address filedescriptor index objecttype size start suppressable threadid trace type heap memoryaddress mops address index isatomic false iswrite true size threadid trace address index isatomic false iswrite false size threadid trace mutexes address destroyed index mutexid trace reportcount sleeptrace stacks stopdescription Data race detected summary Data race in closure throws A in DipDependencyContainerinContextAkey DipDefinitionKey injectedInType SwiftOptionalAnyType injectedInProperty SwiftOptionalSwiftString inCollaboration SwiftBool container SwiftOptionalDipDependencyContainer logErrors SwiftOptionalSwiftBool block throws A throws A at x b b tag threads index name parentthreadid running threadid threadosid trace index name parentthreadid running threadid threadosid trace uniquetids fileUsersor wsDipSourcesDipswift runtime Threading Issues Data race in closure throws A in DipDependencyContainerinContextAkey DipDefinitionKey injectedInType SwiftOptionalAnyType injectedInProperty SwiftOptionalSwiftString inCollaboration SwiftBool container SwiftOptionalDipDependencyContainer logErrors SwiftOptionalSwiftBool block throws A throws A at x b b notice Threading Issues Location is a byte heap object at x b b Write of size by thread x b in closure in DependencyContainerinContextAkeyinjectedInTypeinjectedInPropertyinCollaborationcontainerlogErrorsblock at Usersor wsDipSourcesDipswift x in partial apply for closure in DependencyContainerinContextAkeyinjectedInTypeinjectedInPropertyinCollaborationcontainerlogErrorsblock x d in DependencyContainerthreadSafeA at Usersor wsDipSourcesDipswift x fc in DependencyContainerinContextAkeyinjectedInTypeinjectedInPropertyinCollaborationcontainerlogErrorsblock at Usersor wsDipSourcesDipswift x b in DependencyContainerresolvetypetagbuilder at Usersor wsDipSourcesResolveswift x in DependencyContainerresolvetagbuilder at Usersor wsDipSourcesResolveswift x e c in DependencyContainerresolveAtagbuilder at Usersor wsDipSourcesResolveswift x ac in DependencyContainerresolveAtag at Usersor wsDipSourcesResolveswift x dcc in AppDelegateapplicationdidFinishLaunchingWithOptions at Usersor wsDipSampleAppDipSampleAppAppDelegateswift x de c in objc AppDelegateapplicationdidFinishLaunchingWithOptions x b e in UIApplication handleDelegateCallbacksWithOptionsisSuspendedrestoreState x f d in start Read of size by thread x b in DependencyContainerresolvetypetagbuilder at Usersor wsDipSourcesResolveswift x in DependencyContainerresolvetagbuilder at Usersor wsDipSourcesResolveswift x e c in DependencyContainerresolveAtagbuilder at Usersor wsDipSourcesResolveswift x ac in DependencyContainerresolveAtag at Usersor wsDipSourcesResolveswift x ddb b in closure in AppDelegateapplicationdidFinishLaunchingWithOptions at Usersor wsDipSampleAppDipSampleAppAppDelegateswift x ddc in partial apply for closure in AppDelegateapplicationdidFinishLaunchingWithOptions x ddda in thunk for escaping calleeguaranteed x ec in tsaninvokeandreleaseblockvoid x efe c in dispatchclientcallout Heap block allocated by thread x eb in wrapmalloc x d e in swiftslowAlloc x de df in AppDelegateinit at Usersor wsDipSampleAppDipSampleAppAppDelegateswift x de c in objc AppDelegateinit x b in UIApplicationMainPreparations x f d in start Mutex M created x aa in wrappthreadmutexinit x a c in NSRecursiveLock init x fd in NSRecursiveLockallocatinginit x ff fa in DependencyContainerinitautoInjectPropertiesconfigBlock at Usersor wsDipSourcesDipswift x feec in DependencyContainerallocatinginitautoInjectPropertiesconfigBlock x de df in AppDelegateinit at Usersor wsDipSampleAppDipSampleAppAppDelegateswift x de c in objc AppDelegateinit x b in UIApplicationMainPreparations x f d in start please advise Hello Heres the situation I have some singletons which are make sense only if user is logged in So after user is logged out I want to release all those singletons and recreate new instances after the next login To do that Ive separated all those singleton into another container and collaborate it with the main container Then I register singletons on login and clear second container on logout The problem is after I clear the second container singletons are not getting released because main container retains them but I cant resolve them from main container They are released only after next login when I register and resolve them again Is this an intended behavior Code example import UIKit import RxSwift import RxCocoa import Dip public protocol TestClassType class var count Int get public class TestClass TestClassType private static var count Int public let count Int init count TestClasscount TestClasscount print init TestClass count deinit print deinit TestClass count private var container DependencyContainer extension DependencyContainer func registerSessionRelatedStuff printregisterSessionRelatedStuff let container DependencyContainer containerregistersingleton TestClass as TestClassType collaboratewith container container container func unregisterSessionRelatedStuff printunregisterSessionRelatedStuff weak var item try resolve as TestClassType printHere we are still able to resolve type item print reset containerreset container nil let item try resolve as TestClassType printHere we are not able to resolve type anymore item printBut the instance is still alive item var loggedIn BehaviorSubjectBoolvalue false var loggedInDriver loggedInasDriveronErrorDriveWith emptydistinctUntilChanged class ViewController UIViewController IBOutlet weak var button UIButton private var container DependencyContainer private var isWorking BehaviorRelayBoolvalue false private lazy var isWorkingDriver DriverBool isWorkingasDriveronErrorDriveWith emptydistinctUntilChanged private var disposeBag DisposeBag override func viewDidLoad superviewDidLoad loggedInDriverfilter map in driveonNext containerregisterSessionRelatedStuffdisposedby disposeBag loggedInDriverfilter map in driveonNext containerunregisterSessionRelatedStuffdisposedby disposeBag loggedInDrivermap in false driveisWorkingdisposedby disposeBag loggedInDrivermap Logout Login drivebuttonrxtitledisposedby disposeBag isWorkingDrivermapdrivebuttonrxisEnableddisposedby disposeBag buttonrxtapasSignalwithLatestFromloggedInDrivermapdoonNext weak self in selfisWorkingaccepttrue printLoggin IN OUT delay emitto loggedIndisposedby disposeBag loggedInDriverfilter delay driveonNext weak self in guard let self self else return printPrevious instance will only die here try selfcontainerresolve as TestClassType disposedby disposeBag ilyapuchka I added my CoreDataService file so you can reproduce the crash 