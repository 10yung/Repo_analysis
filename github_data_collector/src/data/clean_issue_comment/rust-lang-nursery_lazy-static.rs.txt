Currently its not possible to do rust lazystatic static ref FOO bar MyFooStructnewawait I trying to build a project that uses sdl which depends on lazystatic but Im getting Ctoolsemsdkupstreambin llvmnmexe error C Users Leo Projects rustsnake target wasm unknownemscripten release deps liblazystaticedee b afbrlibrustmetadatabin The end of the file was unexpectedly encountered Isnt this lib supported Im doing something wrong rustc lazystatic I am calling a threadunsafe unix libc function So I have a Mutex in my code to mitigate this issue Linux provides a threadsafe version so its not needed on there So I have the following code rust lazystatic cfgallunix nottargetos linux static ref MYMUTEX stdsyncMutex stdsyncMutexnew This configuration predicate works fine on functions types and even normal statics but when used inside lazystatic I instead get a rather unhelpful expected type found static MYMUTEX error Quoting bluejekyll at The spin dependency is no longer maintained it appears This causes cargo audit to fail on downstream projects I havent had a chance to look into potential fixes Some probably many projects have a cargo audit denywarnings job that will now fail if they depend on lazystatic I have a use case thats similar to lazystatic but that cannot be solved nicely right now If the default initializer to a lazystatic variable is something that wants arguments at initializationtime or is something that can fail then currently the usage is very awkward Of course its possible that Im missing something obvious Im very new to Rust still so apologies in advance if thats the case You may well consider this out of scope for this project wouldnt really be lazy but I wanted to ask before I contemplate if its worth forking the project Basically what I want would look something like this rust lazystatic pub static ref QUOTES QuoteLibrary fn main let filename quotesyaml match QuoteLibraryloadfilefilename allows me to provide arguments to the initializer function Okquotes lazystaticinitialize QUOTES quotes assigned here Errerr allows reporting initialization failures nicely The semantics would be Any access to QUOTES before its initialized would panic Attempting to set the value multiple times might possibly panic too This saves me from writing rust lazystatic static ref QUOTES MutexOptionQuoteLibrary MutexnewNone and also saves lockunwrap calls every time I want to use the QUOTES value For context this is what I initially wrote when attempting to use the current lazystatic rust lazystatic pub static ref QUOTES QuoteLibrary QuoteLibraryloadfileorexitquotesyaml Note cannot supply arguments from main function fn main lazystaticinitialize QUOTES other code impl QuoteLibrary pub fn loadfileorexitfilename str QuoteLibrary match Selfloadfilefilename Okquotes quotes Errerr printlnError loading filename err exit Calling exit from an initializer is awkward Hello the current rustlangnursery organisation is considered deprecated and the Rust Programming Language organisation is trying to consolidate managing Rusts GitHub organisations as such wed like you to consider moving your repository to the main rustlang organisation instead How Do I Move To rustlang You wont be able to transfer your repository directly youll need to transfer your repository to MarkSimulacrum who will then move your repository to the rustlang organisation Deprecating If you no longer intend to maintain this repository please let us know and we will take of deprecating the project Adding the attribute allownonuppercaseglobals doesnt work since attributes I provide are applied to the synthesized type but not to the actual static variable rust lazystatic allownonuppercaseglobals static ref fooBar i produces warning static variable fooBar should have an upper case name srclibrs static ref fooBar i help convert the identifier to upper case FOOBAR note warnnonuppercaseglobals on by default Playground link I have a tiny crate really just a crate to test miri where I noticed that after a cargo update lazystatic depends on spin Or at least spin gets compiled If you want to reproduce get that folder and do cargo update I couldnt land the updated version yet due to other problems Isnt that a problem The fact that spinnostd is a feature means that if any create enables it then globally all lazy statics will use a spin lock Given that there is no way to know what kind of computation is done in the initializer spinning instead of properly putting waiting threads to sleep seems like a huge waste of CPU cycles I am not entirely sure what exactly is enabling the feature in my case the reverse dependency graph of spin is not very big spin v lazystatic v c chacha v randchacha v rand v devdependencies cargomiritest v homersrcrustmiritestcargomiri getrandom v rand v randcore v rand v randchacha v randhc v devdependencies rand v randpcg v rand v devdependencies rand v MarkSimulacrum on Zulip suggested that Cargo ignores cfg restrictions for feature flags and thus getrandom is likely the trigger here Cc newpavlov FWIW the fact that there is a negated term no in the feature also indicates this is probably a bad approach see the feature name guidelines Cargo features are additive creates can only ask for a feature to be enabled but never ask for a feature to be disabled When compiling the code below rust macrouse extern crate lazystatic macrorules unitlikestruct vvis nameident v struct name unitlikestructpub MyStruct macrorules lazystring vvis nameident sexpr lazystatic v static ref name String formats lazystringpub NOTHING nothing Cargo says error no rules expected the token pub srcmainrs v static ref name String formats no rules expected this token in macro call lazystringpub NOTHING nothing in this macro invocation Thanks in advance In my crate ring I have use cases where I want to lazily initialize a value using only a spin lock waiting for CPUID to finish and where I want to lazily initialize a value using only libstds synchronization primitives and never spin opening a file lazily where the file handle will be shared across threads Currently this is impossible to do because the spinnostd feature is allornone I propose that lazystatic be augmented with two new macros lazystaticspin and lazystaticstd which respectively use spin or libstd Then the existing spinnostd feature would simply control which of those two macros lazystatic is implemented in terms of