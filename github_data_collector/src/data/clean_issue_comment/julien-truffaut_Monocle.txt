Updates orgtypeleveldisciplinescalatest from RC to RC Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgtypelevel artifactId disciplinescalatest details labels libraryupdate semverprerelease Updates orgscalasbtsbt from to Release NotesChangelog Ill automatically update this PR to resolve conflicts as long as you dont change it yourself If youd like to skip this version you can just close this PR If you have any feedback just mention me in the comments below Have a fantastic day writing Scala details summaryIgnore future updatessummary Add this to your scalastewardconf file to ignore future updates of this dependency updatesignore groupId orgscalasbt artifactId sbt details labels libraryupdate semverminor Replaces I did some experiment with Dotty in the following repo The type inference is so much better in Dotty than it looks like we can have fully inferred polymorphic optics here is an example Since the type inference drives a significant portion of our design decisions I think we should mainly target Dotty and Scala when it is available We might want to crosscompile to Scala when Monocle x is mature Should include and all other backward compatible changes I started to play with an encoding of Prism and Optional that can provide details when these optics fail branch trait Optional E A B extends Fold A B with Setter A B def getEitherfrom A Either E B def modifyEf B B A Either E A def setEto B A Either E A trait Prism E A B extends Optional E A B trait Lens A B extends Optional Nothing A B with Getter A B Here are some examples scala case class Foomap Map Int Option Boolean val map Lens Foo Map Int Option Boolean Lens Foo Map Int Option Boolean mapfoo newVal foocopymap newVal def ati Int Optional String Map Int Option Boolean Option Boolean UOptionalindex Map Int Option Boolean Int Option Boolean iwithErrorsMissing value at index i def some A Prism String Option A A UPrismsome A withErrorExpected Some but got None val foo FooMap Sometrue None def optici Int Optional String Foo Boolean mapcomposeaticomposesome Boolean testget error reporting optic getEitherfoo shouldEqual Righttrue optic getEitherfoo shouldEqual LeftExpected Some but got None optic getEitherfoo shouldEqual LeftsMissing value at index testset error reporting optic setEfalsefoo shouldEqual RightFooMap Somefalse None optic setEfalsefoo shouldEqual LeftExpected Some but got None optic setEfalsefoo shouldEqual LeftsMissing value at index Names need to be changed joroKr pointed out that we can use variance for Getter and Fold even in the monomorphic case Optics like most functional programming concepts follow some principles also called laws FP libraries tend to have two kinds of operations Constructors where users need to verify the constructed object follow those rules usually via propertybased testing Combinators where users are guaranteed properties are preserved For example if you have a valid optic applying any combinator gives you another correct optic Now the problem is that some methods are incredibly convenient for users but they may break optics principles TODO add examples In Monocle x and x we told users Sorry we understand what you want It is useful but potentially unsafe so we dont put this in the library It has been very frustrating to users In my opinion we should allow those combinators but we need a way to mark them as dangerous Many libraries use unsafe prefix eg unsafeFilter Other languages use a suffix like filter Ideally it shouldnt be too verbose Hi thank you very much for this library it helps me a lot every day but Ive faced a strange issue Im not sure if it is a bug or not but its behavior is unexpected for me What I want to do is to have a Lens for a collection like Map that allows me to do something like this scala val map Map String Vector String Mapempty val result mapapplyLensdefaultIndexfoomodify foo assertresult Mapfoo Vectorfoo But with the default implementation of monoclefunctionIndex and all its implicits it doesnt work I had to define a custom fromAt for it Here is my code scala def fromAt S I A implicit ev At S I Option A Index S I A Index i val lens evati Optionallensgeta s lenssetSomeas Would that be a good idea to add something like this to the Monocle Or maybe there is something that solves my problem better I have a working implementation already I think however that Index might not be the best solution for this use case and maybe it should be a different abstraction for it A Getter A B is equivalent to A B So the variance of Getter should be the same as Function covariant in A the input and contravariant in B the output If you are like me and have trouble putting your head around variance you will find a great resource in Thinking with types scala trait Getter A B def getfrom A B On the other hand a Lens A B is equivalent to a pair of function get A B set A B A Both A and B appear in covariant and contravariant positions which means Lens must be invariant in A and B scala trait Lens A B extends Getter A B A is both an input and ouput of set def setfrom A newValue B A All write optics are invariant but it turns out that their polymorphic version is not For example a PolyLens A A B B is a pair of function get A B set A B A Now both A and B are in contravariant position and A and B are in covariant position scala trait PolyLens A A B B extends Getter A B def setfrom A newValue B A Thank you Adam Fraser and John De Goes for the idea Also thanks to Georgi Krastev for pointing out monomorphic Lens can inherit Getter with variance This issue is directly conflicting with removing polymorphic optics in So the question is does variance in polymorphic optics brings enough benefits to compensate for their inconvenience EDIT I removed the section where I said monomorphic Lens cannot inherit Fold with variance