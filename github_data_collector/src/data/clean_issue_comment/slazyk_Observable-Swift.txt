Hey This repo seems not maintained anymore are you aware of an updated fork Fixed a couple compilation warnings that occurred under Xcode default warning settings Swift I believe those were the issues referenced at Redefined public ValueType as to not use internal types Redefined value as to use ValueType Removed conformance of O O and O to AnyObservable as this was redundant with ObservableChainingProxy type requirements slazyk Please take a look and submit your feedback Currently when copying values lets say between models we always need to access them Example swift modelnamevalue diffModelnamevalue modelname diffModelnamevalue or shorthand modelname diffModelname The improvement allow use to do this swift modelname diffModelname There is no need to access the value of the Observable and since we use operator this action seems to be also pretty clear unlike get warning when use with xcode A tiny change to allow others just to copypaste the pod definition Issue Hi there I ran into unsurmountable issues getting the framework running where a name clash happens with any class within the module when importing as a framework ie Cocoapods For example we have an Event class since our domain models everyday events and Swift gets tripped up on being able to specify that an event is an ObservableEvent as opposed to your own Event The reason for this is that both the module is called Observable as well as a framework class exists called Observable This is apparently an antipractice in Swift to have the module use the same name as any of its existing classes Event typealiasing gets tripped up by this ie typealias ObservableEvent ObservablesEvent PROPOSAL Rename the framework to Observables or something similar Unfortunately I think this is the only way out of this without renaming the Observable class itself I have made all the changes required on the fork here Would appreciate you accepting this and renaming the project Cocoapod will likely require a new pod GitHub has a rename option at the top of the project Settings page I know its not the nicest thing to rename the project but you really want people to be able to integrate your project seamlessly using Cocoapods etc and not just copying the files in and itll solve any problems like this going forward So hopefully someone else doesnt waste a full day chasing this down as I did Cheers Renamed module to Observables to get around unsurmountable issues with making the module work when there is a name clash with any class within the module when importing it as a framework ie Cocoapods For example if you have an Event class in your own project ie your domain models everyday events Swift gets tripped up on being able to specify that an event is an ObservableEvent as opposed to your own Event The reason for this is that both the framework module is called Observable as well contains a class called Observable Its apparently an antipractice in Swift to have the module use the same name as any of its existing classes Event type aliasing gets tripped up by this ie typealias ObservableEvent ObservablesEvent compiler cant distinguish between Observable the class and Observable the module despite the import Observable declaration Thus the solution was to rename the framework to Observables or something similar Unfortunately this is the only reliable way out of this without renaming the Observable class itself Alternatives would have been to rename the Observable class not worth it or giving up framework integration and copying files directly not using Cocoapods What do you think about adding a method like Eventremoveowner ownerAnyObject It would eliminate the need to store subscriptions in an instance var in the common case I cant implement it in an extension because the list of subscriptions is marked internal It would be useful to somehow getting the first value of an Observable immediately after adding a handler Say I have a View that updates a textLabel based on the corresponding ViewModels name property swift class MyViewModel var name Observabletest class MyView UIView IBOutlet var nameLabel UILabel func configureWithViewModelviewModel MyViewModel nameLabeltext viewModelnamevalue viewModelnameafterChange unowned self in selfnameLabeltext Its a bit cumbersome having to repeat myself about how the value of a viewModel affects changes in the view Is there another way to do this or is it something that could be implemented 