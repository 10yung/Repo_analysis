As far as I can see jwtscala is not useful if you have more than one secretkey Possibilities for this include Secret rotation its a good practice to regularly rotate secrets to do this you need to concurrently accept tokens signed with both old and new secrets for the period of time where you start using the new secret but there are tokens signed by the old secret that havent yet expired Per issuer secrets You may have multiple services issuing JWTs each with their own publicprivate key pair Ideally information about which secret is being used should be in the JWT itself for example the iss claim may contain an identifier for the issuer and the public key used to verify the signature for that issuers JWTs would be selected by inspecting that To support this the signature for decoding would have to be something in the form of JwtClaim Secret Of course this could be achieved by first decoding the claim without passing a secret and setting the signature option to false reading the issuer selecting a secret and then decoding again with the secret but then youre unnecessarily decoding the jwt twice All these libraries are vulnerable under DoSDoW attacks which exploit On complexity of Scalas HashMap construction when all keys have hash code or Javas BigIntegerBigDecimal parsing from the decimal representation Here are PRs with code and instructions to reproduce 