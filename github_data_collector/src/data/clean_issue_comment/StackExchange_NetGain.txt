Hi Ive managed to implement NetGain as a complete replacement for Websocketsharp for my mobile MMO game it seems to completely work without any issues but with Websocketsharp there were some packets that I was sending to clients that were none async I need to guarantee order in these packets I noticed that the TcpHandler sends all messages using the SocketSendAsync method and I cant seem to find anything that handles orderering of packets being sent or waiting for an async send to complete before moving onto the next Im hoping Im wrong though Please can you confirm if guaranteed ordering of sends is implemented in some way Alternatively would there be any sideeffects if I were to implement the SocketSend method Many thanks Daryl Hi I found the websocket server cant accept the connection with the subprotocol For example new wsImplwssubprotocol So i modify some places in CompleteHandshake in WebSocketsProcessorRFC Basically I have to append SecWebSocketProtocol before complete the handshake My question is how can I override this method in my project instead of modifying the source code updates My current solution is to modify the CompleteHandshake in WebSocketsProcessorRFC cs What Ive done is to make sure the subprotocol in headers secwebsocketprotocol is valid if so append the acceptable subprotocol in the string frame Any suggestions Thank you The website that I am using to connect to the socket server uses SSL How can I do this I created the news feed websocket in which it send data to socker server every second meanwhile I send the new post to the server it seems like receive synchronously I would like to know if there is any way to make it async to run the process I think itd be helpful to provide a client code example to complement the server example in READMEmd These two examples will successfully communicate over the given port if hosted in separate processes I used two instances of LinqPad for testing TcpHandlerDefaultMaxIncomingQuota and DefaultMaxOutgoingQuota is really low what is the purpose of this limitation doesnt seems like a protocol requirement and WebSocketsProcessorRFC cs use TcpHandlerDefaultMaxOutgoingQuota for its bufferstream and cause it to throw a exception in BufferStreamGrow should I set a higher DefaultMaxOutgoingQuota or remove the limit completely or set a different default limit for websocket Buffer maximum length exceeded vs Exception SystemInvalidOperationException Buffer maximum length exceeded vs StackExchangeNetGainBufferStreamGrowInt newLength E repos projectserver deps StackExchangeNetGain BufferStreamcs StackExchangeNetGainBufferStreamWriteByte buffer Int bufferOffset Int count E repos projectserver deps StackExchangeNetGain BufferStreamcs StackExchangeNetGainWebSocketsWebSocketsProcessorRFC SendNetContext context Connection connection Object message E repos projectserver deps StackExchangeNetGain WebSockets WebSocketsProcessorRFC cs StackExchangeNetGainConnectionSendNetContext context Object message E repos projectserver deps StackExchangeNetGain Connectioncs StackExchangeNetGainWebSocketsWebSocketsMessageProcessorSendWebSocketConnection connection Byte message E repos projectserver deps StackExchangeNetGain WebSockets WebSocketsMessageProcessorcs Sorry if those questions seem trivial I have not found any documentation Can I send the Username on open connection Or this is done at OnAuthenticate How can distinguish users right from the start Thanks The following code will reproduce the bug var endpoint new IPEndPointIPAddressLoopback using var client new TcpClient clientProtocolFactory WebSocketClientFactoryDefault clientOpenendpoint var dataLength var bytes new byte dataLength var resp stringclientExecuteSyncbytes WriteLineDateTimeNowHHmmss fff tresp I think there must be something wrong in method BufferStreamWritebyte buffer int bufferOffset int count int origCount count CheckDisposed ifisReadOnly throw new NotSupportedException int newEnd checkedoffset origin count if newEnd length GrownewEnd length newEnd int chunkIndex offsetNetContextBufferSize chunkOffet offsetNetContextBufferSize int thisPage NetContextBufferSize chunkOffet var chunk buffers chunkIndex will throw ArgumentOutOfRangeException if the bufferLength if thisPage count can write to a single page BufferBlockCopybuffer bufferOffset chunk chunkOffet count Im sending binary data to the server and one request in particular seems to keep tripping this In ProcessFrame there is this code C else ifpendingCount Processcontext connection framePayload frameOpCode else throw new NotImplementedException Ive been trying to strip down an example to reproduce it but not having much luck I grabbed the raw request as it was logged by NetGain then sent it through the TcpClient but that works just fine The big difference is the client side is using WebSocketSharp Ive pulled in the source code and can see it happen but since Im not really that familiar with the protocol its hard for me to understand whatwhy its happening If it matters the message is bytes long Whats interesting is that it says bytes are available But what I see in the Output Window is this server Receive Success bytes Received bytes are here server processing with bytes available Parsed header from FE F E B server processed bytes remaining server processing with bytes available BTW Is there an easy way to actually view the activity when the client isnt a browser I could do this with Wireshark but then Id have to move the server to another machineVM for testing Id rather not if there was some nice way of doing it I thought you can send as soon as the client connects so I tried this cs public class ClientHandler WebSocketsMessageProcessor protected override void OnOpenedWebSocketConnection connection connectionSendContext hello But the client didnt receive anything A workaround I found is to have the client initiate the conversation and send whatever I need to send from OnReceive Is there another way to be notified when I can use the connection to talk to the client If it makes any difference Im using Websocket Net on the client cs webSocket new WebSocketwslocalhost webSocketOpened WebSocketOpened webSocketMessageReceived WebSocketMessageReceived webSocketClosed WebSocketClosed webSocketError WebSocketError webSocketOpen 