I have a struct where some of the fields are using some custom property wrappers I want to be able to extract those values Example Using the Lazy property from this spec swift protocol Test struct Foo Test Lazy var bar Int With the template stencil for type in typesimplementingTest extension typename func test for variable in typevariables printvariablename variabletypeName endfor endfor I get swift extension Foo func test printbar Int But it doesnt have the value bar LazyInt Also these property wrappers have support for projectedValues too In which case bar LazyInt would also be available but the type would have to be known in that case There is requirement that inline code generated from a different template can be processed forceparse arguments provide this ability for generated code in a file In this pull request annotationranges is given forceparse argument and if the inline annotation ends with one of the templates then that inline code is not removed Hi I just noticed that xcodeproj is pinned to while the tuist repository is already at x Is there a reason for that Currently Sourcery fails for me with Xcode projects that contain Swift Package Manager packages as it does not support those object types Ive managed to change the files in Pods to just ignore these types and that made it work for me for now but before I go and try to fix this properly I wanted to ask whether there is some deeper reason why were not on current xcodeproj Cheers Uli Using krzysztofzablockiSourcery from Mintfile Sourcery already installed Running sourcery dyld Library not loaded rpathlibswiftAppKitdylib Referenced from usrlocallibmintpackagesgithubcomkrzysztofzablockiSourcerybuild sourcery Reason image not found the annotation is like this sourcery its easy to be taken as useless comments Can add at the beginning looks like this sourcery Protocol inherited from another protocol with same method name protocol UserManagerProtocol AnotherUserManagerProtocol func currentCompanyin context NSManagedObjectContext Company protocol AnotherUserManagerProtocol func currentCompanyin context NSManagedObjectContext Company AutoMockable protocol UserManagerProtocolAutoMockable UserManagerProtocol AutoMockable Generated class UserManagerProtocolAutoMockableMock UserManagerProtocolAutoMockable MARK currentCompany var currentCompanyInCallsCount var currentCompanyInCalled Bool return currentCompanyInCallsCount var currentCompanyInReceivedContext NSManagedObjectContext var currentCompanyInReceivedInvocations NSManagedObjectContext var currentCompanyInReturnValue Company var currentCompanyInClosure NSManagedObjectContext Company func currentCompanyin context NSManagedObjectContext Company currentCompanyInCallsCount currentCompanyInReceivedContext context currentCompanyInReceivedInvocationsappendcontext return currentCompanyInClosuremap context currentCompanyInReturnValue MARK currentCompany var currentCompanyInCallsCount var currentCompanyInCalled Bool return currentCompanyInCallsCount var currentCompanyInReceivedContext NSManagedObjectContext var currentCompanyInReceivedInvocations NSManagedObjectContext var currentCompanyInReturnValue Company var currentCompanyInClosure NSManagedObjectContext Company func currentCompanyin context NSManagedObjectContext Company currentCompanyInCallsCount currentCompanyInReceivedContext context currentCompanyInReceivedInvocationsappendcontext return currentCompanyInClosuremap context currentCompanyInReturnValue Per request from ilyapuchka in this demonstrates the issue where Sourcery will generate several empty case statements when only a few valid case statements are expected I dont know enough about Sourcery to fix this issue myself but I hope this helps resolve it Basically Im getting swift extension ExampleStruct enum GeneratedCases case case case case case case case case case case case case case case case case case case case case case case case When I expect swift extension ExampleStruct enum GeneratedCases case one case two Ive been using Sourcery to generate documentation automatically for GitHub wiki ie generate markdown files based on types annotations as its pretty user friendly on there as in easy to read and also very easy to do in templates thanks to Sourcerys capability to generate files on the fly However using annotations is not very coderfriendly though as it gets hard to maintain because every special characters that need to be escaped For example swift sourcery doc This is a Foo nAnd it does bar public struct Foo I think making Sourcery able to parse documentations comment as a protocol such as Documentable for example so that the documentation comments are readily available for anything documentable would be great so that code can be like swift This is a Foo And it does bar public struct Foo Itd be just an addition to Sourcery and wouldnt change existing functionality This could also potentially allow to create a template that makes Sourcery automatically generate markdown for documented codebases which could be interesting and useful in the context of GitHub wikis If that seems like a good idea I can get a stab at it and submit a PR If I have a Swift code like this typealias UserResult ResultUser AccountError this type UserResult does not appear in typesall If I do something like this extension UserResult then sourcery will add it into typesall but typename will be ResultUser AccountError instead of UserResult what I expected I read through many issues mentioning typealias here but its not clear to me is this correct behavior or a bug This PR is a restart of and a first step towards better generics handling by Sourcery Changes are intentionally smaller in scope than in the original and are almost backwardscompatible In fact the only truly breaking change I see is TypeisGeneric property that became computed previously it was passed in initializer but its unlikely that this change will break someones usage of the framework This PR follows glossary and terminology proposed in so its better to read full explanation provided in that PR Brief summary of changes that were implemented here Introduce TypegenericTypePlaceholders and TypegenericTypeParameters properties fill them on FileParser and Composer level Introduce MethodgenericTypeParameters property Preserve Type knowledge wherever possible even if types are unknown in scope of objects that are related to generics Implement type specializationfor example ObservableElement can be a template class and ObservableInt can be a specialized version of that class that contains both generic type placeholder Element and generic type parameter Int Even though this PR is only the first step and does not finish generics parsing fundamentally it was designed to be a good incremental improvement to not turn this PR into breaking monster it was previously cc ilyapuchka truizlop