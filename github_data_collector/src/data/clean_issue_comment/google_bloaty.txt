What does this error mean I get it when trying to look at compileunits Im not able to load ELFs for an embedded PowerPC platform that Im using bloaty ppchelloworldelf bloaty ELF region outofbounds Im running on Linux x and here is the sample file Im trying to load The exception is being thrown here Breakpoint bloatyanonymous namespaceStrictSubstr data offoffentry n at homeawilkecodebloatysrcelfcc THROWELF region outofbounds gdb bt bloatyanonymous namespaceStrictSubstr data offoffentry n at homeawilkecodebloatysrcelfcc x bca f in Next this x ffff aa at homeawilkecodebloatysrcelfcc NoteIter section this x ffff aa at homeawilkecodebloatysrcelfcc bloatyanonymous namespaceElfObjectFileGetBuildId thisoptimized out at homeawilkecodebloatysrcelfcc x a f f in bloatyBloatyScanAndRollupFile this x fffffffda file xd cb rolluprollupentry xd acf outbuildidoutbuildidentry xd ad at homeawilkecodebloatysrcbloatycc x a e in operator data xd acf closure xd d at homeawilkecodebloatysrcbloatycc snip Im assuming that bloaty is crashing when reading the section header for PPCEMBapuinfo since thats the only notetype section in this ELF readelf ppchelloworldelf S grep NOTE PPCEMBapuinfo NOTE c The header values parsed by bloaty dont make sense gdb frame x bca f in Next this x ffff aa at homeawilkecodebloatysrcelfcc name StrictSubstrremaining ptrnnamesz gdb px ptrnnamesz x gdb px ptrndescsz x gdb px ptrntype x gdb However these appear to be bytereversed interpretations of the expected values in the header See this ABI reference section The expected values are name size bytes type This is really pushing my knowledge of the ELF format but it appears that this is an endianness issue when parsing the section header PowerPC is a bigendian platform and my host platform is littleendian readelf ppchelloworldelf h grep endian Data s complement big endian Thanks for any help you can provide Ive been running bloaty on an iOS app recently and found that d compileunits while very helpful in some cases was consistently telling me that a single c file was MB Is it possible that there is something going on when the binary is overly large Output from the iOS App with an embedded static lib bloaty n d compileunits s file debugfileDSYM App Binary VM SIZE FILE SIZE Mi Others Mi Mi externalAPNGKitAPNGKitlibpngapngpngerrorc Mi Mi TEXTtext Mi Mi DATAobjcconst Mi Mi LINKEDIT Mi Mi TEXTcstring Mi Mi TEXTobjcmethname Mi Mi DATAobjcdata Mi Mi TEXTunwindinfo Mi Ki TEXTgccexcepttab Ki Mi TOTAL Output from the dependent library built separately bloaty n d compileunits s file debugfileAPNGKitframeworkdSYMContentsResourcesDWARFAPNGKit APNGKitframeworkAPNGKit VM SIZE FILE SIZE Ki LLVMbundle Mi Mi LibraryCachescomapplexbsSourcesarcliteiOSarclite sourcearclitemm Mi TEXTtext Ki Ki LINKEDIT Ki Unmapped Ki Ki APNGKitAPNGKitlibpngapngpngrutilc Ki Ki TEXT Ki Ki APNGKitAPNGKitlibpngapngpngc Ki Ki LLVM Ki Ki APNGKitAPNGKitlibpngapngpngreadc Ki Ki APNGKitAPNGKitlibpngapngpngrtranc Ki Ki APNGKitAPNGKitlibpngapngpngwutilc Ki TEXTcstring Ki Ki APNGKitAPNGKitAPNGImageViewswift Ki Ki APNGKitAPNGKitAPNGImageswift Ki Ki APNGKitAPNGKitlibpngapngpngsetc Ki Ki APNGKitAPNGKitlibpngapngpngwritec Ki Ki APNGKitAPNGKitlibpngapngpngpreadc Ki Ki APNGKitAPNGKitDisassemblerswift Ki Ki UsersJP LibraryDeveloperXcodeDerivedDataAPNGKitctwilwszsgnxvzbbionmu Ki Ki MachO Headers Ki Ki APNGKitAPNGKitlibpngapngpnggetc Ki Ki APNGKitAPNGKitlibpngapngpngerrorc Ki Mi TOTAL Mi On some binaries I have run through bloaty compiled from the tarball source I have noticed that some functions which have cold generated segments dont get demangled properly As an example if you had a function foo with the signature void foo mangled as Z foov which had a cold section the symbol would be Z foovcold Bloaty doesnt demangle Z foovcold which can sometimes make output confusing Technically the fact that it doesnt demangle it is expected as Im assuming that string doesnt adhere to the Itaniumetc mangling convention However even denoting it like foo cold Could be more readable perhaps Im not sure how easy this would be to resolve and it sounds like a pretty low priority However I didnt see any existing issues covering this In embedded applications two pieces of code might have exactly the same set of addresses but get paged out manually depending on what code is needed at that time You can see more here Suggested plan for Bloaty Instead of using just the VM address to disambiguate use VM address file offset This will allow overlays to work correctly Is it planed to add Split DWARF support to bloaty d compileunits does not work for my build where debug info is outsourced into external dwo files VM SIZE FILE SIZE section debugranges Mi section debugaddr Mi section debugline Mi section gdbindex Mi Mi DWARF is missing filename Mi readelf debugdump looks like this Contents of the debuginfo section Compilation Unit offset x Length x bit Version Abbrev Offset x Pointer Size b Abbrev Number DWTAGcompileunit c DWATranges x d DWATlowpc x DWATstmtlist x c DWATGNUdwoname indirect string offset x productCMakeFilesproductmoduleobjlibdirproductcppdwo DWATcompdir indirect string offset x developgit genopt DWATGNUpubnames DWATGNUaddrbase x DWATGNUdwoid xdb d acb a DWATGNUrangesbase x Bloaty gives a Corrupt MachO file error on a file lipo detailedinfo gives this output Fat header in REDACTEDSdk fatmagic xcafebabe nfatarch architecture armv cputype CPUTYPEARM cpusubtype CPUSUBTYPEARMV offset size align architecture armv s cputype CPUTYPEARM cpusubtype CPUSUBTYPEARMV S offset size align architecture i cputype CPUTYPEI cpusubtype CPUSUBTYPEI ALL offset size align architecture x cputype CPUTYPEX cpusubtype CPUSUBTYPEX ALL offset size align architecture arm cputype CPUTYPEARM cpusubtype CPUSUBTYPEARM ALL offset size align The hexdump of the first part of the file is this ca fe ba be c c e b c l b e c e c h fd e e G e a ff c x b d e c ar e a f ch An issue for visualizing symbol dependency tree from READMEFuture Work This would be great for helping users find which part of their code is pulling in huge symbol dependencies Just some information in case someone wants to add support for the Atmel AVR architecture to bloaty I have tried analysing an elffile compiled for the ATmega P microcontroller Atmel bit AVR RISCbased architecture which failed with the error Unknown ELF machine value The error is raised in elfcc at line since EMAVR value does not get handled there After a quick look at the documentation of the capstone decompiler it seems that AVR microcontrollers are not explicitly supported But I gave it a try anyway by selecting the ARM architecture also RISCbased with little endian and the resulting bloaty binary seems to be working fine with AVR elffiles after this little addition to the switch statement in the function ElfMachineToCapstone case EMAVR arch CSARCHARM mode CSMODELITTLEENDIAN break Note though that I do not know much about processor architectures and the way capstone works so the question remains if this change introduces problems I am not yet aware of if anyone could provide additional information in this regard Id be grateful Many thanks to the developers for this useful tool I tried build my binary with g and clang and analyze with bloaty I always had same error bloaty Unexpected ehframe format value I trying to analyze elf file linux build when I run bloaty without flags it prints correct output VM SIZE FILE SIZE debuginfo Mi debugstr Mi debugloc Mi debugline Mi Mi text Mi debugabbrev Mi debugranges Mi strtab Ki Ki ehframe Ki Ki rodata Ki symtab Ki Ki ehframehdr Ki debugaranges Ki Ki gccexcepttable Ki Ki bss Ki dynstr Ki Ki Others Ki Ki dynsym Ki Ki plt Ki ELF Headers Ki Ki relplt Ki Mi TOTAL Mi But for compileuntis or symbols I had this error OS Ubuntu gcc Ubuntu ubuntu clang version ubuntu tagsRELEASE final I tried also g and ggdb flags same problem 