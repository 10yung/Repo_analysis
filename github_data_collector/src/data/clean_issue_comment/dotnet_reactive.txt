 Bug Despite our best efforts bugs can slip into releases or corner cases forgotten about We will try our best to remedy the situation andor provide workarounds Note that certain odd behaviors are by design and as such are not considered bugs Which library version Was reported against still present in What are the platforms environments and related component versions XamarinAndroid What is the use case or problem In ReacitveUI we use Reflection and Tuples to provide Two Way Binding to UI elements It seems that the reflection spits a specific error now when it tries to bind on XamarinAndroid The issue was reported after we migrated to Value Tuples This is related to What is the expected outcome That the bindings are found and Android handles the Two Way binding What is the actual outcome The following error is produced The Android App crashes What is the stacktrace of the exceptions if any Do you have a code snippet or project that reproduces the problem reactiveui zip Feature request Which next library version ie patch minor or major Major as it most likely would be a breaking change due classesmethods being moved outaround What are the platforms environments and related component versions NET Framework SystemReactive at least Checked and How commonly is this feature needed one project several projects companywide global Causing audit issues Companywide on any projects using Rx in any Full Framework service code eg AspNetCore x Please describe the feature Would like to see the WindowsForms references moved out of the main SystemReactive library and into their own NuGet package We are getting audit issues as SonarQube is complaining that all of our server side projects should be using STA Thread attributes as we have a reference to WindowsForms Yes we are ignoring the error but still think it is worth moving out into their own package Hi When referencing SystemReactive in a WPF project using the MicrosoftNETSdkWindowsDesktop SDK both UseWindowsForms and UseWPF and NET core I have this warning C Program Files dotnet sdk Sdks MicrosoftNETSdk targets MicrosoftNETSdkFrameworkReferenceResolutiontargets warning NETSDK A FrameworkReference for MicrosoftWindowsDesktopApp was included in the project This is implicitly referenced by the NET SDK and you do not typically need to reference it from your project For more information see Library version Tried with both VS and dotnet build You can find an example here I recently ran into a consistency issue with call order of disposables This is happening across all versions of Rx Consider the following queries c static void Mainstring args var o ObservableUsing DisposableCreate ConsoleWriteLineR r ObservableReturn var o ObservableUsing DisposableCreate ConsoleWriteLineR r o o Subscribe ConsoleReadLine ConsoleWriteLine var o a o Publishpo ObservableUsing DisposableCreate ConsoleWriteLineR r po o aSubscribe ConsoleReadLine ConsoleWriteLine var o b o SelectManyx ObservableUsing DisposableCreate ConsoleWriteLineR r ObservableReturnx o bSubscribe ConsoleReadLine ConsoleWriteLine All of these queries are about chaining the results of a sequence as a causal consequence on the notifications of o Each of the observables also has some disposable resources that are specified with the Using operator The st example chains the two observables by having o subscribe to o inside its creation expression The nd example does exactly the same thing but uses Publish to multicast the observable first The rd example uses SelectMany to create o from a sequence generated by the singleton value of o All these observables return the exact same sequence of values However inconsistent behaviour is observed when cleaning up the resources involved in the operation Specifically the disposal order for the st example is R R Whereas the disposal order for the nd and rd examples is R R From being used to RAII principles I would expect the latter case to be the correct one as resources created last should be disposed first which seems to be the case for the majority of operators in Rx Hence my surprise finding that the st simple example actually switches the order around This is problematic for compositionality semantics of Rx Any ideas about why this is happening and what should the expected semantics be like Bumps PublicApiGenerator from to details summaryRelease notessummary Sourced from PublicApiGenerators releases Changes Fix Output property even though indexer exists PR details details summaryCommitssummary c f Merge pull request from sungam rindexernamefix ed fix bab c add tests to demonstrate problem See full diff in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart If all status checks pass Dependabot will automatically merge this pull request dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details This is actually distilled from a much more complicated debugging session which boils down to the following query c using System using SystemLinq using SystemReactiveLinq namespace Recursive class Program static void Mainstring args var timer Observable TimerTimeSpanZero TimeSpanFromSeconds SelectManyx Observable Returnx Repeat Dok ConsoleWriteLinek TakeWhilek i i k timerSubscribe ConsoleReadLine In my understanding this query should repeat the value N as many times as N and then stop but for some reason it loops forever on the Repeat even though TakeWhile is clearly terminating as can be verified by moving the WriteLine right after the TakeWhile operator it will return zero once and then nothing as opposed to an infinite stream of zeroes when its right after Repeat Its wonderful that we now have framework provided IAsyncEnumerable and some C sugar for it but where are the extension methods we all need Where Select Is this package the official home for IAsyncEnumerable extension methods If yes where can I read more about it Where are the docs Why isnt full Linq support included in the net core framework Hi Please implement an operator that walks through a collection of observables and emits all values for the first observable thats not empty c public static IObservableT SwitchIfEmpty this IObservableT first params IObservableT others Here is a SO question about that Here is a possible implementation After upgrading our projects NET Core from Reactive our xunit tests failed to start with AM Error MicrosoftVisualStudioTestPlatformObjectModelTestPlatformException Testhost process exited with error Error An assembly specified in the application dependencies manifest ProjectXTestsdepsjson was not found package SystemReactiveReference version path SystemReactivedll Unlike all other nuget packages I noticed in VS that Reactivedll now shows up in Solution ExplorerProjectDependenciesAssembly as well as under Packages reactive Reverting back to removes the assembly reference and allows our unit tests to execute once again