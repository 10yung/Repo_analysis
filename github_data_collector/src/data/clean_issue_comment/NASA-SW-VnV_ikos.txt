See that could impact our implementation too Im attempting to use ikosscan on a project that calls MPI wrapper compilers instead of the CC compilers directly This fails because ikos intercepts the MPI wrapper commands and replaces them with clang compilers but does not include the MPI header flags needed for a successful parse Chombo libsrcBaseToolsSPMDH fatal error mpih file not found include mpih error generated The analyzer generates false positives when the code uses the following pattern c include ikosanalyzerintrinsich define SUCCESS extern int fvoid extern int gvoid extern int hvoid int x int main int status f if status SUCCESS status g x if status SUCCESS status h ikosassertx return The analyzer generates the following warning testc warning assertion could not be proven ikosassertx First this code pattern is questionable and I would recommend not using it It is hard to read and causes trouble to static analyzers Prefer the earlyreturn pattern see this example Anyway we could solve this false positive by optimizing the control flow graph The current control flow graph is here We could write an optimization pass that replaces the edge from to by an edge from to This would fix remove the warning The current analysis cannot catch a buffer overflow in a structure For instance c include ikosanalyzerintrinsich typedef struct int tab int x Struct int main Struct s stab overflow on tab writes on x ikosassertsx return The analyzer only checks that the memory write is within the structure so it is considered safe The analyzer will actually know that sx is so we could say that the analysis is somewhat sound regarding the memory model To fix this we should investigate the inbounds flag of the LLVM getelementptr instruction See LLVM Language Reference Manual What happens if an array index is out of bounds We could implement an abstract domain containing a union of at most N disjunctive abstract values This should be implemented as an option to the analyzer so that the user can specify N This could be used to unroll loops and fix false positives for instance or This is somewhat similar to There are still questions on how to implement the abstract operators such as join meet widening and narrowing The current analysis is imprecise when merging branches where one side has uninitialized variables For instance c include ikosanalyzerintrinsich int mainint argc char argv int tab if argc tab ikosprintvaluestab tab return The output of the analyzer is testc ikosprintvaluestab tab tab is in tab may be uninitialized We could add an abstraction that remembers whether a value is uninitialized or within a given range This should help with We could implement backward operators to improve the precision on guards This could help with and Using a small integer eg uint t int t etc as a loop counter usually results into false positives For instance c include stdinth void fint p uint t n for uint t i i n i p i i int main int tab ftab return IKOS returns testc warning possible buffer overflow pointer p uint ti accesses bytes at offset between and bytes of local variable tab of size bytes p i i The problem comes from the integer promotion rule in C The comparison i n actually turns into unsignedi unsignedn which creates temporary variables in the LLVM bitcode zext i to i dbg zext i to i dbg icmp slt i dbg This results in a lose of precision in the analyzer similar to A temporary workaround is to use a relational domain such as dbm or polyhedra This false positive appears in our benchmarks times in aeroquad times in mnav at least times in BioSentinel On the following example c include stdioh int mainint argc char argv if argc return printfHello s argv return IKOS generates the following warnings testc In function main testc warning memory access might be invalid could not infer information about pointer argv printfHello s argv testc In function main testc warning possible buffer overflow pointer argv accesses bytes at offset bytes of argv printfHello s argv We need to model argcargv properly to get rid of these warnings This seems complicated to achieve for nonrelational numerical domains The current implementation of the octagon domain has several issues segmentation fault unsoundness etc This should be fixed before adding doctagon in the analyzer In the meantime the APRON octagon domain can be used with dapronoctagon