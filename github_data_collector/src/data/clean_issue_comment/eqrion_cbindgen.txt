 Preface This one is a bit of a doozy and I cant tell if its a rustc issue or a cbindgen issue or both so Im going to crossreport them so both projects can be aware I dont have a minimal reproduction but it is easily reproducible in my repo Repo Working Commit b ec Failing Commit c The only difference is the addition of the crate type of cdylib rlib is there but it reproduces on my next commit which removed it System Info Xubuntu Rust and Cargo locked to nightly rustc rustc nightly ae cargo cargo nightly ad dbe e CBindgen latest compiled on the same nightly toolchain cbindgen Repro The rustc command is the exact command cbindgen runs to get macro expanded data This all takes place in the root of my repo cargo build cargo rustc lib manifestpath bvenativeCargotoml p bvenative Placeholder verbose Z unstableoptions prettyexpanded Both succeed as expected However if you call cbindgen it fails and the rustc no longer outputs anything at all Succeeds cargo build Fails citing an issue with compiling Occasionally must be run twice cbindgen bvenative c bvenativecbindgentoml v Returns zero but outputs nothing cargo rustc lib manifestpath bvenativeCargotoml p bvenative Placeholder verbose Z unstableoptions prettyexpanded You can call as many times as you want it will always fail The problem goes away when you cargo clean and reappears by running cbindgen again Comments I have no idea what or who is causing this issue I feel like even if cbindgen is ultimately the cause of the bug the expansion shouldnt be able to fail and not output anything without erroring and returning in some way Notes Possibly relevant cbindgen code rustc issue Thanks This should fix Please tell me if there anything I can do better The test is a reduced version of It currently fails cc emilio Hi When trying to generate bindings for this code rust use serdeDeserialize Serialize reprC deriveSerialize Deserialize pub struct Vec f x f y f z f nomangle pub extern C fn fx const Vec f f xx with a Cargotoml containing toml dependencies serde version features derive and a cbindgentoml toml language C parse parsedeps true The following panic is produced WARN Parsing crate serdederive cant find librs with cargo metadata thread main panicked at IntoIter is not generic Usersrbcargoregistrysrcgithubcom ecc db ec cbindgen srcbindgeniropaquers stack backtrace stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt corefmtwrite stdioWritewritefmt stdpanickingdefaulthookclosure stdpanickingdefaulthook stdpanickingrustpanicwithhook stdpanickingcontinuepanicfmt stdpanickingbeginpanicfmt cbindgenbindgeniropaqueOpaqueItem as cbindgenbindgeniritemIteminstantiatemonomorph cbindgenbindgenirtyTypeaddmonomorphs cbindgenbindgenlibraryLibrarygenerate cbindgenbindgenbuilderBuildergenerate cbindgenmain stdrtlangstartclosure stdpanickingtrydocall rustmaybecatchpanic stdrtlangstartinternal main note Some details are omitted run with RUSTBACKTRACEfull for a verbose backtrace Link to project that should reproduce the issue I am running cbindgen and rustc e hah and I just realized I filed a very similar issue that was related to however both of which are closed now Since this time the problem is related to specifying parsedeps true Im not sure if they are after all related or not Inputs rust nomangle doc a n b pub extern C fn examplea and rust nomangle doc a n n b pub extern C fn exampleb Rendered rustdoc rustdocthe doc attribute Actual generated header cpp a b void examplea cpp a b void exampleb Expected generated header cpp a b void examplea cpp a b void exampleb This happens when Im trying to generate multiline comments with macro Looks like code we simply use value in single doc attribute directly without any modification like rustdoc does BTW Im happy to help this out We have a generic type being exposed to C Mangle path adds an underscore between the types Is it possible to configure this as it messes with the projects code style Looking at the code this is actually probably pretty easy We buffer up literally everything until the end so we should in theory be able to emit just the types into another file Ideally the full header would just include the types header in this mode Specifically you would want a version of writetofile that takes two files and splits this general itemprocessing part across the two And then invoke it here Split off from Right now we dont generate structs for reprpackedn structures because it appears that there is a fair amount of difficulty generating the correct field alignments due to disparities between the semantics of GCCs attributealignedn with attributepacked and Rusts reprpackedn The below is a quote from describing the problem hr If Im reading this right it turns out that reprpackedn does not really have a simple native C representation In Rust reprpackedn indicates that the fields should have the smaller of n and stdmemalignoffieldtype as their alignment While it is true that in C you can specify individual field alignments like so struct foo uint t foo attributealigned uint t foo attributealigned uint t foo attributealigned uint t foo attributealigned bool foo attributealigned attributepacked The issue is that in Rust the following struct reprC packed struct Foo foo u foo u foo u foo u foo bool Should actually be represented as depending on your architecture struct foo uint t foo attributealigned uint t foo attributealigned uint t foo attributealigned uint t foo attributealigned bool foo attributealigned attributepacked And its not clear to me how we can determine what the natural alignment of the constituent types is And unfortunately this is critical to making sure that C and Rust code can interoperate with packed structures Its a bit unfortunate that Rust decided to have different semantics to GCCs alignment extensions The extra kicker is that AFAIK stdmemalignof depends on your architecture so wed probably have to do lots of extra work to generate the right alignment for each architecture rust supports And its important to note that getting this wrong will almost certainly result in pretty hideous crashes Spun off from Since aligned enums have a stable representation and thus we should represent them correctly when generating nonopaque versions Closes 