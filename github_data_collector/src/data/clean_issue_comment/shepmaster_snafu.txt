 Motivation Currently Snafu is designed to work with enums like rust enum MyEnum VariantA val Foo val Bar VariantB val Baz val i However a somewhat common pattern in Rust examples is to have enums like rust struct VariantA val Foo val Bar struct VariantB val Baz val i enum MyEnum VariantAVariantA VariantBVariantB While it is slightly more verbose it has a few advantages Since enum variants are not types its not possible to accept a MyEnumVariantA as a function parameter or to store it somewhere You can only passstore MyEnum However when youve made each variant its own type VariantA can be passed around or stored Note there is an RFC which proposes to add variant types to Rust which would remove this advantage However this comment doesnt give the impression that this will be implemented soon If multiple enums can have the same variant you must repeat that variant and all its fields in each enum definition With the second style you just repeat the VariantAVariantA line When matching on this kind of enum if a variant has a lot of fields in the first style you have to match like rust match myenum VariantA val val val val val whereas if you use the second style you can match like example rust match myenum VariantAa use aval aval etc Snafu does not support this second style of error enum but I think support for it can be added backwardscompatibly since deriveSnafu currently isnt implemented for regular structs its only implemented for singlefield tuples and it also isnt implemented for enums with singlefield tuple variants only structlike and unit variants So this second style of enums neatly falls outside of what Snafu currently supports The only issue is that there will be a naming collision between variant data structs and context selectors Both are according to the regular conventions given the same name as the enum variant So some bikeshedding will need to be done here which I do below Bikeshedding My vote for how to color the bike shed is as follows Allow deriveSnafu for regular Rust structs If the struct is called Foo this creates a new struct FooContext which is the context selector Any attributes that currently work on structlike enum variants work on structs as well and they do the same thing essentially as if you had an enum with a single variant Display and Error are implemented for Foo IntoErrorFoo is implemented for FooContext etc Allow deriveSnafu for enums that have singlefield tuple variants Display and Error are implemented as usual but for these singlefield tuple variants no context selector is generated it shouldve been generated in step above For an enum MyEnum with variant VariantA I think IntoErrorMyEnum should not be implemented for VariantAContext even though it could but instead we should implement FromVariantA for MyEnum I think this should allow contextVariantAContext to work in a function returning MyEnum the operator does the into Also implementing IntoErrorMyEnum for VariantAContext would probably break type inference I suppose there should also be a way to specify the name of the generated context selector This would be part of the snafu attribute eg snafucontextMySelectorStructName display or something This would need to be specified both on the variantdata struct and on the enum variant Heres how the example from the snafu docs homepage would look with this style rust deriveDebug Snafu snafudisplayCould not open config from filenamedisplay source struct OpenConfig filename PathBuf source stdioError deriveDebug Snafu snafudisplayCould not save config to filenamedisplay source struct SaveConfig filename PathBuf source stdioError snafudisplayThe user id is invalid userid struct UserIdInvalid userid i backtrace Backtrace deriveDebug Snafu enum Error OpenConfigOpenConfig SaveConfigSaveConfig UserIdInvalidUserIdInvalid type ResultT E Error stdresultResultT E fn loginuserPconfigroot P userid i Resultbool where P AsRefPath let configroot configrootasref let filename configrootjoinconfigtoml let config fsreadfilenamecontextOpenConfigContext filename Perform updates to config fswritefilename configcontextSaveConfigContext filename ensureuserid UserIdInvalidContext userid Oktrue Hello There are two information about the default state of the backtrace feature snafuBacktrace page says it is enabled by default snafuguidefeatureflags page says it is disabled by default As such one of these two pages is wrong I am no expert in how features are declared in Cargotoml but I think the default behaviour is backtrace disabled by default If this issue is accepted then Ill be very happy to provide you a PR to fix the documentation I havent seen any previous discussion on this so Im opening this ticket mostly to see what is shepmasters stance on this Coming from past experiences with errorchain and failure I got used to the bail macros they both provide with slightly different semantics for quickly generatingreturning errors Have you maybe already considered that in the past for snafu Do you have additional thoughts to share First thanks for making SNAFU Im really enjoying its ergonomics I started a new project and tried to create a couple nested errors but hit a name collision between the selectors that SNAFU was generating and one of my existing structs My inner module looks like this rust pub struct Config deriveDebug Snafu pub enum ConfigError impl Config pub fn load ResultSelf ConfigError My outer module imports a couple things from this struct and exports a new error type that wraps ConfigError rust use crateConfig ConfigError deriveDebug Snafu pub enum SyncError Config oh no a name collision source ConfigError pub fn sync Result SyncError let config ConfigloadcontextConfig Collision here too The Snafu derive macro on SyncError tries to define a struct named Config as the context selector which ends up colliding with the struct Config that I imported before One solution for this particular case I thought of was to put my SNAFU error into its own mod block to scope everything the macro defines Combined with snafuvisibility and reexporting the error type this seems to work rust use crateConfig mod error use crateconfigConfigError use snafuSnafu deriveDebug Snafu snafuvisibility pubsuper pub enum SyncError Config source ConfigError pub use errorSyncError pub fn sync Result SyncError let config ConfigloadcontexterrorConfig Another way we could solve this is by adding a configuration option like snafumod error to instruct SNAFU to wrap all of its context selectors into a module with the given name Does this feature make sense Is there a better solution to this particular problem that Im not seeing Thanks Copy over iterchain from Rust unstable into ErrorCompat Related Depended by A fairly common printerror implementation as a part of the main example With the recent proliferation of errorhandling crates it has become clear that the situation around the lack of a coreerrorError is really suboptimal In SNAFU nostd support is being introduced through a whole new Error trait just for nostd which could lead to similar problems that failure had by becoming incompatible with the ecosystem Ideally the Error trait would show up in core but due to coherence concerns and stddependent features being added to stderrorError a resolution is unlikely to happen soon As such I propose making a new crate coreerror exposing our own version of the Error trait The goal of this crate is twofolds Provide a common trait for various error handling crates Failure SNAFU Fehler Anyhow errorchain and any other Allow nostd libraries that dont want to depend on a specific error handling crate to still expose errors that can interoperate with those libraries Such a crate would work like this With the std feature it just reexport stderror With nodefaultfeatures it exposes an Error trait similar to the one in std but without backtraces and without the stdalloconly impls Rustc version autodetection is used to figure which errors to implement the trait on The alloc feature enables downcasting in addition to supporting alloc errors The crate would compile on all versions from to the latest stable version The trait will be compatible with stds Error trait and if libcore gains an Error trait in the future it should be compatible with it too Once the crate reaches Ill consider it ready for integration in the various error crates and will follow the same stability guarantee Rust does No breaking changes ever Work has already started in Id be interested in hearing feedback on the design Assume I have an error enum like this rust deriveDebug Snafu pub enum Error snafudisplay message source SessionError source SomeError message String When I later use into on a field for some reason like this rust somethingwithresultcontextSessionError message something went wronginto I will then receive a cryptic error message related to the generated struct error E type annotations needed testrs somethingwithresultcontextSessionError message something went wronginto cannot infer type for T Most users will probably not know whats going on if they dont know that it could be referring to a generated type parameter I havent looked into procedural macros myself yet but I think it would be possible to somehow make the error message more user friendly New user here I would like to be able to report meaningful error messages across a boundary between my Rust code and my API endpoints and otherwise access the content of those error messages programatically To do so I need to include a printout of the snafu display macro for a particular error variant For example given the following error struct rust pub enum MyEnum snafudisplaysome displayed value Variant source source backtrace backtrace display String get this field to autofill from snafu display attribute value i I would like to raise the error as follows rust return ErrMyEnumVariant value what I need to provide when raising the error And get something like this back when the error occurs rust MyEnumVariant display some displayed source source backtrace backtrace value It seems like there may be a couple of ways to accomplish this One would be to add another magic backing field such as snafu has already done for source and backtrace The other would be to add macro support for snafu to populate a new field displayField below for sake of illustration with the display value which would have less risk of breaking compatibility Something like this rust pub enum MyEnum snafudisplaysome displayed value displayFieldmsg Variant source source backtrace backtrace msg String get this to autofill from snafu display attribute value i Thank you