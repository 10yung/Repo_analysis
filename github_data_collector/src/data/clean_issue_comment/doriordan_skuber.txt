Field secretName in IngressTLS should be optional to reflect this documentation Field is left optional to allow SSL routing based on SNI hostname alone secretName is currently required by this Scala client which results in this JSON deserialization error akkahttpscaladslserverRejectionError ValidationRejectionobjitems spectls secretName msg errorpathmissing args SomeskuberjsonPlayJsonSupportForAkkaHttpPlayJsonError objitems spectls secretName msg errorpathmissing args Hey Dave Do you have an example of saving a configmap into a namespace that contains content like this apiVersion v kind ConfigMap metadata name testconfig namespace default data configyaml namespaces default labels app owner You can remove a cluster from your kubectl configuration by running kubectl config deletecluster and this will succeed even if a context referring to that cluster exists kubectl will then continue to work normally as long as you dont try to use that context only then will it fail Skuber in comparison fails to parse the configuration file even if you dont use that context I think Skuber should like kubectl be more tolerant than this and only fail when a user attempts to use that context The simplest thing would probably be for it to just ignore contexts whose clusters or users dont exist but ideally if you tried to use the context it would give a more meaningful error message roughly like cluster foo not found for context bar Is there a way to cancel already running request in skuber I do not have experience with Akka maybe theres a straightforward solution assumming you know how Akka operates Would there be any interesst in supporting OpenshiftObjects like DeploymentConfig Routes I have just came across a case and would like to understand the concept behind this as it seems odd to me The case I had was doing a status check for pods to see if there running or not Now when the pod is not running and status check is done an exception is thrown at KubernetesClientImplscala Which means a failed future This is in particular to me is odd because the call it self was successful check if a pod has a status but instead of returning an exception the status of the pod should be None with UNKNOWN To deal with the exception I did this for status podstatus phase statusphase yield phase recover case err K SException if errstatuscodemap getOrElsefalse None None in my case will be translated into UNKNOWN by the caller To clarify my question would it not be better to return an UNKNOWN status for a pod that is not found when doing a status check Hi all The tests dont show a way to determine when a command execd in a pod returns or what its return status is Is there any way to a determine this Or could it be implemented Our workaround at the moment is reading maybeStdout maybeStderr and waiting for it to stop producing for n seconds Or to echo out some marker after any command runs so we know its finished Thanks for any help Theres a slight difference in Scale object in autoscalingv version where the selector field is a string instead of an object This results in ValidationRejection when you attempt to do any of the following calls skubergetScale ReplicaSet myReplicaSet skubergetScale StatefulSet myStatefulSet e JsErrorListstatusselectorListJsonValidationErrorListerrorexpectedjsobjectWrappedArray akkahttpscaladslserverRejectionError ValidationRejectionobjstatusselector msg errorexpectedjsobject args SomeskuberjsonPlayJsonSupportForAkkaHttpPlayJsonError objstatusselector msg errorexpectedjsobject args at skuberjsonPlayJsonSupportForAkkaHttpanonfununmarshaller PlayJsonSupportForAkkaHttpscala at playapilibsjsonJsErrorrecoverTotalJsResultscala at skuberjsonPlayJsonSupportForAkkaHttpread PlayJsonSupportForAkkaHttpscala at skuberjsonPlayJsonSupportForAkkaHttpanonfununmarshaller PlayJsonSupportForAkkaHttpscala at akkahttpscaladslutilFastFutureanonfunmap FastFuturescala at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFuturemapextensionFastFuturescala at akkahttpscaladslunmarshallingUnmarshalleranonfunmap Unmarshallerscala at akkahttpscaladslunmarshallingUnmarshalleranonfuntransform Unmarshallerscala at akkahttpscaladslunmarshallingUnmarshalleranon applyUnmarshallerscala at akkahttpscaladslunmarshallingLowerPriorityGenericUnmarshallersanonfunmessageUnmarshallerFromEntityUnmarshaller GenericUnmarshallersscala at akkahttpscaladslunmarshallingUnmarshalleranon applyUnmarshallerscala at akkahttpscaladslunmarshallingUnmarshaltoUnmarshalscala at skuberapiclientimplKubernetesClientImplanonfuntoKubernetesResponse KubernetesClientImplscala at scalaconcurrentFutureanonfunflatMap Futurescala at scalaconcurrentimplPromiseanonfuntransformWith Promisescala at scalaconcurrentimplCallbackRunnablerunPromisescala at akkadispatchBatchingExecutorAbstractBatchprocessBatchBatchingExecutorscala at akkadispatchBatchingExecutorBlockableBatchanonfunrun BatchingExecutorscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at scalaconcurrentBlockContextwithBlockContextBlockContextscala at akkadispatchBatchingExecutorBlockableBatchrunBatchingExecutorscala at akkadispatchTaskInvocationrunAbstractDispatcherscala at akkadispatchForkJoinExecutorConfiguratorAkkaForkJoinTaskexecForkJoinExecutorConfiguratorscala at akkadispatchforkjoinForkJoinTaskdoExecForkJoinTaskjava at akkadispatchforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava at akkadispatchforkjoinForkJoinPoolrunWorkerForkJoinPooljava at akkadispatchforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava We generate access tokens to use with Kubernetes through a custom Vault interface This interface just generates an AccessToken in a string that we then need to pass into Skuber to use however the interface we implemented is custom and unique to our company and so adding a pull request to Skuber to just implement a VaultAuth would not work Unfortunately because TokenAuth and AuthProviderAuth is marked as a final case class we cannot override these with our own custom VaultAuth provider To get around this issue we end up having to call k sInit for every interaction we need to do so we can make sure to use fresh credentials val credProvider CustomVaultCredentialProvider def k simplicit a ActorSystem m Materializer KubernetesClient val k sCluster Cluster server clusterEndpoint certificateAuthority SomeRightclusterCA val k sContext Context k sCluster This is where the token gets refreshed for skuber TokenAuthcredProviderrefreshAccessTokengetTokenValue val k sConfig Configuration clusters Mapdefault k sCluster contexts Mapdefault k sContext currentContext k sContext k sInitk sConfig Do something with it k sget JobList I am requesting to make AccessTokenAuth subclassable from outside of skuber That way we can implement a VaultTokenAuth extends AccessTokenAuth and have it work similarly to the existing GcpAuth Hey there I have some code that looks like this scala def scaleDeploymentnamespace String name String newScale Int Future Scale skuberusingNamespacenamespacegetScale Deployment nameflatMap scale val downscale scalewithSpecReplicasnewScale skuberusingNamespacenamespaceupdateScale Deployment name downscale calling this method with nonzero values in newScale works just fine However if I need to scale the deployment to then Unmarshalling fails with the following error e JsErrorListspecreplicasListJsonValidationErrorListerrorpathmissingWrappedArray akkahttpscaladslserverRejectionError at skuberjsonPlayJsonSupportForAkkaHttpanonfununmarshaller PlayJsonSupportForAkkaHttpscala at playapilibsjsonJsErrorrecoverTotalJsResultscala at skuberjsonPlayJsonSupportForAkkaHttpread PlayJsonSupportForAkkaHttpscala at skuberjsonPlayJsonSupportForAkkaHttpanonfununmarshaller PlayJsonSupportForAkkaHttpscala at akkahttpscaladslutilFastFutureanonfunmap FastFuturescala at akkahttpscaladslutilFastFuturestrictTransform FastFuturescala at akkahttpscaladslutilFastFuturetransformWithextension FastFuturescala at akkahttpscaladslutilFastFuturemapextensionFastFuturescala at akkahttpscaladslunmarshallingUnmarshalleranonfunmap Unmarshallerscala at akkahttpscaladslunmarshallingUnmarshalleranonfuntransform Unmarshallerscala at akkahttpscaladslunmarshallingUnmarshalleranon applyUnmarshallerscala at akkahttpscaladslunmarshallingLowerPriorityGenericUnmarshallersanonfunmessageUnmarshallerFromEntityUnmarshaller GenericUnmarshallersscala at akkahttpscaladslunmarshallingUnmarshalleranon applyUnmarshallerscala at akkahttpscaladslunmarshallingUnmarshaltoUnmarshalscala at skuberapiclientimplKubernetesClientImplanonfuntoKubernetesResponse KubernetesClientImplscala at scalaconcurrentFutureanonfunflatMap Futurescala at scalaconcurrentimplPromiseanonfuntransformWith Promisescala at scalaconcurrentimplCallbackRunnablerunPromisescala at akkadispatchBatchingExecutorAbstractBatchprocessBatchBatchingExecutorscala at akkadispatchBatchingExecutorBlockableBatchanonfunrun BatchingExecutorscala at scalaruntimejava JFunction mcVspapplyJFunction mcVspjava at scalaconcurrentBlockContextwithBlockContextBlockContextscala at akkadispatchBatchingExecutorBlockableBatchrunBatchingExecutorscala at akkadispatchTaskInvocationrunAbstractDispatcherscala at akkadispatchForkJoinExecutorConfiguratorAkkaForkJoinTaskexecForkJoinExecutorConfiguratorscala at akkadispatchforkjoinForkJoinTaskdoExecForkJoinTaskjava at akkadispatchforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava at akkadispatchforkjoinForkJoinPoolrunWorkerForkJoinPooljava at akkadispatchforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava It seems that k s is omitting the value in replicas which invalidates the Json object for Skuber Is this a known issue perhaps related to Is there a workaround Thanks in advance M