 Hi Rust interduced asderef and asderefmut instead of doing it this way selfheadasrefmapnode node same can be achieved this way selfheadasderef and instead of doing it this way selfheadasmutmapnode mut node same can be achieved this way selfheadasderefmut Thanks Early on the book talks about a node not being allocated at all The book assumes an allocatedalwaysmeansheapallocated parlance not allocated at all implies stackallocated allocated implies heapallocated However some folks were taught using an allocatedmeanseitherstackorheapallocated parlance not allocated at all implies the object does not exist which is nonsensical in this context allocated is ambiguous and implies either stackallocated or heapallocated For folks in the second camp the books phrasing is super confusing until they realize a different parlance is being used The node with junk should have a comma similar to the other nodes Make clear that allocated means heapallocated Closes The text doesnt mention the requirement to change the import to use stdcellRef RefCell RefMut In I would appreciate clarification on exactly where and why the first node on the list gets deallocated from the heap by pop after pop uses memreplace or take Im loving your tutorial and Im hoping to get more clarity on Rusts deallocation strategies In the second version of push in it is confusing to have two definitions of newtail the second shadowing the first rust pub fn push mut self elem T FIRST DEFINITION let newtail BoxnewNode elem elem When you push onto the tail your next is always None next None Put the box in the right place and then grab a reference to its Node SECOND DEFINITION SHADOWING FIRST ONE let newtail match selftailtake Someoldtail If the old tail existed update it to point to the new tail oldtailnext Somenewtail oldtailnextasmutmapnode mut node None Otherwise update the head to point to it selfhead Somenewtail selfheadasmutmapnode mut node selftail newtail Is this a hint that they will wind up having the same value