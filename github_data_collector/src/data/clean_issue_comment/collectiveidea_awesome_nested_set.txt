select works great but I dont know how to generate views The examples I found only printed the first root so I wanted a full iteration of all categories We have STI classes like this ruby class Parent actsasnestedset countercache counter end class Foo Parent end class Bar Parent end Then when I try to move a Bar instance under the Foo instance doing barmovetochildof foo Id like to increment counter field of the parent class Foo but its impossible because the increment is done by doing internally like ruby selfclassincrementcounteractsasnestedsetoptions countercache newparent It virtually equals to the following in my case ruby Barincrementcountercounter foo But theyre an STI so the SQL which will be performed is like sql UPDATE parents SET counter COALESCEcounter WHERE parentstype Bar AND parentsid It updates no records because id is a type of Foo So I guess the codes in updatecountercache should be like ruby newparaetclassincrementcounteractsasnestedsetoptions countercache newparent If my guess is right Im willing to open a PullReq for it Thanks We bulk upload tree data which is very slow out of the box when you are dealing with K nodes We were able speed this up a bunch by disabling the callbacks and doing a rebuild after the the inserts see for those details Despite that the actual rebuild is still very slow and we are trying to think of a faster way to do it Does anyone have any thoughts on how to make it faster Either improving on what we already developer or allowing for parallel process so we could split up the tree into multiple background jobs Below is the scoped rebuild code we are using def selfrebuildtreeaccountid version modeled after rebuild in awesomenestedsetrb accountid is our scope rootnodes selfwhereaccountid accountid version versionroots indices scope lambdanode if actsasnestedsetoptions scope scope lambdanode scopecolumnnamesinjectstr columnname str AND connectionquotecolumnnamecolumnname connectionquotenodesendcolumnnametosym end setleftandrights lambda do node set left node leftcolumnname indices scopecallnode find NestSetModelwhere quotedparentcolumnfullname scopecallnode node orderquotedleftcolumnfullname quotedrightcolumnfullname ideachn setleftandrightscalln set right node rightcolumnname indices scopecallnode nodesavevalidate false end rootnodeseach do rootnode indices scopecallrootnode setleftandrightscallrootnode end end private def setzeroleftandrights self leftcolumnname unless self leftcolumnname present self rightcolumnname unless self rightcolumnname present end byebug commentchildren ArgumentError Exception wrong number of arguments given expected EXPECTED oO awesomenestedset is not currently compatible with Oracle as various places will trigger ArgumentError Combination of limit and lock is not supported See The three places Ive found that are triggering this in awesomenestedset are rightmostnodelock in rightmostbound lock true in reloadnestedset nestedsetscoperightofleftselectprimaryidlocktrue in destroydescendants I was able to work around the last one by adding my own beforedestroy to my model that handles child cleanup then sets selfskipbeforedestroy true but the others probably require more effort if locking is to be preserved I know that Oracle is a hardinaccessible platform to test on but hopefully this will help others who run into this problem get on the right track Im getting this error using Rails ArgumentError Unknown key order Valid keys are classname anonymousclass foreignkey validate autosave tablename beforeadd afteradd beforeremove afterremove extend primarykey dependent as through source sourcetype inverseof countercache jointable foreigntype indexerrors I think that removing the order solved the issue Im refactor my code with bulkinsert for a tree im already using awesomenestedset and I have an array with several objects where they only have the parentid Actually im using rebuild inside a Job But I think that is not an efficient solution So I appreciate if you have any ideas to improve my code I use bulkinsert gem Job class MassiveInsertJob ApplicationJob queueas default def perform task structure Taskcreaterhytmictasktask structure Taskrebuild begin SendPusherJobperformlatertask structure message Rhythmic task ok type notice rescue error puts error end end end Bulk Taskbulkinsertname uniqueid ownerid sectorid currentprogress basestartdate baseenddate baseduration basedaysduration startdate enddate duration daysduration currentstate completionstatus reschedulescount source projectganttid rhytmictask active calendaruniqueid parentid lft rgt createdat updatedat do worker arraychildreneach do task array task name task uniqueid task ownerid task sectorid task currentprogress task basestartdate task baseenddate task baseduration task basedaysduration task startdate task enddate task duration task daysduration task currentstate task completionstatus task reschedulescount task source task projectganttid task rhytmictask task active task calendaruniqueid task parentid task lft task rgt DateTimenow DateTimenow workeradd array end end I create inventoryitem then call movetochildof then generate the below SQL which is very slow Anyone can help SQL ms UPDATE inventoryitems SET lft CASE WHEN lft BETWEEN AND THEN lft WHEN lft BETWEEN AND THEN lft ELSE lft END rgt CASE WHEN rgt BETWEEN AND THEN rgt WHEN rgt BETWEEN AND THEN rgt ELSE rgt END parentid CASE WHEN id THEN ELSE parentid END updatedat WHERE inventoryitemsid IN SELECT inventoryitemsid FROM inventoryitems WHERE inventoryitemslft BETWEEN AND OR inventoryitemsrgt BETWEEN AND ORDER BY inventoryitemslft ASC While this feature may be somewhat niche I had a need for it I thought I would PR the changes in case anyone else finds them useful The unscoped changes did not break any specs but I do wonder about whether that might be a breaking change for some people One upside from my perspective though is that it gets closer to supporting other default scope gems like actsasparanoid Example Use Case Using the spec models for consistency Categories have many things through CategoriesThings Things have many categories through CategoriesThings Existing behavior was that when viewing a list of Things for a given Category that list is return in alphabetical order by a field body You want to add awesomenestedset to CategoriesThings to allow custom ordering You also want to preserve the alphabetical order for existing records until a user explicitly changes it Changes were needed in order to reference an order belonging to a different database table Hi folks At solidusiosolidus we have a use case for which I cant find a good solution and I would like your advices We have many taxonomies and each taxonomy is a nested set of taxons Taxons can be any depth level so they have ancestors We have an API endpoint where the user can ask for multiple taxons at once and we generate a pretty name for each one in the form of Ancestor Ancestor Ancestor LeafTaxon To do that we use the ancestors method but it generates a new SQL query for each taxon the user asked to retrieve a typical N problem What I would like to do would be to includesancestors but its not defined as an hasmany and thus dont work Do you have any tips on how to preload all ancestors of multiple taxons with the minimum amount of SQL queries 