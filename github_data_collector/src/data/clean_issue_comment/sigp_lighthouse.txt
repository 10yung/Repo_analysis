 Issue Addressed None Proposed Changes Fixed all clippy warnings I could find Additional Info Allowed warnings beaconnoderestapisrclibrs beaconnoderestapisrcrouterrs eth utilslighthousemetricssrclibrs eth utilssszteststestsrs eth utilsssztypessrcbitfieldrs I think I caught a bug in reducedtreers where the error would not actually get returned Possible bug avoided Description The forwards block iterator can be given an end state as a reference point This should be done for nonfinalized iterations We should pass the state and the blockhash to Storeforwardsblockrootsiterator as the endstate and endblockroot params At the moment the function on the BeaconChain hardcodes the current head which should be true for finalized iters We should loop through stateblockroots to see if the block is a recent ancester If so use current head as the state If not we can search for the block and state which is resource heavy or error and renegotiate requests Description This updates the network crates to support shard subnets and the naive attestation aggregation strategy This adds a variety of features including gossipsub message validation This upgrade addresses the following issues Description It would be great if there was a rest API method to detect whether a node is synchronized For example the prysm client has a ethv alpha nodesyncing which returns a bool This is important when orchestrating multiple beacon nodes and knowing when they are ready to serve traffic Potentially related issues Issue Addressed Closes Proposed Changes Removes outdated yaml file Add proposer slashing endpoint and associated test Add attester slashing endpoint and associated test Add documentation to the lighthouse book Fix some clippy warnings Sort the beacon api mdbook to make it easier to find endpoints Sprouls SPRP Tips Description Since we made the hot database sparse disk reads of states have increased from around MBmin to MBmin This is due to the loading of epoch boundary states when processing attestations which bypasses the checkpoint cache Steps to resolve I have a workinprogress implementation on my epochboundarycache branch that uses the existing checkpoint cache but has the disadvantage of increasing the size of the checkpoint cache from to it needs to be in order to have a good chance of the two most recent boundary states being in the cache It successfully reduces reads to about MBmin but the memory usage has proved problematic for my node even with GB of memory states should only be MB max so this could be a manifestation of In order to keep the cache small or at least have that as an option I think we could use an LRU cache and set its minimum size to something slightly larger than perhaps During the refactor I think it would also be beneficial to split the cache into separate block and state caches as when we load an epoch boundary state we dont have a full checkpoint but we may want to add it to the cache if it wasnt already there Issue Addressed NA Proposed Changes Removes ReducedTree and replaces it with ProtoArray TODO Remove Ages syncbugfinder Description In perblockprocessing we store a list of intermediate states when fastfowarding a state through skip slots Given that each state is on the order of MB theyre mb when SSZ encoded not sure what they consumer when in RAM theres an attack here to force us to skip forward more blocks than we can keep in RAM Suggestions Enforce a maxskip slots value This was found to be annoying in testnets so perhaps we allow it to be disabled at runtime Store the blocks in the DB as we go and unwind if we encounter an error Id probably lean towards a combination of the both still has a DoS vector that we can fill up a filesystem but we can fit many more states in the DB than in RAM because theres more memory and there is compression efficiency when storing in the DB that is not present in RAM Description Presently there is no way for a user to submit slashings to the beacon node We can fix this by providing some API endpoints to insert them into the op pool Steps to resolve Add two HTTP endpoints to the restapi POST beaconproposerslashing accepts a ProposerSlashing and feeds it to op poolinsertproposerslashing POST beaconattesterslashing same as above but sproposerattester pscott I think this is a good one for you 