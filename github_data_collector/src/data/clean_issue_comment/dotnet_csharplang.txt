Similarly to how we can stack using blocks I would like to see us be able to stack try and unsafe Eg cs Old try unsafe Do stuff in unsafe context New We can keep them on one line for legibility try unsafe Do stuff in unsafe context Usecase Sometimes especially in the case of tryfinally blocks the entire try clause is unsafe context For instance heres some code I put together in learning how to use Span cs public PasswordSecureString password IntPtr valuePtr IntPtrZero try valuePtr MarshalSecureStringToGlobalAllocUnicodepassword unsafe password new SpancharvaluePtrToPointer passwordLength finally MarshalZeroFreeGlobalAllocUnicodevaluePtr In this case the marshal operation could be placed in the unsafe block without issue and thus the entire try clause could be made unsafe Forgive me for using SecureString the point was learning how to use lowlevel stuff like marshaling and span so I went allin This is not production code I felt try unsafe should be the proper order since it reads somewhat like try this unsafe action though if unsafe try seems better due to keyword ranking or whatever other reasons Id love to hear thoughts I tend to run into this type of pattern quite often c public static class Cache public T GetObjectTstring key CacheTGetObjectkey private static class CacheT Error name cannot match enclosing type private Dictionarystring T lookup public T GetObjectstring key lookup key Obviously I can find a different name for the inner class but sometimes thats annoying in terms of code readability and in the case of nested generic types there is only an ambiguity if the number of generic parameters is the same so it would be nice to lift the matching name restriction for that particular case Programming languages are opinionated Programming languages are opinionated whether we like it or not Any given programming language makes some things easy and other things not as easy If someone is programming and has to choose between the two the language effectively encourages them to do things the easy way Sometimes the opinions of a language are intentional but sometimes the opinions are incidental and do not align with the language authors own opinions When that happens that is a language design smell When we design and modify a language we should aim to have its opinions align with our own C grew up opinionated C came preloaded with a set of opinions inherited from its predecessors It is objectoriented operations on a data type should be placed on the data type on which they operate If an operation varies in behavior from one kind of instance to another it should be virtual internal dispatch The exceptions to this inherited from nonobjectoriented C are the integral and enum types for which switch permits external dispatch C is imperative algorithms are expressed as a sequence of steps described by statements C is mutationbased objects are mutable and the purpose of computation is to mutate data Concurrency is expressed by protecting mutable data with monitors lock to provide mutual exclusion during mutation Opinions have changed over time As weve learned more about good software engineering practices weve reconsidered these opinions and modified the language and its libraries accordingly We added extension methods to permit a nonvirtual operation to be declared outside the type on which it operates while being used by the client as if it were a member We added a number of enhancements to make more declarative and less imperative code possible such as expressionbodied methods Linq the elvis operator and local functions We added libraries that support forkjoin concurrency and asynchronous computation pipelines We added autoproperties to make it easier to declare APIs with immutable members In all of these we moved the languages opinion not by making the existing things harder but by adding yet easier ways of doing things that align with our opinions of what is right The opinionated purpose of Programming With Data features This cluster of features aims to move Cs opinion From internal dispatch to external dispatch From mutation based to patterns that work well with immutable data From imperative statement oriented to declarative eg expression oriented One shortcoming of Cs opinion is that internal dispatch is frequently inappropriate for programminginthelarge ie for data types that span component boundaries This is particularly true when the data type cannot anticipate all of the operations that clients will want to perform on it or when the data type is described by a set of related types Extension methods do not help much because they are not virtual they give the appearance of internal dispatch without actually providing support for it Two programming patterns that can be used to address this are the use of visitors and switching on kind fields These are widely used throughout Roslyn Both permit constanttime dispatch based on the logical kind of the data type But these programming patterns are clumsy and errorprone C adds typeswitch patternmatching in the switch statement as a more direct way of expressing external dispatch without these issues Typeswitch moves the languages opinion toward external dispatch but currently it has a performance penalty that is enough to discourage many uses which we are trying to address with runtime support The purpose of records and patternmatching are to reorient Cs opinions toward what are now understood to be better programming practices APIs for exchange types types that are interfaces between program components are better operated upon using external dispatch than internal dispatch for operations that are not core to the meaning of the data types Expressionoriented code can be more declarative and more clear than statementoriented code we seek to make it easier to express algorithms using expressionoriented approaches Many design issues are simpler when exchange types have an immutable API surface We dont seek to change Cs opinion that variables should by default be immutable though we are open to that as we do not propose using fields for these API elements Example of a language design pitfall It might seem that adding support for a hypothetical readonly modifier to parameters and locals would move the languages opinion in alignment with these directions That is not so for two reasons First readonly int x is not shorter than int x so the opinion has hardly moved val instead of var is slightly better but it moves an opinion from encouraging mutability of locals toward being neutral about the mutability of locals But it adds the opinion that types for locals should be inferred which is not intended It also doesnt make immutable preferred because it isnt shorter Second the benefits of immutability occur at API boundaries not within a method body So the hypothetical change even if it moved the languages opinion would not do so in accordance with the reason for wanting to move the opinion Im not saying the readonly modifier would be a bad idea just that it doesnt fit with this theme For similar reasons expression blocks are not particularly useful to move the languages opinion in a direction consistent with these preferences Which is not to say it is a bad idea A design principle for Programming With Data There is a useful design criterion for this cluster of features that can make them more intuitive for programmers there should be a syntactic alignment between the principal operations on an exchange type The principal operations are declaration creation decomposiion and dispatch We can draw a matrix of categories of types to see how were doing so far Type Declaration Creation Decomposition Dispatch pattern intint x int xint x or class with mutable fieldsclass Point public int X Y new Point X Y pXPoint X int x Y int y or Point X Y anonymous typenew X Y pX X int x Y int y or X Y record classclass Pointint X int Y proposedPoint proposedint x int y pPointint x int y or Point tupleint x int y int x int y pint x int y or ListListintnew Listint DictionaryDictionaryKVnew DictionaryKV K V This illustrates our attempt to align the syntax between the different forms in which a type is used That alignment helps build the programmers intuition and simplifies understanding of the features Hopefully we can keep the syntactic forms simple and aligned to continue that tradition Currently C is very limited in code quotation abilities as it only supports lambdaexpressions without statements in them which were originally introduced for LINQ Some other languages like LISP and Nemerle provide a much more powerful tool quasiquotation Ie not only they allow to represent language expressions syntax trees statically as literals but also allow to incorporate dynamically generated expressions into them in the same manner as string interpolation works Thats how it could possibly look in C csharp Expression FFuncint Expression expr var fourtyTwo ExpressionContant return x x fourtyTwo expr In this case Fi ExpressionConstanti will return an expression equivalent to x x In the code above expression represents a quote with a literal representation of an expression inside name and expression represent incorporated values Potentially a quotation block could contain any expression representable by the SystemLinqExpressions hierarchy That means quotes can be recursive quotes within quotes which questions the rules of interpolation should name always target the topmost in quotation sense name and be escaped with subsequent appending of more s or should it unquote one level up and each added means unqoute one more level up csharp var e expr var lam e e lamCompileInvokeexpr In the first case the result would be expr in the second case expr In the same fashion of the or operators there should be a operator for the cases when we want to flip a boolean without having to selfreassign it This is especially nice in practice when using long camelcased variable names Because instead of looking for a in the midst of a long code line we can much more easily identify at the end and recognize its importance csharp bool longCamelCasedVariableName false later in code longCamelCasedVariableName longCamelCasedVariableName This instead would be written as csharp bool longCamelCasedVariableName false later in code longCamelCasedVariableName Ive found myself running into this a few times as I port my libs to NRTs It would be useful to be able to specify that a particular property or method return value means that a related property or field will not be null It could be marked in either direction and the second example is probably easier to implement in the NRT flow analyzer though the first example reads much nicer to me and can be implemented with overloaded constructors on the existing attributes c public class Path public bool IsFilePath get public bool IsDirectoryPath IsFilePath I think this is much nicer overload NotNullWhen NotNullWhennameofIsFilePath true NotNullWhennameofIsDirectoryPath false public Path ParentDirectory get public class Path This direction feels a bit more awkward and probably requires new attributes to feel somewhat sensible IndicatesNotNullWhentrue nameofParentDirectory public bool IsFilePath get IndicatesNotNullWhenfalse nameofParentDirectory public bool IsDirectoryPath IsFilePath public Path ParentDirectory get Path path GetPath if pathIsFilePath Do not warn that ParentDirectory may be null ConsoleWriteLineParent directory pathParentDirectoryToString else Warning that ParentDirectory may be null if or is not used ConsoleWriteLineParent directory pathParentDirectoryToString none This shouldcould also work for fields c public class CollectionOfStuff NotNullWhennameofIsEmpty false private Stuff stuff public bool IsEmpty stuff null stuffLength public void DoSomething if IsEmpty ArrayReversestuff Dont warn that stuff may be null I played around with various ways to name the IndicatesNotNullWhen annotation and arrange the parameters but I couldnt really come up with something that felt right That said both annotations could be useful since the IndicatesNotNullWhen variation could be used on return values of methods as well c public class PersonEntity public string Name get set return IndicatesNotNullWhentrue nameofName public bool IsValid return stringIsNullOrWhiteSpaceName var person GetPerson if personIsValid string nameParts personNameSplit Dont warn that Name might be null With the introduction of nonnullable reference types Ive hit a case a few times where I want to create a class like this one public abstract class FooT where T notnull public T Value get set But I cannot because the compiler complains A nullable type parameter must be known to be a value type or a nonnullable reference type Nonnullable property Value is uninitialized Consider declaring the property as nullable Are there any plans to allow this Am I missing something I have my suspicions on why it was left out but it feels like this could be allowed to some degree since nameof operator returns only the last member of the expression to get the full path we must call nameof multiple times as follow c nameofhttpContextnameofhttpContextResponsenameofhttpContextResponseStatusCode to get the httpContextResponseStatusCode string if c would have a new operator that get whole expression only the last call would be sufficient so I propose a new operator to do this job that returns the same previous string c fullnameofhttpContextResponseStatusCode httpContextResponseStatusCode true So a little context Im working with a binding around the Vulkan Graphics and Compute API and some of its methods have Span and pointer overloads I need to pass a null literal for this but its somehow ambiguous between SpanT and T SpanT has an implicit conversion from a T array which can notably be a null reference causing this but shouldnt it use a direct match to null T instead of causing this ambiguous resolution cs public static void MyMethodSpanint span public static unsafe void MyMethodint ptr MyMethodnull This is somehow ambiguous 