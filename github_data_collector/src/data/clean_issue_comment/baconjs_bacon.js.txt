It swallows startWith and mapEnd values expected behaviour Calling startWith or mapEnd multiple times on a stream injects those values just fine in the right order javascript BaconfromArray startWith startWith mapEnd mapEnd flatMapx Bacononcex observed behaviour javascript BaconfromArray startWith missing after flatMapLatestBacononce startWith mapEnd missing after flatMapLatestBacononce mapEnd flatMapLatestx Bacononcex Id expect flatMapLatestBacononce to behave like flatMapBacononce Somehow the following startWith and mapEnd events are delivered too quickly to allow Bacononce to emit just its only value Id like to discuss the things Ive done here Its not very elegant and more the brute force speak shell scripts code Good things first In another test step all existing unit tests are transpiled to use the new aggregated ES module distBaconmjs Those tests identified another issue in srctopromisets where the TS compiler did generate ES code which breaks when invoked This again underlines that one cannot blindly trust the TS compiler output and running tests on the dist files may always be necessary Personally I find this really scary Didnt they always say TS was compatible to JS Unit tests all green Lacking much TypeScript or Chai knowledge and being new to ES modules these bad things happened Transpiling unit tests takes ages Transpiling to a directory inside the test sources may be not wise In the preparation shell script I had to fix some import paths using a hammer ie sed Cleanup shell script uses some scary rm instructions At least I did not rm rf though I struggled with Bluebirds and zenobservables module format when used as custom Promise constructor and Standard ES Observable will there ever be such a thing Still at proposal Stage last presented July in the tests Bumps mixindeep from to details summaryCommitssummary f c ee fa ensure keys are valid when mixing in values See full diff in compare view details details summaryMaintainer changessummary This version was pushed to npm by doowb a new releaser for mixindeep since your current version details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details For consistency the seed value is optional in fold and scan too Type signature for fold and scan similar to the proposed signature of flatScan Implementation of scanSeedless is rather naive Maybe thats why I had to mark many unit tests unstable switching aggressively mode did always fail dont know why In doubt what UpdateBarrierwhenDoneWith is so I simply removed it for scanSeedless Duplicated most unit tests to check the seedless methods TODO Update documentation This is probably not exactly an issue with bacon itself but since Im new to FRP I would like to hear opinions For the project Im working on I came to a stage where I need a kind of feedback mechanism Since I still think mostly in imperative programming terms I cant figure out a way to avoid it Basically I have a simple Requests stream that has to be transformed into Responses stream This is a nodejs project and the requests are actually send over a serial port thus requests have to be send synchronously So far I have used flatMapConcat which did great in queuing the requests and dispatching them one by one But for some technical reasons I have to avoid the queue Im not going into details but in short in specific situations the requests have to be dispatched either immediately or not at all lets say that executing the queued requests later is of no use Of course the logical thing is to use flatMapFirst which does exactly the above My problems started when the requirement emerged that the dropped requests have to be redirected to another stream for simplicity lets say to a logger I created a property which indicates whether theres an active request and tried to modulate the request stream with it Heres a simplified diagram The problem with this approach is that it introduces a cyclic dependency When I try to run this I get stack overflow RangeError Maximum call stack size exceeded at flushDepsOf nodemodules baconjs dist Baconjs at flushDepsOf nodemodules baconjs dist Baconjs at flushDepsOf nodemodules baconjs dist Baconjs I found a way around this by breaking the dependency chain by separating the flow graph with a Bus This works as expected since busy no longer seems to be dependent on Requests But its little ugly of course I looked into the code related to flushDepsOf and the problem is that the flushed map gets filled in for a given observable only when all its dependencies are flushed Of course if the same observable is found somewhere within these dependencies it becomes infinite recursion I tried moving the flushed obsid true line before iterating through the dependencies This of course avoids the infinite recursion but probably can cause troubles in some cases This is my first ever work with FRP so I dont really know what Im up against here First is cyclic dependence really a sign of wrong approach to the problem Feedback mechanisms exist in all domains of engineering programming etc so probably it should be allowed in FRP too If it is not is there some trick that can rearrange the flow in a such a way that cycles can be avoided so far I havent thought of one Second if cyclic dependencies are not strictly forbidden does this mean that bacon can be improved to better handle them like the solution with moving the flushed line above Thank you Arrayfilter can change the type of the array when passed a userdefined type guard See for example this this gets inferred as number string const numberOrStringArray jee this is inferred as number thanks to the type guard const numberArray numberOrStringArray filterx x is number typeof x number Could Observablefilter support a similar type guard The type definition for Arrayfilter in the example is filterS extends Tcallbackfn value T index number array T value is S thisArg any S If just the reducer function is given the first value of the source stream will be passed as initial event of the resulting Property and used as the left argument when the reducer is first invoked on the second source event Ive found this useful to save meaningless lines of code It should be easy understand because JS users are familiar with Arrayreduce where the seed value is also optional It should also be nonbreaking javascript BaconfromArray flatScana b a blog If you are in favour of this change perhaps scan should be extended as well Remarks Ive found it very difficult to please the TypeScripts type checking Because the first parameter to flatScan is mow multimorphic ie a value or a function Which IMO is naturally for dynamic JavaScript however TypeScript makes it really hard to enable this at all Ive not updated the documentation yet My superficial issue is to document explicitly that the sideeffect f in observableonValuef like observablesubscribef has the ability to cancel its subscription of stream updates by returning BaconnoMore After hours of debugging see code example below this really came as a surprise for me because Ive never had an event consumer function to update the event flow logic Up to now I did not care what my sideeffects return Promises Strings or whatever Is this an API which is worth supporting I mean Does this encourage good programming practise Can this break for innocentlooking sideeffect functions Eg returning a WebComponent tag which could be nomore or the example below Breaking a stable API is bad but IMO this feature is dangerous What does everybody think Here my example of two nested BaconfromBinders Can you spot why outerStream is unsubscribed even though nobody calls unsubscribe or returns BaconnoMore explicitly javascript var outerStream BaconfromBinderfunction myOuterBindersinkOutside const innerStream BaconfromBinderfunction myInnerBindersinkInside quasi sinking sinkInside into sinkOutside setTimeoutsinkOutside sinkInside return consolelogcleaning inner innerStreamtake onValuex consoleloginner consumer x return consolelogouter clean up outerStreamonValuef finner value f is sinkInside actually The output is cleaning inner OK because take inner consumer inner value OK outer clean up THIS WAS A SURPISE The solution begins with that sinkInside of the inner streams binder returns BaconnoMore because of take This is then fed to the outer streams onValue sideeffect invoker by the ES arrow function in the last line I could blame it on ES arrow functions because rewriting the sideeffect to a regular function expression fixes the behaviour javascript outeronValuefunctionf finner value cleaning inner inner consumer inner value However if someone comes along and refactors it back into an arrow function the bug reappears Ive read and answered to numerous complaints that code involving bustoProperty does not work And I totally agree that its counterintuitive that something like this from Bacon FAQ does not work javascript var bus new BaconBus var property bustoPropertyFIRST buspushSECOND propertyonValuefunctionval consolelogval Youd like the console to log SECOND but it logs FIRST instead Whats happening here is that your Property wont get updated when there are no listeners Before you add an actual listener using onValue the Property is not active its not listening to the underlying Bus It ignores input until someones interested So it all boils down to the laziness of all Bacon streams and properties This is a key feature too the streams automatically plug in to their sources when a subscriber is added and unplug when there are no more subscribers A simple patch for this would be to have BustoProperty always add a dummy subscriber to the resulting Property Then again it would fail in setups like this busmapx x toProperty so its not such a great patch after all Or is it Because if you flipped it like bustoPropertymapx x it would be good again The underlying problem is that the subscribercountbased mechanism for change propagation in Baconjs doesnt serve you well in cases when you create a stateful Property on top of a stateless EventStream unless you always have at least one subscriber on the Property One option Im halfseriously considering is to have Properties throw an error in cases where you resubscribe after the last subscriber has been removed This is probably always a bug in application code because it can lead to propagating outdated values Thoughts 