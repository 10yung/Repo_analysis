At printfs first placeholder strings have gotten reversed Mainly at ArchinitFpus CONFIGXSAVEXSAVES block Line x wrmsrIA XSSMSR desiredfeatures IA XSSMSR is defined with typo value of xD A it should be xDA The above variable desiredfeatures does not have desired value Because IA XSS MSR can only be set a few bits other values will cause generalprotection fault Line set nullFpuStateheaderxcompbv But its type xsavestatet has mismatched size with XSAVE area Based on Intel manual its size should be bytes B legacy region plus B XSAVE header But now it is only B as its legacy regioni statet has only bytes And in these codes some relevant namescomments look also none consistent with Intel manual Maybe it is better to take a careful look at them thoroughly According to the newest ACPI specificationversion RSDP structure can be found in either of the two placessection One is at E h FFFFFh the other is at the first KB of the Extended BIOS Data Area function acpigetrsdp implemented only the first one To increase seL compatibility we can add a little code just before line unsigned long ebda uint t x e EBDA base address ebda if ebda x Linux use this value to validate the base address for addr char ebda addr char ebda addr if strncmpaddr acpistrrsd if acpicalcchecksumaddr ACPIV SIZE return acpirsdpt addr Hi In boot stage when memory map entries exceed limitation will give a warning The warning used a false format zd it could be d And the preceding alternation to multibootmmaplength is too early for the printf wants its original value Thus line should follow the printf statement Regards Happy New Year again Some low level console io functions like printf have bugs in file printunsignedlonglong will print leading s of lowerright bytes after printing upperleft bytes When all lower parts are s it will break out in line after testing shifts That means all lower parts have been done But line printunsignedlonglower uibase will still be executedprinting another Wrong Line should be if shifts at least left number to allow the next statement to deal Like d format vprintf will print padding spaces after printing the argument value in line n printspacesnspaces n But as nspaces counting padding request and n counting total printed nspaces n has no means And most likely nspaces will be less than n To patch this it should append a temporary varible to record original n just after getting nspaces then after printing the arg value n printspacesnspaces n orign Here printspaces should also be fixed In line of printspaces it should return i instead of ndeclare i outside for loop Thus whenever n or n the return value will all be the correct result In x sizeoflong When printflul the biggest value will be decimals long Now in line of printunsignedlong it just gives the buffer size sizeofunsigned long So buffer maybe overflow Wish these helpful Regards Happy New Year In cmdlineparse wants to print information about arguments cmdline and consoleport Because printf eventually use x KSdebugPort but not x KSconsolePort to work and x KSdebugPort hasnt got meaningful value yet so it failed The most straightforward way to fix it is to give x KSdebugPort the same value as x KSconsolePort before L But as nobody in kernel tree use x KSconsolePort maybe its better to remove it Regards Merry Christmas used wrong mask x to test x PCID feature According to Intel and IA ArchitecturesSoftware Developer s Manual Table bit is PCID flag its mask is x So the above statement should be andl x ecx Regards This adds the RISCV PLIC driver for Ariane and updates the device tree The following changes are made to ensure that invariants hold for IPC situations and to ensure that the receiver of an IPC does not need to trust a sender not to cause it to receive an IPC without an SC Senders of IPCs to passive servers are not given any control as to whether SCs are donated so as to avoid the situation where a passive server expects an SC but ends up inactive with no SC due to misplaced trust in the sender The new semantics for scheduling context donation are simply that if the sender has not timeout faulted the receiver has no SC and the sender has an SC then the senders SC will be donated to the receiver If the sender has an SC it is guaranteed to be ready on its core unless it is a timeout fault in which case the SC wont be donated to the receiver This ensures a receiver will never timeout fault but that it may become unschedulable if it ends up without an SC To prevent this trusted software should not remove scheduling contexts from TCBs blocked on send to endpoints serviced by passive servers Additionally scheduling contexts must be configured and ready to execute on the core for which they are configured in order to be bound to a TCB or notification This ensures that notification objects and threads blocked on endpoints are configured such that a receive operation will lead to the receiver having no SC or a ready SC but never a unready timedout SC The necessary updates to sel test can be found in the sel sel test PR So as to ensure that all TCBs in queues are either faulted passive or have schedulable SCs we cannot allow arbitrary SCs to be bound to TCBs that are already in queues If a TCB is in a queue it should first be removed before having an SC bound to it