test ringbuffer code looks like may get wrong value after resizing and Im not sure why ringbuffer need resize if its not a bug would you mind explain the design of ringbuffer implementation in freecache code snippet below var d byte rb NewRingBuf fmtPrintlnstringrbDump fmtPrintlnwrite writeoffset rbEnd rbWrite byte fmtPrintlnbuffer stringrbDump fmtPrintlnrbString fmtPrintln index rbEnd fmtPrintlnwrite abcdef writeoffset rbEnd rbWrite byteabcdef fmtPrintlnbuffer stringrbDump fmtPrintlnrbString fmtPrintln fmtPrintlnafter resize to rbResize fmtPrintlnbuffer stringrbDump fmtPrintlnrbString fmtPrintln fmtPrintlnwrite AB rbWrite byteAB fmtPrintlnbuffer stringrbDump fmtPrintlnrbString fmtPrintln fmtPrintlnread abcdef by offset index rbReadAtd index fmtPrintlnstringd result below write writeoffset buffer size start end index write abcdef writeoffset buffer cdef ab size start end index after resize to buffer abcdef size start end index write AB buffer ABabcdef size start end index read abcdef by offset cdef can port over the ideas to freecache it doesnt have expiry controls timeNow will sometimes result in a full system call this is the default on AWS EC instances I think for an LRU you can probably get away with second precision One option would be to have a background goroutine that called timeNow every second and cached the result globally is this production ready any issues i shld be looking out for Simplifying logic thats duplicated Makes stats consistent with how theyre getting cleared and locates them to a single method Because the value is only support byte we should serializeunserialize our data each setget operation this will cost more CPU time And the serializedunserialized object will free which cause more GC Why do we just use interface as value add method Resize newSize oldSize keep all entry newSie oldSize discard all entry bug case go package main import fmt strconv time githubcomcoocoodfreecache githubcomzhangcunlifreecache func main cachesize cache freecacheNewCachecachesize value aaa key bytekey value value cacheSetkey bytevalue it cacheNewIterator for entry itNext if entry nil break fmtPrintf iterator keys values n stringentryKey stringentryValue value value XXXXXX cacheSetkey bytevalue value value XXXXYYYYYYY cacheSetkey bytevalue it cacheNewIterator for entry itNext if entry nil break fmtPrintf iterator keys values n stringentryKey stringentryValue Support resize cache size at runtime Do you have schedule of this feature Thanks Is it possible to make this stuff configurable Using mmap as a backend for saving data to disk may be a good choice