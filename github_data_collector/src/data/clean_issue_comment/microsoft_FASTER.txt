This is related to When recover fails usually the serializer will be activated with a bad data stream The actual call stack of deserialization will cause an unhandled exception to bubble up and kill the process A possible workaround would be to catch the exception on the site But then it would not be pretty the wire the explosion back to business code Also a corrupted data stream is a show stopper anyway Call Stack Root SystemPrivateCoreLibdllSystemThreadingIOCompletionCallbackPerformIOCompletionCallbackuint errorCode uint numBytes SystemThreadingNativeOverlapped pNativeOverlapped Unknown Process Crash The active test run was aborted Reason Test host process crashed Unhandled exception SystemTextJsonJsonException The input does not contain any JSON tokens REMOVED FOR CONCISION at FasterDictionaryFasterDictionary BaseSerializer DeserializeTContent obj in C Codigo FasterDictionary FasterDictionary src FasterDictionary FasterDictionarySerializerscsline at FasterDictionaryFasterDictionary ValueSerializerDeserializeValueEnvelope obj in C Codigo FasterDictionary FasterDictionary src FasterDictionary FasterDictionarySerializerscsline at FASTERcoreGenericAllocator DeserializeByte raw Int ptr Int untilptr Record src Stream stream at FASTERcoreGenericAllocator AsyncReadPageWithObjectsCallback TContext UInt errorCode UInt numBytes NativeOverlapped overlap at SystemThreadingIOCompletionCallbackPerformIOCompletionCallbackUInt errorCode UInt numBytes NativeOverlapped pNativeOverlapped Proposal There should be a way to communicate a bad stream back to the Recover call site Could we have a context maybe as a parameter to serializer methods so we can signal any problems Id gladly detail and prepare a PR In the current version of FASTER C on Linux we use libaio for async IO handling It is a known issue that libaio is not very efficient Recently iouring is released with Linux kernel which advertises to be a high performance aysnc IO library It would be useful to try it and see if we can improve disk performance on Linux by replacing libaio with it More details for iouring can be found here Right now the FASTER constructor takes IFunctions as input These function callbacks identify how to perform operations such as readingwriting RMW inplace and copyupdates etc An interesting alternative would be to provide them later during session creation and associate the functions with sessions instead of the main FASTER instance This would let different sessions use different functions Eg one session could perform RMW for incrementing field while another could perform a different function It would make it easier to use the same FASTER instance to store different forms of data one can do it even today via functions that switch between the different operations based on input but maybe a bit more cumbersome Note that all the sessions will still see the same data types TKey TValue TInput etc but will be able to operate on the data in a customized way Further the late binding of functions means that users can change the function being performed during runtime by simply deleting the older session and creating a new session with the new functions There might be a performance implication due to the late binding this is as yet unknown Is it possible to Write TryEnqueue in FasterLog and periodically read from same FasterLog and truncateuntil simultaneously I get Unable to add item to list exception during this process Implemented a checkpoint and log commit using cloud storage completing the device package Also adds some refactoring for the original code More testing is needed before merge Opening this PR now so it is visible and I dont forget The test fails from time to time in CI run for Linux build RUN PagingTestQueueUpsertReadConcurrent homevstswork scctestpagingtesth Failure Expected equality of these values StatusPending Which is byte object result Which is byte object FAILED PagingTestQueueUpsertReadConcurrent ms Example of CI runs Hi If I understand the code correctly the C version of FASTER doesnt handle CPRSHIFTDETECTED and RETRYLATER OperationStatuses in Delete method We would like to support a separate read cache in FASTER C The basic idea is to have a separate instance of the hybrid log that acts as the read cache and sits between the hash table and the main hybrid log The index points to records in either the read cache or the log Entries in the read cache point to their previous record either on the read cache or the main log Main log entries never point to the read cache The read cache has two regions in memory identical to the main log Reads of records in the immutable region cause them to be copied over to the tail serving as the cache policy When pages expire from the read cache head address expiring records need to be evicted ie their previous pointers have to be updated Read more about the read cache in the C PR here Hi Are there plans to refactor C part of the project to be conformant with W The C version of FASTER has the ability to compact a portion of the head of the log copying live records to the tail We need to port this capability to C This is a straightforward enhancement and the design is already flushed out in the C version More info can be found in the C PR Depends on 