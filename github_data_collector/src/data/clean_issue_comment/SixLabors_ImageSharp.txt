 Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open x I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop x I have provided test coverage for my change where applicable Description Merge sources and tests from SixLaborsCore resolve Namespace structure were left untouched The new source structure follows namespace hierarchy in src SixLaborsCore tests have been grouped under their own directory Most memoryintensive ArrayPoolMemoryAllocatorTests have been disabled temporarily The safest way to run such tests would be arcanes RemoteExecutor Do not squashmerge Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open x I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop x I have provided test coverage for my change where applicable Description Added ability to skip pixel data for each row Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open x I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop x I have provided test coverage for my change where applicable Description see Please change from internal so I can subclass Image the following methods Accept EnsureNotDisposed Doing so will allow me to create a MipMap class based off of Image for the ImageSharpTextures library Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open x I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop x I have provided test coverage for my change where applicable Description Currently WIP and started PR so that progress can be watched and commented on Thanks for contributing to ImageSharp Prerequisites X I have written a descriptive pullrequest title X I have verified that there are no overlapping pullrequests open X I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop X I have provided test coverage for my change where applicable Description The OilPaintingProcessor was allocating arrays for each single pixel being processed Ive switched to a single shared float array rented from the used configuration and Im using that as temporary data for all the processing bins In doing so Ive also switched to UnsafeAdd for all the readwrite operations to the bins for that extra microoptimization breeze Just noticed those throwaway arrays while working on my other pull request and I couldnt resist Thanks for contributing to ImageSharp Introduction Apart from the API simplification the main intent of was to enable new optimizations its possible to eliminate a bunch of unnecessary processing steps from the most common YCbCr Jpeg thumbnail making usecase As it turned out in simply changing the pixel type to Rgba is not sufficient we need to implement the processing pipeline optimizations enabled by the NET Core Hardware Intrinsic API especially by the shuffle and permutation intrinsics which are allowowing fast conversion between different pixel type representations and component orders eg Rgba Rgb as well as fast conversion between Planar and Packed pixel representations The latter is important because raw Jpeg data consists of planes representing the YCbCr data while an ImageSharp Image is always packed This analyisis Kicks off by explaining the causes of the Rgb slowdown in Defines Processing Pipelines as a chains of Data States and Transformations Presents a deep overview of the current floating point Jpeg and Resize pipelines showing incremental improvement opportunities Note the Resize pipeline is still TODO and it will remain so for a couple of daysweeks This should not prevent you from getting the big picture though Roughly explains the challenges of adding integer SIMD operations to the Jpeg pipeline Please let me know if some pieces are still hard to follow Its worth to check out all URLs while reading TLDR If you want to hear some good news before reading through the whole thing jump to the Conclusion part Why is Rgb post processing slow in our current code YCbCr TPixel conversions the generic case JpegImagePostprocessor is processing the YCbCr data in two steps Color convert AND pack the Y Cb Cr image planes to Vector RGBA buffers The two operations are carried out together by the matching JpegColorConverter With the YCbCr colorspace which has only components this is already a suboptimal since the th alpha component Vector W is redundant Vector packing is done with nonvectorized code Convert the Vector buffer to pixel buffer using the pixel specific implementation Rgba vs Rgb Perf profile for PostProcessIntoImageRgba Perf profile for PostProcessIntoImageRgb The difference is that PixelOperationsRgba FromVector does not need to do any component shuffling only expanding byte values to floats while in PixelOperationsRgba FromVector we first convert the float buffers to Rgba buffers fast which is followed by an Rgba Rgb conversion using the suboptimal default conversion implementation This operation Could be significantly optimized by utilizing byte shuffling SIMD intrinsics Is in fact unnecessary By extending JpegColorConverter with a method to pack data into Vector buffers we could convert Vector data into Rgb data exactly the same way we do the Vector Rgba conversion Definition of Processing Pipelines Personally my memory is terrible and I always need to reverse engineer my own code when we want to understand whats happening and make decisions Lack of comments and confusing terminology is also misleading To get a good overview its really important to step back and abstract away implementation details by thinking about our algorithms as PIPELINES composed of Data States and Transformations where D Data States nodes are representations of pixel data buffers in a specific form T Transformations edges are specific SIMD or scalar implementations of algorithms This representation is only good for analyzing data flow for a specific configuration eg a well defined input image format decoder configuration output pixel type To visualize the junctions we need DAG nerdface Current floating point YCbCr Jpeg Color Processing Resize pipelines improvement opportunities Presumtions The executing runtime is netcoreapp enables VectorWiden The executing CPU supports the AVX instruction set implying that VectorTs are in fact AVX registers and VectorT intrinsics are JITed to AVX instructions Vector operations are JITed to SSE instructions I Converting raw jpeg spectral data to YCbCr planes Converting raw jpeg spectral data to YCbCr planes done by CopyBlocksToColorBuffer D planes of quantized spectral Int jpeg components x Buffer DBlock x YCbCr T AVX Int Int widening and Int float conversion both using VectorT implemented in Block x FLoadFromBlock x D planes of quantized spectral float jpeg components x Buffer DBlock x YCbCr T Dequantization by SSE multiplication Block x FMultiplyInplaceDequantiazationTable D planes of DEquantized spectral float jpeg components x Buffer DBlock x YCbCr T SSE floating point IDCT D Planes of float jpeg color channels x Buffer DBlock x YCbCr T AVX normalization and rounding using VectorT Rounding is needed for better libjpeg compatibility D Planes of SUBSAMPLED float jpeg color channels normalized to x Buffer DBlock x YCbCr T Chroma supersampling No SIMD fully scalar code full of ugly optimizations to make it at least cache friendly Done by Block x CopyTo super misleading name D Planes of W H sized float jpeg color channels normalized to x Buffer DBlock x YCbCr II a Converting the YCbCr planes to an Rgba buffer YCbCr planes Rgba buffer done by ConvertColorsInto D Planes of W H sized float jpeg color channels normalized to x Buffer DBlock x YCbCr T Color convert and pack into a single Vector buffer D Floating point RGBA data as MemoryVector T Convert the Vector buffer to an Rgba buffer In the Rgba case case the input buffer could be handled as homogenous float buffer where all individual float values should be converted to bytes The conversion is implemented in BulkConvertNormalizedFloatToByteClampOverflows utilizing AVX conversion and narrowing operations through VectorT D The result image as an Rgba buffer II b Converting the YCbCr planes to an Rgba buffer current suboptimal pipeline YCbCr planes Rgb buffer done by ConvertColorsInto D Planes of W H sized float jpeg color channels normalized to x Buffer DBlock x YCbCr T Color convert and pack into a single Vector buffer D Floating point RGBA data as MemoryVector T Convert the Vector buffer to an Rgba buffer utilizing BulkConvertNormalizedFloatToByteClampOverflows utilizing AVX conversion and narrow operations through VectorT D Temporary Rgba buffer T PixelOperationsRgb FromRgba suboptimal extra transformation D The result image as an Rgb buffer II b Converting the YCbCr planes to an Rgba buffer IMPROVEMENT PROPOSAL YCbCr planes Rgb buffer done by ConvertColorsInto D Planes of W H sized float jpeg color channels normalized to x Buffer DBlock x YCbCr T Color convert and pack into a single Vector buffer We can utilize shuffling intrinsics for the packing Hint extend the JpegColorConverter interface with a bool CanConvertToRgbVector property and a ConvertToRgbVector method D Floating point RGBA data as MemoryVector T Convert the Vector buffer to an Rgba buffer using BulkConvertNormalizedFloatToByteClampOverflows D The result image as an Rgb buffer III a Resize ImageRgba current pipeline TODO III b Resize ImageRgb current pipeline TODO Without any change the current code shall run faster than for ImageRgba III b Resize ImageRgb IMPROVEMENT PROPOSAL TODO Integerbased SIMD pipelines Although the Hardware Intrinsic API removes all theoretical boundaries to have match with other high performance imaging libraries for both Jpeg Decoder and Resize by utilizing AVX and SSE integer algorithms there is a big practical challange Its very hard to introduce these improvements in an iterative manner Its not possible to exchange the elements of the Jpeg pipeline at arbitrary points because it would lead to insertion of extra float Int conversions To overcome this we should start introducing integer transformations and data states at the beginning andor at the end of the pipeline This could be done by replacing the transformations and the data states in subsequent PRs while moving the Int float conversion towards the bottom when starting from the beginning and the float byte conversion towards the top when starting from the end EG At the beginning of the pipeline first replace dequantization then IDCT then normalization etc At the end of the pipeline we shall implement a full integer YCbCr Rgb SIMD conversion first Conclusion If we aim for low hanging fruits I would start by implementing II b and III b After that we can continue by introducing integer SIMD operations starting at the beginning or at the end of the Jpeg pipeline I would also suggest to keep the current floating point pipeline in the codebase as is to avoid perf regressions for pre users I believe those platforms will be still relevant for many customers for a couple of other years I have done this effect but not very good I think so I am using DrawText method and precalculate every text watermark point to do But I havent found how to roate this text watermark when DrawText I want to make every text watemark rotate degree angle Like below image effect Wolud you have another simple way to do this preview Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open x I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop I have provided test coverage for my change where applicable Description A description of the changes proposed in the pullrequest The format of the and bit Bmp images embedded in an ico is subtly different and undocumented I came up with some changes to the Bmp decoder to properly process a Bmp image extracted from an ico file that has transparency Examples Here are several images that shows the effect of the changes The image samples Word document shows the original ico file the raw bitmap extraction from the ico and the fixed image using the updated code Thanks for contributing to ImageSharp Image samplesdocx Prerequisites x I have written a descriptive pullrequest title x I have verified that there are no overlapping pullrequests open I have verified that I am following matches the existing coding patterns and practice as demonstrated in the repository These follow strict Stylecop rules cop I have provided test coverage for my change where applicable Description Before going though all the prereqs since Im new to this project Im creating this to discuss further Note that the switch approach isnt possible because Types arent compile time constants If statements should work though 