According to the documentation it is stated that This library validates automatically the exp and nbf claims if present However from the source code it would be an optout option to validate exp claim causing a disparency from the documentation and the actual logic As specified in PS RSASSAPSS using SHA hash algorithm PS RSASSAPSS using SHA hash algorithm PS RSASSAPSS using SHA hash algorithm The RSASSAPSS signature verification algorithm is supported by ring Please specify that in the test folder the correct public key for privatersakeypem is publicrsakey pem and not publicrsakeypem Looking at the tests where the der files are one would assume that its publicrsakeypem that is the correct one but I only got the test token verified by using publicrsakey pem and thought there was something wrong in my base to bytearray conversion Im having a hard time authenticating a token using a x c MS OAuthAzure Below is the code rust Trying to isolate the problem by only checking the signature let validationconfig jsonwebtokenValidation algorithms vec jsonwebtokenAlgorithmRS leeway validateexp false validateiat false validatenbf false aud None iss None sub None let token eyJ eXAiOiJKV QiLCJhbGciOiJSUzI NiIsIn let x ccert MIIDBTCCAe gAwIBAgIQKOfEJNDyDplBSXKYcM let rawder base decodeconfigder base STANDARDunwrap let d jsonwebtokendecodeMsOAuthPayload token rawder validationconfig The above always returns InvalidSignature RS is the correct algo The cert is correct I tried it on jwtio by adding a BEGINEND cert and it validates fine I used ssl to convert the BEGINEND pem to DER and the bytes match up from the base decode The key URL is but my specific tenant returns the same keys Anyone have some insight on what Im doing wrong here Thanks There are quite a few changes happening in the PRs more input format for RSA ECDSA signing verification as well as some Validation changes I have already removed the iat check in the next branch since it isnt something that should be checked Right now Validationalgorithms is a vec I dont remember why but it shouldnt be the case it should be an algorithm Algorithm instead I will accept a PR for that or do it myself later also adds a standalone verifyrsa fn which Im wondering if we can somehow streamline it with the rest of the crate Since Rust doesnt have default parameters we always have to pass a Validation struct currently Maybe we can put the decoding onto this struct instead so you get something like rust currently let token decodeClaims token secretasref Validationdefault possible JwtDecoder has the same fields as the current Validation let token JwtDecoderdefaultdecodehs Claims token secretasref This way we dont have a single function where we are trying to fit all arguments inside and the user has to select explicitely which decode fn to use This solves the vec of algorithms at the same time and allows having better documentation for each The downside is duplication of those functionsdocs for the various digest values decodehs decodehs decodehs for each algo Any other ideascriticismsthings missing ccing the people involved in various issuesPRs recently AaronFriel jbg JakeShadle matthewnicholswesttel greglearns The listing for jsonwebtoken on seems to be outdated eg it claims you dont support exp checking You can submit a PR to update it at their repo I have a rust service that needs to verify JWTs from rdparty services that I do not control The rd party service Portier in this case supplies the RSA public components n modulus and e exponent Given that jsonwebtoken can only read DER encoded keys and that I cannot manually run the recommended commandline options for OpenSSL what is the recommended way of being able to decode a JWT using JsonWebToken in a rust service Currently I have been able to get an ssh public key from the rsa components n e but that seems like a dead end since a public ssh key doesnt seem to be easily converted to DER Any ideas Any plan to support JWE support 