In a recent paper Hoffmann Klo and Rupp show how to reduce the required blinding scalars to only a logarithmic number This could be a nice prover speedup The main idea is that for each value send in the inner product argument only a single blinding scalar is needed The blinding vector s therefore only needs logn random entries at specific positions Its explained in section of the paper They also have an implementation here CC devhoffmann Our implementation of the R CS system differs from the one described in the paper We extended the system to allow randomized constraints obtained as FiatShamir challenges bound to the entire previous proof transcript data This makes the system more powerful for example we can do a proofofshuffle asymptotically faster On than described in the paper On log n Our initial iteration of this idea had the limitation that the randomness could only be bound to the values of the externally committed wires the individual V commitments but for Cloak we needed to be able to bind the randomness to the values of internal wires committed to by the aL aR aO vector commitments To solve this problem oleganza came up with a twophase construction where the vector commitments are split and randomized eg aL aL eaL where aL is a vector with nonzero phase entries aL is a vector with nonzero phase entries and e is a FS challenge More details on the construction are available in our internal documentation Before we can release this API we need to a formalize the model for these randomized constraint systems and b have a security proof in that model We described this problem to bbuenz last fall and at the Stanford Blockchain Conference in January As of ZCon I think he said that he had suggested the problem to an MSc student but I dont remember the details I think this work would be done best in the open this GH issue is a good place to keep track of it because it blocks release of the R CS API See We should probably create a TranscriptError type that can be converted into either error type Im trying to update the R CS benchmark code for and Im a bit confused by the Randomized Randomizable distinction introduced in The documentation for RandomizableConstraintSystem says Gadgets that do not use randomization should use trait bound CS ConstraintSystem while gadgets that need randomization should use trait bound CS RandomizedConstraintSystem Gadgets generally should not use this trait as a bound on the CS argument it should be used by the higherorder protocol that composes gadgets together But the RandomizableConstraintSystem trait is the one with the specifyrandomizedconstraints so arent gadgets that need randomization forced to use the able trait not the ized trait This is a zkInterface adapter to use bulletproofs as a proving system See live demo See example usage I found these lines in proverrs rust fn constrain mut self lc LinearCombination TODO check that the linear combinations are valid eg that variables are valid that the linear combination evals to for prover etc I tried implementing this since I have some issues debugging a proof system I built Ive written rust fn constrain mut self lc LinearCombination let sum Scalar lctermsitermapv s let l match v VariableOne Scalarone VariableCommittedi selfv i VariableMultiplierLefti selfaL i VariableMultiplierRighti selfaR i VariableMultiplierOutputi selfaO i l s sum debugasserteqsum Scalarzero TODO check that the linear combinations are valid eg that variables are valid that the linear combination evals to for prover etc selfconstraintspushlc Which works but it changes the behaviour of the method Certain tests eg examplegadgettest started failing because now the prove system does not return Err on validation but panics earlier Another option would be to return Result R CSError in fn constrain but that alters the signature for ConstraintSystem and thus for verifier who will always return Ok anyhow It would also not allow to disable this behaviour on release builds What kind of implementation for this TODO would you consider best Maybe even something different from my proposals It allows for the challenge phase to accept closures that take some more context eg moving nonClone values in the challenge closure This works in stable since Rust cfr This closes issue In other news Im not yet happy with the static bound on the closures Since Im not yet worried about that kind of performance just hacking around currently Im not going to fight the borrow checker there yet Hi It was briefly discussed in the dalekcryptography slack that this crate currently cannot be used in nostd environments due to its internal usage of randthreadrng which obviously requires threadlocal storage and thus the std library oleganza proposed exposing an API such as verifywithrng which then the current verify would be a backwardscompatible wrapper for by passing in a randthreadrng verifywithrng should have a trait bound for Rng CryptoRng and possibly also SeedableRng since the FromEntropy trait also requires std Questions Would you like me to featuregate the publicity of this Ie cfgnotfeature std pub fn verifywithrng cfgfeature std fn verifywithrng So that explicitly only nostd users are trusted with passing in their own correctlyseeded PRNG Fixes Add a FnMut closure to Proverprove to allow the prover to adjust the generator capacity based on the circuit size for the given constraint system See 