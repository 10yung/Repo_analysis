 node compatible streams via readablestreams moduledeps module replacements without redirect module better hook for plugins to interact with browserify options before being consumed internally support for parsing more modern js out of the box resolve all npm audit reports add CI task document explicit platform support for browserify bundles public documented API for replacing modules deep in the graph can currently do it via js by mutating the builtins obj example drop older platform support to make these improvements easier this is my personal list happy to add others This is a breaking change see Fixes Working with javascript library from here It works as expected when used without browserify as it creates global Typed function in browser But when used browserify with gulp Its not working as expected as it not creating global function Typed when loaded in browser throwing error Typed is not functionThere also problems when used for other jQuery plugins in entry script I used import typedjslibtypedjs I am trying to bundle up imagemin but i get Error Parsing file C nodemodules fastglob out readers streamjs Unexpected token my mainjs file const imagemin requireimagemin const imageminJpegtran requireimageminjpegtran const imageminPngquant requireimageminpngquant async const files await imagemin imagesjpgpng destination buildimages plugins imageminJpegtran imageminPngquant quality consolelogfiles data Buffer e path buildimagesfoojpg An alternative that uses requirefastsafestringifystable instead of jsonstablestringify Fixes Im creating a threejs loader but theres a lot of sweet stuff from npm which Id really like to leverage Since I want as few dependencies as possible it would seem the best approach would be to use ES export import but that doesnt seem to be possible currently I understand that the current system makes that hard but it would seem like the generated format lends itself to just add a root level script at the bottom The generated function would wrap up all the scripts as it currently does but doesnt insert the code for the root script instead it wraps the require function with the root module to moduleid mappings which previously was inserted straight into the wrapping function and returns that wrapped assigned to require Super confusing but essentially a bundle file would look like Something which looks very close to whats currently being generated but instead assigned to require let require function function re n t Root level can now use require as per usual create an exposed API which can be imported let somedep requiresomedependency function foousingdep arg function barusingdep arg export foousingdep barusingdep Would there be any demand for such a feature or am I perhaps missing something Im far from an expert on neither javascript nor node the URL module is built in in node but when you have browserify in you stack that means nodejs great url module is replaced but non compatible trash making life very miserable Please change that requirement to the module that does not break nodejs functionality Hi I am creating a JWT creation with node packages but as my website is made with php I can not run nodejs and php at the same time so I did RND and I came to know about Browserify It great but I am having a issue like I need two variables of nodemodules var jwt requirejsonwebtoken var uuid requireuuidv but when I used browserify packages are added with so my code is giving me ReferenceError uuid is not defined var requirelodash var requirejquery var requirejsonwebtoken var requireuuidv May you please help me to get resolved it If you run browserify with an invalid command line option it displays a chunk of JS that would have thrown a module not found error if run It would save quite a bit of mental effort if it just told the user that the option is wrong browserify foo filejs functionfunction rentfunction oififn i ife i var cfunctiontypeof require requireiff creturn ci ifureturn ui var anew ErrorCannot find module ithrow acodeMODULENOTFOUNDavar pn i exportse i callpexportsfunctionrvar ne i r return onrppexportsrentreturn n i exportsforvar ufunctiontypeof require requirei itlengthiot i return oreturn r When importing an external module twice using both relative and absolute project path the module resolution path differs in slash prefix js Browserify externalajs addnew Readable read thispush requireajs requireajs thispushnull bundle pipeprocessstdout results in js functionfunction rentfunction oififn i ife i var cfunctiontypeof require requireiff creturn ci ifureturn ui var anew ErrorCannot find module ithrow acodeMODULENOTFOUNDavar pn i exportse i callpexportsfunctionrvar ne i r return onrppexportsrentreturn n i exportsforvar ufunctiontypeof require requirei itlengthiot i return oreturn r functionrequiremoduleexports requireajs requireajs ajsajsajsajs where the resolved paths are ajs and ajs causing one of them to not resolve to the target module on runtime One solution would be to not prefix relative imports with I couldnt find out why it was actually introduced