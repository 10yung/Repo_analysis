Open a py file and get message File mode specification error error server is incompatible with nowait EIN works well Mx pyntmode to restart pynt mode and got the same error Personal config System OS Mojave Python Already finished pip install pynt pip install jupyter etc This was the message I got after I hit kbdCc Cskbd ein warn No recorded kernelspecs for nil einnotebooklistnewnotebook Wrong type argument einnotebooklist nil I am using spacemacs on Windows and also my kbdMxkbd einjupyterserverstart works fine if I start it manually Start emacs and open a py file it immediately give me this error epcstartserver Server may raise an error Use Mx epcpoptolastserverprocessbuffer RET to see full traceback Traceback most recent call last File usrlocalbinpyntserve line in module import codebooksyntax File usrlocallibpython sitepackagescodebookinitpy line openfosenviron HOME pynt aclose SyntaxError invalid syntax Whats the best approach to merge pynt into the ipythonnotebook layer pyntserve fails for me with python because its using fstrings which were added in python python pyntserve Traceback most recent call last File hometaupannobackupvirtualenvsmyprojectbinpyntserve line in module import codebooksyntax File hometaupannobackupvirtualenvsmyprojectlibpython sitepackagescodebookinitpy line openfosenviron HOME pynt aclose SyntaxError invalid syntax Org mode has lots to offer over Jupyer notebooks JupyterLab EIN Off the top of my head good markup markdown has issues support for passing data between code blocks in different languages remote execution configured percell tree editing navigation facilities eg navimode Speed keys orgrefile to ease working with large documents Code cells in Org mode can execute in Jupyter kernels for various languages via the obipython package This gives the user dynamic completion from the kernel doc lookup from the kernel access to remote kernels By virtue of using Org notebooks written this way are trivially version controlled can generate source via tangling no more copypasting from notebooks are exportable to an absurd degree Exporters include ipynb Markdown html with Bootstrap LaTexPDF revealjs and Google slides Many more even docx are available via tools like oxpandoc The scimax project has very interesting additions video demo to obipython including emulating most Jupyter notebooks commands their keybindings see the scimaxjupytercommandmode hydra in here multiple kernels in one Org file live editable LaTeX previews Here are some ways Pynt could be more powerful with Org Org manages sessions kernels perdocument persubtree and percell with the most specific taking precedence This means that any operations which spawn new kernels could just inject a new subtree into the current document You could then capture the complete history with multiple code variants attached to different kernels all within one document Features like branch unpacking could benefit from having powerful tree manipulation facilities which are the heart of Org I assume youre relying on the markdown headings to manage the tree structure in the ipynb According to this spec youre limited to a depth of Org has no limit that I can find and more importantly it gives the user powerful tools to navigate the tree These tools open the door to more sophisticated cell generation facilities For example imagine generating a cell for each intermediate definition within a function trace of depth Maybe Id like to do that for different invocations and then poke around in the tree of generated cells Being forced to work at the toplevel of a notebook would make this unwieldy if not impossible Future proof The ideas in Pynt are not Jupyterspecific and ipynb can be generated from Org files I dont know the Pynt code well enough to guess the level of effort for this It likely mainly depends on how much experience the contributor has with automating Org I thought the best first step would be to discuss the proscons here to just dumping the entire region into the notebook So that you dont print out the exception trace Maybe print out a nice message This is for raising returns Just like were doing for for loops It would be similarly useful to have for while loops For example the django migration has the following class python Generated by Django on from djangodb import migrations models import djangodbmodelsdeletion class MigrationmigrationsMigration initial True dependencies operations migrationsCreateModel nameChoice fields id modelsAutoFieldautocreatedTrue primarykeyTrue serializeFalse verbosenameID choicetext modelsCharFieldmaxlength votes modelsIntegerFielddefault migrationsCreateModel nameQuestion fields id modelsAutoFieldautocreatedTrue primarykeyTrue serializeFalse verbosenameID questiontext modelsCharFieldmaxlength pubdate modelsDateTimeFieldverbosenamedate published migrationsAddField modelnamechoice namequestion fieldmodelsForeignKeyondeletedjangodbmodelsdeletionCASCADE topollsQuestion I cant access any of these fields The namespace scheme that would make the most sense would be initialMigration but this will clash with the namespace conventions for functions Will have to think about this some more