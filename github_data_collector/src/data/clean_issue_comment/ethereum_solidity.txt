 most probably made the rule list split hack obsolete we should verify that and can potentially merge the rule list back together Description While working on I noticed two minor issues in yulopti ConditionalUnsimplifier step was not available in the tool but present in OptimiserSuiteallSteps I suspect it might have been added later and nobody remembered to add it to the tool A typo repeated f in fflatten Checklist x Code compiles correctly x All tests are passing New tests have been created which fail without the change if possible README documentation was extended if necessary Changelog entry if change is visible to the user x Used meaningful commit messages Im not sure it this change requires anything in README or Changelog As for tests the tool is just a single cpp file and therefore does not have any as far as I can tell Please let me know if any of these should be added after all Description This is the initial part of the implementation of It provides a commandline application toolsyulphaser which can already load yul source code apply optimizations and rank the resulting programs by their size It runs a trivial completely randomized genetic algorithm and prints the result of each round to the console The pull request includes a few unit tests but the coverage is still minimal This is still work in progress Structure Program class encapsulates all the details of source code parsing analysis and application of optimizations An instance represents a syntax tree after a few hardcoded transformations disambiguation grouping hoisting etc and ready for arbitrary optimizations Chromosome class defines a sequence of optimization steps Provides methods for generating changing and accessing its sequence It does not know about Program and does not interact with it directly Population class runs the genetic algorithm It stores a set of chromosomes and refines it in subsequent algorithm rounds Its mostly concerned with controlling the flow of the algorithm and does not itself do anything complicated It uses Chromosome and Program to evaluate fitness of sequences Not yet implemented No mutation or crossover yet The algorithm just drops the worse half of the population in each round and refills it with randomized chromosomes No way to specify the seed for the random number generator yet Needs more unit tests For now I have tests only for Chromosome No saving and reloading of algorithm state When interrupted the state is lost A sequence is applied to the program only once Its supposed to be applied a few times in a loop Program is loaded from file and parsed each time its being evaluated I should keep one initialized instance and make a copy when I need to apply optimizations to it Lots of stuff is still hardcoded The program is not flexible enough for experimenting yet Known issues VarNameCleaner is disabled for now because it throws Source needs to be disambiguated even though it is already disambiguated FullInliner used to fail for me in the same way SSATransform too but on yulAssert instead Both went away when I changed how I pass AST and other objects around by value vs smart pointersreferences Its likely that Im using it wrong or copying something that should not really be copied I need to take a closer look at this Questions Should I worry about moving vectors of stdstrings around I realized that I could make almost all of them char const and save some dynamic allocations because step names are just constexprs but Im not sure its worth the time It wont be a bottleneck anyway Is it OK to use plain assert for sanity checks solAssert looks more like a normal check to me It throws exceptions and does not get removed in release builds so Im a bit reluctant to use it for heavier checks for invariants preconditions and generally stuff that should not happen unless there is actually a bug in the code Since yulphaser is not a library I had to list all the necessary cpp files again in testCMakeListstxt to have soltest link properly This does not seem like a very good solution Should I store those paths in some cmake variable Or maybe try to create a library out of the classes I want to test Tests for toolsyulphaser seem like they should go into a subdirectory in testtools but that directory already exists and contains extra tools for testing so It did not seem right to me to mix them with test cases so I put them in testsyulphaser instead Is that OK Checklist x Code compiles correctly x All tests are passing x New tests have been created which fail without the change if possible README documentation was extended if necessary Changelog entry if change is visible to the user x Used meaningful commit messages From the abstract documentation it seems like what the keyword does is mark the contract as nondeployable ie it needs to be inherited from Because contracts missing function implementations are always nondeployable they require abstract If this is the case shouldnt abstract be required also for contracts with constructor internal Depends on Part of Abstract Hey I am trying to standardize appended compact signatures in top of what GnosisSafe did There is interesting things happening in but it also seems to lack to standardize the signature format We have formats I know Canonical bytes size Compact bytes size v is padded to a single byte Super compact size v is embedded in r bitwise I think that maybe would be interesting to solidity have a type signature to create a new standard out of all and we could use something like function checkSigsignature memory signatures I think that if anything is done it should be looked into what GnosisSafe done and how we could improve in solidity for this implementation be more elegant Motivation However I think that this is such common thing that solidity should have it embedded so it becomes easier for all wallets understand the format of signature and that is a signature or multiple supported I know ya going to say to use Struct and Libraries and yes thats what I would have to use if this dont gets approved Specification WIP Brainstorm Signatures should Dynamic Size Depending on the type Can be nested a signature can contain other signatures that themselves can contain other signatures Have type accessible to contracts know what to do Can check against msgsender Can be null check against application logic Backwards Compatibility Could be part of ABIV Encoder so its under experimental features The solidity javascript library created using Emscripten defaults the namespace to Module this is can cause a conflict with other libraries that use the same namespace still using the default A suggestion of a new namespace could be Solidity emphasis on suggestion Backwards Compatibility The emscripten library is wrapped by solcjs and with the new WebAssembly ouput I assume that will be required to change as well This may the ideal opportunity to do the change as that will be the main library affected for the majority of end users Thanks Compiling all test contracts into bytecode Traceback most recent call last File hometravisbuildethereumsolidityscriptsbytecodecomparepreparereportpy line in module out err proccommunicatejsondumpsinputjson File usrlibpython subprocesspy line in communicate stdout stderr selfcommunicateinput endtime timeout File usrlibpython subprocesspy line in communicate inputview memoryviewselfinput TypeError memoryview str object does not have the buffer interface References Direct access to the stack is not allowed any more so we can remove most of the stack height checks Remove x AsmAnalysisInfostackHeightInfo AsmAnalyzermstackHeight some errors have to be checked differently but we should also rephrase the error messages since they are all talking about the stack