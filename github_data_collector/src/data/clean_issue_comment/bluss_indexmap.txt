This should improve the efficiency a bit and the code readability in the resolve function with one less tab Theres no reason it shouldnt work with the stdlib hashset Perhaps we can add a second method for this The serde feature is still always compiled with its std feature meaning that indexmaps serde feature is not nostd compatible In some of the benchmarks if I replace insert with code based on entry the benchmarks run slower If we could get these to performance parity then we can delete the insert code since it is duplicated by the functionality in entry To test this you can update insert to be like this note insertfull uses entry right now rust pub fn insert mut self key K value V OptionV selfinsertfullkey value The following is the benchmark difference I see when using entry in insert The hashmap benchmarks can be ignored ordermap is the interesting part The hashmap benchmarks are controls Change from before to after name nsiter nsiter diff nsiter diff inserthashmap inserthashmap inserthashmap inserthashmapintbigvalue inserthashmapstr inserthashmapstring inserthashmapstringoneshot insertorderedmap insertorderedmap insertorderedmap insertorderedmapintbigvalue insertorderedmapstr insertorderedmapstring Add iterators that iterate a sliced keyvalue range sliced in the orderindex space Before merging well look at if its not better to express using views from The main infidelity of the interface is the need to handle BoundExclusivestdusizeMAX which does not have an equivalent in the ij or ij and slices cant handle it natively The scaffolding in srcutil to create the slice and slicemut methods is somewhat verbose but it allows us to write neat code where it is used Fixes I was hacking on the compiler and I wrote rust Weve rejected overlap in each product in the sum Now we must account for the possibility that orpattern is a factor in a product A basic case to reject here is V a V a a let lastid prodidslastunwrap bindingsvaluesmutskiplenbeforeforeachval val lastid which is nice Maybe bindingsvaluesmutrangelenbeforeforeach would be nicer I would like to use IndexMap as a BTreeMap with faster reads and slower writes But calling sortkeys after every insert is pretty slow Would it be possible to have a insertsorted method that would just insert the element before the next bigger one Instead of cfgfeatures serde which is bit counterintuitive and not in consistency with rust ecosystem This PR adds operations to IndexMap and IndexSet that allow an entry to be moved to a specific position in the iteration order while preserving the order of all other entries The operations average computation time is proportional to the distance between the entrys current position and the new position assuming that probing the hash table takes constant time on average The PR requires an upgrade to Rust version because it relies on the rotateleft and rotateright methods of the slice type If upgrading to is deemed inappropriate at this time it may be necessary to delay merging this PR The new operations also may allow for an alternative implementation of orderedremove from PR in which the element being removed is first moved to the end of the ordering then IndexMappop is called This might be more efficient if the element to be removed is already close to the end I havent included that idea in the PR but it could be considered if the PR is accepted Please let me know if you find any problems in the PR that I need to fix One thing I am unsure about is whether returning Option is or is not an appropriateidiomatic way of supporting error detection in a method that wouldnt normally return anything Use Case My use case for this PR is that I am planning to create a GUI application where the user can manage a list of items including reordering the items by dragging and dropping an item in the list Internally the items may reference each other by a unique key Ideally I want to be able to look up an item efficiently by both its numerical index and its unique key IndexMap seems like a good fit for this use case and this PR would make it easier for me to implement the reordering through drag and drop