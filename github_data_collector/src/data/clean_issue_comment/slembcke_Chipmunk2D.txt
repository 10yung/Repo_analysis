When I try to add a body to a space that is not initialized I get the error Aborting due to Chipmunk error You have already added this body to this space You must not add it a second time Failed condition bodyspace space That error message is completely unrelated to the mistake that I made and I spent a few minutes being very confused as I was sure I had only added the body once Cherrypicked on x branch Im stuck on v due to atm Sorry this is not a bug I just wanted ask a question I could not figure out how to search the forums although the FAQ mentions a search field I cannot find it anywhere Also it seems that posting is only possible when you are logged in But how do I register a new account Is it possible at all Actually I was looking for some detail information on how transferred impulses are calculated during collisions I want to simulate objects that break during collision when the magnitude of transferred impulse exceeds a certain threshold If this happens I want to lower the restitution coefficient or even set it to zero But for this to work I need to know the approximate transferred impulse BEFORE the actual impulses isare applied Does this make sense at all Any ideas how to achieve this If you do a segment query from point A to point B and there is a shape covering point A that the query intersects it will call for that shape at point B instead of point A Heres the simplest reproduction I could come up with in C include chipmunkchipmunkh void foundShapecpShape cpVect point cpVect cpFloat alpha void printfFound shape at gg with alphagpointxpointyalpha int main cpSpace space nmGetPhysicsWorld cpBody body cpSpaceGetStaticBodyspace cpSpaceAddShapespace cpCircleShapeNewbody cpvzero cpSpaceSegmentQueryspacecpv cpv CPSHAPEFILTERALL foundShape NULL return The output is Found shape at with alpha It should be Found shape at with alpha Might be worth checking other query types for similar edge cases There is no CMAKE toggle that can be used to chose single precision floating point Currently the floating point precision is hardcoded in the header depending on platform Hey and forever cheers for this wonderful Chipmunk project which I keep sticking to over the years I also recently dove into Rust which is I think a very promising lowlevel language both modern and efficient Wondering how Rust and Chipmunk could interact I came accross this page listing known Chipmunk binding and ports which does not include Rust yet On the Rust side I found two crates the first chipmunksys claims it only wraps syslevel calls for the second chipmunk claiming its work in progress but seems abandonned since Did you know about them Is a port to Rust or a neat binding already on the roadmap somewhere Has anybody else started anything in this direction When bridging this library into Swift the stricter typing means that all the CGFloat values from UIKit have to be cast back and forth from cpFloat With this change cpFloat is typedefed CGFloat if CPUSECGTYPES is set which means no casts are required This should have no effect when used from C as CGFloat should be either float or double depending on the same conditions as cpFloat uses A user of pymunk made me aware that cpSpacePointQuery and cpSpacePointQueryNearest treats sensor shapes differently The Nearest version ignore senor shapes while the other does not It seems a bit inconsistent and confusing The code itself is clear so I dont really know if this is a bug or a feature May be useful for tracking APIABI changes in the library The report is created with the help of opensource abitracker tool chipmunk d chipmunk d Environment Linux x GCC Chipmunk D and higher