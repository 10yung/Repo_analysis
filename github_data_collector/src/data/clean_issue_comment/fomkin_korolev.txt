Internal messages queue solves the problem which is already solved by any PubSub system Besides we force all users to watch on Any in theirs Context This is not good We decided to move StateStorage under the hood Saving state to external storage demanded by no one this is just an improvement point currently buttonLogin eventlogin wont give compiling error It will help beginners a lot if invalid JavaScript event names such as login give compiling errors I dont think Scala has enum types Can we use singleton types to make the event interface typesafe x Rename korolevAsync to koroleveffectEffect x Rename run to runAsync x Add unsafeRun x Add koroleveffectstreamStream instead of LazyBytes x Drop catseffectsupport x Add korolevcats for integration with koroleveffect x Add korolevzio for integration with koroleveffect x Add korolevmonix for integration with koroleveffect x Rename akkahttp to akka x Add akka streams korolev streams conversion x Merge korolevserver and korolev modules x Current conception of Effectfork is totally wrong and unable to represent IOTask meaning of fork Must be redesigned x Effectpromise should be redesigned to support lazy semantics x Rewrite server to support lazy effect semantics x Rewrite main code to support lazy effect semantics x Drop korolevexecution package The first problem is that PartialFunction doesnt compose well Example scala val f PartialFunction Int Int case f PartialFunction Int Int function val f PartialFunction Int Int case f PartialFunction Int Int function f andThenf res PartialFunction Int Int function res isDefinedAt res Boolean true res scalaMatchError of class javalangInteger And this leads us to the problem I want to log the state before and after toState call Of cause I can write it directly but what is FP for I want to do is as middleware and compose it Maybe its better to use Kleisli with OptionT here It composes well The Second problem again with PartialFunction and toState The signature of the function is PartialFunction RouterPath S F S And if I want to make a decision about handling the path based on the old state I just cant do it in the pattern matching All I can do is to return the old state What if change Router definition like this scala final case class Router F Async S fromState Kleisli Option S RouterPath toState Kleisli OptionT F RouterPath S S Web Components fell short of expectations Most of components are extremely heavy Low browsers support API is complicated We should add an our own component API to empower JavaScript interoperability Few months ago we were drop blaze support Currently only one backed for use is akka Its not fair Lets add http s support Minimal application where issue is reproducible render body scala body form formId input type checkbox name sfoobar button Upload eventclick access for formData accessdownloadFormDataformIdstart printlnsformData formData yield If checkbox is not checked formData is empty actually Upload leads to javanioBufferUnderflowException Currently head is the same for all application We cant modify it for different pages What we need to do KorolevServiceConfighead should be function Standard things like a title css and script urls should be able to get defined as strings Custom tags also should be supported Its required for custom metadata head tag attributes should be customizable Its also required for custom metadata Facebook Open Graph for example scala head state Head title Hello world styles Seq scripts Seq customHeadAttributes Map customTags Seq meta 