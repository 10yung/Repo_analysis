This commit extends the Func type in the wasmtime crate with static wrap constructors The goal of these constructors is to create a Func type which has zero shims associated with it creating as small of a layer as possible between wasm code and calling imported Rust code This is achieved by creating an extern C shim function which matches the ABI of what Cranelift will generate and then the host function is passed directly into an InstanceHandle to get called later This also enables enough inlining opportunities that LLVM will be able to see all functions and inline everything to the point where your function is called immediately from wasm no questions asked Theres a few items which I think need some more discussion on this PR before we land it and Im also just curious how others think of an API like this for embedding Figuring out how traps work Right now ResultT Trap is intended to be supported as a return from a Rust closure but without generating a function shim its not trivial to generate a trap Currently the code sort of cops out by manually doing a segfault via writevolatile but that feels pretty brittle Im curious if others have a good idea of how to trigger a trap from Rust code Dealing with multivalue isnt supported yet I talked with fitzgen briefly but it sounds like we may not have a native ABI in Rust that matches up with multivalue returns Id ideally like to support Rust closures returning for example i i to automatically get wired up to a multivalue return import but the ABI of that Rust function I dont think matches what Cranelift currently does I suspect that this will require some work in Cranelift to maybe add a new ABI that matches the extern C abi for the native platform Im also curious to largely just get some more eyes on this Im shooting for an extremely low overhead Func wrapper but naturally theres a lot of possible unsafety here if things dont line up precisely Close review would definitely be appreciated Ive wanted to do this for some time but recently Ive been thinking that the wasmtimewasi crate should move over to the wasmtime API but to preserve the current functional semantics where it has zero shims at runtime I felt was important so I wanted to try to pursue this style of creating a lowoverhead Func Issue description lightbeam will try to calculate the remainder even if an overflow occurs in the function rems sh debugdiffcompile panicremainderoverflow wasm thread main panicked at attempt to calculate the remainder with overflow XXXwasmtimecrateslightbeamsrcbackendrs note run with RUSTBACKTRACE environment variable to display a backtrace This issue is related to the function rems when dealing with the i rems opcode I suspect this issue can also occurs in remu Reproduction Download panicremainderoverflow zip wat module type func result i func type result i i const i const i rems unreachable wasmtime commit fa f a e e d f bed cf Hi During fuzzing i found the following module that is consider as valid for wasmparser but reject by wasmtime both cranelift lightbeam backend validwasmparserbutrejectwasmtimezip Return error by wasmtime sh wasmtime validwasmparserbutrejectwasmtimewasm Error failed to run main module validwasmparserbutrejectwasmtimewasm Caused by WebAssembly failed to compile WebAssembly translation error Invalid input WebAssembly code at offset Invalid varu Error Cranelift CompileWasmInvalidWebAssembly message Invalid varu offset Part of On master for me currently I get cargo test test wasttestsuites misctraps Finished test unoptimized debuginfo targets in s Running targetdebugdepswasttestsuites f d a a a running test error test failed to rerun pass test wasttestsuites Caused by process didnt exit successfully homealexcodewasmtimetargetdebugdepswasttestsuites f d a a a misctraps signal SIGSEGV invalid memory reference The stack trace of the segfault looks like this details Thread wasttestsuites received signal SIGSEGV Segmentation fault dolookupx undefnameundefnameentry x ffff c b UnwindFindFDE newhashnewhashentry oldhasholdhashentry x ffff ff c ref x ffff f resultresultentry x ffff ff d scope x ffff ffe i version x ffff fd flags skip x typeclass undefmap x ffff fd f at dllookupc dllookupc No such file or directory gdb bt dolookupx undefnameundefnameentry x ffff c b UnwindFindFDE newhashnewhashentry oldhasholdhashentry x ffff ff c ref x ffff f resultresultentry x ffff ff d scope x ffff ffe i version x ffff fd flags skip x typeclass undefmap x ffff fd f at dllookupc x ffff de ef in dllookupsymbolx undefname x ffff c b UnwindFindFDE undefmap x ffff fd f refrefentry x ffff ff symbolscope x ffff fd version x ffff fd typeclasstypeclassentry flags skipmapoptimized out at dllookupc x ffff de ec in dlfixup loptimized out relocargoptimized out at elfdlruntimec x ffff dec ca in dlruntimeresolvexsavec at sysdepsx dltrampolineh x ffff a in from libx linuxgnulibgccsso x ffff a in from libx linuxgnulibgccsso x ffff a in UnwindBacktrace from libx linuxgnulibgccsso x bccf d in backtracebacktracelibunwindtrace cb at homealexcargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized cb at homealexcargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x bcce e in backtracebacktracetrace cb at homealexcargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x bc d in backtracecaptureBacktracecreate ip at homealexcargoregistrysrcgithubcom ecc db ec backtrace srccapturers x bc in backtracecaptureBacktracenewunresolved at homealexcargoregistrysrcgithubcom ecc db ec backtrace srccapturers x b a c in RecordTrap pc x ffff f incomplete sequence resetguardpagefalse at cratesruntimesrctraphandlersrs x bb cba in HandleTrap context x ffff ff resetguardpagefalse at signalhandlersSignalHandlerscpp x bb d in WasmTrapHandler signum info x ffff ff b context x ffff ff at signalhandlersSignalHandlerscpp signal handler called x ffff f in x fffffff c in x ffff f in x fffffff ad in x bb b in WasmtimeCallTrampoline vmctx x bb e stdthreadlocalLocalKeyTtrywith body x ffff fd args x fffffff b at signalhandlersTrampolinescpp Backtrace stopped previous frame inner to this frame corrupt stack details where the faulting instruction looks like this details Dump of assembler code for function dolookupx x ffff ddf push r x ffff ddf push r x ffff ddf push r x ffff ddf push r x ffff ddf push rbp x ffff ddf push rbx x ffff ddf a sub x rsp x ffff ddf mov x r eax x ffff ddf mov rdi x rsp x ffff ddf a mov rsirsp x ffff ddf e mov rdx x rsp x ffff ddf mov rcx x rsp details where I can read rsp x in gdb but I cant write to it I believe whats happening here looks like this Wasmtime registers signal handlers with SAONSTACK The Rust standard library configures an alternate stack if one isnt already configured perthread The stack defaults to SIGSTKSZ bytes which is bytes on x linux When a wasm trap happens we call Backtracenewunresolved This ends up consuming enough stack space that we blow the stack hitting presumably some sort of guard page This doesnt appear to be happening on CI and from what I can guess its relatively localized and dependent on stack sizes here and there This may also be glibc related because the actual fault itself is in the dynamic loader presumably since this was the first time I generated a backtrace I believe though that pages at most apparently isnt enough to generate a full stack trace note that were also hitting things like malloc which we pray works Im not really sure what best to do about this I can actually fix this locally by calling Backtracenewunresolved somewhere randomly in the program before it hits a fault since that way the dynamic loader isnt triggered during the trap handler Unfortunately its not really easy for us to set our own stack to handle faults on since that would involve poking with sigaltstack on all threads wasmtime is called on which may lead to excessive overhead The stack pointer of the various frames are for one trace in a debug build function rsp diff from previous WasmTrapHandler x ffff ff HandleTrap x ffff ff f RecordTrap x ffff ff f backtracecaptureBacktracenewunresolved x ffff ff e backtracecaptureBacktracecreate x ffff ff backtracebacktracetrace x ffff ff d backtracebacktracetraceunsynchronized x ffff ff a backtracebacktracelibunwindtrace x ffff ff a UnwindBacktrace x ffff ff df x ffff ff c x ffff ff bc dlruntimeresolvexsavec x ffff ff dlfixup x ffff ff dllookupsymbolx x ffff ff dolookupx x ffff ff f Since libstd allocates pages for the stack handler Im assuming that the stack was from x ffff ff to x ffff ff which is why dolookupx faulted Im not sure why WasmTrapHandler started so low but maybe theres a bunch of kernel data structures or signal information on the stack Unsure In any case it looks like we definitely cant run the dynamic loader in SIGSTKSZ but we presumably can run backtraces because thats whats already happening on CI I wanted to get this all written down in an issue somewhere because Im about to send a PR for a pretty bad hack which doesnt truly fix the issue but should patch over the problem for now hopefully I think the wasm obj binary should be removed This patch adds initial support for ittapi which is an open source profiling api for instrumentation and tracing and profiling of jitted code Build cargo build featuresprofiling Profile Using amplxecl from VTune amplxecl v collect hostpost targetdebugwasmtime jitprofile testwasm Note Vtune is a free open source profiling tool for identifying performance bottlenecks This patch which brings in ittapirs when the profiling feature is enabled currently only supports the profiling of jitted code but I am investigating using ittapi for profiling of wasmtime itself with a future patch that builds on this one Issue description An addition with overflow make lightbeam to panic when compiled in debug mode Note This issue is similar to I suspect other overflows like those ones to be in the code Overflowed values are then provided to dynasm meaning that in release mode Lightbeam will generate Assembly code that will try to access invalid memory address like x kernel address etc leading to different errorspanics sh targetdebugdebuglightbeam loadaddoverflowlightbeamwasm thread main panicked at attempt to add with overflow XXXwasmtimecrateslightbeamsrcbackendrs note run with RUSTBACKTRACE environment variable to display a backtrace This issue is related to the macro load when dealing with the i load s opcode Reproduction Download loadaddoverflowlightbeamzip or wasm wat loadaddoverflowlightbeamwasm wat module type func func type i const i const i load s offset align unreachable memory export start func Testing program need to be compiled in debug mode ie RUSTFLAGSg cargo build rust use stdenv use stdfsFile use stdio use stdioRead use stdpathPathBuf use wasmtimefuzzingoracles use wasmtimejitCompilationStrategy Read the contents of a file fn readcontentspath PathBuf ResultVecu ioError let mut buffer Vecu Vecnew let mut file Fileopenpath filereadtoend mut buffer dropfile Okbuffer fn main let args VecString envargscollect let wasmpath stdpathPathBuffrom args let wasmbinary Vecu readcontents wasmpathunwrap let rescompile oraclescompile wasmbinary CompilationStrategyLightbeam wasmtime commit dcd fd d c a afeb dea e This commit adds support to the wasmtimeModule type to parse the text format This is often quite convenient to support in testing or tinkering with the runtime Additionally the wat parser is pretty lightweight and easy to add to builds so its relatively easy for us to support as well The exact manner that this is now supported comes with a few updates to the existing API A new optional feature of the wasmtime crate wat has been added This is enabled by default The Modulenew API now takes impl AsRef u instead of just u and when the wat feature is enabled it will attempt to interpret it either as a wasm binary or as the text format Note that this check is quite cheap since you just check the first byte A Modulefromfile API was added as a convenience to parse a file from disk allowing error messages for wat files on disk to be a bit nicer APIs like Modulenewunchecked and Modulevalidate remain unchanged they require the binary format to be called The intention here is to make this as convenient as possible for new developers of the wasmtime crate By changing the default behavior though this has ramifications such as for example supporting the text format implicitly through the C API now Im curious to get others feedback here on this change theres naturally a number of variations this could take beyond the one Im proposing here We could not add support at all the wat crate is just one Cargotoml line away anyway We could make wat an offbydefault feature We could add explicit functions to parse wat files I would personally advocate that this proposal asis is the best of all worlds though sunfishcodes suggestion of a watparsebytes function which takes either wasm or wat is perhaps the singlemost convenient thing Ive seen in a long time so I think we can get a lot of mileage from enabling this by default in all the typical APIs If an environment doesnt want the wat parser to be supported then its always optional and can be easily disabled without affecting clients too much since wat parsing is likely only used as a convenience If you build with rather than setuptoolsrust I hear its less picky about which python version the result binds to Might help simplify your build a bit maybe