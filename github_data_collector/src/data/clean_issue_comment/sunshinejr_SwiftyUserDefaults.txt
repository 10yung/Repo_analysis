unarchiveObjectwith was deprecated in Mac Catalyst Use unarchivedObjectOfClassfromDataerror instead archivedDatawithRootObject was deprecated in Mac Catalyst Use archivedDataWithRootObjectrequiringSecureCodingerror instead I think it can support Mac Catalyst iOS runs on Mac Here are a few small warnings to deal with img width altScreenshot at PM src Facing this issue while updating to swift I recently experienced a crash I installed it using SwiftPM but it crashed Its release build not debug build To test this I ran a manual Cocoapods installation But there was no problem So I reinstalled with Cocoapods Some other librarieseg Parchment had same issue Using generic seems to be the problem The library seems to prevent apps from running on iOS and possibly below except when being run via Xcode Nether TestFlight nor AdHoc build works when installed to a iOS device However the same build works on a iOS device I tested this with a newly created blank project only adding SwiftyUserDefaults via CocoaPods Removing the pod makes the app work again Keysswift extension DefaultsKeys enum Foo enum Bar var key DefaultsKeyString initfoobar key defaultValue enum Bar var key DefaultsKeyString initfoobar key defaultValue Testswift Defaults How can I work In the earlier x version I had this class SomeClass NSObject NSCoding var someVariable String initbookIdentifier String superinit selfsomeVariable someVariable NSCoding func encodewith aCoder NSCoder aCoderencodesomeVariable forKey someVariable NSCoding required initcoder aDecoder NSCoder selfsomeVariable aDecoderdecodeObjectforKey someVariable as String extension DefaultsKeys static let someVariables DefaultsKey String SomeClass someVariables extension UserDefaults subscriptkey DefaultsKey String SomeClass String SomeClass get if let someVariables unarchivekey return someVariables else return set archivekey newValue According to migration guide it should be now just class SomeClass NSObject NSCoding DefaultsSerializable var someVariable String initbookIdentifier String superinit selfsomeVariable someVariable NSCoding func encodewith aCoder NSCoder aCoderencodesomeVariable forKey someVariable NSCoding required initcoder aDecoder NSCoder selfsomeVariable aDecoderdecodeObjectforKey someVariable as String extension DefaultsKeys static let someVariables DefaultsKey String SomeClass someVariables defaultValue But Im getting following error User Defaults Attempt to set a nonpropertylist object AppNameSomeClass x fc as an NSUserDefaultsCFPreferences value for key someVariables Terminating app due to uncaught exception NSInvalidArgumentException reason Attempt to insert nonproperty list object AppNameSomeClass x fc for key someVariables So it doesnt seems to support dictionary with NSCoding values even though you state that String Any is supported I am trying to store value Date in user defaults This is the key static let firstActivityDate DefaultsKeyDatefirstActivityDate And code responsible for storing func setActivityDate if Defaults AppRateDefaultsfirstActivityDate nil Defaults AppRateDefaultsfirstActivityDate Date I have to run it twice in two sessions of application to correctly store value First attempt is showing value as long as app is up and running After turning off and running once again its once again empty After second attempt value persists Edit It seems to be connected with thread After running this part of code on the main it seems to work fine Is custom settergetter for defaults currently supported I saw in that it was initially planned but I dont see it in the docs When the UserDefaults return nil SwiftyUserDefaults falls back to using the defaultValue by default But what if you set eg a String that can be nil I thought defaultValue would mean the initial value but apparently it doesnt I think the current behavior is weird though Because you can sensibly use it to call registerdefaults and have your initial fallback values be used on one hand but then cannot get rid of it all all on the other Id prefer to change the implementation to fall back to defaultValue for nonoptional types only I started with UInt but the obvious next step would be to add Int and UInt The code is pretty repetitive In other projects we used a code generator for this to prevent typos and code thats getting on ones nerves to maintain But for new types and their tests we could stick with manual implementations just as well Do you want to support the other types out of the box at all anyway Do you want manual or generated code