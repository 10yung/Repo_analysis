As far as I know it is not possible to set default options to be used by all scopes in a specific controller The use case that I have is that there are a bunch of scopes in my controller but all of them should only apply to the index action Currently I would have to add only index to each of those hasscope forproject as projectid only index hasscope forsection as sectionid only index hasscope starred type boolean as focused only cardindex It would be nice to be able to set a bunch of defaults to be used by hasscopes in the controller I can imagine that this might not only be useful for only and except but possibly also with if A trivial solution could be something like this scopedefaultoptions only index hasscope forproject as projectid hasscope forsection as sectionid hasscope starred type boolean as focused This can be accomplished simply enough by adding a new class field and merging these contents in hasscope like so def hasscopescopes block options scopesextractoptions optionssymbolizekeys optionsassertvalidkeystype only except if unless default as using allowblank in optionsmergeselfscopedefaultoptions However there might be a more robust solution not sure what troubles this dumb solution might cause Besides Do you consider this a valid feature request and would consider merging something like that if I create a PR hasscope validates the keys using assertvalidkeys thus its impossible to extend functionality adding new keys to the configuration What I was going to achieve I have scopes and I would like to display how many items per scope I have this functionality and I was going to make use of hasscope configuration like so hasscope filter showcount true and read showcount in my code via scopesconfiguration Regards Alexander When I tried setting up a scope like this hasscope status in reportoptions default any and hitting the controller action without any params I noticed it was generating status NULL in the where conditions I was expecting it to generate status any by default since no params reportoptions status is present When I dug deeper with a debugger its sending nil to the scope is because it valuevaluesatoptions using is indeed nil in gemshasscope libhasscoperb block options block if type boolean options allowblank block blockcallself target targetsendscope elsif value optionskeyusing value valuevaluesatoptions using block blockcallself target value targetsendscope value else block blockcallself target value targetsendscope value end byebug valuevaluesatoptions using nil I havent dug any deeper yet to see how its supposed to get the default value but just wanted to report what Ive found so far and suggest that it should probably be expected behavior for default to work with using too My workaround was to not use in to tell hasscope to dig into the hash but to use type hash and handle the digging into the hash and applying defaults manually myself in the block hasscope reportoptions type hash do controller relation hash if value hash active any relation relationactivevalue end relation end I am in a categorycontroller And a category has many categorycontentrefs I have a categorycontentref scope in the categorycontentref model which is scope tag I would like to do this thing When I get a request on categorysomecategorytagtagname applyscopescategorycategorycontentrefs I want to apply the scope tag on the categorycontentrefs is that possible Hi I have scope like below hasscope bydistance using i lat lon type hash do controller scope value scopebydistancevalue value controllercurrentuser end And i want to access value like lat or lon how can i do that I was able to apply a scope for a hasmany associations but cant figure out belongsto association This is what i used for league hasmany champions through leaguechampions scope bychampion champion Leaguejoinsleaguechampionswhereleaguechampions id LeagueChampionwherechampion Championwhereid champion I wanna now be able to do the same but for League belongsto user association And filter by userprice Any idea Third attempt Allows you to use hasscope even if the name of the controller breaks the Rails naming convention We have an AR model named FooBar but the controller is named FooAdminBarsController This arises because the AR model is in a Gem that was developed separately withscopemodel was created as a way to work around these issues without having to restructure apps The boolean usage documentation shows an example of setting a default value on a scope hasscope visible type boolean hasscope active type boolean allowblank true and models with scope visible wherevisible true scope active value true whereactive value This leads me to believe that I should be able to implement the code above and be able to call resourceactive and receive have the scope processed with true as the value However the scope receives the value false