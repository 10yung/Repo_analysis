I have gone through the page on how to apply css classes programmatically by extending the Stylesheet class The problem I am having and Im sure the solution to correct this is simple is that when applying the stylesheet to the app like so kotlin open class MainApp App private var mainWindow MainWindow null private lateinit var springContext AnnotationConfigApplicationContext init importStylesheetStylesclass HERE reloadStylesheetsOnFocus private fun showMain try thismainWindow springContextgetBeanMainWindowclassjava catch e BeansException if mainWindow null LOGerrorFailed to instantiate main window e stop val stage Stage stagetitle Eve Ore Bust stagescene ScenethismainWindowroot stageisMaximized true stageisResizable true stageshow stagetoFront With my style class kotlin class Styles Stylesheet companion object val navigation by cssclass init navigation button backgroundColor ColorRED textFill ColorGREEN selected backgroundColor ColorBLUE And attempt to apply the navigation reverence to a button kotlin class NavMenu ViewNavigation View override var root vbox private val btnGeneral button addClassStylesnavigation HERE padding Insets imageviewimagesiconsgearpng fitHeight fitWidth alignment PosCENTERLEFT useMaxWidth true graphicTextGap text General init withroot maxWidth minWidth addbtnGeneral The style does not get applied to the button However the style properties will display when I apply those style properties directly in the button body The NavMenu is being added to my main view by kotlin Component class MainWindow Autowired constructor private val viewModel MainWindowViewModel ViewMain Window override val root vbox PostConstruct fun postConstruct withroot gridpane visibleWhen loggedIn row constraintsForRow apply percentHeight addNavMenu HERE Hi thank you for this project I realized its not possible to have a tableview with both enableDirtyTracking and rowExpander they both call setRowFactory so one clobbers the other Im wondering if theres a simple way to compose the two or any other suggestions I added destructuring operators to MapChangeListener to allow usage like this kt observableMapaddListenerMapChangeListener key added removed exciting stuff This might be more controversial than since the order is relatively arbitrary although it feels quite natural to me If this addition is not desired feel free to close this pull request otherwise I should probably also add these operators to the other collection types listeners Fixes Disclaimer this is my first time dealing with JavaFX or Observables in general so this could be a very stupid question Im writing this very late in the evening with English not being my native language so please bear with me through the couple of inevitable mistakes Im trying to build a UI that shows the progress of a processing task There are a couple of variables that represent the progress like elapsed time current speed average speed etc In my original implementation these were SimpleXPropertyproperties in my model which I then bound to the labels in my view However this approach comes with a very hefty performance cost since these progress variables are updated on the UIthread tens of thousands times per second I cant slow down these updates that would slow down the processing itself so I need a way to slow down the UIupdates In other words I need a notautomaticallyupdated Binding I want to automatically update the values in the UI but not after every single change I dont even remember everything Ive tried anymore but my most promising attempts were messing with the invalidation of a Binding sadly the UI didnt seem update automatically and using a second buffer property like this pseudocode kt var progress val progressUI SimpleIntegerProperty labeltextbindprogressUI runAsync interestingProcess this updates the progress variable timeline this KeyFrameDurationZERO EventHandler Synchronization of the UI props progressUIsetprogress this KeyFrameDurationseconds update frequency cycleCount AnimationINDEFINITE Threadsafety issues in this example aside this approach seems to work but it feels very wrong I have to define each property twice one primitive and one observable and synchronize them manually in the event handler This is a lot of boilerplate especially when dealing with threadsafety for what Id think be a notuncommon usecase The use of a timeline as suggested by this stackoverflow answer for periodic scheduling also feels kindof backwards but I can see why it makes sense I tried to create a wrapper object to reduce boilerplate but I ran into problems with the various nongeneric but structurally equivalent superclasses of the primitive SimpleXProperty classes For example both SimpleIntegerProperty and SimpleLongProperty boil down to a PropertyNumber instead of their native variants Is there a better way to handle this problem I feel like Im missing something very obvious here since I cant be the first one with this issue Sadly after several days of searching I still havent found a solution My latest hunch is to use the commitrollback properties of ViewModel but that doesnt feel right either Unfortunately the guide page on this topic is kind of confusing to me To me it looks like everything up to ItemViewModel is written as if PersonModel extends plain ViewModel but it already extends ItemViewModel Using a plain ViewModel is never explained other than that its used for more complex situations The examplecode doesnt seem to match up with the text but maybe thats just me I cant find a DSL builder for the StackedAreaChart Are my eyes failing me or is it actually missing Is there a plan to create framework that allows to test TornadoFX application similarly to AssertJ for Swing Is there a way to accomplish this using standard tornadofx dialog builder The only way i accomplished something remotely close to this is using thislayoutX any double value thislayoutX any double value What this does is the windows shows up on its desired position first then the settings are applied and dialog is in the position i want it Perhaps creating separate dialog then setting up desired position and then calling show method would be better but still it kinda feels strange that position cant be set before the dialog is shown I make my view named MyViewit extends the class named View I want to add a view in the vbox after pressing a buttonbut it doest work I use this way like following code override val root hbox buttonadd view action printlndone this thishobxMyView The console prints the messagebut my view no show in the interface If i use this wayI can see my view override val root hbox thisMyView how to solve this problem Is there a reason why only the piechart builder has a data parameter 