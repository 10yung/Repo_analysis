The computedFn function doesnt allow a varying number of arguments between calls to the function it returns This is apparently already known since the function description says computedFnfn returns a function with the very same signature There is no limit on the amount of arguments that is accepted However the amount of arguments must be consistent and default arguments are not supported Is there a fundamental reason that you cant provide a varying number of arguments Or has the code just not been made flexible enough yet to allow varying argument counts If its the former impossible to implement whats the explanation for that limitation If its the latter possible to implement then I plan to do the work of implementing it as its pretty important for my current usecase Anyway Im guessing it is possible so Im starting work on trying to implement that functionality if its not possible though please let me know so I can save some time potential question Why do you need to provide a varying number of arguments Basically Because thats the only way Im able to send in an array in a way thats compatible with caching In more detail I unwrap the arrays items and send each one in as a separate argument to the function This lets the data be cached by the DeepMapEntry chain When the function actually runs it then reconstructs the array argument from the constituent items Im trying to use deepObserve with an object that has an ObservableSet field but the changes in this field are not reported typescript class Foo observable barSet new Set const foo new Foo deepObservefoo consolelogfoo changed foobarSetaddbar foo changed is not logged to the console Is this something that is supported I looked into the deepObserve code and found that it uses this function typescript function isRecursivelyObservablething any return isObservableObjectthing isObservableArraything isObservableMapthing to determine whether an object can be observed but the isObservableSet check is missing In the same vein as it would be great to use a custom equals function with createTransformer to avoid bubbling bubbling recomputes of transformers that return arraysmapsetc This commit passes the options through to the internal computed The name option is not passed through since that can be changed with the debugNameGenerator option In my model I have several computed getters and accordingly setters to derive the plain values from Simple example ts import computed observable from mobx export default class Car observable public colorCode red computed public get colorInstance any return colorCode thiscolorCode public set colorInstancecolorInstance any thiscolorCode colorInstancecolorCode If I now create a view model from it using createViewModel changes applied to the colorCode property are directly visible in the view If I instead apply changes by using the colorInstance setter it seems to have no effect See here for the full running example When looking at the generated getters and setters in the code the observation makes sense computed values are always read from localComputedValues while changes are always written to localValues Hence in my example colorInstance is written to the localValues colorInstance but read from localComputedValues where it will never be uptodate Is this a bug or is it intended to work like that and I made a mistake somewhere If you need further details feel free to ask updateableObservable updateableObservable takes a non observable or observable value and turns it into an observable that can be later updater with another nonobservable or observable value while trying to keep observable object references the same as much as possible Think of this as an observable with support for a smart deep merge This is useful for example when theres a big object coming from a backend call yet youd like to only trigger the minimum amount of reactions possibles the ones with actual changes The returned value will have two methods get returns the value of the observable updatenewValue use this to update the current observable with the new value The first parameter is the inital value the updateable observable should take The second parameter update mode can take one of the folowing values shallow properties primitives objects maps and arrays are turned into a shallowly observable values deep properties primitives objects maps and arrays are turned into a deeply observable values deepProps keys like shallow except some properties are turned into deep observables optin Parameters initialValue T mode UpdateableObservableMode ltT Examples javascript const backendTodoList a plain array with list of plain todo objects const todoList updateableObservablebackendTodoList deep new todo list comes from backend todoListupdatenewBackendTodoList get the observable value todoListget Returns IUpdateableObservable ltT MobX introduced keepAlive as option to computed I was just curious what was the reasoning behind value from fromPromise and current from fromResources and lazyObservable as those names dont appear anywhere else in mobx In RxJs most of the return values are RxObservable Coming from there one would expect these to implement some common interface like boxed values get Whats the equivalent predictable interface for the return values inmobx and mobxutils Just spent some time trying to get it to work with the npm package rx but it didnt work I only noticed I had to use RxJS npm package rxjs when I looked at the relevant tests file With RxJS the examples work fine The errors were toStream Uncaught TypeError Object is not iterable at getIterable rxalljs at FromObservablesubscribeCore rxalljs at FromObservabletryCatcher rxalljs at setDisposable rxalljs fromStream Cannot read property fn of undefined forgot to save stack trace 