Some methods to make sure that trimeshes are watertight and correctly wound would be valuable This could use ray casting Workaround rust fn meshcontainspointT RealFieldmesh TriMeshT point Point T bool if meshaabbcontainslocalpointpoint return false match meshtoiandnormalwithray Isometry identity Raynewpoint VectornewTone Tzero Tzero false unused Someintersection meshisbackfaceintersectionfeature None false Issues Assumes mesh is wellformed watertight and correctly wound Depends on ray casting for point queries which is not necessarily ideal for keeping things modular The code below panics after worldupdate These triangles are part of a larger model Luckily I was able to pinpoint these two triangles There seemed to be other combinations too but I dont what they are extern crate nalgebra as na use naPoint fn main let mut world ncollide dpipelineCollisionWorldf new let group ncollide dpipelineCollisionGroupsdefault let origin naIsometry identity let tri ncollide dshapeShapeHandlenewncollide dshapeTrianglenew Point fromslice Point fromslice Point fromslice let tri ncollide dshapeShapeHandlenewncollide dshapeTrianglenew Point fromslice Point fromslice Point fromslice let querytype ncollide dpipelineobjectGeometricQueryTypeContacts worldaddorigin tri group querytype worldaddorigin tri group querytype worldupdate Heres the full backtrace thread main panicked at index out of bounds the len is but the index is rustc e bb e fc caa a e a ca d srclibcoreslicemodrs stack backtrace x f cb backtracebacktracelibunwindtraceh fcc e e bc b at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs x f cb backtracebacktracetraceunsynchronizedh bad be e a at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x f cb stdsyscommonbacktraceprinthd a f c da at srclibstdsyscommonbacktracers x f cb stdsyscommonbacktraceprinth ec f cfb e a at srclibstdsyscommonbacktracers x f cb stdpanickingdefaulthookclosureh cbf b e f at srclibstdpanickingrs x f a stdpanickingdefaulthookh a f d at srclibstdpanickingrs x a d stdpanickingrustpanicwithhookh f b e f ed at srclibstdpanickingrs x fc stdpanickingcontinuepanicfmth abfbb e b a at srclibstdpanickingrs x faf rustbeginunwind at srclibstdpanickingrs x b bfd corepanickingpanicfmth e f af b at srclibcorepanickingrs x b bb corepanickingpanicboundscheckhf c c cc d ca at srclibcorepanickingrs x c d usize as coresliceSliceIndex T indexmuthbf c f e d at rustc e bb e fc caa a e a ca d srclibcoreslicemodrs x coresliceimpl coreopsindexIndexMutI for T indexmuth c e fdd at rustc e bb e fc caa a e a ca d srclibcoreslicemodrs x f allocvecVecT as coreopsindexIndexMutIindexmuth e ef ae at rustc e bb e fc caa a e a ca d srcliballocvecrs x aaf ncollide dqueryalgorithmsepa EPANclosestpointsh a c a a b d e at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcqueryalgorithmsepa rs x ef ncollide dquerycontactcontactsupportmapsupportmapcontactsupportmapsupportmapwithparamshf da b ed b at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcquerycontactcontactsupportmapsupportmaprs x f ncollide dpipelinenarrowphasecontactgeneratorconvexpolyhedronconvexpolyhedronmanifoldgeneratorConvexPolyhedronConvexPolyhedronManifoldGeneratorN as ncollide dpipelinenarrowphasecontactgeneratorcontactmanifoldgeneratorContactManifoldGeneratorNgeneratecontactsh c b c ad at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasecontactgeneratorconvexpolyhedronconvexpolyhedronmanifoldgeneratorrs x bcb ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdatecontacthf a db f ee at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers x bdd ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdateinteractionh c df d at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers x be ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdateha ddc b at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers x e ncollide dpipelineglueupdateperformnarrowphaseh f cb be at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineglueupdaters x e c ncollide dpipelineglueupdateperformallpipelineh fa fff f at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineglueupdaters x a cdb ncollide dpipelineworldCollisionWorldNTupdatehc d b a cbe at homemecargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineworldrs x af ncollidebugmainhfc fbffefbd at srcmainrs x c stdrtlangstartclosureh e d bded b at rustc e bb e fc caa a e a ca d srclibstdrtrs x fae stdrtlangstartinternalclosureh e c c a at srclibstdrtrs x fae stdpanickingtrydocallh ccd dc eaa at srclibstdpanickingrs x a d a rustmaybecatchpanic at srclibpanicunwindlibrs x a d stdpanickingtryhc e ee ee f at srclibstdpanickingrs x a d stdpaniccatchunwindh dfc c aee at srclibstdpanicrs x a d stdrtlangstartinternalhea b a afe at srclibstdrtrs x c d stdrtlangstarth cf c a at rustc e bb e fc caa a e a ca d srclibstdrtrs Below are the crates I use approx alga nalgebra ncollide d rustc e Heres an OBJ file made out of these triangles o Triangles v v v v v v s off f f Heres the stack thread unnamed panicked at assertion failed selfpts id Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcqueryalgorithmsepa rs stack backtrace stdpanickingdefaulthookclosure stdpanickingdefaulthook stdpanickingbeginpanicPanicPayloadA as corepanicBoxMeUpget stdpanickingbeginpanic ncollide dqueryalgorithmsepa EPANcomputesilhouette at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcqueryalgorithmsepa rs ncollide dqueryalgorithmsepa EPANclosestpoints at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcqueryalgorithmsepa rs ncollide dquerycontactcontactsupportmapsupportmapcontactsupportmapsupportmapwithparams at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcquerycontactcontactsupportmapsupportmaprs ncollide dpipelinenarrowphasecontactgeneratorconvexpolyhedronconvexpolyhedronmanifoldgeneratorConvexPolyhedronConvexPolyhedronManifoldGeneratorN as ncollide dpipelinenarrowphasecontactgeneratorcontactmanifoldgeneratorContactManifoldGeneratorNgeneratecontacts at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasecontactgeneratorconvexpolyhedronconvexpolyhedronmanifoldgeneratorrs ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdatecontact at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdateinteraction at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdate at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelinenarrowphasenarrowphasers ncollide dpipelineglueupdateperformnarrowphase at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineglueupdaters ncollide dpipelineglueupdateperformallpipeline at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineglueupdaters ncollide dpipelineworldCollisionWorldNTupdate at Usersduncancargoregistrysrcgithubcom ecc db ec ncollide d srcpipelineworldrs Im not really sure what leads to this All I know is that it happens more often with large density of cuboids in my world My code is generating a bunch of random integer size and location axisaligned cuboids inside some D region Then it runs this loop Resolve intersections by pushing rooms apart along the contact normal loop Need to do this for changes in position to take effect worldupdate let mut moveactions HashMapnew for h h manifold in worldcontactpairstrue handlecontacth h manifold mut moveactions Need to perform movements after releasing the borrow on world for handle pushv in moveactionsiter let moveobj worldgetmuthandle expectCollision object does not exist for handle let mut pos moveobjpositionclone posappendtranslationmut Translationfrompushv moveobjsetpositionpos if moveactionsisempty break fn handlecontact h CollisionObjectSlabHandle h CollisionObjectSlabHandle manifold ContactManifoldf moveactions mut HashMapCollisionObjectSlabHandle Vector f Once a cuboid from a contact has been moved it may invalidate other contacts that it was a part of so skip them if moveactionscontainskey h moveactionscontainskey h return let contact manifolddeepestcontactexpectNo penetration in contactcontact if contactdepth return The normal should be parallel to some axis To ensure that there are no endless cycles of resolutions only allow resolutions to push in the positive direction along each axis let n contactdepth contactnormalintoinner let pushv movehandle if nx ny nz n h else n h moveactionsinsertmovehandle pushv It also seems that more stress I put on this code more densely packed cuboids the more likely it is to terminate without actually resolving all of the collisions Sometimes it leaves about of the cuboids still colliding Im actually using this algorithm for a voxel world so I convert between integer and floating points coordinates by rounding Then I check for overlap using the integer extents of the cuboids And it doesnt seem like rounding error since the overlaps are much greater than in each dimension I have a short repro use nalgebraIsometry Translation Vector zero use ncollide d shapeCuboid ShapeHandle worldCollisionGroups CollisionWorld GeometricQueryType use stdcollectionsHashMap fn twocollidingcuboids let mut world CollisionWorldnew Add two intersecting cuboids to the world let mut groups CollisionGroupsnew groupssetmembership groupssetwhitelist let contactsquery GeometricQueryTypeContacts let shape ShapeHandlenewCuboidnewVector new let pos Isometry newzero zero worldaddpos shapeclone groups contactsquery worldaddpos shape groups contactsquery loop BUG updating doesnt clear out the old contact pairs so in the loop below we will try pushing apart objects that according to their positions and shapes should not be in contact anymore worldupdate Resolve intersections by pushing cubes apart along the contact normal let mut moveactions HashMapnew for handle handle manifold in worldcontactpairstrue Once a room from a contact has been moved it may invalidate other contacts that it was a part of so skip them if moveactionscontainskey handle moveactionscontainskey handle continue let contact manifolddeepestcontact expectNo penetration in contactcontact if contactdepth continue The normal should be parallel to some axis To ensure that there are no endless cycles of resolutions only allow resolutions to push in the positive direction along each axis let n Vector f contactdepth contactnormalintoinner let pushv movehandle if nx ny nz printlnPushing room n handle else printlnPushing room n handle moveactionsinsertmovehandle pushv let obj worldcollisionobjecthandle unwrap let obj worldcollisionobjecthandle unwrap printlnC obj shapeasshapeCuboidf printlnC obj shapeasshapeCuboidf printlnC obj positiontranslationvector printlnC obj positiontranslationvector printlnDepth contactdepth printlnN contactnormalintoinner Need to perform movements after releasing the borrow on world for handle pushv in moveactionsiter let moveobj worldcollisionobjectmuthandle expectCollision object does not exist for handle let mut pos moveobjpositionclone posappendtranslationmut Translationfrompushv moveobjsetpositionpos if moveactionsisempty break fn main twocollidingcuboids Basically Im trying to use a CollisionWorld to push apart a bunch of colliding cuboids Ive simplified the example here to just cubes Youll see that with ncollide d the example will loop forever because it never realizes that the cubes are not in contact after being pushed apart This must be a regression in behavior according to the documentation of an older version It states that contactpairs iterates through all the contact pairs detected since the last update So you can see the problem is that it also iterates through pairs detected before the last update I think maybe I can work around this using the contactevents function but it makes things more complicated because of my particular application I dont want to push the objects more than necessary so for each iteration over the contacts I will only push an object the first time I see it in a contact pair By pushing an object it might resolve more collisions that come up in the contact iterator later and I dont want to try resolving these unnecessarily If I have to use contactevents then when I ignore a stale contact I may never see the contact pair again if the collision is left unresolved At least this is my interpretation of the docs here Specifically this part about ContactEventStarted This event is generated whenever the narrowphase finds a contact between two collision objects that did not have any contact at the last update It would be greatly appreciated if someone could suggest another workaround while this bug is addressed Thanks The docs here state that the interesction test is done with the broadphase which is incorrect as it is done for the entire pipeline This is also the case for CollisionWorldinterferenceswithaabb Presently supporting a new shape requires defining a new ContactDispatcher which is boilerplateheavy awkward to compose and does not account for CCD or highlevel query functions This could be improved by relying something like on one or more dynamic containers that map TypeId TypeId T for various query functions T and which can easily be mutated by the user to add new cases However implementation of some queries in terms of abstract interfaces like dyn SupportMap complicates this as the desired algorithm is associated with an unbounded set of concrete TypeIds The scaling methods on various shapes scale the points of the shape but not the BVT which seems to lead to collision detection using the wrong shape This issue is related to rustsimnphysics It is about implementing deserialization capabilities to ncollide so they can be used when adding those capabilities to nphysics As said in the linked issue Im willing to make a PR for this myself and I will use this issue to discuss the questions specific to ncollide The first thing I did in my temporary fork was adding denybaretraitobjects to srclibrs and using cargo fix to put dyn in front of every trait object thereby making them easily recognisable This was changes and originally meant only for development purposes but I think it is sufficiently handy and nonintrusive that it may be a good idea to keep it If this is done it should most likely be in a different PR to keep changes manageable Then I started deriveing the crap out of everything and doing a few manual implementations which only contained unimplemented when I ran into problems Im still looking at the problem of trait objects but typetag as suggested by Ralith seems to fix it without security concerns by basically making an enum out of things I also looked at serdetraitobject but that serialized the vtable pointer and could allow arbitrary code execution I think about sure and the crate also warns of its insecurity and is specific to a binary Question Is a dependency like typetag acceptable Otherwise I would end up probably implementing about the same thing but less mature I have also looked at the serialization support of some dependencies petgraph supports serialization when using the feature serde nalgebra supports serialization when using the feature serdeserialize slab does not support serialization but has as of yet unreleased functionality which should make it easier and only leave a simple manual implementation left to do smallvec supports serialization but Im not even sure if its in use anymore couldnt find it at least Im currently in the middle of my test week and will resume work on this next weekend sorry for being a bit slow right now Since the old Collectors are removed this is an APIbreaking change They could easily be readded on top of the Visitors though