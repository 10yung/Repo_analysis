Ive created a module to integrate authboss and hydra This allows an authboss backed api to provide loginconsent flow for the hydra oauth flow The module adds loginconsent and logout api calls Im not that familiar with authboss yet and wondering if you had any initial feedback The test folder is currently a mess and not really testing anything properly Currently planning to address that and improve documentation next I had a couple of initial questions whats the difference between using the authboss redirector and httpredirect all of the POST login code and half the POST logout are copied from those respective modules I was wondering if you had any thoughts on reusing that code or not Ive thought about importing the modules directly and attempting to just wrap the function calls required without calling the Init function but wondered what your thoughts were also any preferences or guidelines for events and errors I think one additional confirm workflow that I think is missing is requiring emailsms confirmation before a user updates their emailsms Example flow for user registered and confirmed user requests to change email email verification sent to new email user verifies email and authboss updates related I would like to create a moduleconfirmemailupdate confirmsmsupdate that addresses the above Current plan is to start with a fork of the confirm module but I wanted to check with you to see if there was anything I should know or advise you had Hello I released example project based on authboss After login I got panic T Z INFO middlewarezaploggergo GET authlogin ip ua Mozilla X Linux x AppleWebKit KHTML like Gecko Chrome Safari proto HTTP path authlogin lat ms status size camforchatsignal T Z INFO user isqad gmailcom is confirmed allowing auth camforchatsignal T Z INFO user isqad gmailcom logged in camforchatsignal Panic ResponseWriter must be a ClientStateResponseWriter or UnderlyingResponseWriter in see authbossLoadClientStateMiddleware middlewarebasicWriter camforchatsignal goroutine running camforchatsignal runtimedebugStack x c x x camforchatsignal usrlocalgosrcruntimedebugstackgo x d camforchatsignal runtimedebugPrintStack camforchatsignal usrlocalgosrcruntimedebugstackgo x camforchatsignal githubcomgochichimiddlewareRecovererfunc xc b x f b a d xc camforchatsignal gopkgmodgithubcomgochichiv incompatiblemiddlewarerecoverergo x b camforchatsignal panic x a d xc b camforchatsignal usrlocalgosrcruntimepanicgo x b camforchatsignal githubcomvolatiletechauthbossMustClientStateResponseWriter x f b a d xc xc fe camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleclientstatego x e camforchatsignal githubcomvolatiletechauthbosssetState x f b a d xc x a d x x x x xc a a x camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleclientstatego x f camforchatsignal githubcomvolatiletechauthbossputState camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleclientstatego camforchatsignal githubcomvolatiletechauthbossPutSession camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleclientstatego camforchatsignal githubcomvolatiletechauthbossauthAuthLoginPost xc e x f b a d xc xc d x xc b d camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleauthauthgo x c camforchatsignal githubcomvolatiletechauthbossdefaultserrorHandlerServeHTTP xc a xa ef xc fe d x f b a d xc xc d camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibledefaultserrorhandlergo x camforchatsignal nethttpServeMuxServeHTTP xc f x f b a d xc xc d camforchatsignal usrlocalgosrcnethttpservergo x d camforchatsignal githubcomvolatiletechauthbossdefaultsRouterServeHTTP xc e x f b a d xc xc d camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibledefaultsroutergo x camforchatsignal nethttpStripPrefixfunc x f b a d xc xc c camforchatsignal usrlocalgosrcnethttpservergo x d camforchatsignal nethttpHandlerFuncServeHTTP xc fb x f b a d xc xc c camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomgochichiMuxMountfunc x f b a d xc xc c camforchatsignal gopkgmodgithubcomgochichiv incompatiblemuxgo x camforchatsignal nethttpHandlerFuncServeHTTP xc d x f b a d xc xc c camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomvolatiletechauthbossModuleListMiddlewarefunc x f b a d xc xc b camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatiblemodulego x camforchatsignal nethttpHandlerFuncServeHTTP xc d c x f b a d xc xc b camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomgochichiChainHandlerServeHTTP xc e x f b a d xc xc b camforchatsignal gopkgmodgithubcomgochichiv incompatiblechaingo x camforchatsignal githubcomgochichiMuxrouteHTTP xc x f b a d xc xc b camforchatsignal gopkgmodgithubcomgochichiv incompatiblemuxgo x f camforchatsignal nethttpHandlerFuncServeHTTP xc a x f b a d xc xc b camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomgochichimiddlewareRecovererfunc x f b a d xc xc b camforchatsignal gopkgmodgithubcomgochichiv incompatiblemiddlewarerecoverergo x f camforchatsignal nethttpHandlerFuncServeHTTP xc d x f b a d xc xc b camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal gitlabcomcamforchatservermiddlewareCurrentUserDataInjectfunc xa c xc f xc b camforchatsignal appmiddlewarecurrentuserdatainjectgo x camforchatsignal nethttpHandlerFuncServeHTTP xc d xa c xc f xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomvolatiletechauthbossAuthbossLoadClientStateMiddlewarefunc x f b xc xc camforchatsignal gopkgmodgithubcomvolatiletechauthbossv incompatibleclientstatego x fa camforchatsignal nethttpHandlerFuncServeHTTP xc d x f b xc xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal gitlabcomcamforchatservermiddlewareDbfunc x f b xc xc camforchatsignal appmiddlewaredbgo x fb camforchatsignal nethttpHandlerFuncServeHTTP xc d x f b xc xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal gitlabcomcamforchatservermiddlewareZapLoggerfunc xa xc c xc camforchatsignal appmiddlewarezaploggergo x ab camforchatsignal nethttpHandlerFuncServeHTTP xc d xa xc c xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomgochichimiddlewareRealIPfunc xa xc c xc camforchatsignal gopkgmodgithubcomgochichiv incompatiblemiddlewarerealipgo x camforchatsignal nethttpHandlerFuncServeHTTP xc d a xa xc c xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal githubcomgochichiMuxServeHTTP xc xa xc c xc camforchatsignal gopkgmodgithubcomgochichiv incompatiblemuxgo x camforchatsignal githubcomgochichiServerBaseContextfunc xa xc c xc camforchatsignal gopkgmodgithubcomgochichiv incompatiblecontextgo x camforchatsignal nethttpHandlerFuncServeHTTP xc fb xa xc c xc camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal nethttpserverHandlerServeHTTP xc b xa xc c xc camforchatsignal usrlocalgosrcnethttpservergo xa camforchatsignal nethttpconnserve xc e xa xc ec camforchatsignal usrlocalgosrcnethttpservergo x camforchatsignal created by nethttpServerServe camforchatsignal usrlocalgosrcnethttpservergo x f camforchatsignal T Z INFO middlewarezaploggergo POST authlogin ip ua Mozilla X Linux x AppleWebKit KHTML like Gecko Chrome Safari proto HTTP path authlogin lat ms status size Here is cite from my code r chiNewRouter rUse middlewareRealIP appMiddlewareZapLoggerlogger appMiddlewareDbdbConn abLoadClientStateMiddleware appMiddlewareCurrentUserDataInjectab middlewareRecoverer rGroupfuncr chiRouter rUseauthbossMiddleware ab authbossRequireNone authbossRespondUnauthorized confirmMiddlewareab rPostsdp funcw httpResponseWriter r httpRequest rGroupfuncr chiRouter rUseauthbossModuleListMiddlewareab rMountauth httpStripPrefixauth abConfigCoreRouter rGet implHomePage As you see I used chi for router and I put abLoadClientStateMiddleware into middleware stack as required But I got panic First off thanks for building and supporting this package I struggled a bit to implement a reasonable email confirmation flow I documented my eventual solution in the wiki What Id like to happen is this User signs up User sees a page that says weve sent a confirmation email to foobarcom User can still access some parts of the site before confirmation but others are blocked off Ideally Id be able to implement this flow just by not using confirmMiddleware and creating my own middleware But AB registers its confirm checks in the confirmInit method making it impossible to override Two things that would need to change AB should still start a session upon registration even if confirm is enabled AB should only check userGetConfirmed true in the middleware which it does now and not as part of a BeforeauthbossEventAuth check Issue opened for the creation of a wiki page that summarizes the doubts and problems for newbies I know this question has already been asked so many times but after hours of searching I still dont have a clear answer to my problem Even projects like have been abandoned and have not answered to new questions and doubts over the years like this PROBLEM Lets say I have a backend on backdomaincom and a frontend on frontdomaincom My backend is a simply app with these rest endpoints POST login accepts JSON body like username myname password mypass verify credentials if OK gives and create a cookie with session if NOT gives GET players check session in cookie if OK gives with players if NOT gives POST player check session in cookie if OK gives and edit player if NOT gives My frontend app has login page with a form with username and password fields for issue a POST request to backdomaincomlogin players which request a GET request to backdomaincomplayers a button which issues a POST request to backdomaincomplayer QUESTIONS Do I need CSRF protection in this scenario I think YES I need because an attacker can issue a request to backdomaincomplayer from malicioussitecom and use my session cookie to edit player because Im logged in and I still have a session cookie on my domaincom Do I need CSRF protection eg an XCSRFToken header when I the first time login on backdomaincomlogin In this scenario I still dont have any session cookie in my browser And also I dont know where to get my CSRF token for XCSRFToken authorization header too I read on they are creating a dedicated endpoint on backend for this and they explain its not a security vulnerability I saw in authbosssample you just add the XCSRFTOKEN header on OPTIONS calls go if flagAPI In order to have a proper API with csrf protection we allow the options request to return the csrf token thats required to complete the request when using post optionsHandler funcw httpResponseWriter r httpRequest wHeaderSetXCSRFTOKEN nosurfTokenr wWriteHeaderhttpStatusOK We have to add each of the authboss getpost routes specifically because chi sees the Mount above as overriding the pattern routes stringlogin logout recover recoverend register muxMethodFuncOPTIONS optionsHandler for r range routes muxMethodFuncOPTIONS authr optionsHandler But why are you using that Are you using that token in javascript after the OPTIONS call But the very first one call is failing right Im confused What do you think about using the dataInjector func to inject csrf token in json response In fact it is like when we render csrf token in html Right Hi There arent any templates for OTP in authbossrender and OTP doesnt work individually Faced the issue when I am trying to use both modules in an API setting Tried returning an error in AuthbossStorageServerSave under the condition while it blocks the recovery the HTTP response is also empty Wonder if there is a way to signal the caller of the error Hello I am interested in using AuthBoss to handle user login and consent as part of an OAuth flow I am using ORY Hydra I am wondering Is this something that makes sense to do Is there a builtin way to use AuthBoss as the Identity Provider part of OAuth I see that there is an OAuth module but it seems like this is for delegating authentication to another provider If it makes sense but theres no builtin way how can I modify the existing passwordbased use case to perform the necessary redirects when the user is authenticated and consent is granted Discussing with the great developer valyala in thread about the amazing Authboss he gave us a suggestion to optimize a bit As for the performance superfluous memory allocation when returning the byte slice from bytesBuffer The memory allocation could be avoided if Render could accept ioWriter to write template output to Can we just use ioWriter instead of byte in Render method Issue opened for the creation of a wiki page that summarizes the doubts and problems for newbies I have two doubts about the redir behaviour of authboss SCENARIO I have two sides backendmysitecom clientmysitecom Many times I need to disconnect the user so I redirect it from lets say clientmysitecomteams to backendmysitecomauthbosslogoutredirteams It doesnt work because authboss detects unauthorized account invalidated from client side and redirects to backendmysitecomauthbossloginredir F and I loose my redir info DOUBT Can we pass redir info from logout to login DOUBT Even if I use loginredirteams I read some time ago that it is wrong from a security point of view to enter complete URLs in the redir info such as backendmysitecomauthbossloginredir I know authboss automagically adds the backendmysitecom part after login and before redirect to redir Is there a way to change this initial part eg with Is ConfigPathsAuthLoginOK involved here in some way