Fixes The SVGs generated by macrorailroad should display correctly on most modern browsers Although we do not use too much CSStrickery we want to ensure that the most used browsers always render the same output This is especially important if macrorailroad should ever get on a path to be included in some form into rustdoc Come up with a scheme to automatically test that SVGs generated for specified testcases result in the same rendering across browsers A rough sketch could be a testsuite that takes certain macros as input produces variants of the diagrams sends them to selenium to produce a screenshot and ensure that all screenshots look the same for some definition Rusts RFC has a list of browsers that rustdoc should always support As of now this is last Chrome versions last Firefox version Firefox ESR last Safari version last iOS version last Edge version last UCAndroid version There is currently no way in Rust itself to have pernonterminal documentation For example in nom method there is just no way to express what a self and args actually do One could come up with a convention to document this in a standardized way that does not hurt rustdoc rustc or readability but can be parsed and use as tooltips legend or something else in these diagrams Cooked up example rust This is the panicmacro It causes panic msgexpr Something that evaluates to a string may be printed to stderr if possible fmtexpr A format string as used stdfmt argtt Arguments to the format string macrorules panic msgexpr msgexpr fmtexpr argtt We could associate that comment parse the minilanguage and use the hints as further explanation Note that each namefragment can only appear once as macrorailroads already implies that a namefragmenttuple carries the same meaning throughout the macro definition A diagrams geometry is separate from its finetuned design via CSS The current default CSS is probably not the best Come up with a better CSStheme for macrorailroad A dark theme would probably be useful It would be extremely useful to bidirectionally map span information to diagram elements so that we can highlight sections in the sourcetext which correspond to a diagramelement The user might pick mouseover an element the corresponding sections in the source should be highlighted there may be multiple such sections in different arms think of the vertex terminal in gfxdefines which in the optimized form appears once but has two sources we can highlight sections of the diagram which correspond to a syntaxelement The user might select parts of the text The diagramelements which are sourced by that part of the text should be highlighted This requires us to acquire collect and map CodeSpaninformation up to the point where we generate a diagram The code to add custom dataattributes to an SVGelement is already in place In addition to a diagram we also give back some form of codemap Some JScode can then control the blinkenlights via CSSrules regarding the affected SVGnodes Edit problem has been identified see next comment The macro below results in ParseErrorNone from parsestrMacroRules Not very helpful Is there any way to get more output rust macrorules unborrow PRIVATE RULES This rule fires when we have parsed all the arguments It just falls through to output stage FIXME could fold the output rule into this one to reduce recursion parse namestt letstt thrutt unborrowout names lets thru Parse an argument and continue parsing This is the key rule assigning a name for the argument and generating the let statement parse argexpr resttt namesident letsstmt thrutt unborrowparse rest names arg lets let arg arg thru Right here an ident is created out of thin air using hygiene Every time the macro recurses we get a new syntax context so arg is actually a new identifier Output stage for free functions Assembles the let statements and variable names into a block which computes the arguments calls the method and returns its result out namesident letsstmt methident arg expr lets metharg names Output stage for object methods out namesident letsstmt objident lets objnames PUBLIC RULES Macro entry point for object methods objident argsexpr unborrowparse args obj info about the method call saved for later generated let statements generated argument names arguments to be parsed Macro entry point for free functions methident arg expr argsexpr unborrowparse args meth arg Hello Thanks for creating such a cool project smile tada ttmunchers are one of many macro programming patterns written about in The Little Book of Macros Many of Rusts more complicated and powerful macros use this pattern to accomplish their functionality These are probably the macros that would benefit the most from this project so it would be really cool if there was a way to integrate them properly Basically what we would need to do is see through that pattern and modify the diagram so that it reflects the way the macro is actually meant to be used instead of just the raw input syntax that it takes This is definitely a nontrivial thing to detect in all cases so I really just recommend starting from a few common patterns and working your way up Lets look at this example rust Given ids a b d this will produce let a let b let c macrorules ids Increment a given counter countexpr nameident resttt idscount name idscount rest Support only one name and also make the ending comma optional countexpr nameident let name count Base case countexpr Running this in macrorailroad correctly produces the following diagram This exactly matches the input syntax of the macro as it is written It would be nice however if the diagram represented how the macro is truly meant to be used One potentially simple way to implement this would be to Detect tt repetition at the end of the declared input to a macro branch This is anything in the form xxxtt in macrorules Note that xxxtt is different from xxxtt the second does not fall under this pattern Detect whether that tt repetition is passed back into the macro itself recursively You might need to check if the tt repetition is passed back exactly the same with no additional tokens added within the repetition so xxx would be different If this happens you can look at the macro call and figure out after which token the tt repetition is placed Once you know that you draw a line back to where the tokens from the tt repetition will be passed In the example above the macro calls itself in the line idscount rest you would draw a line back to just after the comma after count The second image above shows the exact desired result If the tt repetition is used anywhere else other than in a call to the same macro do not treat it specially This implies that there may be multiple calls that a tt repetition is passed to so you may draw arrows leaving one token and getting to multiple other tokens Ideally you would support more complicated forms than just resttt so any repetitions that get passed back into the macro would work but maybe that can be a future enhancement Some cases to think about There may be multiple tt repetitions separated by some other token resttt rest tt If there are multiple tt repetitions not separated by any token the first one will get everything and the second one is superfluous restttrest tt rest will always be empty There are both repetitions and repetitions and the diagram will appear differently for both Some macros are mutually recursive in that they call each other I dont think you need to worry about supporting this case Hopefully I havent scared you away with all of this information Ive tried to outline a lot of the cases for you to consider but Im sure I missed some as well Given all of this I really do recommend starting by supporting the most simple cases of this pattern and then working up to the more general case If this is implemented even just for simpler cases it would be extremely valuable as a documentation tool for so many macros rust macrorules x printlnSpace printlnNo space fn main x x The two branches are currently seen as identical even before optimizing This is not correct We need more tests especially of lowering to guarantee that we produce correct results in all cases It would be a disaster if we produced visual representations that are not actually part of the syntax