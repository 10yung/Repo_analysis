Hey Im in the process of making an async version of One hurdle Im facing is that msgpackrust only support synchronous IO It would be great well at least for me if it would work asynchronously as well Are there plans Would you accept a PR If so how should it be implemented I guess one does not want to throw away the sync versions so should the API be duplicated or should it be a feature switch From this comment For cstyle enums this serializes quite poorly rust enum Foo A B C Resulting msgpack is A None where I expected A Can this be fixed before release or does this need another option were I to open a PR It generally seems like rmps output cannot really be consumed from other languages serdejson does this optimization and it seems pretty easy If I recall correctly well need to modify the deserializer to accept this kind of enum serialization too but that shouldnt be too bad For consistency I think we should do this both when writing string variant names and when writing integer variant indices Im not sure how breaking this change would be with our policies On an upgrade it would cause the serializer to produce different output for the same enum output which would not be accepted by older versions of this library We could also just add this as an option and make it the default in the next major version This issue in Serde affects Serde Msgpack Serde Msgpack unlike other format implementations has an option to the serializer to tell whether to serialize structs as a map with named fields or as a sequence without field names The deserializer doesnt however have the corresponding option but instead relies on this issue to accept both forms which is usually not what is wanted and comes with the unwanted consequences mentioned in the issue in Serde Either the deserializer should have this option added or even better remove the option from the serializer and let the serialize implementation of the struct decide the format The correct way to specify that a struct is going to be serialized without field names is in the serialize implementation of the struct A container attribute can be added to Serde Derive for this purpose Example code adapted to Serde Msgpack rust use serdederiveDeserialize deriveDebug Deserialize struct Person firstname String lastname String fn main let data rmpserdetovec John Doeunwrap eprintln data eprintln rmpserdefromslicePerson data Howdy Im using serdetranscode to go from msgpack json without a problem Sadly once I needed to go the other direction Im unable to let msg r channel kmsgtest message Hello assert that the test json string can be parsed and decoded let res serdejsonfromstrserdejsonValuemsg assertresisok let mut deserializer serdejsonDeserializerfromstrmsg let mut bytes Vecnew let mut serializer rmpsSerializernew mut bytes let res transcode mut deserializer mut serializer dbg res assertresisok test fails on this assert assertbytesisempty The error Im getting is attempt to serialize struct sequence or map with unknown length with the line an column listed of the first member of the object Hey there I just noticed using serdeflatten causes serializations to fail with UnknownLength Quick repro rust use serdeDeserialize Serialize deriveDebug Serialize Deserialize struct Test serdeflatten comment this and serialization works flat Nested deriveDebug Serialize Deserialize struct Nested more Vecu fn main let nested Nested more vec let test Test flat nested let serialized rmpserdetovec test println serialized ErrUnknownLength Being a newcomer to rmp I needed some struggle to understand that I have to enable the withserde feature of the rmpv crate for deserializing data of type rmpvValue So far so good eg now I can nicely convert a type into a Value with mpvexttovalue However such Values are always created as ValueArrays during serialization and there seems to be no way influencing this behavior For serialization usually theres a pair of functions where the default serializes into an array eg rmpserdeencodetovec and theres a variant creating a map eg rmpserdeencodetovecnamed I cannot see anything similar for values theres only tovalue without tovaluenamed or anything similar Is there any way to serialize a type into a ValueMap with the current codebase Would this require extra development efforts within the library I even thought of customizing rmpvextseSerializer which seems to cause this behavior but its even private in the module Thanks for this library Is there any interest from the devs in nostd support We have been using corepack as an alternative but it is inferior to rmp in a number of ways unrelated to the std support I might be willing to provide a patch along the lines of adding a feature nightly which will allow using nightlyonly features like alloc crate selecting serde and byteorder with defaultfeatures false in the Cargotoml in nightly mode Replacing most uses of std prefix with either core or alloc as appropriate The toml crate has a trick for this Their serializestruct recognises their builtin datetime type by name and delegates to a specialised serializer Likewise to deserialize With serde newer than the tests fail roundtripuntaggedenumwithenumassociateddata stdout thread roundtripuntaggedenumwithenumassociateddata panicked at called Resultunwrap on an Err value Syntaxdata did not match any variant of untagged enum Foo srclibcoreresultrs The test failure can be seen by cargo updateing which will bring you to serde or higher To go back in time try serde serdederive has a different error to the one we see today Currently the Serializer and Deserializer pairs in rmpserde do not implement ishumanreadable As a consequence of this types that support a more compact representation serialize and deserialize inefficiently for example IPv addresses should take something like bytes but currently use an annoying bytes as they serialize as regular strings my qualm stems from serializing IpNet structs Has this issue been discussed before While I do think this is a reasonable request to make it is nevertheless a breaking change mentioned on the serde docs previously serialized types that support a compact representation will fail at deserialization I am currently using a forked repo implementing this change merging would be extremely easy from a technical point of view an effective lines of code addded but there is a discussion to be had