Fix to pyzmq added to pyzmq master in removed need for custom ZMQEventLoop in order to support use of alternative uvloop etc coroutine engines However Zguide examples under examplesPythonasyncioioloop see pathopubsubpy for two such cases are still using outdated ZMQEventLoopbased approach which also results in examples being more complex than needed decorators nonasyncbased coroutines etc Please use current pyzmq asyncio example code instead in Zguide Also filed as pyzmq issue in it wasnt clear whos actually responsible for Python examples in Zguide and maintains their parity with pyzmq code examples Noticed while referencing the MDP examples that they are in need of refactoring to not confuse or continue mistakes Just two examples unless I am mistaken This is the only place where expectreply exists meaning its essentially unused and an artifact from copying and pasting another example Then in the same file instance variables are set for what ought to just be constants on the class such as timeout vs TIMEOUT or reconnect vs RECONNECT etc But I found these examples by using Ruby code to demonstrate patterns I was transposing as Crystal Rather than refactor Ruby for its own sake it would make more sense to add Crystal examples made from the Ruby ones and just know that refactoring will also be involved Adding an issue in hopes of coming back later myself and making a contribution Have loved MQ for ages now and am grateful that Hintjens lives on so presently not only in the guide on my desk but in the movement which only needs updated language examples over time Hello Im trying to implement own heartbeat pattern using JeroMQ This is Paranoid Pirate Java Worker And this is part of code that reconnects socket if there is no heartbeat from main server java ctxdestroySocketworker worker workersocketctx liveness HEARTBEATLIVENESS Am I wrong or should we recreate poller to register new socket Something like java ctxdestroySocketworker worker workersocketctx poller ctxcreatePoller pollerregisterworker ZMQPollerPOLLIN If I dont reopen poller I got zmqZErrorIOException javaniochannelsClosedChannelException and it is ok because poller tries to poll from closed socket Do we need to add these lines to the documentation or is it my fault peering cs and peering cs doesnt seem to work Can someone help me in complete sample A subscription is often but not necessarily a printable string See zmqsetsockopt for how this works Should be A subscription is often but not necessarily a printable string See zmqsetsockopt for how this works On MacOS docbook ps and dbtoepub are not readily available The alternative is to use pandoc In a MacOS version of binbuildpdfs one just change docbook ps bookxml ps pdf bookps with pandoc from docbook to latex output bookpdf bookxml and dbtoepub ebookxml with pandoc from docbook to epub output ebookepub ebookxml Im checking an examples for REQREP sockets and trying to make some sense from lazy pirate examples Take a look at php sample php context new ZMQContext client clientsocketcontext sequence retriesleft REQUESTRETRIES read write array while retriesleft We send a request then we work to get a reply clientsendsequence expectreply true while expectreply Poll socket for a reply with timeout poll new ZMQPoll polladdclient ZMQPOLLIN events pollpollread write REQUESTTIMEOUT If we got a reply process it if events We got a reply from the server must match sequence reply clientrecv if intvalreply sequence printf I server replied OK ss reply PHPEOL retriesleft REQUESTRETRIES expectreply false else printf E malformed reply from server ss reply PHPEOL elseif retriesleft echo E server seems to be offline abandoning PHPEOL break else echo W no response from server retrying PHPEOL Old socket will be confused close it and open a new one client clientsocketcontext Send request again on new socket clientsendsequence The block in question is the last else My understanding that we can get there only when poll returned pollin events which can happen when notfinal poll try for REQUESTTIMEOUT and got nothing in the socketyet This looks like a normal situation the poll data have just not returned yet we should do retriesleft more attempts Why do we close the socket and send the message again in the inner while sending messages again should only happen when we did retriesleft poll attempts Resending the request is handled in the outer while cycle its unnecessary to kill the socket after st poll without data void socketzmqsocketcontexZMQPUB bindsocketepgmaddress int rczmqsendsocketdata datalengthZMQSNDMORE rczmqsendsocketdata datalengthZMQSNDMORE rczmqsendsocketdata datalength When the data volume is too large or the transmission frequency is too fast you will recv data data data order Expect related explanation Originally posted by mofeigit in in serviceinternal msg dont delete after send