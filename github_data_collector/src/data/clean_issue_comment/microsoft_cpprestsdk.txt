Overview On Android when using httpclient with HTTPs SSL if we have network security config for example cert pinning with one or more domainconfig elements the platform cert verification fallback method verifycertchainplatformspecific fails with JNI exception CertificateException Below is an example network security config xml networksecurityconfig domainconfig cleartextTrafficPermittedfalse domain includeSubdomainstrueazurewebsitesnetdomain pinset expiration pin digestSHA pin pin digestSHA pin pinset domainconfig networksecurityconfig Note that this happens when default OpenSSL validation fails for example due to missing CA configured and we need to fallback to platform verification via verifycertchainplatformspecific As a result SSL connection fails Details The code here calls X TrustManagercheckServerTrusted obtained via factory method But the overload being called does not contain the hostName parameter Underneath in this case X CertificateManager resolves to RootTrustManager aospsystemframeworksbasecorejavaandroidsecuritynetconfigRootTrustManagerjava and this class has an overload which takes the hostName On the other hand the overload which does not take a hostName as last parameter will throw exception if domain specific configs are present mConfighasPerDomainConfigs true Note that the second method handles hostName ok and locates the corresponding NetworkSecurityConfig based on it aospsystemframeworksbasecorejavaandroidsecuritynetconfigRootTrustManagerjava java Override public void checkServerTrustedX Certificate certs String authType throws CertificateException if mConfighasPerDomainConfigs throw new CertificateException Domain specific configurations require that hostname aware checkServerTrustedX Certificate String String is used NetworkSecurityConfig config mConfiggetConfigForHostname configgetTrustManagercheckServerTrustedcerts authType Hostname aware version of link checkServerTrustedX Certificate String This interface is used by conscrypt and androidnethttpX TrustManagerExtensions do not modify without modifying those callers UnsupportedAppUsage public ListX Certificate checkServerTrustedX Certificate certs String authType String hostname throws CertificateException if hostname null mConfighasPerDomainConfigs throw new CertificateException Domain specific configurations require that the hostname be provided NetworkSecurityConfig config mConfiggetConfigForHostnamehostname return configgetTrustManagercheckServerTrustedcerts authType hostname The suggestion here is to call the second overload from verifyX certchain which already has the hostName as input argument and pass it forward Note that the second overload is not part of the base X TrustManager interface but we can use X TrustManagerExtensions wrapper checkServerTrusted which takes hostName and underneath will locate the correct method cpp bool verifyX certchainconst stdvectorstdstring certChain const stdstring hostName X TrustManager javalocalrefjclass X TrustManagerClassenvFindClassjavaxnetsslX TrustManager CHECKJREFenv X TrustManagerClass jmethodID X TrustManagerCheckServerTrustedMethod envGetMethodIDX TrustManagerClassget checkServerTrusted LjavasecuritycertX CertificateLjavalangStringV Validate certificate chain javalocalrefjstring RSAStringenvNewStringUTFRSA CHECKJREFenv RSAString envCallVoidMethod trustManagerget X TrustManagerCheckServerTrustedMethod certsArrayget RSAStringget CHECKJNIenv Workaround The current workaround is to make OpenSSL succeed and never fallback to the platform specific verification This can be achieved for example via SSLCERTFILE environment variable and spilling the CA pem during startup and thus bypass the platform verification code Hi Ive a use case to send a continuous audio stream to a web server using TLS wssuri and receive corresponding text I have to repeatedly send audio to the server until no more audio data While the audio is being sent server will start sending responses with partial results after some intervalfrom the time it started receiving audio I dont see any samples or examples to do the mentioned tasks It would be great if I can get some example or pseudo code to do Thank you Hi All Im trying a simple example connect to server using wasuri send a message receive a message close socket connect The following code is working fine websocketclient client stdstring bodystrhello clientconnectUwssuriwait auto receivetask clientreceivethen websocketincomingmessage retmsg auto retstr retmsgextractstringget stdcout retstr retstr n websocketoutgoingmessage msg msgsetutf messagebodystr clientsendmsgwait receivetaskwait clientclosewait clientclosewait stdcout hello world n and getting the output retstr apiVersion methodTEXTidloAesAW RyORhhZv vlfgdatatextDonetruetextsubstitutedTextmaxAlternates errorreasonUNKNOWNmessagesome message javalangIllegalStateException Expected BEGINOBJECT but was STRING at line column hello world But When I want to use websocketcallbackclient using the following example include iostream include cpprestwsclienth include cpprestproducerconsumerstreamh using namespace web using namespace webwebsocketsclient using namespace concurrency using namespace concurrencystreams int mainint argc char argv websocketclient client websocketcallbackclient client clientconnectUwssuriwait clientsetmessagehandler websocketincomingmessage retmsg auto retstr retmsgextractstringget stdcout retstr retstr n utilitystringt closereason clientsetclosehandler closereason websocketclosestatus status const utilitystringt reason const stderrorcode code stdcout closing reason reason n stdcout connection closed reason reason close status intstatus error code code stdendl stdstring bodystrhello websocketoutgoingmessage msg msgsetutf messagebodystr clientsendmsgwait clientclosewait clientclosewait stdcout hello world n Im getting the following error closing reasonUnderlying Transport Error connection closed reason Underlying Transport Error close status error code websocketpptransport hello world Am I doing something wrong Please let me know how to use websocketcallbackclient in a correct way Thank you See discussion in My project uses a dll which is written by thirdparty and this dll uses boost libraryversion is if i compile cpprestdk using vcpkg vkpkg will download boost automaticallyversion is this will lead to conflict So i want to ask is it possible to compile cpprestsdk using existing boost library so as to cpprestsdk and thirdparty dll use the samle boost libraray I built a simple example with sanitizer added the parameter fsanitizer address undefined in CXXFLAGS OS Debian gcc include iostream include cppresthttpclienth include cpprestfilestreamh include cppresturih include cpprestjsonh using namespace utility using namespace web using namespace webhttp using namespace webhttpclient using namespace concurrencystreams int main Create user data as JSON object and make POST request auto postJson pplxcreatetask jsonvalue jsonObject jsonObject Ufirstname jsonvaluestringUatakan jsonObject Ulastname jsonvaluestringUsarioglu return httpclientU requestmethodsPOST uribuilderUapiappendpathUuserstostring jsonObjectserialize Uapplicationjson Get the response then httpresponse response Check the status code if responsestatuscode throw stdruntimeerrorReturned stdtostringresponsestatuscode Convert the response body to JSON object return responseextractjson Parse the user details then jsonvalue jsonObject stdwcout jsonObject Ufirstname asstring jsonObject Ulastname asstring jsonObject Uid asstring stdendl try postJsonwait catch const stdexception e printfError exceptions n ewhat return Error usrlocalincludecpprestastreambufh runtime error member call on address x e which does not point to an object of type basicstreambuf x e note object is of type Concurrencystreamsdetailsbasiccontainerbufferstdcxx basicstringchar stdchartraitschar stdallocatorchar a a e e b vptr for Concurrencystreamsdetailsbasiccontainerbufferstdcxx basicstringchar stdchartraitschar stdallocatorchar string id jsonrpc result ERROR LeakSanitizer detected memory leaks Direct leak of bytes in objects allocated from x f bc in interceptorrealloc libx linuxgnulibasanso xe x f bbb bc libx linuxgnulibstdcso x If without a sanitizer it is naturally not there More precisely it is just no one tells you about it such as sanitizer Any thoughts on how to fix this now the default becomes CMAKEINSTALLLIBDIRcmakecpprestsdk This is a respin of I added the Wfloatequal compilation option to CmakeList and the following error is reported when compiling rootcpprestsdk Releaseincludecpprestjsonh In member function bool web json number operator const web json number const rootcpprestsdk Releaseincludecpprestjsonh error comparing floating point with or is unsafe Werror floatequal case json number type doubletype return mvalue othermvalue How to solve this problemhelp me Firstly I run my app with cpprestsdk installed through brew I archived and uploaded to Mac Appstore but they rejected So I embed the dylib in my project The dylib I copied from the installed folder usrlocaloptcpprestsdk and then I uninstall the cpprestsdk so it deleted that folder I have successfully archived validated distributed and run the app on a second Mac which does not have that CLI utility or Xcode installed or CPPREST installed by brew through the Developer ID outside the Mac App Store workflow several times However the archive failed to validate for Mac App Store distribution with this error Screen Shot at How can I resolve it