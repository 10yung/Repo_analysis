Ive discovered why Im not getting the monitor exits I expect In ProcessAdapterexit a test is made for the state of the process If its not alive then the link break monitor break code is not triggered However it is possible for monitor to be registered during the call to exit The subsequent call to exit then does not issue the rest of the monitor exit messages and ditto for the link breaks So it seems process exit is not quite right If I remove this check then I get more monitor exit messages through to my erlang process Wall of text as its late Attempts to monitor a nonlive pid should send an immediate link break message to the other end much as monitoring a nonexistent process should send an immediate monitor exit message Could you possibly go back and update the README so that the example code is complete and it works Most of the code samples generate errors and for the life of me I cant get the sample echo client to work quite right For example this clientside code definitely doesnt work for echo scala val node Noderemote cookie nodespawn mbox mboxsendkharon Symbolkharonhypatia mboxself mboxself Hello val received mboxreceive printlnReceived received The serverside gets the message and returns a response but the client never gets it This revision to the above however does work scala val node Noderemote cookie val mbox nodespawnMbox mboxsendkharon Symbolkharonhypatia mboxself mboxself Hello val received mboxreceive printlnReceived received But in both cases the code hangs due to what I can only guess is a thread running in the background that isnt being cleaned up Ive tried this scala nodeshutdown printlnShutdown The Shutdown is output but it doesnt really stop the node Is there an example for how you stop a node just making a quick remote call for information Thanks Default connection does retries and polls the connection automatically Logs output to tell you whats up The number of retries and a connection timeout are configurable According to the tests this doesnt break the old interface Theres a new Epmd signature that lets you access a netty ChannelFuture if you want to go deep on retry logic yourself Need to unregister Metrics for Pids which can otherwise be destroyed as these will hang around in the JVM and not be GCd due to that dangling JMX reference Reverting ae bb bea a f b ad d bddb d d fixes mvn test Classes like MetricsRegistry appear in both the newly introduced metricsscala dependency and the existing overlockscala dependency which probably explains it decode regular termsscalangtermsScalaTermDecoderSpec javalangNoSuchMethodError comyammermetricscoreMetricsRegistrynewTimerLjavalangClassLjavalangStringLjavalangStringLjavautilconcurrentTimeUnitLjavautilconcurrentTimeUnitLcomyammermetricscoreTimer decode full distribution packetsscalangtermsScalaTermDecoderSpec javalangNoSuchMethodError comyammermetricscoreMetricsRegistrynewTimerLjavalangClassLjavalangStringLjavalangStringLjavautilconcurrentTimeUnitLjavautilconcurrentTimeUnitLcomyammermetricscoreTimer Scalang needs a supervisor implementation equivalent to Erlangs Currently link breakages are delivered cooperatively This is undesirable behavior in the case of processes that have long running message handlers and processes spawned from an anonymous function which might never yield execution to an error handler We need the ability to deliver an interrupt to the fiber running a particular process 