Previously this was unset and used the system default According to the documentation starting from Java it should be possible to use signatures with PS algorithm but when I try this it gives an error unless BouncyCastle is used But I though that starting from Java BouncyCastle would just not be necessary anymore Any tips signWithsignKey SignatureAlgorithmPS gives iojsonwebtokensecuritySignatureException Unavailable RSA Signature algorithm SHA withRSAandMGF This is not a standard JDK algorithm Try including BouncyCastle in the runtime classpath Looks like by using PS it tries Signature algorithm SHA withRSAandMGF which seems BouncyCastle specific I added a claim with the Long type value code but when it is encoded in the class DefaultJwtBuilderjava by the method base UrlEncodeObject o String errMsg calling TextCodecBASE URLencodebytes it returns a token that the value of the claim is code The only last digit is changed A simple test MapString Object publicClaims new HashMap publicClaimsputcode L ObjectMapper objectMapper new ObjectMapper byte bytes objectMapperwriteValueAsBytespublicClaims String token TextCodecBASE URLencodebytes Token response is eyJzZXNzaW uX hbWUiOiJuYW lIiwiY kZSI MjY Njk MDg NzYzMjU MjksIm hbWUiOiJhZG pbiJ If I decode it with TextCodec the response is correct like String tokenDecoded TextCodecBASE URLdecodeToStringtoken If I use String type it is correct in the encode and decode But I would like to use the true type Long Context We are currently implementing RFC which requires requests authenticated through JWS object payloads It suggests using signed POSTASGET requests with empty JWS bodies for authenticating GET requests When using jjwt library for the JWS handling we found that empty bodies are disallowed quite explicitly in DefaultJwtParser when parsing JWSs Solution We added flag allowEmptyBody alongside JwtParserBuilder fields and methods to the DefaultJwtParser This way the empty body check can still be used if required and allowing them is an intentional call To successfully parse emptybody JWS objects the parsed payload is accepted in a nullsafe way DefaultJWTParser lines When proactively checking for and mapping json in line we added a simple empty check for the payload javautilmap cannot be inherited with different type arguments String and null Error here public class DefaultJwsHeader extends DefaultHeader implements JwsHeader how to fix this Note without fixing it will return always null thx Simple testcase import javatimeLocalDate import javatimeZoneOffset import javautilDate import orgjunitjupiterapiAssertions import orgjunitjupiterapiTest import iojsonwebtokenCompressionCodecs import iojsonwebtokenJwt import iojsonwebtokenJwts public class JjwtDeflateCompatibilityTest Test public void testJjwt String jwt JwtsbuildersetIssuermesetSubjectuser setIssuedAtDatefromLocalDateof atStartOfDaytoInstantZoneOffsetUTC setExpirationDatefromLocalDateof atStartOfDaytoInstantZoneOffsetUTC compressWithCompressionCodecsDEFLATEcompact Jwt parsed Jwtsparserparsejwt Same token as above but created with String jwt eyJhbGciOiJub lIiwiemlwIjoiREVGIn eNqqVsosLlayUspNVdJRKi NAjJLi OLgJzMxBIlK sTMzMLEwsDAx l IoCJSsTQwMjExOQQC AAADw Jwt parsed Jwtsparserparsejwt AssertionsassertEqualsparsedtoString parsed toString fails currently Fails currently with iojsonwebtokenCompressionException Unable to decompress bytes at iojsonwebtokenimplcompressionAbstractCompressionCodecdecompressAbstractCompressionCodecjava at iojsonwebtokenimplDefaultJwtParserparseDefaultJwtParserjava Caused by javaioEOFException Unexpected end of ZLIB input stream at javautilzipInflaterInputStreamfillInflaterInputStreamjava at javautilzipInflaterInputStreamreadInflaterInputStreamjava at javaioFilterInputStreamreadFilterInputStreamjava at iojsonwebtokenimplcompressionAbstractCompressionCodecreadAndCloseAbstractCompressionCodecjava at iojsonwebtokenimplcompressionDeflateCompressionCodecdoDecompressDeflateCompressionCodecjava at iojsonwebtokenimplcompressionAbstractCompressionCodecdecompressAbstractCompressionCodecjava more Returns the JWT a href codeiatcodea issued at timestamp or code null if not present pIf present this value is the timestamp when the JWT was createdp return the JWT code nbf value or code null if not present Date getIssuedAt referencing code nbf but should be code iat exp claim should be number however jjwt supports parsing the string as a number and as last fallback parsing string as a ISO formatted date In iojsonwebtokenlangDateFormats there are following patterns private static final String ISO PATTERN yyyyMMddTHHmmssZ private static final String ISO MILLISPATTERN yyyyMMddTHHmmssSSSZ So they are named here as ISO and if cant parse the exception says it is not ISO formatted private static Date parseIso DateString s String name throws IllegalArgumentException try return DateFormatsparseIso Dates catch ParseException e String msg name value does not appear to be ISO formatted s throw new IllegalArgumentExceptionmsg e Despite that ISO allows you to have the offset The offset from UTC is appended to the time in the same way that Z was above in the form hh mm hh mm or hh The patterns from DateFormats will accept only Z value Therefore values like T are not accepted resulting in ParseExceptionIllegalArgumentException Another point is that it throws IllegalArgumentException which does not inherit from JwtException not intuitively this may result in noncaught exception In my understanding the fix would be to change the patterns to following removing the single quotes around Z letter private static final String ISO PATTERN yyyyMMddTHHmmssZ private static final String ISO MILLISPATTERN yyyyMMddTHHmmssSSSZ and throwing MalformedSpecificationClaimException extends JwtException instead of IllegalArgumentException Due to old implementations before JJWT was modularized the iojsonwebtokenlang package in the api module contains a lot of classes and methods that arent needed by JJWT users For as many of these classes and methods as possible should be moved to the impl module since theyre almost exclusively used by JJWT implementation classes Note that anything used by any of the extensions or in the api module itself would need to remain in the api module But this number should be relatively minor If this opens a can of worms we can leave these classes alone but per the openclosed principle itd be best to not expose anything thats not absolutely critical for using the api Setting for the milestone as semver dictates this cant be done without incrementing the major version number