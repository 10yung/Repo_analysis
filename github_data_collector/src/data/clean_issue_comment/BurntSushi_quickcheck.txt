I am no longer happy about depending on the rand crates There is too much churn too many crates and IMO worst of all there is no desire to add a minimal version check to their CI Which means anything that depends on quickcheck in turn cannot reliably have its own minimal version check Because I am tired of depending on rand I have started removing it completely where possible For example in walkdir Ive removed quickcheck as a dependency In ripgrep Ive removed tempfile as a dependency because it in turn was the only thing bringing rand into ripgreps dependency tree I dont see any other path forward here I can either continue to grin and bear rand drop everything that depends on randomness or figure out how to generate randomness without rand Specifically Id very much like to add a minimal version check back to the regex crate which catches bugs that happen in practice See here and here My sense is that there is some design space in the ecosystem for a simple source of randomness that doesnt need to be cryptographically secure and an API that does not experience significant churn Certainly quickcheck does not need a cryptographic random number generator With that said there is some infrastructure in the rand API that is incredibly useful For example quickcheck makes heavy use of the Rnggen method for generating values based on type So it seems like if we have something like the Rng trait with with a noncryptographic RNG then wed be probably good to go Are there other avenues here What have I missed My experience in building infrastructure for randomness is pretty limited so am I underestimating the difficulty involved here Another side to this question is whether any users of quickcheck are leveraging parts of the rand ecosystem that would be difficult or impossible to do if we broke ties with rand Aims to fix and Changes the implementation of Arbitrary for numbers to ignore the size of gen and instead pick uniformly from the entire range of the type Todo x change behavior X integer types x floatingpoint types X add tests x explain new meaning of Gens size in documentation Hello It appears this test will always pass even setting QUICKCHECKTESTS and QUICKCHECKMAXTESTS to a large value eg and QUICKCHECKGENERATORSIZE to rust fn propgtx i bool x i minvalue fn main quickcheckpropgt as fni bool printlnHello world It appears these lines of code attribute to this issue If upper mingsize tymaxvalue as usize then if upper tymaxvalue always evaluates to the else branch I have a test with signature rust fn atestn usize bool but all the selected values of n are in which seems counterintuitive Is this what I should expect Obviously we cant do full generic N until const generics are implemented I only wanted it for f s anyway and settled for six f s in my functions parameters and Id be happy to send a pull request for just T Arbitrary k for a few small ks if thats good with you Would be nice to have Strings impl isnt quite the same I have a type which wraps an i and wrote an Arbitrary impl like so rust trait ArbitraryPgDate fn arbitraryG Gen Self PgDatei arbitrary When I actually output what its running with the values are only ranging from to instead of completely random numbers as Id expect Additionally shrink appears to be flawed on these types My understanding was that quickcheck would test for known problematic values for a given type For i Id expect that to at minimum be i MAX and i MIN but when I add the shrink like so rust fn shrink self BoxIteratorItemSelf Boxnewself shrinkmapPgDate I just see the same range of to This caused a critical bug that occurs for any values less than to go unnoticed Using rustc nightly d d bb f fn reverseT Clonexs T VecT let mut rev vec for x in xsiter revinsert xclone rev test fn reverseidentity fn propxs Veci bool xs reversereversexsassliceasslice quickcheckprop produces error the trait quickchecktesterTestable is not implemented for the type fncollectionsvecVeci bool testsreverseidentityprop quickcheckfalse compiles this appears to be specific to the fn impls including the zeroarg fn Currently INFINITY NEGINFINITY NAN and possibly are never generated by quickcheck These values are valid floats and should be tested for 