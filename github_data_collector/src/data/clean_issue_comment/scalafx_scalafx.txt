Scala brings significant changes in collections ScalaFX provides several custom collections like ObservableBuffer scalacollectioncompat provides tools for using the same collection code in and no support for In other words needs to be dropped to enable support From a checkout of openjfx rg since c modulesjavafx g moduleinfojava modulesjavafxgraphicssrcmainjavajavafxgeometryBoundsjava modulesjavafxgraphicssrcmainjavajavafxscenerobotRobotjava modulesjavafxcontrolssrcmainjavajavafxscenecontrolSpinnerjava x Bounds add missing properties with PR Robot requires to wrap the new Robot class from javafxscenerobot Spinner x initialDelay as part of changeset ded be x repeatDelay as part of changeset ded be getClassCssMetaData returns a CssMetaData do we need to wrap that too getControlCssMetaData same At least for some types of ScalaFX properties operations such as does not work while manually rewriting the assignment works well How to reproduce Tested on Scala scala import scalafxbeanspropertyIntegerProperty object ScalaFxPropertyBug val property IntegerProperty Compiles well propertyvalue propertyvalue Error Expression does not convert to assignment because receiver is not assignable propertyvalue Debugging Looks like the value method is defined in the IntegerProperty class while value is defined in ReadOnlyIntegerProperty Maybe this confuses the Scala compiler The lookup method on javafxsceneNode is usually used along with a type cast to the expected Node subclass This lets you do things like val chartTitle panelookupmyChartasInstanceOf LineChart getTitle However the scalafxsceneNode implementation of lookup wraps the result in a scalafx Node When you try to cast this wrapped value you get a ClassCastException at runtime Caused by javalangClassCastException scalafxsceneLowerPriorityIncludesanon cannot be cast to scalafxscenechartLineChart I suggest that scalafx should provide its own lookupbyid mechanism which returns the scalafxwrapped values Then these values can be safely cast to the desired type JavaFX requires that custom cell factories are implemented in such a way that javafxscenecontrolCell T updateItemT item boolean empty is implemented correctly Quite from JavaFX documentation for updateItem It is very important that subclasses of Cell override the updateItem method properly as failure to do so will lead to issues such as blank cells or cells with unexpected content appearing within them Current implementation of helper cellFactory assignment is not suitable to handle that Consider TreeCellcellFactoryv TreeView T TreeCell T Current suggestions is to use it like this scala cellFactory v TreeView Person new TreeCell Person treeItemonChange p text if p null pvaluefirstName pvaluelastName else null graphic null Above implementation will results in rendering artifacts as empty cells cannot be handled correctly the empty flag is not available The proper way would be to extends javafxscenecontrolCell scala cellFactory new javafxscenecontrolTreeCell Person We are deriving from JavaFX for easier use add ScalaFX wrapper for this val self TreeCell Person this override def updateItemitem Person empty Boolean Unit superupdateItemitem empty selfgraphic null selftext if empty null else item match case p Person pfirstName plastName case null null This is a lot of boilerplate code There should be a helper cellFactory assignment that would promote ability to write correct code Mot of the boilerplate would be generated automatically user would only handle rendering and be provided with empty flag Consider assignment with signature scala def cellFactoryu TreeCell T T Boolean Unit It would be used like this scala cellFactory treeCell item empty treeCellgraphic null treeCelltext if empty null else item match case p Person itemfirstName itemlastName case null null Maybe it should be even simpler Code for resetting graphic and text when item is null or empty would be generated automatically A cell factory would only handle nonnull items and nonempty cells scala cellFactory treeCell item treeCelltext itemfirstName itemlastName This would be for all classes that have cell factories not only TreeView I had a talk with jpsacha and planned to initiate the steps to make ScalaFX as part of Typelevel project Typelevel wants following things from our contributorsCommitters There must be a consensus amongst the projects stakeholders that they want to join Typelevel Please post who are all like to join Typelevel as part of ScalaFx project The project must be willing to support the Typelevel code of conduct or something equivalent Scala Community builds test new Scala builds against open source projects From the project README The main goal of the Scala Community builds is to guard against regressions in new versions of Scala language standard library and modules Its also a service to the open source community providing early notice of issues and incompatibilities The implicit conversion from scalafxbeanspropertyIntProperty to scalafxbeansvaluesObservableValue Int Int is missing This implicit conversion works for String and generic types but not for primitive types such as Int Long Double A minimal example to show this issue scala import scalafxbeansproperty import scalafxscenecontrol object ConversionIssue extends App class Personname String age Int val name new StringPropertythis name name val age new IntegerPropertythis age age val nameColumn new TableColumn Person String cellValueFactory valuename val ageColumn new TableColumn Person Int cellValueFactory valueage Line is okay but line fails with the following error Error type mismatch found scalafxbeanspropertyIntegerProperty required scalafxbeansvalueObservableValue IntInt cellValueFactory valueage Hi I suggest that we should define map for ReadOnlyProperty Generally speaking I think it is called fmap in functional reactive programming It is very simple easy to read and can be considered as Scalastyle programs For example if we have map for StringProperty we can write programs like following scala object Main extends JFXApp val a StringProperty val b amaps String s val c bmaps String s avalue i printlnavalue i printlnbvalue i printlncvalue i this program cannot be compiled How do you think about this EDIT I just wrote working prototype for StringProperty scala import scalafxapplicationJFXApp import scalafxbeanspropertyStringProperty object Main extends JFXApp NOTE this is just prototype proof of concept We should define more generic and safe way def mapPropertyv StringProperty f String String StringProperty val r StringPropertyfvvalue initialize with current value def update Unit rvalue fvvalue vonChangeupdate r val a StringProperty val b mapPropertya s String s val c mapPropertyb s String s avalue i printlnavalue i printlnbvalue i printlncvalue i 