 Is your feature request related to a real problem or usecase This type can be usefull to reverse required and optional properties of an object Related question Describe a solution including usage in code example Solution ts import RequiredKeys OptionalKeys from utilitytypes export declare type FlipT PartialPickT RequiredKeysT RequiredPickT OptionalKeysT Usage ts import Flip from utilitytypes type MyObject a number b number c number type MyFlippedObject FlipMyObject Should be type MyObject a number b number c number Who does this impact Who is this for TypeScript users Is your feature request related to a real problem or usecase Yes for instance to exclude typename field from generated GraphQL type As a reference question on stack overflow Describe a solution including usage in code example Proposed solution works for typescript but I have not tested with union types ts import Primitive from utilitytypes type DeepOmitObjectT extends object K P in Excludekeyof T K DeepOmitT P K type DeepOmitArrayT extends any K P in keyof T DeepOmitT P K export type DeepOmitT K T extends Primitive T T extends object DeepOmitObjectT K T extends Arrayinfer E ArrayDeepOmitE K T extends any DeepOmitArrayT K never Who does this impact Who is this for TypeScript users Is your feature request related to a real problem or usecase A clear description of your problem or usecase As most of you probably know Typescript added the as const assertion to get a nonwidening type literal with object attributes set as readonly in typescript Now that construct in itself is very valuable But since the beginning I was irked by the fact that AFAIK theres no clean way to validate such a type the very thing Typescript was made for I regularly use unmodified Objects to provide config of how precisely my application works I E Testing conditions shown tabs etc and being able to do that with nonwidening type literals is making things easier and typesafer Today I got to this issue another time and decided thats enough and decided to hack a quick helper together The only Article I could find in my quick search was this the validate type near the end but this isnt quite what I was looking for So my solution looks different Its also not ideal while the Solution I linked needs a runtime check or assertion which would not be type save every time the variable is used mine has considerable runtime overhead upon creation of the variable But ultimately that shouldnt be a large problem for my most common usecase for checked nonwidening literals being configuration with fileglobal variables that only get created once on spinup I also earlier implemented a alternative solution with a little less overhead but pretty confusing syntax which wouldnt be possible to offer in a library well unless they typecheck their libraries SInce I hacked this together pretty quickly and see many issues I wanted to discuss this issue if you find this an issue too and possible solutions here Describe a solution including usage in code example ts export const getConstValidator ValidType extends unknown ConcreteType extends readonly ValidType value ConcreteType value export const getConstArrayValidator ValueType extends unknown ConcreteArrayType extends readonly ValueType array ConcreteArrayType array export const getConstDictValidator ValueType extends unknown ConcreteDictType extends readonly key string ValueType dict ConcreteDictType dict usage const validatedConstAssertedDict getConstDictValidatorfield number some dict field field as const Alternative from ts type ValidateT U T extends U T never usage const correctImpl test open CHANNELOPEN close CHANNELCLOSE fail CHANNELFAIL as const const wrongImpl test open OPENCHANNEL close CHANNELCLOSE fail CHANNELFAIL as const returns typeof correctImpl type ValidatedCorrect Validatetypeof correctImpl ChannelDefinition returns never type ValidatedWrong Validatetypeof wrongImpl ChannelDefinition The alternative I used a few times before unclear syntax though has to be done manually each time etc ts const constAssertedDict some dict field field as const const assertCorrectType key string field number constAssertedDict Who does this impact Who is this for People who love to use nonwidening literals for configuration of the apps behavior but want to typetest them without having to resort to other validators in the pipeline Describe alternatives youve considered optional Listed a few alternatives in the main part Alternatively you could decide its not worth it its for me though Additional suggestionsissues If we decide to offer this in this library there is another issue with the usage of these type literals in code that being that typescript current default type implementation of Objectentries Objectkeys etc dont take advantage of type literals but will widen the type even if its nonwidening So to use the config objects in some places I have to resort either to type assertion inplace or provide a correctly typed alternative The most elegant way to do this Ive found is to provide an alias for these methods with their type asserted to the nonwidend returnvalue write this on the phone like some above code so might not work exactly like that but should get the point across ts const objectEntries Objectentries as unknown as DictLiteral extends objectdict DictLiteral ValuesType key in keyof DictLiteral key DictLiteral key Now if we decide to offer such a thing this could lead to some issues with browser compatibility as Objectentries etc are not fully supported by all browsers and Im not certain if all polyfillpipelines do support polyfilling library code This it might be better to just offer the types you cast the functions too Or even modify the global type definitions Thank you for your contribution thumbsup Please makes sure that these checkboxes are checked before submitting your PR thank you Description Add Augmented types for consistency Related issues Resolved Checklist x I have read CONTRIBUTINGmd x I have linked all related issues above x I have rebased my branch For new features x I have added entry in TOC and API Docs x I have added a short example in API Docs to demonstrate new usage x I have added type unit tests with dtsjest Is your feature request related to a real problem or usecase A clear description of your problem or usecase We have DeepReadonlyT DeepMutableT added in DeepRequiredT DeepNonNullableT and DeepPartialT We should have consistency in their code Describe a solution including usage in code example A clear description of the solution including usage with complete code examples nicely formatted with ts tags especially if thats a new api proposal Proposed changes are below with inline comments diff diff git asrcmappedtypests bsrcmappedtypests index b c fbbb c asrcmappedtypests bsrcmappedtypests export type PromiseTypeT extends Promiseany T extends Promiseinfer U type ReadonlyNestedProps DeepReadonlyNestedProps export type DeepReadonlyT T extends args any any Primitive export type DeepReadonlyT T extends args any any Primitive null undefined null and undefined not needed after T T extends DeepReadonlyArrayinfer U DeepReadonlyArrayU T extends DeepReadonlyObjectinfer V DeepReadonlyObjectV T T extends DeepReadonlyArrayany DeepXXXArrayany vs any described below DeepReadonlyArrayT number Dont need to infer on Arrays can just index with number T extends DeepReadonlyObjectinfer U DeepXXXObjectinfer U vs object described below DeepReadonlyObjectU never all primitives and nonprimitives are covered and this case will never happen private tslintdisablenextlineclassname export interface DeepReadonlyArrayT extends ReadonlyArrayDeepReadonlyT export type DeepReadonlyObjectT readonly P in keyof T DeepReadonlyT P export type DeepMutableT T extends args any any Primitive null undefined added in null and undefined not needed after T T extends DeepMutableArrayany DeepXXXArrayany vs any described below DeepMutableArrayT number Dont need to infer on Arrays can just index with number T extends DeepMutableObjectinfer U DeepXXXObjectinfer U vs object described below DeepMutableObjectU never all primitives and nonprimitives are covered and this case will never happen private tslintdisablenextlineclassname export interface DeepMutableArrayT extends ArrayDeepMutableT private export type DeepMutableObjectT readonly P in keyof T DeepMutableT P DeepRequired desc Required that works for deeply nested structure export type DeepReadonlyObjectT type RequiredNestedProps DeepRequiredNestedProps export type DeepRequiredT T extends args any any export type DeepRequiredT T extends args any any Primitive null undefined Move functionsprimitives to be handled in one place null and undefined not needed after T T extends any DeepXXXArrayany vs any described below DeepRequiredArrayT number Dont need to infer on Arrays can just index with number T extends object DeepXXXObjectinfer U vs object described below DeepRequiredObjectT T never all primitives and nonprimitives are covered and this case will never happen private tslintdisablenextlineclassname export interface DeepRequiredArrayT export type DeepRequiredObjectT type RequiredNestedProps DeepNonNullableNestedProps export type DeepNonNullableT T extends args any any export type DeepNonNullableT T extends args any any Primitive null undefined T T extends any DeepXXXArrayany vs any described below DeepNonNullableArrayT number Dont need to infer on Arrays can just index with number T extends object DeepXXXObjectinfer U vs object described below DeepNonNullableObjectT T never all primitives and nonprimitives are covered and this case will never happen private tslintdisablenextlineclassname export interface DeepNonNullableArrayT export type DeepNonNullableObjectT type PartialNestedProps DeepPartialNestedProps export type DeepPartialT T extends Function T T extends Arrayinfer U DeepPartialArrayU T extends object DeepPartialObjectT T undefined export type DeepPartialT T extends args any any Primitive null undefined Change Function to explicit declaration Move functionsprimitives to be handled in one place null and undefined not needed after T undefined T extends DeepPartialArrayany DeepXXXArrayany vs any described below DeepPartialArrayT number Dont need to infer on Arrays can just index with number T extends DeepPartialObjectinfer U DeepXXXObjectinfer U vs object described below DeepPartialObjectU never all primitives and nonprimitives are covered and this case will never happen private tslintdisablenextlineclassname export interface DeepPartialArrayT extends ArrayDeepPartialT DeepXXXArrayany vs any and DeepXXXObjectinfer U vs object DeepReadonlyT DeepMutableT and DeepPartialT use DeepXXXArrayany and DeepXXXObjectinfer U for their array and object cases respectively However DeepRequiredT and DeepNonNullableT use any and object The reason to use DeepXXXArrayany and DeepXXXObjectinfer U is because the following test fails with any and object Using any and object causes two DeepReadonlyObject to show up in the snapshot diff DeepReadonly testTypeDeepReadonlyDeepReadonlyNestedProps type should match snapshot expectvaluetoMatchSnapshot Received value does not match stored snapshot DeepReadonlyObject first second name string DeepReadonlyObjectDeepReadonlyObject first second name string DeepRequiredT and DeepNonNullableT seem to only work with any and object because they use NonUndefinedT and NonNullableT in their DeepXXXArrayT and DeepXXXObjectT definitions I have to double check Who does this impact Who is this for Who is this for All users TypeScript users Yourself People using X Y Z etc TypeScript users Is your feature request related to a real problem or usecase A clear description of your problem or usecase Related to and We have DeepPartialT DeepRequiredT and DeepReadonlyT We should also add DeepMutableT Similar to maybe we should have a DeepOptionalT that would be an alias of DeepPartialT Describe a solution including usage in code example A clear description of the solution including usage with complete code examples nicely formatted with ts tags especially if thats a new api proposal ts export type DeepMutableT T extends args any any Primitive null undefined T T extends DeepMutableArrayany DeepMutableArrayT number T extends DeepMutableObjectinfer U DeepMutableObjectU never private tslintdisablenextlineclassname export interface DeepMutableArrayT extends ArrayDeepMutableT private export type DeepMutableObjectT readonly P in keyof T DeepMutableT P Who does this impact Who is this for Who is this for All users TypeScript users Yourself People using X Y Z etc TypeScript users Is your feature request related to a real problem or usecase A clear description of your problem or usecase Related to I added MutableT in For optional properties we have OptionalT K and RequiredT K AugmentedRequiredT K in our codebase To be consistent we should also have AugmentedMutableT K and AugmentedReadonlyT K Maybe we should even have AugmentedPartialT K although OptionalT K already does the job for consistency sake We should have some consistency between Partial vs Optional These two keywords mean the same thing for us However in the case of Required we didnt use a new word and just augmented with AugmentedRequiredT K Describe a solution including usage in code example A clear description of the solution including usage with complete code examples nicely formatted with ts tags especially if thats a new api proposal Given MutableT in ts export type AugmentedMutable T extends object K extends keyof T keyof T OmitT K MutablePickT K ts export type AugmentedReadonly T extends object K extends keyof T keyof T OmitT K ReadonlyPickT K ts Same as OptionalT K export type AugmentedPartial T extends object K extends keyof T keyof T OmitT K PartialPickT K Who does this impact Who is this for Who is this for All users TypeScript users Yourself People using X Y Z etc TypeScript users Table of contents needs improvements in organization for better user experience also we are missing some builtin examples Here is a rough plan of needed improvements Improve api list organization and grouping operations on object keys Add missing builtin types Record Parameters ConstructorParameters Add missing usecase examples to standardlib API Add Optional type alias for Partial I would be nice to have a nice API Documentation webpage with search functionality similar to Ramda API documentation requirements A recommended solution is to parse source files which now contains usage examples in JSDoc comments to generate a markdown based static documentation website One way is to use a full documentation generator to generate a website from source files Im open to suggestions if you can find something but I guess TypeScript support will be required maybe this Another way would be to use a JSDoc Markdown transformer like jsdoc md and then add some custom scripts to do the rest and use it as a page in a markdown docs generator like Docsaurus or Docz Additional alternatives to investigate looks nice and this TS project is using it so we might check their solution Im not sure if its possible either way might be good to document 