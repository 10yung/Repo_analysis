It doesnt affect us but worthwhile to add the test to prevent regression I noticed that amalgamation doesnt work on ARM and PowerPC tested on Travis CI it works fine on AMD because the target values used in the GCC pragmas are not valid ARM INFO Writing amalgamation header to botanallh INFO Writing amalgamation header to botanallinternalh INFO Writing amalgamation source to botanallcpp INFO Writing amalgamation source to botanallneoncpp INFO Writing amalgamation source to botanallarmv cryptocpp INFO Writing amalgamation source to botanallarmv cryptoneoncpp INFO Botan revision gited ab fd b ea ff b unreleased undated build setup is complete botanallarmv cryptoneoncpp error target pragma armv crypto is invalid pragma GCC target armv crypto botanallarmv cryptoneoncpp error target pragma neon is invalid pragma GCC target neon make buildobjlibbotanallarmv cryptoneono Error make Waiting for unfinished jobs botanallarmv cryptocpp error target pragma armv crypto is invalid pragma GCC target armv crypto make buildobjlibbotanallarmv cryptoo Error botanallneoncpp error target pragma neon is invalid pragma GCC target neon make buildobjlibbotanallneono Error PowerPC INFO Writing amalgamation header to botanallh INFO Writing amalgamation header to botanallinternalh INFO Writing amalgamation source to botanallcpp INFO Writing amalgamation source to botanallaltiveccpp INFO Writing amalgamation source to botanallpowercryptocpp INFO Botan revision gited ab fd b ea ff b unreleased undated build setup is complete botanallpowercryptocpp error pragma GCC target powercrypto is invalid pragma GCC target powercrypto make buildobjlibbotanallpowercryptoo Error May be somewhat related to Release planned for April feature freeze starting March th Cert path building TLS handshake internals refactoring Fix BoGo shim to handle PSS tests Support timeout in BoGo DTLS tests Resolveexamine remaining BoGo test failures Hello All Im using BotanTLSServer on top of standalone ASIO Im using a selfsigned certificate as CA and another one as server certificate signed with that selfsigned one both made with botan command line using ECDSA algorithm session manager is SessionManagerNoop rng is AutoSeededRNG and the policy is StrictPolicy Im using version and everything works fine on Windows and ArchLinux Now my questionproblem If I upgrade botan on my ArchLinux going to version or when I built it on an Ubuntu box botan I get an alert TLS handshake failure on the client side At the moment I have no idea what is wrong or what else to look for If I use openssl as a client I get the following openssl sclient enablepha tls state msg showcerts connect localhost CAfile tmpcerttempcertspem CONNECTED SSLconnectbefore SSL initialization length db TLS Handshake length db ClientHello d cd a fe c a cb b c d d cd f d e b cd cd aa a a c c c f cc a cc a cc aa c b c f e c c b c c c a c c c d c d c f ff a c e e b a c a d e d e a b SSLconnectSSLv TLS write client hello length TLS Alert length fatal handshakefailure SSL alert readfatalhandshake failure SSLconnecterror in error error SSL routinesssl readbytessslv alert handshake failuresslrecordreclayers c SSL alert number no peer certificate available No client certificate CA names sent SSL handshake has read bytes and written bytes Verification OK New NONE Cipher is NONE Secure Renegotiation IS NOT supported Compression NONE Expansion NONE No ALPN negotiated SSLSession Protocol TLSv Cipher SessionID SessionIDctx MasterKey PSK identity None PSK identity hint None SRP username None Start Time Timeout sec Verify return code ok Extended master secret no Am I missing some initializationconfiguring for other versions of botan This is PR allows wrapping TLSServer using TLSStream x how to configure timeouts see comment what happens on short read x implement asyncshutdown x drop commit that adds the spike x sort out licensing issues regarding the Beast example the CLI tool removed the example and opted for a simpler unit test instead x outsource Beast example link in manual x restore lowestlayer accessors or decide that we didnt need them Testing In addition to the TODOs above Im wondering how we should best unit and integration test this The existing tlsasiostream unit tests are not really meaningful here as the underlying Channel is mocked and does not care whether we want it to do a clientside or serverside handshake The spike that is included could be adjusted to become a kind of integration test if we want to have something like that Sorry for original title typo fuzzer build runs with ASan only right now I think because UbSan wasnt supported by GCC Should enable UbSan socketcpp socketudpcpp and clisocketutilsh have a lot of sharedduplicated code for handling differences in socket interface between BSD and Windsock Consolidate into a single internal header which can be used across all three Im trying to verify ECDSA signatures but I dont understand how to verify hashes directly Is there a way to use prehashed data instead of having the PKVerifier calculate the hashes Only ever seen this in CI not been able to reproduce gost sign pubkeygost signvec ran tests FAILED Failure Test failed with exception OIDencodeinto OID is invalid Key C BA A C A A BCD D F B DF F C BF C AA D F AB CD ED FEDA A B AD FD DC It seems more common on the Aarch fuzzer build which has cores so it may be some kind of threading bug The EC group being tested here is a custom registered one which I suspect is part of the issue