Tested with preview Orig Code cs using System namespace ConsoleApp public class CZZZ static int count static void Main ConsoleWriteLineM ConsoleWriteLineM public static int M count int x return M x int M x TryGetXout x if count M x return x public static int M int x M x return x void M x x private static bool TryGetXout int x x count return true Actual M InvalidOperationException Sequence contains no elements maybe related to cs SystemInvalidOperationException Sequence contains no elements at SystemLinqEnumerableFirst TSource IEnumerable source at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageIsClosureILTransformContext context ILVariable variable ITypeDefinition closureType ILInstruction initializer at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageRunILFunction function ILTransformContext context at ICSharpCodeDecompilerCSharpCSharpDecompilerDecompileBodyIMethod method EntityDeclaration entityDecl DecompileRun decompileRun ITypeResolveContext decompilationContext M After modified variableHasInitialValue to variableAddressCount which also fix in TransformDisplayClassUsagecs it not throw exception But the scope of x will be changed and it will return instead of in new code cs public static int M count return M x int M x TryGetXout int x if count M x return x M Maybe an variant of M it will not throw InvalidOperationException but will hit some assert and see the return is lost cs public static int M M int x see the return is lost void M x Tested with preview Reproduce step Compile the below code Open the output assembly with ILSpy Switch to IL with C modesee ctor or cctor cs using System using SystemLinqExpressions public class C private static ExpressionFuncint a private ExpressionFuncint b Stacktrace cs SystemNullReferenceException at ICSharpCodeILSpyCSharpILMixedLanguageMixedMethodBodyDisassemblercDisplayClass Disassembleb KeyValuePair kvp at SystemLinqEnumerableFirstOrDefault TSource IEnumerable source Func predicate at ICSharpCodeILSpyCSharpILMixedLanguageMixedMethodBodyDisassemblerDisassemblePEFile module MethodDefinitionHandle handle at ICSharpCodeDecompilerDisassemblerReflectionDisassemblerDisassembleMethodBlockPEFile module MethodDefinitionHandle handle GenericContext genericContext at ICSharpCodeDecompilerDisassemblerReflectionDisassemblerDisassembleMethodPEFile module MethodDefinitionHandle handle at ICSharpCodeDecompilerDisassemblerReflectionDisassemblerDisassembleTypePEFile module TypeDefinitionHandle type at ICSharpCodeILSpyTextViewDecompilerTextViewDecompileNodesDecompilationContext context ITextOutput textOutput at ICSharpCodeILSpyTextViewDecompilerTextViewcDisplayClass DecompileAsyncb Only showing the full information but the protection cant see all of code ICSharpCodeDecompilerMetadataPEFileNotSupportedException PE file does not contain any managed metadata ICSharpCodeDecompilerMetadataPEFilectorString fileName PEReader reader MetadataReaderOptions metadataOptions ICSharpCodeILSpyLoadedAssemblyLoadAssemblyObject state SystemThreadingTasksTask InnerInvoke SystemThreadingTasksTaskExecute Some obfuscators seems to be removing the CompilerGenerated attributes maybe I didnt get it right but TypeDefinitionIsCompilerGenerated checked whether the attribute existed Why is it necessary I find it confusing I thought its some kind of bug As stated in SharpTreeView is the only remaining firstparty component inside the repo that is not MIT licensed History Together with other parts eg AvalonEdit it was copied verbatim from SharpDevelop at the time ILSpy was started AvalonEdit source code was later swapped for AvalonEdit NuGet which was relicensed to MIT please see for the relicensing of SharpDevelop to MIT Options leave it is as is take the latest MITlicensed code from the SharpDevelop repository and replace our LGPL copy with the new MITlicensed copy However we have fixed stuff in our repo that never happened in SharpDevelop new project format bug fixes et cetera relicense our LGPL copy to MIT See the history changes have been contributed by developers wout JCA to the copied code Wed need to get their ok Tested with master roslyn Seems roslyn start to use an new mode and can not be proper translated by ILSpy See also Orig Code M works well and it is just to be used to compare with M cs public static int M TT t return t is int i i public static int M Tobject t This one works just use it to compare with M return t is int i i IL CS method public hidebysig static int M T T t cil managed Method begins at RVA x Code size x maxstack locals init int IL ldarg IL box T IL isinst SystemRuntime SystemInt IL b brfalses IL IL d ldarg IL e box T IL isinst SystemRuntime SystemInt IL unboxany SystemRuntime SystemInt IL d stloc IL e brs IL IL ldci m IL ret IL ldloc IL ret end of method CM This one works just use it to compare with M method public hidebysig static int M T object t cil managed Method begins at RVA x Code size x maxstack locals init int IL ldarg IL isinst SystemRuntime SystemInt IL brfalses IL IL ldarg IL unboxany SystemRuntime SystemInt IL e stloc IL f brs IL IL ldci m IL ret IL ldloc IL ret end of method CM Expected Will get the below code if you change typeof t from T to object cs public static int M TT t if t is int return intt return Actual cs public static int M TT t if t is int return t as intShould not use as here return Old Code from Roslyn Decompile code cs public static int M TT t T val if val t is int return intobjectval return il method public hidebysig static int M T T t cil managed Method begins at RVA x Code size x maxstack locals init int i T IL ldarg IL dup IL stloc IL box T IL isinst SystemRuntime SystemInt IL d brfalses IL d IL f ldloc IL box T IL unboxany SystemRuntime SystemInt IL a stloc IL b brs IL f IL d ldci m IL e ret IL f ldloc IL ret end of method Class M I am one of the principal developers on the Visual Studio Debugger and the original developer of several of Visual Studios core debugging scenarios The ilspy decompiler is a very impressive piece of technology We Visual Studio are preparing to release a new feature where the ilspy decompiler is fully integrated into the debugger This will allow users to produce symbols and source while debugging even in cases where modules only exist in memory such as dump files that contain module memory or when a user realizes after starting a debug session that decompilation is required We are running into some limitations with the symbol sequence point generation I have been prototyping fixes for these issues and I would like to start a conversation around them Sequence points seem to be getting emitted at locations where the ilstack is not empty Anytime this happens the debugger will be incapable of performing evaluations and many times breakpoints will fail to bind The CLR will consider the current execution location within a cant stop region Even in release builds our compilers still often try to empty the il stack across statement boundaries Note that this is even happening when decompiling debug builds with nop based sequence points in the il Sequence points are missing at opening and closing braces from some other issues I believe this has been discussed but was determined to be low priority However with the VS integration this breaks several scenarios such as stepping in to a method with symbols and then invoking the decompiler As an example since C compilers emit sequence points at the opening braces the debugger with symbols but without source will stop on the opening brace of a function during a stepin If after stepping in the user performs decompilation to produce source the debugger will complain that the current instruction pointer has no source info since the sequence points emitted by the decompiler will not contain this location I hope you are as excited about this scenario as we are on the VS Debugger Fully integrated decompilation will make my own daytoday workflow much easier Test with master Orig code cs private static void MMMM M static void M do object context new object Invoke contextToString while true private static T InvokeTFuncT func func Actual But when directly look into the compiler generated method MMMMgM the init line of var context is proper removed The only difference I can see in ILAst is that the var in latter one is not marked as HasInitialValue cs private static void MMMM M static void M object context defaultobjectthis line should be removed while true context new object Invoke contextToString ILSpy version preview Error decompiling A Transform in assembly C Temp err dll SystemArgumentException An item with the same key has already been added at SystemThrowHelperThrowArgumentExceptionExceptionResource resource in offset at SystemCollectionsGenericDictionary InsertTKey key TValue value Boolean add in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageVisitStObjStObj inst in offset at ICSharpCodeDecompilerILStObjAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockBlock block in offset at ICSharpCodeDecompilerILBlockAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockContainerBlockContainer container in offset at ICSharpCodeDecompilerILBlockContainerAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockBlock block in offset at ICSharpCodeDecompilerILBlockAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockContainerBlockContainer container in offset at ICSharpCodeDecompilerILBlockContainerAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockBlock block in offset at ICSharpCodeDecompilerILBlockAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockContainerBlockContainer container in offset at ICSharpCodeDecompilerILBlockContainerAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockBlock block in offset at ICSharpCodeDecompilerILBlockAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockContainerBlockContainer container in offset at ICSharpCodeDecompilerILBlockContainerAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitILFunctionILFunction function in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageVisitILFunctionILFunction function in offset at ICSharpCodeDecompilerILILFunctionAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitCallCall inst in offset at ICSharpCodeDecompilerILCallAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitLeaveLeave inst in offset at ICSharpCodeDecompilerILLeaveAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockBlock block in offset at ICSharpCodeDecompilerILBlockAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitBlockContainerBlockContainer container in offset at ICSharpCodeDecompilerILBlockContainerAcceptVisitorILVisitor visitor in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageDefaultILInstruction inst in offset at ICSharpCodeDecompilerILILVisitorVisitILFunctionILFunction function in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageVisitILFunctionILFunction function in offset at ICSharpCodeDecompilerILTransformsTransformDisplayClassUsageRunILFunction function ILTransformContext context in offset at ICSharpCodeDecompilerCSharpCSharpDecompilerDecompileBodyIMethod method EntityDeclaration entityDecl DecompileRun decompileRun ITypeResolveContext decompilationContext in offset continuing with outer exception ICSharpCodeDecompilerDecompilerException at ICSharpCodeDecompilerCSharpCSharpDecompilerDecompileBodyIMethod method EntityDeclaration entityDecl DecompileRun decompileRun ITypeResolveContext decompilationContext in offset at ICSharpCodeDecompilerCSharpCSharpDecompilerDoDecompileIMethod method DecompileRun decompileRun ITypeResolveContext decompilationContext in offset at ICSharpCodeDecompilerCSharpCSharpDecompilerDoDecompileITypeDefinition typeDef DecompileRun decompileRun ITypeResolveContext decompilationContext in offset at ICSharpCodeDecompilerCSharpCSharpDecompilerDoDecompileTypesIEnumerable types DecompileRun decompileRun ITypeResolveContext decompilationContext SyntaxTree syntaxTree in offset at ICSharpCodeDecompilerCSharpCSharpDecompilerDecompileTypesIEnumerable types in offset at ICSharpCodeDecompilerCSharpWholeProjectDecompilercDisplayClass WriteCodeFilesInProjectb IGrouping file in offset at SystemThreadingTasksParallelcDisplayClass ForWorkerb in offset at SystemThreadingTasksTaskInnerInvokeWithArgTask childTask in offset at SystemThreadingTasksTaskcDisplayClass ExecuteSelfReplicatingb Object p in offset err input 