 this is the example code package main import log githubcomgingonicgin githubcommicrogomicroweb type Say struct func s Say Anythingc ginContext logPrintReceived SayAnything API request cJSON map string string message Hi this is the Greeter API func s Say Helloc ginContext logPrintReceived SayHello API request cJSON ginH helloworld func main Create service service webNewService webNamegomicroapigreeter serviceInit Create RESTful handler using Gin say newSay router ginDefault routerGETgreeter sayAnything routerGETgreetername sayHello Register Handler serviceHandle router Run server if err serviceRun err nil logFatalerr start service go run maingo GINdebug GET greeter mainSayAnythingfm handlers GINdebug GET greetername mainSayHellofm handlers I Listening on I Received SayAnything API request start micro micro local visit curl idgomicroclienttransportcode detail Not Found page not foundstatusInternal Server Error output from console GIN s POST GIN s POST stop micro and start micro handler micro api handlerhttp visit messageHi this is the Greeter API output from console GIN s GET greeter I Received SayAnything API request Question When I start micro local and visit the url server get request but the method is POST and start by micro api handlerhttp server get the correct request Why I get this behavior how can I post data when Contenttypeapplicationxwwwformurlencoded if rBody nil switch ct case applicationxwwwformurlencoded expect form vals in Post data default data ioutilReadAllrBody reqBody stringdata Hi Im wondering if there is a simpler way to initialise a service while using plugins package main import context log githubcommicrogomicro githubcommicrogomicroserver githubcommicrogopluginsservergrpc githubcommicrogopluginstransportgrpc func HandlerWrapperhandlerFunction serverHandlerFunc serverHandlerFunc return funcctx contextContext req serverRequest rsp interface err error logPrintlnHandling requet return func main service microNewService microNametestservice microWrapHandlerHandlerWrapper logPrintlnservice name before parsing env vars serviceOptionsServerOptionsName serviceInit microNametestservice logPrintlnservice name after parsing env vars serviceOptionsServerOptionsName serviceServerInit serverNametestservice serverWrapHandlerHandlerWrapper logPrintlnafter resetting service name serviceOptionsServerOptionsName Run the server if err serviceRun err nil logFatallnerr The code above is an example of how Im initialising my service Here Im only passing args to microNewService and serviceInit just to make my point clearer Im running this code with MICROSERVERgrpc go run maingo And the output is service name before parsing env vars testservice service name after parsing env vars gomicroserver after resetting service name testservice Server grpc Listening on Broker http Connected to As expected serviceInit replaces the server forcing me to call serviceServerInit after it So basically I have to call microNewService serviceInit and serviceServerInit plus serviceClientInit because in the actual service Im also using some wrappers for the client and Im also loading the client plugin Im wondering is there is a way to initialise the service in fewer steps Also looking to the code it doesnt seem necessary to import githubcommicrogopluginsservergrpc and githubcommicrogopluginsclientgrpc Are they really necessary when using these plugins Im currently using gomicro v Thanks in advance I want to know micro api gateway cpu and memory stats so use micro api command to start default API Gateway micro docs said this profile value Debug profiler for cpu and memory stats MICRODEBUGPROFILE so please tell me set goenv MICRODEBUGPROFILE value is command profile how can i use Thank u very much Is your feature request related to a problem Please describe A clear and concise description of what the problem is Ex Im always frustrated when Describe the solution youd like Some times we may use one micro api gateway for rpc and http at the same time Can we add a endpoints apiEndpoint option for gomicrowebService interface Handle and HandleFunc func My implement So that user can use webService start a http service for micro api gateway Otherwise users need to implement it themselves Just an idea to see if its necessary to add to the gomicroweb eg go package main import fmt nethttp githubcomhbgomicropluginsweb githubcommicrogomicroapi githubcommicrogomicroutillog func main create new web service service webNewService webNamegomicroapiconsoleweb webVersionlatest initialise service if err serviceInit err nil logFatalerr serviceHandleconsole handler apiEndpoint Name console Host stringlocalhost Path string console Method stringPOST GET DELETE Handler proxy run service if err serviceRun err nil logFatalerr type handler struct func handler ServeHTTPw httpResponseWriter r httpRequest wWrite bytefmtSprintfrequest success path v rURLPath Additional context Add any other context or screenshots about the feature request here I use githubcommicrogomicrotransportquic a server work some time report this error i need help Is your feature request related to a problem Please describe Add the possibility to use your own logger or another logger like logrus Logrus is very good for microservices in particular to add fields Its very annoying to have two different log lines like this INFO T start service statustest I Listening on C I Received signal interrupt I Stopping Describe the solution youd like An option Logger that can be set when defining the microservice or another better solution Like go service microNewService microNameservice microLoggerDEFINELOGGERHERE Hello I have deployed my micro service on cloud machine A port is enabled and started consul consul agent dev client with following config curl cmn t caa a acc b ec f a b ca aa ffff f t caa a acacf e d b ca aa ffff d t caa a e d a b d b ca d d e aa ffff t caa a a dcf c e aa b acecf b ecd aa ffff f c t caa a ca fc fcecf b ca d d e aa ffff a e e c b ac c df e a b dba da d b d ebffb b bb eaff f e eb c ea fcf fef a f f da fc c fa ae de f c ba c edf cdab b e e e ec cf b d e a ca be a d f b f e a f bce c cd adac e a b b f c e f b bdc bcdeb ffb faf fa d d bf a d a bd d e b f d f ffffdaaee f v cca c d e ffff cc e consul curl Node ID e ad bc b db e e b f Node PROD Address Datacenter dc TaggedAddresses lan wan Meta consulnetworksegment CreateIndex ModifyIndex Service ID cmn a cab e e afaedd a c Service cmn Tags t caa a acc b ec f a b ca aa ffff f t caa a acacf e d b ca aa ffff d t caa a e d a b d b ca d d e aa ffff t caa a a dcf c e aa b acecf b ecd aa ffff f c t caa a ca fc fcecf b ca d d e aa ffff a e e c b ac c df e a b dba da d b d ebffb b bb eaff f e eb c ea fcf fef a f f da fc c fa ae de f c ba c edf cdab b e e e ec cf b d e a ca be a d f b f e a f bce c cd adac e a b b f c e f b bdc bcdeb ffb faf fa d d bf a d a bd d e b f d f ffffdaaee f v cca c d e ffff cc e Address Meta null Port Weights Passing Warning EnableTagOverride false Proxy MeshGateway Expose Connect CreateIndex ModifyIndex Checks Node PROD CheckID serfHealth Name Serf Health Status Status passing Notes Output Agent alive and reachable ServiceID ServiceName ServiceTags Type Definition CreateIndex ModifyIndex But if I try to call micro service from another server not in the same LAN then I get ERROR microrpcgo idgomicroclientcode detailcall timeout context deadline exceededstatusRequest Timeout ERROR microrpcgo executiontime s ERROR apidapidgo if I run the test on machine A with its local ip as consul registry then it works what should I do to make the service available for remote machines http micro api srv grpc header makemap string string if md ok metadataFromContextctx ok for k v range md header k v frontend request http header key ContentLength was put in backend request metadata directly but the contentlength was changed when I use micro with istio the envoy nghttp will verify contentlength then cause ErrCodeProtocol here is nghttp integrationtests func TestH H BadRequestCLt testingT st newServerTesternil t noopHandler defer stClose we set contentlength but the actual request body is bytes res err sthttp requestParam name TestH H BadRequestCL method POST header hpackHeaderField paircontentlength body bytefoo if err nil tFatalfError sthttp v err want http ErrCodeProtocol if reserrCode want tErrorfreserrCode v want v reserrCode want 