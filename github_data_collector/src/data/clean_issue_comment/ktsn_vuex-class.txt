It will be useful to use your library with es modules in browser PLEASE READ THE ISSUE REPORTING GUIDELINE BEFORE SUBMITTING YOUR ISSUE Issue Reporting Guideline Questions For general usage question which is not related to vuexclass should be posted to StackOverflow or other Q A forum Such questions will be closed without an answer Bug Reports Please make sure to provide minimal and selfcontained reproduction when you report a bug Otherwise the issue will be closed immediately I am trying to use State in my vue component but Vetur gives a hint Member XXX implicitly has an any typeVetur code like this js storets state switchFlg false my component State private switchFlg I know it needs declaration type and I can fix it by State switchFlg boolean But I think its too troublesome I have to write the declaration type twice or even more Is there a better solution Currently the definition is typescript export type GetterS R state S getters any rootState R rootGetters any any every parameter other than state S is actually optional and should be declared as such Right now this is keeping me from actually using these types because using them would make my unit test code messy with extraneous nullvalued params Also could you provide some guidance on when these typings are actually useful As far as I know these classes are never used directly but rather by Vuex internals This PR adds some generic types to enhance StateTransformer and namespace for better type inference Is it possible to setup Getter to get the following output javascript computed collectionCategoryObjects return thisstoregetters entitiescollectionsgetCollectionCategoryObjects department thisdepartment collectionTitle thiscollectionTitle How can I create Getter in a compact format Is there a way to setup a getter that is less verbose than this javascript const Ncollection namespaceentitiescollections class NcollectionGettergetCollectionCategoryObjects getterCollection any get Collection return thisgetterCollection department thisdepartment collectionTitle thiscollectionTitle Hey I have seen recommendations to use this package Im thinking If there is a comparison between thisstyle and the vanilla style it will help me decide on whether I should adopt this project I would like to define the types of mutations as symbol but Mutation supports just string as argument is it possible to add support for symbol PLEASE READ THE ISSUE REPORTING GUIDELINE BEFORE SUBMITTING YOUR ISSUE Issue Reporting Guideline Questions For general usage question which is not related to vuexclass should be posted to StackOverflow or other Q A forum Such questions will be closed without an answer Bug Reports Please make sure to provide minimal and selfcontained reproduction when you report a bug Otherwise the issue will be closed immediately When combined with a dynamic store registration as described by the vuex docs the decorators fail as they try use the store before it exists Proposed changes Explain how to access to a flat state Explain how to access to a nested state Reasons Understand more quickly how to use the library Issues Fixes and I am trying to bind a checkbox to my Vuex Store My understanding is that I need to use vmodel bformcheckbox idonlyMineFilterCheckbox vmodelonlyMineFilterShow only Minebformcheckbox To do the binding I need to create a computed property on my component class I can either do this export default class MyView extends Vue Mutation updateOnlyMineFilter Statestate stateonlyMineFilter onlyMineFilterState boolean get onlyMineFilter return thisonlyMineFilterState set onlyMineFiltervalue boolean thisupdateOnlyMineFiltervalue or this export default class MyView extends Vue store any get onlyMineFilter return thisstorestateonlyMineFilter set onlyMineFiltervalue boolean thisstorecommitupdateOnlyMineFilter value The first option uses the vuexclass annotations which is consistent with the rest of my component but it is verbose and the statemutation members are only used once The second option is less verbose but forces me to use store directly with the declaration of store just to fool typescript which I dont like What would be best I think would be if the state accessor and the mutation could be combined into a single annotation something like this Computedstate stateonlyMineFilter updateOnlyMineFilter onlyMineFilter boolean What do we think I am happy to attempt the implementation if we think it is a good design 