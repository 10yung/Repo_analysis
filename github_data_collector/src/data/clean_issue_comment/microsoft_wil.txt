If exceptions arent enabled using wilcomptr results in an error that isnt immediately clear without digging through the source error C comptr is not a member of wil It should be pretty easy to add a struct that takes a compile time message and staticassertfalse message if that class is instantiated to produce a clearer error message when using throwing types in binaries that dont support exceptions Still looking into it but it seems that in the following C HRESULT hr SOK try throw stdbadalloc catch hr LOGCAUGHTEXCEPTION auto hrDirect wilResultFromCaughtException REQUIREhr hrDirect The catch handler is not getting executed inside of ResultTestsExceptionHandling FWIW something similar is working correctly C auto hr HRESULT try throw stdbadalloc catch RETURNCAUGHTEXCEPTION The only difference is that the second example is within a lambda Could be that Catch is doing something weird wrt exception handling thats interfering with a newer update in MSVC Still looking at it In your documentation you say To get started testing WIL first make sure that you have a recent version of Visual Studio and the most recent Windows SDK installed I use Visual Studio and Win SDK and library cant be compiled because of some unknown attributes in header files Looks like VS andor Win SDK is not enough Could you please mention in documentation exact version of VS and SDK which are required to use WIL New header wilchronoh defines stdchrono adapters for all fixedfrequency Windows timers and timestamps General considerations User modeonly for now because I dont know if chrono is kernel modesafe If we could get confirmation of the safety of chrono from the compiler people we could add similar wrappers for functions like KeQueryTickCount KeQuerySystemTime etc Alternatively we could fork the LLVM chrono into a wistdchronoh header Where possible functions have been made constexpr through WILIBCPPCONSTEXPRAFTERCXX so that it depends on the underlying constexprness of chrono functions I havent implemented DOSFAT timestamps because frankly I think they arent worth the effort The following timers have a variable frequency and cant have zerooverhead stdchrono adapters so they arent included for now QueryPerformanceCounter The auxiliary counter if there was a function to query it what is the deal with it The CPU timestamp register as returned by intrinsics like rdtsc or rdtscp This timer comes with additional considerations such as Detecting availability whether the architecture implements it whether the sandboxhypervisorVM allows access to it whether it has a stable frequency eg constant or invariant TSC on IntelAMD processors etc Querying the frequency hard I tried and I still dont have a good answer Instruction ordering for example rdtsc is unordered and needs a fence mmmfence or mmlfence for meaningful measurements or alternatively rdtscp can be used but all solutions require an additional feature test and even the feature test itself cpuidcpuidex may in turn require a feature test Processor cycle counters eg QueryThreadCycleTime are out of scope since they arent timebased at all Testing I dont know how to write test cases but I could learn All clock classes support a form of compiletime dependency injection so writing tests for corner cases shouldnt be hard Overview Tick counter clocks The following Clocks are defined tickcountclock rep DWORD period stdmilli ms issteady true now wraps GetTickCount if WIN WINNT x tickcount clock rep ULONGLONG period issteady timepoint same as tickcountclock now wraps GetTickCount Caveats Unlike standard C clocks these clocks have an unsigned rep This is intentional the value returned by GetTickCount has a limited range and we dont want to incur in undefined behavior dealing with signed underoverflow System time clocks The following Clocks are defined systemtimeclock rep LONGLONG period stdratiomultiplystdhecto stdnano ns issteady false now wraps GetSystemTimeAsFileTime tofiletime and fromfiletime conversion between timepoint and raw FILETIMEs tosystemclock and fromsystemclock conversion between timepoint and stdchronosystemclocktimepoint totimet fromtimet totime t fromtime t totime t fromtime t conversion between timepoint ns Windows epoch and stdtimettime ttime t s UNIX epoch if WIN WINNT WIN WINNTWIN precisesystemtimeclock rep period timepoint issteady same as systemtimeclock tofiletime fromfiletime tosystemclock fromsystemclock totimet fromtimet totime t fromtime t totime t fromtime t same as systemtimeclock now wraps GetSystemTimePreciseAsFileTime highprecisionsystemtimeclock if WIN WINNT WIN WINNTWIN alias for precisesystemtimeclock else alias for systemtimeclock Caveats tofiletime and fromfiletime are implemented inline because including win helpersh to use wilfiletime routines didnt seem worth it compared to the downsides win helpersh pulls in extra dependencies and pollutes the namespace wilfiletime routines arent constexpr nor constexprcompatible In tosystemclock and fromsystemclock we nonportably assume stdchronosystemclocktimepoint starts from the UNIX epoch However this is true in all C runtime library implementations I know of and it will be a requirement starting from C Interrupt time clocks When targeting Windows or later if WIN WINNT x the following Clock is defined unbiasedinterrupttimeclock rep LONGLONG period stdratiomultiplystdhecto stdnano ns issteady true now wraps QueryUnbiasedInterruptTime When targeting Windows or later and using a Windows or later SDK ifdef NTDDIWIN the following Clocks are also defined interrupttimeclock rep LONGLONG period stdratiomultiplystdhecto stdnano ns issteady true now wraps QueryInterruptTime preciseinterrupttimeclock rep period timepoint issteady same as interrupttimeclock now wraps QueryInterruptTimePrecise preciseunbiasedinterrupttimeclock rep period timepoint issteady same as unbiasedinterrupttimeclock now wraps QueryUnbiasedInterruptTimePrecise Process and thread times Types The following types are defined cputimeduration stdchronodurationLONGLONG stdratiomultiplystdhecto stdnano cputime cpp enum class cputime total kernel user executiontimes cpp struct executiontimes systemtimeclocktimepoint creationtime systemtimeclocktimepoint exittime cputimeduration kerneltime cputimeduration usertime threadtimes and processtimes aliases for executiontimes Functions The following functions are defined cpp templateclass ErrorPolicy threadtimes getthreadtimesHANDLE thread GetCurrentThread threadtimes getthreadtimesHANDLE thread GetCurrentThread Returns the threadtimes for the thread identified by the thread handle Defaults to the current thread Wraps GetThreadTimes handling errors according to ErrorPolicy ErrorPolicy defaults to errexceptionpolicy when calling the nontemplate overload cpp templateclass ErrorPolicy cputimeduration getthreadcputimeHANDLE thread GetCurrentThread cputime kind cputimetotal cputimeduration getthreadcputimeHANDLE thread GetCurrentThread cputime kind cputimetotal Returns the CPU time usage specified by the kind argument for the thread identified by the thread handle Defaults to the total kernel user CPU time of the current thread Wraps GetThreadTimes handling errors according to ErrorPolicy ErrorPolicy defaults to errexceptionpolicy when calling the nontemplate overload cpp templateclass ErrorPolicy processtimes getprocesstimesHANDLE process GetCurrentProcess processtimes getprocesstimesHANDLE process GetCurrentProcess Returns the processtimes for the process identified by the process handle Defaults to the current process Wraps GetProcessTimes handling errors according to ErrorPolicy ErrorPolicy defaults to errexceptionpolicy when calling the nontemplate overload cpp templateclass ErrorPolicy cputimeduration getprocesscputimeHANDLE process GetCurrentProcess cputime kind cputimetotal cputimeduration getprocesscputimeHANDLE process GetCurrentProcess cputime kind cputimetotal Returns the CPU time usage specified by the kind argument for the process identified by the process handle Defaults to the total kernel user CPU time of the current process Wraps GetProcessTimes handling errors according to ErrorPolicy ErrorPolicy defaults to errexceptionpolicy when calling the nontemplate overload Clocks The following Clocks are defined currentthreadcputimeclock rep period same as cputimeduration duration cputimeduration nowErrorPolicy wraps getthreadcputime with default arguments and the specified ErrorPolicy returning the total CPU time used by the current thread now wraps now passing errexceptionpolicy as its ErrorPolicy currentprocesscputimeclock rep period same as cputimeduration duration cputimeduration nowErrorPolicy wraps getprocesscputime with default arguments and the specified ErrorPolicy returning the total CPU time used by the current process now wraps now passing errexceptionpolicy as its ErrorPolicy Caveats Only error policies that interrupt execution eg errfailfastpolicy errexceptionpolicy are meaningfully supported Policies that return error codes will be effectively ignored and errors will cause undefined values to be returned CPU time clocks were only defined for the current process and current thread so that they could be stateless classes The Clock concept doesnt mandate statelessness but its unclear to me how statefulness conceptually interacts with timepoint CPU time clocks were only defined for total time because I couldnt think of a good unambiguous API for passing a cputime argument is a leap year and there are lot of times developers do things like manipulate SYSTEMTIME or FILETIME or convert from one to another and they do not take into account leap years C has AddYears for this WIL should implement safe date manipulation methods like C so that isnt a mess Per the thread on adopt one of Raymonds suggestions I personally like the intermediate stdtuple approach This may require yet another layer of indirection if the tuple instantiation triggers the no mixing C SEH in a single frame requirement Any chance you would publish on conan Raymond pointed this out here this should be fixed PathCchh is included in win helpersh However the functions declared in this header are only available on Windows or higher An include guard could be used to cover this case if WIN WINNT WIN WINNTWIN include PathCchh endif But after quickly inspecting win helpersh I couldnt find any references to the symbols in PathCchh and it compiles without any errors in my project without this include If the PathCchh include has no function I propose it should be removed When the diagnostics level is set to using the following define define RESULTDIAGNOSTICSLEVEL In a release build with all optimizations etc I do expect that ReturnHr is not called in the generated code However this is not the case when using the RETURNIFFAILED macro if hr wildetailsin diag ReturnHrretaddr hr return hr A possible solution might be do define different helper macros depending on RESULTDIAGNOSTICSLEVEL Eg if RESULTDIAGNOSTICSLEVEL undef RETURNHRFAIL define RETURNHRFAIL RETURNHRFAILEXPECTED undef RETURNIFWIN BOOLFALSE define RETURNIFWIN BOOLFALSE RETURNIFWIN BOOLFALSEEXPECTED undef RETURNLASTERRORIFNULL define RETURNLASTERRORIFNULL RETURNLASTERRORIFNULLEXPECTED undef RETURNLASTERRORIF define RETURNLASTERRORIF RETURNLASTERRORIFEXPECTED undef RETURNIFWIN ERROR define RETURNIFWIN ERROR RETURNIFWIN ERROREXPECTED undef RETURNHRIF define RETURNHRIF RETURNHRIFEXPECTED endif 