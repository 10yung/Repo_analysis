I have a scenario where i would like to publish an event when a specific message was moved to the error queue I would also like to extract a property from the message I attempted to solve it by a configuration like this csharp endpointConfiguration Recoverability Failedsettings settingsOnMessageSentToErrorQueuefailedMessage MovedToErrorQueuefailedMessage endpointInstance private async Task MovedToErrorQueueFailedMessage failedMessage FuncIEndpointInstance getEndpointInstance if SomehowGetMessageFromfailedMessage is MyCommand command await getEndpointInstancePublishnew MyCommandDeliveryFailedEventcommandid however the FailedMessage type seems a bit sparse and im not sure how i would go about extracting message data from that so my next attempt was to add a behavior like this csharp private class AddMyPropToHeader BehaviorIIncomingLogicalMessageContext public override async Task InvokeIIncomingLogicalMessageContext context FuncTask next if contextMessageInstance is MyCommand command contextHeadersAddMyCommandId commandIdToString await nextConfigureAwaitfalse to the pipeline and in the error handler pick this header up from FailedMessageHeaders but the custom header i added is not available there so it seems my only option now is for the sender of the message to add the header which seems like a somewhat ugly solution Is that correct or is there perhaps a better way Since the release with changes to the PropertySagaFinder some of our sagas are giving exceptions resulting in failed messages Example exception message SystemException Message SomeMessageType mapped to saga SomeSaga has attempted to assign null to the correlation property ProcessId Correlation properties cannot be assigned null We have a message type named ProcessSucceeded that looks as follows ParentProcessId d ef a d bcfcc bb ProcessId b e cb bb e TenantId SomeTenant The correlation property here is ParentProcessId and is configured as follows mapperConfigureMappingProcessSucceededmsg msgParentProcessId ToSagadata dataProcessId To clarify we have processes that can have subprocesses In the saga for the parent process we want to handle successmessages of type ProcessSucceeded that are published by the subprocess However not all of our processes have a parent process because they ARE the parent process So the ParentProcessId property is set to null In case a messages arrives with the property set to null we can safely drop it not handle the message This worked well in version but no longer works in because the correlation property is validated against null values explicitly Is there a way for you to allow null correlation properties but drop the messages in which they appear We are currently unable to update to the latest version Endpoint can throw with an exception Learning transport does not support custom saga finders at start when a saga message mapping is on a message that does not match a naming convention This is a very confusing error as there were no custom saga finders present The configurationBuilderCustomization parameter which allows customization of the endpoint configuration in the IEndpointSetupTemplateGetConfiguration method currently doesnt allow the customizations to use async code This requires some code to use GetAwaiterGetResult eg here public interface IEndpointSetupTemplate TaskEndpointConfiguration GetConfigurationRunDescriptor runDescriptor EndpointCustomizationConfiguration endpointConfiguration ActionEndpointConfiguration configurationBuilderCustomization Other similar projects have started to drop it and given that MS support ended we can also consider dropping it What would be the highest new full framework we can lock on Or can we go netstandard only Removes the building of the dispatcher and make the subscribe unsubscribe terminator stage connectors that go into the dispatch pipeline Less builder access Allows to properly intercept and stamp messages even in acceptance tests for subscribe and unsubscribe calls without having to decorate the dispatcher Hardcoded previous step ids to be backward compatible Found no doco that says these have to be terminators With the refactoring efforts around the hosting receive and send components a lot of workarounds had to be added for backwards compatibility With the next major version those workarounds canshould be removed in order to simplify the code quite a bit Remove the internal settings access by the components Settings classes Change transport initialization by removing the marked obsolete methods in the SendComponent to the components regular Initialization process Consider removal of featureComponentRegisterFeatureEnabledStatusInSettingshostingConfiguration functionality in EndpointCreatorInitialize that is needed to allow transports to know if the TimeoutManager is enabled or not needed to for backwards compatibility around native timeouts Consider removing feature state completely from settings Remove obsolete marked methods in HostComponent I am trying to add a Behavior like below to the pipeline in order to access IMessageHandlerContext but the behavior is not picked up c configurationRegisterComponentsc cConfigureComponentContextBehaviourDependencyLifecycleInstancePerCall configurationPipelineRegisterbehavior typeofContextBehaviour test containerRegisterComponentForContextAccessor And that is the definition of the Behavior c public class ContextBehaviour BehaviorIInvokeHandlerContext public override Task InvokeIInvokeHandlerContext context FuncTask next var contextAccessor contextBuilderBuildContextAccessor throw new ExceptionContext behaviour invoke issue contextAccessorContext context return next public class Registration RegisterStep public Registration basestepId ContextBehaviour behavior typeofContextBehaviour description Sets IMessageHandlerContext for ContextAccessor public class ContextAccessor public IMessageHandlerContext Context get set We have a BehaviorIIncomingPhysicalMessageContext added to the pipleline and that is working However the above one doesnt work and Invoke method for is never called I am not sure if I need to replace another behavior or something else is missing Trying out the impact of PublicApiGenerator beta on NServiceBus The test has been excluded because at the time of release it was incompatible with NHibernate PR was raised to make it compatible