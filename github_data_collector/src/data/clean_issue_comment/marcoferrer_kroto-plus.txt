It would be beneficial to users if they were able to enable log output when debugging issues with coroutines One of the main reason this was avoided initially was because we didn t want to tie users to a particular logging framework Additionally we didn t want to introduce any overhead into the library Using something like googles flogger would provide performant logging and allow users to include whichever backend matches their current logging framework It would be nice to see an example dokka configuration that would display the autogenerated code preferably with DSL examples Arrangement Project with a Spring Web MVC RestController that uses a protobuf generated class as an input and calls the same server code as the GrpcSpringService using Kroto Plus configured to generate builders message extensions and coroutines for the service and messages defined in the proto files Kroto Plus version SNAPSHOT was used Copyright C Electronic Arts Inc All rights reserved package comeapoutineroolzrlzservice import comeaprrapiRController import orgspringframeworkbootSpringApplication import orgspringframeworkbootautoconfigureSpringBootApplication import orgspringframeworkcontextConfigurableApplicationContext import orgspringframeworkcontextannotationBean import orgspringframeworkcontextannotationComponentScan import springfoxdocumentationbuildersPathSelectors import springfoxdocumentationbuildersRequestHandlerSelectors import springfoxdocumentationspiDocumentationType import springfoxdocumentationspringwebpluginsDocket import springfoxdocumentationswagger annotationsEnableSwagger SpringBootApplication EnableSwagger import the specific ones we want Swagger exposed for rather than let it wander around scanning controllers in the packages ComponentScanbasePackageClasses RControllerclass class Swagger SpringBoot companion object lateinit var appContext ConfigurableApplicationContext JvmStatic fun mainargs ArrayString appContext SpringApplicationrunSwagger SpringBootclassjava args Bean fun api Docket return DocketDocumentationTypeSWAGGER select apisRequestHandlerSelectorsany pathsPathSelectorsany build SpringBootApplication ComponentScancomeap EnableDiscoveryClient EnableConfigurationProperties class RApp companion object private val logger KotlinLogginglogger JvmStatic fun mainargs ArrayString loggerdebug Running RApplication with args KlaxontoJsonStringargs SpringApplicationrunRAppclassjava args Bean fun init CommandLineRunner loggerdebug init called Bean fun userProvider UserProvider return ThreadLocalUserProvider RestController RequestMappingv r class RController Autowired constructor private val service RService fConverter FConverter private val timers Timers private val rResultConverter rResultConverter private val container KContainer private val bEvaluator BEvaluatorservice fConverter private val logger KotlinLogginglogger PostMappingvalue tenanttenantIdentityentityId consumes applicationxprotobuf applicationjson produces applicationxprotobuf applicationjson fun ruleResultRequest PathVariabletenantId tenantId String PathVariableentityId entityId String RequestBody eRequests BERequest ResponseEntityBRResults runBlocking val tags mapOfactorKey to PAKeyentityId tenantIdtoString withLoggingContexttags respond rainbow brackets plugin for IntelliJ is useful here logicFunc ruleResultConvertertoDto timersrecordAsyncMetricTypesRRequestGrpcid tags async bEvaluatorexecuteevalRequests entityId tenantId afterFunc loggerinfo Finished all requests in list for tenantId entityId DeleteMappingtenanttenantIdentityentityId fun deleteSession PathVariabletenantId tenantId String PathVariableentityId entityId String ResponseEntityBoolean this block wraps with trycatch with boilerplate logging and is from the apicommon library returns an ResponseEntityOkthis return value as body when it exits the respond block return respond logicFunc servicedeleteSessionPAKeyentityId tenantId afterFunc loggerinfoCompleted REST API to gRPC call for deleteSession for tenantId entityId GetMappingvalue r produces applicationjson fun getAllRNames ResponseEntityListString runBlocking val rNames containergetRNames val tags mapOfrNames to rNamestoString withLoggingContexttags respond loggerdebug Finished returning all the rnames rNames mockServices filter includePath comeap implementAsObject true generateServiceList true serviceListPackage comeapr serviceListName MockRServices protoBuilders filter excludePath google includePath comeap unwrapBuilders true useDslMarkers true grpcCoroutines grpcStubExts supportCoroutines true extendableMessages filter includePath comeapr syntax proto import googleprotobufanyproto package comeapr option javapackage comeaprrp option javamultiplefiles true service RService rpc bREvaluation BERequest returns BRResults rpc deleteSession DeleteSessionRequest returns DeleteSessionResponse message BERequest string tenantId string entityId repeated ERequestV eRequests Service service message BRResults repeated EResponseV responses message EResponseV string associatedRequestId repeated RResultV rResults message RResultV string rId bool state mapstring string results message ERequestV string requestId repeated FDto f repeated string rIdFilter message Service string service string key message FactDto string factId googleprotobufAny value This is a possible FDto value message FJsonValue string jsonValue The string with the JSON representation enum FType The supported types the JSON representation can be mapped to STRING INTEGER BOOLEAN DOUBLE LISTINTEGER LISTSTRING STATSDATA FType fType message DeleteSessionRequest string tenantId string entityId message DeleteSessionResponse bool success Expected Works the same as before starts up fine with a Swagger UI Actual Fails to start gets lost in the gRPC generated code Workaround Remove Kroto Plus observe that it starts up again Several cases have come up where users have wanted to be able to destructure message with the familiar kotlin syntax Although this is highly requested it doesn t come for free It can become massively error prone for users if they re arrange fields ids or introduce new ones I still think a safe implementation can be provided by allowing users to define a deconstructor option within their message Similar to the common proto support of the method signature option The trade off is that this would make the component extensions explicitly defined and managed by the proto author instead of implicitly determined by the plugin There s a already a branch in progress with a working example but the majority of the effort needed for this is in writing good documentation Hello In bidirectional streaming How I can check client connection status I am developing multiplayer online game with your library and I want to know when one player disconnect and notify to other players How come the abstract NameImplBase class generates open functions rather than abstract functions I think it would be nice to get a compile time error if a method has not been implemented rather than a runtime error Hello Can you provide an example of how to subscribe to a server stream please In my case the server sends messages to the stream every second but when I connect to it like Screenshot at Oct I get messages every minutes Currently server implementations use server handler builder to process incoming calls using the existing stream observer api This requires a lot of adapter code just to map coroutine behavior to the existing stream observer call back It should be possible to implement ServerCallHandler and emit its usage in the generated code This gives us the ability to not only improve performance but map the coroutine apis closer to the call level At the moment it is difficult to expand the kroto API With access to the call we could potentially allow users to pass execution parameters via a call wrapper type This would allow the customization of the following Server method CoroutineStart Initial coroutineContext Channel buffer size for streaming APIs Possibly Custom Exception handlers Call wrapper example kotlin abstract class ServerCallCoroutineReqTRespT delegate ServerCallReqTRespT SimpleForwardingServerCallReqTRespTdelegate open val initialContext CoroutineContext EmptyCoroutineContext open val coroutineStart CoroutineStart CoroutineStartATOMIC open val requestChannelBufferSize Int ChannelBUFFER The kroto implementation of ServerCallHandler would be able to check for this type explicitly during method invocation and use the parameters provided Now in development there is not elegant form to show errors in console we have to put in every coroutine try catch and print the error and in production for example if I have EntityNotFoundException I have to put a try catch and raise StatusException Is there an elegant way to handle exceptions with coroutins If we use the classic grpc form we have the interceptors but in the case of the coroutins the exception is encapsulated before it can be handled by the server interceptors I think the errors should be able to be handled like coroutin errors in the context and if they are not handled there the server must handle it with interceptors and if the server dont handle it the application should be closedBy default should exist a interceptor to catch every exception and handle it for avoid application closing At the moment I have solved it by modifying the library to delegate errors to a Handler from ThrowtoRpcException but it is not the best