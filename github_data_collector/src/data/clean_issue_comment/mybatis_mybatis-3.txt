Mapperxml can support the dynamic creation of SQL but is there a better way to use it For example creating SQL using a DSL package toprish import javautilList import static toprishOrderORDER import static toprishUserUSER import static toprishjsqldslDsl public class Ztest public static void mainString args ListUser query sql select from USERasuleftJoinOnORDERasoUSERIDeqORDERUSERID where USERIDeq orderByUSERID groupByUSERID limit queryUserclass sql select from user as u left join order as o on uid ouserid where uid order by uid desc group by uid limit Systemoutprintlnquery UseriduserNameUseriduserName select from user as u left join order as o on uid ouserid where uid order by uid desc group by uid limit Question Please use the mailing list Or Stack Overflow with mybatis tag Questions on this tracker will be closed without comment Bug report Please fill out the BUG REPORT FORM below To fix a bug we need to reproduce it first And we spend a lot of time just trying to reproduce the reported problem so please consider creating a failing test case or an example project How to create a test case How to create a good example How to upload your project to GitHub Feature request Please delete the BUG REPORT FORM below and describe the feature It is a good idea to discuss your changes on the mailing list to get feedback from the community If you have a patch with unit tests send a pull request Please see the wiki page BUG REPORT FORM MyBatis version xx Database vendor and version MySql Test case or example project This part code means wirte off doc batch update purchase docs residue amount to pay update idupdateResidueAmount foreach collectionlstDoc itemmDoc separator update psspurchase set residueamounttopayresidueamounttopaymDocwriteOffAmount where companyidmDoccompanyId and doccodemDocsourceDocCode and isaudited and residueamounttopay gt mDocwriteOffAmount where foreach update Expected result I need to know whether process is completely successful by a result about affected rows like return a number of rows or array about affected rows Actual result this result actually return even the doc update more than rows I cant judge whether the doc update complelety This is the rest of I had rewritten the rest and reviewed them Now its time to submit them mybatis version is x in the Configuration class public Executor newExecutorTransaction transaction ExecutorType executorType executorType executorType null defaultExecutorType executorType executorType executorType null ExecutorTypeSIMPLE executorType Executor executor i think executorType check is repeated defaultExecutorType cant be empty so i think executorType no need second check Minor overall affect but could impact some pull requests Ive had this sitting around since January th and its had little to no impact during rebasing since so its low risk HiI found that there are many mappers that cause fullgc dependency groupIdorgmybatisgroupId artifactIdmybatisartifactId version version dependency Sometimes people dont need the first level cache but theres no way to avoid mybatis taking up these memory so I added nouse to localcachescope for this circumstances Control level cache behavior at statement level Hi I would like to add SQL comment like below globally to all SQL SELECT FROM users TraceID foobarbaz So I wrote this code But This uses reflection API Therefore this code is not productionready Is there another way I need a way to enable to add SQL comment generated by some code Motivation SQL with TraceID is useful If we just find a query without TraceID in slow query log we cannot identify a transaction But if there are TraceID in slow query we can trace a transaction So I need MyBatis version The null pointer was first discovered by the log file It appears in the createAutomaticMappings method of DefaultReusltSetHandler We noticed that at line getUnmappedColumnNames returned a null which caused NPE We continue to debug and find that loadMappedAndUnmappedColumnNames is very strange The simple nonnested resultType we use in SQL and columnPrefix is null in getMapkey the generated map key id was wrong cause id contains no null string We ran it again in the normal environment and found that the key in the map contains a null string The key generated in the loadMappedAndUnmappedColumnNames does not have a null string When using mapkey to obtain the corresponding unMappedColumnNames in method getUnmappedColumnNames line the key contains null and we got null how does it appears i cant understand img Caused by javalangNullPointerException at orgapacheibatisexecutorresultsetDefaultResultSetHandlercreateAutomaticMappingsDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlerapplyAutomaticMappingsDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlergetRowValueDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlerhandleRowValuesForSimpleResultMapDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlerhandleRowValuesDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlerhandleResultSetDefaultResultSetHandlerjava at orgapacheibatisexecutorresultsetDefaultResultSetHandlerhandleResultSetsDefaultResultSetHandlerjava at orgapacheibatisexecutorstatementPreparedStatementHandlerqueryPreparedStatementHandlerjava at orgapacheibatisexecutorstatementRoutingStatementHandlerqueryRoutingStatementHandlerjava at orgapacheibatisexecutorSimpleExecutordoQuerySimpleExecutorjava at orgapacheibatisexecutorBaseExecutorqueryFromDatabaseBaseExecutorjava at orgapacheibatisexecutorBaseExecutorqueryBaseExecutorjava at orgapacheibatisexecutorCachingExecutorqueryCachingExecutorjava at orgapacheibatisexecutorCachingExecutorqueryCachingExecutorjava at orgapacheibatissessiondefaultsDefaultSqlSessionselectListDefaultSqlSessionjava 