Hello I am currently using your repository for my PhD I would like to know how to send a Chan from a server to a Client such that they both connect to this new sessionchannel I have a recursive error which requests either a send when I have a recv or a recv when I have a send Thank you in advance Are there plans to allow the user to configure the actual transport underneath a Chan I want to use session types with asyncawait and in distributed systems Thanks Hello I am currently experimenting with BSTs in Rust and hopefully soon MPSTs Ill be publishing the code soon The following thread covers different design decisions relating to the internal implementation without changing the interface for consumers When I move on to MPST Ill experiment with a DSL using macros Use a union over all message variants and rely on the state machine to select the desired type to sendrecv Vs Transmuting a Boxpointer on the crossbeamchannel Note For safety the union will can trivially be replaced with an enum Currently rusts enum representations arent quite as nice as they could be but this should improve in the future further reducing the cost of tagging each variant Importantly we do not need unsafe to implement session types The space inefficient enum tag wont be much more than the optimized choicebased tag and it is already significantly cheaper than boxing all messages Backend agnostic Ie A nostd context can use a corecellCellOptionUnionOfMessages as the underlying channel without worrying about allocations Choices can send a single message and if followed with a send the two messages may be bundled Vs Sending each boolean choice over the channel Although Rust doesnt have linear types it does have private constructors which I conject in combination with affine types is sufficient to force the protocol to progress through at least one valid path Replacing the unit in the E type parameter of a Chan with a public contextual type with a private constructor instantiating it the relevant function can be forced to return the closed channel to its caller Do we need anything stronger than requiring the program progress through at least one valid path Proof of concept rust mod private pub struct Start pub struct End impl Start pub fn finishself End End pub fn requirecompletionf impl FnStart End fStart pub fn requirecompletionmutmut f impl FnMutStart End fStart use selfprivaterequirecompletion requirecompletionmut fn main The closure is given a Start but it cannot create another It is required to return an End but it can only acquire one by consuming the Start with a call to Startfinish requirecompletions sfinish Good These fail as expected requirecompletion privateStartfinish requirecompletion privateEnd Caveat This misuse of channels is prevented by Fn but not FnMut However an actor defined without the visibility of its caller removes this particular risk too requirecompletionmut s requirecompletionmuts corememreplace mut s s finish sfinish Suggestion is to add a macro for writing the session types down Something like rust protoAtm Client Id act u u act u act act u eps eps where T P denotes RecvT P T P denotes SendT P A B C is ChooseA ChooseB C A B C is OfferA OfferB C t P should be RecP Any occurrences of t in P should be replaced with an appropriate VarN construct eps is just Eps The output of proto is then two type aliases rust type Atm type Client Atm as HasDualDual This should replace the current constructs like this rust type Atm RecvId ChooseRecAtmInner Eps type AtmInner OfferAtmDeposit OfferAtmWithdraw OfferAtmBalance Eps type AtmDeposit Recvu Sendu VarZ type AtmWithdraw Recvu ChooseVarZ VarZ type AtmBalance Sendu VarZ type Client Atm as HasDualDual Some relevant documentation and Associated types are powerful enough to avoid needing an environment stack or recursive session types rust pub trait HasDual type Dual SessionType pub trait Alias type Id HasDual pub struct GotoA AliasPhantomDataA pub struct GotoDualA AliasPhantomDataA implA Alias HasDual for GotoA type Dual GotoDualA implA Alias HasDual for GotoDualA type Dual GotoA Cool but it requires ugly struct definitions and impls at every depth I think this downside is mentioned throughout session type literature Its not practical they said Just use recursive session types they said But wait theres macros rust protoAtm Recv String AtmMenu Accept AtmDeposit Recv u Send u Goto AtmMenu AtmWithdraw Recv u Send bool Goto AtmMenu AtmGetBalance Send u Goto AtmMenu End Unfortunately the macro necessary to expand such a construct is ridiculously complex and this is after omitting recursion chooseoffer etc rust macroexport macrorules proto formty End End formty Goto tty Gotot formty Recv tty resttt Recvt protoformty rest formty Send tty resttt Sendt protoformty rest formty stufftt protoformty stuff formty ity stufftt i as AliasId formty ity tident stufftt i as AliasId newaliases otherstt protoconstructalias others newaliases somettresttt otherstt protonewaliases some rest others newaliases resttt otherstt protonewaliases rest others newaliases aliasident astufftt loltt otherstt protonewaliases lol alias astuff others newaliases aliasident tident astufftt loltt otherstt protonewaliases lol alias t astuff others newaliases xident resttt otherstt protonewaliases rest others constructfinal aliasident aresttt allowdeadcode struct alias impl Alias for alias type Id protoformty arest constructfinal aliasident aresttt resttt protoconstructfinal alias arest protoconstructfinal rest constructalias eps resttt protoconstructfinal rest constructalias aliasident resttt otherstt protonewaliases rest others alias rest startident resttt protoconstructalias start rest eps Right now the path down a Choose style decision tree is formed by signaling with booleans over the channel which is not space efficient Further you must use macros to avoid having to do a bunch of annoying compositions to select the branches you want Heres an alternative API which unfortunately requires Rust nightly but somehow works rust featureoptinbuiltintraits use stdmarkerPhantomData trait ChooseFrom implQ ChooseFrom for FinallyQ implP Q ChooseFrom ChooseFrom for ChooseP Q struct FinallyQPhantomDataQ struct ChooseP Q ChooseFromPhantomDataP Q struct CompoundA BPhantomDataA B trait NotSame impl NotSame for implA NotSame for CompoundA A trait ChooserT fn num usize implP Q ChooseFrom ChooserP for ChooseP Q fn num usize implP ChooserP for FinallyP fn num usize implP S Q ChooseFrom ChooserS ChooserS for ChooseP Q where CompoundS P NotSame fn num usize Qnum implP Q ChooseFrom ChooseP Q fn chooseS self usize where Self ChooserS Selfnum fn main let a Chooseusize Chooseisize ChooseString Finally ChoosePhantomData println achooseString Basically in theory you can just call chanchooseProtocol and it will signal over the channel that youre switching to that protocol using a single number Perhaps if theres a monomorphization recursion limit anyway we could use u or u instead of usize to make the discriminant as small as possible Safety note if the number wraps around it will cause memory safety violations Perhaps we can use peano numbers to encode a maximum limit here Also I believe with inlining LLVM will completely optimize this away Are the transmutes necessary for performance reasons Chan could be reconstructing itself as it takes itself by value and should not need to transmute Im reasonably confident LLVM will optimize this away 