 In the same spirit as the following environment variable cargo fix could try first applying all suggestions and if it fails applying only the MachineApplicable ones This could be problematic depending on the codebase size due to compilation times but may be it could be worked around by keeping rustc statistics of prior runs and only do this if compile times are short enough Work for and rustlangrust Dont merge this yet we need to evaluate downstream consequences Here is a diff created by running cargo fix editionidioms on a piece of code diff diff git asrcmainrs bsrcmainrs index f d c c asrcmainrs bsrcmainrs extern crate futures extern crate hyper extern crate hypertls extern crate serde The four blank lines it substituted for the extern crate statements it removed are useless and just create a bunch of odd looking space in the source code Itd be better to just remove the lines without replacement Excuse me if this is not the right place to bring this up What if a library could use deprecated a convention about what to put in the note to enable cargo fix to automatically fix the deprecation if its due to a rename rust deprecatednoteRenamed to newname pub fn oldnamex i i newnamex pub fn newnamex i i unimplemented Heres the rustc warning rust Warning use of deprecated item oldname Renamed to newname srcvisitreversedrs oldname note warndeprecated on by default In that sense it is guided by rustc I dont know at all if this is doable but I imagine it would require some kind of agreed protocol for the format of the deprecation message A more formal way to go about it would be to design this in rustc and for example use a new attribute or a new option on the attribute like deprecatedrenamedtonewname In an empty directory run sh cargo new lib a cargo new lib b cargo new lib ac echo b path b aCargotoml echo c path c aCargotoml cat asrclibrs END pub fn foo pub mod bar use foo pub fn baz foo END cp asrclibrs bsrclibrs cp asrclibrs acsrclibrs cd a cargo nightly fix edition j find name librs xargs grep use rm r a b This creates three crates with identical code with one depending on the other two through path Cargo dependencies cargo fix is able to silently fix the root crate for the other two it only prints warnings Output with nightly which contains cargo nightly d f which depends on rustfix rust Created library a project Created library b project Created library ac project Checking b v tmpfoob warning absolute paths must start with self super crate or an external crate name in the edition tmpfoobsrclibrs use foo help use crate cratefoo note W absolutepathsnotstartingwithcrate implied by W rust compatibility warning this was previously accepted by the compiler but is being phased out it will become a hard error in the edition note for more information see issue Checking c v tmpfooac warning absolute paths must start with self super crate or an external crate name in the edition csrclibrs use foo help use crate cratefoo note W absolutepathsnotstartingwithcrate implied by W rust compatibility warning this was previously accepted by the compiler but is being phased out it will become a hard error in the edition note for more information see issue Checking a v tmpfooa Fixing srclibrs fix Finished dev unoptimized debuginfo targets in s bsrclibrs use foo acsrclibrs use foo asrclibrs use cratefoo The first step is to run cargo fix cargo fix edition This will check your code and automatically fix any issues that it can cargo fix is still pretty new and so it can t always fix your code automatically If cargo fix can t fix something it will print the warning that it cannot fix to the console If you see one of these warnings you ll have to update your code manually Indeed running roughly this command with nightly prints some warnings So many warnings that just transferring them through SSH saturates the Mbps link from my build server sh touch librs cargo fix edition allowdirty manifestpath portsservoCargotoml tmpfixlog ls sh tmpfixlog M tmpfixlog wc lines tmpfixlog tmpfixlog grep warning tmpfixlog c grep warning tmpfixlogsortuniq c warning absolute paths must start with self super crate or an external crate name in the edition warning anonymous parameters are deprecated and will be removed in the next edition warning async is a keyword in the edition warning try is a keyword in the edition grep help use crate tmpfixlog c To be fair these numbers are inflated because a lot of the relevant code is generated But still I hope this shows that the absolutepath warnings are extremely common I feel it is essential that rustfix can fix them automatically for the edition migration path to be viable These absolutepath warnings seem to be mostly in one of three cases An use statement for an item in the same crate The warning message suggests adding crate and even shows what the new import should look like So it seems like we re most of the way there to apply this fix automatically An use statement for an item in an external crate but that crate has been renamed with for example extern crate mozjs as js In this case a path starting with js could be considered absolute and referring to an external crate Though this is a language change rather than a rustfix change An derive attribute with a derive defined in a procmacro crate Builtin derives like deriveClone are not affected The correct fix is probably to add use cratenameDeriveName near the start of the module Again automatically Is something like dryrun planned Or rustfix will always require a VCS Here This issue concerns the matter of a single suggestion that happens to replace multiple spans functionality that is not used often but which does exist This is not to be confused with multiple suggestions that happen to touch the same code which if I understand correctly while reading quickly was what was about Im happy to work on this because I need it for rustlangrust A place for people to report success or partial success and things they liked