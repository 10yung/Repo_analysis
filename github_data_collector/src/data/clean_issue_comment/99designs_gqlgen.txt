 What happened current signatures type Cache interface Getkey string value interface ok bool Addkey string value interface to type Cache interface Getctx contextContext key string value interface ok bool Addctx contextContext key string value interface What did you expect I want to use AppEngines memcache for graphqlCache but Its required that contextContext from http request If this breaking change is acceptable Ill send a PR What happened I have a schema where I want to log the name and value for an input field but I am unable to get the name and value of the input field associated with the directive What did you expect I would expect the name and value to be printed as mentioned in the type extension examples Minimal graphqlschema and models to reproduce Schema directive inputLog on INPUTFIELDDEFINITION input NewTodo text String inputLog userId String type Mutation createTodoinput NewTodo Todo Directive definition func InputLog ctx contextContext obj interface next graphqlResolver res interface err error rc graphqlGetResolverContextctx strToBeLogged fmtSprintffield v has value v rcFieldName obj fmtPrintlnstrToBeLogged return nextctx prints field createTodo has value Text UserID I would expect field text has value foo versions gqlgen version go version The idea here is to have a central proxy to packagesLoad that can be invalidated as files are written out reducing the number of packageLoad calls way down Would love to get your thoughts vikstrous Alternative to and that includes some fairly heavy refactor Updated timing for one of our apps v real m s user m s sys m s master real m s user m s sys m s packagecache real m s user m s sys m s i have n number of graphql file and i want separate resolver of each graphql file how it is possible I want to create sperate resolver for each graphql file Out put of go env GO MODULE GOARCHamd GOBIN GOCACHEhomekrawlercachegobuild GOENVhomekrawlerconfiggoenv GOEXE GOFLAGS GOHOSTARCHamd GOHOSTOSlinux GONOPROXY GONOSUMDB GOOSlinux GOPATHhomekrawlergo GOPRIVATE GOPROXY GOROOTusrlocalgo GOSUMDBsumgolangorg GOTMPDIR GOTOOLDIRusrlocalgopkgtoollinuxamd GCCGOgccgo ARar CCgcc CXXg CGOENABLED GOMODhomekrawlergosrcdemogomod CGOCFLAGSg O CGOCPPFLAGS CGOCXXFLAGSg O CGOFFLAGSg O CGOLDFLAGSg O PKGCONFIGpkgconfig GOGCCFLAGSfPIC m pthread fmessagelength fdebugprefixmaptmpgobuild tmpgobuild gnorecordgccswitches hi gqlgen team if gqlgen supports relay is very cool Normally when a service is taking part in graphql federation it will have at least one type defined with a key field so that other services can link to that is have an edge pointing to the type that this service provides The previous federation code assumed that was the case But its not required a service could not define key on any of its types It might seem that would mean the service is unreachable since there is no possibility of edges into the service but there are two edges that can exist even without a key top level Query edges and top level Mutation edges That is if a service only provides a toplevel query or toplevel mutation it might not need to define a key This commit updates the federation code to support that use case Describe your PR and link to any relevant issues I have Added tests covering the bug feature see testing Updated any relevant documentation see docs What happened What did you expect i want id is also CamelCase Minimal graphqlschema and models to reproduce versions gqlgen version v go version go modules What happened When running my app online I wanted to be able to utilize GraphIQL from the Playground handler but it currently has hardcoded CDN I think this is a reasonable default but breaks offline flows or what happens when the CDN goes down What did you expect More of a feature request potentially I could even submit the pull but a way to optionally set the CDN for the GraphIQL javascript files either globally or via instantiation of the handler etc Minimal graphqlschema and models to reproduce na versions Latest of all What happened I have written a marshaler for some DateTypes to be ISO conform This is the code of the marshaler If I try to run my application I get an error from the generated code internalappgraphqlgqlexecgengo not enough arguments to return internalappgraphqlgqlexecgengo ecunmarshalInputDateTime undefined type executionContext has no field or method unmarshalInputDateTime internalappgraphqlgqlexecgengo ecDateTime undefined type executionContext has no field or method DateTime internalappgraphqlgqlexecgengo not enough arguments to return internalappgraphqlgqlexecgengo ecunmarshalInputDate undefined type executionContext has no field or method unmarshalInputDate internalappgraphqlgqlexecgengo ecDate undefined type executionContext has no field or method Date internalappgraphqlgqlexecgengo ecDate undefined type executionContext has no field or method Date I have created the marshaler as described here What did you expect The application should start and does not throw this error Minimal graphqlschema and models to reproduce This file was generated based on personjson Do not edit manually schema query Query mutation Mutation type Mutation createPersoninput NewPerson Person deletePersonidentifier ID Boolean type Person active Boolean birthDate Date createdAt DateTime description String identifier ID updatedAt DateTime type Query personidentifier ID Person persons Person input NewPerson birthDate Date DateTime in ISO eg T scalar DateTime Date in ISO eg scalar Date Time in ISO eg scalar Time versions gqlgen version go version What happened Currently the only way to determine whether an input parameter is null vs undefined is to use reflections like described here Not ideal to have to use reflections and to manually have to unmarshal the data and one of the thing that gqlgen is supposed to do for us What did you expect Would be great to have a way to get the input parameters without having to use reflection It seems that the map string interface is always calculated anyway as we can see here Could this map be added to the context instead gqlgen could then expose a get from context method to retrieve the list of input parameters that were passed