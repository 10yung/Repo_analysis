 Environment NetMQ Version Operating System Win NET Version Core I created a console application that connect to a server via SubscribeSocket i run the program with wifi ON i start receiving messages If i disable wifi the messages stop If i enable wifi within seconds the messages start coming again if i wait more no more message ever come On some computers with the same software the problem does not manifest itself i investigated the problem here but i do not know how to work around it We precisely chose netmq for the network resiliency since the application will work with intermittent wifi connection ZMTP and the Null Mechanism is implemented as part of supporting Curve is a matter of implementing the Curve mechanism classes Net port of libsodium ZMTP and Curve RFC Curve mechanism classes that need to be ported We would also need to port the following socket options bool CurverServer this should be used to decide which curve class to create client or server CurvePublicKey CurveSecretKey and CurveServerKey To hook curve mechanism with the StreamEngine create the relevant mechanism classes here Optional z encoding of certificates I recommend to port czmq cert certstore classs as well ZAP authentication protocol All code is in one line without syntax highlighting Environment NetMQ Version Latest of master Operating System window NET Version framework standard A RouterSocket as server and the clients are DealerSockets Use a Monitor to listen the RouterSocket s Disconnected event When listened to the client disconnected how to confirm which client is disconnected Environment NetMQ Version Operating System Win NET Version Framework Expected behaviour Hi I have problem with this function I was writen event wich working but some times this event in shutdown and I don t know why public void GetterFuncstring string start NetMQPoller poller new NetMQPoller getterReceiveReady send Event byte ID getterReceiveFrameBytes orderFromWife getterReceiveFrameString string answer CheckerorderFromWife getterSendMoreFrameID getterSendFrameanswer startorderFromWife ThreadSleep pollerAddgetter pollerRun Actual behaviour This is exeption NetMQHostUnreachableException HResult x MessageIn StreamXSend SourceNetMQ StackTrace at NetMQCorePatternsStreamXSendMsg msg at NetMQCoreSocketBaseTrySendMsg msg TimeSpan timeout Boolean more at NetMQNetMQSocketTrySendMsg msg TimeSpan timeout Boolean more at NetMQOutgoingSocketExtensionsSendIOutgoingSocket socket Msg msg Boolean more at NetMQOutgoingSocketExtensionsSendFrameIOutgoingSocket socket Byte data Int length Boolean more at NetMQWebSocketsWSRouterRouterShimHandlerOnOutgoingMessageNetMQMessage message at NetMQWebSocketsBaseShimHandlerOnMessagePipeReadyObject sender NetMQSocketEventArgs e at NetMQNetMQSocketInvokeEventsObject sender PollEvents events at NetMQNetMQPollerRun at NetMQWebSocketsBaseShimHandlerRunPairSocket shim at NetMQNetMQActorRunShim at SystemThreadingThreadHelperThreadStartContextObject state at SystemThreadingExecutionContextRunInternalExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx at SystemThreadingExecutionContextRunExecutionContext executionContext ContextCallback callback Object state Boolean preserveSyncCtx at SystemThreadingExecutionContextRunExecutionContext executionContext ContextCallback callback Object state at SystemThreadingThreadHelperThreadStart I was try fix it witch trychatch but nothing has changed Environment NetMQ Version Operating System PC Windows NET Version NET x via Unity f installed via NuGet and Asyncio version Expected behaviour I want to build a C DealerSocket and connect it to a Router at a known external address I want to send messages to the Router frequently and leave the Dealer up for the entire game Actual behaviour On Mac error works perfectly On PC I get this error message and the dealer is prevented from sending messages SocketException The operation completed successfully AsyncIOWindowsSocketSetSocketOption SystemNetSocketsSocketOptionLevel optionLevel SystemNetSocketsSocketOptionName optionName SystemInt optionValue at c de b face e a AsyncIOAsyncSocketsetNoDelay SystemBoolean value at c de b face e a NetMQCoreTransportsTcpTcpConnectorOutCompleted SystemNetSocketsSocketError socketError SystemInt bytesTransferred at b a a a eb ff aebfd NetMQCoreTransportsTcpTcpConnectorStartConnecting at b a a a eb ff aebfd NetMQCoreTransportsTcpTcpConnectorProcessPlug at b a a a eb ff aebfd NetMQCoreZObjectProcessCommand NetMQCoreCommand cmd at b a a a eb ff aebfd NetMQCoreIOThreadReady at b a a a eb ff aebfd NetMQCoreIOThreadMailboxRaiseEvent at b a a a eb ff aebfd NetMQCoreUtilsProactorLoop at b a a a eb ff aebfd SystemThreadingThreadHelperThreadStartContext SystemObject state at ba d b fbab b ac SystemThreadingExecutionContextRunInternal SystemThreadingExecutionContext executionContext SystemThreadingContextCallback callback SystemObject state SystemBoolean preserveSyncCtx at ba d b fbab b ac SystemThreadingExecutionContextRun SystemThreadingExecutionContext executionContext SystemThreadingContextCallback callback SystemObject state SystemBoolean preserveSyncCtx at ba d b fbab b ac SystemThreadingExecutionContextRun SystemThreadingExecutionContext executionContext SystemThreadingContextCallback callback SystemObject state at ba d b fbab b ac SystemThreadingThreadHelperThreadStart at ba d b fbab b ac UnityEnginecRegisterUECatcherb Object UnhandledExceptionEventArgs Steps to reproduce the behaviour code for the Dealer no other dependencies in the project using System using SystemCollections using SystemCollectionsGeneric using SystemLinq using SystemText using SystemThreading using SystemThreadingTasks using NetMQ using NetMQSockets using UnityEngine public class Dealer MonoBehaviour private bool dealerCancelled private IEnumerator dealerWorkerRoutine public Queuestring OutBox new Queuestring public Queuestring Inbox new Queuestring public Listfloat pings new Listfloat private DealerSocket sock public delegate void SocketDel private void Start tcp var connections new Liststring tcp SetupDealerconnections static void ClientReceiveReadyobject sender NetMQSocketEventArgs e Msg myMessage new Msg eSocketReceiveref myMessage DebugLogmyMessage private void SetupDealerListstring connections using var poller new NetMQPoller var resTask TaskFactoryStartNew DealerSocket client null var clientSocketPerThread new ThreadLocalDealerSocket if clientSocketPerThreadIsValueCreated client new DealerSocket clientOptionsIdentity EncodingUnicodeGetBytes ToString clientConnectconnections clientReceiveReady ClientReceiveReady clientSocketPerThreadValue client pollerAddclient else client clientSocketPerThreadValue while true var messageToServer new NetMQMessage messageToServerAppendEmptyFrame messageToServerAppendmessageToServer ConsoleWriteLine ConsoleWriteLine OUTGOING MESSAGE TO SERVER ConsoleWriteLine DebugLogClient Sending messageToServer clientSendMultipartMessagemessageToServer TaskCreationOptionsLongRunning pollerRunAsync DebugLogtaskresTaskStatusToString DebugLogpollerpollerIsRunning will handle the incoming message with the special HEARTBEAT Returns true if the message is not a special and should be enqueued to the list returns false if the message is a heartbeat throwaway private static bool DealerHandleIngressstring message ref Listfloat pingList if messageStartsWithHEARTBEAT var splits messageSplitSkip SelectConvertToDoubleToArray pingListAddfloat Timetime floatsplits pingListRemove return false else return true Thats my code thats running in a Unity Monobehavior The main thread in Start should start the longrunning task that would be handling the Dealer socket and all of its communication I thought that maybe it was a thread issue so I reimplemented it as a coroutine and got the exact same error using System using SystemCollections using SystemCollectionsGeneric using SystemLinq using SystemNetSockets using SystemThreading using NetMQ using NetMQSockets using UnityEngine public class TestCoroutine MonoBehaviour private bool dealerCancelled private IEnumerator dealerWorkerRoutine public Queuestring OutBox new Queuestring public Queuestring Inbox new Queuestring public Listfloat pings new Listfloat private DealerSocket sock public delegate void SocketDel private void Start tcp var connections new Liststring tcp StartDealerconnections private void StartDealerListstring targetConnections dealerWorkerRoutine DealerWorkertargetConnections StartCoroutinedealerWorkerRoutine pingsClear private IEnumerator DealerWorkerListstring toConnect sock new DealerSocket sockOptionsSendHighWatermark foreach var x in toConnect sockConnectx dealerCancelled false DebugLogSt ThreadSleep DebugLoglooping while dealerCancelled handle incoming while sockHasIn sockTryReceiveFrameStringout var message if DealerHandleIngressmessage ref pings InboxEnqueuemessage handle outgoing while OutBoxCount sockSendFrameOutBoxDequeue sockSendFrameHEARTBEATlongTimetime yield return new WaitForSeconds f DebugLogpost will handle the incoming message with the special HEARTBEAT Returns true if the message is not a special and should be enqueued to the list returns false if the message is a heartbeat throwaway private static bool DealerHandleIngressstring message ref Listfloat pingList if messageStartsWithHEARTBEAT var splits messageSplitSkip SelectConvertToDoubleToArray pingListAddfloat Timetime floatsplits pingListRemove return false else return true this also works perfectly on Mac but not on PC at all What is the recommended way to run a Dealer in Unity as a longrunning process How can I debug this issue with the SocketException Am I missing any other references permissions etc Ive learned a ton through the problemsolving process but would love some help thanks This should fix and a few other similar potential bugs in other versions of Remove and RemoveAndDispose See a few other comments on a couple of the tests and about throwing ArgumentException from Remove when socket is disposed Those should be left to a future PR though Environment NetMQ Version Operating System Win NET Version Standard Core Expected behaviour pollerRemovesocket socketDispose should remove the socket from the pollers list and then dispose the socket poller should continue to run servicing other sockets Actual behaviour poller throws ObjectDisposedException after socketDispose is called Steps to reproduce the behaviour This code in a unit test pollerRemovesocket socketDispose Causes an ObjectDisposedException error to throw on the pollers thread from SocketBaseCheckDisposed and kill my unit test runtime There needs to be some better syncing on PollerRemove so that it blocks the the pollers thread andor the caller of Remove such that the Remove does not return until that socket is actually removed from the pollers internal list This is the issue as it is currently written I would argue that CheckDisposed should return a bool so that poller can not try to access that socket and avoid throwing the exception I cant find a path to calling SocketDispose after it has been passed to PollerAddSocket and PollerRunAsync is called that doesnt throw UDP using var client new NetMQSocketsRequestSocket clientConnectudplocalhost for int i i i ConsoleWriteLineClient Sending Hello clientSendFrameHello var message clientReceiveFrameString ConsoleWriteLineServer Rep Msg message ERROR NetMQProtocolNotSupportedException Invalid protocol udp 