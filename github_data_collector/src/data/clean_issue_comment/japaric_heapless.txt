I work in a crate that requires static allocation everywhere heapless has been great I do have a lot of code that looks like rust let mut heaplessvec Veci U Vecnew heaplessvecpush expectFailed to push Now Id like to get all these pushes on the same level of error forwarding semantics as the rest of my crate and avoid any possibility of a panic Because pushT returns a Result T rather than a Result static str we cant use the brilliant operator to pass errors from pushing up the error chain Right now in order to return the error I want I have to do something along the lines of rust let mut heaplessvec Veci U Vecnew match heaplessvecpush Ok Err return Errfailed to push onto heapless vec This is really verbose If we had another type of push function that returned a Result static str then we could use like this rust fn psuhtovec ResultVeci U static str let mut heaplessvec Veci U Vecnew heaplessvecpushmsg heaplessvec This would represent a huge clean up and brings heapless more in line with encouraged Rust error handling semantics What are your thoughts on this Queue supports switching out the type to use for head and tail pointers which can save memory instead of Bytes for usizes I can choose to pay only Bytes for u s It would be nice to have the same option for Vec which currently always uses usize Some serialization formats distinguish between arrays of bytes and byte strings One approach is to defer to serdebytes An alternative is that heapless has a specialized Vecu wrapper type with its own serde routines but delegating everything else to Vec This is probably preferable to have all the traits available Thoughts I could give this a try if there is support to include such a Bytes type here I have a privatenonpolished POC that does the obvious thing Maybe there are other properties it could have over a generic Vec such as Ord or maybe more efficient extendfromslice and more natural target of Stringintobytes Closes Unfortunately const construction wont work since the Default or Clone bound on T cant be used then so Ive not added an internal type to irs Let me know if you think any other traits should be implemented The probing algorithms used in this crate for IndexMap are pretty rudimentary and from my pretty unscientific benchmarks basically just copying the benchmarks from the hashbrown crate comparing FnvHashMap with the fnvbased hashmap from this crate it seems like IndexMap is around x slower than stdcollectionsHashMap test indexmaptestsgetremoveinsertheapless bench nsiter test indexmaptestsgetremoveinsertstd bench nsiter Here are the benchmarks used to get the results above I compiled with LTO and codegenunits in order to make sure that std wasnt getting benefits from being inlining where heapless wasnt most notably around stdhash vs hash Of course these benchmarks are for large maps and smaller maps wont give such pronounced differences Also the use of hash will probably give a speedup on bit targets that the std map doesnt have access to rust bench fn getremoveinsertheaplessb mut Bencher let mut m crateFnvIndexMap U new for i in minserti iunwrap let mut k biter mget k mget k mremove k minsertk k unwrap k bench fn getremoveinsertstdb mut Bencher let mut m fnvFnvHashMapwithcapacityandhasher Defaultdefault for i in minserti i let mut k biter mget k mget k mremove k minsertk k k Im writing an embedded project that needs a hashmap and although I do have access to an allocator avoiding it will make my performance more predictable So I might try to put in a PR improving the performance of IndexMap if I get some spare time to do so Please implement the Write trait for byte vectors If possible please also implement ReadWrite for ConsumerProducer and other data structures It is currently not possible to be generic over the index type or single coremulti core SPSC queue variants because the traits Uxx and XCore cant be declared as type parameters because they are private If the traits were sealed so that the crate retained control over what types could implement Uxx and XCore it would be possible to write more generic code utilizing SPSC queues Example pool Pool allocator for the DMA engine running the transfers where each node in the allocator is an MyPoolNode allownonuppercaseglobals MyPool MyPoolNode The attribute propagates properly but the comment does not This makes it difficult to document and show examples connected to the pool Ive needed a classic ringbuffer quite a few times now and since its not that hard rolled my own What I mean is fixed capacity array plus index of head push moves head and overwrites allows random access using iterator and some standard things like first last maybe all items are initially filled with some default allows getting rid of Options for first etc normal mut methods no lockfree support This is nothing fancy but seems like it falls under the mission statement of heapless Ill contribute an initial implementation PR if yes