 Issue If a programmer supplied assumption assume etc is provably false this should result in a diagnostic and the assumption should be ignored Steps to Reproduce See Expected Behavior A diagnostic message pointing out that the second assumption is provably false Actual Results The false assumption is asserted to the prover Issue Hey I was playing around with MIRAI this weekend but I hit an issue trying to get MIRAI to check itself on the latest master After poking around a bit it looks like theres a foreign contract or blacklist missing Specifically it looks like MIRAI is complaining about something Unimplemented for rustchirdefidDefId as stdhashHasher Im sorry if thats a bit vague Im not very familiar with MIRAI Steps to Reproduce Run validatesh on current master c c ad e ef d aac d f f I also tested on the previous two commits same problem Results For completeness heres the part of log when run with MIRAILOGtrace Otherwise heres the relevant part of validatesh where MIRAI checks itself sh devMIRAI RUSTFLAGSZ alwaysencodemir RUSTCWRAPPERmirai RUSTBACKTRACE MIRAILOGinfo cargo build lib p mirai Compiling mirai v UsersphiliphayesdevMIRAIchecker T Z INFO mirai MIRAI options from environment Options singlefunc None testonly false diaglevel RELAXED T Z INFO mirai MIRAI options modified by command line Options singlefunc None testonly false diaglevel RELAXED T Z INFO miraicallbacks Processing input file checkersrclibrs T Z INFO miraicallbacks storing summaries for checkersrclibrs at varfoldersy nfv ryx x f gvdv rfd rynvd TmiraitempdirCiiLgkkjcSR summarystoresled T Z INFO miraisummaries creating a non default new summary store T Z INFO miraicallbacks skipping function miraiabstractvalueIMPLSERIALIZEFORAbstractValue as it is not public snip T Z INFO miraicallbacks skipping function miraiconstantdomainimplementconstantdomainleclosureclosureclosureclosureclosure as it is not public T Z INFO miraicallbacks skipping function miraiconstantdomainimplementconstantdomaingtclosureclosureclosureclosureclosure as it is not public T Z INFO miraicallbacks skipping function miraiconstantdomainimplementconstantdomaingeclosureclosureclosureclosureclosure as it is not public T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors t is stdoptionOption str T Z INFO miraivisitors selector is as Some T Z INFO miraivisitors t is type error T Z INFO miraivisitors selector is T Z INFO miraivisitors t is T T Z INFO miraivisitors selector is T Z INFO miraivisitors function logprivateapilog cant be reliably analyzed because it calls function logLoglog which has no body and no summary foreign fn argument key dyndyn logLog error internal compiler error srclibrustctraitscodegenmodrs Encountered error Unimplemented selecting BinderrustchirdefidDefId as stdhashHasher during codegen thread rustc panicked at BoxAny srclibrustcerrorslibrs stack backtrace unknown unknown snip unknown note rustc nightly de d f running on x appledarwin note compiler flags Z alwaysencodemir C debuginfo C incremental cratetype lib query stack during panic codegenfulfillobligation checking if stdhashHasher fulfills its obligations end of query stack error aborting due to previous error error could not compile mirai Environment sh uname a Darwin philiphayesmbp Darwin Kernel Version Thu Jun PDT rootxnu RELEASEX x swvers productName Mac OS X rustc version rustc nightly de d f cargo version cargo nightly f f e Issue I have been working on porting SMACK Rust regressions to MIRAI to uncover potential issues The eventual goal is to have a nice publicly available suite of Rust benchmarks Along the way I discovered this MIRAI issues where it appears to be missing the fact that the two assertions in this small example should obviously fail Steps to Reproduce Run MIRAI on this small example macrouse extern crate miraiannotations pub fn main let a i result let b i result assume a a a in assume b b b in verify a b ab in verifya b ab in Expected Behavior Both assertions should fail Actual Results The assertions are not failing Environment rustc nightly de d f MIRAI v I couldnt find the instructions for enabling the static analyzer in the documentation For example I want the compiler to raise an error in the following example rust prei alen posta i v fn updatea mut Boxi i usize v i a i v Is it possible Issue Running MIRAI on selection sort which iterates over a range of integers causes fixed point loop divergence Steps to Reproduce Test case fn selectionsortarray mut i let mut min for i in arraylen min i for j in i arraylen if array j array min min j let tmp array i array i array min array min tmp fn main let mut array printlnThe initial array is array selectionsort mut array println The sorted array is array Cargo command RUSTCWRAPPERmirai MIRAILOGinfo cargo check Expected Behavior Analysis should reach fixed point without divergence in the loop Actual Results T Z INFO miraicallbacks Processing input file examplesselectionsortsrcmainrs T Z INFO miraicallbacks storing summaries for examplesselectionsortsrcmainrs at UsersrashmimudduluruMIRAItargetdebugdepssummarystoresled T Z INFO miraicallbacks outer fixed point iteration T Z INFO miraicallbacks analyzingselectionsortselectionsort T Z INFO miraisummaries Summary store has no entry for coresliceimplementleni T Z WARN miraivisitors fixed point loop diverged in body of selectionsortselectionsort T Z WARN miraivisitors Fixed point loop took iterations for selectionsortselectionsort T Z INFO miraicallbacks analyzingselectionsortmain T Z INFO miraicallbacks T Z INFO miraicallbacks outer fixed point iteration T Z INFO miraicallbacks reanalyzingselectionsortselectionsort T Z INFO miraisummaries Summary store has no entry for coresliceimplementleni T Z WARN miraivisitors fixed point loop diverged in body of selectionsortselectionsort T Z WARN miraivisitors Fixed point loop took iterations for selectionsortselectionsort T Z INFO miraicallbacks reanalyzingselectionsortmain Environment Rust version rustc version rustc nightly fe b AbstractDomainimplies and AbstracDomainimpliesnot use algebraic rules to attempt to figure out at compile time what the values of x y and x y are The rule is that false is also the way to say I dont know These implications are used to eliminate paths and to simplify conditional expressions Only a few rules are currently used Here are some more rules that Ive previously used in another project Better check them with theorem prover for there may transcription errors Note that the rules are recursive and may have exponential complexity unless depth limited x x x y z if x z y z x y z if x z y z x y if x y c true false c c false y false z if y z since c false y is false unless y is true z is true if y is true c false y z false if y z since c false y is false unless y is true z is true if y is true c x false false z if x z since c x false is false unless x is true and z is true if x is true c x false z false if x z since c x false is false unless x is true and z is true if x is true c x false z if c z x z false x x x false x x x not type correct but might happen x x not type correct but might happen x x x y z if x z y z x y z if x z y z x y if x y x y if y x x y if y x since if y is false x can be any value and if y is true then x must be true c false true c c false y z false if y z since z false is true if y is true c false y false z if y z since false z is true if y is true c x false z false if x z since z false is true if x is true c x false false z if x z since false z is true if x is true c x false z if c z x z x y y z x z x y x z y z Issue Running MIRAI over an entire crate every time it the crate is rebuilt is somewhat painful since every function body is reanalyzed at least once An alternative way to is to run MIRAI as part of the linter see and It seems that the linter will only call the MIRAI plugin when a function has changed so the it should be sufficient to invoke the checker in the same way as will be done by Issue Currently a set of constants in checkersrcklimitsrs provides limits on how much computation MIRAI will do in various places With these limits in place largish crates can be analyzed in a somewhat reasonable time frame The limits do however impact on precision and may lead to false negatives By making these into variables that can be set via command line options it will become possible to schedule longer runs that may find more issues than more limited runs The greater precision allowed by such runs can also be used to weed out false positives The recommended way to complete this task is to turn the constants in klimits into the fields of a struct and to provide a constructor that sets the fields to default values along with a command line processor that updates the values from options in the command line The limits struct should then be made part of the visitor state checkersrcvisitorrs Ideally there should also be a way to set these options to non default values for integration test cases See also Issue We need more issues Create some meta issues to spur the creation of more issues Steps to Reproduce Look at the issues tab Expected Behavior There should be more issues and meta issues Actual Results Not enough issues Issue Some parts of the MIRAI code base are not covered by integration tests You task here is to find such bits of code and to create an issue for each of them Ideally follow up with a PR that contains a test case that covers that bit of code Steps to Reproduce As you read through the code base to get to know it click on the coverage button so see code coverage The code coverage tools is not quite perfect so you might see lines that are marked as not covered when they obviously are but there will be some cases that are not obviously covered You can verify that a line of code is not covered by setting a break point on it and running the integration tests from the debugger If you are going to follow up with a PR to fix this omission the next step would be to set some breakpoints in the surrounding covered code to find the test cases that reach then and then try to mutate one or more of those test cases to instead or also reach the uncovered code Expected Behavior Every executable source line should be reached by an integration test case Actual Results Some code lines are not so covered 