 What happens Gatling throws error and closes connection on response from server instead of simply following the redirect as expected ERROR ighasSseListener unexpected state closed with error message ighasSseException Server returned http response with code This is a full blocker for testing server sent events connections SSE should behave the same way to HTTP requests in that the default behavior should be to follow redirects not throw Can you help me How can I resolve this GATLINGHOME is set to Userssevenlmworkspacegatlinggatlingchartshighchartsbundle BasicSimulation is the only simulation executing it Select run description optional ERROR igaGatling Run crashed javalangNullPointerException null at iogatlingappSelectionSelectoraskRunDescriptionSelectionscala at iogatlingappSelectionSelectoranonfunselection Selectionscala at scalaOptiongetOrElseOptionscala at iogatlingappSelectionSelectorselectionSelectionscala at iogatlingappSelectionapplySelectionscala at iogatlingappRunnerrun Runnerscala at iogatlingappRunnerrunRunnerscala at iogatlingappGatlingstartGatlingscala at iogatlingappGatlingfromArgsGatlingscala at iogatlingappGatlingmainGatlingscala at iogatlingappGatlingmainGatlingscala I mean something like this assertions globalrequestPerSectarget deviation inclusivetrue where target is target intensity and deviation is deviation in percent Silencing is currently supported only for HTTP requests It would be great to have it also for websockets In the following example wscheckpollupdate timeouts multiple times which is correct bc we need to send client pings however its reported as an error plus it adds the wait time to the response time so it breaks lot of time statistics as well val wsWaitForPollUpdate asLongAscapturedFeedbackIdvalidate Int isInstanceOf Failure execwswspingsendText await secondswscheckTextMessagewscheckpollupdate matchingsubstringpollupdate checksubstringeventuuiduuid checkregexfeedbackid saveAscapturedFeedbackId Its true that this is basically a workround to the missing feature described here but I think this feature could be useful even in other use cases Relevant mailing list threads I am trying to use gatling to test an SSE endpoint that represents an update stream To properly test this I want to open the SSE stream issue a normal HTTP request that triggers an update then check that the SSE client has received the update event My code looks something like this scala execopenSseStream exectriggerUpdate execcheckUpdateInSseStream My problem is that if the update message is sent to the SSE client very quickly it might already be consumed and ignored by the time the check is activated I can think of three possible ways to solve this make the check nonblocking so I can activate the check before I trigger the update add an API to specify an ActionBuilder with the setCheck so that the action will be executed after the check is set up but before it blocks further execution add an option to buffer incoming SSE messages while no check is active and replay them as soon as a check is set up If necessary I can build a sample application that demonstrates the problem but I hope its already clear from the explanation It would be nice to pass multiple actions to a checkIf method the same way as a check allows through the comma So for example instead of writing this check checkIffirstexistsdofirst checkIffirstexistsdosecond checkIffirstexistsdothird it would be nice to have API as follows checkcheckIffirstexistsdofirstdosecond dothird As of Gatling as explained in the documentation Setting a smaller number of concurrent users won t force existing users to abort The only way for users to terminate is to complete their scenario It might make sense to reconsider and abort users probably based on their age When useGroupDurationMetric is set to true the report displays the true duration of a group including pauses But response time assertion on groups only verifies on the cumulated response times excluding pauses the useGroupDurationMetricfalse way of displaying response times in the report Then useGroupDurationMetric is set to true the assertions should use the duration metrics to make it consistent Single Page application often perform multiple requests at the same time while viewing pages Right now the only way to simulate to behavior is to use the resources DSL element However if you do so youd end up silencing your precious API requests with silentResources Id see multiple ways to provide this ability A copy of the resources DSL that isnt silenced A fullfledged DSL element that enables users to have parallel workflows inside the simulation like we do with WebSockets Polling or SSE See for a previous query on this We have the following issue In our system graphql subscriptions messages are published with a regular http request whereas subscribed with websocket so websocket check does not need to send anything before it checks A case with check just after ws connection does not work either because we need to send http request between ws connection and ws check 