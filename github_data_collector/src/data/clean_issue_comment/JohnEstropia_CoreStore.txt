 I was using ListMonitor delegate to update the tables swift func listMonitorWillChange monitor ListMonitorKargoCD tableViewbeginUpdates func listMonitorDidChange monitor ListMonitorKargoCD let limit UserServicesharedInstanceuserTotalLimit let kargos StorageuserParcelslimitlimit WatchSessionManagersharedManagersendkargos kargos tableViewendUpdates func listMonitorDidRefetch monitor ListMonitorKargoCD tableViewreloadDataeffect roll func listMonitor monitor ListMonitorKargoCD didInsertObject object KargoCD toIndexPath indexPath IndexPath SpotlightDataManageraddToSpotlightobject tableViewinsertRowsat indexPath with automatic func listMonitor monitor ListMonitorKargoCD didMoveObject object KargoCD fromIndexPath IndexPath toIndexPath IndexPath tableViewdeleteRowsat fromIndexPath with automatic tableViewinsertRowsat toIndexPath with automatic func listMonitor monitor ListMonitorKargoCD didUpdateObject object KargoCD atIndexPath indexPath IndexPath if let cell tableViewcellForRowat indexPath as KargoListCell configurecell with object SpotlightDataManageraddToSpotlightobject func listMonitor monitor ListMonitorKargoCD didDeleteObject object KargoCD fromIndexPath indexPath IndexPath SpotlightDataManagerremoveFromSpotlightidentifier objecttrackingID tableViewdeleteRowsat indexPath with automatic Starting with iOS I started to get following warning on the console When I put a symbolic breakpoint as the warning says I see that its generated in didInsertObject delegate call TableView Warning once only UITableView was told to layout its visible cells and other contents without being in the view hierarchy the table view or one of its superviews has not been added to a window This may cause bugs by forcing views inside the table view to load and perform layout without accurate information eg table view bounds trait collection layout margins safe area insets etc and will also cause unnecessary performance overhead due to extra layout passes Make a symbolic breakpoint at UITableViewAlertForLayoutOutsideViewHierarchy to catch this in the debugger and see what caused this to occur so you can avoid this action altogether if possible or defer it until the table view has been added to a window Table view UITableView x e frame clipsToBounds YES autoresize RMBM gestureRecognizers NSArray x ed f layer CALayer x a contentOffset contentSize adjustedContentInset dataSource AppMyList x dd In a future update these CoreStoreObject properties ValueRequired ValueOptional TransformableRequired TransformableOptional RelationshipToOne RelationshipToManyOrdered RelationshipToManyUnordered will be deprecated in favor of these propertyWrapper implementations FieldStored replacement for ValueRequired andValueOptional FieldComputed new equivalent to transient versions of ValueRequired andValueOptional FieldCoded replacement for TransformableRequired andTransformableOptional with additional support for custom encoders such as JSON FieldIdentifier new FieldToOne replacement for RelationshipToOne FieldToManyOrdered replacement for RelationshipToManyOrdered FieldToManyUnordered replacement for RelationshipToManyUnordered Field types that are marked above as replacements will be able to migrate directly from their old counterparts So if you have a property declared now as swift let title ValueOptionalStringtitle initial Mr you can directly convert it to swift FieldStoredtitle var title String Mr when you are ready They will be effectively equal to Core Data and your VersionLocks will remain intact Note that this effectively forces you to use a different syntax for queries which is a lot intuitive than the current Before FromPersonwhere title Mr After FromPersonwhere title Mr Also a couple of Pros The propertyWrapper versions will be magnitudes performant and efficient than their current implementations Currently Mirror reflection is used a lot to inject the NSManagedObject reference into the properties With propertyWrappers this will be synthesized by the compiler for us See The propertyWrapper versions being structs will give the compiler a lot more room for optimizations which were not possible before due to the need for mutable classes The only Con will be You need to update your code by hand to migrate to the new propertyWrappers But the legacy ones will remain available for quite a while so no need to panic Post implementation ideas Blob support background fetched Compound keys Traits ReadOnly etc I will try to save records with type Here is model import UIKit import CoreData class WindEntity NSManagedObject NSManaged var windidString NSManaged var latitudeDouble NSManaged var longitudeDouble func setInitialValues selflatitude Doublearc randomuniform selflongitude Doublearc randomuniform selfwindid NSUUIDuuidStringlowercased var coordinate CLLocationCoordinate D get return CLLocationCoordinate DMake selflatitude selflongitude set selflatitude newValuelatitude selflongitude newValuelongitude Save code class DBManager NSObject static let sharedManager DBManager let dataStack DataStackxcodeModelName Hunt private override init superinit let migrationProgress dataStackaddStorage SQLiteStore fileName Huntsqlite configuration Default localStorageOptions recreateStoreOnModelMismatch optional Provides settings that tells the DataStack how to setup the persistent store completion result Void in switch result case successlet storage printSuccessfully added sqlite store storage case failurelet error printFailed adding sqlite store with error error CoreStoreDefaultsdataStack dataStack func saveWindModelweatherWeatherModel dataStackperform asynchronous transaction Void in let wind transactioncreateIntoWindEntity windsetInitialValues windcoordinate weatherlocationcoordinate printwind wind isUpdated windisUpdated completion result Void in switch result case success let people try selfdataStackfetchAllFromWindEntity printpeople people case failurelet error printerror After saving I will try to fetch items and have data fault wind HuntWindEntity x f d entity WindEntity id x f c xcoredataE BACA A C A WindEntitytC C F CF E B C B CFDD data latitude longitude windid f d d a f af a eaaf isUpdated false people HuntWindEntity x f c entity WindEntity id x fe c e b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f ca entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cdc entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cd entity WindEntity id x fe c a b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cbe entity WindEntity id x fe c e b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f ceb entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cf entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cf entity WindEntity id x fe c a b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cfa entity WindEntity id x fe c e b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f cff entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c a b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d e entity WindEntity id x fe c e b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d d entity WindEntity id x fe c a b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c e b xcoredataE BACA A C A WindEntityp data fault HuntWindEntity x f d entity WindEntity id x fe c b xcoredataE BACA A C A WindEntityp data fault What I do wrong We are experiencing this crash would love your help to figure out whats going on Crashed Updater libobjcAdylib x fb fb objcmsgSend CoreData x d dd PFFaultHandlerLookupRow CoreData x d ac PFFulfillDeferredFault CoreData x d d pvfkheader CoreData x d b sharedIMPLpvfkcoreq CoreData x d e generateAccessorblockinvoke Here is what we are doing dataStackperformasynchronous transaction in let objects try transactionfetchAll backgroundQueueasync URLSessionshareddataTask dataStackperformasynchronous transaction in let item try transactionfetchOne update item fetched object completion in completion result in Thanks for your help Hi Team Can I use the code below to get objects from my background queue and using those objects within the main queue Because sometimes I got some crash EXEBADACCESS when reading object properties img width altScreen Shot at PM src Im changing local data and they arent updating I have to kill app and after opening again they are updated dataStackperform asynchronous transaction Void in let newOffline transactioncreateIntoCDOffline newOfflinesetValuesdata data let stored transactionfetchOne FromCDUserData where id Int id if let local stored localused newOfflineused completion result Void in completion Im using async callbacks and after completion needs to be updated func userDataid Int UserData let storedUserData selfdataStackfetchOne FromCDUserData where id Int id return storedUserDatamap UserDatafromCoreData the last func doesnt getting updated local datas PS In SquelLite browser shows changed data if YES post a or if NO post a or If you answered YES please do share a short comment on particular usecases you need them for I am considering deprecating the ObjectiveC API if there is not much use for it Your feedback is appreciated Would it be possible to rename LogLevel to something like CoreStoreLogLevel to avoid conflicts with other libraries Can you please comment on this question I have prepared workaround by getting values from list monitor but not sure if its correct I would like to call fetchAll after listMonitorDidChange actually when core data records are updated func listMonitorDidChange monitor ListMonitorExerciseEntity var exerciseFromMonitor ExerciseEntity for index in monitornumberOfObjects exerciseFromMonitorappendmonitor index printexerciseFromMonitor if exerciseFromMonitorcount updateDatawith routinesFromMonitor 