 I have a UIKit app where I am starting to integrate a bit of SwiftUI into via UIHostingController My SwiftUI views need to use Combine State or ObservedObjectPublished for example but Id still like these views to work with my existing ReactiveKit Signals Is this possible without writing a bunch of boilerplate code Has anyone else tried to make ReactiveKit and Combine work together in one app The shared verb between this method and Disposabledispose makes them appear extremely similar in behaviour I suggest RxSwifts disposedby When I make PRs for ReactiveKit Ive tried to add unit tests but Ive been having a difficult time There is a lot of interesting test helper utilities youve created to make your unit tests easier to write but its difficult to understand what its doing or how to use it Writing some documentation and maybe a simple usage guide would be really helpful I know this is a pretty low priority issue but its definitely something thats been a pain point for me Ive tried digging into it a little bit but still havent been able to really figure out how to write tests for ReactiveKit Note This isnt about writing unit tests for my personal code that uses ReactiveKit this is about writing tests for the actual ReactiveKit code base when I make PRs for this library Same goes for Bond First of all my apologies if architectural questions are not supposed to be asked in the issue tracker but I couldnt find a satisfying answer anywhere else In my particular case I have the following two ViewModels I selected a certain day here in a week class DayViewModel BaseViewModel let selectedDay PropertyDate func switchedto dayNumber Int selectedDayvalue selectedDayvaluedayInSameWeekfor dayNumber I generate an overview on the home screen depending on which day is selected class HomeViewModel BaseViewModel LogsContainingViewModel snip let selectedDay PropertyDate snip Im wondering whats the best approach I could either monitor that property like this daysViewModelselectedDayobserveNext unowned self newDate in selfviewModelselectedDayvalue newDate disposein disposeBag Or I pass in the property when I construct the DayViewModel let daysViewModel DaysViewModelselectedDay selfhomeViewModelselectedDay On one hand I think having less state is always better on the other hand the properties might have different lifecycles and I can also imagine the same property shared over multiple view models could cause more problems with threading etcetera Please show any example of how to use operator repeatwhen I dont understand how to use it I did a pod update to latest Bond for my project which currently has support for Swift and XCode I got compilation error all are related to ReactiveKit One of the compilation error saysPodsReactiveKitSourcesSignalProtocolOptionalswift Generic parameter Element could not be inferred Please help me to fix this issue Reactive Kit got updated a few days ago to version Bond Version began pulling that version of the library even though its only compatible with Swift Workaround I had to manual go into the cocoa pods podsec file and set the Reactive Kit version and checksum to a version below Reactive Kit to avoid build errors since we have not upgraded to Swift yet Minor version bump should not contain breaking changes as Reactive Kit contains breaking changes for bond version Description I am trying to map a collection of events from a datastore to a list of choices in a different datastore made by a user for some all of the events in that collection The collection of events is stored in a LoadingProperty Something like public let events LoadingProperty Event ApplicationError events LoadingProperty some HTTP request that retrieves an array of events from a remote server toLoadingSignal I will display those events in a UITableView with custom cells that show whether or not the user will attend In order to provide a mutable observable array to bind that table to I have to issue a request for every event to check if the user has already made some selection I know not the best solution but thats what I am dealing with for now So I am building that MutableObservableArray from the events property Everytime it gets refreshed then the mapping is established again and the table is updated accordingly public let eventsArray MutableObservableArrayMappingScheduleChoice MutableObservableArray events dematerializeLoadingState suppressErrorlogging true withlatestFrom userServicecurrentUservalue map arg Event User in let evts user arg return evtsmap user unwrap flatMapconcat arg SignalMappingScheduleChoice ApplicationError in let evt user arg return evt getEventSelectionfor userlocalId responseusing client map first map MappingScheduleChoiceschedule evt choice collect observeNext state in selfeventsArrayreplacewith state disposein bag Problem The main issue is that dematerializeLoadingState never really completes just reloads and therefore collect can never issue a new array via next that would be used to build the MutableObservableArray If I add takefirst right before collect then the first events will show up in the table with the proper user choices as intended but just for those events Id like to achieve this for all the events present in the events property Now this seems like a very very complicated solution and I am happy to hear other suggestions on how to achieve the intended result But otherwise any nifty little trick I have forgotten about that could make this work thanks N I am wrapping my network requests into signals like this func requestResponse endpoint EndpointResponse SignalResponse ResponseError return SignalResponse ResponseError observer in let request selfmanagerrequest selfurlpath endpointpath method httpMethodfrom endpointmethod parameters endpointparameters encoding endpointencoding request validate responseData response in let result responseresultflatMapendpointdecode switch result case successlet value observernextvalue observercompleted case failurelet error observerfailedResponseErrorreason errorlocalizedDescription statusCode responseresponsestatusCode return BlockDisposable requestcancel The issue I am having is that when I am observing this signal the callback is triggered twice next with value and completed I dont want it to be called twice because obviously I am executing code to update the UI inside the callback Sometimes the value is null for some requests I expect with empty response so I cannot check the value If I dont call completed after next the issue disappears but I not sure if it would cause a memory issue because the signal is being disposed in the case of a failed or completed event as seen here public func on event EventElement Error locklock defer lockunlock guard disposableisDisposed else return if let observer observer observerevent if eventisTerminal disposabledispose Any suggestions