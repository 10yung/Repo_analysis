 Uses refPrefix when using patchfrom mode Fills ldm tables when using patchFrom mode Forces dictBuffer to be freed only after compression ends because of refPrefix Forces singlethread when using patchfrom multithreaded support planned in future pr Forces long when using patchfrom on dictionaries larger than mb zstd is available as a port in VCPKG documenting the install process here will help users get started by providing a single set of commands to build zstd ready to be included in their projects VCPKG is a C library manager that simplifies installation for zstd and other project dependencies we also test whether our library ports build in various configurations dynamic static on various platforms OSX Linux Windows x x UWP ARM to keep a wide coverage for users Im a maintainer for vcpkg and here is what the port script looks like We try to keep the library maintained as close as possible to the original library I am looking into improving the compression of a messaging system Due to data concerns is there a way to train a dictionary while in use I have looked through the manual and had a quick dig through the zdicth and it appears not Has anyone attempted or done something like this What would be needed to implement this Is it unfeasible due to how the compression works In preparation for new dictionary search structure I dont think I nee to refactor opt since there is only one place where dictionary searching happens Memory is allocated but at the end of function never free it Platform Windows Visual Studio Intel Compiler Result Some streams blowup on decompress Cause Incorrect results leading to a blowup are created by bitstreamh when doing an optimized compile MEMSTATIC unsigned BIThighbit U val assertval if definedMSCVER Visual unsigned long r BitScanReverse r val return unsigned r BitScanReverse returns success or failure The Microsoft definition is successreturn BOOLEAN BitScanReverse out DWORD Index in DWORD Mask The Zstd code assumed that r will be left at zero when the success if false However I dont think the intrinsic is defined that way The r value is likely undefined on failure Certainly the Intel Compiler is making this assumption during its optimization at level O O or below dont have the bug This could be an Intel Compiler bug but it is more likely a bug in the zstd code assuming that r has a valid value on failure This code stops giving the wrong value when changed to MEMSTATIC unsigned BIThighbit U val assertval if definedMSCVER Visual unsigned long r return BitScanReverse r val unsignedr The following Microsoft Intrinsics are used on zstd BitScanForward BitScanReverse BitScanForward BitScanReverse All of these calls will potentially be affected by this bug and all cased should be fixed Summary I would like to produce a diff file quickly of the changes from some binary file A to B where B is a changed version of A i managed to do this with zstd but see below What I tried section It could be said from my naive viewpoint that finding differences between files is somewhat the domain of dictionarybased compression programs So why reinvent the wheel and create yet another new software Reasoning For starters there currently seems to be a lack of standalone utilities that do this All of them seem to be tied to something else Be it zsync unmaintained as far as I see being tied to urls and http bsdiff taking nearly seconds to generate the diff file whereas zstd does this in under a second Then bigger tools such as casync require allornothing adoption of their way of doing things Secondly most Linux distros provide package updates as a totally new filestobedownloaded There are major bandwidth and monetary savings that could be had here if an efficient and easy stand alone binary diff could be had And again since zstd needs to find repetitions and their positions in files exposing functionality that supports using all of this to produce and use diff files or at least stapling this functionality to public api could be a good fit here What I tried I managed to use zstd to produce a very small diff file of changes from binary file A to B with very fast creation time less than sec of around KB for both test cases simple and complex This small diff file was then given to zstd as thefiletobedecompressed and the original binary file A was given to zstd to use as dictionary This procedure was able to reproduce the binary file B detailssummary Click to show transcript of the commands used summary preparing the file thats being used in this experiment fish cp binqemusystemx bin splitting the binary file in two and showing that the when combined the splits are equal to the original fish split n d bin binsplit cat binsplit binsplit diff s bin devstdin Files bin and devstdin are identical putting second half of the file in place fish cat binsplit binsplit binrev cat binsplit bintailhalf listing current state of directory fish lf bin binsplit binsplit binrev bintailhalf test simple compressing decompressing and comparing using the original binary file as dictionary fish compressing zstd D bin long zstdldmHashRateLog chainLog vv f binrev o binrevbindictzstd zstd command line interface bits v by Yann Collet Loading bin as dictionary binrev bytes binrevbindictzstd binrev Completed in sec cpu load decompressing zstd D bin vv d o binrevbindictzstddecompressed binrevbindictzstd zstd command line interface bits v by Yann Collet Loading bin as dictionary binrevbindictzstd bytes comparing to original diff s binrev binrevbindictzstddecompressed Files binrev and binrevbindictzstddecompressed are identical test complex compressing decompressing and comparing using the original binary file as dictionary fish compressing zstd D bin long zstdldmHashRateLog chainLog vv f bintailhalf o bintailhalfbindictzstd zstd command line interface bits v by Yann Collet Loading bin as dictionary bintailhalf bytes bintailhalfbindictzstd bintailhalf Completed in sec cpu load decompressing zstd D bin vv d o bintailhalfbindictzstddecompressed bintailhalfbindictzstd zstd command line interface bits v by Yann Collet Loading bin as dictionary bintailhalfbindictzstd bytes comparing to original diff s bintailhalf bintailhalfbindictzstddecompressed Files bintailhalf and bintailhalfbindictzstddecompressed are identical listing current state of directory fish lf bin binsplit binsplit binrev bintailhalf bintailhalfbindictzstd bintailhalfbindictzstddecompressed binrevbindictzstd binrevbindictzstddecompressed details Question As can be witnessed I found that I can give to zstd any file to be used as a dictionary zstd happily ingests it even if the given dictionary file was not generated using the zstds own train argument Question Is this allowed Can I rely on zstd allowing me to do this in the future Question Would it be reasonable to expose this functionality via the API in some way so that the otherwise unnecessary parts whatever they are could be avoided Question Currently I ran against a wall when trying this procedure on files bigger than MB zstd refuses to use dictionaries bigger than thisdetailssummarythe errorsummary fish zstd command line interface bits v by Yann Collet Loading usrbindocker as dictionary zstd error Dictionary file usrbindocker is too large MB details Question Is this a necessity Could this check be removed from the source code without any ill effect thus allowing bigger binaries to be diffed This fixes the build for the current mesa master on my mulitlib Slackware system when ld is given usrliblibzstdso instead of usrlib libzstdzo For an example pkgconfig file see libpkgconfpcin from the pkgconf project Hello I tried to use zstd to compress log files which are continuously appended Execute bash binbash while true do echo line tmplogtxt done When I tried to compress in another session I were faced to this issue zstd compress stdout tmplogtxt tmplogtxtzst zstd error Read error Incomplete read B zstd t tmplogtxtzst tmplogtxtzst MB tmplogtxtzst Decoding error Corrupted block detected Note gzip handle this gzip stdout tmplogtxt tmplogtxtgz gzip tmplogtxt file size changed while zipping gzip v t tmplogtxtgz tmplogtxtgz OK Same for lz lz compress stdout tmplogtxt tmplogtxtlz lz t tmplogtxtlz tmplogtxtlz decoded bytes Regards Rather than do string comparisons to exclude devnull specifically it makes more sense to me to avoid all special files ie devices FIFOs symlinks sockets and directories This change does that although it finds that in most places that chmod chown are called from there are already UTILisRegularFile guards So I guess this is my proposal to amend to fix better