I havent been able to correctly pass in objects allocated in Java to methods that take a uniqueptr sink argument Im attaching a simple example that contains a very small interface and implementations of that interface in C and Java There is a C factory class with a factory method that returns instantiations of the C implementation as a uniqueptr There is a simple registry class that accepts a uniqueptr of that interface The registry moves the argument into a vector There is a Java test app that creates some of the C implementation objects using the factory method and adds them to the registry It then creates some Java implementation objects and passes them to the registry Once the add method returns it appears the underlying memory is freed as the element in the vector is no longer valid Note that this same thing happens if I manually allocate a C implementation without the factory method and pass it through How can I get uniqueptr semantics to work correctly when passing in an object that wasnt allocated as a uniqueptr from a C factory method Use buildsh to compile Use runsh to run example targz On some machines we are getting Error on Tesseract This occures when creating new instance of TessBaseAPI javautilconcurrentExecutionException javalangInternalError Should not get here at javautilconcurrentFutureTaskreportUnknown Source at javautilconcurrentFutureTaskgetUnknown Source at javaxswingSwingWorkergetUnknown Source at comimviewerworkerOCRTaskdoneOCRTaskjava at javaxswingSwingWorker runUnknown Source at javaxswingSwingWorkerDoSubmitAccumulativeRunnablerunUnknown Source at sunswingAccumulativeRunnablerunUnknown Source at javaxswingSwingWorkerDoSubmitAccumulativeRunnableactionPerformedUnknown Source at javaxswingTimerfireActionPerformedUnknown Source at javaxswingTimerDoPostEventrunUnknown Source at javaawteventInvocationEventdispatchUnknown Source at javaawtEventQueuedispatchEventImplUnknown Source at javaawtEventQueueaccess Unknown Source at javaawtEventQueue runUnknown Source at javaawtEventQueue runUnknown Source at javasecurityAccessControllerdoPrivilegedNative Method at javasecurityProtectionDomainJavaSecurityAccessImpldoIntersectionPrivilegeUnknown Source at javaawtEventQueuedispatchEventUnknown Source at javaawtEventDispatchThreadpumpOneEventForFiltersUnknown Source at javaawtEventDispatchThreadpumpEventsForFilterUnknown Source at javaawtEventDispatchThreadpumpEventsForHierarchyUnknown Source at javaawtEventDispatchThreadpumpEventsUnknown Source at javaawtEventDispatchThreadpumpEventsUnknown Source at javaawtEventDispatchThreadrunUnknown Source Caused by javalangInternalError Should not get here at sunniofsWindowsNativeDispatcherCreateSymbolicLink Native Method at sunniofsWindowsNativeDispatcherCreateSymbolicLinkUnknown Source at sunniofsWindowsFileSystemProvidercreateSymbolicLinkUnknown Source at javaniofileFilescreateSymbolicLinkUnknown Source at orgbytedecojavacppLoaderloadLibraryLoaderjava at orgbytedecojavacppLoaderloadLoaderjava at orgbytedecojavacppLoaderloadLoaderjava at orgbytedecotesseractglobaltesseractclinittesseractjava at javalangClassforName Native Method at javalangClassforNameUnknown Source at orgbytedecojavacppLoaderloadLoaderjava at orgbytedecojavacppLoaderloadLoaderjava at orgbytedecotesseractTessBaseAPIclinitTessBaseAPIjava at comimviewerworkerOCRTaskOCRCheckerinitOCRTaskjava at comimviewerworkerOCRTaskdoInBackgroundOCRTaskjava at javaxswingSwingWorker callUnknown Source at javautilconcurrentFutureTaskrunUnknown Source at javaxswingSwingWorkerrunUnknown Source at javautilconcurrentThreadPoolExecutorrunWorkerUnknown Source at javautilconcurrentThreadPoolExecutorWorkerrunUnknown Source at javalangThreadrunUnknown Source Motivation The main challenges here are of course the numerical ranges vs java types in terms of API for gettingsetting values uint isnt so bad as it fits in a long like UByteIndexer uses int However uint can clearly represent values larger than long Not sure what the best solution for uint is but some options are use long ignoring the overflow add a newcustom Number class uint stored as a long converted as required BigInt not exactly a low overhead solution however For example for this Java code Java NamespaceNativeLibrary Propertiesinherit orgexampleNativeLibraryConfigclass public class NativeClass extends Pointer static Loaderload Default native constructor public NativeClass superPointernull allocate private native void allocate Virtual public native StdString BytePointer getproperty Following C class is generated C class JavaCPPhidden JavaCPPNativeLibrary a aNativeClass public NativeLibraryNativeClass public jobject obj static jmethodID get property JavaCPPNativeLibrary a aNativeClass NativeLibraryNativeClass objNULL using NativeLibraryNativeClassgetproperty virtual stdbasicstring char getproperty stdbasicstring char supergetproperty return NativeLibraryNativeClassgetproperty Where JavaCPPNativeLibrary a aNativeClassgetproperty is C stdbasicstring char JavaCPPNativeLibrary a aNativeClassgetproperty Skip boring stuff Dangling reference return StringAdapter char rptr rsize rowner JavaCPPNativeLibrary a aNativeClassgetproperty should return by value not reference It also means that generated override actually overrides nothing since NativeLibraryNativeClassgetproperty returns by value I suspect that it is caused by StdStringjava having Caststdbasicstring annotation but Im not sure why it is there Im trying to create a opencv build off master with some custom flags however im getting errors like this when trying to compile What would be the cause of this Im not to familiar with javacpp yet so i really dont know where to start fixing this issue But to me it looks like I either need to map a CvBox D constructor with the float argument or create the missing converter somewhere What is your take on this homenetbraindevjavacpppresetsopencvtargetnativeorgbytedecoopencvlinuxx gpujniopencvcorecpp error no matching function for call to CvBox DCvBox Djfloat In file included from homenetbraindevjavacpppresetsopencvtargetnativeorgbytedecoopencvlinuxx gpujniopencvcorecpp homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note candidate CvBox DCvBox D typedef struct CvBox D homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note candidate expects arguments provided homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note candidate constexpr CvBox DCvBox Dconst CvBox D homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note no known conversion for argument from jfloat aka float to const CvBox D homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note candidate constexpr CvBox DCvBox DCvBox D homenetbraindevjavacpppresetsopencvcppbuildlinuxx gpuincludeopencv coretypesch note no known conversion for argument from jfloat aka float to CvBox D homenetbraindevjavacpppresetsopencvtargetnativeorgbytedecoopencvlinuxx gpujniopencvcorecpp In function void Javaorgbytedecoopencvopencv coreCvBox DallocateLjavanioFloatBuffer Lorgbytedecoopencvopencv coreCvSize D f FJNIEnv jobject jobject jobject jfloat I am trying to write a faiss index to a java output stream The writeindex method accept an IOWriter struct and write data using its operator The generated code contains a superoperator method that fails to compile Some kind of name escaping seems required for it to work c void writeindex const Index idx IOWriter writer c struct IOWriter name that can be used in error messages stdstring name fwrite virtual sizet operator const void ptr sizet size sizet nitems return a file number that can be memorymapped virtual int fileno virtual IOWriter java Namespacefaiss NoOffset PropertiesPlatform link faiss gomp preload faiss include faissimplioh public class IOWriter extends Pointer static Loaderload public IOWriter allocate private native void allocate Castsizet Nameoperator Virtualtrue public native long applyConst Pointer ptr Castsizet long size Castsizet long nitems c class JavaCPPhidden JavaCPPfaiss a aIOWriter public faissIOWriter public jobject obj static jmethodID applyLorgbytedecojavacppPointer JJ using faissIOWriteroperator virtual sizet operator const void arg sizet arg sizet arg sizet superoperator const void arg sizet arg sizet arg throw JavaCPPexceptionCannot call pure virtual function faissIOWriteroperator JavaCPPfaiss a aIOWriter faissIOWriter objNULL Here is my example code What I want do is generate class MyClass without generating BaseA BaseB and BaseC classes in java file MyClass have to inherit after classes Is it possible I assume that it is but I have to some special tricks in config file to handle it Thanks a lot for help Well this project is for C i know but Rust is becoming more popular It would be good for support binding Java Rust Rust can import C libs Maybe it wont be hard to do this Hi everyone The issue is the following I have to transfer ownership of an allocated data an array from C to Java How would I do that As a side note Ive tried to work something out with ArrayAllocator annotation but havent quite understood the idea of how it works I got a couple of NullPointerExceptions during my experiments that look like this javac cp javacppjarhomevasnikteljavacpptest testLibjava Generating homevasnikteljavacpptestjnijavacppcpp Generating homevasnikteljavacpptesttestjniLibcpp Warning Method public static native void testLiballocateArrayint cannot behave like a ArrayAllocator No code will be generated Exception in thread main javalangNullPointerException at orgbytedecojavacpptoolsGeneratormethodsGeneratorjava at orgbytedecojavacpptoolsGeneratorclassesGeneratorjava at orgbytedecojavacpptoolsGeneratorgenerateGeneratorjava at orgbytedecojavacpptoolsBuildergenerateAndCompileBuilderjava at orgbytedecojavacpptoolsBuilderbuildBuilderjava at orgbytedecojavacpptoolsBuildermainBuilderjava The question is how those annotations work and whether this exception is an intended behaviour Yes I know you already know but that was tagged on to the HDF stuff so proper bug report time Is there still a skip tests switch I wanna do presets hdf for you This is an ARMHF bit on a Raspberry Pi with stock OS a Debian Buster fork Of note is this which occurs right at the start possibly the problem Full log attached debugjcppzip WARNING An illegal reflective access operation has occurred WARNING Illegal reflective access by comgoogleinjectinternalcglibcoreReflectUtils fileusrsharemavenlibguicejar to method javalangClassLoaderdefineClassjavalangStringbyte intintjavasecurityProtectionDomain WARNING Please consider reporting this to the maintainers of comgoogleinjectinternalcglibcoreReflectUtils WARNING Use illegalaccesswarn to enable warnings of further illegal reflective access operations WARNING All illegal access operations will be denied in a future release 