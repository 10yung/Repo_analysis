Compilation speed could be reduced significantly with the addition of extern template declaration in nonheader mode Compilation times for the following snippet with cmake release build with extern template s without extern template s c include fmtformath namespace fmt extern template FMTAPI formatcontextiterator internalvformatto internalbufferchar stringview basicformatargsformatcontext all templates from fmtsrcformatcc int main fmtmemorybuffer b fmtformattob Hello world return fmt is now faster than doubleconversion and x faster than libc stdostringstream on floatingpoint formatting according to the dtoabenchmark but there is still a lot of room for improvement img width altScreen Shot at AM src gives some optimization ideas Floating numbers should have thousand separator with specifier n like python Python python from locale import setlocale LCALL setlocaleLCALL enUS enUS nformat nformat C cpp setlocaleLCALL enUS fmtformatn n gives As discussed in and elsewhere consider adding a locale modifier to floatingpoint format specs eg c auto s fmtformat Lf n s decimal point taken from locale Ive been trying out compiling format strings and run into a few issues when using custom types with examples at the end I know its still experimental get function fails to compile when using multiple type arguments in fmtcompile It should look like c Returns a reference to the argument at index N from first rest template int N typename T typename Args const auto getconst T first const Args rest staticassertN sizeofArgs if constexpr N return first else return getN rest In headeronly mode clashes with Type safety can be violated quite easily c constexpr auto f fmtcompiledoubleFMTSTRING n stdcout fmtformatf formattable Maybe the compiled format should contain template arguments that could later be used to enforce type safety at compile time but still allowing implicit conversions Format specifiers dont work with custom types c constexpr auto f fmtcompileformattableFMTSTRING n stdcout fmtformatf formattable crashes at runtime with terminate called after throwing an instance of fmtv formaterror what format specifier requires numeric argument Stack GIraise x fd ed GIabort x fd unknown x fd ab unknown x fd b b stdterminate x fd b cxathrow x fd b fmtv internalerrorhandleronerrorchar const clone cold x efd d fmtv internalnumericspecscheckerfmtv internalerrorhandlerrequirenumericargument formath fmtv internalcfvformattofmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr formattable fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr formattable fmtv basicformatargsfmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char compileh fmtv formatfmtv internalcompiledformatmainlambdastr formattable formattableconst fmtv internalcompiledformatmainlambdastr formattable const formattable compileh main maincpp libcstartmain x fd b b start x efd d ba Format parsing seems to be ignored stdcout fmtformatFMTSTRING n fails to compile while constexpr auto f fmtcompiledoubleFMTSTRING n compiles fine stdcout fmtformatf crashes at runtime with terminate called after throwing an instance of fmtv formaterror what invalid type specifier Stack GIraise x f e ed GIabort x f e unknown x f e dc unknown x f e e b stdterminate x f e e cxathrow x f e e fmtv floatspechandleronerror formath fmtv internalhandlefloattypespecfmtv floatspechandler formath fmtv internalbasicwriterfmtv bufferrangechar writedoubledouble true formath fmtv internalargformatterbasefmtv bufferrangechar fmtv internalerrorhandleroperatordouble formath fmtv visitformatargfmtv argformatterfmtv bufferrangechar fmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char coreh fmtv internalcfvformattofmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr double fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr double fmtv basicformatargsfmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char compileh fmtv formatfmtv internalcompiledformatmainlambdastr double doubleconst fmtv internalcompiledformatmainlambdastr double const double compileh main maincpp libcstartmain x f e b b start x b ba Custom format specifiers crash with SIGSEGV c constexpr auto f fmtcompileformattableFMTSTRING n stdcout fmtformatf formattable This is from when the argformatter tries to dereference nullptr Stack fmtv basicstringviewcharbegin coreh fmtv basicparsecontextchar fmtv internalerrorhandlerbegin coreh fmtv formatterformattable char voidparsefmtv basicparsecontextchar fmtv internalerrorhandler maincpp fmtv internalvaluefmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char formatcustomargformattable fmtv formatterformattable char void coreh fmtv basicformatargfmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char handleformat coreh fmtv argformatterfmtv bufferrangechar operator formath fmtv visitformatargfmtv argformatterfmtv bufferrangechar fmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char coreh fmtv internalcfvformattofmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr formattable fmtv bufferrangechar const fmtv internalcompiledformatmainlambdastr formattable fmtv basicformatargsfmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char compileh fmtv formatfmtv internalcompiledformatmainlambdastr formattable formattableconst fmtv internalcompiledformatmainlambdastr formattable const formattable compileh main maincpp libcstartmain x fe db b start x cc ba Longer custom format specifiers fail to compile but only if the compiled format is used in fmtformat or similar c constexpr auto f fmtcompileformattableFMTSTRINGN n stdcout fmtformatf formattable Compiler output In file included from maincpp usrlocalincludefmtcompileh In instantiation of const fmtv internalformatparttypename fmtv internalchartimplStype fmtv internalcompiledformatbaseS typename stdenableiffmtv iscompilestringSvalue voidtypeparts const fmtv internalcompiledformatbaseS typename stdenableiffmtv iscompilestringSvalue voidtypenumformatparts with S mainlambdastr typename stdenableiffmtv iscompilestringSvalue voidtype void fmtv internalcompiledformatbaseS typename stdenableiffmtv iscompilestringSvalue voidtypepartscontainer fmtv internalformatpartchar typename fmtv internalchartimplStype char usrlocalincludefmtcompileh required from typename Contextiterator fmtv internalcfvformattoRange CompiledFormat fmtv basicformatargsContext with Context fmtv basicformatcontextstdbackinsertiteratorfmtv internalbufferchar char Range fmtv bufferrangechar CompiledFormat const fmtv internalcompiledformatmainlambdastr formattable typename Contextiterator stdbackinsertiteratorfmtv internalbufferchar usrlocalincludefmtcompileh required from stdcxx basicstringChar fmtv formatconst CompiledFormat const Args with CompiledFormat fmtv internalcompiledformatmainlambdastr formattable Args formattable Char char typename stdenableifstdisbaseoffmtv internalbasiccompiledformat CompiledFormatvalue inttype anonymous maincpp required from here usrlocalincludefmtcompileh in constexpr expansion of fmtv internalcompiletopartschar fmtv tostringviewmainlambdastrmainlambdastrfmtv compilestring usrlocalincludefmtcompileh in constexpr expansion of fmtv internalcompileformatstringtrue char fmtv internalcompiletopartsfmtv basicstringviewChar with Char char unsigned int N unnamed struct formatstr collector usrlocalincludefmtcompileh in constexpr expansion of fmtv internalparseformatstringtrue char fmtv internalformatstringcompilerchar fmtv internalcompiletopartsfmtv basicstringviewChar with Char char unsigned int N unnamed struct formatstr fmtv internalformatstringcompilerchar fmtv internalcompiletopartsfmtv basicstringviewChar with Char char unsigned int N unnamed struct formatstr handler usrlocalincludefmtformath in constexpr expansion of handlerfmtv internalformatstringcompilerchar fmtv internalcompiletopartsfmtv basicstringviewChar with Char char unsigned int N unnamed struct onformatspecsp end usrlocalincludefmtcompileh error call to nonconstexpr function void fmtv internalerrorhandleronerrorconst char if it onerrormissing in format string Example source file compiled with GCC C c include fmtcompileh include fmtformath include iostream struct formattable int i FMTBEGINNAMESPACE template struct formatterformattable formatterint bool specialfalse template typename ParseContext constexpr auto parseParseContext ctx decltypectxbegin if ctxbegin special true ctxadvancetoctxbegin if ctxbegin N ctxadvancetoctxbegin return formatterintparsectx template typename FormatContext auto formatformattable f FormatContext ctx decltypectxout if special ctxout return formatterintformatfi ctx FMTENDNAMESPACE int main prints as expected stdcout fmtformatFMTSTRING n formattable prints as expected stdcout fmtformatFMTSTRING n formattable fails to compile because of get constexpr auto f fmtcompileformattable formattableFMTSTRING n stdcout fmtformatf formattable formattable prints violates type safety constexpr auto f fmtcompiledoubleFMTSTRING n stdcout fmtformatf formattable terminate called after throwing an instance of fmtv formaterror what format specifier requires numeric argument constexpr auto f fmtcompileformattableFMTSTRING n stdcout fmtformatf formattable dereferencing a nullptr fmtcompileh constexpr auto f fmtcompileformattableFMTSTRING n stdcout fmtformatf formattable fails to compile stdcout fmtformatFMTSTRING n compiles constexpr auto f fmtcompiledoubleFMTSTRING n stdcout fmtformatf crashes at compile time only if both lines are uncommented constexpr auto f fmtcompileformattableFMTSTRINGN n stdcout fmtformatf formattable return This will make fmt work with llfio From While I have you as the author of fmt can I persuade you to add support for raw gather buffer formatting to fmt Then one can do cool stuff like llfiofilehandle fh fhwriteoffset fmtoutSystem error code n errno Here out simply emits an iterable which iterates something smelling like spanconst byte I appreciate your print io function et al but we can go much lower level without programmer inconvenience Plus out works immediately with Networking LLFIO anything which consumes gather buffers etc no extra work Compile time validation of named arguments is currently disallowed That is a somewhat unfortunate restriction I havent dug into the internals of fmtlib enough to know whether this is due to the impossibility of making it work or due to an implementation challenge If the latter I think it is probably worth figuring out how to make it work Is there some background on why it is currently disallowed Any thoughts on whether an implementation is possible Currently the number and types but not values of formatting arguments has to be known at compile time Consider adding an API to allow fully dynamic construction of argument lists to support use cases like the one mentioned in I have a few use cases but they all boil down to wanting to externalize the format of whatever needs to be produced from the C code So for example a config file might have a format string in it and that format string wants to extract zero or more named values from some data dictionary in the program If you use unicode symbols as fill character for alignment you get runtime error for example for printu n i str there supposed to be outputs like this March March but there is runtime error missing in format string doesnt list public methods inherited from fmtinternalbasicbuffer Is it intentional and users are not supposed to call those methods