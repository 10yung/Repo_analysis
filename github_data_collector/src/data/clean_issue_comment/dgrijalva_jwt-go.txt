Its inconvenient to check it with strcmp instead of switch errtype jwtValidationError is the same for invalid signature as for any other like from custom Valid method It would be great if we could set it manually Thanks Is there any particular reason to have following logic duplicated func verifyAudaud string cmp string required bool bool func verifyIssiss string cmp string required bool bool If it is done just to be consistent and have helper function for each claim I would understand But still feels repetitive I think there can be a single function that does verifyStr is helper function to verify value of claims of string type func verifyStrstr string cmp string required bool bool if str return required if subtleConstantTimeCompare bytestr bytecmp return true return false Add native support for key rotation for ES HS RS and PS verifications In those SigningMethods Verify implementations also allow the key to be the type of the slice of the supported key type so that the caller can implement the KeyFunc to return all the accepted keys together to support key rotation While key rotation verification can be done on the callers side without this change this change provides better performance because When trying the next key the steps before actually using the key do not need to be performed again If a verification process failed for nonkey reasons for example because its already expired it saves the effort to try the next key It is December and this issue is still existing import errors os time githubcomdgrijalvajwtgo githubcomjinzhugorm CreateRefreshAndAccessToken creates a user access token and a jwt token func u User GenerateTokensuser modelsUser map string string error var err error apiKey osGetenvAPISECRET Set claims This is the information which frontend can use The backend can also decode the token and get admin etc claims jwtMapClaims claims authorized true claims userid userID claims isAdmin userIsAdmin claims isClient userIsClient claims isCustomer userIsCustomer claims email userEmail claims exp timeNowAddtimeHour Unix Token expires after hour token jwtNewWithClaimsjwtSigningMethodES claims create accesstoken accessToken err tokenSignedString byteapiKey if err nil return nil err rfClaims jwtMapClaims rfClaims sub rfClaims exp timeNowAddtimeHour Unix generate refresh token rfToken jwtNewWithClaimsjwtSigningMethodES rfClaims refreshToken err rfTokenSignedString byteapiKey if err nil return nil err return map string stringaccesstoken accessToken refreshtoken refreshToken nil I am still getting this and it is not descriptive enough I have tried this issue but the is no working solution link go get githubcomdgrijalvajwtgo go downloading githubcomdgrijalvajwtgo v incompatible verifying githubcomdgrijalvajwtgov incompatible githubcomdgrijalvajwtgov incompatible reading Gone ed sign and verify support Signedoffby BluBbmADe BluBbmADeusersnoreplygithubcom Signedoffby Vasiliy Tolstov vtolstovunistackorg Given the example CustomClaimsType for shouldnt the signature of ParseWithClaims specify a pointer to Claims like go func ParseWithClaimstokenString string claims Claims keyFunc Keyfunc Token error when I was attempting to use the method locally I was receiving an error json cannot unmarshal object into Go value of type jwtClaims because I was passing a nonpointer reference for claims On OSX I am generating my key file using sshkeygen t ecdsa b m PEM Then if I test it like this echo foo bar jwt key testecdsa alg ES sign jwt key testecdsapub verify Error Couldnt parse token key is of invalid type Looking at the code I believe this is because jwtgo is relying on pemDecode which is expecting header lines and sshkeygen m PEM only includes those for the private key However a I havent had trouble manually adding these lines and b I want something easy to tell my own users about how to generate these keys Do you have an example of how to property create the key pairs for EC I am trying to parse a RS encoded token tokenString from java it could be successfully decoded by public key in java using the following java code JwtsparsersetSigningKeypublicKeyparseClaimsJwsjwt However It could be verified by jwtSigningMethodRS Verify just as described in But not able to be jwtParse I tried to write more debug print messages inside the parse function and verified not even run into it tokenString eyJhbGciOiJSUzI NiIsInppcCI IkRFRiJ eNqqVkqtKFCyMjQ s Q sbA MtFRyk NTUot kxRslIKLbZQggn JeamAoUcfRz HxcXRWeze tr bFq Ui AAADwjBXD LT aq oXTgDoPkiV n QdSZPZI Z J MWQC aHK oXwcovEU dVbtB TF byuu qi J GUttODT k gCl DViuCOV gczwTcvKslotUvXzoJ wa QuujnjxLEE r p k tsv OIFSUZzDksJFYNPlJH eFG DROx TsOz az SujZi GGbTc SLgzFHPrHMrovRZ qLCw JrdtsLzBBI OQJgRYwV fQf O IsMkHtetjkN dKgUkJtRarNWOk rpTPppLypiLU J wrElLMh TzUVZW Fz cDHDDBACJgMmKQ pOFEDKvYZN dLCF GiTZV DbXhNxO lqT JUN a p z G WNRjblf qZeuYdQvkIsiKrCbSIE XeY gaBgkOzuEvzltMrpRmb Oox ibOfVT KBh Lvqsb XbQjCio CLE ViCLqoe AaRqlUyrk n BIGr IW dcw CEryEMIjsjVp mtPXamJzf kt Rf iRBqwv zP Plg ResXbmsFUgOflAUPcYmfLug W W ntcUlTHAKXrNfaJL QQiYAaDukGZHDytsOWTuuXw lVxjtXYi VbRAIjh aIYSELEmEpE Ny htQtywYXMQNfJpB nNn IiWakgcYYMJ TmKM token err jwtParsetokenString functoken jwtToken interface error fmtPrintlntoken parse start error handling if err nil logFatalerr It got error message as following invalid character x looking for beginning of value exit status I am curious if I can verify token signature how come not able to parse its header and claims body Or I missed anything before doing jwtParse Any comment is highly appreciated The VerifyExpiresAt function for Claims has incorrect or unclear documentation It states that it will compare the exp claim to cmp which is indicative of a comparison when in reality it does a cmp exp comparison