In version I found this code in class SingleProducerSequencer java if wrapPoint cachedGatingSequence cachedGatingSequence nextValue cursorsetVolatilenextValue StoreLoad fence long minSequence while wrapPoint minSequence UtilgetMinimumSequencegatingSequences nextValue waitStrategysignalAllWhenBlocking LockSupportparkNanos L TODO Use waitStrategy to spin thiscachedValue minSequence should setVolatile be necessary Does it mean that memory visibility cause the behind of the consumers As we know the class SingleProducerSequencer uses padded long variables to solve false sharing issue Then why doesnt the class MultiProducerSequencer use the same way to solve false sharing issue as class SingleProducerSequencer does Is it because there is no false sharing issue while using class MultiProducerSequencer or some other reason If I close a before the data production is completed it will cause infinite loop Here is my test code Slf j public class DisruptorSingleTest private static int len ConstantsEVENTNUMOM private static DisruptorData dataDisruptor public static void mainString args String name ManagementFactorygetRuntimeMXBeangetName Systemoutprintlnname int ringBufferSize dataDisruptor new Disruptornew EventFactoryData Override public Data newInstance return new Data ringBufferSize new ThreadFactory Override public Thread newThreadRunnable runnable return new Threadrunnable disruptorconsumerthread ProducerTypeSINGLE new YieldingWaitStrategy DataConsumer dataConsumer new DataConsumer EventHandlerGroupData dataEventHandlerGroup dataDisruptorhandleEventsWithdataConsumer RingBufferData start dataDisruptorstart new Threadnew Runnable Override public void run RingBufferData ringBuffer dataDisruptorgetRingBuffer for int i i len i long seq ringBuffernext Data data ringBuffergetseq datasetIdi datasetNamec i ringBufferpublishseq start dataDisruptorshutdown public static class DataConsumer implements EventHandlerData private long startTime private int i public DataConsumer thisstartTime SystemcurrentTimeMillis Override public void onEventData event long sequence boolean endOfBatch throws Exception i if endOfBatch long endTime SystemcurrentTimeMillis loginfoDisruptor constTime endTime startTime i The probable causes are as follows comlmaxdisruptorSingleProducerSequencernextint Im a noob of DisruptorI find the following code in the Disruptor getting started ExecutorService executorService new ThreadPoolExecutor IntegerMAXVALUE L TimeUnitSECONDS new SynchronousQueueRunnable int bufferSize LongEventFactory factory new LongEventFactory DisruptorLongEvent disruptor new DisruptorLongEventfactory bufferSize executorService Connect the handler RingBufferLongEvent ringBuffer disruptorgetRingBuffer ButI find others use this method RingBuffercreateSingleProducer to create RingBufferI dont know which is the best way and the difference between ADisruptor constructor and BRingBuffercreateSingleProducer Thank you This code is copy from my project and WorkProcessor Override public void decrConsumer int nextUnUsed getNextUsed if nextUnUsed RingBufferHandlerEvent ringBuffer disruptorgetRingBuffer WorkProcessor processor processors nextUnUsed AbstractSentinelHandler handler handlers nextUnUsed if processor null handler null Systemoutprintlnremove disruptor thread handler handler processor processor if processor null handler null problem in here processorhalt try handlerawaitShutdown catch InterruptedException e Systemoutprintlne ringBufferremoveGatingSequenceprocessorgetSequence processors nextUnUsed null handlers nextUnUsed null updateUseStatenextUnUsed NUUSED Override public void run if runningcompareAndSetfalse true throw new IllegalStateExceptionThread is already running sequenceBarrierclearAlert notifyStart boolean processedSequence true long cachedAvailableSequence LongMINVALUE long nextSequence sequenceget T event null while true try if previous sequence was processed fetch the next sequence and set that we have successfully processed the previous sequence typically this will be true this prevents the sequence getting too far forward if an exception is thrown from the WorkHandler if processedSequence processedSequence false do nextSequence workSequenceget L sequencesetnextSequence L while workSequencecompareAndSetnextSequence L nextSequence if cachedAvailableSequence nextSequence event ringBuffergetnextSequence workHandleronEventevent processedSequence true else problem in here cachedAvailableSequence sequenceBarrierwaitFornextSequence catch final TimeoutException e notifyTimeoutsequenceget catch final AlertException ex if runningget break catch final Throwable ex handle mark as processed unless the exception handler threw an exception exceptionHandlerhandleEventExceptionex nextSequence event processedSequence true notifyShutdown runningsetfalse After i use processorhalt to stop workProcess cachedAvailableSequence sequenceBarrierwaitFornextSequence throws an AlertException exception and the message of index nextSequence is lost How can I solve this problem Thank you can postion move to postion should be more available This is the first step in the process of modularizing the Disruptor JAR Adding AutomaticModuleName in the manifest file makes the library usable as a Java automatic module without moving the library itself to Java or later or creating a moduleinfojava This allows the Disruptor when loaded as an automatic module to get its name from the AutomaticModuleName entry in MANIFESTMF instead of being inferred from the filename This second option is dangerous as filenames are far from being unique and stable This post explains the point of having an AutomaticModuleName defined Maybe I misunderstand the TimeoutBlockingWaitStrategy meaning I thought TimeoutBlockingWaitStrategy will release the producer thread when the ringbuffer is full after waiting for a time period eg sec But now the behavior looks producer is waiting still When I debug the code I found the process is waiting on below code MultiProducerSequencer which you already have an comments on TODO do current cursorget next current n long wrapPoint next bufferSize long cachedGatingSequence gatingSequenceCacheget if wrapPoint cachedGatingSequence cachedGatingSequence current long gatingSequence UtilgetMinimumSequencegatingSequences current if wrapPoint gatingSequence LockSupportparkNanos TODO should we spin based on the wait strategy continue gatingSequenceCachesetgatingSequence else if cursorcompareAndSetcurrent next break while true So I am thinking is this code dont consider any waiting strategy we choose My intention is to not block producer threads even we can drop some messages if the ringbuffer is full But we hope to let waiting strategy to do so not to check ringbuffer size by ourselves and also need to maintain some timeout etc I am using JDK docker image Thanks I have the pattern whereby a number of events are produced by multiple threads I then need to transform these events and then dispatch them to a number of consumers The consumers need to be dynamically added and removed from the system at runtime I was thinking of using ring buffers We would receive the events on the first ringbuffer and have a single consumer which transforms them and places the transformed events on the second rindbuffer We would then have a number of consumers on the second ringbuffer that receive events I cant quite figure out how to dynamically add and remove consumers at runtime I have tried this java private final DisruptorLockAction outgoingDisruptor new DisruptorLockActionnew RINGBUFFERSIZE DaemonThreadFactoryINSTANCE private final RingBufferLockAction outgoingRingBuffer private final SequenceGroup outgoingSequenceGroup new SequenceGroup private final MapLockEventListener BatchEventProcessorLockAction outgoingListenersWithProcessors new NonBlockingHashMap thisoutgoingRingBuffer outgoingDisruptorstart public void registerListenerfinal LockEventListener lockEventListener final SequenceBarrier barrier outgoingRingBuffernewBarrier final EventHandlerLockAction handler event sequence endOfBatch lockEventListeneracceptevent final BatchEventProcessorLockAction processor new BatchEventProcessoroutgoingRingBuffer barrier handler processorgetSequencesetbarriergetCursor outgoingSequenceGroupaddprocessorgetSequence processorgetSequencesetoutgoingRingBuffergetCursor outgoingListenersWithProcessorsputlockEventListener processor processorrun notify the listener that it was registered lockEventListenerregistered public void deregisterListenerfinal LockEventListener lockEventListener final BatchEventProcessorLockAction processor outgoingListenersWithProcessorsremovelockEventListener processorhalt outgoingSequenceGroupremoveprocessorgetSequence notify the listener that it was deregistered lockEventListenerunregistered However when I call registerListener at runtime it always blocks on processorrun and never proceeds from there What am I doing wrong here