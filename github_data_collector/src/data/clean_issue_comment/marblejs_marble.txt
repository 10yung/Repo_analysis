Problem When using usemultipart I cant seem to expand the Observable with additional values beyond the multipart upload For example typescript const a rpipe rmatchPatha rmatchTypePOST ruseEffectRxpipe usemultipart Expanding the Observables with additional values RocombineLatestRxfrom Seems to only log once apparently the last value in above array Rotap upload n consolelogn Rocount Responds with Should be Romapbody status body I created a repository to reproduce the issue node v marblejscore next marblejsmiddlewarebody next marblejsmiddlewarecors next marblejsmiddlewareio next marblejsmiddlewarelogger next marblejsmiddlewaremultipart next rxjs Hi there I believe there is a bug createServer factory javascript eventserverEventSubjectpipetakeWhilee isCloseEvente server metadatasubscribe takeWhile takes a second argument inclusive setting it to true should allow server close callback to get called javascript eventserverEventSubjectpipetakeWhilee isCloseEvente true server metadatasubscribe thanks Marblejs v is right around the corner Before its official release I would like to introduce the incoming new features and potential API breaking changes This is a place for general discussion about all the changes their relevance and potential impact to your codebase Feel free to ask questions and propose improvements General overview of new features official support for TypeScript v official support for RxJS v official support for fpts v x simplified dependency injection via new useContext hook introducing new module marblejsmessaging for building Microservices for MVP version with support for AMQP RabbitMQ and Redis transport layers I expect more transport layers to be introduced after release Ill post another issue when needed or expect a surprise Incoming breaking changes Context API fpts x brought a major breaking change in its API see changelog It introduced changes that have a major impact to Context API eg Reader monad Whats new More explicit dependency binding Previous API wasnt so precise which could result to confusion eg when the dependency is lazilyeagerly evaluated Old way typescript eager bindToWsServerTokenwebsocketsServerrun lazy bindToWsServerTokenwebsocketsServer New way typescript eager bindEagerlyToWsServerTokenwebsocketsServer lazy bindToWsServerTokenwebsocketsServer bindLazilyToWsServerTokenwebsocketsServer Reader creation Old way typescript import reader from marblejscore const someService readermapctx New way typescript import reader from marblejscore import pipe from fptslibpipeable import map from fptslibReader const someService pipereader mapctx The release of fpts also had an impact to HTTP and WebSocket server creators Since the run method on Reader etc has been replaced with a thunk server creation also applied to this change Bootstrap thunks are promisified which means that they will return an instance only when started listening if not then will throw an error Old way typescript const server createServer serverrun New way typescript const server createServer await server Effect interface changes Currently Effect interface defines three arguments where the second one is used for accessing contextual client eg HttpResponse WebSocketClient etc Typicaly the second argument was not used very often Thats why in the next major version client parameter will be moved to context object which will result to reduced available number of parameters from to Old way typescript const foo WsEffect event client meta eventpipe matchEventFOO metaask context reader New way typescript const foo WsEffect event ctx eventpipe matchEventFOO ctxclient contextual client ctxask context reader This change also implies a much cleaner base Effect interface typescript interface EffectI O Client input ObservableI ctx EffectContextClient ObservableO interface EffectContextT U extends SchedulerLike SchedulerLike ask ContextProvider scheduler U client T With that change the last argument of Effect interface is no more called as EffectMetadata but rather as EffectContext When dealing with error or output Effect the developer had to use the attribute placed in the third effect argument eg const effect req client initiator error In the case of ErrorEffect the thrown error is passed to stream directly typescript const error HttpErrorEffectHttpError req reqpipe map req error In the case of OutputEffect the message initiator eg initial request is passed to stream directly typescript const output HttpOutputEffect out respipe map req res Nightly builds If you would like to take part in beta testing feel free to try out canary releases Ill try to inform here about new builds and changes that they introduce CC tstelzer Hi there Is there any way to known when a websocket clients connection is broken so that I can do a followup action eg update the database about the clients status I have used fpts in my project and that has a version of and I have used marblejsmiddlewarelogger to log my requests when I request my server that exited with the error below TypeError Option fromNullablemap is not a function in the file nodemodulesmarblejsmiddlewareloggerdistloggerutiljs Then I inspected your code that package also using fpts in the old style map getOrElse I dont know how to debug this And I hesitated to use other middlewares Because of other package also use that lib in the same manner Is your feature request related to a problem Please describe Hello I noticed that Marble is inspired by the Angular ecosystem In my everyday developer experience I really appreciate what the CLI tools bring to me It helps to quickly scaffold main building blocks and enforce consistency It could be really nice to have CLI tools for Marble Describe the solution youd like The angulardevkit and schematics can be a good fit to provide CLI functionality Describe alternatives youve considered After digging in other CLI tools it appeared to me that there is no strong alternative to the angulardevkit package I m a big fan of marblejs I ve been following it closely since the early releases and I love the simplicity of its design Has anyone proposed that marblejs expand to include messaging capabilities ie NATS grpc SQS etc The fact that it is lightweight and simple makes it a great candidate for microservices that rely on messaging I think NATS in particular could be a good fit Hi guys hand I want to implement jsonschemavalidator for marblejs Why Have written jsonschema validation middleware for my pet project and I wish to contribute to marblejs and thing that the solution can be useful for the marblejs community Why Joi middleware is not enough Joi looks pretty good but I need to generate swagger specs for my API So use the same schema for validation and documentation is a good idea in my opinion Internal realization In my project I use typescriptjsonschema for generation schema from typescript interfaces So I have custom logic for schema loading and not sure that such solution will be good for marble Implementation proposal I propose one of three ways implementation jsonschema validator for marble Use typescriptjsonschema API for generating schema from typescript types or interfaces The way is fully based on typescript interfaces or types So we have a simple described type and generate JSON schema in runtime when application start Then we keep generated schemas in memory and use for validation orand serving swagger specs if we need Prebuild schemas for validation This way is similar to previous but instead compiling JSON schema on the fly we will build schemas before and just read the schemas from files Pass JSON schema manually This way is simplest from this list Just pass JSON schema as a simple object and marble users should implement source yourself It will like as Joi middleware but instead passing Joi builder we will pass JSON schema object I think last way it preferred for marble such as not all users need the functionality for generation schemas and serving specs Questions What you guys think about implementing such middleware If you approve implementing the middleware which way you prefer Should I clarify something from the description above 