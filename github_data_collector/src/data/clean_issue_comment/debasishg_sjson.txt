Hi I have a case class case class User name Name gender String agestring This is a sample case class in some cases my json is incomplete like namesagargendarmale Now when I am trying to convert this json to case class using following code import sjsonjson val js JsValuefromStringjson val userObj fromjson User js Its giving me error Is there any way we can create case class objects from incomplete JSON netdebasishg sjson scalaVersion test code scala package test case class QueryJson timefrom Int timeto Int Int object Main import sjsonjson import DefaultProtocol import dispatchclassicjsonJsonParser import scalautilparsinginputCharSequenceReader implicit val QueryJsonFormat Format QueryJson asProduct timefrom timetoQueryJsonQueryJsonunapplyget def mainargs Array String val q QueryJson printlnJsonSerializationtojsonq val js JsonSerializationfromjson QueryJson JsonParsernew CharSequenceReader timefrom timeto null printlnjstimefrom printlnjstimeto sbt run result scalaMatchError null of class dispatchclassicjsonJsNull at sjsonjsonBasicTypesanon readsStandardTypesscala at sjsonjsonBasicTypesanon readsStandardTypesscala at sjsonjsonJsonSerializationfromjsonJsonSerializationscala at sjsonjsonGenericanon readsGenericscala at sjsonjsonJsonSerializationfromjsonJsonSerializationscala at testMainmainMainscala at testMainmainMainscala at sunreflectNativeMethodAccessorImplinvoke Native Method at sunreflectNativeMethodAccessorImplinvokeNativeMethodAccessorImpljava at sunreflectDelegatingMethodAccessorImplinvokeDelegatingMethodAccessorImpljava at javalangreflectMethodinvokeMethodjava I think thowing a RuntimeException will be better like what List and Seq do When dispatch got rebooted its json lib got removed So what would be the ideal upgrade path for json library behind sjson Looks like Dispatch Reboot supports json s native jackson and liftjson out of the box And apparently json snative is pretty much liftjson only without the problems of lift release cycle DoublePositiveInfinity DoubleNaN etc In my local branch Ive got scala implicit object DoubleFormat extends Format Double def writeso Double try JsValueapplyo catch we need InfinityNaN goodness case e NumberFormatException JsValueapplyotoString def readsjson JsValue json match case JsStringn ntoDouble case JsNumbern ndoubleValue case throw new RuntimeExceptionDouble or string expected Im not sure the wisdom of this but it works for me Hi there This is WhitespaceBot Im an opensource robot that removes trailing white space in your code and gives you a gitignore file if you didnt have one Why whitespace Whitespace is an eyesore for developers who use text editors with dark themes Its not a huge deal but its a bit annoying if you use Vim in a terminal Really Im just a proof of concept GitHubs V API allows robots to automatically improve open source projects and thats really cool Hopefully somebody maybe you will fork me and make me even more useful My owner is funding a bounty to anybody who can add security fixing features to me Ive only cleaned your most popular project and Ive added you to a list of users not to contact again so you wont get any more pull requests from me unless you ask If Im misbehaving please email my owner and tell him to turn me off If this is pull request is of no use to you please just ignore it Thanks WhiteSpacebot from Gunio Introspection of beans often lead to processing same metadata repeatedly eg List of Beans lead to processing of the bean metadata many times On Can this be improved with a cache implementation There is this project called Salat here on Github that is able to serialize case classes without any help from annotations Have a look Maybe this mechanism could be build into sjson Why not to use val field contextgetgetDeclaredFieldpropsgetnameget val fieldInnerType fieldgetGenericTypeasInstanceOf ParameterizedType getActualTypeArguments instead of val field contextgetgetDeclaredFieldpropsgetnameget val ann fieldgetAnnotationclassOf JSONTypeHint when determining types of elements in list field For example here Thanks Oleg Hi there First of all Id like to extend my gratitude to all contributors for providing this really useful library In addition I wanted to know whether itd be possible to offer users more control when serializing a type thats been annotated with BeanInfo Specifically itd be very helpful to provide a way to tell the serializer that one or more properties ought to be handled through custom logic For example scalareflectBeanInfo case class Response content String status Int uri javanetURI val r Responseturtles new javanetURI val j new StringsjsonjsonSerializerSJSONoutr The default behavior as I understand it is to recursively serialize each field in a uniform manner In the case of uri of type javanetURI the result will be a JSON object containing various properties like host port path and so on This behavior is useful and makes sense in the majority of cases However in a couple of specific places I need to override it For example Id like the URI to serialize as a JSON string instead of an object The logic to do this is trivial eg calling either toString or toASCIIString yet as far as I can tell from looking at JsBeanscala there is no way to specify it It looks like the options I have are to either a switch to JsValues b switch to one of the type classbased approaches or c use only primitive types for fields instead of more appropriate complex types For me option a is not adequate because it defeats the purpose altogether Furthermore option b seems too heavyweight when the current approach works so well in most cases with no intervention Thus Ive stuck with c so far Perhaps Im missing another way to do what I want Otherwise the following two ideas come to mind Introduce a new annotation or extend one of the existing ones to support custom serialization logic Use reflection to determine whether an object provides a suitable toJSON method or equivalent and if so invoke it during serialization instead of the default bean property handler Note that the two arent mutually exclusive In fact the annotation could be used to guide or disable the method invocation If there is interest in something like this I could work on a patch to provided the functionality though I should mention that Im new to Scala so it may take a few tries Thanks once again Regards Alvaro 