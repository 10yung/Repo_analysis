in my app sometimes there are some dead locks in redis javalangIllegalMonitorStateException attempt to unlock lock not locked by current thread by node id e d b b a e b d ac threadid at orgredissonRedissonLocklambdaunlockAsync RedissonLockjava at orgredissonmiscRedissonPromiselambdaonComplete RedissonPromisejava at ionettyutilconcurrentDefaultPromisenotifyListener DefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListeners DefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListenersNowDefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListenersDefaultPromisejava at ionettyutilconcurrentDefaultPromisesetValue DefaultPromisejava at ionettyutilconcurrentDefaultPromisesetSuccess DefaultPromisejava at ionettyutilconcurrentDefaultPromisetrySuccessDefaultPromisejava at orgredissonmiscRedissonPromisetrySuccessRedissonPromisejava at orgredissoncommandRedisExecutorhandleReferenceRedisExecutorjava at orgredissoncommandRedisExecutorhandleSuccessRedisExecutorjava at orgredissoncommandRedisExecutorhandleResultRedisExecutorjava at orgredissoncommandRedisExecutorcheckAttemptPromiseRedisExecutorjava at orgredissoncommandRedisExecutorlambdaexecute RedisExecutorjava at orgredissonmiscRedissonPromiselambdaonComplete RedissonPromisejava at ionettyutilconcurrentDefaultPromisenotifyListener DefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListeners DefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListenersNowDefaultPromisejava at ionettyutilconcurrentDefaultPromisenotifyListenersDefaultPromisejava at ionettyutilconcurrentDefaultPromisesetValue DefaultPromisejava at ionettyutilconcurrentDefaultPromisesetSuccess DefaultPromisejava at ionettyutilconcurrentDefaultPromisetrySuccessDefaultPromisejava at orgredissonmiscRedissonPromisetrySuccessRedissonPromisejava at orgredissonclienthandlerCommandDecodercompleteResponseCommandDecoderjava at orgredissonclienthandlerCommandDecoderhandleResultCommandDecoderjava at orgredissonclienthandlerCommandDecoderdecodeCommandDecoderjava at orgredissonclienthandlerCommandDecoderdecodeCommandCommandDecoderjava at orgredissonclienthandlerCommandDecoderdecodeCommandDecoderjava at orgredissonclienthandlerCommandDecoderdecodeCommandDecoderjava at ionettyhandlercodecByteToMessageDecoderdecodeRemovalReentryProtectionByteToMessageDecoderjava at ionettyhandlercodecReplayingDecodercallDecodeReplayingDecoderjava at ionettyhandlercodecByteToMessageDecoderchannelReadByteToMessageDecoderjava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextfireChannelReadAbstractChannelHandlerContextjava at ionettychannelDefaultChannelPipelineHeadContextchannelReadDefaultChannelPipelinejava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelAbstractChannelHandlerContextinvokeChannelReadAbstractChannelHandlerContextjava at ionettychannelDefaultChannelPipelinefireChannelReadDefaultChannelPipelinejava at ionettychannelnioAbstractNioByteChannelNioByteUnsafereadAbstractNioByteChanneljava at ionettychannelnioNioEventLoopprocessSelectedKeyNioEventLoopjava at ionettychannelnioNioEventLoopprocessSelectedKeysOptimizedNioEventLoopjava at ionettychannelnioNioEventLoopprocessSelectedKeysNioEventLoopjava at ionettychannelnioNioEventLooprunNioEventLoopjava at ionettyutilconcurrentSingleThreadEventExecutor runSingleThreadEventExecutorjava at ionettyutilinternalThreadExecutorMap runThreadExecutorMapjava at ionettyutilconcurrentFastThreadLocalRunnablerunFastThreadLocalRunnablejava at javalangThreadrunThreadjava We are interested in running Sentinel behind a L proxy terminating TLS This sentinel will report a master at IPmasterport This master is behind a second L proxy terminating TLS on a port we plan to infer from the reported masterport Ideally Redisson would offer Sentinel Master over TLS with the ability to configure a port mapping function to take masterport and translate it to the L proxy port terminating TLS in front of the master As an aside our model does not require us to translate either the sentinel or master IP but the Lettuce example below fully allows that Here is the equivalent Lettuce due out code package comexample import iolettucecoreRedisClient import iolettucecoreapiStatefulRedisConnection import iolettucecoreapisyncRedisCommands import iolettucecoreinternalHostAndPort import iolettucecoreresourceClientResources import iolettucecoreresourceDnsResolvers import iolettucecoreresourceMappingSocketAddressResolver import orgjunitTest public class TestApp Test public void testLettuceSentinel final MappingSocketAddressResolver portMapper MappingSocketAddressResolvercreateDnsResolversUNRESOLVED hostAndPort int port hostAndPortport switch port case port port break Systemoutprintfmapping s to sd n hostAndPorttoString hostAndPorthostText port return HostAndPortofhostAndPorthostText port final ClientResources clientResources ClientResourcesbuildersocketAddressResolverportMapperbuild final RedisClient redisClient RedisClientcreateclientResources redisssentinel mymaster try final StatefulRedisConnectionString String connection redisClientconnect Systemoutprintlnconnected final RedisCommandsString String redisCommands connectionsync redisCommandsclientSetnameblah final String result redisCommandssetfoo bar Systemoutprintfset foo results n result final String foo redisCommandsgetfoo Systemoutprintfget foos n foo redisClientshutdown Describe alternatives youve considered Many Including putting the sentinel master cluster behind an F load balancer terminating TLS and let the F choose the master Clients program to the F over plain Redis API over TLS RLock lockisHeldByCurrentThread verification before unlocking but sometimes exception orgredissonclientRedisException Unexpected exception while processing command at orgredissoncommandCommandAsyncServiceconvertExceptionCommandAsyncServicejava at orgredissoncommandCommandAsyncServicegetCommandAsyncServicejava at orgredissonRedissonObjectgetRedissonObjectjava at orgredissonRedissonLockisHeldByThreadRedissonLockjava at orgredissonRedissonLockisHeldByCurrentThreadRedissonLockjava Add a customizer interface that can be implemented by beans wishing to customize the RedissonClient auto configuration onsider Redisson PRO version for advanced features and support by SLA Might be connected to but I wasnt too sure about that so I decided to create a new issue instead Expected behavior No memory leak Actual behavior SentinelConnectionManager is leaking memory because it stores too many connections to the sentinels in the nodeConnections map We are using a singleton Redisson instance for connecting to our replicated Redis instance nodes sentinels After running for some days we are experiencing high GC times and OOM errors Upon investigating the heap dump we noticed that the SentinelConnectionManager stores nearly connection to the same sentinels in its nodeConnections map However the sentinels map itself only contains the expected entries img width altsentinelconnectionmanagerheap src I tried analyzing and reproducing the leak myself but I wasnt too successful since I am not familiar with your code Would be great if you could have a look what could cause such a behavior Unfortunately cant provide the heap dump since it might contain sensitive data Steps to reproduce or test case NA Redis version Redisson version Redisson configuration configuseSentinelServerssetMasterNamemymaster addSentinelAddressredisSentinelAddress setPassword setReadModeReadModeMASTER setSubscriptionModeSubscriptionModeMASTER setMasterConnectionPoolSize setRetryInterval setRetryAttempts setConnectTimeout setTimeout onsider Redisson PRO version for advanced features and support by SLA Expected behavior We are using Redisson with AWS elasticache redisson cluster Redisson client throws exception from some of the hosts Only way to recover is to reboot the EC instancesrestart the application Slaves are reachable from the EC Actual behavior Redisson client fails with the following exception eventhough slaves are reachable from EC Caused by orgredissonclientRedisConnectionException SlaveConnectionPool no available Redis entries Disconnected hosts at orgredissonconnectionpoolConnectionPoolgetConnectionPooljava Redisson xjar at orgredissonconnectionpoolSlaveConnectionPoolgetSlaveConnectionPooljava Redisson xjar at orgredissonconnectionbalancerLoadBalancerManagernextConnectionLoadBalancerManagerjava Redisson xjar at orgredissonconnectionMasterSlaveEntryconnectionReadOpMasterSlaveEntryjava Redisson xjar at orgredissonconnectionMasterSlaveConnectionManagerconnectionReadOpMasterSlaveConnectionManagerjava Redisson xjar at orgredissoncommandRedisExecutorgetConnectionRedisExecutorjava Redisson xjar at orgredissoncommandRedisExecutorexecuteRedisExecutorjava Redisson xjar at orgredissoncommandRedisExecutor runRedisExecutorjava Redisson xjar at ionettyutilHashedWheelTimerHashedWheelTimeoutexpireHashedWheelTimerjava nettycommon Finaljar at ionettyutilHashedWheelTimerHashedWheelBucketexpireTimeoutsHashedWheelTimerjava nettycommon Finaljar at ionettyutilHashedWheelTimerWorkerrunHashedWheelTimerjava nettycommon Finaljar at ionettyutilconcurrentFastThreadLocalRunnablerunFastThreadLocalRunnablejava nettycommon Finaljar Steps to reproduce or test case Exception happens very randomly in production Redis version Redisson version Redisson configuration configsetNettyThreads useClusterServers addNodeAddressredisUrl setTimeout setRetryInterval setMasterConnectionPoolSize setMasterConnectionMinimumIdleSize setSlaveConnectionPoolSize setSlaveConnectionMinimumIdleSize setPingConnectionInterval setKeepAlivetrue onsider Redisson PRO version for advanced features and support by SLA Use RDelayedQueue hit an bug The code is as below RBlockingQueueDelayJob blockingFairQueue redissonClientgetBlockingQueuetopicName RDelayedQueueDelayJob delayedQueue redissonClientgetDelayedQueueblockingFairQueue delayedQueueofferdelayJob TimeUnitSECONDS Expected behavior I expect the job can be executed after second Actual behavior In my prod environment I found almost all job is executed after second but only a few jobs were executed immediatelydo not delay seconds Steps to reproduce or test case It is hard to reproducde only a few jobs were executed immediately in each day Redis version redisversion Redisson version Redisson configuration In Spring Boot RedissonAutoConfiguration there is the need for post customizing the autoconfigured RedissonClient Would you consider a pull request with this functionality Is your feature request related to a problem Please describe Redission collection is used in my application single jar and want to package needed classes without all optional dependencies to reduce app size Describe the solution youd like Split feature optional dependencies are used as sub module Describe alternatives youve considered Remove all optional dependencies java classes from my jar Follow dependency document in wiki But I dont think it is right approach and whether have potential problems 