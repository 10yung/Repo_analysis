I feel like I must be overlooking something but I ran across this while writing some tests I tried whittling it down to find the breaking point some of these panic signal SIGSEGV invalid memory reference some dont rust Panic let i stdi MIN let Integernewi Panic let i stdi MIN stdu MAX as i let Integernewi Panic let i stdi MAX let Integernewi Panic let i stdi MAX let Integernewi Ok let i stdi MAX as i let Integernewi Panic let i stdi MIN as i pow let Integernewi Ok Looks like this is a threshold on the positive end let i stdi MIN as i pow let Integernewi Ok let i stdi MIN as i pow let Integernewi Panic looks like the here is where it fails at least on the negative end let i stdi MIN as i pow let Integernewi Ruby version ruby p revision x darwin Rust version rustc ea If this is a Ruby limitation only handling values in between and bit int types Im not sure what a reasonable solution would be but it at least seems worth documenting Hi there Im just getting my feet wet with RustRutie so its entirely possible that this patch is nonsensical Also Im not sure if I have put things in the right place etc Happy to make any changes you consider necessary First because Ruby has a different implementation of rbeql Ive added a bunch of cfg directives to buildrs so that functions can be defined conditional on the Ruby version This means that the faster iseql function is only used on Ruby Presumably I should document these somewhere but I havent done this The remaining changes are Objectequals is now a wrapper around the rbequal C function Objectiseql is now a wrapper around the rbeql C function on Ruby Objectisequal simply performs an comparison on the underlying values which is the same behaviour as the rbobjequal C function I need Integer to support u I saw somewhere that Integer is merged between Fixnum and Bignum So the only limitation seems to be the Rust API I can open a PR if you would like Tell me Thanks for the awesome project I have a bizarre issue and was hoping you might be able to shed some light on it I have a project that Id like to use the rouge syntax highlighter with so Im using rutie to interop with ruby In all my tests before integrating the code into my main project rutie rouge was working fine I VMinit and VMinitloadpath and then eval a small ruby file I wrote and use the class inside of it to interact with rouge and that all works However when I moved this code into my main project a most peculiar error occurs the title of this issue So in my main project I added the below to the very start of main rust rutieVMinit rutieVMinitloadpath eprintln rutieEncodingfindutf eprintln rutieEncodingfindascii bit eprintln rutieEncodingfindusascii Surprisingly utf and usascii both exist but ascii bit does not This appears to be an issue specifically with the way my binary is compiled as different ruby versions and different environments this is being run in a docker container but building running the binary on my actual computer results in the same produce the same error When I run that snippet above in a plain project with just a rutie dependency and no other code it works fine Note that running the binary in the docker container will exhibit the error but I can also start irb in the same container and verify that the ascii bit encoding works fine so Im pretty baffled Where the error occurs in the main project Where the error occurs in the interop crate Note that this error doesnt occur if you add a binary to this crate and run it It works as intended Is there something that could be happening during compilation or linking that could be screwing this up Thats all I can think at this point considering its just this binary that is afflicted and across platforms Maybe its something completely different Hopefully you have some input I havent thought of The Ruby C method rbprocnew was created to make Proc from C function This means we can also make a Proc from a Rust function The method signature is as follows in C c VALUE rbprocnewVALUE funcANYARGS VALUE yieldarg VALUE procarg VALUE val Which means the Rust representation may be one of the following rust pub fn rbprocnewfunc CallbackPtr val Value Value rust pub fn rbprocnewfunc extern fnValue OptionValue Value val Value Value I would like someone who has a more intimate knowledge of using FFI callback pointers in Rust to help create this and allow us to use Rust closures as Ruby procs The Windows test suite runs but many to most of the tests now time out in windows Even though a Ruby dependency libgmp dll is in the path the linker is having issues linking with it I have put forth my best efforts to making Rutie work for Windows If you have a better understanding of linkers and dependencies and would like to see full Windows support please help with this issue When choosing to compile with RUBYSTATIC flag the test for classvmVMinitloadpath fails When choosing to compile with RUBYSTATIC flag the test for classstringRStringisvalidencoding fails When choosing to compile with RUBYSTATIC flag the test for classstringRStringfrombytes fails Related issues ruru helix If we heap allocate a structbased helix object eg Durationnew GC runs It will GC the Ruby object associated with the helix object because the GC couldnt see the VALUE pointer on the stack 