The recommended way to accumulate items into an immutable collection shows examples using Guava Some libraries use AutoValue but dont want to force the user to use Guava because Guava is known to cause headaches when different libraries requireprovide different versions of Guava So it would be nice to have collection builders present directly in AutoValue like a ListBuilder a SetBuilder a MapBuilder Those builders would then return Collectionunmodifiablewrapped collections Kotlin has a nice singleton system thanks to kotlin objects it creates a class that works automatically as a singleton which from the perspective of Java looks like a class with a static field INSTANCE which contains the only instance of the class This is particularly helpful in the context of service loaders as it gives more control over the instance used as a service Unfortunately the way ServiceLoader works currently requires classes that can be instantiated using their default constructor which objects do not have But thanks to the magic of annotation processing this is actually fixable Without any processing this is what someone could write to make their object work with ServiceLoader kotlin interface MyInterface fun myMethod String object MyObject MyInterface override fun myMethod String hello AutoServiceMyInterfaceclass class MyObjectServiceLoaderProxy MyInterface by MyObject This uses the delegation mechanism also provided in Kotlin in short if you are implementing an interface using by anImplementationOfSaidInterface instances of the class will delegate the nonexplicitely implemented functions to anImplementationOfSaidInterface Note this does not work with abstract classes too bad but not the end of the world There now we can use ServiceLoader with objects we just need to tidy it up a bit having the annotation on the object and generating the class automatically should be doable and would provide all the benefits without requiring user intervention as long as the service is represented by an interface We can also give a non standard name to the class to avoid people using it by mistake after all this is only meant to be for the eyes of the ServiceLoader Thoughts eamonnmcmanus saturnism AutoFactory beta has a compilescoped dependency on AutoValue which adds the following annotation processors to classpath comgoogleautovalueextensionmemoizedMemoizedValidator comgoogleautovalueprocessorAutoAnnotationProcessor comgoogleautovalueprocessorAutoValueBuilderProcessor comgoogleautovalueprocessorAutoValueProcessor This is problematic for two reasons AutoValue doesnt support incap thus incap has to be disabled for the whole Gradle module Consumers of AutoFactory dont expect any additional APs besides AutoFactory itself cc ronshapiro I believe may be happening for AutoService as well I have these dependencies listed in my buildgradle implementation comgoogledaggerdagger implementation comgoogledaggerdaggerspi implementation comgoogleautoserviceautoservice rc annotationProcessor comgoogleautoserviceautoservice rc If I build with gradlew stop gradlew build then I dont see the error adding orggradledaemonfalse to gradleproperties also works Running gradlew build twice yields the following error gradlew build Task appcompileJava FAILED FAILURE Build failed with an exception What went wrong Execution failed for task appcompileJava javautilServiceConfigurationError daggerspiBindingGraphPlugin Error reading configuration file Try Run with stacktrace option to get the stack trace Run with info or debug option to get more log output Run with scan to get full insights Get more help at BUILD FAILED in s actionable tasks executed Fixes googleauto This change adds recursive validation for supertypes and superinterfaces to SuperficialValidation Consider the following example java TargetElementTypeTYPEUSE ElementTypeTYPEPARAMETER public interface TypeUseTest String value default java import comgoogleautovalueAutoValue AutoValue abstract class Animal abstract String name abstract int numberOfLegs static Builder builder return new AutoValueAnimalBuilder AutoValueBuilder abstract static class Builder abstract Builder setNameTypeUseTesthi String value abstract Builder setNumberOfLegsint value abstract Animal buildTypeUseTesthi bye Builder this In AutoValueAnimalBuilder I see the TypeUseTest annotation copied down to the implementation of setName But I do not see the TypeUseTest annotation on this copied down for the implementation of build This may be a bit of a corner case but it would be great if it were supported If the maintainers are interested and can point me roughly where the code should go I can look into opening a PR One of the things we did in Truth a while back was to print values differently if they contain newlines So for example you would see expected foo but was bar But youd see expected public class Foo Foo but was public class Bar Bar I would speculate but its just speculation that this might be a nice feature for AutoValue toString implementations too Even in the case in which fields arent multiline a multiline toString can be nice in some cases I think Truth has gotten reports that AutoValue toString like to be fair almost all toString implementations makes it hard to see which field differs when there are a lot of fields But of course oneline toString is nice in plenty of cases too so I wouldnt advocate for always going multiline nor probably for making it configurable Its just a nice additional advantage in the cases in which multiline is already justified Its also possible that Truth should have more special handling of AutoValue types in some cases I recently started using autoservice in a Gradle project I noticed that while there was documentation on how to get started using autoservice with Maven there was no documentation for Gradle In my experience having simple howto guides for getting started lowers the barrier of entry for using this project I wasnt sure if I should include a note that it appears that the autoserviceannotations artifact did not exist prior to version rc Any feedback is appreciated Not sure where to file this issue but i thought to start here Using Android Studio with androidx databinding enabled AutoValue and Glide i faced the Error cannot find symbol DataBindingComponent it was all over the place of all generated databinding classes Also there were Glide errors but i was already used to know that they are always present if the project does not compile However there were no AutoValue errors present Now if i declare an empty interface for the DataBindingComponent to make the data binding compiler happy the root error from AutoValue gets revealed error Parameter type javalangBoolean of setter method should be boolean to match getter fixing that and then removing the dummy interface i am happy to be able to compile the project again The sad thing is whenever i introduce an AutoValue error i have to repeat the process 