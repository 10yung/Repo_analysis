We have a number of flat structures defined in data storage ie a database which are defined through a user interface These are essentially types but we do not have a CLR type that represents them We retrieve them as property bags and then generate JSON documents on the fly using JSONNET to feed the client a JS app This is not much of an issue as the results stream from the data source usually SQL Server or RavenDB and we dont incur the cost of materializing everything in memory Additionally we incur the overhead of serializing the data from the providers to an intermediate CLR type instance and then serialize that to the response stream standard HTTP response from ASPNET Core However we have some very large payloads with many rows a few hundred K which is sometimes wide maybe columns When this happens the problem we have on the client is that we have to get the entire JSON string representing the response and deserialize that which presents some resource constraint issues It would be preferable if we were able to use a serializerserialization format will be able to yieldstream objects or at least construct arrays without needing to store the entire response up front One solution we have is to page the data and make multiple calls with smaller payloads this has a number of problems mainly Wed have to run the query multiple times which could lead to potentially inconsistent results We could store the results of the query up front on the server which we explicitly avoided up to now by streaming from the data provider to the response stream We also have thought about using linedelimited JSON but that presents its own set of problems With that in mind we are searching for other serialization formats that support the scenario Protobuf allows for this on the writer side as mentioned by mgravell However Id still like to avoid needing to materialize to an intermediate CLR type if possible So the question becomes can I define a schema at runtime without a CLR type and populate instances of that schema when streaming results On the JavaScript side protobufjs allows for defining a schema purely through reflection so were covered there The idea is that we can define the same schema on the server and client side through the type definitions we have stored in our providers Thanks in advance We have data coming in to our eventhubs which are encoded using protobufnet the read however is from a spark pipeline which uses googles protbuf I see that while this works fine for other fields there are issues with Timestamp column In the C gen the column used is DateTime and in scala it is googleprotobufTimestamp While this doesnt fail during run time the values produces are incorrect Below is one such value it was encoded for value in a recent date T Im generating a list of grpc proto rpc method signatures and I need the Type Name that protobufnet uses in its RuntimeTypeModelGetSchema At the moment Im using reflection to call the internal method which works as expected but would obv prefer to call a public API It would be great to add a differencer that can be used to determine the differences between two specified protocol messages Similar to This would allow notifying users of changes prior to processing them when using protocol buffers for serializing Im trying to wrap my head around the following issue but I apologize if I misunderstand how things like this supposed to be implemented I have a custom type in our system that I would like to serialize using Protobuf The type has implicit conversion to Int so I want to send it on the wire as if it would have been an Int On the receiving end different types of consumers this type does not exist and I want it to look as if it was an Int in the first place This is a small repro example on what Im trying to do public struct CustomType public static implicit operator longCustomType d dvalue public static implicit operator CustomTypelong d new CustomTyped private long value public CustomTypelong value thisvalue value public class Item ProtoMember public CustomType CustomId get set ProtoMember public string Description get set static void Mainstring args var item new Item CustomId Description Test var stream new MemoryStream SerializerSerializestream item This throws Unhandled Exception SystemInvalidOperationException Type is not expected and no contract can be inferred protoItem I first tried with declaring a surrogate but then I couldnt deserialize it in the other end as an Int so then I tried using the alpha version and writing a custom serializer for the CustomType above that I couldnt make work if thats even supposed to be possible to do since it complained about invalid WireType being string when trying to write it as a In probably me implementing it wrong After upgrading accidentally to the latest version of protobufnet I can see a lot of errors with AsReference obsoletion I chose Protobufnet to implement serialization as opposed to say json solely because of this feature if a complex graph of objects with child and parent relationships and differenct branches connected through relationships needs to be serialized there need to be some kind of identifiers added to identify relationships after deserialization to correctly rebuild object structure Obviously there is wire size benefit of serializing unique instances of objects only once not to mention easy handling of cycles Additionally worrying about reconnecting all relationships is obviously error prone and if serialization library and protocol supports such feature it is a life saver It seems AsReference was chosen to be removed leaving protobufnet in the same ball park as json serialization for objects with interconnected nodes graphs Is there a way to implement AsReference feature as an addon logic which will hook into global process of property serialization with the purpose of identifying unique objects and enabling deserialization of them in one place and referencing them in other places its so hard for me about reading itSo many class that i cant remember anyone when i see it again Shall we make a graph about the Class Diagram Protogen does not compile proto file with reserved keyword in enum Protogen version g ec abff Protoc version libprotoc Consider following proto file protobuf syntax proto Enumeration enum SomeEnum Reserve values reserved to to max UNKNOWN ENUM ENUM ENUM ENUM protogen is not able to compile it protogen csharpout testreservedproto testreservedproto error expected Symbol while protoc compiles it without issues protoc csharpout testreservedproto CSharp autogenerated Generated by the protocol buffer compiler DO NOT EDIT source testreservedproto autogenerated pragma warning disable region Designer generated code using pb globalGoogleProtobuf using pbc globalGoogleProtobufCollections using pbr globalGoogleProtobufReflection using scg globalSystemCollectionsGeneric summaryHolder for reflection information generated from testreservedprotosummary public static partial class TestReservedReflection region Descriptor summaryFile descriptor for testreservedprotosummary public static pbrFileDescriptor Descriptor get return descriptor private static pbrFileDescriptor descriptor static TestReservedReflection byte descriptorData globalSystemConvertFromBase String stringConcat ChN ZXN LXJlc VydmVkLnByb RvKmEKCFNvbWVFbnVtEgsKB VOS PV Q ABILCgdFTlVNXzAxEAESCwoHRU VTV wMxADEgsKB VOVU fMTAQChILCgdF TlVNXzExEAsiBAgCEAIiBAgEEAkiCAgMEP HYgZwcm bzM descriptor pbrFileDescriptorFromGeneratedCodedescriptorData new pbrFileDescriptor new pbrGeneratedClrTypeInfonew typeofglobalSomeEnum null endregion region Enums summary Enumeration for lock type summary public enum SomeEnum pbrOriginalNameUNKNOWN Unknown pbrOriginalNameENUM Enum pbrOriginalNameENUM Enum pbrOriginalNameENUM Enum pbrOriginalNameENUM Enum endregion endregion Designer generated code Noticed an overload we need was missing adding it here hello I am wondering if it is anyhow possible to create a duplex communication with low level TCP Socket Something like nettcpbinding in wcf Maybe also with help of Tcplistener and TCPClient 