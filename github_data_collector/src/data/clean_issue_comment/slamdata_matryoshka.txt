Hi Is there any possibility to publish matryoshkacore artifact for scala Can I help with that CC djspiewak Best regards Karol Hi I wanted to let you know about a subtle but pretty fundamental bug weve found in Haskells recursionschemes library Since Matryoshka uses the same recursionschemes from comonads approach as we do and exposes the same gcata distZygoT and histHisto building blocks as we do Im pretty sure the bug affects Matryoshka as well Now the bug is pretty subtle Only zygomorphic histomorphisms and their generalizations such as the infamous zygohistomorphic prepromorphism seem to be affected and even then they only compute an incorrect answer when the input trees depth is at least Another symptom is that histomorphisms do more work when implemented via gcata and distHisto than when implemented by hand Thats the symptom I noticed first but be sure to read further down it really is a correctness issue not just a performance issue In our Haskell implementation we have decided to move away from comonads but thats a pretty big change so you might consider the following slightly less drastic but still painful change remove gzygo and distZygoT from the library zygo and distZygo are still fine Manually reimplementing histo might be a good idea too Keep in mind however that these are merely the symptoms I have noticed there might be more Anyway I wrote a lot more about the problem in the upstream issue but since the problem is pretty subtle let me know if you have any question Eg Birecursiveiso should pass the monocleIso laws xanafcatag xhylog f for some generic f and g xcatag xhylog project and its dual either make other operations gcata futu etc final or add laws comparing them to the default impls Hi I saw the talk from Greg Pfeil and found the park on mutual recursion really appealing I created a simple example of numeric and boolean operations that I would be happy to add to a documentation once I figure how to do traversals It is a nice domain to document due to some obvious rewrites on boolean expressions I appreciate that we need a natural transformation to transform A is higherkinded Functor a thing But not sure if there is further infrastructure around this scala sealed trait BoolAndCalcF A I Using AtLeastTwoList as a more complex use case case class And A expressions AtLeastTwoList A Boolean extends BoolAndCalcF A Boolean case class Or A expressions AtLeastTwoList A Boolean extends BoolAndCalcF A Boolean case class Not A wrapped A Boolean extends BoolAndCalcF A Boolean case class BoolVal A value Boolean extends BoolAndCalcF A Boolean A bridge from calculation to booleans case class Compare A I Numeric J Numeric left A I op CompOp right A I extends BoolAndCalcF A Boolean case class Add A I Numeric left A I right A I extends BoolAndCalcF A I To show it would not compose with the rest due to Option case class Divide A I Numeric left A I right A I extends BoolAndCalcF A Option I case class Num A I Numeric value I extends BoolAndCalcF A I sealed trait CompOp object CompOp case object GT extends CompOp case object LT extends CompOp case object EQ extends CompOp case object NE extends CompOp case object GE extends CompOp case object LE extends CompOp import catsdataOneAnd type AtLeastTwoList A OneAnd OneAnd ListA A case class AtLeastTwoList A head A secondA tail List A def map B f A B AtLeastTwoListfhead fsecond tailmapf def fold B h A Bf B A B B tailfoldLeft B fhhead secondf For instances on refined types Eg BirecursiveAux Int With NonNegative Option Eg is there something we can do like Recursive t f PatternMonoid f Monoid t where PatternMonoid is the missing piece and similarly for other type classes We have or maybe used to have things like this for Functor and Foldable but should try to expand it as much as possible I think I remember seeing some instances like this in the Haskell world perhaps in paba compdata repeatedly returns one more time a function value instead of being a method also added ginterpret Symptoms cata and other recursion patterns unavailable for Fix and related types scalaVersion comslamdata matryoshkacore Causes Ambiguity between recursiveTRecursive and birecursiveTBirecursive apparently in toplevel package object How to reproduce import matryoshka import matryoshkaimplicits import matryoshkadataFix implicitly Recursive Fix Option console error ambiguous implicit values both method recursiveTRecursive in package matryoshka of type T F implicit evidence matryoshkaRecursiveT T matryoshkaRecursiveAux T F F and method birecursiveTBirecursive in package matryoshka of type T F implicit evidence matryoshkaBirecursiveT T matryoshkaBirecursiveAux T F F match expected type matryoshkaRecursive matryoshkadataFix Option implicitly Recursive Fix Option Same problem for Mu and Nu Workaround def rimplicit r BirecursiveT Fix matryoshkabirecursiveTBirecursiver Matryoshka could definitely benefit from libraryspecific advice when it comes to compiler errors See here for how Hopefully this can be done as a subproject otherwise weall need a separate repo Itd be great to create a tutorial using the scalaexercisesscalaexercises tool so users can interactively solve Matryoshka problems