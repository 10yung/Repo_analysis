The current inttobytestring method is susceptible to the Oddlength string error Added a verification with bitlength and adjusted the conversion into bytestring error while using on kali linux bootstrap bootstrap autoreconf not found After following the instructions for docker setup Im able to scan single ip addresses whenever i scan a single ip address using docker run cve latest xxxx However using the python script im getting errors whenever attempting to scan a subnet Id actually like to scan from a list of specific ips within a txt file Would that be possible scanwithdockerpy xxxx Results rootkaliDesktopCVE scanwithdockerpy xxxx Traceback most recent call last File scanwithdockerpy line in runrdesktopindocker stdout stderr processcommunicatetimeout File usrlibpython subprocesspy line in communicate stdout stderr selfcommunicateinput endtime timeout File usrlibpython subprocesspy line in communicate selfchecktimeoutendtime origtimeout File usrlibpython subprocesspy line in checktimeout raise TimeoutExpiredselfargs origtimeout subprocessTimeoutExpired Command usrbindocker run cve latest xxxx timed out after seconds During handling of the above exception another exception occurred Traceback most recent call last File scanwithdockerpy line in module main File scanwithdockerpy line in main rdesktopresult rdesktoppoolmaprunrdesktopindocker hostswithport open File usrlibpython multiprocessingpoolpy line in map return selfmapasyncfunc iterable mapstar chunksizeget File usrlibpython multiprocessingpoolpy line in get raise selfvalue File usrlibpython multiprocessingpoolpy line in worker result True funcargs kwds File usrlibpython multiprocessingpoolpy line in mapstar return listmapargs File scanwithdockerpy line in runrdesktopindocker stdout stderr processcommunicatetimeout File usrlibpython subprocesspy line in communicate stdout stderr selfcommunicateinput endtime timeout File usrlibpython subprocesspy line in communicate selfchecktimeoutendtime origtimeout File usrlibpython subprocesspy line in checktimeout raise TimeoutExpiredselfargs origtimeout subprocessTimeoutExpired Command usrbindocker run cve latest xxxx timed out after seconds Hi Just encountered a small bug When a target computer has some licensing issue Remote Deskop Connection The remote computer disconnected the session because of an error in the licensing protocol Please try connecting to the remote computer again or contact your server administrator the script will report it as vulnerable Example from a Windows R server rdesktop xxxxxxxxx Registering MST channel Connection established using SSL WARNING License error alert from server Invalid client Target is VULNERABLE Using the console will yield the proper result rdesktop xxxxxxxxx Registering MST channel Connection established using SSL Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Sending MST check packet size x offset x Max sends reached please wait for race condition to be sure Target appears patched Keep up the good work And thanks for not unleashing the digipocalypse There is a python version based on original authors msf plugin It works on windows xp windows R windows thanks for zerosum x s work Usage pip install pocsuite pocsuite r cve py u nongit starting at INFO loading PoC script cve py INFO pocsusite got a total of tasks INFO running pocwindows rdp rce cve target POSSIBLE OS R DC VULNERABLE TARGET targeturl pocname pocid component version status windows rdp rce cve rdp win win k win k r win k winxp success success shutting down at pocsuite r cve py u nongit starting at INFO loading PoC script cve py INFO pocsusite got a total of tasks INFO running pocwindows rdp rce cve target POSSIBLE OS xp VULNERABLE TARGET targeturl pocname pocid component version status windows rdp rce cve rdp win win k win k r win k winxp success success shutting down at Impressive work here congratulations Just a few questions Suricata seems to set Must be within bytes channels bytes per channel for the use after free channel so that will be little fun with the payload when there is only space for bytes Why did you chose this specific amount of channels and is the hardcoded ID for easier compliance with a potential exploit Is the size of the heap the same with and without this ruleset of Suricata