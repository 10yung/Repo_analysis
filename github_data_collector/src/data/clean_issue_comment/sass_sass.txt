When I switch from using import to use and not change anything else my styling breaks Webpack doesnt complain or anything but the app just has no styling Proposal Specs x Documentation Too small to warrant explicit documentation Dart Sass LibSass Although typically partial URLs are written in use rules without the leading underscore its possible to write them with the underscore Currently the spec and Dart Sass both treat the underscore as part of the use rules default namespace so use example has the default namespace example rather than example This is a bug in the spec the default namespace should be the same regardless of whether the URL has an underscore or not Unfortunately since this is a backwardsincompatible change it wont be able to go through the fast track process and will require a full proposal I wonder if it would make sense to somehow allow using use to import only the imported modules members variables mixins functions but not the imported modules styles Here is my use case Supposing this is my master Sass file scss use componentsalertscss use componentsbuttonscss and this is alertscss scss use button alert backgroundcolor buttonbgcolor and this is buttonscss scss bgcolor blue button backgroundcolor bgcolor the CSS compiled from the master Sass file would be css button backgroundcolor blue alert backgroundcolor blue Note that the compiled CSS for button appears before that of alert despite the order of the use statements in the master Sass file As the documentation states Any styles loaded using use will be included exactly once in the compiled CSS output no matter how many times those styles are loaded so this behavior is not unexpected However I do think it would be valuable to allow for using use to import only members because this would give Sass authors some flexibility to use different organizationalarchitectural approaches Perhaps the syntax could be consistent with the syntax for controlling visibility with forward eg use button hide styles and use button show mixins functions bgcolor and use button show variables where all of the above would result in styles not being imported but the bgcolor variable being imported the strings are just example keywords that might make it easier to includeexclude members by type rather than having to do so individually I think its useful to draw a comparison with JS modules here Conceptually importing a Sass file using use seems to be similar to importing a JS module that has a side effect in this case the side effect being that the styles are outputted Basically I think itd be useful to be able to opt out of this side effect given that importing Sass modules has value beyond the outputting of styles usage of locally scoped members Added by nex Proposal Specs Dart Sass LibSass Hi nex and friends Ive noticed that there are a few gaps between CSSs specified syntax and what dartsass will parse one area in particular is parsing supports conditions The following examples should all be valid in CSS syntax but each generate parsing errors in dartsass css supports a b supports cd supports ef The syntax for supports conditions in CSS is defined here perl supportscondition not supportsinparens supportsinparens and supportsinparens supportsinparens or supportsinparens supportsinparens supportscondition supportsfeature generalenclosed supportsfeature supportsdecl supportsdecl declaration One thing that seems missing is that the CSS syntax allows generalenclosed productions which are very openended in what they can contain perl generalenclosed functiontoken anyvalue ident anyvalue It looks like this might be the section of the dartsass parser where these conditions are read but Im not sure right now how to fix this or improve the code thats there When tokenized as CSS supports cd should look like this json type ATRULE value type BLOCK value name name supports prelude token WHITESPACE type FUNCTION value token IDENT value d name c token WHITESPACE You can use this tool to check what different browsers will parse out of a string of CSS input Or run this code to parse and restringify a string of CSS in any browser to see the same kind of result js import stringify consolelog stringify parse supports cd It looks like Safari struggles with supports conditions that arent inside parens but Chrome and Firefox both seem to follow the spec a little more closely Safari img width altsafarimostlyworks src Firefox img width altfireroxallwork src It would be great if dartsass could parse CSS more accurately in this area please let me know if theres any way I can be of further help in identifying or testing this Thanks x Proposal x Specs x Documentation x Dart Sass LibSass If a library like the following scss libraryscss original libcolor red default a color libcolor removes the lib prefix when migrating to the module system it will add an importonly stylesheet like so to preserve the manually prefixed names for downstream users still using import scss libraryscss migrated color red default a color color libraryimportscss forward library as lib But this currently breaks downstream stylesheets like scss downstreamscss libcolor green import library which compiled to a color green prior to migration and a color red after It seems like this is due to importstyle configuration not propagating through a forward When using sass libraries with reactvue components and building with webpack Every imported file in the component is processed individually which requires the shared libraries to reload for every file Ideally JavaScript API can create ImportCacheAsyncImportCache by importing some shared files and libraries and pass this cache to every rendercompile call Edited by nex x Proposal x Specs x Documentation x Dart Sass LibSass The current plan is to add a with clause to forward This would work like the same clause in use except that unconfigured variables or variables set with the default flag would still be configurable by the modules loading the module in which the forward appears For example scss forward unopinionated with hue default Can be overridden by upstream users saturation Cannot be overridden by upstream users Ive been moving my Sass packages over to the module system but I keep hitting a problem I cant figure out I usually have a central set of configuration variables that need to be configurable by users be used by all the internal modules But any time I make an internal file available to other files I lose the ability to take userconfigurations Error This module was already loaded so it cant be configured using with Ive tried adding duplicate default settings in each file that needs but then I get Error Module sassconfigscss and the new module both forward a variable named setting As far as I can tell everything that uses a particular default variable has to live in the same file Is this how its meant to work How would you recommend handling global package config shared among partials Theres currently no standard way for Sass users to import packages from dependencies There are a number of domainspecific solutions such as Webpacks tildebased imports npmsasss loadpathlike functionality or Dart Sasss support for Darts package URLs Most of these have the disadvantage of needing to be explicitly optedinto and all of them make it difficult to share stylesheets across different contexts For example if package A depends on package B how can A import B in a way that will work in both Webpack and in Dart This is the kind of situation where centralization is a boon If we can build into the Sass language a notion of a package import thats flexible enough to work across contexts we can make it usable by all stylesheets with confidence that even if theyre used by different build runners or even ported to a different package manager their dependencies will continue to work What does it look like The Sass specification talks about imports in terms of URLs The current JS API deals with them as a combination of raw strings and filesystem paths but Id like to move away from that as part of The current most popular solution for package imports is probably sassloaders which passes any import that begins with through Webpacks builtin resolution infrastructure We could reuse this syntax but it doesnt work well with URL semantics A string beginning with a tilde is syntactically a relative URL which means wed need to check for the relative path package first before passing the URL to the package importer Wed have a similar problem if we automatically added nodemodules to the load path Every instance of use bootstrap would need to check the relative path first as well as potentially every load path before checking the package importer It also makes package stylesheets less visually distinctive which can be confusing for readers As such I propose that we use the URL scheme pkg to indicate Sass package imports so users would write use pkgbootstrap This doesnt conflict with any existing syntax and so producing backwardscompatibility headaches and it nicely mirrors the syntax of Sasss core libraries use sasscolor What does it do The purpose of a standard package importer is in fact to avoid specifying the exact behavior of the importer so that it can do something sensible for each context However since Nodejs is by far the most popular context in which Sass is used we should figure out what it does in that particular case When resolving a URL I think it should check nodemodules folders as described in Nodes documentation beginning from the parent directory of the module in which Sass is invoked if its invoked as a library from JS or the parent directory of the entrypoint file if Sass is invoked via the command line Theres a convention of npm packages declaring their Sass entrypoints using style or sass keys in their packagejson While its definitely useful to be able to write import bootstrap rather than import bootstrapscssbootstrap I actually think we shouldnt support this Instead I think we should encourage packages to define an indexscss file that acts as the entrypoint This will ensure that even if the package ends up on the load path or installed through some way other than nodemodules it can still be imported correctly without needing to parse packagejson x Proposal The spec is already correct x Documentation Too much of an edge case x Specs x Dart Sass LibSass Reproduction root p color var Im opening this as a metaissue to track the holistic problem that the Bolt design system is seeing with very slow build times Id like to provide tools to help make it faster and in doing so hopefully improve the performance for all users with similar use cases Analysis At sghoweris suggestion Ive been testing performance on the testsasscompiletest branch with the following results LibSass with a monolithic entrypoint file about s for initial compilation and rebuilds no matter what file was changed LibSass with many different entrypoints combined via Webpack about s for initial compilation s for rebuilds when boltcorestylesindexscss is modified and s for rebuilds when an individual component is modified Dart Sass with a monolithic entrypoint file about s for initial compilation and rebuilds no matter what file was changed Dart Sass with many different entrypoints combined via Webpack about s for initial compilation s for rebuilds when boltcorestylesindexscss is modified and s for rebuilds when an individual component is modified Note when compiling with Dart Sass Im using my own branch as well as a local version of Dart Sass with a fix for Im compiling with Fibers enabled to trigger the muchfaster synchronous code path Its not surprising that Dart Sass is slower than LibSass for monolithic compilations since pure JS is always going to be somewhat slower than C but it is surprising that LibSass benefits from multiple entrypoints while Dart Sass does not mgreter or xzyfer do you have any insight into why that could be Is LibSass doing some sort of caching across compilations or is it able to run multiple compilations in parallel I then attached a profiler to the Dart Sass compilation to see if I could determine where its spending all that time It looks like by far the biggest culprit about of the total compilation time is spent resolving imports Most of this is spent waiting for filesystem calls to determine exactly which files exist The remaining time is spent doing mostly breadandbutter interpreter stuff with a slight emphasis on builtin map manipulation functions CommandLine Compilation As an experiment I also set up a version of the repo where the monolithic entrypoint can be compiled from the commandline Compiling this with the nativecode Dart Sass using sass I nodemodules docssitesasscompiletestscss devnull takes about s although of course it has no caching across compilations so incremental compilations would be much more expensive Interestingly SassC takes about s for the same compilation which is also much faster than the monolithic compilation when driven via Webpack Its not clear to me whats causing this major discrepancy the commandline run comments out the exportdata function but commenting it out in the Webpack run doesnt substantially increase its performance Its possible that some of it is just performance improvements to LibSass itself between the version available through Node Sass and the version I was testing with gc When profiling the Dart VM compilation it looks like its spending vastly less time about of the total compilation time checking the filesystem I think this is because Dart Sasss import semantics especially in the presence of importers are subtly different from the JavaScript APIs in a way that allows it to cache the vast majority of lookups Possible Solutions Note any solution we come up with should avoid substantially regressing the singlecomponentrecompilation case Embedded Dart Sass This is likely to be by far the easiest solution Dart Sass is currently easiest to use from JS as a pureJS package but as mentioned above JS as a language imposes a considerable amount of overhead Were planning on launching an embedded mode that will run the Dart VM as a subprocess which should substantially improve performance relative to the pure JS version Its hard to say exactly how much benefit this would provide especially because it depends on which precise importer and caching semantics we decide on but my guess is it would at least make Dart Sasss performance competitive with LibSasss Better Caching Semantics As I mentioned earlier Dart Sass running in JS library mode doesnt cache its import resolution within a single compilation This is necessary to maintain strict compatibility with Node Sass but it doesnt have to be locked in place forever As part of we should look into defining a new set of semantics like those in native Dart Sass that are more amenable to caching Module System One of the features of the new module system is ensuring that a given file is only loaded once How much this will help depends on how much the current setup is importing the same files multiple times though CrossCompilation Caching The current compilation setup compiles many different entrypoints and then uses Webpack to combine them This has the benefit of allowing Webpack to avoid unnecessary recompilation when an individual component is modified but it currently means that Sass or at least Dart Sass doesnt share any state across compilations of each separate entrypoint In general its not safe for Sass to assume that separate compilations have anything in common the entire filesystem could have changed between two calls to render But when Webpack kicks off a batch of compilations its aware that theyre all expected to work the same filesystem state Sass could provide some API perhaps a Compiler object that makes the assumption that nothing changes across multiple compilations so it can share cached import resolutions between them We could even go a step further and provide the ability for the Compiler to be informed when changes do happen so that the cache can be invalidated only as much as necessary Dart Sass already has support for this internally for watch mode wed just need to provide an API for it Im not sure if Webpack exposes this information though maybe evilebottnawi can provide insight here Loaded Module Caching This is the furthestreaching possibility but also one that could get monolithic compilation to within the speed of filebyfile compilation for a single modified component The module system defines a clear notion of the loaded state of a module and we could cache this state across compilations and avoid even evaluating a module again once its loaded The major complexity here is that loading a module can have side effects including changing the state of another loaded module Wed need to have some way of marking modules as well as anything downstream from them as uncachable when this happens But uncachable modules are likely to be a small minority so this should still provide considerable benefits