Ive been following the tutorial at with some minor alterations but I cant understand what the lookat method is doing I have created a window and set the lookat position to the center of the view window in theory but this is not what appears Example code rust const WIDTH f const HEIGHT f fn main let mechanicalworld DefaultMechanicalWorldnewVector new let geometricalworld DefaultGeometricalWorldnew let mut bodies DefaultBodySetnew let mut colliders DefaultColliderSetnew let jointconstraints DefaultJointConstraintSetnew let forcegenerators DefaultForceGeneratorSetnew Build a static ground body and add it to the body set let groundhandle bodiesinsertGroundnew Spawn some objects at center and axis let mut testbed Testbednewempty Tell the testbed your ground has an handle equal to groundhandle This will make it be drawn in gray testbedsetgroundhandleSomegroundhandle Provide to the testbed all the components of our physics simulation testbedsetworld mechanicalworld geometricalworld bodies colliders jointconstraints forcegenerators Adjust the initial camera pose let center Point newWIDTH HEIGHT printlnCenter center testbedlookatcenter testbedaddcallbacktick testbedrun When run I get this window which is not the center I put in Screenshot from Is there a bug in the lookat method or is there something we could add to the documentation to make it clearer what the expected behavior is In the D plasticity web demo rapidly clicking on any of the platforms causes a panic Panic error message called Optionunwrap on a None value cargowebsnippet af d a a fa a b e acd ZN stdweb webcore initialization initialize u bu bclosureu du d he f f c E ZN std panicking rustpanicwithhook h a d aa e f fE ZN std panicking continuepanicfmt h bc f dc f bE rustbeginunwind ZN core panicking panicfmt h bd c c b d dE ZN core panicking panic h fb f c dE ZN LTnphysicstestbed dtestbedTestbedu asu kiss dwindowstateStateGT step h f b a a dbE ZN LTstdwebwebcorenewtypeNewtypeLTLPstdwebwebcoreserializationFunctionTagCu LPA CRPRPCstdwebwebcoreonceOnceLTFGTGTu asu stdwebwebcoreserializationFuncallAdapterLTFGTGT funcalladapter hfa c e dE ModuleSTDWEBPRIVATEdyncall output Everything in the demo is at default settings Replicated in Firefox esr and Chrome on Windows HEAD bade The first kind of crash can be reproduced pretty reliably by making a single ragdoll stuck in the platform and then dragging it around furiously until it passes through On one occasion this happened randomly even before any ragdoll stuck Backtrace thread main panicked at assertion failed minbound minbound homeburjuicargoregistrysrcgithubcom ecc db ec ncollide d srcqueryalgorithmsgjkrs stack backtrace x fea backtracebacktracelibunwindtracehfe db at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs x fea backtracebacktracetraceunsynchronizedh b a at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x fea stdsyscommonbacktraceprinth ae at srclibstdsyscommonbacktracers x fea stdsyscommonbacktraceprinthe dd ddddf at srclibstdsyscommonbacktracers x fea stdpanickingdefaulthookclosureh a eb b f at srclibstdpanickingrs x fe f stdpanickingdefaulthookh ca f a a e b at srclibstdpanickingrs x fe f stdpanickingrustpanicwithhookhffcefc d at srclibstdpanickingrs x d a a stdpanickingbeginpanichdaa c d e a x d b ncollide dqueryalgorithmsgjkcastrayh d ebdde a x d d b ncollide dqueryrayraysupportmapimpl ncollide dqueryrayrayRayCastN for ncollide dshapecapsuleCapsuleNtoiandnormalwithrayh e db c da c x db ncollide dpipelinegluequeryInterferencesWithRayNObjects as coreitertraitsiteratorIteratornexth a fee dcc x df nphysicstestbed dtestbedTestbed as kiss dwindowstateStatestephbeba d e x def f nphysicstestbed dtestbedTestbedrunh fe eb f fe e x d bd ragdoll mainha e a f x d a stdrtlangstartclosureh d a ac x d ce main x f a fb eee libcstartmain x d e start x unknown The second kind happens usually when multiple ragdolls are stuck Backtrace thread main panicked at index out of bounds the len is but the index is rustceae dfe e afdc f a d ddf bsrclibcoreslicemodrs stack backtrace x e e backtracebacktracelibunwindtracehfe db at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs x e e backtracebacktracetraceunsynchronizedh b a at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x e e stdsyscommonbacktraceprinth ae at srclibstdsyscommonbacktracers x e e stdsyscommonbacktraceprinthe dd ddddf at srclibstdsyscommonbacktracers x e e stdpanickingdefaulthookclosureh a eb b f at srclibstdpanickingrs x e e f stdpanickingdefaulthookh ca f a a e b at srclibstdpanickingrs x e e f stdpanickingrustpanicwithhookhffcefc d at srclibstdpanickingrs x e e f stdpanickingcontinuepanicfmthc f c c fc at srclibstdpanickingrs x e f a rustbeginunwind at srclibstdpanickingrs x e fd fc corepanickingpanicfmth daf b ca b at srclibcorepanickingrs x e fd e corepanickingpanicboundscheckh ade df e at srclibcorepanickingrs x e c ncollide dshapeconvexpolygonalfeature ConvexPolygonalFeatureNcliphd aeb e b x e cde ncollide dpipelinenarrowphasecontactgeneratorconvexpolyhedronconvexpolyhedronmanifoldgeneratorConvexPolyhedronConvexPolyhedronManifoldGeneratorN as ncollide dpipelinenarrowphasecontactgeneratorcontactmanifoldgeneratorContactManifoldGeneratorNgeneratecontactsh a e e f eb f x e d ncollide dpipelinenarrowphasecontactgeneratorcapsuleshapemanifoldgeneratorCapsuleShapeManifoldGeneratorNdoupdatehb bfa b e x e b ncollide dpipelinenarrowphasecontactgeneratorcapsuleshapemanifoldgeneratorCapsuleShapeManifoldGeneratorN as ncollide dpipelinenarrowphasecontactgeneratorcontactmanifoldgeneratorContactManifoldGeneratorNgeneratecontactsh f fb b f b x e a ncollide dpipelinenarrowphasenarrowphaseNarrowPhaseNHandleupdatecontacthecb bc cab x e fe nphysics dworldgeometricalworldGeometricalWorldNHandleCollHandleperformnarrowphasehe cfd e fcc x e ac nphysics dworldmechanicalworldMechanicalWorldNBodiesCollHandlestephb ac b b a x e f nphysicstestbed dtestbedTestbed as kiss dwindowstateStatestephbeba d e x e ed f nphysicstestbed dtestbedTestbedrunh fe eb f fe e x e bd ragdoll mainha e a f x e stdrtlangstartclosureh d a ac x e ce main x fceed ee libcstartmain x e e start x unknown I notice that DefaultMechanicalWorld is not really a replacement for nphyics dworldWorld from v but rather a subset Whatever reason the geometrycollider world body collider joint and force sets are now separate the examples show that these often do not need to be used separately Is it worth adding a type akin to the old World to wrap all the above and likely also ease migration from v To demonstrate the issue I made the following test which should be selfexplaining Notice the use of position in the collider description builder vs setposition test pub fn test use nalgebraIsometry Vector use ncollide dshapeCuboid ShapeHandle use nphysics d forcegeneratorDefaultForceGeneratorSet jointDefaultJointConstraintSet objectBodyPartHandle ColliderDesc DefaultBodySet DefaultColliderSet Ground worldDefaultGeometricalWorld DefaultMechanicalWorld world let mut mechanicalworld DefaultMechanicalWorldnewVector new let mut geometricalworld DefaultGeometricalWorldf new let mut bodies DefaultBodySetf new let mut colliders DefaultColliderSetnew let mut jointconstraints DefaultJointConstraintSetf new let mut forcegenerators DefaultForceGeneratorSetf new ground let groundthickness let groundshape ShapeHandlenewCuboidnewVector new groundthickness let groundhandle bodiesinsertGroundnew let co ColliderDescnewgroundshape translationVector y groundthickness buildBodyPartHandlegroundhandle collidersinsertco let cuboid ShapeHandlenewCuboidnewVector repeat let isometry Isometry translation collider let co ColliderDescnewcuboidclone positionIsometry translation buildBodyPartHandlegroundhandle let cohandle collidersinsertco asserteqcollidersgetcohandle unwrapposition isometry collider let mut co ColliderDescnewcuboidclonebuildBodyPartHandlegroundhandle co setpositionIsometry translation let cohandle collidersinsertco asserteqcollidersgetcohandle unwrapposition isometry mechanicalworldstep mut geometricalworld mut bodies mut colliders mut jointconstraints mut forcegenerators passes asserteqcollidersgetcohandle unwrapposition isometry fails asserteqcollidersgetcohandle unwrapposition isometry The link to found on in the sentence The sensor demo shows a ballshaped sensor attached to a cube All colliders except the ground that intersect this ball are colored in yellow is broken Hi it would be great to enabledisable a collider separately from a rigid body This would also allow cases where some specific colliders on a body could be enableddisabled without disabling the body itself Currently only one constraint solver is available and implemented in the MoreauJeanSolver struct For research purposes Im working on other constraint solver implementations though they are far too specialized at the moment to contribute them anytime soon At the moment there is no simple way of implementing and switching between different solvers in nphysics without forking it and implementing everything inside of the fork First of all I would propose to add a ConstraintSolver trait that requires all functions that are currently called on the MoreauJeanSolver by the MechanicalWorld or should be part of the solver interface in general This includes at least the functions step and stepccd It might also include the setcontactmodel function but Im not sure if this has to be required for the trait The second point would be how different solver types get handled by the world This could be done either through generics or using a trait object The first approach would be easier to combine with the current design of the MechanicalWorld and its methods I think this would just require to add a generic Solver ConstraintSolver parameter to the world and accordingly change the type of the solver field This should be enough to make it work Alternatively one could also use a trait object to access the solver This would technically allow changing the solver between steps without constructing a new MechanicalWorld However this requires more changes from the current design The method step of the MechanicalWorld and the methods step and stepccd along with some internal methods of MoreauJeanSolver are generic wrt Colliders ColliderSetN BodiesHandle Handle CollHandle and Constraints JointConstraintSetN Bodies They have to be removed from the methods to support creating a ContstraintSolver trait object The only possible solution I can think of is moving the generic parameters to the ConstraintSolver and MechanicalWorld traits themselves Inside of the constraint solver implementations this would require adding phantom data fields because the types are only used be the respective methods Changing the solver to a trait object requires adding an additional lifetime bound of static to some of its generic parameters which includes Bodies Colliders and Constraint Im not sure if this is ok because I think a goal of making these set types generic parameters was to move lifetime handling out of the world Any thoughts on this So I noticed there doesnt seem to be much work going on here at the moment and figured this might be a good time to make this PR since the likelyhood of massive quantities of merge conflicts is severely reduced If this is not the right time then feel free to close this PR and schedule these changes for another time all changes were made completely automated by running cargo fix after adding denybaretraitobjects to librs rustsimncollide provides a bit of background for the reasons why its preferable to enforce dyn in front of every traitobject but in short it enhances their visibility by distinguishing them from structs Consider this program rust let mut world Worldnew let shape ShapeHandlenewCuboidnewVector repeat let collider ColliderDescnewshape density let topjoint FreeJointnewIsometry identity let bodydesc MultibodyDescnewtopjoint collider collider parentshiftVector repeat build mut world Testbednewworldrun When running this program I notice that the cube is still suspiciously close to the global origin Considering that the parentshift should shift it by units on each axis I would expect the cube to be visibly moved or probably even completely out of sight but no such thing happens and the cube seems to remain comfortably seated at the coordinate origin When I use a PrismaticJoint instead of a FreeJoint the cube is nowhere to be found as expected So this seems to be some kind of special behaviour that only affects FreeJoints but I didnt see such behaviour mentioned anywhere in the documentation so I guess this is a bug