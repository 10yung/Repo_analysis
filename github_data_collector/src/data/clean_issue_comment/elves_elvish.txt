Implement a method on Frame that shows a deprecation message go func Frame Deprecatereason string However during the entire lifecycle of an Evaler the same deprecation message should only be shown for the same source location once For example if you have a function that uses a deprecated feature the same message should only be shown the first time the function is called Until this feature is implemented deprecated feature will have a TODO Formally deprecate feature X attached to them in the Go code Let me start with thanking you for this wonderful project I really enjoy it And it works like a charm on my macOS machine However I am forced to use MS Windows at work As I want to use elvish for my daily work I encountered an issue when using the autocompletion on the press of TAB To visualize the problem let me show you how a path builds up using the feature sh cd TAB cd go TAB cd go pkg Needless to say the user would expect that to look like sh cd go pkg I believe to have identified some lines that are partly causing the issue pkgeditcompleterawitemgo go func c ComplexItem Cookq parsePrimaryType completionItem quoted parseQuoteAscStem q return completionItem ToInsert quoted cCodeSuffix a simple concatenation ToShow cStem cDisplaySuffix ShowStyle cDisplayStyle Due to the concatenation we have these multiple single cuoted expressions after one another As I see it one could argue that whenever there is such a case all singlequoted expressions should be combined into a single one Howevever as I just started looking at the code I have not yet a complete overview and this may be a bad idea xiaq what do you think How could this issue be effectively avoided I would be glad to help out Thanks for your work Much appreciated This adds two basic functions for working with lists Elvish already allows both operations by special syntax but its often useful to have them as functions editbeforeaddcmd hook let its functions check the command about to save and output a stirng If the string is nonempty it will be passed to the next function in the hook chain as input and finally saved to db otherwise the command will be ignored Can be used for hiding subdirectories eg tmp Given this setup editcompletionmatcher argument seed editmatchprefix seed ignorecasetrue If I try to complete a filename and there is only one match but the case of what I typed does not match the filename I get a completion list containing just one element For example after typing ls doc all lower case and hitting TAB I get this is my prompt I removed the right prompt ls Documents COMPLETING argument Documents What I expected is what is seen on the command line above without the two extra lines and no need to hit RETURN to continue That is what happens if I type ls Doc and hit TAB I did a little more testing based on the lobsters discussion If I run f f with the function f below using the elvishHEAD binary sometimes the variable is incremented by one and sometimes its incremented by My suspicion is that this is a race condition If thats the case I think it would be undefined behavior in Go and would be flagged by Gos race detector though I didnt try install fn f echo a a install echo a install install ff install echo a install ff install echo a install ff install echo a install ff install echo a install ff install echo a Elvish is a pretty ambitious project There are always a lot of things to do which translates to a lot of issues among other things Without some proper organization it is very easy to get buried in details and lose track of important problems to solve We use labels in a structured way to organize issues You can browse the list of all labels have it open alongside this document and explore it Category labels The most important labels are those that categorizes issues There are sets of them A Project contains closely related often intertwined issues A project needs a concrete coherent design and hopefully has one A project also has a completion criteria that is it can be called done at some point in future Projects are identified by labels that start with P and these labels all have the same color A Component also contains closely related issues they touch the same part of the code base and can benefit from some consistency However they are not related enough to form coherent projects Some may be just small things that can be implemented individually while some may be part of a protoproject that hasnt fully emerged Components are identified by labels that start with C and these labels all have the same color An Area is like a component just bigger issues in the same area are related on a high level but not as much as a component Areas are identified by labels that start with A and these labels all have the same color With the exception of a few meta issues like this one all issues have exactly one category label When an issue conceptually belongs to both a Project and a Component the Project is favored as it is more specific Likewise a Component takes precedence over an Area Issues may be recategorized over time to represent shifts in our conception For example a Project may eventually emerge from a Component and issues may move from the Component to the newly conceived Project Type labels There are type labels tbug tcleanup tnote and tquestion and they all have the same color Feature requests do not have a specific label as they are so common Other labels There is an additional label maybe It means that we are not yet sure whether the issue is a good idea Eventually either we think it is a good idea and remove the label or we think it is a bad idea and close the issue Originally posted by xiaq in I am considering introducing a readupto command elvish readupto last The command reads from the bytes input one byte at a time The argument last may be one of A string with a single byte in which case it specifies the byte to stop reading after A function in which case readupto passes each byte as a string to the predicate and stops after the predicate outputs a false value There is something subtle about readupto its output will include the first byte that is equal to last if last is a string or fails the last predicate if last is a function This is a consequence of how pipelines work The first simpler variant is now implemented but the second predicate argument remains The command history present in the line editor is a fused history consisting of the part of the permanent history when the session started plus the session history There should be an API for accessing the fused history