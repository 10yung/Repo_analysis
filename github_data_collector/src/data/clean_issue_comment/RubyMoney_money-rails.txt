Rescue if removeinstancevariable raises NameError This solves the issue of being unable to edit the cents in a Money field As an example consider this config for a Money field in Rails Admin for use with database columns pricecents and pricecurrency ruby configure price money excludefields pricecents pricecurrency Attempting to edit the field results in the following error because of the Integer field type Changing the Money field type to extend String instead of Integer solves this issue moneywithoutcentsandwithsymbol results in something eg like with a normal space between the number and the symbol This allows the symbol to be split apart from the number like this To avoid that the space needs to be replaced by the nbsp entity nbsp That is the sole purpose of the nbsp entity as nonbreaking space I dont think theres a use case for the normal space in html of course it might for other usecases api log etc so perhaps this should be parametrized Is there a workaround for this besides reimplementing on the application side I need a little bit of help Im looking to show the cost of a collection in multiple currencies gbp usd and eur Ive installed the gem updated my database and I have GBP price as default and its showing Ive added the rate configs configaddrate GBP USD configaddrate GBP EUR and registered the currencies in the model registercurrency gbp registercurrency usd registercurrency eur monetize pricecents as price withcurrency gbp How do I go about showing all three currency prices with the symbols based on the exchange rate The new default serialization introduced in breaks any apps that relied on the old default of serializing the complete object This includes anyone using the common x branch of Active Model Serializers where including the name of the money field would include the whole object including the currency This is against expectation of anyone assuming the versioning follows SemVer My use case is rendering objects with money fields as json from the backend API and having a front end JS service that understands what was the serialized money object to format this on the front end using symbol from the embedded currency object Although I understand the desire to default to a simpler object doing this in a minor point release seems incorrect This issue is partially linked to the issue As a fix for my idea was to make this change near diff Dont create a new Money instance if the values havent been changed if memoized memoizedcents amount memoizedcurrency attrcurrency result memoized if memoized memoizedcents amount if memoizedcurrency attrcurrency result memoized else memoizedamount memoizedamounttomoneyattrcurrency writeattribute subunitname memoizedamountcents Cache the value it may be nil result instancevariablesetname memoizedamount end elsif amountpresent If amount is NOT nil or empty string load the amount in a Money amount Moneynewamount attrcurrency Cache the value it may be nil result instancevariablesetname amount end But after that these specs started failing ruby it assigns the correct value from params do paramsclp amount tax currency CLP product Transactioncreateparamsclp expectproductvalidto betruthy expectproductamountcurrencysubunittounitto eq expectproductamountcentsto eq end ruby it reassigns cents amount when subunitunit ratio changes preserving amount in units do transaction Transactioncreateamount tax currency USD expecttransactionamountto eqMoneynew USD transactioncurrency CLP expecttransactionamountto eqMoneynew CLP expecttransactionamountcentsto eq end Failures MoneyRailsActiveRecordMonetizablemonetize assigns the correct value from params FailureError expectproductamountcentsto eq expected got compared using specactiverecordmonetizablespecrb in block levels in top required MoneyRailsActiveRecordMonetizablemonetize reassigns cents amount when subunitunit ratio changes preserving amount in units FailureError expecttransactionamountto eqMoneynew CLP expected Money fractional currencyCLP got Money fractional currencyCLP compared using Diff Money fractional currencyCLP Money fractional currencyCLP specactiverecordmonetizablespecrb in block levels in top required Finished in seconds files took seconds to load examples failures But if I change the params order so that in a params hash the currency would go prior to the amount then it passes ruby it assigns the correct value from params do paramsclp currency CLP amount tax product Transactioncreateparamsclp expectproductvalidto betruthy expectproductamountcurrencysubunittounitto eq expectproductamountcentsto eq end This way I get a green dot from rspec for this example Also if I pass amountcents instead of amount then specs are also green If I understand correctly moneyrails processes params hash keyvalue pairs one by one and when it gets to the currency first it assigns it and later when it gets to the amount it uses correct currency But when the amount goes first then moneyrails uses the default currency EUR in specs and since we pass not amountcents but amount it sets cents value according to the currency subunits config subunits per unit in this case Later when it gets to the currency it just sets it As a result I get CLP instead of CLP So the primary issue is about the ordered nature of params processing Also I believe that you should not apply the default currency when some currency is passed in params Hello I have a workflow where an user can setup for a record a currency and amount Later he can update both currency and amount for example he can switch from EUR to BTC Here is the issue Compare this ruby prymain mm MyModelcreatecurrency EUR amountcents MyModel x f d daf id currency EUR amountcents prymain mmamount Money fractional currencyEUR prymain mmupdatecurrency BTC amountcents ms BEGIN MyModel Update ms UPDATE mymodels SET currency amountcents WHERE mymodelsid currency BTC amountcents id ms COMMIT true prymain mmamount Money fractional currencyBTC to this ruby prymain mm MyModelcreatecurrency EUR amountcents MyModel x c c id currency EUR amountcents prymain mmamount Money fractional currencyEUR prymain mmupdatecurrency BTC amountcents ms BEGIN MyModel Update ms UPDATE mymodels SET currency amountcents WHERE mymodelsid currency BTC amountcents id ms COMMIT true prymain mmamount Money fractional currencyBTC Behavior in the latter example is pretty unexpected obviously I investigated and found that the issue occurs due to the memoization logic implemented around this line the one that calculates incorrect amount So it happens only in specific case when the cents amounts of both old and new values match and when the currencies differ at the same time Personally I think that it is better not to decide for a developer about how many cents should be assigned and let him determine himself when a value should be converted to a different currency and when it shouldnt ps Im using moneyrails rails with activerecord pg Similarly to monetize currentamountcents withmodelcurrency currency delegate currency to account Fails to set the amount Pricecreate currentamount accountid Sets the amount correctly Pricecreate accountid currentamount A work around Ive found is changing the order with strong parameters as my Price is created from an API controller def createparams paramsrequirepricepermitaccountid currentamount end Noticed this issue which might be a bit dated Curious whats the best way to do things like group with sum or any active record calculations Right now I have it return the numbers in cents which I have to then convert to Money object Example class Transaction include ActiveModelModel include MoneyRailsActiveRecordMonetizable attraccessor amountcents monetize amountcents withmodelcurrency currency end It can not work because of aftersave 