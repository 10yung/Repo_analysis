This currently doesnt work outside of this crate since it seems that macrointernal lints arent exposed across crate boundaries serdeDeserialize takes the lifetime parameter de How should I check that a class derives serdeDeserialize One of the working solutions is assertimplallMyType serdeDeserializestatic using the trick that static is available everywhere However is this the best practice Please consider adding this note to the documentation It is possible to implement a macro that returns a const boolean that indicates if a type implements a certain trait This might be useful to implement more complex static assertions when used together with staticassertionsconstassert I took the macros name from the staticassertionsassertimplall macro and then change the assert to is since it takes the same arguments but returns a boolean instead of causing a compiler error The macro I came up with looks like this rust macrorules isimplall xty tpath struct WrapperT Sized const T This impl has a trait bound on x so the type can only be accessed if x implements t implT Sized t WrapperT where allownonuppercaseglobals const staticassertisimplall bool true This trait provides an associated const for all types but the inherent implementations const has a higher priority trait Blanket allownonuppercaseglobals const staticassertisimplall bool false implT Sized Blanket for T If a blanket trait by the user is in scope that conflicts with the above blanket trait then this will fail to compile but it wont return incorrect values Wrapperxstaticassertisimplall Alternative macro implementation I also made a different version of the macro that ensures that the staticassertisimplall lookup wont fail if a blanket trait is in scope that conflicts rust macrorules isimplall xty tpath pub struct WrapperT Sized const T This impl has a trait bound on x so the type can only be accessed if x implements t implT Sized t WrapperT where allownonuppercaseglobals const staticassertisimplall bool true Resolve the type without the inner module being in scope type AType Wrapperx This module is private to this scope and wont affect path resolution for the paths provided by the user mod inner Used to reference the type in this new module pub trait GetType type Type This trait provides an associated const for all types but the inherent implementations const has a higher priority trait Blanket allownonuppercaseglobals const staticassertisimplall bool false implT Sized Blanket for T pub const VALUE bool as GetTypeTypestaticassertisimplall impl innerGetType for type Type AType innerVALUE Pro The constants cant have name collision but the types and traits might still have them Con Probably wont work with type parameters while the previous version should Since the Wrapper struct and the AType type alias can still cause name conflicts with the paths provided to the macro it doesnt really help that constants name cant cause name conflicts so this version of the macro isnt really better then the previous one and its definitely longer and more complex so it should probably not be used Some Tests Here is some tests I used to see if my macro worked rust test fn itworks macrorules asconst valueexpr const VALUE bool value VALUE Test macro asserteqasconstisimplall Send Sync true asserteqasconstisimplall Send Fromu false asserteqasconstisimplall Fromu Fromu Send false Boolean logic asserteqasconst isimplall Send stdpanicUnwindSafe isimplall Sync stdpanicRefUnwindSafe true Counting implemented traits asserteqasconst let mut count count isimplall Send as usize count isimplall Sync as usize count isimplall Fromu as usize count isimplall Intou as usize count false asserteqasconst let mut count count isimplall Send as usize count isimplall Sync as usize count isimplall Fromu as usize count isimplall Intou as usize count true The macro isnt perfect and a trait with the correct method name can interfere with the macro Currently this only causes the macro to not compile and not to return an incorrect value compilefail use playgroundisimplall trait Interfere allownonuppercaseglobals const staticassertisimplall bool true implT Interfere for T These should return false but the above trait might interferes and causes them to return true isimplall Fromu isimplall Fromu Fromu allowdeadcode fn interferencewithmacro By using onunimplemented tracking issue custom error messages like the following can be emitted on assertion failure error E static assertion failed testsmessagesrs assertimploneFoo A B C Foo must implement exactly one of the given traits required by closure AmbiguousIfMoreThanOnesomeitem help the trait closure AmbiguousIfMoreThanOne is not implemented for Foo note this error originates in a macro outside of the current crate in Nightly builds run with Z externalmacrobacktrace for more info This can be done like so behind a nightly feature flag rust macrorules assertimplone xty tpath const fn cfgattr feature nightly rustconunimplemented message static assertion failed label Self must implement exactly one of the given traits trait AmbiguousIfMoreThanOneA This introduces assertfieldoffsets for ensuring that given struct fields are at specific offsets This current implementation works in Rust and However the current beta and nightly compilers fail to perform the constant evaluation This is not unexpected since the current code creates a reference at memalignofT where there is no initialized memory Even though the reference is nonnull dereferencing those addresses is definitely undefined behavior I wont be merging this PR asis However Im interested to learn how this macro could be implemented in a sound way See also cc oliobk RalfJung In version it was possible to have a asserteqsize inside a function and refer to the type parameters of that function In version that is no longer possible rust fn fooT staticassertionsasserteqsizeRcT ArcT text error E cant use generic parameters from outer function fn fooT type parameter from outer function try adding a local generic parameter in this method instead staticassertionsasserteqsizeRcT ArcT use of generic parameter from outer function This would be handy for example to ensure struct sizes dont grow beyond some limit It can be implemented like this rust macrorules assertlesize aty bty const MaybeUninit u sizeofb sizeofa MaybeUninituninit Assertion that the supplied type must be one of multiple listed types One possible although not so elegant implementation is like this rust macrorules asserttypein labelident typety inty mod label fn mux in fn v type muxv Over on the rust internals board betamos noted that it would be nice to be able to annotate a type or value as sendable and get a compiletime error if it is not I thought this should be achievable using a macro and that it would be a good fit for this crate Maybe someone here can take a crack at it Edit updated request to assertexprimpl As per robinkrahls request I made an attempt at this but it doesnt necessarily work The only limited working form is if v is an ident or tt where only assertvariantThing A works and neither of the others does And even then it still requires the featuretypealiasenumvariants attribute for some reason on nightly Below is my current failing attempt at a solution rust featureunderscoreconstnames featuretypealiasenumvariants enum Thing A B x C macrorules assertvariant ety vpat const fne e match e ev assertvariantThing A assertvariantThing B assertvariantThing C fn main Ideally the best solution would allow for rust assertvariantThing A assertvariantThing B assertvariantThing C assertvariantThing A B C 