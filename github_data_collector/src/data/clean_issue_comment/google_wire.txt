Lets imagine we have an application with a lot of business logic and big amount of abstraction layers This application could make calls to external for example http services When it comes to functional testing we want to mock our caller service and control response it will return to us The rest of application should work in its normal mode When we have some kind of IoC container we could instantiate our application and then replace needed services in container with corresponding mock Thanks to separate definitions we dont need to manually call the whole dependency graph we just need to get the container with default definitions for each services and then replace needed with mocks Is there a way in wire to swap one dependency in the middle of dependency graph Is your feature request related to a problem Please describe Its difficult currently to use wire for conditional bindings or to delay instantiation of a bound type Im thinking along the lines of daggers support for Provider and Lazy Describe the solution youd like If wire can inject a type A it would be cool if it could also inject a func A Theres probably a better solution but without generics Im not sure what it would be For example lets say A is expensive to instantiate and I only want to do so if some condition is true This isnt right type A struct expensive things here var aSet wireNewSet wireStructnewA dependsOnA var someCondition bool func dependsOnAa A B we always pay the cost of instantiating A if someCondition do stuff with A do other stuff return a B What one would like is func dependsOnAaProvider func A B if someCondition a aProvider do stuff with A Describe alternatives youve considered Two alternatives Build separate graphs and use conditions do decide which injector function to use This isnt great if the dependency graph is complex and there are multiple types that need conditional or lazy instantiation since configuring the entire graph N different ways is tedious Generate separate injector functions for each lazyconditional thing and use those functions inside higher level provider functions Following the example above func dependsOnA B if someCondition a injectA this is a wire gend function do stuff with A Ive used two injector strategies in the past with guice for bootstrapping but its not a great to use use all over the place in an app because youll have multiple disconnected dependency graphs This is bad if A needs a B but B is also needed in a graph elsewhere I think some sort of wire analog to Lazy or Provider would also help with and It would be great if Wire would work out of the box with Bazel There could be a gowireinjector build rule that takes the source of the file containing the injector and generate a library that could be included as a dependency elsewhere The generated file could be left out uncommitted in the source code repository similar to how proto rules work Is your feature request related to a problem Please describe When building applications we might want to support different database drivers eg using Go CDK and using the inmemory docstore for development and mongo or firestore for production For the scenarios it would be useful if there was a way to conditionally generate code This does reduce flexibility but eases development especially when you are wiring up something that is unlikely to change often eg the database driver is unlikely to change without a recompilation anyway Describe the solution youd like When running wire the wire generator will execute conditionals at generation time eg if you have a switch on an env variable it would do a check based on the env variable set at the time wire was run Describe alternatives youve considered I have looked at the proposed solution of but this still causes problems since we then are back at needing to effectively build out the whole dependency ourselves Additional context Example of current conditional implementation wirego go wireBuild conversationsNewManager datastoreProvideCollection wireValuedatastoreCollectionNameconversations datastoreProvideContext return conversationsConversationManager nil datastorestorego go func ProvideCollectionctx contextContext name CollectionName docstoreCollection error switch osGetenvDBDRIVER case mongo return NewMongoCollectionctx ProvideHostName ProvideDatabaseName name case memory return NewInMemoryCollection return nil errorsNewtried to initialize invalid driver Desired configuration wirego go switch osGetenvDBDRIVER case mongo wireBuild conversationsNewManager datastoreMongoProviderSet wireValuedatastoreCollectionNameconversations datastoreProvideContext return conversationsConversationManager nil case memory wireBuildconversationsNewManager datastoreNewInMemoryCollection datastoreProvideContext return conversationsConversationManager nil return nil errorsNewtried to initialize invalid driver Describe the bug I am actually not sure this is a pure bug of mis configuration but since I googled and asked at some places and was not provided with any suitable answer I believe it is unexpected behavior Let me explain once in a while wire complains about the error on type that is for some reason now visible to it This scenario is particularly weird because it seems to treat two different types but because wire does not detect the type properly it tricks him to cause unrelated error of double definition in provider set This is the error serverconfiggo Configs has multiple bindings for invalid type current provider ProvideLiveMediaHandlerConfig serverconfiggo previous provider ProvideLivePostgresConfig serverconfiggo To Reproduce The configuration on those lines are these two providers ProvideLivePostgresConfig returns valid postgresSQL config instance func ProvideLivePostgresConfigc Config livemediaobjectPostgresSQLConfig return livemediaobjectPostgresSQLConfigDatabaseDSN cdatabaseDSN line ProvideLiveMediaHandlerConfig additional handler configs func ProvideLiveMediaHandlerConfigc Config livemediaobjectHandlerConfig return livemediaobjectHandlerConfigEnv cappEnv line Configs set mentioned in error is defined as Configs is a config provider to auto wire var Configs wireNewSetProvideLivePostgresConfig ProvideLiveMediaHandlerConfig Expected behavior I would expect it to provide the type returned when throwing error message invalid type is not telling anything for debugging Version githubcomgooglewire v Is your feature request related to a problem Please describe I have several controllers that I want to create These controllers all implement the type XX interface but are from different classes Currently I must create one function for each controller and then call them one by one to create an array of controllers and then pass this array of controllers to the router package The issue is all of them requires an instance of the same objects over and over this object is shared between them some validator and also an object related to the database I have this problem in another place with loading multiple keys in the system from various sources Usually when I need multipleinstance or implementation of an interface Describe the solution youd like When the providers provide type X more than one time and if the next consumer required a slice of type X or it uses then instead of error about multiple providers pass them in order of appearance in the list to the next function something like this go func base string return shared resource func p b string int return func p b string int return func p in int int sum for i range in sum in i return int sum func wireMe int panicwireBuildbase p p p the result should be something like this go func wireMe int s base this resource is shared between all of them return p p s p s Describe alternatives youve considered The only alternative is to write them one by one The problem is the base function in my example It should be some singleton in my use case or I should call it myself and pass the resource to all other function as a parameter Additional context None Describe the bug When using the headerfile flag the resulting generated file has the following go generate line go gogenerate wire This implies when someone later runs go generate the header file that was originally in the file will be removed To Reproduce sh wire headerfilepathtoheaderfile go generate Expected behavior After running wire with the headerfile flag running go generate again would not produce a delta Version v Additional context Describe the bug Panic when running wire To Reproduce Sorry I cant give a specific repro because I worked around it as soon as I ran into it Theres a lot of proprietary code involved and it would have been pretty hard to isolate The error was related to a bind statement wireBindnewInterface newConcrete I dont know what was unusual about this bind statement There was New function that returns a pointer to Concrete and Concrete implements Interface In I was able to use newConcrete but I had to change that to newConcrete after upgrading to and thats when the panic happened I hope that the following stack trace helps If not we might want to wait for someone to run into this again and provide a repro panic runtime error invalid memory address or nil pointer dereference signal SIGSEGV segmentation violation code x addr x pc x d goroutine running gotypesPackagePath homeusergosrcgotypespackagego githubcomgooglewireinternalwireobjectCacheget xc b x bb xc cc x x x x x homeusergopkgmodgithubcomgooglewirev internalwireparsego x d githubcomgooglewireinternalwireobjectCacheprocessExpr xc b xc a b xc cfdce x b x e xc a c x x x x homeusergopkgmodgithubcomgooglewirev internalwireparsego xfd githubcomgooglewireinternalwireobjectCacheprocessNewSet xc b xc a b xc cfdce x b xc a c x xc a xf xc ec x c homeusergopkgmodgithubcomgooglewirev internalwireparsego x a githubcomgooglewireinternalwireobjectCacheprocessExpr xc b xc a b xc cfdce x b x a xc a c xc a xf xf xc homeusergopkgmodgithubcomgooglewirev internalwireparsego x githubcomgooglewireinternalwireobjectCacheget xc b x bd xc a d x x x x x homeusergopkgmodgithubcomgooglewirev internalwireparsego x e githubcomgooglewireinternalwireobjectCacheprocessExpr xc b xc b b xc a x x a xc b b x x x c xc b e homeusergopkgmodgithubcomgooglewirev internalwireparsego xfd githubcomgooglewireinternalwireobjectCacheprocessNewSet xc b xc b b xc a x xc b e x xc b a x xc e x c homeusergopkgmodgithubcomgooglewirev internalwireparsego x a githubcomgooglewireinternalwireobjectCacheprocessExpr xc b xc b b xc a x x a xc b e xc b a x x xc homeusergopkgmodgithubcomgooglewirev internalwireparsego x githubcomgooglewireinternalwireobjectCacheget xc b x bd xc b x x x x x homeusergopkgmodgithubcomgooglewirev internalwireparsego x e githubcomgooglewireinternalwireobjectCacheprocessExpr xc b xc b e xc f eb x x a xc b a x x x b cc xc homeusergopkgmodgithubcomgooglewirev internalwireparsego xfd githubcomgooglewireinternalwireobjectCacheprocessNewSet xc b xc b e xc f eb x xc b xc b e x x x x homeusergopkgmodgithubcomgooglewirev internalwireparsego x a githubcomgooglewireinternalwiregenerateInjectors xc b f xc da x xc f a x x x xc c b homeusergopkgmodgithubcomgooglewirev internalwirewirego xaaf githubcomgooglewireinternalwireGenerate x ca xc d xc x xc c x x xc c b x x homeusergopkgmodgithubcomgooglewirev internalwirewirego x maingenCmdExecute xc eb x ca xc d xc a x x x x f cf e homeusergopkgmodgithubcomgooglewirev cmdwiremaingo x mainmain homeusergopkgmodgithubcomgooglewirev cmdwiremaingo x a exit status Expected behavior No panic Version Additional context Sorry too much proprietary code Hope theres something obvious that recently changed and the stack trace helps Problem Statement In production dependencies can misbehave in unexpected or unchecked ways For example a database module could fail to initialize quickly due to network error or a provider could loop infinitely due to programmer error In any case where the particular module is coded to block rather than fail fast this can lead to an entire application failing to start up or shut down cleanly Potential Solution I can imagine a number of ways to handle this case but there is one that seems simple and useful to me timeouts If specified in the wireinject code wire could generate code to perform a timeout on startup and also during cleanup Im not sure about the syntax but it could be something like wireWithTimeoutSomeProvider timeMinute It could also be global as a new parameter to wireBuild In either case the generated code would be surrounded by a select statement that fails when a timer expires Does wires current design already account for this use case Is it generally programmer error to perform longrunning effects in a provider or are there other legitimate use cases where a provider can fail to return in a timely manner Its common for constructor functions to return values that have a Close method thats used to clean up the values associated resources This doesnt fit easily with the convention used by wire of using a functyped return value This means its always necessary to add an adaptor function that returns a cleanup function that calls the Close method As a possible feature it might be possible to add a wire function that makes this easier Cleanup specifies that cleanupFunc should be used to clean up values of a given type The cleanupFunc argument must be of type funcT or funcT error where T is the type to be cleaned up If it returns an error the error value will be discarded For example wireBind openDatabaseFile openDatabase wireCleanuposFileClose func CleanupcleanupFunc interface Cleaner 