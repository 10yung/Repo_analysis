Often times especially with mock test data it is handy to ORDER BY rand or SELECT rand AS someName We have already implemented this functionality for MySQLs rand function and would do it for others if we are certain of their syntax etc We can submit a pull request for this feature but it is dependent on some of our other pull requests that have not been merged yet so please let me know how to proceed I took some time to separate and organize into pull requests some of my teams work on Squash that we thought you might like We hope these features are useful and are happy to answer any questions where you have them We closed a previous issue regarding generalizing FunctionExpression implementations as our work already includes this Thank you Description Adds common support for the SQL case expression Expressions of both common formats are supported Supported SQL CASE With Primary Operand Condition SQL sql CASE yesOrNo WHEN yes THEN ELSE END CASE Without Primary Operand Condition sql CASE WHEN yesOrNo yes THEN WHEN yesOrNo no THEN ELSE END Kotlin Example Taken from unit tests kotlin Note the use of the word Clause to avoid reserved words select caseStringliteral whenClauseliteral thenClauseliteralfalse whenClauseliteral thenClauseliteraltrue whenClauseliteral thenClauseliteralfalse elseClauseliteralfalse Testing A basic test case was added for this functionality but could be improved to include more varying conditions though this may not be necessary because it is ultimately using Expressions for most functionality related to the conditions and values Edited to include a kotlin example from unit tests Description This feature intends to generalize the creation of common FunctionExpression implementations within dialects It introduces a GeneralFunctionExpression class for functions that simply need a name and one value which could be used by any dialects to quickly add functions particularly aggregates As such this pull request also includes the average function as an addition to the BaseSQLDialect Testing Unit tests were added for the base aggregate functions however some adjustment was required to make it work generically for all databases as the types returned by the databases for an aggregate are not all the same Some returned a Long vs a Double for the average function for example This feature adds a computed default property to columns such that Squash can execute any logic required by the developer to generate the default value for a column Example One use case for this feature would be generating predictable identity columns as opposed to simply using autoincrement in MySQL It is common these days to use libraries like Twitter Snowflake or Flickrs ticket server to create primary keys and this feature serves to assist in that In an effort to cleanup the deprecation warnings we replaced calls to ClassnewInstance with ClassgetConstructornewInstance val dbConnection PgConnectioncreatejdbcpostgresqllocalhost mydb val transaction dbConnectioncreateTransaction updateTestEntityset TestEntityname BLEH RandomnextInt whereTestEntityid eq executeOntransaction transactioncommit This causes a postgres error Cannot commit when autoCommit is enabled C P Hikari and regular JDBC allows you to turn off autocommit on the connection itself Where would be a reasonable place to add such a property on PgConnection and its parent classes themselves val dbConnection PgConnectioncreate jdbcpostgresqllocalhost mydb ConnectionOptionsautoCommit false The workaround for now is to switch off autocommit on the DB level which is not always an option when using a DB hosted by someone else This happens on Postgres havent tried it on other databases I create a test table notice the defaultTEST on the namecolumn object TestEntity TableDefinitionname test val id integeridautoIncrementprimaryKey val name varcharname defaultTEST Now when I try and use this TableDefinition to generate a scema val trans DatabaseHandlercreateTransaction transdatabaseSchemacreatelistOfTestEntity I get the following error Exception in thread main orgpostgresqlutilPSQLException ERROR there is no parameter CREATE TABLE IF NOT EXISTS test id SERIAL NOT NULL name VARCHAR NOT NULL DEFAULT CONSTRAINT PKtest PRIMARY KEY id Arguments SQLArgumentindex valueTEST at orgjetbrainssquashdriversJDBCTransactionexecuteStatementJDBCTransactionkt at orgjetbrainssquashschemaDatabaseSchemaBasecreateDatabaseSchemaBasekt at TablesmainTableskt Caused by orgpostgresqlutilPSQLException ERROR there is no parameter at orgpostgresqlcorev QueryExecutorImplreceiveErrorResponseQueryExecutorImpljava at orgpostgresqlcorev QueryExecutorImplprocessResultsQueryExecutorImpljava at orgpostgresqlcorev QueryExecutorImplexecuteQueryExecutorImpljava at orgpostgresqljdbcPgStatementexecuteInternalPgStatementjava at orgpostgresqljdbcPgStatementexecutePgStatementjava at orgpostgresqljdbcPgPreparedStatementexecuteWithFlagsPgPreparedStatementjava at orgpostgresqljdbcPgPreparedStatementexecutePgPreparedStatementjava at orgjetbrainssquashdriversJDBCTransactionexecuteStatementJDBCTransactionkt more At the moment fromCitizens innerJoinCities Citiesid eq CitizenscityId selectCitizensname Citiesname the criteria can be deduced automatically fromCitizens innerJoinCities selectCitizensname Citiesname Or maybe even implicit join like in JOOQ In some applications you don t want to or you are not allowed to permanently remove a record from the database But you still need to remove or hide records which are no longer active One example could be a user account which you want to keep because it is linked to other business objects which are still used Typical story after an entity is marked with deletedtrue it should not be visible anywhere except specially chosen places