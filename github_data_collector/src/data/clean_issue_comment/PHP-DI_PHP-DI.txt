Hi I believe there is one usecase missing in the docs that I am not sure how to resolve Suppose I have Logger and Logger entities Both of them implement LoggerInterface I would like to inject both of them by interface ie inject Logger into Controller via an interface and inject Logger into Controller via an interface Is this possible via the arraylike definitions file The LoggerInterface in the docs deals with one Logger entity only Reproduce with php phpcsfixer rulesnativefunctioninvocation fix src allowriskyyes phpcsfixer from Details PR for Fix of The DefaultValueResolver currently gets executed before the TypeHintContainerResolver This causes type hinted parameters with default values always to resolve to the default value Thus its impossible to overload php functions with new parameters which requires any additional parameter to default to null in order to prevent the PHP warning Declaration of should be compatible with public function callService service null service is always null containersetServiceclass service containercall obj call Fix Containerphp needs to be changed from parameterResolver new ResolverChain new DefaultValueResolver new TypeHintContainerResolverthisdelegateContainer to parameterResolver new ResolverChain new TypeHintContainerResolverthisdelegateContainer new DefaultValueResolver Or Fix Allow for injecting a custom ResolverChain or a custom Invoker instance or class DI add does not function on nested arrays dont know if this behavior is by design and thus expected or not php originalDefinitions settings vowels a e i consonants b c d overrideDefinitions settings DI add vowels i o u consonants DI add f g h notice the add emojis builder new DI ContainerBuilder builderaddDefinitionsoriginalDefinitions overrideDefinitions builderbuildgetsettings Expected result php vowels i o u consonants b c d f g h emojis Actual result php vowels i o u consonants f g h emojis The result is the expected for vowels and emojis it is replacing and adding new items to the array On the other hand I expect consonants to be added to the array by using DI add what it actually happens is that DI add does not consider the previous array and creates a new one with the provided data mimicking the replacement done on vowels Hi is there a way to force explicit definitions with autowiring Something like this php builder new DI ContainerBuilder builderuseAutowiringfalse builderaddDefinitions App Fooclass DI autowire Actually it fails with DI Definition Exception InvalidDefinition Cannot autowire entry App Foo because autowiring is disabled This would benefit to compilation When the class gets destroyed in its life cycle the destruct method gets called and if theres one implementation in the original class the proxy class tries to execute the base class implementation But looks like the proxy class is getting destroyed before creating a instance for the base class and as theres no check for null values we get the following error Wed Jun Uncaught Error Call to a member function destruct on null in Projectpath var proxies ProxyManagerGeneratedProxyPMCLASSNAMEGenerated d f c dc a cbf f f d php Stack trace Projectpath vendor phpdi phpdi src Proxy ProxyFactoryphp ProxyManagerGeneratedProxy PM CLASSNAME Generated d f c dc a cbf f f d destruct Projectpath vendor phpdi phpdi src Proxy ProxyFactoryphp DI Proxy ProxyFactorycreateProxyCLASSNAME ObjectClosure Projectpath vendor phpdi phpdi src Compiler ObjectCreationCompilerphp DI Proxy ProxyFactorygenerateProxyClassCLASSNAME Projectpath vendor phpdi phpdi src Compiler ObjectCreationCompilerphp DI Compiler Obje in Projectpath var proxies ProxyManagerGeneratedProxyPMCLASSNAMEGenerated d f c dc a cbf f f d php on line The project path and class full qualified names were hidden because its a private project where the class is related to database connectivity That class just access authorization data and creates a new connection instance The destruct method implementation exists to ensure the connection will be closed when the class gets destroyed In this scenario the class was never used and thats why I believe its getting destructed before creating an instance for the original class ServiceLocator Serving lazy dependencies for classes using ServiceSubscriberInterface A ServiceSubscriber exposes its dependencies via static getSubscribedServices method A ServiceLocator instance could then be injected into a class via constructor or a property the instance would be already configured with dependences read from getSubscribedServices but the dependences wont be instantiated until first get thats how laziness is introduced DI Definition Reference checks if its a ServiceLocator entry by comparing its name with DI Definition ReferenceserviceLocatorClass Reference definitions are passed with additional parameter requestingName which generally points to name of the class which implements ServiceSubscriberInterface to resolve ServiceLocator for that class Suggested as a lightweight alternative for heavyweight proxies from ocramiusproxymanager note its based on changes from PHPDIPHPDI so commit a is included here as well since there is second argument passed to Reference constructor to also cover AnnotationBasedAutowiringreadConstructor method which was introduced in that PR Usage php class MyClass implements ServiceSubscriberInterface var ServiceLocator protected serviceLocator param ServiceLocator serviceLocator public function constructServiceLocator serviceLocator thisserviceLocator serviceLocator Lazy instantiate heavy dependencies ondemand public static function getSubscribedServices array return SomeClassclass heavyDependency HeavyServiceclass public function doOperation someClass thisserviceLocatorgetSomeClassclass return someClassdoSomething public function getSomethingFromThatHeavyDependency this method may be rarely used and it might be good idea to skip resolving the dependency every time during instantiation for performance reasons return thisserviceLocatorgetheavyDependencygetSomething from ovosPHPDI compile final function with injected dependencies only for closure factories for now as the first step Simple example before php return thisresolveFactorystatic function return bar factory now php return static function return bar More complex example before php return thisresolveFactorystatic function DI Factory RequestedEntry entry DI Container c dbName null parts explode entrygetName type parts if dbName null issetparts dbName parts parts false factory cget CMS Database ConnectionFactoryclass return factorycreatetype dbName dbmysql dbName NULL now php return static function DI Factory RequestedEntry entry DI Container c dbName null parts explode entrygetName type parts if dbName null issetparts dbName parts parts false factory cget CMS Database ConnectionFactoryclass return factorycreatetype dbName new DI Compiler RequestedEntryHolderdbmysql thisget cc bd c dc e NULL from ovosPHPDI run pregreplacecallback already during compilation from php protected function get ce da dc c return DI Definition StringDefinitionresolveExpressionpathcache BASEPATHapplicationcache thisdelegateContainer protected function get ce da dc c return DI Definition StringDefinitionresolveExpressionpathcacheapp pathcachefile thisdelegateContainer to php protected function get ce da dc c return thisresolveStringPlaceholderBASEPATH pathcacheapplicationcache protected function get ce da dc c return thisresolveStringPlaceholderpathcache pathcacheappfile where resolveStringPlaceholder proxies to thisdelegateContainerget from ovosPHPDI 