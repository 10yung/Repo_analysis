Hi I am trying to reproduce the example here using virtual machines ie client server router katran And the below diagram illustrates my environment I am using ubuntu with the kernel generic for the virtual machines client net router net katran net server net net net client ip katran ip server ip router ip net if net if net if The routing table of the router is as below dev ens proto kernel scope link src via dev ens dev ens proto kernel scope link src dev ens proto kernel scope link src dev ens proto kernel scope link src It seems the katran sends ipip packet correctly to the router after resolving VIP ie Here is a tcpdump from the router ef e c ethertype IPv x length tos x ttl id offset flags none proto IPIP length tos x ttl id offset flags DF proto TCP length Flags S cksum x ddd correct seq win options mss sackOKTS val ecr nopwscale length ef e c ethertype IPv x length tos x ttl id offset flags none proto IPIP length tos x ttl id offset flags DF proto TCP length Flags S cksum x df correct seq win options mss sackOKTS val ecr nopwscale length But the problem is the router cant forward ipip packets to the server It drops the packets before it calls the iprecv as shown the below kernel trace log I expect the networking stack of the router calls the iprecv function to handle ipip packet This is the log of kernel call trace from the router when it receives ipip packets swapper skbkfreeskb skbaddr xffff f protocol location xffffffffa e f fffa e kfreeskb kernelkallsyms fffa e f netifreceiveskbcore kernelkallsyms fffa e c netifreceiveskb kernelkallsyms fffa e f netifreceiveskbinternal kernelkallsyms fffa e c napigroreceive kernelkallsyms fffc a cprxpoll kernelkallsyms fffa e netrxaction kernelkallsyms fffa e softirqentrytextstart kernelkallsyms fffa b irqexit kernelkallsyms fffa a doIRQ kernelkallsyms fffa retfromintr kernelkallsyms fffa fa nativesafehalt kernelkallsyms fffa fa defaultidle kernelkallsyms fffa b archcpuidle kernelkallsyms fffa fa defaultidlecall kernelkallsyms fffa d db doidle kernelkallsyms fffa d cpustartupentry kernelkallsyms fffa b b startsecondary kernelkallsyms fffa d secondarystartup kernelkallsyms Am I missing something to config the router thx Junho Hi and sorry in advance for being naive I have an interesting application for Katran and was wondering if you could let me know whether you think Katran would be a good fit I need to collect and encapsulate packets relating to TCP sessions which may be received at any of a number of distinct geographically distributed egress points from a large IP network Packets returning from the internet relating to a particular TCP session may appear at any of a number of different edge routers Im wondering if I could install Katran in each egress data center and configure it to encapsulate each TCP session and route it to a consistent server within a centralized cluster of processing servers somewhere inside the network In reality the centralized cluster is itself a TCPtoTCP proxy that understands the relevant L protocol however we only need Katran to help with marshalling the packets from the edge Once were inside the network the networks fabric can route packets properly to their destination from the filtering servers It seems like this should be possible because from Katrans point of view whether Katran is literally at the top of the rack or in a completely different rack somewhere else in the world should make no difference Note that latency here is not a real concern given the underlying protocol we are proxying Big diff Major changes renaming XdpTester to BpfTester adding features to unittest BPFPROGTYPESCHEDCLS TC bpf adding into katran tester fixtures for healthchecking bpf program right now input and output are exactly the same for now it is being used either to make sure that prog is loaded and running somark in bpf program could be manually changed to some static value instead of somarkskbmark this is till would be available in vanila kernel adding new healthchecking bpf program this one forced to reshuffle some existing code so existing helpers would be bpf program agnostic eg before they were including balancermaps etc the new healthchecking program allow to directly create encapsulation of the healthcheck packet instead of relying on ip and ipv tunnel interfaces w external flag set TestedBy katrantester for healthchecking somark were manually set to and to force ipip and ip ip healthchecks generation ipip ethertype IPv x length tos x ttl id offset flags none proto UDP length udp sum ok UDP length ffdeadbeaf deadbeaf ethertype IPv x length tos x ttl id offset flags none proto IPIP length tos x ttl id offset flags none proto UDP length udp sum ok UDP length ethertype IPv x length tos x ttl id offset flags none proto TCP length Flags cksum x e correct seq ack win length HTTP ffdeadbeaf deadbeaf ethertype IPv x length tos x ttl id offset flags none proto IPIP length tos x ttl id offset flags none proto TCP length Flags cksum x e correct seq ack win length HTTP ip ip ethertype IPv x length tos x ttl id offset flags none proto UDP length udp sum ok UDP length ffdeadbeaf deadbeaf ethertype IPv x dd length hlim nextheader IPIP payload length fc fc tos x ttl id offset flags none proto UDP length udp sum ok UDP length ethertype IPv x length tos x ttl id offset flags none proto TCP length Flags cksum x e correct seq ack win length HTTP ffdeadbeaf deadbeaf ethertype IPv x dd length hlim nextheader IPIP payload length fc fc tos x ttl id offset flags none proto TCP length Flags cksum x e correct seq ack win length HTTP ethertype IPv x dd length hlim nextheader TCP payload length fc fc Flags cksum xfd f correct seq ack win length HTTP ffdeadbeaf deadbeaf ethertype IPv x dd length hlim nextheader IPv payload length fc fc hlim nextheader TCP payload length fc fc Flags cksum xfd f correct seq ack win length HTTP 