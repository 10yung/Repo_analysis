Currently our Nethereum library detects a functionABI using the keyword constant With Solidity ABIs generated will no longer have the constant keyword but is replaced with stateMutability view inputs internalTypestringnameatypestring stateMutabilitynonpayabletypeconstructorinputs internalTypeuint namenumbertypeuint namegiveMeNumberoutputs internalTypeuint nametypeuint stateMutabilityviewtypefunctioninputs internalTypeuint namenumbertypeuint namegiveMeStringoutputs internalTypestringnamesomeStringtypestring stateMutabilityviewtypefunctioninputs namemyNumberoutputs internalTypeuint nametypeuint stateMutabilityviewtypefunctioninputs internalTypeuint nametesttypeuint namesendMeMoneyoutputs stateMutabilitypayabletypefunctioninputs namesomeStringoutputs internalTypestringnametypestring stateMutabilityviewtypefunction Current Behavior Attempting to deploy also to interact with a contract will return an error Possible Solution We might want to look into supporting both constant for backwards compatibility and stateMutability when looking up FunctionABI I believe also the payable flag changed on the ABI too where for example payablefalse is deprecated in favour of stateMutabilitynonpayable Hi Im a beginner coin developer for use Nethereum need to install ethereum core Best Regards Ive got a solidity method that returns address function getAssetBuyer public view returnsaddress return buyerAddress The call from c Nethereum is public async Taskstring getBuyerAddress get the address of the buyer which included in the deal var getAssetBuyerFunction deployedContractIsntanceGetFunctiongetAssetBuyer var assetBuyerAddress await getAssetBuyerFunctionCallAsyncstring return assetBuyerAddress But the output is incorrect Nethereum return string in lower case letters Instead of x Bd dc e Ae D C CF C A Aac I get x bd dc e ae d c cf c a aac Remix at testnet returns x Bd dc e Ae D C CF C A Aac correct For anyone trying to crawl the chain and get the initial genesis it will simplify adding the genesis to Nethereum for information as probably Genesis Transactions like Etherscan does Detailed Description In my Net Core project I have created an API to check eth balance using Nethereum Each API call will open a new TCP connection to RPC and doesnt dispose it after In linux it will generate too many closewait connection then eventually crash due to error of Too many open files in system ERROR MicrosoftAspNetCoreServerKestrel Connection id HLRNQKQ FLGR Request id HLRNQKQ FLGR An unhandled exception was thrown by the application NethereumJsonRpcClientRpcClientUnknownException Error occurred when trying to send rpc requestss SystemNetHttpHttpRequestException Too many open files in system SystemNetSocketsSocketException Too many open files in system at SystemNetSocketsSocketctorAddressFamily addressFamily SocketType socketType ProtocolType protocolType at SystemNetSocketsDualSocketMultipleConnectAsyncctorSocketType socketType ProtocolType protocolType at SystemNetSocketsSocketConnectAsyncSocketType socketType ProtocolType protocolType SocketAsyncEventArgs e at SystemNetHttpConnectHelperConnectAsyncString host Int port CancellationToken cancellationToken Screenshots Current Behavior This will open a new connection each time but doesnt terminate or dispose it after Expected Behavior Should dispose and terminate the web connection Possible Solution Allow to dispose the web Issue tracker is ONLY used for reporting bugs New features questions and support should be discussed on our gitter channel first Gitter Current Behavior When the JSON RPC payload size return from Ethereum is mulitplies of we will get this exception below NethereumJsonRpcClientRpcClientUnknownException Error occurred when trying to web socket requestss NethereumJsonRpcClientRpcClientTimeoutException Rpc timeout after milliseconds SystemThreadingTasksTaskCanceledException The operation was canceled SystemIOIOException Unable to read data from the transport connection The IO operation has been aborted because of either a thread exit or an application request SystemNetSocketsSocketException The IO operation has been aborted because of either a thread exit or an application request End of inner exception stack trace at SystemNetSocketsSocketAwaitableSocketAsyncEventArgsThrowExceptionSocketError error at SystemNetSocketsSocketAwaitableSocketAsyncEventArgsGetResultInt token at SystemNetSecuritySslStreamInternalFillBufferAsyncgInternalFillBufferAsync TReadAdapter TReadAdapter adap ValueTask task Int min Int initial at SystemNetSecuritySslStreamInternalReadAsyncInternal TReadAdapter TReadAdapter adapter Memory buffer at SystemNetHttpHttpConnectionReadBufferedAsyncCoreMemory destination at SystemNetHttpHttpConnectionRawConnectionStreamReadAsyncMemory buffer CancellationToken cancellationToken End of inner exception stack trace at SystemNetHttpHttpConnectionRawConnectionStreamReadAsyncMemory buffer CancellationToken cancellationToken at SystemNetWebSocketsManagedWebSocketEnsureBufferContainsAsyncInt minimumRequiredBytes CancellationToken cancellationToken Boolean throwOnPrematureClosure at SystemNetWebSocketsManagedWebSocket Private TWebSocketReceiveResultGetterTWebSocketReceiveResult Memory payloadBuffer CancellationToken cancellationToken TWebSocketReceiveResultGetter resultGetter at NethereumJsonRpcWebSocketClientWebSocketClientReceiveBufferedResponseAsyncClientWebSocket client Byte buffer End of inner exception stack trace at NethereumJsonRpcWebSocketClientWebSocketClientReceiveBufferedResponseAsyncClientWebSocket client Byte buffer at NethereumJsonRpcWebSocketClientWebSocketClientReceiveFullResponseAsyncClientWebSocket client at NethereumJsonRpcWebSocketClientWebSocketClientSendAsyncRpcRequestMessage request String route End of inner exception stack trace at NethereumJsonRpcWebSocketClientWebSocketClientSendAsyncRpcRequestMessage request String route at NethereumJsonRpcClientClientBaseSendInnerRequestAsync T RpcRequestMessage reqMsg String route at NethereumJsonRpcClientClientBaseSendInnerRequestAsync T RpcRequest request String route at NethereumJsonRpcClientClientBaseSendRequestAsync T RpcRequest request String route We suspect this code will make additional read call which cause this RpcClientTimeoutException eventually The variable bytesRead will be in this situation if lastByte bytesRead return signalled with a line feed or just less than the full message bytesRead else bytesRead await ReceiveBufferedResponseAsyncclient bufferConfigureAwaitfalse Possible Solution WebSocketReceiveResultEndOfMessage can help us to check if the message is well received or we shall take additional read call to get left message from server We can make ReceiveBufferedResponseAsync to return WebSocketReceiveResult object directly do receiveResult await ReceiveBufferedResponseAsyncclient bufferConfigureAwaitfalse if receiveResultCount memoryStreamWritebuffer receiveResultCount while receiveResultEndOfMessage false I am trying to transfer ether to a contract and from contract to another account So far I succeded to run the solidity code in Remix using javascript VM and injected web contract deployed on RemixMetamask too I succeded to send ether to the contract using Nethereum but when it comes to triggering the transfer function in Nethereum its not working nothing happen Here is the Solidity code pragma solidity contract MyFirstContract function external payable function getBalance public view returnsuint return addressthisbalance function sendaddress payable to uint value public returns bool requirevalue addressthisbalance totransfervalue return true And Nethereum code Infura Ropsten var contractAddress xEf cFd E cA D ab F BBd var transactionHash x b c ab e ca ec deee b d fa cc e b var contractABI var senderAddressTest accAccountAddress var recipientAddressTest x dfD E ceCb C AeA Cb D C Ef var senderPrivateKeyTest accAccountPassword var accountTest new NethereumWeb AccountsAccount senderPrivateKeyTest var web Test new Web accountTest accAccountNetwork accInfuraApiKey var contractTest web TestEthGetContractcontractABI contractAddress var transaction await web TestEthGetEtherTransferServiceTransferEtherAndWaitForReceiptAsynccontractAddress m new BigInteger This function sends ether to the contract It worked and confirmed on ropstenetherscanio var function contractTestGetFunctionsend var wie the ether I want to send from the smart contract for example object parameters new object recipientAddressTest wie var result await functionCallAsyncboolparameters I guess this line initiates the send function it work on Remix but not in Nethereum However the result is true strange and recipientAddressTest doesnt get ether etherscan didnt update too Is it possible to deploy a smart contract in Nethereum using Infura I know we cannot use web PersonalUnlockAccountSendRequestAsync because Infura doesnt hold private keys but Nethereum allow us to use their Account object var account new AccountprivateKey In addition the command await web MinerStartSendRequestAsync doesnt compiled because Miner doesnt exist Haim WARNING this PR depends in part on previous PRs which are primarily subscription based fixes and unit tests Before these changes the existing RPC integration tests can not be run easily or reliably They depended on data only present on specific local test nets Some tests were failing as they were out of date with current clients The aim was to to run this suite of tests against different clients local or hosted and to be more consistent with other integration tests in Nethereum This will allow the tests to be run in CI against geth and parity and therefore raise problems related to new client versions Different RPC tests are more suited to one test net than another To avoid heavy duty test data setup routines which are likely to be fragile most tests now use a hosted test net to provide data particularly for subscription tests Efforts have been made to reference as little static data as possible to ease future maintenance Some tests target the local test net as hosted test nets do not support all RPC methods A few tests target mainnet to provide known reliable data Environmental Variable Based Client Configuration Test settings are driven by the ETHEREUMCLIENT environmental variable eg geth parity This is the same variable the Ethereum Client Integration Fixture references NOTE Whilst running tests in Visual Studio on Windows the ETHEREUMCLIENT environmental variable which I had set via setx in the command line was not being picked up I added a class and a setup step to ensure user environmental variables which are user targeted or stored in the launchSettingsjson file are loaded TestSettingsCategory Each unit test defines a test settings category localTestNet hostedTestNet live The combination of the current client and category determines the settings at run time Current Configuration via testSettingsjson WHEN ETHEREUMCLIENT is geth localTestNet geth via Ethereum Client Test Fixture hostedTestNet geth via Infura against Rinkeby live infura against mainnet WHEN ETHEREUMCLIENT is parity localTestNet parity via Ethereum Client Test Fixture hostedTestNet parity via Infura against Ropsten live infura against mainnet New integration tests for reactive and event based subscriptions They target rinkeby as they require a source of frequent blockchain data which is faster than live Test settings configuration has changed in this PR to support the subscription tests BUT it is only a transitional change MVP is you like A forthcoming PR applies configuration changes for all RPC integration tests and allows the same suite of tests to be run against different client ie geth and parity based upon the ETHEREUMCLIENT environmental variable