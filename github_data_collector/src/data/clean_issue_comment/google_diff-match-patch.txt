This is a great library Unfortunately it has been ambiguous about what input it wants to accept and what it wants to output That is while we know that its character based we dont have a definition of character The Lua library even makes it clear that since Lua is unaware of Unicode then it will treat content as as a series of bytes not a series of characters This ambiguity has caused numerous problems for folks wanting to interchange delta strings and gets us into tricky situations when dealing with emoji and other characters which are encoded as surrogate pairs in UTF Consider this example A B a We can all agree that what happened is that we entered a a in between the two existing characters Some libraries produce this delta ta t Python Python when compiled in wide mode Most libraries produce this delta ta t Python when compiled in narrow mode JavaScript ObjectiveC Java I didnt check the others This seems like enough to highlight the disparity in indexing and length calculations I propose a new nonbreaking change to indicate what the index and length values are measured in In my own work in I discovered that clients are fine decoding in fromDelta a blank insertion group Therefore I propose that we send blank insertion groups at the front of a delta to indicate what the indexing and length values correspond to There are only three realistic measurement units Unicode code points probably what would have been most ideal to use from the start UTF code units because most platforms and languages use this internally bytes because thats the most agnostic way of measuring this In addition we should point out that the legacy behavior is to not report measurement units In my proposal wed stick a number of empty insertion groups at the front of a delta to indicate which of those measurement units wed want in the order above one group to indicate Unicode since unicode is the nominal way to think about text here two groups to indicate UTF code units since these are twobyte characters three groups to indicate bytes because I dont know what to do about Lua other than to make it obvious and no groups to indicate an unreported measurement identical to all existing deltas Measurement units Delta Unicode code points t ta t UTF code units t t ta t Bytes t t t a t Unspecified one of the above without the prefix Note that these diffs should might work in all existing libraries to produce the same result as they would without the leading groups However this gives us a chance to update fromDelta to support the denoted measurement units and then we can slowly migrate the client libraries to support returning their deltas in a requested unit Im reading the line diff and word diff section of the wiki It is stated to make a copy of linesToChars and call it linesToWords it would be great if this was built into the library already But for now is there a sample implementation of linesToWords in JavaScript Fixes Alternate to Fixes for Java JavaScript Objective C Python Python Status Please scrutinize the code and think of any test cases not covered already in this patch Weve deployed these changes in Simplenote and are uncovering any issues we can find Please let us know your thoughts on the direction here This is a pragmatic patch in that its addressing the problem where its at and tries to impose no new constraints on the library where possible Major changes in toDelta we no longer attempt to create URIencoded strings with split surrogates this was either crashing client applications or corrupting the data depending on which platform was in use in fromDelta we are recovering when possible from corrupted delta strings produced by unpatched versions of this library there are two fixes sometimes we encode surrogatepair halves as if they were valid Unicode they arent well now decode those anyway because after applying a diff with these invalid code points we should rejoin the surrogate halves and get valid Unicode out in unpatched ObjectiveC libraries we might have created invalid diffs where we send null in between two surrogate halves this is caused by the original bug and we might receive these sequences in a delta string high surrogatenulllow surrogate If we leave these in here then diffmatchpatch will operate fine but it will send invalid Unicode that it created onto the consuming application in this patch Ive added guards against this very specific pattern so that we can remove the unintentionally injected null and rejoin the surrogate halves this means that were mangling the input but that input would have already been mangled anyway and presumably itd be impossible to send the same sequence of code units to diffmatchpatch since something would have had to send invalid Unicode in the first place Working on this bug has surfaced a bigger question about what diffmatchpatch expects All of the Simplenote applications work at the level of UTF code units and a large part of that is because this is how most of the diffmatchpatch platforms work Something seems ideal about referencing Unicode code points in diffmatchpatch instead of any particular encoding but to change now seems like it would break way more than it would fix Id like to propose that we think about creating a new output version which could be selected to specify that diffs do that difftoDelta diffmain no specification means existing behavior F F B difftoDelta diffmain unit native existing behavior whatever the unit of a string is F F B difftoDelta diffmain unit ucs make UCS the default since most libraries used it already or something F F B difftoDelta diffmain unit codePoint empty addition group at the beginning to denote Unicode indices F F B empty group ignored by old clients Sometimes we can find a common prefix that runs into the middle of a surrogate pair and we split that pair when building our diff groups This is fine as long as we are operating on UTF code units It becomes problematic when we start trying to treat those substrings as valid Unicode or UTF sequences When we pass these split groups into toDelta we do just that and the library crashes In this patch were postprocessing the diff groups before encoding them to make sure that we unsplit the surrogate pairs The postprocessed diffs should produce the same output when applying the diffs The diff string itself will be different but shouldnt change that much only by a single character at surrogate boundaries Notes This is my first contribution to this repo and Im obviously not familiar with the style and this patch is obviously incomplete My purpose is to propose code with working tests to demonstrate the change and I expect to clean up any remaining details that need resolving Ive pulled in the surrogate tests that josephrocca added and they are all passing In the issue causing these failed tests was using isSurrogate for all cases when we should have been using isHighSurrogate and isLowSurragate depending on the context Thanks for any and all help and feedback I tried to use python version diffmatchpatch to visualize my ocr experiment result aka difference between gt and prediction If I just follow the instruction dmp dmpmodulediffmatchpatch diff dmpdiffmainfile file html dmpdiffprettyHtmldiff The result doesnt make sense at all Just now I realize the reason is that the default timeout is set to second and files Im trying to compare are too long I only need to add dmpDiffTimeout to make the code work Its kind of strange that there was no notification that told me the operation was timed out I feel that at least the code should notify user that your last operation timed out if it happened Without the notification I suspected that the problem was on the encoding of strings to be compared and wasted a lot of time debugging Ported the Javascript version of diffmatchpatch into Typescript x I ported the JavaScript tests All tests passing x I checked in the generated Typings declaration dts x I also checked in the compiled UMD binary for those wanting to directly import that into their projects To run tests cd typescripttests tsc node builttestsdiffmatchpatchtestjs node builttestsspeedtestjs Did anyone use this with angular The following PR makes the JS algorithm aware of surrogate pairs and will avoid splitting a pair into two different Diff objects I think there might be more places which needs to be surrogatepairaware but I havent been able to find test cases to confirm this Fixes encodeURI blows up for some patchobj Example js let diffmatchpatch requirediffmatchpatch let text let text let diff new diffmatchpatch consolelogdiffpatchtoTextdiffpatchmaketext text using STL stringcontainer to replace QT code add Make file and all tests passed