When clipping a mesh with the method TriangleMesh DOperationsclip one would assume that all the points of the mesh which satisfy the given predicate are part of the resulting clipped mesh However the way it is currently implemented is that only the points which satisfy the predicate and are part of a triangle are clipped In Scalismo we do not enforce that every point in a mesh is part of a triangle Indeed it is perfectly valid in Scalismo to create a mesh with an empty triangle list Therefore we should not assume or enforce that all points are part of a triangle in the clip mesh function The same problem most likely occurs when clipping tetrahedral meshes There seems to be an issue with the PivotedCholesky in that for many input computeApproximateEig demonstrates chaotic behavior ie a tiny variation in the input produces large variation in the output This is not a matter of indeterminacy the code is deterministic it is just sensitive to tiny variations of input Here is some code to demonstrate this val p ds for until yield Point D DenseVectorrand Double toArray val variancesA DenseVectorrand Double toArraytoIndexedSeq val variancesB for v variancesA yield v e without the e the difference is val gk ds for s variancesA variancesB yield GaussianKernel D s val ik ds for k gk ds yield DiagonalKernelk val tol PivotedCholeskyRelativeTolerance e val dms dvs for ik ik ds yield PivotedCholeskycomputeApproximateEigik p ds tolunzip val dmdiffs for i until yield dmsi dmsitoArraytoIndexedSeq val dvdiffs for i until yield dvsi dvsitoArraytoIndexedSeq printlnfor x dmdiffsflatten dvdiffsflatten yield mathabsxsum Note that this test code is random and does not always demonstrate the instability but usually does Furthermore the instability itself does not necessarily make an error in the result of the computation using PivotedCholesky But whether or not the instability directly produces an error in the output it seems an undesirable property of PivotedCholesky particularly since it makes the generation of LowRankGaussianProcesses effectively randomized in practice Thanks for sharing your code Currently tests are broken when one or more spaces are contained in the absolute path to the project folder The returned path of the resource then contains the escaped sequence instead of spaces A fix could be to use a URLDecoder to transform the paths such the are decoded with spaces again The default Pivoted Cholesky stopping criterion PivotedCholeskyRelativeTolerance can experience a NotConvergedException when using a very small dataset The following code will in most of the runs throw an error when using the default stopping criteria If the stopping criteria instead is set to be numberOfEigenfunctions data then it consistently works scala val model StatismoIOreadStatismoMeshModelnew Filemodel bfmnomouth h get val ref modelreferenceMesh val data to mapf modelsample printlnsdata length datalength val dc DataCollectionfromMeshSequencereferenceMesh ref registeredMeshes data get val dcGpa DataCollectiongpadc StatisticalMeshModelcreateUsingPCAdcGpa NumberOfEigenfunctionsapplydatalength get printlnpca computed StatisticalMeshModelcreateUsingPCAdcGpaget NotConvergedException printlnpca computed Full error message might need to run multiple times to get the error message depends on the samples that are drawn from the BFM Exception in thread main breezelinalgNotConvergedException at breezelinalgsvdbreezelinalgsvddoSVDDoublesvdscala at breezelinalgsvdSvdDMImplapplysvdscala at breezelinalgsvdSvdDMImplapplysvdscala at breezegenericUFuncapplyUFuncscala at breezegenericUFuncapplyUFuncscala at breezelinalgsvdapplysvdscala at scalismonumericsPivotedCholeskycomputeApproximateEigGenericPivotedCholeskyscala at scalismonumericsPivotedCholeskycomputeApproximateEigPivotedCholeskyscala at scalismostatisticalmodelDiscreteLowRankGaussianProcesscreateUsingPCADiscreteLowRankGaussianProcessscala at scalismostatisticalmodelStatisticalMeshModelcreateUsingPCAStatisticalMeshModelscala at scalismostatisticalmodelStatisticalMeshModelcreateUsingPCAStatisticalMeshModelscala at appsbfmPCAtestmainPCAtestscala at appsbfmPCAtestmainPCAtestscala meshtriangulationadjacentTrianglesForPoint currently results in a IndexOutOfBoundsException when accessed for a pointId not belonging to any cell same for adjacentPointsForPoint The reason is that the pointIds used for the computation of this array are obtained by iterating over the cells only This comes from the assumption that the meshes read into Scalismo must be correct ie without any floating vertices This condition is however not enforced at read time Here we should either enforce that meshes are correct at read time eg throw an exception and request to activate a repair flag or fix the arrays above to return an empty Seq TriangleId for a point not belonging to any cell As of now SSM only allows for rigid transformations The suggestion is to extend to also allow for similarity transform At first perform a rigid transform and then a scaling transform for the basis vectors according to the computed scaling factor between original and target landmarks as done in similarity DLandmarkRegistration Reference mesh and mean deformation field should also be updated Update the VTK library to the newest version This will allow running headless mode thereby avoiding X forwarding diceCoefficient from MeshMetricsscala should be modified at least with a grid sampler that does not rely on a random number of samples It would be useful if one could combine some additional attributes such as the subjects age weight height gender or even some properties of the shape itself eg length or width of the bone together with the shape model An example use case of such a combined model would be to complete a fractured bone by conditioning the model not only on the observed healthy part but additionally on the patients attributes age weight length of the contralateral bone etc which should improve the completion results The method presented in this paper could for example be used in the implementation generalized to all shapes not just faces The function PivotedCholeskycomputeApproximateEigGeneric takes a parameter D It is from the outside not clear what this parameter does and why it is needed Either it has to be documented or if possible hidden from the interface 