It would be great if the default StreamLogHandler would honour LOGLEVEL environment variables To change the loglevel I currently have to do this dance right swift LoggingSystembootstrap label in var handler StreamLogHandlerstandardOutputlabel label handlerlogLevel trace return handler Because StreamLogHandler hardcodes its level to info swift public var logLevel LoggerLevel info It would be nice if that would at least default to the setting of the LOGLEVEL environment variable ideally w supporting LOGLEVELlabel as well Essentially swift public var logLevel LoggerLevel let env ProcessInfoprocessInfoenvironment return LoggerLevelrawValue LOGLEVEL label LoggerLevelrawValue LOGLEVEL info Maybe w a little more caching Expected behavior Currently MultiplexLogHandler mutates all registered handlers to the same log level permitting fallthrough granularity would be useful for distributed systems Example st Handler logLevel trace stdout pipe local storage nd Handler logLevel info external endpoint analytic processing backend rd Handler logLevel critical external endpoint urgent sysadmin alert gateway SwiftLog versioncommit hash swiftlog I experience a Catalyst problem is there a solution or workaround Expected behavior I expected the library to work also in a combined iOSmacOS project Catalyst Actual behavior I created a lightweight wrapper around the lib and put it into a Log Swift Package For import Logging the compiler tells Logging is not available when building for Mac Catalyst Consider using if targetEnvironmentmacCatalyst to conditionally import this framework SwiftLog versioncommit hash The Packageswift content for the Log wrapper import PackageDescription let package Package name Log products Products define the executables and libraries produced by a package and make them visible to other packages library name Log targets Log dependencies Dependencies declare other packages that this package depends on packageurl package url from packageurl from targets Targets are the basic building blocks of a package A target can define a module or a test suite Targets can depend on other targets in this package and on products in packages which this package depends on target name Log dependencies testTarget name LogTests dependencies Log Swift OS version output of swift version uname a Xcode A c Swift macOS iOS Expected behavior Milestones should be in sync with released versions Actual behavior We released but no such milestone exists exist and is not closed etc Proposal When closing tickets always assign a milestone When releasing a version ensure tickets or PRs if no ticket present for PR are assigned to milestone Close milestone link to it from release notes I think it matters a lot to be clean and consistent here We should start with cleaning up the existing issues releases I can take this on WDYT tomerd weissi Lets link to by jordanebelanger Would you want to submit a PR adding a link to it to the section jordanebelanger Id like to use Lock in a custom LogHandler implementation but am unable to because Lock is declared as internal in Locksswift Was Lock intended to be used like this Expected behavior Under Special cases in the API docs here the example implementation LogHandlerWithGlobalLogLevelOverride has a property overrideLock Lock Actual behavior This is not possible if the custom LogHandler implementation eg LogHandlerWithGlobalLogLevelOverride is defined in another module as Lock is internal and not visible there SwiftLog versioncommit hash version Swift OS version output of swift version uname a Apple Swift version swiftlang clang Target x appledarwin Title and end goal of ticket changed to add some examples see discussion below for detail edit ktoso I was looking into creating a FileLogHandler but I am unsure of a safe and convenient way to go about doing that due to issues inherent with logging to files vs something like stdout with the current limitations of this framework For example there is no available throwable factory overload and nowhere is it documented that a logger requires an initializer that takes a single String argument Looking through the code it becomes much easier to see that you need some kind of an initializer that takes a single string argument Why is there no official protocol requirement for the initializer if this is clearly a requirement I want to make a FileLogHandler but with the current standard functionality everyone would just be accustomed to passing in a label I could just log in a common location like varlog on linux but people should be able to specify a custom file location if they so choose The Logger initializer that takes a LogHandler argument is internal so I cannot use that and the restrictions on the factory signature are too restrictive to allow this I could make the String parameter the path to the log file but since it is not throwable or nullable I cannot do any sort of validation that the path exists or is writable by the current process Do I just silently fail Should I just print a message Why are there no throwablenullable overloads for the factory or why is there no ability to use a custom factory signature The fileprivate restrictions make it more difficult to provide my own handy extensions to achieve my desired functionality Is there something Im missing here or was there just massive oversight when designing this From what I can tell it would be extremely difficult to set up a logger that sends logs to an external service requiring connection parameters and theres no way you could validate those parameters during initialization of the handler LoggingSystembootstrap must only be called once per process One might assume to bootstrap the logger in XCTestCasesetUp but this can be called multiple times and will result in an assertion To get around this a global lazy variable can be used that is asserted in each setUp method It will only be run once the first time it is accessed allowing for logging to be configured in XCTests Declare the global variable like so swift let isLoggingConfigured Bool LoggingSystembootstrap label in var handler StreamLogHandlerstandardOutputlabel label handlerlogLevel debug return handler return true Then in your XCTestCases use like so swift import XCTest final class FooTests XCTestCase override func setUp XCTAssertisLoggingConfigured We should consider documenting this or providing some sort of helper add link to cocoapod to readme see Hello This is more like a pitch not an issue at all and it s probably too late However I d like to have a custom handler for oslog something like this works fine for debugging purposes even though it s using private API swift import os import SwiftOSOverlayShims func log level LoggerLevel message LoggerMessage metadata LoggerMetadata file String function String line UInt dso UnsafeRawPointer args CVarArg let ra swiftoslogreturnaddress messagewithUTF Buffer buf UnsafeBufferPointerUInt in bufbaseAddresswithMemoryReboundto CCharself capacity bufcount str in withVaListargs valist in swiftoslogdso ra selflogfromlabel selftypefromlevellevel message valist Unfortunately the current log signature misses dsoHandle and args using file function and line instead What do you think about adding two more arguments to the log function Or maybe you have some alternative suggestion Thanks in advance