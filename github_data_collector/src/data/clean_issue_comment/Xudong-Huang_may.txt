That is when I was running benchmark on my MacBook Pro inch i GB DDR The result is x slower than even it is running in release mode What are the possible tunings I missed Tokio is switching to a new scheduler implementation Read Making the Tokio Scheduler x faster for the details As such it would be nice if a new comparisonbenchmark of between May and Tokio could take place as it means that the Performance section of the current README will become outdated Using gdb or something else Its quite important for debugging Is there a performance comparison with go language Just read and it makes a really compelling case for the combination of stackful coroutines proper linux AIO and eventually SPDK support This is a combination I could actually imagine myself using in sled where Im now trying to scale toward a manycore architecture but dont want to pay the various ergonomic costs associated with the popular async stuff in the rust ecosystem right now may be a nice reference for building linux AIO support for May Would you be interested in having AIO support in May directly or do you see this as something better implemented in a separate library Very curious about this we can use this API to wrap the code that would run for a long time or would block a thread when the API is invoked the worker thread would become a normal thread and it will kick another thread to continue scheduling on the worker queue when the API is invoked in the IO thread it would first rescheduling to a worker thread It would be great if there was a Postgres client library for may Thanks for considering could use a ReadVWriteV extension trait for the new interface The current scheduler has the following problems it needs configuration workers ioworkers runonio it would be nicer if user does not need to configure anything and yet get maximum performance all the time it has a global ready list scaling to anything other than a few cores and this will become a bottleneck timer thread is also global another point of contention event loop is on a separate thread Both and cause unnecessary OS context switches whenever there is a timer expiry or IO poll I propose the following design for a new scheduler which I plan to implement This is a request for comments My understanding of may is not that deep so it is possible that some things wont work may has N schedulers S where N is the number of CPUs of the machine each S runs on its own kernel thread each S has a single threaded eventloop coros waiting for io and a timerlist coros waiting on timer each S has its own readylist which contains coroutines ready to run crossbeamdeque workstealing each S has its own yieldlist coros that yielded and can resume immediately may has a single list of parked threads parked may has a counter of stealing threads numstealing The scheduling loop will look like this rust loop when yieldlist is not empty this means we have coroutines the yielded but are ready to run as such we do need to check the eventloop and return as fast as possible let timeout if schedyieldlistempty else schednextdeadline now while let Someco yieldlistpopback schedreadylistpushco select moves ready coroutines to the local readylist each ready coroutine is pushed to the front schedeventloopselecttimeout if we have more than coroutine ready to run and there are no threads stealing and we have parked threads unpark one to increase parallelism if schedreadylistlen numstealingloadOrderingAcquire parkedempty if let Somet parkedpop tunpark run all coros until readylist is empty while let Someco schedreadylistpop runcoroutineco we have cpu bound coroutines that yielded restart the loop to make more coroutines readyexpire timers etc if selectyieldlistempty continue we have no ready coroutines to run time to steal assertschedreadlistempty numstealingfetchadd OrderingRelease see implementation below if schedsteal continue we didnt manage to steal anything which means there is nothing to do numstealingfetchsub OrderingRelease parkedpushthreadcurrent threadpark To make stealing fast and avoid spurious parkunpark we spin for a while trying to steal and then give up rust fn steal mut self let deadline now ms needs tuning loop let id rand N random victim if id selfid stealing from ourselves is silly p continue else let stolen loop match schedules id readyliststeal StealEmpty break None StealDataco break Someco StealRetry if let Someco stolen selfreadylistpushco return true if now deadline return false 