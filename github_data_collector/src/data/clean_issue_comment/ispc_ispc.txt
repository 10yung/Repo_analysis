Main Changes are Updated latest llvm version to a Since has branched but released using the temporary branch in alloy Has to update this once official release happens LLVM moved openmp to a new library frontendopenmp Modified Cmake to add this Changes in headers caused us to add some new headers setjmp and longjmp deprecated and removed From what I understand they have not been supported for a while now Hence the complete removal BasicBlockPass removed in llvm switched to FunctionPass Alignment no longer use integer values have to use llvmMaybeAlign Here is some code which has valid ISPC syntax but causes LLVM to die C void MyFuncuniform int x printHello n x struct MyObject void MyFuncPtruniform int export void TestMain MyObject obj objMyFuncPtr MyFunc uniform int x objMyFuncPtrx export void TestMainBroken uniform MyObject obj The only difference objMyFuncPtr MyFunc uniform int x objMyFuncPtrx When assigning a function pointer to a uniform struct the output is Assertion failed getOperand getType castPointerTypegetOperand getTypegetElementType Ptr must be a pointer to Val type file c iusers aneshlya llvmrelease llvm llvm lib ir instructionscpp line Though it passes all the syntax checks Sample code fragment const uniform float uniform src srcpixels for uniform unsigned int i i width i programCount float r g b a aostosoa src i r g b a fails to compile with the following error Error Unable to find any matching overload for call to function aostosoa Passed types const uniform float uniform varying float uniform varying float uniform varying float uniform varying float uniform casting the first argument to uniform float uniform fixes the error Is it possible to add AMD znver znver architecture support I observed the following error while building ispc from sources using the buildsh script on a Raspberry Pi Model B running bit Raspbian buster OS on a bit aarch Linux kernel Trying to configure release version ERROR Fatal error cant configure release version I observed the following error while building ispc from sources using the buildsh script on a Raspberry Pi Model B running Raspbian buster OS on a bit armv l Linux kernel Generating builtinsc linuxarmv cpp clang warning unknown platform assuming mfloatabisoft clang warning unknown platform assuming mfloatabisoft In file included from builtinsbuiltinsc In file included from usrincludeunistdh usrincludefeaturesh fatal error syscdefsh file not found include syscdefsh Please see minute of the following video on my YouTube channel for an occurrence of this specific error I observed during the build process The buildsh script completed producing an ispc binary However none of the ispc examples would compile with the resulting binary Execution mask and loop termination condition is not being efficiently evaluated for forwhiledo loops on AVX targets export void whilelooptestuniform float cmp uniform float vout uniform int count foreach index count varying float c cmp index whilec c c vout index c targetavx knli x assembly LBB foreachfullbody leal rax ecx movslq ecx r vmovups rdir zmm vcmpnleps LCPI rip to zmm k kortestw k k je LBB vpternlogd zmm zmm zmm k z vpmovdb zmm xmm LBB forloop vaddps LCPI rip to zmm zmm vpcmpeqb xmm xmm xmm vpmovsxbd xmm zmm vptestmd zmm zmm k vmovaps zmm zmm k vcmpnleps LCPI rip to zmm k vpternlogd zmm zmm zmm k z vpmovdb zmm xmm vpand xmm xmm xmm vpcmpeqb xmm xmm xmm vpternlogq zmm zmm zmm vpmovmskb xmm ecx testw cx cx vmovaps zmm zmm jne LBB jmp LBB LBB in Loop HeaderBB Depth vmovaps zmm zmm LBB forexit targetavx skxi x assembly LBB foreachfullbody leal rax ecx movslq ecx rcx vmovups rdircx zmm vcmpnleps LCPI rip to zmm k kortestw k k je LBB vpmovm b k xmm LBB forloop vaddps LCPI rip to zmm zmm vptestnmb xmm xmm k vmovaps zmm zmm k vcmpnleps LCPI rip to zmm k vmovdqu xmm xmm k z vptestmb xmm xmm k kortestw k k vmovaps zmm zmm jne LBB jmp LBB LBB in Loop HeaderBB Depth vmovaps zmm zmm LBB forexit The SKX target looks a bit cleaner due to the AVX VLBW instructions but there is still no reason to use byteword instructions to manipulate the mask The loop entry test in both cases uses optimal instructions While compiling for an avx knli x target it appears suboptimal code is being generated for simple comparisons of varying int types float comparisons appear to use efficient instructions The issue is occurring with the binary but can also be reproduced on Godbolt with multiple ispc versions Examples below illustrate float and int cases float code export void floatcompareuniform float vin uniform float cmp uniform float vout uniform int count foreach index count varying float v vin index varying float c cmp index if c v v v else v sqrtv vout index v float assembly foreach full body section LBB foreachfullbody cltq vmovups rdirax zmm vcmpnleps rsirax zmm k kortestw k k je LBB vmulps zmm zmm zmm k LBB foreachfullbody jb LBB vsqrtps zmm zmm vmovaps zmm zmm k vmovaps zmm zmm LBB foreachfullbody vmovups zmm rdxrax addl r d addl eax cmpl r d r d jl LBB cmpl ecx r d jl LBB int code export void intcompareuniform float vin uniform int cmp uniform float vout uniform int count foreach index count varying float v vin index varying int c cmp index if c v v v else v sqrtv vout index v int assembly foreach full body section LBB foreachfullbody movslq r d r vmovups rdir zmm vpsrad rsir zmm vpmovdb zmm xmm vpcmpeqb xmm xmm xmm vmovdqa zmm zmm vpternlogq zmm zmm zmm vpmovmskb xmm eax testw ax ax je LBB vmulps zmm zmm zmm vpmovsxbd xmm zmm vptestmd zmm zmm k vmovaps zmm zmm k vmovaps zmm zmm LBB safeifaftertrue vpcmpeqb xmm xmm xmm vmovdqa zmm zmm vpternlogq zmm zmm zmm vpmovmskb xmm eax testw ax ax je LBB vsqrtps zmm zmm vpmovsxbd xmm zmm vptestmd zmm zmm k vmovaps zmm zmm k vmovaps zmm zmm LBB ifdone vmovups zmm rdxr addl r d addl r d cmpl r d r d jl LBB cmpl ecx r d jge LBB The expected output for the int case would replace the vcmpnleps instruction with a vpcmpd variant Note the avx skxi x target also seems affected Currently the list of target types only seems to include one i target for the x ISA SIMD extensionssse i x host sse i x sse i x sse i x sse i x sse i x sse i x avx i x avx i x avx i x avx i x avx i x avx i x avx i x avx i x avx knli x avx skxi x avx skxi x genericx genericx genericx genericx genericx genericx genericx neoni x neoni x neoni x neoni x Are there any plans or blockers stopping support for targets such as avx skxi x or avx i x These would be especially useful when making kernels that deal with text and image data Right now ispc returns the following assembly with O targetavx skxi x c int funcint a int b return a b funcvytvyt funcvytvyt vpaddb xmm xmm xmm ret It is only using the xmm registers adding x at a time when it could be adding x at a time and doing the equivalent of mm addepi with the zmm registers I could possibly be misunderstanding these flags though and avx skxi x means it will try and force a bit addition to use bit additions which would involve a lot more code moving around than usual How would I try and get ispc to emit the more optimal bit arithmetic though VS Code Plugin support LSP It is undermaintained currently Eg the plugin doesnt support remote editing