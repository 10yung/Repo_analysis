 To read the bytes from timerfd we use Glibcread directly but we should use try Posixread instead which would ve made debugging incredibly straightforward We should probably also go through the codebase and find other uses of DarwinGlibsyscall rather than Posixsyscall outside of Systemswift read returning EINVAL is a bug in NIO and we should assertprecondition that it doesnt happen similar to what we do for EBADFEFAULT on all syscalls See for an example where that happens If the user returns a future from a different event loop from EventLoopscheduleRepeatedAsyncTask will cause a precondition in NIO Thats a bug test case that shows the issue swift func testRepeatedTaskOffFuture let elg EventLoopGroup MultiThreadedEventLoopGroupnumberOfThreads defer XCTAssertNoThrowtry elg syncShutdownGracefully let elg EventLoopGroup MultiThreadedEventLoopGroupnumberOfThreads defer XCTAssertNoThrowtry elg syncShutdownGracefully let g DispatchGroup var callNumber genter let task elg nextscheduleRepeatedAsyncTaskinitialDelay nanoseconds delay nanoseconds task in struct Dummy Error callNumber switch callNumber case return elg nextmakeSucceededFuture case gleave return elg nextmakeFailedFutureDummy default XCTFailshouldnt be called callNumber return elg nextmakeFailedFutureDummy taskbeginin nanoseconds gwait The ByteBuffer String API is tied to the concrete String type Would be nice to allow arbitrary StringProtocol values most importantly substrings SwiftNIO versioncommit hash Swift OS version output of swift version uname a any Changed the HTTP response flow preconditions to allow for continue heads Motivation Channel handlers need to be able to respond to Expect continue requests Easy to reproduce w curl eg curl verbose F a F b Trying TCPNODELAY set Connected to localhost port POST HTTP Host localhost UserAgent curl Accept ContentLength Expect continue need to be able to respond to this ContentType multipartformdata boundary c d e HTTP Continue w the patch HTTP OK ContentType texthtml transferencoding chunked Without the patch curl still works but will wait a second or so w sending the request body until some timeout Other clients may just timeout BTW Not sure maybe NIOHTTP needs the same patch Modifications This doesnt change any actual code just the incorrect assumptions in the preconditions continue heads can be sent multiple times until the actual response head is sent out Result Channel handlers can write continue heads to the NIOHTTP pipeline Once the snapshots are available on swiftorgdownload we should CI with them Theyre not available right now yet but the swift branch is cut CC Lukasa tomerd shahmishal Motivation Using pread and calculating file offsets should usually be preferred to using the kernels seek pointer because its often faster and there is no interference from reads happening on other threads For some reason we didnt support this yet in NIO Modifications Use support pread where possible Result Faster better and happier vlm Actual behavior After the issue I started to dig into the implementation of base The results of that work can be found at fabianfettswiftbase While implementing decoding I tested the performance of my implementation against Foundation Since I wanted to base my work on the Base encoding provided by NIOWebsocket I also tested its performance Surprisingly its rather slow Encoding k times the bytes from to produced these results On my MacBook Pro GHz Intel Core i Number of invocations Encoding Foundation took s NIOWebsocket took s On Linux Foundations performance isnt great either Therefore the performance hit compared to Foundation is not as bad Encoding Foundation took s NIOWebsocket took s Base took s If possible minimal yet complete reproducer code or URL to code The code to reproduce can be found the branch comparewithniowebsocketbase at fabianfettswiftbase Performance results on GitHub actions can be seen in the Performance Tests Not great for detailed measuring but we are of the target by quite a margin in this case Looking into the issue with Instruments Im quite sure the performance hit is based on the use of the UnicodeScalar that seem to come with some memory overhead img width altScreen Shot at src SwiftNIO versioncommit hash commit hash ac e bccd ab f e ef b code unchanged since Feb Swift OS version output of swift version uname a Target x appledarwin Darwin xxx Darwin Kernel Version Thu Jun PDT rootxnu RELEASEX x we should create a bunch of structs called NIOAtomicBool NIOAtomicInt NIOAtomicInt NIOAtomicUInt which clearly document that they have reference semantics To start with they should be implemented with NIOAtomic and once Swift supports them we should implement them with the upcoming stdlib atomics