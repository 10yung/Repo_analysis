Some completion result types can be reliably assumed to be the end of an input chunk and followed by a space so insert that space automatically when appropriate eg a ProviderItem is unlikely to have anything except a space following it as it is the end of a path so insert the space with the path Implements which has more details on the idea Currently there are no tests written for this but all existing ones pass Im also not sure if it should be behind an option Allow filtering of results by keys used in binding Closes Environment data PS version rc PSReadline version rc os WinBuild PS file version HostName ConsoleHost BufferWidth BufferHeight Steps to reproduce or exception report run SetPSReadLineOption EditMode Vi type abc type kbdEsckbd type cffcc exception will be thrown Exception SystemInvalidOperationException Operation is not valid due to the current state of the object at MicrosoftPowerShellPSConsoleReadLineStartEditGroup at MicrosoftPowerShellPSConsoleReadLineGroupUndoHelperStartGroupAction instigator Object instigatorArg at MicrosoftPowerShellPSConsoleReadLineViReplaceLineNullable key Object arg at MicrosoftPowerShellPSConsoleReadLineProcessOneKeyPSKeyInfo key Dictionary dispatchTable Boolean ignoreIfNoAction Object arg at MicrosoftPowerShellPSConsoleReadLineViChordNullable key Object arg at MicrosoftPowerShellPSConsoleReadLineProcessOneKeyPSKeyInfo key Dictionary dispatchTable Boolean ignoreIfNoAction Object arg at MicrosoftPowerShellPSConsoleReadLineInputLoop at MicrosoftPowerShellPSConsoleReadLineReadLineRunspace runspace EngineIntrinsics engineIntrinsics CancellationToken cancellationToken psreadline psreadline Termux for android Fedora The cursor can be often misplaced which could be caused by the resizing of the window when the inputpad becomes activeinactive Its very possible related to PSReadLine as it works fine when PSReadLine is unloaded This happens in Termux an Android terminal emulator and Linux environment application Aarch Fedora are installed Related issue Screenshot Screenshot Given that the decision has been made to require and integrate an external module PSReadLine for command handling its confusing PowerShellPowerShell PowerShellPSReadLine and redundant to have two copies of the history and the commands which modify history should be made to optionally modify both Right now the PowerShell History is numbered and supports reinvoking via InvokeHistory or r and also via tabcompletion like Tab but PSReadLine owns the hotkeys and search The PSReadLine history is persistent but only the PowerShell History has commands to importexportclear it which allow one to modify whats stored in the history in the case one accidentally types something one doesnt want logged Obviously theres a substantial difference between them architecturally since PSReadLines history only contains the actual commandlines but the actual history retrieved by GetHistory includes the status as well as the start and end time However this dichotomy combined with the use of bashsimilar aliases history and r etc and hotkeys which sometimes return different or no results is confusing and should be resolved ideally by having the history commands work on or appear to work on the same size persistent history buffer as PSReadLine Perhaps a blend of menu complete and history searching seems to be a common ask Using SetPSReadLineOption EditMode vi viModeIndicator Cursor on Windows Terminal does not display any differences based on the mode you are in Its likely due to Windows Terminal accepting the DECSCUSR escape sequence as opposed to whatever Windows Console supported Just raising a potential issue When LengthInBufferCells is used to estimate the buffer cells that an entire line will consume it can be inaccurate when a doublewide character lands with only cell remaining at the edge of the buffer Functions such as ConvertOffsetToPoint and ConvertLineAndColumnToOffset do account for this The most likely places this will cause a problem is in trying to calculate where on the screen needs to be cleared after rendering an edited line Environment data PSReadLine beta Windows Windows PowerShell or PowerShell Core Steps to reproduce Produce a command line whos last character is a CJK doublewidth character and the command line is just one character from wrapping Then edit the command line to include one more character before the CJK and the CJK will roll to the next line but the newly inserted character is not added Furthermore when the extra character is removed and the CJK character rolls back on to the first line its not completely removed from where it was shown on the second line I think this might all have to do with some blanking assumptions and the wrong spots are being blanked at the wrong time Demonstrating and Cursor position does not correlate to the steps After step there should be only blank at the end of the first line I added another f Note I have no idea what CJK character I copied and pasted when testing another issue The following documentation item would seem to imply that SaveIncrementally would allow the history to be used between sessions immediately SaveIncrementally save history after each command is executed and share across multiple instances of PowerShell Environment data PSReadLine beta PowerShell preview Windows Insiders Steps to reproduce Start multiple sessions simultaneously enter commands in each and afterwards use kbdUpArrowkbd to attempt to find each others commands in different sessions The only result I get is that a new session created after all the commands in the different sessions will see all the history in the order they were entered