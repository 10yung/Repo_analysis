cling based C as scripting language hot code reload Why Able to run C script in runtime or compile it for max speed as in example HOT code reload possible approaches store app state fix cling undo for files execute cling code to change callbacks variables nested clingInterpreter with multiple clingMetaProcessor IDK how to do it but you can create child clingInterpreter I see there are no versions and releases so users must use bleeding edge or a fork of Oryol and all dependencies It seems to me that in order to properly support versions you must tag all dependencies then change fipsyml to point to the appropriate tags Its somewhat of a grunt work but I think its important to allow users work without the risks involved with always using bleeding edge This will also allow safe tagging of stable versions which may be useful for breaking changes for example the one in the sokolgfx pull request An added benefit will be the ability to git bisect which with luck you will never have to use PS But according to Murphys law the only way to guarantee you will never use something is to invest effort in making it So theres that laughing I just updated Mojave and tried to built my project which has been working great I now get these errors Any suggestions Oryols RTTI doesnt work properly in Emscripten when using dynamic libraries A simple test case moduleh class Module public RefCounted OryolClassDeclPlugin OryolBaseTypeDeclPlugin public virtual Module class ModuleOfSpecificType public Module OryolClassDeclModuleOfSpecificType OryolTypeDeclModuleOfSpecificType Module public virtual ModuleOfSpecificType virtual void doSomething sidemoduleh class SideModule public ModuleOfSpecificType OryolClassDeclSideModule OryolTypeDeclSideModule ModuleOfSpecificType OryolClassCreatorSideModule public virtual void doSomething If the class SideModule is used in well a side module in Emscripten and then dlopened by the main code and constructed via eg extern C PtrModule create return new Module and dlsymsidemodule create is used to instantiate it and get a PtrModule named m if mIsAModuleOfSpecificType On desktop this code is run On Emscripten not so much mDynamicCastModuleOfSpecificTypedoSomething If thats changed to use a raw pointer access and manual cast eg ModuleOfSpecificTypempdoSomething then it works fine Importantly it works on native platforms and it works with a manual cast The only thing thats broken is the RTTI I suspect that Emscripten gives each module its own address space which makes Oryols RTTI fundamentally incompatible with Emscripten with libdl A possible solution once the module support is added behind a Fips option have that option also change to a different RTTI implementation that functions differently One idea that occurs to me if its possible to override specific templates which IIRC it is the RTTI can be changed to overload for the specific class I have a program that launches a group of Luabased plugins The plugins are instantiated in parallel that is there are a number of threads that set up the plugins However I came upon an assertion failure when using IOLoad to load in the Lua scripts as apparently IOLoad can only be called from the thread IOSetup was called from Is there any way to change this so that IO can execute on other threads Summary I added a mat uniform to my vertex shader I assigned it an identity matrix so I was surprised when my mesh stopped displaying I replaced the uniform by the literal identity mat vec vec and the mesh displayed correctly So I checked with Nvidia Nsight and I found the issue My uniform declaration glsl uniform params mat viewProj mat model My uniform data looks like this params on the GPU Address Data x x x x x x The generated vertex shader tries to initialize the mat like this mat params xy params xy According to the data it should be mat params xy params zw Test case Overview the project only has two source files Shader code in codeshadersglsl Uniforms applied in codeBattleAppcc BattleAppOnRunning c Update parameters thismainVSParamsviewProj viewProj thismainVSParamsmodel glmmat thismainDrawStateFSTexture MainShadertex thistexBG Render GfxApplyDrawStatethismainDrawState GfxApplyUniformBlockthismainVSParams GfxDraw Generated files shadersh shaderscc Vertex shader contents If an item to be added is a reference to an item in the same container and the container needs to grow the item reference will be invalid and a memory corruption might happen Detect if the container needs to grow and create a copy of the item before growing I read to the bottom of the pipelines doc and reached its rather anticlimactic conclusion Im having a casual play with Oryol this summer and hopefully will do something more substantial with it next summer after exams Im not a C programmer let alone a game developer so the documentation is really useful Added Center button to the GamepadState printout in the TestInput sample Added gamepad mapping for Nintendo Wii U Pro Controller on glfw Linux