Have a look at the docs on Middleware It reads public typealias MiddlewareState escaping DispatchFunction escaping State But the code is public typealias MiddlewareState escaping DispatchFunction escaping State escaping DispatchFunction DispatchFunction As a quickfix we could put the definition on one line and silence SwiftLint I tried to run the latest jazzy v locally but the result was the same I files realmjazzy I find the idea of Redux on iOS very very VERY cool and try to find the right framework for me to start with this architecture ReSwift seems to have more coverage on medium youtube etc but I like SwiftRex very well documented and pretty interesting as well what are the main differences here Hi guys Faced with such a question how can I implement screen navigation control in swiftUI I think I need to insert the pattern into the SceneDelegateswiftThank You Im seeing a crash when calling storesubscribeself using the latest package via Swift Package Manager img width altScreenshot at src Attached is a bare bones project that reproduces the error It seems to land on x b d f in StoreinitreducerstatemiddlewareautomaticallySkipsRepeats at UsersnodediggityLibraryDeveloperXcodeDerivedDataReSwiftExampleczegixqbdykoeuftxdzkpeylbnfnSourcePackagescheckoutsReSwiftReSwiftCoreTypesStoreswift img width altScreenshot at src Im running Xcode Version B You should be able to reproduce the crash simply by building the attached project ReSwiftExamplezip Are you going to support SwiftUI Any example Thanks Im curios how people are handing form states during reducer state changes For example I have a login form that takes fields username and password On submission I dispatch an action storedispatchLoginRequestpayload initusername username password password I have middleware that picks up this action and makes an async request to my auth provider On success or failure I dispatch the appropriate action dispatchLoginRequestSuccesspayload initaccessToken refreshToken or dispatchLoginRequestFailurepayload initsomeerror Currently my reducer looks something like this swift func authenticationReducer action Action state AuthenticationState AuthenticationState var state state AuthenticationState guard action is AuthenticationAction else return state switch action case as LoginRequest stateform dispatching case let action as LoginRequestSuccess stateaccessToken actionpayloadaccessToken staterefreshToken actionpayloadrefreshToken stateform success case let action as LoginRequestFailure stateform fail stateerror actionpayloaderror default break return state Based on stateform in my view controller I disable the form show a loading indicator show an error alert or reset the form and trigger a navigation This works really however I have a few concerns authenticationReducer should really only be concerned with auth state not ui concerns such as form state I have numerous forms related to login auth reset password recover username trigger multi factor and so on these additional states will all cause my reducer to grow and grow My actions become tied to my forms should I create an action to refresh my tokens I know need to pretty much duplicate LoginRequestSuccess to set new tokens in my store Ideally Id like my actions to be as generic and flexible as possible Coming from the React Redux world I used Redux Form quite heavily this let me keep track of form state in its own separate reducer and provided callbacks such as onSubmitSuccess and onSubmitFail which allowed me to keep my ui state within the ui layer not mix my auth and form states Backstory mjarvis started this in about years ago The way the ReSwiftStore is set up his initial approach created a subscription right away I suggested and tried to help with an approach where apps would have a PendingSubscription that only at the subscribe call would be added to the Store But this didnt work out well in practice and both Malcolm and I have practically given up for the time being With my recent adventures into the realm of making Middleware calls simpler I experimented with another way to dispatch actions and found it would fit ReSwift quite well This is a sample call swift storesubscription select substateanotherSubstate skipRepeats subscribe This code heavily borrows concepts and implementation from RxSwift I had quite some trouble wrapping my had around the concepts to be able to implement them properly A couple of notes regarding the reactive nature aka how the inversion is done State updates are passed on as events in a reactive sequence aka ObservableState State update events are produced via a BlockSubscriber it forwards newState calls to a block which is set from the outside as a callback to pass events down the Observable stream using Observablecreate Observablecreate sounds like youd create the event stream itself similar to creating arrays but it aint so Instead you define the connectionsubscription from Observable to its Observer counterpart In fact every transformation operator select filter skipRepeats adds another Observer on top that forwards events to the next one The observable sequence is really a chain of observers passing on events starting with the initial connection you specify in Observablecreate The actual StoreSubscriberType in an app is not subscribed to the store anymore just the BlockSubscriber is the apps subscribers receive updates via the observableobserver chain BlockSubscriber is prepared in Observablecreate to be subscribed to the store itself but the subscription is only executed when a connection happens This is fun and also weird because I think about the creation first like a hot sequence that just begins pumping out events just but it is actually executed very late and in some sense lazily By using Observable and its observers you can model transformations with operators without actually having a functional store subscription I left extensive comments in the code to make sense of the subleties of memory management I still want to get rid of most parts of it The dual of an Observable operator and its Sink which is just an observer that applies the transformations and conditionally forwards the result to the next in the chain will probably stick But the Producer type wrapping each steps objects in a cancelable objects with strongly references to its parts maybe we can ditch that kind of stuff Important types IncompleteSubscription I went with mjarviss API starting with Storesubscription IncompleteSubscriptionStoreState StoreState The IncompleteSubscriptionRootStoreState Substate tracks the root state type of the store so you cannot create an IncompleteSubscription in one store and stuff it into another unless both use the same state type select operations modify the Substate associated type accordingly while RootStoreState stays the same IncompleteSubscription is the userfacing API Observables and such are internal implementation details Each operation replaces its underlying ObservableSubstate SubscriptionToken Problem with hiding the actual subscription to the store in a hidden BlockSubscriber is that users cannot unsubscribe the real subscriber They only know the object they passed in Lets call the one users own the userfacing subscriber I created SubscriptionToken to introduce a different state update mechanism in addition to notifiying all subscribers You can unsubscribe each token individually like regular subscribers You can also still call Storeunsubscribe with the userfacing subscriber and all corresponding tokens will be removed The tokens keep a strong reference to the observable connection represented by the Disposable type it receives the dispose command when the token is deallocated This breaks the connection and eventually frees the underlying BlockSubscriber as well Things I know are still missing add tests for Filter if we need that operator at all that is test if it crashes expectedly or works properly from multiple threads remove the v SubscriptionBox types etc that introduced the old transformations and revert this to the most basic ReSwift v Subscriptions We still need these for the BlockSubscriber to receive events unless we remove the whole objectbased subscription thing completely from the public API avoid double skipRepeats if automaticallySkipRepeats is enabled figure out if the latest operator is a skipRepeats as well a simple boolean for IncompleteSubscription could do or an type association to the SkipRepeats operator type itself Id love to have your feedback on this PRs to the branch of this PR are also very welcome if you want to play around with it This is specifically for an archive build It fails with these errors ld warning Could not find or use autolinked library swiftSwiftOnoneSupport ld warning Could not find or use autolinked library swiftCore ld warning Could not find or use autolinked library swiftCoreGraphics ld warning Could not find or use autolinked library swiftObjectiveC ld warning Could not find or use autolinked library swiftFoundation ld warning Could not find or use autolinked library swiftDarwin ld warning Could not find or use autolinked library swiftCoreFoundation ld warning Could not find or use autolinked library swiftDispatch Undefined symbols for architecture armv It can be fixed by either upping the target to iOS Or by adding LApplicationsXcodebetaappContentsDeveloperToolchainsXcodeDefaultxctoolchainusrlibswift iphoneos to the link line in build settings This could totally be an Apple issue but it could also be something with Swift and ReSwift and Xcode So finally decided to play around an implementation of something approaching connect decorator from ReactRedux Was initially made for ReKotlin by our Android team but works the same with ReSwift Its mostly syntax sugar but our end goal is to make the getter on storestate unavailable so no more free access to the global store it should all be in your component local Props struct The StoreConnector implementation swift class StoreConnectorProps Equatable StoreSubscriber private var props Props nil private let mapStateToProps AppState Props private let render Props Void initmapStateToProps escaping AppState Props render escaping Props Void selfmapStateToProps mapStateToProps selfrender render storesubscribeQueueself skipRepeats weak self oldState AppState newState AppState Bool in selfprops selfmapStateToPropsnewState internal func newStatestate AppState props mapStateToPropsstate guard let props props else return DispatchQueuemainasync selfrenderprops func unsubscribe storeunsubscribeself deinit storeunsubscribeself And now some example usage swift class SomeComponent private struct Props Equatable let items ObjectId FeedItem let datasource ObjectId private var props Props didSet Actually do you refreshrender private var storeConnector StoreConnectorProps func viewDidLoad storeConnector StoreConnectorPropsmapStateToProps state Props in return Propsitems statefeedStateitems datasource statefeedStatefeeds id render weak self props in selfprops props What do you guys think I use ReSwifts middleware a lot as I consider it one of the killer features of this library and Ive always wondered why the getState function we pass to the middleware returns the state as an optional value having to write the boilerplate of unwrapping it every time we want to access it which is super annoying Ive been thinking about this and in theory it doesnt need to be like that as we always supposed to have a nonoptional state once weve instantiated the store either because we pass a preloaded state to it or because each reducer creates its own initial value after the init action has been dispatched which happens at stores init time In fact you will never see anyone checking if the state is not null before accessing it in the original Redux library written in the super dangerous JavaScript This past weekend Ive been trying to make the changes needed to make getState nonoptional and after accommodating the code a bit and adding a couple of tests Ive realised this is not possible a priori so we can avoid a retain cycle that would make the store impossible to deallocate Ive been trying to use the techniques described here but I couldnt make it work What do you think Should this be possible at all