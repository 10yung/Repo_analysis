after upgrading the gem to latest started seeing unexpected behaviour on throttlers rolling back to fixes the issue but that version is far behind Could not find time to look deep on where it happens Redis is used locally and production at the gem throttles properly example send reqs and set limit at reqs only one reqs gets allowed same test on xx allows sometimes reqs Setting the limit to reqs and sending reqs on releases allows sometimes reqs which can bring bad expectations Hi When upgrading the gem from to weve seen a huge increase in calls to redis our cache store This has also increased latency Was this change intentional why does this happen Request count from NewRelic attached The grey line represents the release of the version with the upgraded gem incrby ttl and get are the ones that went way up Ive bumped by ruby recently to and now my rails is not starting up at all Removing class RackAttack makes the server run as expected without issues I am using Rails and rackattack version Here is how my configuration looks like class RackAttack Ignore in development and test environments return unless Railsenvproduction Blacklist This IP was by extremely aggressive scraper RackAttackblocklistip Configure Cache If you dont want to use Railscache RackAttacks default then configure it here Note The store is only used for throttling not blacklisting and whitelisting It must implement increment and write like ActiveSupportCacheStore RackAttackcachestore ActiveSupportCacheMemoryStorenew Throttle Spammy Clients If any single client IP is making tons of requests then theyre probably malicious or a poorlyconfigured scraper Either way they dont deserve to hog all of the app servers CPU Cut them off Note If youre serving assets through rack those requests may be counted by rackattack and this throttle may be activated too quickly If so enable the condition to exclude them from tracking Throttle all requests by IP rpm Key rackattackTimenowtoiperiodreqipreqip throttlereqip limit period minutes do req reqip unless reqpathstartwithassets end Prevent BruteForce Login Attacks The most common bruteforce login attack is a bruteforce password attack where an attacker simply tries a large number of emails and passwords to see if any credentials match Another common method of attack is to use a swarm of computers with different IPs to try bruteforcing a password for a specific account Throttle POST requests to userssignin by IP address Key rackattackTimenowtoiperiodloginsipreqip throttleloginsip limit period seconds do req if reqpath userssignin reqpost reqip end end Throttle POST requests to userssignin by email param Key rackattackTimenowtoiperiodloginsemailreqemail Note This creates a problem where a malicious user could intentionally throttle logins for another user and force their login requests to be denied but thats not very common and shouldnt happen to you Knock on wood throttleloginsemail limit period seconds do req if reqpath userssignin reqpost return the email if present nil otherwise reqparams email presence end end Custom Throttle Response By default RackAttack returns an HTTP for throttled responses which is just fine If you want to return so that the attacker might be fooled into believing that theyve successfully broken your app or you just want to customize the response then uncomment these lines selfthrottledresponse lambda do env status headers body end end What happens is that I get these errors depending on whats not commented out undefined method blocklistip for RackAttackClass NoMethodError undefined method throttle for RackAttackClass NoMethodError Im experiencing some odd behavior while attempting to pass a proc as an argument to a throttle period I tried following the suggestion to use a proc by ktheory in as my use case is very similar The following code appears to work fine for me ruby periodproc proc Timenowendofmonth Timenowtoi RackAttackthrottledaily peruser throttle limit period periodproc do request business logic end However when I changed the periodproc above to use endofday instead the value is calculated properly but each request seems to result in a new throttle being created and the count value never surpasses ruby periodproc proc Timenowendofday Timenowtoi RackAttackthrottledaily peruser throttle limit period periodproc do request business logic end My understanding is that the ID showing up in the logs corresponds to a current throttle period and a new one is created after a current throttle period expires This ID was being incremented on each new request even though the period had not ended Cache increment rackattack Cache increment rackattack The ID using the endofmonth code remained consistent as far as I saw Out of curiosity I tried using endofweek and the count would reset seemingly sporadically creating showing an incremented ID when the count went back to without hitting the limit It seems that the problem is actually occurring in each scenario but when the proc yields lower values it happens more reliably My guess is that something is busting the cache but Im not sure why or how to explain the discrepancy in behavior Im using v of the gem on Ruby with ActiveSupportCacheDalliStore Any guidance is very much appreciated Upon upgrading to from we end up with RackAttack twice in our middleware stack Actual behavior rails middleware use RackHead use RackConditionalGet use AuthenticatorPartOne use RackAttack our intended RackAttack instance use AuthenticatorPartTwo use RackAttack the duplicate now added in that we dont want run OurAppApplicationroutes Expected behavior rails middleware use AuthenticatorPartOne use RackAttack our intended RackAttack instance use AuthenticatorPartTwo run OurAppApplicationroutes As you can see our specific case involves a twophase authentication middleware stack that is specifically designed to surround RackAttack so we cannot move RackAttack to the end of the stack where it installs itself by default I see that was intended to turn the second instance into a noop but wed much prefer avoiding the double load to begin with Given the need to configure RackAttack anyway one could argue against autoloading the middleware However Id like to instead propose a couple of ways to allow disabling the autoload for advanced configurations like ours while preserving it as the new default behavior Add a config option RackAttackautoload true Defaults to true When false the initializer would skip the autoload Rework the gems default require by moving most of librackattackrb into a new file Replace the original file with nothing but ruby require rackattacknewfile require rackattackrailtie if definedRails This would allow advanced configurations to set the Gemfile as ruby gem rackattack require rackattacknewfile which would implicitly disable the autoload railtie Either way preserves your new default while adding a path for more specific configuration for those of us with apps with advanced middleware configurations Are you open to either of the above solutions If at least one is acceptable Im happy to prepare a PR accordingly if thatd be helpful FWIW either of the above would also allow the removal of the alreadycalled condition return if env rackattackcalled added in which I think may breakprevent PR Using thread locals is the simplest implementation in this case I can think of Closes This can be used as ruby use RackAttack do throttlerequests by ip limit period do request requestip end blocklistblock all access to admin do request requestpathstartwithadmin end selfblocklistedresponse lambda do env Blocked end end The code is a little bit more complicated than it should be as Im not broke old style of reopening RackAttack I would prefer to remain only new style of configuring but then this will force all gem users to update their RackAttack settings and recently added feature of using middleware automatically would not make sense Maybe this makes more sense for release New tests and documentation are missing would add them after agreeing on implementation Closes This is a work in progress failing tests missing new tests and documentation but basically is ready for review to verify basic ideas To add new adapters all is needed is inheriting from base class and implementing required methods ruby module Rack class Attack class MyStoreAdapter StoreAdapter Closes Hello there today while exploring GitHub looking for interesting projects found yours and I would love to contribute by designing a logo for it Im a designer in development and an open source enthusiast We would be working together to create the design that fits best Of course its totally free and you can quit whenever you want In case you agree please let me know any preferences you may have about colors shapes etc Kind regards