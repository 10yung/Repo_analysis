Version cargogeiger cargo geiger thread main panicked at called Resultunwrap on an Err value srclibcoreresultrs stack backtrace coreresultunwrapfailed at srclibcoreresultrs cargoutilcanonicalurlCanonicalUrlnew cargocoresourcesourceidSourceIdnew cargoutiltomlDetailedTomlDependencytodependency cargoutiltomlTomlDependencytodependency cargoutiltomlTomlManifesttorealmanifestprocessdependencies cargoutiltomlTomlManifesttorealmanifest cargoutiltomlreadmanifest cargocoreworkspacePackagesload cargocoreworkspaceWorkspacefindroot cargocoreworkspaceWorkspacenew cargogeigercligetworkspace cargogeigermain stdrtlangstartclosure stdrtlangstartinternalclosure at srclibstdrtrs stdpanickingtrydocall at srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at srclibstdpanickingrs stdpaniccatchunwind at srclibstdpanicrs stdrtlangstartinternal at srclibstdrtrs main libcstartmain start it would be useful to get at least the line number in the toml file that causes the problem EDIT I tried eliminating lines in my Cargotoml to find the offending code but even with my whole Cargotoml commented I got the above error Weird geiger works fine in some other repos Running cargogeiger against dtoa v it reports that it has no unsafe code and uses forbidunsafecode despite neither of these being true It appears that parsing the main file is failing but it seems wrong for this to result in counts rather than some sort of indeterminate status console cargo download x dtoa cd dtoa INFO cargodownload v INFO Latest version of crate dtoa is INFO Crate dtoa downloaded successfully INFO Crate content extracted to dtoa cargo geiger Checking dtoa v tmptmpVYgoVrZqbYdtoa rustc warnings Finished dev unoptimized debuginfo targets in s Failed to parse file tmptmpVYgoVrZqbYdtoa srclibrs SynErrorexpected tmptmpVYgoVrZqbYdtoa srclibrs Scanning done Metric output format xy x unsafe code used by the build y total unsafe code found in the crate Symbols No unsafe usage found declares forbidunsafecode No unsafe usage found missing forbidunsafecode unsafe usage found Functions Expressions Impls Traits Methods Dependency dtoa WARNING Dependency file was never scanned tmptmpVYgoVrZqbYdtoa srclibrs cargo geiger version cargogeiger Example repository There is a lib testlib which contains forbidunsafecode but a binary still in testlib that does not There is also a separate binary testbin which depends on testlib In this case I do not believe there is any possiblity that testbin would be able to see or use unsafe code from testlib because such code doesnt exist in the lib only its bin so ideally cargo geiger when run on testbin should detect this and report that testlib includes forbidunsafecode because it does Running cargo geiger while Rust Language Server is watching my source tree in Atom results in the following panic inconsistently It is easiest to trigger the panic by stopping the cargo geiger build CtrlC then start cargo geiger while RLS is also rebuilding detailssummaryBacktracesummary thread main panicked at called Resultunwrap on an Err value Cargocould not remove build directory srclibcoreresultrs stack backtrace backtracebacktracelibunwindtrace at Usersrunnercargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at Usersrunnercargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprintfmt at srclibstdsyscommonbacktracers stdsyscommonbacktraceprintDisplayBacktrace as corefmtDisplayfmt at srclibstdsyscommonbacktracers corefmtwrite at srclibcorefmtmodrs stdioWritewritefmt at srclibstdiomodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingcontinuepanicfmt at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs coreresultunwrapfailed at srclibcoreresultrs coreresultResultTEunwrap at rustc f ac b ae c e c e be fasrclibcoreresultrs cargogeigerclirunscanmodedefault at cargogeigersrcclirs cargogeigerrealmain at cargogeigersrcmainrs cargogeigermain at cargogeigersrcmainrs stdrtlangstartclosure at rustc f ac b ae c e c e be fasrclibstdrtrs stdrtlangstartinternalclosure at srclibstdrtrs stdpanickingtrydocall at srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at srclibstdpanickingrs stdpaniccatchunwind at srclibstdpanicrs stdrtlangstartinternal at srclibstdrtrs stdrtlangstart at rustc f ac b ae c e c e be fasrclibstdrtrs cargogeigerFormatError as corefmtDebugfmt details You can probably reproduce this with RLS in VSCode as well The unwrap on the Result type is definitely not great error handling but Im wondering if there is a better way to handle cleaning in general Specifying the package name will at least fix the problem with RLS since cargo clean p packagename does not remove the targetrls subdirectory but should still be suitable for geigers cleaning needs The current compile times are a bit painful mainly caused by cargo having a huge number dependencies The obvious solution could be to reduce the number of dependencies of cargo Another very nice direction could be to use cargo as a subprocess no building cargo at all Can cargo output all the data needed by cargogeiger If not whats missing Make this list and then open an issue in the cargo repo and ask if a PR adding that missing data export would be welcome cargo Running cargo install cargogeiger fails on stable Rust Linux x Fedora I dont know if this is related to but that issue also mentions Git Most relevant part of the output cargo install cargogeiger Updating cratesio index Installing cargogeiger v exit code stderr fatal not a git repository or any parent up to mount point Stopping at filesystem boundary GITDISCOVERYACROSSFILESYSTEM not set error occurred Command cc O ffunctionsections fdatasections fPIC m I tmpcargoinstallhNL Hdreleasebuildlibgit sys a bb b d aoutinclude I libgit src I libgit depshttpparser I libgit depspcre I tmpcargoinstallhNL Hdreleasebuildlibssh syse d b eboutinclude fvisibilityhidden DGITREGEXBUILTIN DHAVESTDINTH DHAVEMEMMOVE DNORECURSE DNEWLINE DPOSIXMALLOCTHRESHOLD DLINKSIZE DPARENSNESTLIMIT DMATCHLIMIT DMATCHLIMITRECURSIONMATCHLIMIT DMAXNAMESIZE DMAXNAMECOUNT DSHA DCNOSTANDARDINCLUDES DSHA DCCUSTOMINCLUDESHA C commonh DSHA DCCUSTOMINCLUDEUBCCHECKC commonh o tmpcargoinstallhNL Hdreleasebuildlibgit sys a bb b d aoutbuildlibgit depshttpparserhttpparsero c libgit depshttpparserhttpparserc with args cc did not execute successfully status code exit code warning build failed waiting for other jobs to finish error failed to compile cargogeiger v intermediate artifacts can be found at tmpcargoinstallhNL Hd Caused by build failed This is using stable Rust cargo V cargo edd I can provide more details from the build output or the contents of tmpcargoinstallhNL Hd if necessary Hello I am getting this error for this project stack backtrace x f d backtracebacktracelibunwindtraceh e ebaf c a at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs x f d backtracebacktracetraceunsynchronizedh dc c bea at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs x f d stdsyscommonbacktraceprinthfff dd c f aa at srclibstdsyscommonbacktracers x f d stdsyscommonbacktraceprinth dda cafdedc at srclibstdsyscommonbacktracers x f d stdpanickingdefaulthookclosurehcdbbe ff c b at srclibstdpanickingrs x f d f stdpanickingdefaulthookh bd c a dff at srclibstdpanickingrs x f e stdpanickingrustpanicwithhookh e fb d at srclibstdpanickingrs x f dca stdpanickingcontinuepanicfmthe e cc c e b at srclibstdpanickingrs x f dbac stdpanickingbeginpanicfmthaa ec cec at srclibstdpanickingrs x ed dcc cargogeigercliprintdependencyclosureh dc e c c x ed da cargogeigercliprintdependencyh f f ff a x ed bd cargogeigercliprinttreeh f f c b x ed d c cargogeigermainh c fea c x ed stdrtlangstartclosurehb c f f e x f a stdrtlangstartinternalclosureclosureh bd d b at srclibstdrtrs x f a stdsyscommonbacktracerustbeginshortbacktracehbb e d a b at srclibstdsyscommonbacktracers x f da c stdrtlangstartinternalclosurehd b fdd edd at srclibstdrtrs x f da c stdpanickingtrydocallh cc dc a d at srclibstdpanickingrs x f af rustmaybecatchpanic at srclibpanicunwindlibrs x f e a stdpanickingtryh a e e a at srclibstdpanickingrs x f e a stdpaniccatchunwindhbae a ac c at srclibstdpanicrs x f e a stdrtlangstartinternalhece a cbd d at srclibstdrtrs x ed e b main x fffb a da genericstartmain at csulibcstartc x fffb a fa libcstartmain at sysdepsunixsysvlinuxpowerpclibcstartc x unknown Thank you What Dogfooding Continuous Integration One of the original goals of this project was and still is to make it simple to use in CI as a prebuild step cargogeiger should be able verify that no new unsafe usage or any unsafe usage at all depending on user configuration slips into production TODO Improve the cargo API integration Change the details of the cargo API calls to use the proper cargo flags Most if not all cargoflags should be properly interpreted to imitate what a normal cargo build invocation does If the user wants to test cargo build release which would likely be the normal case in CI then the call to cargogeiger should be cargogeiger release This should allow the cargo build release call to reuse most of the intermediate build artifacts produced by cargogeiger Why is this not already the case The original idea was to never invoke rustc to avoid the heavy build process but this turned out to be inadequate since cargo itself only knows of the entry point source code files and leaves the rest for rustc to resolve Prototype a fast forbid mode The current assumption in cargogeiger is that cargo is able to resolve all entry point source code files which means that we could run the forbidunsafecode scan without doing a single rustc call which would significantly speed things up at the cost of disabling the other metrics for this specific mode Implement a crate version trustlist A simple file containing a list of crates with versons placed in the application project root that are trusted to use unsafe code In other words a list of crates with specific versions that are permitted to not declare forbidunsafecode This is intended to allow CI automatically discover when a dependency that used to be pure safe rust introduce unsafe code directly or through a dependency did previously use unsafe code publish a new version that is not in the trustlist awaiting audit and trust list approval Create an example CI test project Create it in this repository or a new one whatever seems best at that time Add some free open source CI system to run it The syn crate has an unsafe code according to the cargogeiger but it will be used only during compilation afaik It doesnt affect the resulting binary After cargo install cargogeiger on macOS trying to run it against a crate with a rusttoolchain file info in its root fails with a dynamic linking error cargo geiger dyld Library not loaded rpathlibprocmacro f d c aa cddylib Referenced from Userscargobincargogeiger Reason image not found Abort trap 