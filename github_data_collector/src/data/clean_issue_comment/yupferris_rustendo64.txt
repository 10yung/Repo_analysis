rustcserialize would not compile error Can anyone help Due to the instruction pipeline in the R the delay slot writeback will happen after the next instruction has done a register fetch and before the next instructions writeback from in the NEC VR datasheet This is also the case on MIPS R which is the cpu that I am familiar with However reading the datasheet for R it can actually insert delay cycles if an instruction depends on the writeback please have a look at Load Delay in the NEC VR datasheet Needed a cargo update since the currently selected version of num needs a libc version that rustyline doesnt want to work with Notes No completion yet Making all errors while loadingsaving the history file silent was intentional if its your preference to print warnings that can be changed of course Both CtrlC and CtrlD will exit I found that helpful since rapid startbreakedit coderestart cycles are common Later it can be changed to match the gdb behavior of just giving a new prompt on interrupt The history file path is hardcoded to the XDG standard directory Ill leave it to some WindowsMac experts to find the right crate to make this do the right thing on these OS So I figured out the issues I was having yesterday I checked my sha against yours and it matches perfectly with yours Investigating further I figured out that there was an integer overflow occurring in the addi instruction I dont know why your rust didnt catch it while mine did but the code pif and rom are exactly the same In any case I was forced to implement some small amount of overflow handling in It might help anyone else out there who has the same issue Im not sure why rust was overflowing I think it was because it was trying to add two u s that represented negative numbers Not sure if that means i would have been more appropriate or i or whatever I just implemented it bitwise checking for overflow manually Now that I think about it I think my implementation breaks the bitmode I dont know Thoughts The kseg cacheenabled value is ambiguous when reading the RegConfig register There are many combinations of three bits that cause the bool to be false but the bool type is not descriptive enough to tell which of these combinations has actually been stored in the RegConfig register when the program wants to read it In addition there are several other bits of RegConfig that arent being handled whatsoever which is obviously going to be a problem when reading I dont know if any code ever actually reads from the RegConfig register but this will be a problem if some code does Im sorry for being zealous and making an issue for this which might be an overreaction Im watching the series for the first time and I noticed this problem just now Just wanted to make sure this is properly addressed in orderly fashion Suggestion from CryZe 