Hi Thank you all the developers for this amazing project I would like to use this project to install VM on a hardware during its early development stage to test applications And I wish to be able to boot the VM via the network Questions Does the project support UEFI SNPSimple Network Protocol for booting via the network Browsing through the code it seems that it does not support the protocol but I would just like to make sure If there is support or ongoing implementation is there any way that I can contribute to it If there is no support for it but the project would like add support can I fork and do a pull request Or might it be that the project does not intend to add support for UEFI SNP Depends on and addresses This PR adds support for booting via the Xen HVM direct boot ABI This uses a bit unpaged entry point so we just point it at ram start This allows our firmware to be used with QEMUs kernel option This can be invoked like qemusystemx machine typeq accelkvm cpu host smp m display none serial stdio kernel targettargetreleasehypervisorfw drive fileclear kvmimgformatrawifnoneidbootdrive device virtioblkpcidrivebootdrivedisablelegacyon For some reason this gets further in the boot than but still doesnt boot all the way to Linux It can configure the block device and find the kernel but gets stuck at Jumping to kernel I turned off quiet mode in the kernel and confirmed that the first line of the kernel console isnt even being printed rbradford is this the same issue that prevents booting on firecracker Resetting Virtio Devices Signedoffby Joe Richey joericheygooglecom Depends on Fixes Now you can do the following cargo xbuild target targetjson release sstrip targettargetreleasehypervisorfw qemusystemx machine typeq accelkvm cpu host smp m display none serial stdio bios targettargetreleasehypervisorfw drive idbootfileclear kvmimgformatrawifnone device virtioblkpcidrivebootdisablelegacyon And the firmware will go from the realmode reset vector all the way to Rust Driver bug is preventing boot due to VIRTIO feature negotiation Right now all the tests run on the host In an ideal world we would set cargoconfigs buildtarget to be our custom target and have everything xbuild xclippy xtest etc build for the main target This is how blogos does it We would have to setup a custom testing framework however which could be complex We would also have to figure out an easy way to run the tests without too much hassle maybe once is done Per the UEFI spec calling open on a directory path should work but right now it will fail as the code here is only setup to return a file The solution to this is probably reworking the filesystem code to better handle working with directories Nightly doesnt have clippy at the moment so the CI has currently failed Although its possible to fix on a particular version of nightly via rusttoolchain that sometimes goes wrong as it pulls down the latest rustsrc which might not compile with that compiler joshtriplett do you have any thoughts on how we could move away from nightly or mitigate the risks A docker container with a known good toolchain already installed Right now its not possible to run the firmware with any nonFirecracker VMM Ideally we would support a wide range of VMMs There are many small changes that would fix this In the ELF binary advertise support for a common boot specification This would allow any VMM supporting that spec to run the firmware Our options are MutlibootMultiboot this is an older FSF common boot standard It would also let us work with QEMUs kernel option might also work with Xen PVH direct boot This standard started with XEN but support was added to QEMU recently To use this we just need to advertise XENELFNOTEPHYS ENTRY as an ELFNOTE Not supporting PVH is why running QEMU with kernel does not work qemusystemx kernel targettargetreleasehypervisorfw qemusystemx Error loading uncompressed kernel without PVH ELF Note Note that both of these specs would probably require a separate bit entry point The firmware would then need to setup paging before jumping to the normal bit ELF entry point ie start Issue support building the firmware as a flat BIOS binary like OVMFfd allowing it to be directly loadedexecuted by any VMM that supports SeaBIOSOVMF Implementing either of these would let the firmware work on QEMU Im not sure about how to get it working for crosvm it should just work with any ELF binary I can ask around at work Monday to see what the deal is Right now the firmware is built into a normal ELF binary and then booted using Firecracker However it would be nice if were possible to build the firmware into a flat BIOS binary that can be directly executed by the processor on reset Specifically the firmware would be loaded at Guest Physical Address GiB sizeofbinary and then execution would begin at the standard x reset vector xFFFFFFF in Real Mode This is what SeaBIOSs biosbin and EDK s OVMFCODEfdOVMFVARSfd builds do This would then allow for the binary to be used with any VMM that uses the normal BIOS loading process This means automatic support for QEMU and XEN Specifically using QEMU would then be possible with qemusystemx drive ifpflashformatrawreadonlyfilehypervisorfw Design Ideas I would be happy to start exploring this My idea of the execution flow would be One instruction at the reset vector jump to code in Assembly code that b Deals with A c Sets up stub IDTGDTPaging d Switches to long mode e Jump to start ie the normal ELF entry point Our normal Rust entry point start This could be done by having two similar targetjson files that only differed in refering to different layoutld files The layoutfd file for our flat BIOS build would just have to make sure that the code for was properly aligned and at the end of the file This also means that our flat BIOS build would still be an ELF file which has its advantages 