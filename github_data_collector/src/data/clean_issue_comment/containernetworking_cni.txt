json identifier cannot handle json with comments well Change the identifier to jsonc Ref githublinguist json A followup fix PR of IMO we should use blackbox testing for our utility functions Signedoffby Bruce Ma brucema gmailcom Examples in the documentation suggest that can be used for comments Eg the CNI spec contains an example like cniVersion name dbnet type bridge type plugin specific bridge cni Unfortunately using such a configuration with podman results into Error error parsing configuration list invalid character looking for beginning of value Because configuration files seem to be JSON which does not support comments at all it should be clarified how to write comments in configuration files If not supported and CNI spec is wrong such an extension should be explicitly required because comments are essential in configuration files If a plugin exits with a non exit status and prints stuff to stderr but not stdout then pkginvokerawexecgopluginErr will categorize this as netplugin failed with no error message This seems to be in part because it forwards the plugins stderr to its parents stderr which is nice and all but it means that the stderr might end up getting logged somewhere less useful eg in crios logs rather than kubelets Plus the failed with no error message part is just wrong Seen in two unrelated contexts with different plugins in the same day lol dcbw squeed Hello everybody I asked about my problem in corednscoredns url and I taked answer it is cni problem How to resolve that issue cniVersion kubesystem coredns d b d k Running h m kubesystem coredns d b d vmzv Running h m kubectl describe podcoredns d b d k n kubesystem Name coredns d b d k Namespace kubesystem Priority Priority Class Name systemclustercritical Node pr Start Time Wed Oct Labels k sappkubedns podtemplatehash d b d Annotations Status Running IP IPs IP Controlled By ReplicaSetcoredns d b d Containers coredns Container ID docker f e b a e f d a cef d fc a dbe d Image k sgcriocoredns Image ID dockerpullablek sgcriocorednssha eb b b b a ecf c bc c e fd b be e c e ee Ports UDP TCP TCP Host Ports UDP TCP TCP Args conf etccorednsCorefile State Running Started Wed Oct Ready False Restart Count Limits memory Mi Requests cpu m memory Mi Liveness httpget delay s timeout s period s success failure Readiness httpget delay s timeout s period s success failure Environment Mounts etccoredns from configvolume ro varrunsecretskubernetesioserviceaccount from corednstokeng xt ro Conditions Type Status Initialized True Ready False ContainersReady False PodScheduled True Volumes configvolume Type ConfigMap a volume populated by a ConfigMap Name coredns Optional false corednstokeng xt Type Secret a volume populated by a Secret SecretName corednstokeng xt Optional false QoS Class Burstable NodeSelectors betakubernetesiooslinux Tolerations CriticalAddonsOnly noderolekubernetesiomasterNoSchedule nodekubernetesionotreadyNoExecute for s nodekubernetesiounreachableNoExecute for s Events Type Reason Age From Message Warning Unhealthy x over h m kubelet pr Readiness probe failed HTTP probe failed with statuscode cat etccninetd flannelconflist name cbr cniVersion plugins type flannel delegate hairpinMode true isDefaultGateway true type portmap capabilities portMappings true This is a get all the things function which a runtime could use on container teardown to avoid having to itself cache the uniqueness tuple when tearing down all networks for the container containernetworkingcnimaintainers squeed mars Hi Im Yevgeny Pats Founder of Fuzzit Continuous fuzzing as a service platform We have a free plan for OSS and I would be happy to contribute a PR if thats interesting The PR will include the following gofuzz fuzzers This is generic step notconnected to fuzzit Continuous Fuzzing of master branch which will generate new corpus and look for new crashes Regression on every PR that will run the fuzzers through all the generated corpus and fixed crashes from previous step This will prevent new or old bugs from crippling into master You can see our basic example fuzzitdevexamplego and you can see an example of in the wild integration prometheusprometheus corednscoredns googlesyzkaller Let me know if this is something worth working on Cheers Yevgeny Provide a experimental way to fix We let sub process called by invokeExec has the process group id same as its parent process id so when the parent process is killed all the sub processes will be killed in tree recursively Fox example if we use libcni in CRI to call plugin A and plugin A call plugin B and C and plugin B call another plugin D then the pidpgid maybe like processpidpgid CRI A B C D If CRI pid was killed processesA pid with group id will be killed and processesB pid C pid with group id will be killed and process D will be killed in the same way recursively For the same reason if CRI try to kill process A B C D will be killed recursively Signedoffby Bruce Ma brucema gmailcom I have been working on a netfilter plugin assuming that mesos would support the plugin chaining standard of Turns out that they do not Better make sure others are notified about this because I do not think they will change their documentation on this as I have requested of them As discussed in our maintainers meeting we believe that libcni should handle plugin cleanup when the timeout passed by the runtime triggers libcni should send plugins a TERM signal wait a reasonable amount of time a couple seconds and then KILL plugins One complication is that the plugins must be part of the same process group so that on linux we can signal the process group and deliver the same signal to all plugins spawned from the main plugin This could be tricky as Go doesnt easily allow changes between fork exect Some references that might help We could also use syscallSysProcAttr on Linux like so cmd execCommandlongprocess cmdSysProcAttr syscallSysProcAttr Setpgid true Pgid some unique number we come up with cmdRun And then we can signal the Pgid Code for Windows is in the above stackoverflow link to do essentially the same thing