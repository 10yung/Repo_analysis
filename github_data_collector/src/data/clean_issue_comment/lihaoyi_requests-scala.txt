Client certificate supported with PKSC pfx Use like this for passwordless p scala requestsget cert badsslcomclientp Add password if necessary scala requestsget cert badsslcomclientp password badsslcom used in tests can and will occasionally annually update certificates and that would fail the tests Therefore I made the test print a warning in case of client certificate failure instead of failing the test Warning looks like this WARNING Certificate may have expired and needs to be updated Please check andor file issue It will be great if we can use this library in Scalajs According to your code you need to calculate contentlength for multipart uploads After doing that you specifically upload multipart as chunked data with no contentlength This has led to issues for me exactly because of the reason stated in line when i try to POST contentlength is removed from the headers If i make a post with scala val session Session requestsSession headers Map useragent userAgentHeader authorization authHeader accept contenttype applicationjson charsetutf val file new Filepathtofile val multiPart MultiPartMultiItemfile file filegetName val headers Map thing thang ContentLength multiParttotalBytesToSendtoString contenttype smultipartformdata boundarymultiPartboundary sessionposta url data multiPart headers headers When I POST to myself and look at the headers the contentlength is gone because it is controlled at the Java level here My current workaround is this scala case class SizedMultiPartitems requestsMultiItem extends requestsRequestBlobMultipartFormRequestBlobitems with requestsRequestBlobSizedBlob override def length Long totalBytesToSend override def inMemory Boolean false override def headers Seq String String Seq ContentType smultipartformdata boundaryboundary ContentLength totalBytesToSendtoString After going through all the trouble of calculating size for MultiPartFormRequestBlob is there a reason why that is then discarded by making MultiPart not a SizedRequestBlob scala requestshead headers MapAcceptEncoding gzip javaioEOFException javautilzipGZIPInputStreamreadUByteGZIPInputStreamjava javautilzipGZIPInputStreamreadUShortGZIPInputStreamjava javautilzipGZIPInputStreamreadHeaderGZIPInputStreamjava javautilzipGZIPInputStreaminitGZIPInputStreamjava javautilzipGZIPInputStreaminitGZIPInputStreamjava requestsRequesterstreamRequesterscala requestsRequesterapplyRequesterscala ammonitesesscmd Helperinitcmd sc ammonitesesscmd initcmd sc ammonitesesscmd clinitcmd sc I hit this in the wild while poking at the GitHub API scala requestshead A workaround is to ask for a nongzipped response scala requestshead headers MapAcceptEncoding identity works Anyway to launch async request that returns a Future Could you create a scala native release Are you planning to add support for clientside certificates similar to requests From my experience the current Java API is very ugly and painful Just a headsup since you mentioned using HttpURLConnection in the README We used scalajhttp and ran into this bug causing POST requests to retry automatically after a read timeout Which of course can be very badconfusing behavior