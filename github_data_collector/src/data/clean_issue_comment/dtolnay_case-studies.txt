Im in the process of moving overflower to autoref specialization I have found that it works as you described in the unary operation case eg specializing stdopsNeg vs overflowerOverflowerNeg However there is a small niggle when the trait is generic over some other type as for example stdopsAddRHS Self is over RHS In this case if I try to implement the kind for T stdopsAdd this only works for the default RHS type which is Self but eg String implements Add for various other types eg str and Cow str Thus we must allow our kind to be implemented for arbitrary RHS So lets try that pub struct OverflowerAddTag pub trait OverflowerAddKindR fn overfloweraddtag OverflowerAddTag OverflowerAddTag implR T OverflowerAddKindR for T where T stdopsAddR implR T OverflowerAddKindR for T where T OverflowerAddR Now the compiler tells us that we need to give a lifetime to T so we do that which gives us impla R T a OverflowerAddKindR for T where a T stdopsAddR This works Just wanted to let you know rust Before fn f self a Arg b Arg Ret original function body After fn f self a Arg b Arg Ret struct Guard Need to complicate this type name until Macro The function body might use the same name impl Drop for Guard fn drop mut self do the thing let guard Guard No need to change variable name Even when the function body uses the same name let originalf move Ret original function body Let the compiler capture self args etc let value originalf memforgetguard value 