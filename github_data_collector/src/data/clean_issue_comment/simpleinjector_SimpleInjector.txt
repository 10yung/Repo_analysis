Feature adds async disposable support for ASPNET Core but even outside the realm of ASPNET Core async disposable support is useful in two places To asynchronously dispose of disposables on a Scope To asynchronously dispose the Container Because of the extra required MicrosoftBclAsyncInterfaces package I feel adding support to the core library is unsuited for v but we might want to reconsider for v This package should do the following Implement a SimpleInjectorHubActivatorT class Add an extension method for registration of this class Add an extension method that allows autoregistration of Hub classes similar to the RegisterMvcControllers of the ASPNET Core MVC integration package ie it should register Hub classes based on the selected lifestyle ILifestyleSelectionBehavior and should suppress the disposable transient components warning in case the Hub implementation does not override Disposebool Especially this last point is the main reason why we need an integration package Integrating SignalR without an integration package would have been trivial in case Hub would not have implemented IDisposable and it shoulnt have There are other complications such as discussed here that should be taken into consideration which are Hub classes do not always run in a web request for instance with LongPolling which means that they can be resolved without an active Simple Injector Scope This means SimpleInjectorHubActivatorT must create a new Scope within its Create method and dispose of the Scope in the Release method Although the creation of and disposing of a scope could be skipped in case an active scope ie a web request scope already exists that could lead to complications because the request might already have ended in some cases strikeIn case the absense of an active scope the hub activator should be able to supply the Simple Injector ASPNET Core integration with the active IServiceScopeIServiceProvider instance to prevent Simple Injector from creating a new IServiceScope internal which would again lead to multiple instances of scoped registrations but now for ASPNET Core registered typesstrike The hub should run in its own Simple Injector scope and MSDI scope reusing the same incoming MSDI scope might have hard to predict side effects The following issues should be taken into consideration With Simple Injector v introduced the ability to disablee resolving concrete types In v this options should be the default Do you have sample code to register the user controls to enable dependency injection I imagine it would have to be property injection like the web pages VisualizeObjectGraph does not include component types that are part of IEnumerable dependency How To Reproduce Consider the following registrations C var container new Container containerCollectionRegistertypeofIValidator typeofIValidatorAssembly containerRegistertypeofIValidator typeofCompositeValidator containerRegisterMyService containerVerify var actual containerGetRegistrationtypeofMyServiceVisualizeObjectGraph ConsoleWriteLineactual Using types C class MyService public MyServiceIValidatorMyModel myModelValidator interface IValidatorT class CompositeT IValidatorT public CompositeIEnumerableIValidatorT v class Validator IValidatorMyModel public Validator Dependency d class Validator IValidatorMyModel public Validator Dependency d class Dependency class MyModel Prints to the console MyService Transient CompositeMyModel Transient IEnumerableIValidatorMyModel Singleton Dependency Transient Dependency Transient Expected to print MyService Transient CompositeMyModel Transient IEnumerableIValidatorMyModel Singleton Validator Transient Dependency Transient Validator Transient Dependency Transient Additional context SimpleInjector NET Core console app The implemented feature of should be enabled by default in v Integration with IHtmlLocalizer came up in We should discuss and research whether This is something that people need How it is used Whether it would be useful to provide integration How to provide integration how to implement which package etc Currently a delegate registered using RegisterResolveInterceptor is not invoked when a nonresolvable type is requested from Simple Injector Should this be changed Repro c var container new Container containerOptionsRegisterResolveInterceptorc p Expected to be invoked try return p catch Exception ActivationException expected to be thrown throw c true containerGetInstanceITimeProvider Describe the bug The following code doesnt print the name of the type to the console c var container new Container containerOptionsRegisterResolveInterceptorc p SystemConsoleWriteLinecRegistrationImplementationTypeToFriendlyName return p c true containerCollectionAppendITimeProvider RealTimeProvider containerGetInstanceIEnumerableITimeProvider Expected behavior The name of the type should be written to the console Actual behavior The following code doesnt print the name of the type to the console Additional context Latest release v 