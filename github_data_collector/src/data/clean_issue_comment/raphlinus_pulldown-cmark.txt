Im running into all kinds of corner cases with one of my projects this being another one It is even more tricky because tables are not part of CommonMark so it is less clear what the right behavior is The problem this PR solves is that a table that has a paragraph right before it will not be parsed Hello abc def bar baz Becomes a long paragraph the table syntax as part of the paragraph This PR fixes that and inserts a Hello paragraph before the table in the parsed markdown In my project I kind of rely on the possibility of having a paragraph before an element which is how I ran into this issue I did some research to see how other projects notably GitHub render the example above Interestingly GitHub exhibits the same issue in their markdown parsing while this online editor supports it just fine However other examples such as Hello abc def bar baz render correctly on GitHub It is only paragraphs that are not supported right before a table Therefore at least to me this feels more like an accidental bug than correct behavior Personally for me it would be great if this would be merged as Id need to continue using a fork otherwise Another maybe viable option might be to have this behavior be optional via a feature flag although I can see that this is a road that once taken can lead to madness if more and more of the nonstandardized idiosyncratic markdown features end up as feature flags This PR also contains tests and Id be more than happy to improve the code if it is not up to the quality standards of pulldowncmark This should make it easier to see what tests are related to base commonmark or extensions Reviewing tests when a spec changes should be easier this way cc See In addition this PR also implements LUT switching so that the performance of plain CommonMark is not affected by adding extensions The full commit message explains the performance impact of that change Heres the overall effect gpulldowncmark staticscannerlut cargo bench bench htmlrendering baseline baseline crdtparse Finished bench optimized targets in s Running targetreleasedepshtmlrendering cbd ae f c d crdtparse time us us us change p Performance has improved I would also note these benchmarks were running on a pretty noisy machine and the baseline fluctuated quite a lot later still centred on where it was You can at the very least say that plainspec perf is no longer dependent on the number of extensions extra special chars that need to be scanned to support them Since Markdown doesnt have any specific tag to specify the direction of a given block of a text and since there are many cases in which the text body is mixed with RTL and LTR text there is a need to detect the direction of the text automatically based on the context This feature is extremely need to be implemented in whatever possible way but the most feasible solution as per my understanding is to apply bidirection bidi to the render engine so it pass the responsibility of dealing with direction to the browser When I use this library with wasmbindgen E was occurred error E the trait bound pulldowncmarkparseEvent stdborrowBorrowpulldowncmarkparseEvent is not satisfied src librs wasmbindgen the trait stdborrowBorrowpulldowncmarkparseEvent is not implemented for pulldowncmarkparseEvent note required by pulldowncmarktocmarkfmtcmark error aborting due to previous error For more information about this error try rustc explain E ref The parse module has gotten fairly large at k lines of code It contains both the first and second pass of parsing which dont have much code in common Creating separate modules for the passes and moving shared data structures to the root module may improve maintainability and more clearly signal to new contributors the structure of the parser In pulldowncmark the main data structure is a vector backed tree The final tree which is traversed to generate events in two passes Roughly speaking the tree structure is constructed in the first pass blocks and the leaf nodes are finalized in the second pass Especially in this second pass many tree mutations are done which correspond to indexed vector accesses These operations incur the cost of bound checking in Rust which could possibly be avoided by replacing the vector by an efficient arena One such candidate could be idarena This would a great display of getting maximal performance while still enjoying Rusts safety guarantees There may be a tricky bit in the emphasis handling part of the second pass where we currently construct some vector indices with arithmetic which will not work with arena ids One way to get around this may be to ask the arena to upgrade a numeric value to a valid arena id This would do a onetime bounds check after which we could use the id for access without checks after It may also be possible to simply reuse arena ids that are already in the tree Another place where vector backed stores without deletion are used is the Allocations struct It contains details of links images owned strings and table alignments Tree nodes may store keep indexes to the Allocations struct which are much smaller than the details themselves These vector backed datastructures are also prime candidates for arena replacement We dont do any index arithmetic for those idarena The following markdown Note Though you should not rely on this all pointers to abbr titleDynamically Sized TypesDSTsabbr are currently twice the size of the size of usize and have the same alignment causes the abbr tag to close at the newline That is it becomes blockquote pNote Though you should not rely on this all pointers to abbr title quotDynamically Sized Types quot gtDSTsabbr are currently twice the size of the size of codeusizecode and have the same alignmentp blockquote I would expect the blockquote to be mostly transparent and allow the tag to continue commonmarkjs dingus seems to handle it correctly GitHub handles it too though it strips out abbr tags It would be helpful to know what kind of link failed in the broken link callback to improve diagnostics in rustdoc for intradoc links Currently the fuzzer spawns a number of threads which can be rescheduled at any time to any core We might be able to improve performance by pinning each thread to a core