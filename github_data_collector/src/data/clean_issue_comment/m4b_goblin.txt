 The relocation fields are bitfields which makes the ordering all weird Currently we only use the little endian ordering but that wont work for big endian files LLVM has code to handle this difference see here Also related we dont currently parse scattered relocations It works on my fork A bit of the history at and motivation at The default Python extension C flags on Windows with clexe includes GL Whole Program Optimization The docs say obj files produced with GL will not be available to such linker utilities as EDITBIN and DUMPBIN When that is used the obj format is very strange Omit the option and the usual obj format is used and goblin and object process it wonderfully As I can hack the code involved omitting that flag is possible so this doesnt block us but it would be nice to have the optimisations and have one less hack Anyways I can proceed so thanks very much for a workable library Parsing this archive file seems to cause a panic thread main panicked at no entry found for key srclibcoreoptionrs stack backtrace backtracebacktracelibunwindtrace at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracelibunwindrs backtracebacktracetraceunsynchronized at cargoregistrysrcgithubcom ecc db ec backtrace srcbacktracemodrs stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdsyscommonbacktraceprint at srclibstdsyscommonbacktracers stdpanickingdefaulthookclosure at srclibstdpanickingrs stdpanickingdefaulthook at srclibstdpanickingrs stdpanickingrustpanicwithhook at srclibstdpanickingrs stdpanickingcontinuepanicfmt at srclibstdpanickingrs rustbeginunwind at srclibstdpanickingrs corepanickingpanicfmt at srclibcorepanickingrs coreoptionexpectfailed at srclibcoreoptionrs coreoptionOptionTexpect at rustc e bb e fc caa a e a ca d srclibcoreoptionrs alloccollectionsbtreemapBTreeMapKV as coreopsindexIndex Qindex at rustc e bb e fc caa a e a ca d srcliballoccollectionsbtreemaprs goblinarchiveArchiveparse at goblinsrcarchivemodrs goblinObjectparse at goblinsrclibrs strandmatchmain at srcmainrs stdrtlangstartclosure at rustc e bb e fc caa a e a ca d srclibstdrtrs stdrtlangstartinternalclosure at srclibstdrtrs stdpanickingtrydocall at srclibstdpanickingrs rustmaybecatchpanic at srclibpanicunwindlibrs stdpanickingtry at srclibstdpanickingrs stdpaniccatchunwind at srclibstdpanicrs stdrtlangstartinternal at srclibstdrtrs stdrtlangstart at rustc e bb e fc caa a e a ca d srclibstdrtrs main libcstartmain start note Some details are omitted run with RUSTBACKTRACEfull for a verbose backtrace Source rust use stdfsFile use stdpathPath use stdioRead use goblinObject fn main let mut f FileopenPathnewosaunwrap let mut buf Vecnew freadtoend mut buf Objectparse buf ar seems to extract this archive just fine as well It would be extremely helpful to use the capabilities of goblin when working with memoryprocess dumps as well as files on disk Since memory dumps are already mapped we can just skip over the rva resolve function and all of the other functionality will work still Im not sure however if it would be best to implement this as a compiletime feature as this PR does it or as a runtime feature maybe splitting the parse function into parseimage parsemapped or something similiar I ve noticed that goblin has a very long compile time relatively speaking I ve meant to look into this before whether there is something we can do about it and also how to look into it Maybe this is something the rustc might be interested in It doesn t have a lot of lines of code nor is it really very generic aside from usage of scroll so I m wondering what s the precise issue We need to have a story for binary data in goblin as it s becoming more and more urgent to have a full test suite we can run against for compliance and regression We don t want to store binary data in git since this adds to clone time and is generally frowned against There are a few binary files in goblin or what is effectively binary data with vecs with u s but these are grandfathered and we don t need to concern ourselves with them Im open to any and all suggestions about what best path forward is here safetydance This is currently a WIP PR for other members of safetydance to help audit and improve the code This PR aims to tackle the issues raised in unsafe blocks and unsafe impls had no rust Safety annotations which makes it easy to forget or miss safety requirements invariants to uphold be it when the code is written or later when the code is modified it also makes quickly auditing the code harder Thats why imho it is very important to have such safety comment annotations The usages of unsafe corresponded to four cases getunchecked indexing for pedatadirectories array getters These have been factored in a macro to avoid code repetition and within that macro compiletime assertions have been added so that the code is robust to changes unsafe fn exported to the API These have not been audited yet by virtue of being marked unsafe users of the library must explicitely opt into calling these unsafe functions and it is thus mainly their responsibility to do it correctly hence making it a lowpriority fix unsafe impl for plainPlain These implicitly relied on each field also being Plain such as integers but where also used with a macro la C template hence a static assertion has been added in those cases to ensure that the template type parameter is indeed Plain Plain on its own offers nonunsafe transmutebased APIs to go into and from slices of bytes the soundness responsibility of it falls down on the plain crate and has not been audited either Ideally all the plain usages could be replaced by zerocopy since thanks to the derive it offers compiletime checks for the soundness of these impls unsafe fdreadexactplainasmutbytes mut some structure These have been the main change of the PR with the compiletime checked deriveAsBytes we get access to a nonunsafe zerocopyAsBytesasbytesmut for equivalent functionality This in turn has showed that there were some structures that did have padding which has been removed with the reprC packed annotation and the appropriate ptrreadunalignedbased getters I have met some nasty exe that have a invalid idata section which will panic Something like thread main panicked at called Resultunwrap on an Err value MalformedCannot find name from rva x in sections code In this moment i actually dont know why these exe have such idata I just want to parse the unwind info Now pePEparse will parse the whole pefile I am wondering would it be nice to pass some options to enabledisable parse partially Like i would disable parsing the import table as i just want to get the exception table for the unwind info BTW i use gimliobject to help parsing object files Thanks for the great job I dont know where i should fire this issue goblin or gimliobject