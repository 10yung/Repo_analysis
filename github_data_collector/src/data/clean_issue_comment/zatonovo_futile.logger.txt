Any particular reason why flogthreshold returns a character vector futileloggerflogthreshold DEBUG futileloggerDEBUG DEBUG I would have expected the above to be of the same type so that it should be possible to do iffutileloggerflogthreshold futileloggerDEBUG do something Is there any support planned for letting logging be configured externally eg from environment variables or a config file at a default path This would be helpful for us we have lots of R projects that are called from other environments like Java or a shell and its not very convenient for them to call another R function in order to set up logging It seems like theres precedent for this in log j maybe the same style could be followed I would prefer to have R CRAN package tryCatchLog keep working after the JAN changes to futilelogger tryCatchLog is unique in the R package universe in such that after an error in the call stack both the file names and line numbers are returned to the user No other package does that or comes close with line number or file name Package futilelogger is package tryCatchLog s general logger So I vote no to hijack the error handling system yes to new extra parameter emitTRUE I cant figure out how to configure the logger setup Im trying to achieve I would like all messages INFO and above to go to the console stdout and all messages WARN and above to also be logged to a file warnloggerlog Heres my example code libraryfutilelogger flogthresholdINFO flogloggerROOT thresholdWARN appenderappenderfilewarnloggerlog flogloggerROOT thresholdINFO appenderappenderconsole flogdebugdebug message floginfoinfo message flogwarnwarn message flogerrorerror message The output is Rscript logsR NULL NULL NULL INFO info message WARN warn message ERROR error message But the warnloggerlog file is never created The README for the package says Typically only one appender is used per logger but multiple can be assigned How can I assign more than one appender if thats what I need to do to achieve what Im trying to do Thanks Hi Im using Futile Logger with the root logger but with a teeappender to both console and to a log file Ive set R options so that console errors also get written to the log via optionserror function flogerrorgeterrmessage traceback stop On a fresh install of my software an R system error would also generate a package error floglogger not found After some investigation is seems that using lambdar does not generate this error but x does Im guessing its some sort of namespace error Best Alan PS thanks for the great package I use futilelogger a lot in my parallel scripts all of which use package future to handle multiprocessing flog of course works well in this case when logging to a file but does not for logging to the terminal all messages are relayed at the end of the future Is there any way this could be accomplished For a custom json layout based on the package jsonlayout and layoutformat functions the first unnamed argument is passed as id customjson functionlevel msg id if isnullsubstitute msg sprintfmsg outputlist list level jsonliteunboxnameslevel timestamp jsonliteunboxformatSystime Ymd HMS z message jsonliteunboxmsg func jsonliteunboxunavailable havent worked this out returnsprintfs n jsonlitetoJSONoutputlist simplifyVectorTRUE floglayoutcustomjson floginfos test levelINFOtimestamp messages funcunavailable floginfos test test levelINFOtimestamp messagetest funcunavailable Removing the id argument from the customjson function resolves this issue but Im not sure why it works since the layoutformat seems to be called without any issues using the same signature The layoutjson function is putting string interpolation arguments on the output as json fields instead of interpolating the message template libraryfutilelogger floginfotest s interp INFO test interp but after changing the layout floglayoutlayoutjson floginfotest s interp levelINFOtimestamp messagetest sfuncshell interp The interp argument shows up as field on the output and the message template is unchanged Im running futilelogger on R added code to pipeline data with AWR library into the AWS kinesis streams flogappenderappenderkinesishandlerloggingdatauseast LOL kinesis I have a function that calls flogwarn under certain conditions and I want to test those conditions However it looks like the warning doesnt go through the channels that testthatexpectwarning expects it to expectwarning solution docallmyfunction args regexp Missing regime types offpeak WARN Missing regime types in lastperiodpeaks offpeak filling with zeroes Error solution docallmyfunction args did not produce any warnings So the warning makes it to STDOUT or STDERR and doesnt get captured by expectwarning so the test fails Is there some other way to accomplish this easily