Fixes This is a follow up to I dont want to make STDOUTFILENO nonblocking because it can have sideeffect to stdinstderr eg when they all point to the same tty Im fine with writing to stdout being blocking so I made an AsyncOutputStream where the write is just a call to kjFdOutputStreamSTDOUTFILENOwrite However there is one thing Id like to watch when stdout is pollable its hangups whenWriteDisconnected So that my application can be stopped when the output stream readend closes eg myapp grep maxcount SomeEvent To support this I used kjUnixEventPortFdObserverOBSERVEWRITE but truth be told it wasnt for waiting for writes just to get an FdObserver that signals whenWriteDisconnected And I realize now that this had an unfortunate sideeffect When running my application under strace I now get an infinite loop because strace writes to STDERR which is shared with STDOUT strace myapp pid epollwait EPOLLOUT u u pid epollwait EPOLLOUT u u pid epollwait EPOLLOUT u u My understanding is that each write to stderr strace make generates an epollwait event not sure why but why not Each event generates an strace writes And this loop goes on indefinitely I found a way to watch only whenWriteDisconnected by instantiating an FdObserver that observes for nothing value that is neither OBSERVEWRITE nor OBSERVERREAD nor OBSERVERURGENT This still watches hangups since the epoll man page states that EPOLLHUP Hang up happened on the associated file descriptor epollwait will always wait for this event it is not necessary to set it in events With the current FdObserver code this work fine But Im wondering if Im relying on an implementation detail here or if you think it is safe Also asking in case there is a better method I did not think of capnproto is available as a port in vcpkg a C library manager that simplifies installation for capnproto and other project dependencies Documenting the install process here will help users get started by providing a single set of commands to build capnproto ready to be included in their projects We also test whether our library ports build in various configurations dynamic static on various platforms OSX Linux Windows x x UWP ARM to keep a wide coverage for users Im a maintainer for vcpkg and here is what the port script looks like We try to keep the library maintained as close as possible to the original library Should work with Windows Linux macOS using the default settings Also includes a manylinux compatibility build which is used to build linux pypi packages to maximize glibc compatibility of binary packages manylinux uses a newer gcc with an older glibc These dont fully replace yet the travis and appveyor builds However they are much easier to maintain and write This is needed to handle CentOS builds Specifically for manylinux which is used for compiling pypi binary packages Should resolve Issue There were some Windows test issues not sure on why using only posixmemalign and alignedmalloc The Json Rpc class doesnt seem to be able to make jsonrpc array requests as far as I can see it Array requests exist according to this specification I have some code hacked together which is based on capnproto and rewrote parts of the jsonrpc class in this file and made it usable for the kjHttpService class But since I changed to much have added unnecessaryunfinished stuff and dont have a client implemented I dont want to merge my code into capnproto Also its not written to my standard but I can make jsonrpc array calls I can write a proper merge though I just wanted to open an issue before doing that My hacky implementation generates orphans if an array request was sent and adopts them into an appropriately sized array of orphans and serializes that into json I do this because I dont know the response size since notifications dont generate array elements Tracking discussion in would be nice if it were possible to define inlineable structs that behaved identically to a group but provided a strong name that could be reused multiple times Considerations Do we want to support only sealed types or should we support a general mechanism to provide named groups What is the complexity this adds to capnproto This is a draft of the new tutorial sample Im currently unable to build it against head but am able to build against the C source from capnprotoorg you can see an artifact of that in the build file src I spent hours trying to track down the problem thinking it was my mistake This is a draft Im interested in feedback I realize you probably want cmake over meson cmake isnt something I know how to do Ill add more comments before the final version But mostly Id like to know what features you think are important to demonstrate in a tutorial linked from needs to include samples Would be nice if there was a way to adopt external data in a way that guarantees it s the last segment even if an allocation for a far pointer would be needed Use case is having a large bulk data segment that ideally we could handle loss in gracefully without worrying about corrupting cap n proto data fields eg sending a video frame and being able to handle loss in the video payload more easily without worrying about cap n proto framing