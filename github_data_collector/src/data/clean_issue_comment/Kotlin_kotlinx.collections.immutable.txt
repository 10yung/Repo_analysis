FEATURE REQUEST A parameterless version of persistentHashMapOf to avoid creating a useless builder and varargs parameter when the code is just going to create its own builder anyway fun K V persistentHashMapOf PersistentMapK V PersistentHashMapemptyOfKV Parameterless versions of persistentSetOf and persistentListOf already exist It seems odd that this is missing The current proposal document is undecided about whether to expose implementation types in the API Im confused about that If only interface types are exposed how can consumers be sure the collection objects they are dealing with are really immutable Relying on adherence to the contract seems fragile A buggy smart custom implementation can cause hardtodiagnose problems far from the source of the error It defeats the encapsulation benefits of using immutable types in APIs the name of the mutate extension could be a bit misleading since it is returning a new collection with the given modification and not mutating the existing collection In this way it is similar to the copy method on data classes so maybe we could change mutate to be copy or some other name that indicates that a new collection is being returned and the existing collection is unmodified IterableTintersectother IterableT takes a very long time to complete when called with a PersistentList as a parameter Same function works faster with other iterables like List and Set It is minutes with PersistentList and milliseconds with List I couldnt find the exact reason for that but it seems that CollectionretainAll does something with the persistent list which takes ages to complete Here are some examples toListintersect toList takes milliseconds toListintersect toPersistentList takes minutes toListintersect toPersistentListtoSet takes milliseconds toMutableListretainAll toPersistentList takes minutes toMutableListretainAll toPersistentListtoList takes milliseconds My main blocking issue is that is not supported immutableOf functions shouldnt be deprecated They should return Immutable instead of Persistent eg val x immutableSetOf val y ImmutableSetInt immutableSetOf x is PersistentSetInt y is ImmutableSetInt If I want an Immutable why force me to write an explicit type Its not like immutableOf functions are difficult to create or maintain For example here is a ConcurrentSet kotlin import kotlinxcollectionsimmutablePersistentSet import kotlinxcollectionsimmutablepersistentSetOf import kotlinxcollectionsimmutabletoPersistentSet import javautilconcurrentatomicAtomicReference class ConcurrentSetEinitialValue SetE persistentSetOf MutableSetE private val set AtomicReferenceinitialValuetoPersistentSet fun get setget fun modifyoperation PersistentSetE PersistentSetE Boolean while true val old setget val new operationold if old new return false if setcompareAndSetold new return true override fun iterator MutableIteratorE object MutableIteratorE IteratorE by setgetiterator override fun remove throw UnsupportedOperationException override fun addelement E modify itaddelement override fun addAllelements CollectionE modify itaddAllelements override fun clear modify persistentSetOf override fun removeelement E modify itremoveelement override fun removeAllelements CollectionE modify itremoveAllelements override fun retainAllelements CollectionE Boolean TODO Refrain from using these methods if concurrent safety is required Use get instead override val size get setgetsize override fun containselement E setgetcontainselement override fun containsAllelements CollectionE setgetcontainsAllelements override fun isEmpty setgetisEmpty Benchmark parameters adjustment and benchmark result files will be removed before merging Introducing CollisionTrieNode for collision nodes polymorphism approach adds significant performance losses see hashSet regressions Thus collision nodes and normal nodes were not separated into different entities Final benchmark results Canonicalization of collision nodes may help