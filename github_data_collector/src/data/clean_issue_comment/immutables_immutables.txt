It seems to be the combination of a ValueEnclosing and the inner ValueImmutable classes extending the ValueEnclosing class making the parent abstract Value class the default one resolved when using an unqualified name The generated source code needs to qualify the super reference with ImmutableXYZInnerClasssuperxyz It will make sense if you look at the project Hi the suppression mechanisms for javaxannotationGenerated do not seem to work for me I configured three exections using maven run annotation processors on jdk with javac release proconly compile everything to java with release javac procnone compile everything but moduleinfojava to java javac release procnone The first run is done in the generatesources phase of maven like this execution idrunannotationprocessorsonlyid phasegeneratesourcesphase goals goalcompilegoal goals configuration proconlyproc compilerArgumentXlintallcompilerArgument showWarningstrueshowWarnings showDeprecationtrueshowDeprecation false means true useIncrementalCompilationfalseuseIncrementalCompilation annotationProcessorPaths path groupIdorgcheckerframeworkgroupId artifactIdcheckerartifactId versioncheckerversionversion path path groupIdorgimmutablesgroupId artifactIdvalueartifactId version any or version path annotationProcessorPaths excludes excludemoduleinfojavaexclude excludes configuration execution For me it seems as immutables will not pick up the option allowedClasspathAnnotations javalangOverrideclass on the main package nor the file METAINFextensionsorgimmutablesinhibitclasspath I was working on a problem such as the following To allow to be optionally passed in with the builder but if not passed in Lazily compute it Foo fooTheFirst ImmutableFootbuilder value value build Foo fooTheSecond ImmutableFootbuilder value value barnew Bar build fooTheFirstgetBar returns lazily computed default Bar fooTheSecondgetBar returns instance of Bar I know this seems very similar to the normal Default Perhaps this is a logic error and Im just not thinking straight I just want to create an instance of Bar once and use it for the life of the Immutable Unless provided in the builder This fixes issues to copy over set custom SuppressWarnings annotations When creating an immutable class that derives from a base class containing a method with a generic return value the Maven install build fails Any other immutable used somewhere in the source code here for example Index produces errors of the type ERROR UsersfrankDevelopmentcompaniesbynubianworkspacesdevelopmentbynubiandatamodelbynubianelasticsearchcoresrcmainjavacombynubianelasticsearchmanagementIndexSetManagementjava cannot find symbol ERROR symbol class Index But when going to the generated code in Eclipse no errors are present I have attached a example class for reference Add the code to any project that uses Maven and has other immutables and you should see the problem Any ideas Best regards Frank Montyne Problemzip With Builders we can add a static nested class named Builder that will be extended by a generated Builder There is no equivalent for Modifiable Therefore if we want to use Modifiable to simulate smart builders there is no way to achieve the same functionality If Ive an attribute that is ListList the library ensures that the outer list is immutable However I need deep immutability The inner lists should also be detected made immutable We need the ability to determine the schema of Immutable objects that are persisted in a database like MongoDB Since there is no way to inspect private fields of the Immutable class using reflection the closest available alternative was to inspect the mutator methods on the Immutable Builder class But that approach is hacky because the builder class has additional methods equals from wait and collection utility methods like addAll remove set etc Additionally the builder sometimes has overloaded methods eg if a field is of type Optional Also fields annotated with GsonIgnore cant be excluded from the schema when enumerating mutators on the Builder So far generating a new Fields class seems to be the best available option to be able to determine a database schema See The main driver for this change is to be able to determine the schema of objects X in our example that are persisted in a database like mongoDB Since there is no way to inspect private fields of the Immutable class using reflection the closest alternative is to inspect the mutator methods on the Immutable Builder class But that approach is hacky because the builder class has additional methods equals from wait and collection utility methods like addAll remove set etc Also the builder sometimes has overloaded methods eg if a field is of type OptionalT Also fields annotated with GsonIgnore cant be excluded from the schema when enumerating mutators on the Builder Thus generating a new Fields class seems to be the best available option to be able to determine a database schema