Referring to this Quoting RFC An object structure is represented as a pair of curly brackets surrounding zero or more namevalue pairs or members A name is a string A single colon comes after each name separating the name from the value A single comma separates a value from a following name The names within an object SHOULD be unique object beginobject member valueseparator member endobject member string nameseparator value RapidJSON follows this strictly right now There have been enhancement requests to allow relaxation of these rules see eg it says it rapidJSON follows it strictly could you please clarify the behaviour i used the example code provided and when used duplicate key Parse accepted Modified JSON with reformatting hello rapidjson hello world t true f false n null i pi a Lua Mio author Milo Yip pah Hello I am having trouble writing nested arrays back into the file Rapidjson correctly reads the nested arrays but when trying to write it back to a file even without any changes the inner arrays do not get copied I use the following for writing to file Convert it back to a string rapidjsonStringBuffer strbuffer rapidjsonPrettyWriterrapidjsonStringBuffer writerstrbuffer sLoadedDocumentAcceptwriter stdstring jsonstrbufferGetString strbufferGetSize Write to file stdofstream outsdocumentPath out json outclose This is what i am expecting to see in the json animConfig and this is what i get animConfig This happens to all nested arrays in the json not just to this one What am i doing wrong Many thanks Hi I have been using the library for a long time and its simply great I have one simple question though related to the Pointer implementation which I couldnt answer by reading the Tutorial multiple times I have a use case where I keep one single JSON document instance and I have to continuously update the value of some entries in such document as well as create new entries sometimes To simplify the code I have been using a function like this for both creating new entries and changing existing entries values void TestSetValueconst char key const char value PointerkeySetmjsonDoc value So the question would be Is it ok to repeatedly call PointerSet on the same key Or does it cause the old value to not be properly disposed thus leading to memory leak If so the best option is to use PointerSwap for existing entries Thanks Fixed some wrong links Hi I want to implement a generic rest parser I was going through the rapidjson library found it very useful My requirement is to parse a really big complex json file extract the values provided as the arguments in c Lets say following is an excerpt from my json file states entry key ENTITY value barring false id DefaultDeviceLifeCycleActive initial true name Active final false Parameters like statesentryvalueid would be provided I want to return the value of id tag Can you please provide some pointers on it that how can it be implemented Hello I am new to rapidjson I have this huge JSON file which i am parsing and performing different modifications on it I am able to achieve most of it Struck at this one unable to figure out how to do it A simplified example This is how the JSON tree looks like Object label key value label key value key a value b label description snip labelm keym featurem The labelm object has to be changed to the following after modification rest of the object remains the same labelm The keym is a special keyword I first get the value for it ie featurem And then get the corresponding value a number against featurem from a different file This part is have got it working What i am unable to do is delete the labelm object and add the new one with value Here is the code i am using C for rapidjsonValueMemberIterator childNode nodeMemberBegin childNode nodeMemberEnd childNode ifchildNodevalueIsObject ifchildNodevalueHasMemberkeym ifchildNodename labelm Get the value from the feature file Skipping that code as its irrelevant here Value s childNodevalue ChildNodevalueRemoveMemberkeym sSetInt If i do this the RemoveMember removes the keym featurem object but setInt crashes probably because i am trying to change the type of the object So do i have to delete the entire labelm object and readd it I have tried EraseMember too but couldnt get it to work Can u please help me in understanding how i can achieve this using the Memberiterator Please note though the JSON tree i have shown above contains only Object the actual tree i am parsing contains thousands of objects Hence i am using the MemberIterator in a recursive fashion not shown above to walk the entire tree When generate long json string need s Ive been running into issues with the way that decimal numbers are stored as doubles as they are not precise To remedy the issue I made some changes to the code which replace the double in the Number union with a class we created called DoubleString which contains a double which stores the value as well as a fixed character array of bytes making the struct bytes Its a bit hackey but its been working See though note we went with a byte character array instead of Im wondering if there are other options than our hack of it there have been any other improvements in double handling I do see an option kParseNumbersAsStringsFlag but Im not sure what that does To give some additional info We have a fixed decimal class which can represent values like prices very well with no loss and the way we use it with our hack is that when we know we need the original text for a number like a price we call a new function we added GetDoubleString which returns the entire struct we used to replace the d member in the union Number This gives us access to the character buffer Having a value rapidjosnValue value and a schema allOf type string type string minLength type string pattern z rapidjsonSchemaValidator gives an error object type expected string actual integer instanceRef schemaRef allOf expected string actual integer instanceRef schemaRef allOf expected string actual integer instanceRef schemaRef allOf Which is not the one is expected reading the documentation for the structure of the error object I would rather expect the same error structure that is geven for oneOf and anyOf anyOf errors type expected string actual integer instanceRef schemaRef anyOf type expected string actual integer instanceRef schemaRef anyOf type expected string actual integer instanceRef schemaRef anyOf instanceRef schemaRef So either the documentation or implementation should be fixed In case if the documentation incorrect and the implementation is correct I wonder why there exists such a thing as error merging solely for allOf I am using a library that accepts something that is copyable Is threre any class i can use that has copy constructor availble like rapidjsonValue rapidjsonGenaricValue etc