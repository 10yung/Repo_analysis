Adding any library that has a dependency to scalaxml into a monadichtml project makes it break Seen with libraryDependencies orgjulienrf endpointsxhrclientcirce Example fieldset idauthentication classcssClass onkeyup ifEntersetsubmitLogin will fail with overloaded method constructor UnprefixedAttribute with alternatives error key Stringvalue Option Seq scalaxmlNode next scalaxmlMetaDatascalaxmlUnprefixedAttribute and error key Stringvalue Stringnext scalaxmlMetaDatascalaxmlUnprefixedAttribute and error key Stringvalue Seq scalaxmlNode next scalaxmlMetaDatascalaxmlUnprefixedAttribute error cannot be applied to String scalascalajsjsDynamic Unit scalaxmlMetaData error fieldset idauthentication classcssClass onkeyup ifEntersetsubmitLogin instead of compiling Use case scala def actionHandlerev MouseEvent Rx Unit actioncommandmap case SomeactRes actionResult actRes case None printlnno RunResult If this makes sense would it be OK to publish an RC I have some production code that may depend on this working though I guess i could get around it by manually working with Cancelables This seems to be a pervasive issue though it usually doesnt cause an issue in rendering However when it does it is fairly annoying I suggest we have a way like this to rewrite rules Not sure if we want to implement the full version from scalaxml havent looked at it yet but I suspect we could do something much simpler as with a tail recursive filter example of Merge method in doc is val r Rx Int val r Rx Int val merged Rx Int r merger r r merged but I run code below JSExport def run Unit val a Var val b Var val c amergeb val body div divaadiv divbbdiv divccdiv div mountdomdocumentbody body got result browser a b c not what I expect a b c Anything wrong here Merge is often used for complex wiring for patterns like redux there the default behavior of running all initial values through is very annoying I would be happy to have an alternative merge that will not put all initial values through itself but will just start from the initial value of the last merged element x Map Merge Collect Zip DropRep SampleOn FlatMap maybe Performance tests maybe Make rxsharing private documentation rationale from This is a WIP still need to and appreciate any help or suggestions for x more flatMap examples x merge example composition examples tailshareable mixed with alwaysshareable quick look at imitate example algorithmic considerations I suspect a logic error on my part not sure why though even if assertafoldp impurevalue I would expect assertbimpurevalue to work I implemented a simple router along with some helper functions here In the working example we have the helper class scala implicit class RxNodeval rxNode Rx Node extends AnyVal def toNodeerrNode Node divError div Node val nodeOuter div rxNode div nodeOuterchildheadOption match case Somend div classdebug nd div case None errNode I dont understand why the first case cant just be case Somend nd but if you leave it as that you will see bad things happen when you switch between the path counter and any other path starting with ie some html wills stay there and not be replaced while new html continues to be added to the view 