Hey Svartalf Im calibrating my postgresql connection pool choosing total of connections The recommended formula is corecount effectivespindlecount numcpus handles the core count but I dont know of any utility to derive effectivespindlecount if that is even possible This lead me to wonder whether maybe effectivespindlecount is something that can be determined and added to heimrs Does this interest you Updates the requirements on macaddr to permit the latest version details summaryChangelogsummary pemSourced from a href changelogaemp blockquote h h h Addedh ul licodecode formatting render colonseparated MAC address eg codeAB DEF codeli licodecode formatting flag render hyphenseparated MAC address eg codeAB DEF codeli licodecode formatting flag render periodseparated MAC address eg codeAB DEF codeli ul h h h Addedh ul licodeMacAddr nilcode and codeMacAddr nilcode methods to create new nil MAC addressesli licodeMacAddr broadcastcode and codeMacAddr broadcastcode methods to create new broadcast MAC addressesli ul h Fixedh ul licodestdfmtDisplaycode implementation for codeMacAddr code properly renders address in a canonical form a href ul blockquote details details summaryCommitssummary ul lia href Release v li lia href nostd check for CIli lia href Support codecorefmtDisplaycode and alternative formats a href lia href Fixing the CI buildli lia href Updating CHANGELOG for v li lia href Release v li lia href Fixing canonical form for MacAddr li lia href Updating documentation a little bitli liSee full diff in a href viewali ul details br Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details Similar to heimprocessProcessusage it should calculate the CPU load ratio Both aggregated and perCPU functions should be implemented Your FOSSA integration was successful Attached in this PR is a badge and license report to track scan status in your README Below are docs for integrating FOSSA license checks into your CI CircleCI TravisCI Jenkins Other heim could show the same info that dmidecodeSystem does Current implementation of heimError is far from a good one Error type main problem being is that it is impossible to get source error details as they are either hidden behind the Boxdyn Error type or would require some additional public API ex get stdioErrorKind from the heimError As most errors which can happen are some kind of IO failures it seems that heimError can be rewritten as a newtype wrapping the stdioError Further investigation is required There is a Linuxspecific API for a system utilization state exists Would be nice to add it to heim as it seems rather important Things to think about Which subcrate should has it procpressurecpu suits for heimcpu memory for heimmemory but what to do with an io file Old kernels does not has it so API should return OptionT Output for d e aa e c a ac d c commit cargo bloat release time j Compiling Time Crate s syn s uom s heimderive s nix s cc s procmacro s heimprocess s libc s futuresutil s heimcpu s heimdisk s futuresexecutor s rawcpuid s heimsensors s heimmemory s heimnet s memchr s semverparser s numrational s heimhost s numtraits s threadpool s heimvirt s quote s semver s autocfg s hex s buildscriptmain s numcpus s rustcversion s numinteger s heimruntime s platforms s typenum s heimcommon s bitflags s macaddr s futuresio s futurescore s futureschannel s heim s slab s unicodexid s futures s void s lazystatic s futuressink s cfgif s pinutils x syn and quote uom It is going to use the same syn version as heim does this should cut the compilation time x heimderive is based on the syn and quote not much can be done there get rid of nix dependency It is not used so much RUSTFLAGSZ selfprofile x Since asyncawait feature is merged now to Rust nightly and going to be published as part of version it is time to RIIAA Rewrite It In AsyncAwait It would be nice to publish the finished version right after the release Since utmpwtmp is not available in musl hostusers stream will always be empty and any hostUser method will panic as there is no data to provide As for now nothing will be implemented instead of the missing utmp routines and this issue exists only as a note for anyone wondering why it does not work as intended