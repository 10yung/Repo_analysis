For instance limit modifications to variable names and make sure all instances of mimicked variables get mimicked in the same way With such a mode mimicked code could get committed and pass testing without incident Then perhaps a year later somebody tries to add another instance of a mimicked variable and all hell breaks loose Windows redirection to a file breaks because of some lack of support for unicode or utf or something D Fin Desktop Python ChessBottype gamepy mimic game py Traceback most recent call last File C Program Files Python Scripts mimicscriptpy line in module loadentrypointmimic consolescripts mimic File C Program Files Python lib sitepackages mimic py egg mimic initpy line in main File C Program Files Python lib sitepackages mimic py egg mimic initpy line in pipemimic File C Program Files Python lib sitepackages mimic py egg mimic initpy line in pipe File C Program Files Python lib encodings cp py line in encode return codecscharmapencodeinputselferrorsencodingtable UnicodeEncodeError charmap codec cant encode character u c f in position character maps to undefined The error message is of course slightly different every time because of different homoglyphs but in general it consistently fails on windows I havent been able to test it because apparently the windows command line is absolutely garbage at utf support No matter which mode I use it fails to encode a character If anyone on Linux could test this out thatd be appreciated When giving file input to a nix command you can use command file rather than cat file command Currently mimic only converts the homoglyphs to explicit utf codepoints when running mimic heck To allow automated testing this behavior should change to allow programmatic detection of homoglyphs Having an exit code greater than would allow programmatic tests This implements the steganography feature described in It works as follows The file to encode specified by encode is read and converted to a bit stream During the mimicking process mimicked characters represent one or more bits depending on the amount of replacement options If there are replacement options one bit of information can be encoded in the character is represented by the first option is represented by the second If there are still only one bit can be FULLY encoded With bits of data can be encoded and so on is represented by the first is represented by the third The number of bits that can be represented is intloglenoptions There must be more than two options otherwise no bits can be encoded In this case the original character is passed through Each bit from the encode file is put into the output using this method The end of the data is marked by a character that is outside the normal encoding range If there are replacements then the rd would be used as it could not be used to otherwise represent a bit The first two options are used to represent a and a but the third option cannot be used to encode data For replacements either the th or the th could be used since either would be otherwise unused If there are exactly the number of replacements the original character is passed through and the next mimic attempt will include the stop character After all the input data has been encoded and a stop character has been inserted the replacements go back to a random chance This method is compatible with the meharder option and is in fact likely necessary in order to hide information of any substantial size In addition this change also supports mimicking files passed in with the source option rather than on stdin and the tests have been updated to use nose so they can be run using python setuppy test Highlighting the wrong characters those like U E in output to stdout would be great what do you think Homoglyphs from repo A B C D E F G H I J K L M N O P Q R S T V W X Y Z a c d e g h i j l m n o p s u v w x y z Thats what I see in the Sublime Text To move most of the fun to runtime rather than compile or IDE issues offer a mode to only mimic strings 