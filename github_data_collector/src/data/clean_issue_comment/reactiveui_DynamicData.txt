Is your feature request related to a problem Please describe Well not exactly a problem but it could benefit everyone thats using the DD on mobile and other platforms too Shuffling on the lists and unnecessary update of whole item in the UI due to the replacement of items even when their TKey is the same as the previous cached version That means the items are equal not the same reference but only a property has changed The issue Im talking about is mentioned in this issue The real life case In my most recent projects Ive been using Akavache as fetcher of data and caching mechanism and DynamicData to provide the data through my services connecting them through the viewmodels Thats a nice duo but Im constantly being hit by the combination of GetAndFetchLatest gets from the cache and from the remote AddOrUpdateEditDiff because the replacement of items is making my lists to shuffle when a property of the object gets changed on the remote Describe the solution youd like As already discussed in the issue above there are two proposed solutions one is to provide a Transform that receives an update action as argument so that could be implemented for each specific case before presenting the data at the viewmodel level for my case at least the second one is to provide something closer to the cache itself like the EditDiff and AddOrUpdate making use of the Edit to perform the update action as passed in I think both of these mechanisms would be great additions to the framework For my case the second one would be the perfect addition to not have to rely on it as an extension snippet that I copy and paste into my project With them in place I imagine it would cover most of the cases people are using having this optimization out of the box to be used With that we could fine grain how the items would get updated and when Describe alternatives youve considered No others for now Describe suggestions on how to achieve the feature They are already proposed on the issue Additional context Unlike ExpireAfter the LimitSizeTo does not notify the subscribers on deletion only on completion I listen on a Observable and to keep track of it like history I put it into a ObservableChangeSet and persist it Basically a persistable history of an Observable The Observable I listen runs forever But the LimitSizeTo never notify the subscriber when deletion occurs only when the ISourceCache completes So I cannot delete the oldest objects from the database to keep the memorydisk size constant The code where it fails for me public IObservableIChangeSetTObject TKey CreatePersistenceObservableChangeSetTObject TKey IObservableTObject fromObservable FuncTObject TKey keySelector int sizeLimit return ObservableChangeSetCreatecache var collection GetCollectionTObject var compositeDisposable new CompositeDisposable initial load from database after restart cacheAddOrUpdatecollectionFindAll if sizeLimit cacheLimitSizeTosizeLimit Subscribeitems foreach var keyValuePair in items collectionDeletekeyValuePairKey DisposeWithcompositeDisposable fromObservableSubscribeitem collectionUpsertkeySelectoritem item cacheAddOrUpdateitem DisposeWithcompositeDisposable return compositeDisposable keySelector Hi there I noticed the following odd behaviour which I think is a bug in ObservableCache Describe the bug If I subscribe to the observable returned by ObservableCacheConnect as items are being added to the cache on a separate thread these additions are not reliably reflected in the changes received on the subscription Steps To Reproduce The following code reproduces the issue fairly reliably on my PC c var source EnumerableRange ToObservable SubscribeOnNewThreadSchedulerDefault DelayTimeSpanFromSeconds Publish var cache source ToObservableChangeSetx x AsObservableCache sourceConnect await sourceLastAsync var allChanges await cacheConnectFlattenSelectchg chgCurrentToList AssertThatallChanges IsEquivalentToEnumerableRange If I wait until the source has fully populated the cache by uncommenting the await above or if I delay populating the cache until after subscribing by uncommenting the Delay above then the result is as expected which suggests this is a concurrent subscribeupdate issue Expected behavior allChanges should contain all items produced by source Screenshots If applicable add screenshots to help explain your problem na Environment Please complete the following information OS Windows Pro Device PC Version Working Version na Additional context My best guess as to whats going on is that some updates are sneaking in between the lock being released in ObservableCacheConnect in which the initial snapshot is created and the returned observable being subscribed to Best wishes thanks for creating this library Chris This is just an example of onetomany where the a subrecord could be referencedshared by many parent records Inner join might make sense not to return duplicates but cardinality of right join should be that of the set on the right public class SubRecord public Guid id get set public string Desc get set public class Record public int id get set public Guid SubId get set public string Desc get set class Program static void Mainstring args var recordsCache new SourceCacheRecord inti iid var subRecordsCache new SourceCacheSubRecord Guidi iid subRecordsCacheEditcache cacheAddOrUpdatenew SubRecord id GuidParsef cebdba dc ec c c a Descsub one cacheAddOrUpdatenew SubRecord id GuidParse d e ddbab ceba c Descsub two cacheAddOrUpdatenew SubRecord id GuidParse c f fa f bb bcae d a b Descsub three recordsCacheEditcache cacheAddOrUpdatenew Record id SubId GuidParsef cebdba dc ec c c a Desc parent of sub one cacheAddOrUpdatenew Record id SubId GuidParsef cebdba dc ec c c a Desc parent of sub one cacheAddOrUpdatenew Record id SubId GuidParse c f fa f bb bcae d a b Desc parent of sub three var innerJoinResultSubscription subRecordsCacheConnect InnerJoinrecordsCacheConnect records recordsSubId SubRecord subrecord Record record r record s subrecord Bindout var innerJoinResult Subscribe ConsoleWriteLineinnerJoinResultList count innerJoinResultCount innerJoinResultToObservable Subscribeitem ConsoleWriteLine itemItem Desc itemItem Desc right join of subrecord to parents expected result cardinality of n parent records var rightJointResultSubscription subRecordsCacheConnect RightJoinrecordsCacheConnect records recordsSubId key subrecord record ifsubrecordHasValue return record record subrecord subrecordValue else return record record subrecord defaultSubRecord Bindout var rightJoinResult Subscribe ConsoleWriteLinerightJoinResultList count rightJoinResultCount rightJoinResultToObservable Subscribeitem ConsoleWriteLine itemItem Desc itemItem Desc The result is invalid innerJoinResultList count parent of sub one sub one parent of sub three sub three rightJoinResultList count parent of sub one sub one parent of sub three sub three Expected result is rightJoinResult count of or innerJoinResultList count parent of sub one sub one parent of sub one sub one parent of sub three sub three rightJoinResultList count parent of sub one sub one parent of sub one sub one parent of sub three sub three Here is the corresponding SQL use tempdb CREATE TABLE SubRecord id INT PRIMARY KEY Name VARCHAR NOT NULL CREATE TABLE Record id INT PRIMARY KEY SubId INT NOT NULL Name VARCHAR NOT NULL insert into SubRecord values sub one sub two sub three insert into Record values parent ref to sub parent ref to sub parent ref to sub select parentName Name subName SubName from SubRecord sub inner join Record parent on subid parentSubId select count from select subid from SubRecord sub inner join Record parent on subid parentSubId as innerjoinresult select parentName Name subName SubName from SubRecord sub right join Record parent on subid parentSubId select count from select subid from SubRecord sub right join Record parent on subid parentSubId as rightjoinresult and the result Inner Join count parent ref to sub sub one parent ref to sub sub one parent ref to sub sub three Right Join count parent ref to sub sub one parent ref to sub sub one parent ref to sub sub three PS It looks like var rightCache rightSynchronizelockerChangeKeyrightKeySelectorAsObservableCachefalse assumes that subrecords could not be shared by parent records as ChangeKey eliminates all but one parents that share subrecords unique key constraint replacing RightJoin with this Transform produces expected result but I am unsure about concurrency issues var rightJoinResultSubscription recordsCacheConnect Transformrecord var subrecord subRecordsCacheLookuprecordSubId if subrecordHasValue return record record subrecord subrecordValue else return record record subrecord defaultSubRecord Bindout var rightJoinResult Subscribe PS This is a followup to a closed questionissue about manymany relationships implementation The correct solution there is to use a RightJoin instead of recommended InnerJoin Bumps FluentAssertions from to details summaryRelease notessummary pemSourced from a href releasesaemp blockquote h h pa href h h pa href h h pa href Notesap h h pa href Notesap h h ul liNew Provide optout to codeAssertionOptionso gt oWithStrictOrderingcode a href liNew Add collection assertion codeContainEquivalentOfcode a href liNew Add codeShouldNotThrowAftercode assertion for actions a href ul pKudos to a href a href and a href for these amazing additionsp h h ul liFix Performance fixes in codeBeEquivalenTocode a href liFix Reverted changes to codeAssertionScopecode to ensure binary compatibility a href ul h h ul liFix Allows codeBeEquivalentTocode to handle a nongeneric collection as the SUT a href a href liFix Optimized performance of codeIncludeMemberByPathSelectionRulecode a href ul h h ul liNew Now provides a hint when strings differ in length and contain differences a href a href liNew Added codeThrowAsynccode codeThrowExactlyAsynccode and codeNotThrowAsynccode a href liNew Added support for codeShouldThrowcode and codeShouldNotThrowcode for codeFunc ltT gtcode a href liNew Added support for codeprivate protectedcode access modifier a href liNew Updated codeBeApproximatelycode to support nullable types for both the subject and the expectation nullable a href liNew Added codeasynccode version of codeExecutionTimecode to a href liNew Updated codeNotBeApproximatelycode to accepting nullable subject and expectation a href liNew codetypeShouldBetypecode now support open generics a href a href liFix Minor performance improvements to prevent rendering messages if a test did not fail a href a href liFix Improve performance of codeShouldAllBeEquivalentTocode a href a href liFix Improve the presentation of enums to include the value and the number a href a href liFix codeBeEquivalentTocode with codeWithStrictOrderingcode produced messy failure message a href liFix Fixes detecting checking equivalency of a codenullcode subject to a dictionary a href liFix Fixes duplicate conversions being mentioned in the output of the equivalency API a href liFix Comparing an object graph against codeIEnumerablecode now works now as expected a href liFix Selecting members during object graph assertions now better handles codenewcode overrides a href a href ul pstrongNotestrong In versions prior to FA may have skipped certain properties in the equivalency comparison a href fixes this so this may cause some breaking changesp pLots of kudos a href and a href for a majority for the work in this releasep h h trtable truncated blockquote details details summaryCommitssummary ul lia href Added release notes for a href lia href Merge pull request a href from jnyrupenumequalityli lia href Reintroduced the dependency on SystemXmlLinq for NET li lia href Increase mutation score a href lia href Increase mutation scoreli lia href Merge pull request a href from jnyrupconfigurationStoreInterceptorli lia href Intercept Reflection exceptions from codeAppSettingsConfigurationStorecodeli lia href Merge pull request a href from jnyrupxmlSummariesli lia href Cleanup parameter xml summariesli lia href Fix comparing enums and integers for equalityli liAdditional commits viewable in a href viewali ul details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot close will close this PR and stop Dependabot recreating it You can achieve the same result by closing it manually dependabot ignore this major version will close this PR and stop Dependabot creating any more for this major version unless you reopen the PR or upgrade to it yourself dependabot ignore this minor version will close this PR and stop Dependabot creating any more for this minor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language dependabot badge me will comment on this PR with code to add a Dependabot enabled badge to your readme Additionally you can set the following in your Dependabot dashboard Update frequency including time of day and day of week Pull request limits per update run andor open at any time Automerge options neverpatchminor and devruntime dependencies Outofrange updates receive only lockfile updates if desired Security updates receive only security updates if desired details In trying to set up paging of a SourceList according to the examples in DynamicTrader I noticed that there seems to be an inconsistency in what type of IChangeSets are returned for operators for ObservableCache and ObservableList The example in DynamicTrader uses an IObservableCache and Sort returns ISortedChangeSet and Page returns IPagedChangeSet csharp cleanUp tradeServiceAllConnect Filterfilter apply user filter Transformtrade new TradeProxytrade new ParallelisationOptionsParallelTypeOrdered Sortsort SortOptimisationsComparesImmutableValuesOnly Returns ISortedChangeSet Pagepager Returns IPagedChangeSet ObserveOnschedulerProviderMainThread Dochanges PageParametersUpdatechangesResponse changesResponse available because of IPagedChangeSet Bindout data update observable collection bindings DisposeMany dispose when no longer required Subscribe If you try to do the same with a IObservableList instead everything returns IChangeSet csharp var listTradeService new SourceListTrade cleanUp listTradeServiceConnect Filterfilter apply user filter Transformtrade new TradeProxytrade Sortsort Returns IChangeSet Pagepager Returns IChangeSet ObserveOnschedulerProviderMainThread Dochanges PageParametersUpdatechangesResponse changesResponse NOT available because of IChangeSet Bindout data update observable collection bindings DisposeMany dispose when no longer required Subscribe No matter which way is supposed to be the correct way of doing things it can get really confusing when trying to use the operators Description When filling a cache from an observable using ToObservableChangeSet with expireAfter and AsObservableCache memory keeps groving See example code below and description how to see issue ExpiringCache itemSource ToObservableChangeSetvt vtGuid i TimeSpanFromSeconds AsObservableCache Steps To Reproduce Start attached program to reproduce issue When program running with Visual Studio i use Pro go to Diagnostic Tools Memory Usage and click on Take Snapshot After some time eg seconds take a second snapshot Compare the snapshots by clicking on the Object diff cell of the second snapshot In comparison loads of ExpirableItems inside dictionaries can be seen see screenshot below It seems like when expired objects are removed from cache some helper objects are still kept alive Long term memory profiling of similar setup with larger objects show increasing memory Expected behavior Memory should not keep growing after expirethreshold Screenshots Environment OS Windows Device PC Version DynamicData Working Version na Additional context Add any other context about the problem here ExpireTestzip Hi Guys Im interested in using my existing c viewmodels within Blazor Does anyone know if DynamicData works within Blazor I know you get ReactiveUIBlazor that is supported but what about DD Blazor is obviously single threaded Can DD work on a single thread and was StateHasChanged used in the implementation Describe the bug When you use the OnItemAdded method to react to ChangeSets of a SourceList and add new items to a SourceList the order of the generated Add ChangeSets might be wrong depending on the order of using Subscribe or OnItemAdded on the ChangeSet observable returned by Connect This will result in a follow up exception in any classes which consume the ChangeSets like binding onto a ReadOnlyObservableCollection Steps To Reproduce TestMethod public void DynamicDataReaddTest SourceListint source new SourceListint IListint indices new Listint Block A begin sourceConnectOnItemAddedit if it sourceAdd Subscribe ex AssertFail Block A end Block B begin sourceConnectSubscribeit SystemDiagnosticsDebugWriteLineit foreach Changeint change in it DebugWriteLine Change change ItemChangeint item changeItem DebugWriteLine Item item DebugWriteLine ItemCurrentIndex itemCurrentIndex ItemCurrent itemCurrent indicesAdditemCurrentIndex ex AssertFail Block B end sourceAdd CollectionAssertAreEqualnew Listint indicesToCollection When you run this unit test it will fail and will generate the following debug output ChangeSetInt Count Change Add Current Previous None Item Current Previous None ItemCurrentIndex ItemCurrent ChangeSetInt Count Change Add Current Previous None Item Current Previous None ItemCurrentIndex ItemCurrent As you see the Add ChangeSet for the second number added comes first CurrentIndex then the Add ChangeSet for the first number added comes second CurrentIndex This results in an ArgumentOutOfRangeException in the ReadOnlyObservableCollection because the CurrentIndex is not valid yet If you swap the blocks A and B to change the order when a subscription is build you will get the correct order TestMethod public void DynamicDataReaddTest SourceListint source new SourceListint IListint indices new Listint Block B begin sourceConnectSubscribeit SystemDiagnosticsDebugWriteLineit foreach Changeint change in it DebugWriteLine Change change ItemChangeint item changeItem DebugWriteLine Item item DebugWriteLine ItemCurrentIndex itemCurrentIndex ItemCurrent itemCurrent indicesAdditemCurrentIndex ex AssertFail Block B end Block A begin sourceConnectOnItemAddedit if it sourceAdd Subscribe ex AssertFail Block A end sourceAdd CollectionAssertAreEqualnew Listint indicesToCollection This will pass the unit test and create the following debug output ChangeSetInt Count Change Add Current Previous None Item Current Previous None ItemCurrentIndex ItemCurrent ChangeSetInt Count Change Add Current Previous None Item Current Previous None ItemCurrentIndex ItemCurrent Expected behavior The order of the ChangeSet itemsevents should be the same regardless of the order of subscriptions build on the observable returned by Connect Environment Version DynamicData Given this code var source new SourceCacheAppExtension stringa aId source Connect ObserveOnDispatcher TransformAsyncasync ext new ExtensionViewModelext await extGetExtensionPropertiesAsync await GetLogoext Bindout extensions DisposeMany Subscribe DisposeWithdisposables private async TaskBitmapImage GetLogoAppExtension ext var filestream await extAppInfoDisplayInfoGetLogonew WindowsFoundationSize OpenReadAsync BitmapImage logo new BitmapImage logoSetSourcefilestream return logo When the GetLogo method is called the following error is shown The application called an interface that was marshalled for a different thread If the fluent chain is incorrect how could I asynchronously transform the input items Thanks