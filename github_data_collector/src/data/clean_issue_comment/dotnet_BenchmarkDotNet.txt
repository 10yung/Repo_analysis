Is it only to me that updating the given nuget package to versions or I get the following error Launch Execute dotnet ebb d ffa ac b adb edll benchmarkName xxxCreatexxxquantity job InvocationCount IterationCount LaunchCount UnrollFactor WarmupCount benchmarkId in path Unhandled exception SystemBadImageFormatException Could not load file or assembly path bin Release netcoreapp ebb d ffa ac b adb e bin Release netcoreapp ebb d ffa ac b adb edll An attempt was made to load a program with an incorrect format File name path bin Release netcoreapp ebb d ffa ac b adb e bin Release netcoreapp ebb d ffa ac b adb edll I just changed file names and paths Reverting back to version I think its the default when creating new projects at the moment everything works again Im at the airport now Later on I will create a minimal working example to show the problem Im just curious if someone else saw it or I have some other strange problem but its strange because reverting the version everything works again Ive got benchmarks which are taking an array as parameter see below for a simplified example Ive added grouping via an attribute to my test class GroupBenchmarksByBenchmarkLogicalGroupRuleByCategory BenchmarkLogicalGroupRuleByParams the problem is that the benchmark result is showing me the parameter type only without array size which makes the information useless Benchmark code simplified public IEnumerableobject Arrays yield return new object new int yield return new object new int ArgumentsSourcenameofArrays public int Testint data Result currently simplified Method data Test SystemInt Result expected Method data Test SystemInt Can also be int or SystemInt Length According to the docs the default exporters are CSV HTML and Markdown I only want html but the docs dont say how to disable the rest Ive tried adding the HtmlExporter attribute to my test class only but it did not helped Im running my tests with fluent style this way var summary BenchmarkRunnerRunMyTestDefaultConfigInstanceWithConfigOptionsDisableLogFile Similar to This sample benchmark does not increase the opinvocation on warmup when a method is marked with the IterationCleanup attribute public class TestBenchmark Benchmark ArgumentsSourcenameofGetValues public int Case string value return valueLength Benchmark ArgumentsSourcenameofGetValues public int Case string value return valueLength IterationCleanup public void Clear public IEnumerablestring GetValues yield return Value yield return Value The workload stall at When removing the IterationCleanup attribute the workload increase as usual Few users has reported to me that its not obvious that in order to make BenchmarkSwitcher handle console line arguments they must be passed to the Run method We should detect a situation where args were not passed to BDN but are present via EnvironmentGetCommandLineArgs It should be just a few lines of code but should definitely improve the first user experience Fixes It would be better to unify display text generation across all parameters but cannot find a good place for a common method Maybe a base class There is a difference of array representation in summaries depending on a value source In case when ArgumentsAttribute is used an array is displayed as Array arrayLength but in case of ArgumentsSourceAttribute the type name is used The bug can be simply reproduced using the IntroArrayParam sample Method array value Mean Error StdDev ArrayIndexOf SystemInt ns ns ns ArrayIndexOf SystemInt ns ns ns ManualIndexOf SystemInt ns ns ns ManualIndexOf SystemInt ns ns ns ArrayIndexOf SystemInt ns ns ns ManualIndexOf SystemInt ns ns ns The expected behavior is the same as ArgumentsAttribute has csharp Benchmark Argumentsnew int public int ArrayIndexOfint array int value ArrayIndexOfarray value Method array value Mean Error StdDev ArrayIndexOf Array ns ns ns The same issue happens with parameters On Mac OS dotnet version Using dotnet tool to create a BenchmarkDotNet templates project and run it in console dotnet new benchmark consoleapp The generated project cannt built and print the error error NU Project XXXX is not compatible with netcoreapp NETCoreAppVersionv I think the BenchmarkDotNet version referenced by the project is not the right one Because I find the BenchmarkDotNet referenced in the csproj file is and I change the version to The error is gone Ive setup my environment before in NET Framework and my benchmarks worked really great in the past Kudos for this great lib My current issue now is that Im trying to run benchmarks in a new project this time in NET Core After writing my last benchmark and executing them I stumbled upon this error C Program Files dotnet sdk MicrosoftCommonCurrentVersiontargets error MSB Could not copy the file C Users KevinAvignon Documents Dev GitHub RRC RobotmasterCollectionRecommendation RobotmasterCollectionRecommendationBenchmarks bin Release netcoreapp f f e bd a d baf a obj Release netcoreapp f f e bd a d baf a exe because it was not found C Users KevinAvignon Documents Dev GitHub RRC RobotmasterCollectionRecommendation RobotmasterCollectionRecommendationBenchmarks bin Release netcoreapp f f e bd a d baf a BenchmarkDotNetAutogeneratedcsproj C Program Files dotnet sdk MicrosoftCommonCurrentVersiontargets warning MSB Could not write state file obj Release netcoreapp BenchmarkDotNetAutogeneratedcsprojAssemblyReferencecache The file C Users KavignonUserDir Documents Dev GitHub RRC Project ProjectBenchmarks bin Release netcoreapp f f e bd a d baf a obj Release netcoreapp BenchmarkDotNetAutogeneratedcsprojAssemblyReferencecache already exists C Users KavignonUserDir Documents Dev GitHub RRC Project ProjectBenchmarks bin Release netcoreapp f f e bd a d baf a BenchmarkDotNetAutogeneratedcsproj I made sure of the following before running my benchmarks Release mode Passing some arguments to the library m allStats f Unchecked the option Prefer bit My benchmarks functions are public Whats the catch here Im benchmarking the backend of a web application with PostgreSQL as the db We use dotConnect but it requires a dll to be signed with a licence key otherwise it fails connecting to the db I can sign any dll using a set of cmd commands But the problem here is that BenchmarkDotNet generates a new exe for every run So far Im using the InProcess toolchain and have the benchmark project signed But InProcess seems to have limits on the benchmark time Thus Im looking for a way to intersect into the toolchain lifecycle get the target exe namepath and sign it Is it attainable somehow