The code that does the alignment is wrong if align freememaddr xFFFFF freememaddr xFFFFF freememaddr x It should be masking with x FFF instead of xFFFFF if align freememaddr x FFF freememaddr xFFFFF freememaddr x Heads upSorry for the block of text and pictures This has just been bugging me for a bit and I wanted to provide as much context as I couldHeads up When playing around with videoports I noticed that the default kernel code would actually print X in the middle of the screen and not the top left corner as I would expect I thought this was weird and started playing around with that code and discovered more weird things regarding printing I couldnt print multiple characters sequentially nor change their colors For example if I remove offsetfromvga in the subscript and just had int literals I could always print a character at the top left corner of the screen on QEMU address xb but I could never change the color nor print a character immediately after For reference heres me attempting to print a blue B and green C in the top left corner with c char vga xb vga B vga x D light magenta on black vga C vga x a light green on black Error Screenshot at BUT I can get my intended results if I instead explicitly assign those values to the video memory addresses c char xb B char xb x char xb C char xb x a Expected Screenshot at I dug deeper into this and looked at the assembly to see if perhaps gcc somehow emitted some bad instructions but as far as I can tell the assembly looks clean Broken example char vga xb c f b movq xb x rbp ostutorial videoportskernelkernelc This doesnt work as intended vga B a b f mov x rbprax e c movb x rax B is successfully printed ostutorial videoportskernelkernelc vga x D light magenta on black b f mov x rbprax c add x rax This should be xb c d movb xdrax ostutorial videoportskernelkernelc vga C c b f mov x rbprax c add x rax This should be xb c movb x rax ostutorial videoportskernelkernelc vga x a light green on black b f mov x rbprax b c add x rax This should be xb f c a movb xarax Working example for reference char xb B b b mov xb eax e c movb x rax ostutorial videoportskernelkernelc char xb x b b mov xb eax c movb x rax ostutorial videoportskernelkernelc char xb C b b mov xb eax e c movb x rax ostutorial videoportskernelkernelc char xb x a b b mov xb eax c a movb xarax Even more confused I looked further with gdb make gdb Screenshot at And this is the strange part Screenshot at SOMEHOW on the set of instructions when I attempt to access vga rax decrements from xb to xb fff and I dont know why The corresponding assembly for this is b f mov x rbprax c add x rax This should be xb c d movb xdrax So to actually ask my question now have I been doing something wrong this whole time or is this a bug in QEMU or am I misunderstanding something and this is just working as intended Stuff about my environmentother stuff I tried This may or may not be a big deal but instead of cross compiling to i Im instead targeting x so I didnt have to make an i gcc from scratch in an earlier step I was able to get all other examples working with this setup until now I also havent tried making the i crosscompiler and rerunning this example but even if thats the intended way of running this example it would still be nice if someone could offer insight on why Im running into this issue for my bit case Im using GCC v for compiling QEMU version which seems to be one of the newer versions but Im also able to reproduce this with QEMU Diff for reproducing People who want to reproduce this should be able to just git apply this diff to the repo diff git a videoportsMakefile b videoportsMakefile index b be d a videoportsMakefile b videoportsMakefile HEADERS wildcard kernelh driversh OBJ CSOURCESco Change this if your crosscompiler is somewhere else CC usrlocali elfgccbini elfgcc GDB usrlocali elfgccbini elfgdb CC gcc marchx GDB gdb LD ld A x QEMU qemusystemx ELF elf g Use debugging symbols in gcc CFLAGS g all osimagebin First rule is run by default osimagebin bootbootsectbin kernelbin cat osimagebin osimagebin bootbootsectbin kernelbin oformat binary deletes all symbols as a collateral so we dont need to strip them manually on this case kernelbin bootkernelentryo OBJ i elfld o Ttext x oformat binary LD o Ttext x oformat binary Used for debugging purposes kernelelf bootkernelentryo OBJ i elfld o Ttext x LD o Ttext x run osimagebin qemusystemi fda osimagebin QEMU fda osimagebin Open the connection to qemu and load our kernelobject file with symbols debug osimagebin kernelelf qemusystemi s fda osimagebin QEMU s fda osimagebin GDB ex target remote localhost ex symbolfile kernelelf Generic rules for wildcards debug osimagebin kernelelf CC CFLAGS ffreestanding c o o asm nasm f elf o nasm f ELF o bin asm nasm f bin o diff git a videoportskernelkernelc b videoportskernelkernelc index dcc d f d a videoportskernelkernelc b videoportskernelkernelc void main Lets write on the current cursor position we already know how to do that char vga xb vga offsetfromvga X vga offsetfromvga x f White text on black background This doesnt work as intended vga B vga x D light magenta on black vga C vga x a light green on black But this does char xb B char xb x char xb C char xb x a I appreciate a lot from this repo but this repo did not finish a memory management or a simple file system I alone am not able to finish it but I have great passion in creating it Is there anyone who excels in C want to finish it with me In all of the lessonsspecifically in lesson you use x as the default screen size Why How can I get the real screen size I have installed binutils like said and it appears that it does not work because this happens i elfgcc command not found Any fixes While running the code from Lesson in an online compiler I get this ld warning cannot find entry symbol start defaulting to Command terminated by signal Can someone fix this I ve had this problem for some time now but it has spread to my testing environment The keyboard stopped working with qemu on macos then stopped working on linux and yesterday it stopped working on windows Earlier I could use the keyboard with qemu on windows but not on linux or macos and then windows went down too There was a time when all three worked and then stopped without any direct changes on my part I have no idea what s going on There are a few things incorrect in the stack section Not just the stack top can be accessed everywhere in the stack can be accessed The stack top is not x ffe its x ffa where C is stored x is the base address of the stack which doesnt contain anything so its garbage even before popping anything out of the stack Ive been following along with your tutorials and I noticed that your inttoascii function still needs to reverse the contents of the string it populates I implemented some code that reverses the string in place and tested it Hopefully this is helpful thank you so much for your awesome tutorials when I define M bytes in stackkernel has something wrong like this void main char str so I change the code in bootswitchpmasm bits initpm we are now using bit instructions mov ebp x change x to x mov esp ebp then kernel run successed this is a bug 