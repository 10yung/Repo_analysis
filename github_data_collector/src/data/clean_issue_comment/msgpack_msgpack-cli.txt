Hi I am wondering whether it is possible to serialize and deserialize a list member is a class For example in the below scenario serialization of the Customer object seems working however when I deserialize it all the info inside CustomerOrders are lost How should I fix this problem Thank you public class Order int OrderIdgetset string OrderTypegetset public class OrderList public ListOrder Ordersgetset public class Customer public int CustomerIdgetset public OrderList CustomerOrdersgetset if I use il cpp to build my appthe app throw this exception when i used msgpack Steps to reproduce Create an iOS App in Visual Studio for Mac Add a package reference to MsgPackCli Add the following model c public class ExampleModel MessagePackMember Name examples public string Example get set Add the following code c var x MessagePackSerializerGetExampleModel Results A crash with SystemNullReferenceException Object reference not set to an instance of an object at SystemReflectionCustomAttributeNamedArgumentgetMemberInfo x in UsersbuilderjenkinsworkspacexamarinmaciosxamarinmaciosexternalmonoexternalcorertsrcSystemPrivateCoreLibsrcSystemReflectionCustomAttributeNamedArgumentcs at MsgPackReflectionAbstractionsGetMemberName SystemReflectionCustomAttributeNamedArgument source x in c a a d bcf a d e at MsgPackSerializationSerializationTargetGetAttributeProperty SystemString attributeName SystemReflectionCustomAttributeData attribute SystemString propertyName x in c a a d bcf a d e at MsgPackSerializationSerializationTargetcGetAnnotatedMembersWithDuplicationDetectionb SystemReflectionMemberInfo member x d in c a a d bcf a d e at wrapper delegateinvoke SystemFunc SystemReflectionMemberInfoMsgPackSerializationSerializingMember invokeTResultTSystemReflectionMemberInfo at SystemLinqEnumerableSelectArrayIterator TSourceTResult ToArray x in UsersbuilderjenkinsworkspacexamarinmaciosxamarinmaciosexternalmonoexternalcorefxsrcSystemLinqsrcSystemLinqSelectcs at SystemLinqBuffer TElement ctor SystemCollectionsGenericIEnumerable T source x a in UsersbuilderjenkinsworkspacexamarinmaciosxamarinmaciosexternalmonoexternalcorefxsrcSystemLinqsrcSystemLinqBuffercs at SystemLinqOrderedEnumerable TElement ToArray x in UsersbuilderjenkinsworkspacexamarinmaciosxamarinmaciosexternalmonoexternalcorefxsrcSystemLinqsrcSystemLinqOrderedEnumerablecs at SystemLinqEnumerableToArray TSource SystemCollectionsGenericIEnumerable T source x e in UsersbuilderjenkinsworkspacexamarinmaciosxamarinmaciosexternalmonoexternalcorefxsrcSystemLinqsrcSystemLinqToCollectioncs at MsgPackSerializationSerializationTargetPrepare MsgPackSerializationSerializationContext context SystemType targetType x in c a a d bcf a d e at MsgPackSerializationMessagePackSerializerCreateReflectionInternal T MsgPackSerializationSerializationContext context SystemType concreteType MsgPackSerializationPolymorphismSchema schema x be in c a a d bcf a d e at MsgPackSerializationMessagePackSerializerCreateInternal T MsgPackSerializationSerializationContext context MsgPackSerializationPolymorphismSchema schema x c in c a a d bcf a d e at MsgPackSerializationSerializationContextGetSerializer T SystemObject providerParameter x in c a a d bcf a d e at MsgPackSerializationMessagePackSerializerGet T MsgPackSerializationSerializationContext context SystemObject providerParameter x e in c a a d bcf a d e at MsgPackSerializationMessagePackSerializerGet T MsgPackSerializationSerializationContext context x in c a a d bcf a d e at MsgPackSerializationMessagePackSerializerGet T x in c a a d bcf a d e at MsgPackBugTestAppDelegateFinishedLaunching UIKitUIApplication application FoundationNSDictionary launchOptions x in UsersjesperProjectsMsgPackBugTestMsgPackBugTestAppDelegatecs The crash seems to be caused by this line c var property attributeGetNamedArgumentsSingleOrDefault a aGetMemberName propertyName if propertyGetMemberName null Use default return null The property type CustomAttributeNamedArgument is a struct and when the named argument cant be found in this case NilImplication GetMemberName runs on a defaultCustomAttributeNamedArgument There is a fix existing in the codebase to handle this case but because of various ifs being used the version thats being used by Mono does not have this fix It appears that this version is being pulled in instead likely due to Mono not being possible to target for NuGet packages Inserting the same fix in the other branch would solve the issue Limited workaround This exact instance can be worked around by specifying all named arguments used in GetAnnotatedMembersWithDuplicationDetection on all attributes In other words this c public class ExampleModel MessagePackMember Name examples NilImplication NilImplicationNull public string Example get set doesnt throw However it is tedious and if theres a named argumentproperty added at some point it will likely crash in the same way Additionally it seems that this issue recurs all over the place where any MsgPackCli attribute can be used so its hard not to run into Versions used Visual Studio Community for Mac Version build Installation UUID b fee df ac c e a a GTK Raleigh theme XamarinMac d f b Package version Mono Framework MDK Runtime Mono c f ca bit Package version NuGet Version NET Core SDK SDK usrlocalsharedotnetsdk Sdks SDK Versions preview preview preview preview preview rc preview preview preview MSBuild SDKs LibraryFrameworksMonoframeworkVersions libmonomsbuildCurrentbinSdks NET Core Runtime Runtime usrlocalsharedotnetdotnet Runtime Versions preview preview preview preview preview rc XamarinProfiler Version Location ApplicationsXamarin ProfilerappContentsMacOSXamarin Profiler Updater Version XamarinAndroid Not Installed Microsoft Mobile OpenJDK Java SDK Not Found Android Designer EPL code available here Android SDK Manager Version Hash c b Branch remotesorigind Build date UTC Android Device Manager Version Hash d b af Branch remotesorigind Build date UTC Xamarin Inspector Version Hash db Branch release Build date Mon Jul GMT Client compatibility Apple Developer Tools Xcode Build B XamarinMac Version Visual Studio Community Hash e bc Branch xcode Build date XamariniOS Version Visual Studio Community Hash e bc Branch xcode Build date Xamarin Designer Version Hash eac a e Branch remotesorigind Build date UTC Build Information Release ID Git revision f b bbd cb bbfb cff d aa a f Build date Build branch release Xamarin extensions ade d df a d feda a e bacf Operating System Mac OS X Darwin Darwin Kernel Version Thu Oct PDT rootxnu RELEASEX x Hi When serializing a MessagePack class which has a property of type Object it does not retain the type when you deserialize the MessagePack class For example I set the Property Value to an Int number of say When I deserialize the class it comes out as a byte MessagePackObject public class Item public Item Key public object Value set get The workaround is adding something like I have below where you implement your own type Property Is there another better way to do this or is it working as intended MessagePackObject public class Item public Item public Itemobject value if value null if valueGetTypeIsSerializable thisValue value thisType valueGetTypeToString Key public object Value set get Key public string Type set get public object GetOriginalValue object val Value if val null val ConvertChangeTypeval SystemTypeGetTypeType return val Hi we want to use MessagePack in our production and ran into a problem Current stable version does not work with EnumMemberAttribute Its important for us Ive wrote some tests for example csharp public class Tests Fact public void Failed arrange act var firstDto new DtoWithFirstEnum Enum FirstEnumNotOk var serializerForFirst MessagePackSerializerGetDtoWithFirstEnum var bytes serializerForFirstPackSingleObjectfirstDto var serializerForSecond MessagePackSerializerGetDtoWithSecondEnum var secondDto serializerForSecondUnpackSingleObjectbytes assert AssertEqualSecondEnumSecondValue secondDtoEnum Fact public void Pass arrange act var firstDto new DtoWithFirstEnum Enum FirstEnumNotOk var json JsonConvertSerializeObjectfirstDto var secondDto JsonConvertDeserializeObjectDtoWithSecondEnumjson assert AssertEqualSecondEnumSecondValue secondDtoEnum DataContract public class DtoWithFirstEnum DataMemberName enum public FirstEnum Enum get set DataContract public class DtoWithSecondEnum DataMemberName enum public SecondEnum Enum get set public enum FirstEnum EnumMemberValue ok OK EnumMemberValue notok NotOk public enum SecondEnum EnumMemberValue ok FirstValue EnumMemberValue notok SecondValue Looks like we can refine the EnumMessagePackSerializer class in ctor and add new value ByEnumMember in EnumSerializationMethod csharp protected EnumMessagePackSerializer SerializationContext ownerContext EnumSerializationMethod serializationMethod base ownerContext SerializerCapabilitiesPackTo SerializerCapabilitiesUnpackFrom if typeof TEnum GetIsEnum throw new InvalidOperationException StringFormat CultureInfoCurrentCulture Type is not enum typeof TEnum thisserializationMethod serializationMethod thisunderlyingType EnumGetUnderlyingType typeof TEnum var members EnumGetValues typeof TEnum as TEnum thisserializationMapping new DictionaryTEnum string membersLength thisdeserializationMapping new Dictionarystring TEnum membersLength foreach var member in members var enumName serializationMethod EnumSerializationMethodByEnumMember GetNameFromEnumMemberAttr member memberToString var asString ownerContextEnumSerializationOptionsSafeNameTransformer enumName thisserializationMapping member asString thisdeserializationMapping asString member Can you suggest a quick way to solve the problem Thank you Currently Register is a generic method and I have a situation where I need to pass a Type to Register Ive implemented a custom MessagePackSerializer and when trying to deserialize my type from the byte stream which is expected to be a Map I get an exception At the point of the exception unpackerIsMapHeader returns true but trying to do unpackerReadMapLength throws MsgPackMessageTypeException Cannot convert map header from type FixedRaw xA in position Hi Im using MessagePack in Unity not using IL CPP and also in a standalone c application a master server that sends and receives objects from the Unityclient Somehow I get this error when trying to serialize an object of class ClientSetupRequest SystemTypeLoadException Could not load type MessagePackFormattersClientSetupRequestFormatter from assembly at MessagePackFormatterResolverExtensionsGetFormatterWithVerify T MessagePackIFormatterResolver resolver x b in f ef c d bd a a bad at MessagePackMessagePackSerializerSerialize T T obj MessagePackIFormatterResolver resolver x a in f ef c d bd a a bad at MessagePackMessagePackSerializerSerialize T T obj x in f ef c d bd a a bad at wrapper dynamicmethod SystemObjectlambdamethodSystemRuntimeCompilerServicesClosureobject at MessagePackMessagePackSerializerNonGenericSerialize SystemType type SystemObject obj x in f ef c d bd a a bad at The ClientSetupRequest class looks like this using MessagePack MessagePackObject public class ClientSetupRequest GameNetworkEvent Key public string PlayerName The GameNetworkEvent class is just an empty class Im not sure but I think something the exception doesnt occur for some reason Whats strange is that it says from assembly So the assembly is empty I dont know which version I was using before but I just redownloaded MessagePack version using nuget and copied the dll from the net folder to my Unity Project and also referencing it from my standalone c app In agreement with the previous comment when I serialise a simple class csharp public class Person public string Name get set The initial call to MessagePackSerializerGet takes several hundred milliseconds somewhere between ms to ms and the first call to MessagePackSerializerUnpack takes a further ms or so Subsequent calls to both MessagePackSerializerPack and MessagePackSerializerUnpack are fast The delay only seems to happen when the program first runs I assume this behaviour is bydesign but is there a way to work around or at least reduce the slow start behaviour Tested on MSgPackCli v targeting NET Framework Code to reproduce csharp using System using SystemDiagnostics using SystemIO using MsgPackSerialization namespace ConsoleApp public static class Program static void Main SwStart ConsoleWriteLineSwElapsedMillisecondsms create serializer var serializer MessagePackSerializerGetPerson ConsoleWriteLineSwElapsedMillisecondsms for var i i i var msgpack Serialiseserializer new Person Name Bob var person Deserialiseserializer msgpack ConsoleWriteLineSwElapsedMillisecondsms personName ConsoleReadLine static byte SerialiseMessagePackSerializer serializer Person person using var stream new MemoryStream serializerPackstream person return streamToArray static Person DeserialiseMessagePackSerializer serializer byte packedBytes using var stream new MemoryStreampackedBytes return Person serializerUnpackstream static readonly Stopwatch Sw new Stopwatch public class Person public string Name get set Example output ms application starts executes MessagePackSerializerGetPerson ms MessagePackSerializerGet returns after ms ms Bob First call to MessagePackSerializerPack has a slight delay ms Bob Subsequent calls to MessagePackSerializerPack complete quickly ms Bob ms Bob ms Bob Is there anything I can do to reduce this initial time calls to MessagePackSerializerGet take See also Thanks Currently there are some legacy techniques for build artifact versioning it caused release failure of We should fix build scripts to use more simple and modern matter for versioning The script should take advantage git tag if its format matches to semver All version related parameters should be managed in common msbuild project file which will be refered from Directorybuildprops AssemblyFileVersion should be handled in it The script should be run without MSBuildexe The script should be run on pwsh 