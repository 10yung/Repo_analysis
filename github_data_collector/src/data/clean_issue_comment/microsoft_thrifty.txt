We should add a Gradle plugin to allow compilation of Thrift as part of a regular build Wed need to Design an extension API for use in gradle files Register one or more source sets defaulting to srcmainthrift Possibly refactor schemacodegen to provide a configuretime link between thrift input and kt outputs maybe not part of the MVP Im writing a TypeProcessor that adds a method in generated code for a thrift union type Since the processor only gets the generated class as input parameter its rather hard to figure out if the generated Thrifty code reflects a union in thrift I came up with the following which seems rather fragile to me java boolean isUnion typetypeSpecsstream filtere Builderequalsename findFirst flatMapt tmethodSpecsstreamfilterm buildequalsmnamefindFirst mapm mcodetoStringcontainsInvalid union orElsefalse Would it be a good idea to add the userType as a second argument in the process method It would make code generation in general a lot easier since generated code can be based upon the thrift schema AST instead of the generated code I can draft a PR if this seems a good idea Changing the method will break the TypeProcessor api We would instead use the default value specified in thrift if the field has one or null for optionalunrequired fields Wed still have to throw for required fields without a default but Im OK with that the design of enums in thrift isnt forwardcompatible as is and required fields doubly so See for the conversation sparking this feature Hi there this is my first time contributing to this project but I hope I can add some value Introduction Here at The Guardian we have a tool called Ophan to which we send analytics data using Thrift Ive recently been working on a researchheavy project where Ive been trying to write a crossplatform client library for this tool Ophan using Kotlin Multiplatform I have been able to do this multiplatformophan and Thrifty with some important modifications was an important part of the solution Id like to investigate whether theres a way we can incorporate those modifications back into this repo so that Thrifty can be used in other Kotlin Multiplatform projects Requirements Briefly Kotlin Multiplatform projects consist of some common code which can be compiled for and run on any of the supported platforms as well as platformspecific portions of code which are only used on a single platform Common code is Kotlin but with only acces to the common parts of Kotlins standard library and none of the Java standard library for example there is no javautilLinkedList because it must be able to run in nonJVM environments This obviously limits not only the code you can write yourself but what your common code can depend upon If we consider Thrifty specifically there are two key requirements for making it usable in this situation The Thrifty compiler must output Kotlin code which does not import any classes which are not available in the common Kotlin standard library and The Thrifty runtime must abide by the same restrictions Proposed solutions Requirement This is actually really easy to solve with the existing compiler options java jar thriftycompilerjar lang kotlin omitgeneratedannotations listtypekotlincollectionsArrayList settypekotlincollectionsLinkedHashSet other optionsparams Ive used this successfully in multiplatformophan here My only question here is whether its worth adding a new lang kotlinmultiplatform option which sets some of those other values automatically Requirement This is trickier Essentially you have to take the existing thriftyruntime source and modify it to first of all be Kotlin and secondly use only valid common Kotlin dependencies I have done this here but I have only included the CompactProtocol and I have not created tests for this code However I hope this does provide a solid basis for a thriftyruntimektxmultiplatform module in this repo Next steps Really up to you as the project maintainers to decide the best way to proceed I hope this can be of some use to this project and I look forward to hearing from you Talked offline heres a dump of reflective extensions we currently employ because kotlin package comuberthriftyextensions import commicrosoftthriftyschemaField import commicrosoftthriftyschemaLocation import commicrosoftthriftyschemaRequiredness import commicrosoftthriftyschemaUserElement import commicrosoftthriftyschemaUserType import commicrosoftthriftyschemaparserConstValueElement import commicrosoftthriftyschemaparserFieldElement import javalangreflectModifier import javautilUUID Unsafe reflectionbased extensions to Thriftys APIs Necessary because theres no APIs available for adjusting FieldElement APIs Creates a new copy of this Field with required Fieldrequired ness reflectively set via its internal FieldElement field receiver the source Field to use A defensive copy will be made return the new Field instance fun FieldmakeRequired Field val newElement elementFieldgetthis as FieldElementcopyrequiredness RequirednessREQUIRED return toBuilderbuild apply elementFieldsetthis newElement Creates a new copy of this Field with optional Fieldrequired ness reflectively set via its internal FieldElement field receiver the source Field to use A defensive copy will be made return the new Field instance fun FieldmakeOptional Field val newElement elementFieldgetthis as FieldElementcopyrequiredness RequirednessOPTIONAL return toBuilderbuild apply elementFieldsetthis newElement Creates a new copy of this Field with the specified value default value reflectively set via its internal FieldElement field receiver the source Field to use A defensive copy will be made return the new Field instance fun FieldwithDefaultValuevalue ConstValueElement Field val newElement elementFieldgetthis as FieldElementcopyconstValue value return toBuilderbuild apply elementFieldsetthis newElement Creates a new copy of this Field with the specified newId reflectively set via its internal FieldElement field param newId the new id to set receiver the source Field to use A defensive copy will be made return the new Field instance fun FieldnewIdnewId Int Field val newElement elementFieldgetthis as FieldElementcopyfieldId newId return toBuilderbuild apply elementFieldsetthis newElement Ensures this list of Field s are valid such as ensuring theyve got unique field IDs param ensuredLocation the Location of the element holding this list to ensure fields match it receiver the source list to check A defensive new copy will be made return the new fields list with the new field appended to the end fun ListFieldasSafeFieldsensuredLocation Location ListField if distinctBy itid size size Theyre all distinct just return them with locations ensured return map ittoBuilder locationitlocationmatchToensuredLocation build val safeFields foldemptyListField cur next cursafeAddFieldnext ensuredLocation checksafeFieldssize size Data lost return safeFields Safely adds a new Field to this collection while ensuring that it does not conflict with the existing field ids param newField the new Field to add param ensuredLocation the Location of the element holding this list to ensure fields match it receiver the source list to add this to A defensive new copy will be made return the new fields list with the new field appended to the end fun ListFieldsafeAddFieldnewField Field ensuredLocation Location ListField val defensiveCopy newFieldtoBuilder locationnewFieldlocationmatchToensuredLocation build if none itid newFieldid return plusdefensiveCopy val finalField mapFieldidmaxlet maxId defensiveCopynewIdmaxId defensiveCopy return plusfinalField private fun LocationmatchTosource Location Location return if base sourcebase path sourcepath this else Locationgetsourcebase sourcepath Creates a new copy of this Field with the specified newUUID reflectively set via its internal FieldElement field param newUUID the new UUID to use Defaults to a randomly generated one receiver the source Field to use A defensive copy will be made return the new Field instance fun T UserElement TnewUuidnewUUID UUID UUIDrandomUUID T if this is UserType UserTypeclassjavagetDeclaredFieldmixin else javaClassgetDeclaredFieldmixin apply isAccessible true val modifiersField javalangreflectFieldclassjava getDeclaredFieldmodifiers modifiersFieldisAccessible true modifiersFieldsetIntthis modifiers and ModifierFINALinv getthis let mixin UserElementMixin mixinjavaClassgetDeclaredFielduuid apply isAccessible true val modifiersField javalangreflectFieldclassjava getDeclaredFieldmodifiers modifiersFieldisAccessible true modifiersFieldsetIntthis modifiers and ModifierFINALinv apply val olduuid uuid setmixin newUUID checkolduuid uuid New UUID setting failed return this Sets a new default value for a given Field param const the new ConstValueElement to set return this same Field instance fun FieldsetDefaultValueconst ConstValueElement Field val newElement elementFieldgetthis as FieldElementcopyconstValue const elementFieldsetthis newElement return this private val elementField FieldclassjavagetDeclaredFieldelement apply isAccessible true val modifiersField javalangreflectFieldclassjava getDeclaredFieldmodifiers modifiersFieldisAccessible true modifiersFieldsetIntthis modifiers and ModifierFINALinv Theyre apparently legal thrift Not sure if theres much to do here though since theyre not user elements Theyre apparently legal thrift Theyre apparently legal thrift Added binary literals to grammar and code Did it best to my knowledge however I probably got things wrong at places Thank you in advance for reviewing Will solve As I convert more and more Java code from Apache Thrift to Thrifty Ive started to run into a pattern where I start with an existing struct object that might be null and then extends that struct by setting some existing values The most direct way to do this is by conditionally calling the correct Builder constructor java public Struct updateStructStruct struct StructBuilder builder struct null new StructBuilder new StructBuilderstruct builderfooTrue return builderbuild It would be much more convenient if StructBuilder accepted a nullable argument and added a if struct null guard to the generated code so the above could just become java public Struct updateStructStruct struct return new StructBuilderstruct fooTrue build That would detract a bit from the purity of the existing Builder interface but this could be a case where caller convenience could take precedence