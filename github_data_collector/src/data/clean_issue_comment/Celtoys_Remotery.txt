 The bug occurs in the following scenario typically with many unique names being sampled dynamic namings The profiledthread calls StringTableInsertBufferWriteBufferGrow to insert a new name While at the same time the remoterythread handles messages and calls RemoteryReceiveMessagecase GSMP Then the later accesses a buffer the name string which is currently being grown in the profiled thread and not in a defined state Thus causing a memory access violation The proposed solution works practically all the time in all my scenarios Though not guaranteed to work always More changes or explicit synchronization would be needed therefore I am using Windows Microsoft Visual Studio Preview bits build Debug build I build remotery and the rest of my code statically with the following defines RMTUSEOPENGL RMTENABLED There are two scenarios SCENARIO This works fine Main thread initializes Remotery rmtCreateGlobalInstance rmt Various threads are started that do work using rmtScopedCPUSample One of those threads is a renderer thread which does rmtBindOpenGL after activating the context then uses rmtScopedOpenGLSample and finally when shutting down calls rmtUnbindOpenGL and the deactivates the OpenGL context When all threads are gone but the main thread the main thread calls rmtDestroyGlobalInstancermt SCENARIO In this scenario the crash happens Main thread initializes Remotery rmtCreateGlobalInstance rmt Various threads are started that do work using rmtScopedCPUSample One of those threads is a renderer thread which does rmtBindOpenGL after activating the context then uses rmtScopedOpenGLSample and finally when shutting down calls rmtUnbindOpenGL and the deactivates the OpenGL context A new set of threads is started with a new renderer but reusing the old OpenGL context As before in step one of the new threads is the renderer thread so it makes the OpenGL context current calls rmtBindOpenGL and starts rendering When shutting down as before in it calls rmtUnbindOpenGL and then deactivates the OpenGL context When all threads are gone but the main thread the main thread calls rmtDestroyGlobalInstancermt In this second scenario the crash happens in the second rmtUnbindOpenGL call in step which is the second time Im calling it The call relevant callstack is short FlattenSampleTreeSample sample unsigned int nbsamples Line C FlattenSampleTreeSample sample unsigned int nbsamples Line C FreeSampleTreeSample sample ObjectAllocator allocator Line C FreePendingSampleTreesRemotery rmt SampleType sampletype Buffer flushsamples Line C rmtUnbindOpenGL Line C This is in the following code static ObjectLink FlattenSampleTreeSample sample rmtU nbsamples Sample child ObjectLink curlink sampleLink assertsample NULL assertnbsamples NULL nbsamples sampleLinknext ObjectLinksamplefirstchild CRASH HERE Link all children together for child samplefirstchild child NULL child childnextsibling ObjectLink lastlink FlattenSampleTreechild nbsamples lastlinknext ObjectLinkchildnextsibling curlink lastlink Clear child info samplefirstchild NULL samplelastchild NULL samplenbchildren return curlink The exception thrown is on the line marked CRASH HERE Exception thrown read access violation sample was xFFFFFFFFFFFFFFD According to the debugger the Sample sample variable going in is xdddddddddddddddd indicating the memory was already freed It seems somehow rmtUnbindOpenGL doesnt expect to be called more than once All thats needed to make remotery compatible is to add include sysselecth inside the if definedRMTPLATFORMPOSIX block While trying to use Remotery ded f e on my Linux app I get a crash every time the browser connects on the app I managed to trace the issue to TCPSocketPollStatus which corrupts the stack It seems that the crash is provoked by the select call which is known to cause memory corruptions when the given fd is larger than see Ive put an asserttcpsocketsocket FDSETSIZE before the selectcall which fires right before the crash occurs Hey Ive added remotery to my project to use for profiling I ran into one issue that I can not solve in a nice way I think this is more of a VS issue but I thought Id mention it anyway remotery lib remoteryc fatal error C x Debug SomeSharedLibpch precompiled header file is from a previous version of the compiler or the precompiled header is C and you are using it from C or vice versa I think I have tried pretty much everything related to precompiled headers except for turning them off completely The only thing that worked was renaming remoteryc to remoterycpp This is obviously not ideal If anyone happens to have a good idea I am all ears Would be awesome if we could use Remotery to profile CC emscripten games Challenges Websocket server We cant start a websocket server from an emscripten game One workaround is to use a native websocket server as a proxy Another solution is have emscripten directly send the data to another browser tab postMessage Timer accuracy Browsers have recently reduced the accuracy of performancenow because of security and privacy reasons I have heard that soon highaccuracy will be reenabled and some browsers allow to manually enable it through settings Hi All I have a case when trace labels get corrupted Instead I see random numbers In some cases it may fix itself but mostly not Should be fairly straightforward requiring steps Server increments base port number on failure to bind Client continuously polls a range of ports for connection Create a time sync between all connections Im suprised nobodys suggested this yet