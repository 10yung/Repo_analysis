Malformed URLs through an exception in a manner thats inappropriate It happens so early in the request flow that the request isnt even seen by the application javalangIllegalArgumentException URLDecoder Incomplete trailing escape pattern at javanetURLDecoderdecodeURLDecoderjava na at smokeRequestclassdecodeRequestscala smoke jar at smokenettyNettyRequestdecodeNettyRequestscala smoke jar at smokeRequestanonfunparseParams applyRequestscala smoke jar at smokeRequestanonfunparseParams applyRequestscala smoke jar at scalacollectionTraversableLikeanonfunmap applyTraversableLikescala scalalibrary jarna at scalacollectionTraversableLikeanonfunmap applyTraversableLikescala scalalibrary jarna at scalacollectionIndexedSeqOptimizedclassforeachIndexedSeqOptimizedscala scalalibrary jarna at scalacollectionmutableArrayOpsofRefforeachArrayOpsscala scalalibrary jarna at scalacollectionTraversableLikeclassmapTraversableLikescala scalalibrary jarna at scalacollectionmutableArrayOpsofRefmapArrayOpsscala scalalibrary jarna at smokeRequestclassparseParamsRequestscala smoke jar at smokenettyNettyRequestparseParamsNettyRequestscala smoke jar at smokeRequestclassformParamsRequestscala smoke jar at smokenettyNettyRequestformParamslzycomputeNettyRequestscala smoke jar at smokenettyNettyRequestformParamsNettyRequestscala smoke jar at smokeRequestclassparamsRequestscala smoke jar at smokenettyNettyRequestparamslzycomputeNettyRequestscala smoke jar at smokenettyNettyRequestparamsNettyRequestscala smoke jar at commdialogodsmStreamsApiauthenticateStreamsApiscala ondemandstreammanager jarna at commdialogodsmStreamsApianonfunhandleRequest applyStreamsApiscala ondemandstreammanager jarna at commdialogodsmStreamsApianonfunhandleRequest applyStreamsApiscala ondemandstreammanager jarna at scalaconcurrentimplFuturePromiseCompletingRunnableliftedTree Futurescala scalalibrary jarna at scalaconcurrentimplFuturePromiseCompletingRunnablerunFuturescala scalalibrary jarna at akkadispatchTaskInvocationrunAbstractDispatcherscala akkaactor jarna at akkadispatchForkJoinExecutorConfiguratorAkkaForkJoinTaskexecAbstractDispatcherscala akkaactor jarna at scalaconcurrentforkjoinForkJoinTaskdoExecForkJoinTaskjava scalalibrary jarna at scalaconcurrentforkjoinForkJoinPoolWorkQueuerunTaskForkJoinPooljava scalalibrary jarna at scalaconcurrentforkjoinForkJoinPoolrunWorkerForkJoinPooljava scalalibrary jarna at scalaconcurrentforkjoinForkJoinWorkerThreadrunForkJoinWorkerThreadjava scalalibrary jarna Apart from the way used in examples I have tried several other ways to send big files using smoke server but there is no way to do it correctly This is probably because when sending the raw data the function only accepts an array and not a stream So far I havent found a way to close the server without closing the entire process If the server is created using the object of a class by extending to Smoke and not SmokeApp then shouldnt there be a method to shutdown the server if needed Static assets to be read from jar file Built on top of json change You can check just StatisAssets file and ignore the rest Parsing POST JSON parameters Used scala distribution json parser deprecated adds dependency on parser combinators In DelayedInit has been deprecated Smoke should avoid using it in the future More discussion here We should emphasize the importance of updating the session secret I was trying to parse request body to multipartformdata using orgapachecommonsfileupload For that I needed request content as Array Byte I first used getBytesUTF on body This worked fine with text files but for binary files this didnt seem to work On further examination I noticed that the hex for new file was shifted by some amount As a workaround I changed the type of body to Array Byte and made these changes in nettyNettyRequestscala scala val contentLength nettyRequestgetContentreadableBytes var byteArray new Array Byte contentLength nettyRequestgetContentreadBytesbyteArray val body byteArray This seemed to work fine with any type of file 