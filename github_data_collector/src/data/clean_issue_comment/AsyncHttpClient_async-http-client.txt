usage can see exampleCompletableFutures Hi slandelle I offer PR with a new factory for Nettys Channels Ive also added a specific prefix for that group Was not sure about configgetThreadPoolName timer decided to keep it as we have it now Hi I find the delay between RequestTimeout and the time corresponding future completes by a timeout exception is quite long Below is my test version xml dependency groupIdorgasynchttpclientgroupId artifactIdasynchttpclientartifactId version version dependency test code java RequestMappingapitimeouttest public BaseApiResponseLong timeoutTest long timeout try Threadsleeptimeout catch InterruptedException e eprintStackTrace BaseApiResponseLong objectBaseApiResponse new BaseApiResponse objectBaseApiResponsesetDatatimeout return objectBaseApiResponse RequestMappingapitimeout public BaseApiResponseString timeout DefaultAsyncHttpClientConfigBuilder builder new DefaultAsyncHttpClientConfigBuilder buildersetConnectTimeout AsyncHttpClient client asyncHttpClientbuilder int timeout String url BaseApiResponseString response new BaseApiResponse RequestBuilder requestBuilder new RequestBuilder Request request requestBuildersetUrlurlsetRequestTimeouttimeoutbuild long beforeFutureCreated SystemcurrentTimeMillis ListenableFutureResponse responseListenableFuture clientexecuteRequestrequest long futureCreated SystemcurrentTimeMillis responseListenableFutureaddListener long futureComplete SystemcurrentTimeMillis String msg Stringformatfuture creation s future complete s futureCreated beforeFutureCreated futureComplete beforeFutureCreated responsesetMessagemsg Runnablerun try responseListenableFutureget catch Exception e eprintStackTrace return response result I tried many times and the future complete time is always much longer than ms It doesnt matter if I use a precreated AsyncHttpClient or create a new one on each request json code messagefuture creation future complete datanull code messagefuture creation future complete datanull code messagefuture creation future complete datanull code messagefuture creation future complete datanull log javautilconcurrentTimeoutException Request timeout to localhost after ms What if I want to provide the community with the ability to support the unix domain socket protocol If yes how long will the code be incorporated Run up a socks proxy for example Tor browser proxy on port Run this code import orgasynchttpclientAsyncHttpClient import orgasynchttpclientResponse import orgasynchttpclientproxyProxyType import javautilconcurrentFuture import static orgasynchttpclientDsl public class TorDNSIssue public static void mainString args throws Exception AsyncHttpClient c asyncHttpClientconfigsetProxyServerproxyServerlocalhost setProxyTypeProxyTypeSOCKSV FutureResponse whenResponse cprepareGet Response response whenResponseget Systemoutprintlnresponse I get Exception in thread main javautilconcurrentExecutionException javanetUnknownHostException checkexpyuzz wqqyqhjnonion at javautilconcurrentCompletableFuturereportGetCompletableFuturejava at javautilconcurrentCompletableFuturegetCompletableFuturejava at orgasynchttpclientnettyNettyResponseFuturegetNettyResponseFuturejava at playpensttpTorDNSIssuemainTorDNSIssuejava Caused by javanetUnknownHostException checkexpyuzz wqqyqhjnonion at javanetInet AddressImpllookupAllHostAddrNative Method at javanetInetAddress lookupAllHostAddrInetAddressjava at javanetInetAddressgetAddressesFromNameServiceInetAddressjava at javanetInetAddressgetAllByName InetAddressjava at javanetInetAddressgetAllByNameInetAddressjava at javanetInetAddressgetAllByNameInetAddressjava at ionettyutilinternalSocketUtils runSocketUtilsjava at ionettyutilinternalSocketUtils runSocketUtilsjava at javasecurityAccessControllerdoPrivilegedNative Method at ionettyutilinternalSocketUtilsallAddressesByNameSocketUtilsjava If I point it at it works fine Do I have to do something else to make it not fail Thanks Hello dear open source contributors When can you support the Unix domain socket protocol I have simply verified the feasibility of this function through intrusive modification and the workload is within three hundred lines of code but limited by the companys internal open source process I can not provide you with the source code Discussed in but spinning off as its a separate issue Under load when using the NettyReactiveStreamsBody I can reliably reproduce the following error info javalangIllegalArgumentException Duplicate handler name requestbodystreamer info at ionettychannelDefaultChannelPipelinecheckDuplicateNameDefaultChannelPipelinejava info at ionettychannelDefaultChannelPipelinefilterNameDefaultChannelPipelinejava info at ionettychannelDefaultChannelPipelineaddLastDefaultChannelPipelinejava info at ionettychannelDefaultChannelPipelineaddLastDefaultChannelPipelinejava info at orgasynchttpclientnettyrequestbodyNettyReactiveStreamsBodywriteNettyReactiveStreamsBodyjava info at orgasynchttpclientnettyrequestNettyRequestSenderwriteRequestNettyRequestSenderjava info at orgasynchttpclientnettyrequestNettyRequestSendersendRequestWithOpenChannelNettyRequestSenderjava info at orgasynchttpclientnettyrequestNettyRequestSendersendRequestWithCertainForceConnectNettyRequestSenderjava info at orgasynchttpclientnettyrequestNettyRequestSendersendRequestNettyRequestSenderjava info at orgasynchttpclientDefaultAsyncHttpClientexecuteDefaultAsyncHttpClientjava info at orgasynchttpclientDefaultAsyncHttpClientexecuteRequestDefaultAsyncHttpClientjava I have a Scala reproduction with http s It can be seen with sbt run The problem is that that AHC offers the channel back to the pool manager as soon as the last response chunk is read which causes a race condition against the NettySubscribers completion If removeFromPipeline is not called before the channel is offered back to the pool and polled out to another reactive streams request we hit the exception A workaround is to remove the pipeline in a hook in AsyncHandler scala override def onConnectionOfferchannel Channel try channelpipelineremoverequestbodystreamer catch case nse NoSuchElementException this is just a cleanup of last resort This works but is bad for a couple reasons It runs regardless of the body type of the request The name of the pipeline is a private detail of the NettySubscriber Alternatively NettyReactiveStreamsBody could remove the existing one if the addLast call fails and then retry adding a subscriber This isnt the cleanest solution but at least keeps it to one class Im going with the onConnectionOffer hack for now but can work on a PR for this alternative solution unless theres a better hook that Im missing Task Description In our company weve had to fork the sonarstash project and make it support SPNEGO using our inhouse library which handles the SPNEGOKerberos authentication We forked the sonarstash project in order to make it support SPNEGOKerberos via our own inhouse library The sonarstash uses the asynchttpclient for handling its HTTP requests What happens is that both our inhouse SPNEGOKerberos library and the asynchttpclient library are trying to set the Authorization header From the looks of it our library kicks in and does its job but then the asynchttpclient also kicks in and wipes out the token and sets an incorrect one and then the authentication and authorization negotiation fails Proposal We would like to propose adding a simple boolean property in the SPNEGO part of the switch case in perConnectionAuthorizationHeader in AuthenticatorUtils This way it will be possible to disable SPNEGO by passing a property like orgasynchttpclientdisablespnegointerceptortrue This fixes things for us and wed be happy to submit a pull request for it Please advise Both Request timeout and Read timeout throw the same javautilconcurrentTimeoutException javautilconcurrentTimeoutException Request timeout to wwwbaiducom after ms its not convenient to catch the real exception i suggest to throw AhcRequestTimeoutException And AhcReadTimeoutException instead of logging the timeout message in RequestTimeoutTimerTaskjava or ReadTimeoutTimerTaskjava 