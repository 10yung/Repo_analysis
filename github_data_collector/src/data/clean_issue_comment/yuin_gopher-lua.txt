Fixes Changes proposed in this pull request LStates can now optionally limit how many LTables and how many LTable keys are set This provides basic memory quotas for LStates as LTable growth is the most common way for an LState to grow in memory use Defaults to not being tracked When enabled has almost negligible speed and memory impact Is it possible cat sunlua local http requirehttp glua sunlua sunlua module http not found no field packagepreload http CreateFile httplua The system cannot find the file specified CreateFile C opt lua httplua The system cannot find the path specified CreateFile C opt lua http initlua The system cannot find the path specified Iv made the lib gopherluadebugger But it need modify some code in gopherlua this pr is needed which make gopherlua support the hook feature some fix in the first pr include import error and SetHook fix hook fix a bug in gopherlua Iv tried to fix it in my fork getlocal buf fix I could make a pr if needed A debugger is very useful sometimes Hope to finish this work together x GopherLua is a Lua implementation You should be familiar with Lua programming language Have you read Lua reference manual carefully x GopherLua is a Lua implementation In Lua to keep it simple it is more important to remove functionalities rather than to add functionalities unlike other languages If you are going to introduce some new cool functionalities into the GopherLua code base and the functionalities can be implemented by existing APIs It should be implemented as a library Please answer the following before submitting your issue What version of GopherLua are you using cd c What version of Go are you using What operating system and processor architecture are you using linuxamd What did you do NA What did you expect to see NA What did you see instead NA I want to add part of the baselib functions to LState but there is no way to do that since every baselib function implementation is private What about add something like OpenBaseStrip which can pass a list of baselib function name and add them to LState x GopherLua is a Lua implementation You should be familiar with Lua programming language Have you read Lua reference manual carefully x GopherLua is a Lua implementation In Lua to keep it simple it is more important to remove functionalities rather than to add functionalities unlike other languages If you are going to introduce some new cool functionalities into the GopherLua code base and the functionalities can be implemented by existing APIs It should be implemented as a library Please answer the following before submitting your issue What version of GopherLua are you using What version of Go are you using What operating system and processor architecture are you using What did you do What did you expect to see What did you see instead the test code is lua local t aa bb for k v in pairst do printk v end local a local b local c ab local x while true do local name value debuggetlocal x if not name then break end printname value x x end and the output is aa bb t table xc c for generator for state for control k v function xc a the debuggetlocal x cannot get vars like b c x hope to fix this x GopherLua is a Lua implementation You should be familiar with Lua programming language Have you read Lua reference manual carefully x GopherLua is a Lua implementation In Lua to keep it simple it is more important to remove functionalities rather than to add functionalities unlike other languages If you are going to introduce some new cool functionalities into the GopherLua code base and the functionalities can be implemented by existing APIs It should be implemented as a library Please answer the following before submitting your issue What version of GopherLua are you using latest What version of Go are you using What operating system and processor architecture are you using osx What did you do write a value to a LTable with very large int index What did you expect to see the kv should be stored in LTabledic What did you see instead the kv stored in LTablearray and fill many many LNil before the index hi iv seen but i think it could be optimized just like the clua which ensure at least more than usage of the array so iv tried to implement this feature by learned from clua i could make a pr to show what iv done with this if you agree with me X GopherLua is a Lua implementation You should be familiar with Lua programming language Have you read Lua reference manual carefully X GopherLua is a Lua implementation In Lua to keep it simple it is more important to remove functionalities rather than to add functionalities unlike other languages If you are going to introduce some new cool functionalities into the GopherLua code base and the functionalities can be implemented by existing APIs It should be implemented as a library Please answer the following before submitting your issue What version of GopherLua are you using cd cd What version of Go are you using What operating system and processor architecture are you using darwinamd What did you do NA What did you expect to see NA What did you see instead NA I am interested in limiting the amount of memory used by individual LStates so that lua scripts with leaks in them cannot completely consume all process memory It would be great to discuss some ideas here At the end of this process I can potentially propose a patch My thoughts so far It is unlikely that we can get an exact measure of memory used by LStates the goal really is to total up the sizes of all LTables which are currently retained and their contents LTable reference cycles should be handled and LTables which are global and local should be considered Passive tracking Somehow keep a running approximation of the size of allocated memory This would involve hooking code into table operations like RawSet etc table creation NewLTable and possibly other points Difficulties arise with tracking frees as the GC nature of go means that we currently have no single point to hook when an LTable is freed Gos finalizers are not helpful for data structures which can contain cycles I think this could only be made to work if we stopped relying on GC to collect tables and instead modified the VM to do explicit ref counting on table references which would be too intrusive a change I think On demand calculation Another approach could be to calculate the size of an LState on demand eg an ApproxMemSize method for LState This method would iterate all values in the registry and the global table and sum their sizes taking care to avoid double counting This could be a relatively expensive operation but it would have no runtime overhead to normal operation of the VM It may be possible to do some caching between calls to ApproxMemSize to try and skip sizing on tables which have not changed since the last call Im interested in hearing any comments on these ideas or any alternative approaches thanks X GopherLua is a Lua implementation You should be familiar with Lua programming language Have you read Lua reference manual carefully X GopherLua is a Lua implementation In Lua to keep it simple it is more important to remove functionalities rather than to add functionalities unlike other languages If you are going to introduce some new cool functionalities into the GopherLua code base and the functionalities can be implemented by existing APIs It should be implemented as a library Please answer the following before submitting your issue What version of GopherLua are you using cd cd What version of Go are you using What operating system and processor architecture are you using darwinamd What did you do NA What did you expect to see NA What did you see instead NA Im always interested in reducing the runtime memory of gopher lua as my use case has thousands of LStates and tens of thousands of LTables per process I noticed recently that quite a good memory saving was possible by removing the k i and keys fields of the LTable for tables which were never iterated which is the vast majority in my case I think it could be interesting to only initialize and start updating keys and k i on the first call to next so that LTables which are never iterated do not incur this memory overhead It would also marginally speed up table update operations for tables which have never had next called on them although there would be a slight spike on first call to next yuin what do you think Im happy to propose a patch for this I have a question about Pop purposes in the READMErst there is only one reference to it in this section But I didnt noticed any call to Pop when retrieving arguments in the documentation or related modules In my software I use Pop this way everytime I retrieve arguments of my functions go argA LToString argB LToInt LPop or top LGetTop forloop LPoptop Is it good bad required not required Why I think it can lighten Gos garbage collectors work by reducing heap scan about not reachable variables Hello What would you think about integrating with a fuzzing service It could catch bugs Fuzzit gives free service for open source This patch fuzzes DoString I ran for a few hours locally No crashes so far Build will fail due to missing an API key If youre interested the setup is like this In Fuzzit create target gopherlua In Fuzzit settings grab an API key In repo settings in Travis paste it to envvar FUZZITAPIKEY