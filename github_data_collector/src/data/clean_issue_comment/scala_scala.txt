 Hi folks I thought I would bring up yet an other immutableSeqMap impelementation for discussion which beats the current best implementation VectorMap in terms of memory usage less memory usage than VectorMap build time from faster for small to faster for large maps iteration x as fast as VectorMap is equal to VectorMap in lookups and performs worse than VectorMap in updates VectorMap is faster removals VectorMap is faster I wont describe here the exact explanation of the data structure since there is a quite detailed explanation of the structure as well as the algorithms for the above operations included in the Scaladoc for the immutableLinkedHashMap class itself Benchmarks I have included benchmark results for the above operations in this gist which includes as well memory consumption for building Arity arity is what Im calling the maximum length of chains of forwardreferencing Links in the Map please see the scaladoc for a complete explanation It can be finely tuned by changing the LinkedHashMaparity method but after playing around with it a bit it seems that arity strikes the best balance between iteration and writes Theres something like a speedup in going from arity to arity with very little cost to writes but going from arity to arity theres a significant slowdown to writes with diminishing benefits to iteration The general updated method is fully general over any arity but it pays for that generality in speed For this reason Ive written handoptimized versions of the method for when arity and arity these are the updatedArity and updatedArity methods respectively Once an arity is decided on we can just replace updated with the appropriate implementation Thoughts Ive opened this draft PR just to get some feedback on if this data structure seems valuable If folks here think that the gains in builditerationmemory are worth the cost to updatesremovals and maybe for consideration as possibly the default SeqMap in much later versions of Scala When was released I think there were a few unknowns or work left to do but time kinda ran out before they could be fully thought through which SeqMap to set as default VectorMap or TreeSeqMap which SeqMap to include at all VectorMap or VectorMapTreeSeqMap if we should deprecate ListMap IMO yes Can VectorMap be further optimized Maybe an implementation with RelaxedRadixBalancedVector would be make VectorMap strictly dominate TreeSeqMap and so TreeSeqMap would be rendered obsolete Now with Stefans improvements to Vector this is also worth revisiting IMO Are there other potential contenders for best general SeqMap we havent considered yet Enter LinkedHashMap So this proposal draft is just a continuation of that whole discussion odd Ichoran In particular this fixes which is a blocker for getting Spark on Scala None This implementation results in a x x speedup of the method Fixes scalabug Quick POC x only of course The keys in the resulting map are the same so the internal structure will also be the same and that can be used to avoid allocating tuples and going through MapBuilder and other such convolutions Benchmark results x info Benchmark size Mode Cnt Score Error Units info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms This PR info Benchmark size Mode Cnt Score Error Units info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransformConserve gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve gctime avgt ms Alternative with more aggressive conservation REG with conserve info Benchmark size Mode Cnt Score Error Units info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransform avgt nsop info HashMapBenchmarktransform gcallocrate avgt MBsec info HashMapBenchmarktransform gcallocratenorm avgt Bop info HashMapBenchmarktransform gcchurnPSEdenSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSEdenSpacenorm avgt Bop info HashMapBenchmarktransform gcchurnPSSurvivorSpace avgt MBsec info HashMapBenchmarktransform gcchurnPSSurvivorSpacenorm avgt Bop info HashMapBenchmarktransform gccount avgt counts info HashMapBenchmarktransform gctime avgt ms info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts info HashMapBenchmarktransformConserve avgt nsop info HashMapBenchmarktransformConserve gcallocrate avgt MBsec info HashMapBenchmarktransformConserve gcallocratenorm avgt Bop info HashMapBenchmarktransformConserve gccount avgt counts mkeskells Currently BitSet is using implementations of minAftermaxBefore inherited from SortedSet These implementations are very inefficient for BitSet allocate a clone of BitSet and erase bits outside of the range rangeFromrangeUntil allocate and traverse first Iterator for isEmpty check allocate and traverse another Iterator for head last This PR implements dedicated overrides of minAftermaxBefore for BitSet No object allocations are performed and a minimal traversal of BitSet words is done Current implementation info Benchmark spacing Mode Cnt Score Error Units info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop This PR info Benchmark spacing Mode Cnt Score Error Units info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkmaxBefore avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop info BitSetBoundedMinMaxBenchmarkminAfter avgt nsop Benchmark code scala package scalacollectionmutable import javautilconcurrentTimeUnit import orgopenjdkjmhannotations import scalacollectionmutable BenchmarkModeArrayModeAverageTime Fork Threads Warmupiterations Measurementiterations OutputTimeUnitTimeUnitNANOSECONDS StateScopeBenchmark class BitSetBoundedMinMaxBenchmark ParamArray var spacing Int var bs mutableBitSet var middle Int SetupLevelIteration def initializeRange Unit bs mutableBitSet until by spacing middle bsmax Benchmark def minAfter bsminAftermiddle Benchmark def maxBefore bsmaxBeforemiddle 