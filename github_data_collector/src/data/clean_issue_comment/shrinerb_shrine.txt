Hi janko Before writing the issue details I wanna say thank you for this amazing gem Helps out a bunch every day And now Brief Description I believe that uppy isnt compatible with Shrine with versions and newer Expected behavior Direct upload to S with uppy Shrine Actual behavior Uppy sends a OPTIONS preflight request to s params and the response is Method Not Allowed Simplest selfcontained example code to demonstrate issue const fileInput thisfileTarget file input from HTML fileInputstyledisplay none const uppy Uppy autoProceed false restrictions maxFileSize maxNumberOfFiles allowedFileTypes video uppyuseDashboard inline true target dragdroparea showProgressDetails true browserBackButtonClose true uppyuseAwsS companionUrl uppyonuploadsuccess functionfile response var uploadedFileData JSONstringify id filemeta key match cache storage cache metadata size filesize filename filename mimetype filetype var hiddenInput fileInputparentNodequerySelectoruploadhidden hiddenInputvalue uploadedFileData The exact same code passes when using uppy System configuration Ruby version Shrine version Ability to do some kind of lslike behavior in storageagnostic way on a storage Use cases Iterate through entire storage contents to find orphans files not currently being pointed to by a model perhaps left around by a bug or backup recovery In storageagnostic way Maybe you want to do this on just a portion of a very large storage using a prefix instead of on the whole storage at once Provide a UI to let user navigatelist contents of a storage in storage agnostic way for various purposes such as selecting a file API suggestion Storagelist yieldsreturns string paths We can have that Storagelist method which would yield file paths May also take a prefix to list at just a certain directory somestoragelist do path path somepathfilejpg end somestoragelistprefix somepath path Directories would not be yielded because they dont really exist as things on some storage systems only individual files Should there be a way to get an array returned instead of using a block arg Or actually if we use the Enumerable stuff if no block is given to support chaining we can get that and more I think So that should be encouragedrequired in API Shrinelist yieldsreturns UploadedFile objects Then we could have a ShrinelistShrinelist method which would wrap this into an enumerable of ShrineUploadedFile objects An UploadedFile object is our general abstraction for storagelocated files already letting us do various things with it like get a url or delete Shrineliststore uploadedfile Shrineliststore prefix somepath uploadedfile anuploaderlist uploadedfile anuploaderlistprefix somepath uploadedfile Similar to above should probably return Enumerator if no block given to support chaining and other useful things Implementation sketch ruby class ShrineStorageS def list bucketobjectsprefix prefixeach do object yield objectkey prefix end end end ruby class ShrineStorageFileSystem we already have this as listfiles def list Pathnamedirectory add trailing slash to make it work with symlinks find each path pathrelativepathfromdirectorytos if pathfile end end ruby module Shrine module Plugins module List module ClassMethods def liststoragekey block newstoragekeylist block end end module InstanceMethods def list return enumformethod unless blockgiven storagelist do id yield selfclassUploadedFilenewid id storagekey storagekey end end end end registerpluginlist List end end This is Optional Storage API All storages are not required to implement list as shrine itself does not actually use it for basic functionality But it should be encouraged to allow storageagnostic listing The Linter should test if if the relevant method is present but allow it not to be present When testing Linter makes sure prefix arg works and makes sure if no block is given you get an EnumeratorEnumerable returned that behaves appropriately Possible future Linter maximal mode where it requires this and various other nonmandatory but recommended features so you can see if a given storage lints under maximal mode with all recommended features Brief Description How can we use Shrine for S KMS encrypted uploads This had a workaround until recently so I didnt bother reporting but with the latest changes starting v baf bc ed f b cdd a b e c its no longer an option so Im reaching out for help Thanks in advance Expected behavior We are using the KMS encryption support to uploaddownload files from S I managed to make it work by overwriting the S client to let the storage use the AwsS EncryptionClient instead It would look like this ruby require shrinestorages class S Storage ShrineStorageS attrwriter client def objectid AwsS Objectnew The S encryption client is a thin wrapper to generic s client client clienttryclient client bucketname bucketname key prefix id join end end Shrinestorages encrypted S Storagenewprefix encrypted bucket ENV MYENCBUC Shrinestorages encrypted client AwsS EncryptionClientnew kmsclient AwsKMSClientnewregion useast kmskeyid ENV KMSID This little patch allowed us to have a pretty clean KMS support for Shrine Actual behavior With the latest changeset were getting errors while trying to download the file due to I believe the different APIs for AWS S clients Simplest selfcontained example code to demonstrate issue ruby uploadassetread NoMethodError undefined method headobject for AwsS EncryptionClient x b c a from usrlocalbundlegemsshrine libshrinestorages rb in loaddata from usrlocalbundlegemsshrine libshrinestorages rb in open from usrlocalbundlegemsshrine libshrineuploadedfilerb in open from usrlocalbundlegemsshrine libshrineuploadedfilerb in io from usrlocalbundlegemsshrine libshrineuploadedfilerb in read from irb System configuration Ruby version Shrine version Romrb uses drystruct as in its entity objects We cannot create instances of these struct classes just by calling new method We have to supply the values of all the attributes in the new method calls In the backgrounding plugin new method is called on the recordclass drystruct class in case of romrb without passing any attribute so it fails with the following error shell undefined method default Hence file deletion fails Its unfeasible to set default values for all attributes in rom entity structs As an alternative to recordclassnew we can call OpenStructnew which works for all cases including romrb