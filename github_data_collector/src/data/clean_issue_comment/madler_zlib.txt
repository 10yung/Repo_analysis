Building with configure zprefix is a nice feature because it prefixes all exported symbols with z This allows linking a zlib built in such a way with a program which already uses e default zlib which is nice for experimenting with new versions Unfortunately theres one symbol namely zerrmsg which is not prefixed in this case z is already in the original name leading to duplicate symbols in the scenario described above The fix is trivial just prefix zerrmsg with another z as well in zconfhhinzconfhcmakein Building with configure zprefix is a nice feature because it prefixes all exported symbols with z This allows linking a zlib built in such a way with a program which already uses e default zlib which is nice for experimenting with new versions Unfortunately theres one symbol namely zerrmsg which is not prefixed in this case z is already in the original name leading to duplicate symbols in the scenario described above The fix is trivial just prefix zerrmsg with another z as well in zconfhhinzconfhcmakein Compile Zlib on windows After the command cmake GVisual Studio Win is typed in errors occur as folllows Selecting Windows SDK version to target Windows CMake Error at CMakeListstxt project Failed to run MSBuild command MSBuildexe to get the value of VCTargetsPath NET Framework Microsoft R e fe C Microsoft Corporation C Users Administrator source repos zlib zlib build CMakeFiles MSVC VCTargetsPathvcxproj C Program Files x Microsoft Visual Studio Community MSBuild Microsoft VC v MicrosoftCppBuildtargets error MSB The build tools for Visual Studio Platform Toolset v cannot be found To build using the v build tools please install Visual Studio build tools Alternatively you may upgrade to the current Visual Studio tools by selecting the Project menu or rightclick the solution and then selecting Retarget solution C Users Administrator source repos zlib zlib build CMakeFiles MSVC VCTargetsPathvcxproj C Users Administrator source repos zlib zlib build CMakeFiles MSVC VCTargetsPathvcxproj C Users Administrator source repos zlib zlib build CMakeFiles MSVC VCTargetsPathvcxproj PrepareForBuild C Program Files x Microsoft Visual Studio Community MSBuild Microsoft VC v MicrosoftCppBuildtargets error MSB The build tools for Visual Studio Platform Toolset v cannot be found To build using the v build tools please install Visual Studio build tools Alternatively you may upgrade to the current Visual Studio tools by selecting the Project menu or rightclick the solution and then selecting Retarget solution C Users Administrator source repos zlib zlib build CMakeFiles MSVC VCTargetsPathvcxproj Exit code Configuring incomplete errors occurred See also CUsersAdministratorsourcereposzlibzlib buildCMakeFilesCMakeOutputlog C Users Administrator source repos zlib zlib buildcmake GVisual Studio Win CMake Error Error generator Visual Studio Win Does not match the generator used previously Visual Studio Win Either remove the CMakeCachetxt file and CMakeFiles directory or choose a different binary directory On unrelated work this piece of code in zconfh tripped really unfun to trace compiler errors ifndef STDC ifndef const cannot use definedSTDC definedconst on Mac define const note need a more gentle solution here endif endif That code apparently dates back to Zlib June and i would hope is not needed anywhere for anything these days Regardless of why STDC might end up being undefined at some point during porting defining language keywords to nothing should probably not be necessary An error Please have the talk with your compiler would maybe suffice Hello again This optimization uses VSX vector SIMD instructions to try to match multiple bytes at the same time during the search for the longest match A vector load comparison bytes has just a small overhead if compared to their regular versions so the optimized longestmatch tries to match as many bytes as possible on every comparison This PR shares commit with and which can be removed if either one gets merged first It also uses GNU indirect functions to choose which function version optimized or default to run on the first call to longestmatch during runtime To test the performance improvement we used Chromiums zlibbenchcc with input files from jsnellzlibbench The results below show compression throughput in MBs using RAW deflate for all compression levels pngpixels comp lvl default optimized gain jpeg comp lvl default optimized gain executable comp lvl default optimized gain html comp lvl default optimized gain Hi This PR introduces a optimization for Adler checksum for POWER processors that uses VSX vector instructions If adler do byte at time on the first iteration s is s n means iteration n is the initial value of adler at beginning is unless adler initial value is different than So s s c after the first calculation For the next iteration s s c and so on Hence for iteration N s N s N c N is the value of s on after iteration N Therefore for s s N s Ns N Nc N c c N In a more general way s N s sumi to Nc i s N s Ns sum i to NNi c i Where s N s N are the values for s s after N iterations So if we can process Nbyte at time we can obtain adler checksum for Nbyte at once Since VSX can support byte vector instructions we can process byte at time using N we have s s s sumi to c i s s s s sumi to i c i The VSX version starts to improve the performance for buffers with size The performance is up to x better than Adler version from adler nonvectorized version average cpu time in ns on iterations buffer size adler baseline adler power speedup For buffer with length than the performance is almost the same of the nonvectorized implementation with a small performance degradation in some cases buffer size adler baseline adler power NULL Hi During performance tests we noticed that slidehash consumes considerable CPU during compression on Power processors This PR introduces an optimized version using VSX vector instructions to make it faster The main difference is that it slides elements at a time instead of just one as the standard code does The implementation uses GNU indirect function ifunc feature to choose the correct function version to be used on the first call during runtime Later calls will all go directly to the selected function This way the same binary can be used for all Power processor versions The ifunc helper code however is not limited to Power and can be reused by other archs if wanted so it was placed under contribgcc I tried to make as few changes as possible to toplevel files deflatec and instead place most Powerspecific code under contribpower To measure the performance improvement we used Chromiums zlibbenchcc with input files from jsnellzlibbench The results below show compression throughput in MBs using RAW deflate for all compression levels jpeg comp lvl default optimized gain pngpixels comp lvl default optimized gain executable comp lvl default optimized gain html comp lvl default optimized gain note resolving might avoid the issue in many cases in practice as well but might not fully resolve it in case of different build configs When loading libzso with dlopen and RTLDLOCAL it can happen that you end up with mysterious crashes The reason is that your library is run inside a program that ALSO uses zlib but a different version and does not hide the symbols loads it RTLDGLOBAL depends on it The end result is that deflateInit when calling deflateReset ends up calling deflateReset from that INCOMPATIBLE version of zlib The normal solution to that is to link with WlBsymbolic Alternatively eg if one wanted to avoid depending on nongeneric compiler options it would be possible to forbid calling any exported functions from zlib code itself This will be more difficult to do though I do not know if there are any other pieces of code with this same issue eg treesc warning C biflush uses oldstyle declarator inffas c warning C nonstandard extension used function given file scope treesc warning C conversion from int to ush possible loss of dat a gzwritec warning C conversion from sizet to unsigned int Hello I created this pull request to gauge your attitude towards continuous fuzzing and upstream support for it Presently all fuzzer harnesses are in the ossfuzz repo or inside the chromium codebase CC infernochromium Dor s via Thank you Bhargava