I dont know if this is the correct place to ask this but Im clueless on how to achieve this Ive got the following code go package app type FooService interface Fooid uint Foo UpdateFooid uint Foo error BusinessOperationfooID uint barID uint error this will have to call BarServiceUpdateBar somewhere in the implementation type BarService interface Barid uint Bar UpdateBarid uint Bar error As you can see I basically have structs that contain db business logic and one of them has to use the other one The problem occurs in the actual implementation as the structs would have to share the same database not an issue for regular use but for transactions it becomes an issue go package mysql type fooService struct db sqlbuilderDatabase bs appBarService important type barService struct db sqlbuilderDatabase func fs fooService BusinessOperationfooID uint barID uint error tx err fsdbNewTxnil foo fsFoofooId cant use this as it uses the db field not a part of the transaction foo Foo txCollectionfooFindid idOnefoo instead i have to copy paste code in order the use the transaction fsbsBarbarID cant use this as it uses the db field not a part of the transaction bar Bar txCollectionbarFindid idOnebar instead i have to copy paste code in order the use the transaction The BusinessOperation method interally creates a Transaction to be used across all the database operations but Ive yet to find a way to actually share that transaction Suggested solutions Ive seen were to create an interface that wraps both sqlDB and sqlTx like that go type executor interface Execquery string args interface sqlResult error Preparequery string sqlStmt error Queryquery string args interface sqlRows error QueryRowquery string args interface sqlRow and have different structs implement it so then you can pass it around as an argument to the aforementioned methods go func fs fooService BusinessOperationdb executor fooID uint barID uint error fsbsBardb barID this would work The problem with this approach is that those methods on the interface wouldnt work for upper as the methods are quite a bunch more to implement What I came up with was to try and compose sqlbuilderDatabase or sqlbuilderTx and add noop methods for my db or tx implemenation go type DB interface sqlbuliderDatabase Commit error Rollback error type db struct sqlbuilderDatabase noop func d db Commit error return nil func d db Rollback error return nil type tx struct sqlbuilderTx and the issue occurs right here Tx has to implement all methods of sqlbuilderDatabase some of which I have no idea how to go NewTxctx contextContext Tx error Txctx contextContext fn funcsess Tx error error Context contextContext WithContextcontextContext Database SetTxOptionssqlTxOptions TxOptions sqlTxOptions I have no idea how should those be implemented I tried doing the opposite and simply wrap sqlbuliderTx but the same issue occurs except for the db struct go Context contextContext WithContextcontextContext Tx SetTxOptionssqlTxOptions TxOptions sqlTxOptions Id be very glad if I could get some help regarding this issue I am trying to do a join query and have it map correctly to my struct go type ExerciseCms struct Uuid string dbuuid jsonuuid Timestamp int dbtimestamp jsontimestamp Object string dbobject jsonobject Audio Asset db jsonaudio Image Asset db jsonimage Video Asset db jsonvideo Assets Asset db jsonassetsomitempty res dbSelectexercises assetsFromexercisesLeftJoinassetsOnexercisesuuid assetsexerciseuuid err resAll exercises Log is done in a loop logPrintlnDEBUG eAssets Produces go DEBUG I want to suggest moving the License to a separate LISENCE file in the repo This allows it to be more easily autodiscovered eg by the relatively new godev site Currently the side is not showing dbv docs due to not being able to detect the license Ive the following code This is very slow taking seconds to return My hypothesizes that column workflow is very large up to MB and that the cost of transmitting that from the database is just very costly Assuming my hypothesis is correct is there a way to make sure that upperdb does not transfer data it does not need please The dbCollection interface does not include a Database function even though it is implemented by most every adapters collection implementation If interacting with a collection through the standard dbCollection interface type there does not seem to be a way to reference the underlying database Perhaps I am mistaken sqladapterCollection would be ideal for use but its internal and offlimits Specifically Id like to see this method added as part of this interface Is the mongo driver you guys are using maintained It seems not Also what is the recommended way to do a join Should I use the driver itself Right now I am making multiple queries instead of aggregating the results I understand the SQLBuilder isnt supported but there must be some workaround SelectdbRawoid ocprojectdailyreportsendtime Fromo as o Joino as ocOnocorgid oidWheredbCond ocisdelete constsAppIsNoDelete ocstatus constsAppStatusEnable oisdelete constsAppIsNoDelete ostatus constsAppStatusEnable PaginateuintsizePageuintpage count err paginatorTotalEntries paginatorAllpo cant mapping result into po but count has value Given two structs User and Profile linked with a foreign key go type User struct ID uuidUUID Name string CreatedAt timeTime UpdatedAt timeTime type Profile struct ID uuidUUID UserID uuidUUID CreatedAt timeTime UpdatedAt timeTime It would be good to be able to query as follows go type UserWithProfile struct User User dbinline Profile Profile dbinline res UserWithProfile err db SelectFromusers Joinprofiles AS pOnusersid puserid Allres Right now this is impossible due to conflicting field names with multiple inline structs The users ID CreatedAt and UpdatedAt columns are all unset while only the joined Profiles fields are set This could be solvable via When iterating through column names record the number of times that youve seen each column name If weve seen a column name time iterate through the embedded structs in order and set the Nth structs field with the given value This assumes that the struct fields ordering is the same as the order in the database query We could also dynamically rename fields on the fly so that we can match regardless of order though this is much more work Hi Im using de PostgreSQL and Im trying to find a way to make my inserts idempotent using ON CONFLICT DO NOTHING see Any tips on how to do this without writing all the insert SQL code by hand Thanks I looked at the documentation but I dont know if it supports nested transactions