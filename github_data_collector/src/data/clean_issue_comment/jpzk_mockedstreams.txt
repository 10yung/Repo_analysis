If you pass in the classOf the log and continue exception handler the mocked streams fails because it cant cast this to a string KafkaStreams takes care of this internally pputDEFAULTDESERIALIZATIONEXCEPTIONHANDLERCLASSCONFIG classOf LogAndContinueExceptionHandler KafkaStreams Properties is a HashtableObject Object This is with version Kafka itself now supports Can this be cross compiled with Because we arent considering that the topology could fail were not cleaning up if there is a failure in running the topology Consider closing even if there was an exception to clean up the directory When Kafka builds a local table it often takes some time to stream all of the records in This means that doing a join against this table may fail due to the matching record not yet appearing I am trying to write a test to detect this issue with topology and inputs as below val mstreams MockedStreams topologyb some join logic inputStreamforTable someserde someserde irrelevantInputForTable A seq with elements inputStreamForTable someserde someserde relevantInputForTable A seq with one element that matches the third input call inputStreamToJoin someserde someserde singleRecordShouldMatch The intention is that the irrelevant input in the first call to input should overwhelm the app causing a delay in adding the relevant input in the second call to input to the table The join should then fail But it appears that the input calls are processed sequentially which means that this isnt working Does anyone have any ideas on how to write this test I have two streams for inner join Stream Seqkey key key Stream Seqkey key key Expected Stream after innerjoin with addition as result between Stream and Stream Seqkey key key but I get the actual output as Seqkey key Hello there I write an kStream consumer connector So I dont need the builders output here Just run it like KafkaStreamsstart does Can it be added Something simple just like def start withProcessedDriver Hi thanks for the great library One problem I encountered was when I tried to test a TumblingWindow aggregation Lets say I create a second tumbling window like so val w TimeWindows ofTimeUnitSECONDStoMillis advanceByTimeUnitSECONDStoMillis untilTimeUnitSECONDStoMillis Now I use the CustomTimestampExtractor and send in events with value numbertimestamp eg a a a a a I run a simple count aggregation and would expect count to be because the last event arrives when the time window is already closed because of until However the last event is accounted for Could this be an interpretation that the until duration is understood as a lower bound Thanks MockedStreamsoutput doesnt allow you to specify zero for the size of the expected output That means you cant set an expectation that certain inputs should not have any outputs in your topology Instead of raising an exception when given a size of zero output should verify that driverreadOutput returns null and return an empty set