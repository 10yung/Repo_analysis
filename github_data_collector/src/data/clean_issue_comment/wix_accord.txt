Error exception during macro expansion javalangClassCastException scalareflectinternalTreesBlock cannot be cast to scalareflectapiTreesCaseDefApi at scalareflectapiTreesTransformeranonfuntransformCaseDefs applyTreesscala at scalareflectapiTreesTransformeranonfuntransformCaseDefs applyTreesscala at scalacollectionimmutableListloop Listscala at scalacollectionimmutableListmapConserveListscala at scalareflectapiTreesTransformertransformCaseDefsTreesscala at scalareflectinternalTreesclassitransformTreesscala at scalareflectinternalSymbolTableitransformSymbolTablescala at scalareflectinternalSymbolTableitransformSymbolTablescala at scalareflectapiTreesTransformertransformTreesscala at comwixaccordtransformPatternHelperanon transformPatternHelperscala at comwixaccordtransformPatternHelperclasstransformByPatternPatternHelperscala at comwixaccordtransformValidationTransformtransformByPatternValidationTransformscala at comwixaccordtransformValidationTransformanonfunprocessBooleanExpressions applyOrElseValidationTransformscala at comwixaccordtransformValidationTransformanonfunprocessBooleanExpressions applyOrElseValidationTransformscala at scalaruntimeAbstractPartialFunctionapplyAbstractPartialFunctionscala at comwixaccordtransformValidationTransformanonfunrewriteValidationRules applyOrElseValidationTransformscala at comwixaccordtransformValidationTransformanonfunrewriteValidationRules applyOrElseValidationTransformscala at scalaPartialFunctionOrElseapplyPartialFunctionscala at comwixaccordtransformValidationTransformanonfun anonfun applyValidationTransformscala at comwixaccordtransformValidationTransformanonfun anonfun applyValidationTransformscala at scalacollectionTraversableLikeanonfunmap applyTraversableLikescala at scalacollectionTraversableLikeanonfunmap applyTraversableLikescala at scalacollectionimmutableListforeachListscala at scalacollectionTraversableLikeclassmapTraversableLikescala at scalacollectionimmutableListmapListscala at comwixaccordtransformValidationTransformanonfun applyOrElseValidationTransformscala at comwixaccordtransformValidationTransformanonfun applyOrElseValidationTransformscala at scalaPartialFunctionOrElseapplyPartialFunctionscala at comwixaccordtransformPatternHelperanon traversePatternHelperscala at scalareflectapiTreesTraversertraverseTreesTreesscala at scalareflectinternalTreesclasstraverseComponents Treesscala at scalareflectinternalTreesclassitraverseTreesscala at scalareflectinternalSymbolTableitraverseSymbolTablescala at scalareflectinternalSymbolTableitraverseSymbolTablescala at scalareflectapiTreesTraversertraverseTreesscala at comwixaccordtransformPatternHelperanon traversePatternHelperscala at comwixaccordtransformPatternHelperclasscollectFromPatternPatternHelperscala at comwixaccordtransformValidationTransformcollectFromPatternValidationTransformscala at comwixaccordtransformValidationTransformtransformedValidationTransformscala at comwixaccordtransformValidationTransformapplyValidationTransformscala validator CtptyLoanColl arg The exception is for the following validator import comwixaccorddsl import comwixaccordtransformValidationTransformTransformedValidator object IHSValidator implicit val ctptyLoanCollValidator TransformedValidator CtptyLoanColl validator CtptyLoanColl arg if argLNTypeOfSft SLEB argLNBaseProd match case AGRI argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case NRGY argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case ENVR argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case FRGT argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case FRTL argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case INDP argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case METL argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case PAPR argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR case POLY argLNSubProd is inGROS SOFT POTA OOLI DIRY FRST SEAF LSTK GRIN OTHR Only works when I comment all cases but one As soon as I add another one the compilation fails Relevant case class import javaioPrintWriter import javalangBoolean JBoolean import javasqlDate Timestamp import javatimeformatDateTimeFormatter import scalareflectruntimeuniverse case class CtptyLoanCollIMSubmitterID String null IMParticipantID String null IMRepCpCodeType String null CPRepCp String null CPNatureOfRepCp String null IMNatureOfOtherCp String null CPSecOfRepCp String null CPAdditionalSecClass String null IMBranchOfRepCpType String null CPBranchOfRepCp String null IMBranchOfOtherCpType String null CPBranchOfOtherCp String null CPCpSide String null CPEntResponsibleForRep String null IMOtherCpType String null CPOtherCp String null CPCountryOfOtherCp String null IMCountryOfRpCp String null IMSecOfOthrCp String null IMBeneficiaryType String null CPBeneficiary String null IMTriPartyAgentType String null CPTriPartyAgent String null IMBrokerCodeType String null CPBroker String null IMClearingMemberCodeType String null CPClearingMember String null IMCsdParticipantCodeType String null CPCsdParticipant String null IMCsdIndirectParticipantCodeType String null CPCsdIndirectParticipant String null IMAgentLenderCodeType String null CPAgentLender String null IMTradeRef String null LNUti String null LNRepTrackingNo String null LNEventDate Date null IMAsOfDateTime Timestamp null LNTypeOfSft String null LNCleared JBoolean null LNClearingTime Timestamp null LNCcp String null LNTradingVenue String null LNMasterAgreementType String null LNOtherMasterAgreementType String null LNMasterAgreementVer String null IMMasterAgreementID String null LNExecutionTime Timestamp null LNValueDateStartDate Date null LNMaturityDateEndDate Date null LNTerminationDate Date null LNMinimumNoticePer String null LNEarliestCallBackDate Date null LNGeneralCollIndicator String null LNDbvIndicator JBoolean null LNMethodUsedToProvideColl String null LNOpenTerm JBoolean null LNTerminationOptionality String null LNFixedRate String null LNDayCountConvention String null LNFlotRate String null LNFlotRateRefPerTimePer String null LNFlotRateRefPerMultiplier String null LNFlotRatePaymentFreqTimePer String null LNFlotRatePaymentFreqMultiplier String null LNFlotRateResetFreqTimePer String null LNFlotRateResetFreqMultiplier String null LNSpread String null LNAdjustedRate String null LNRateDate Date null LNPrinAmtOnValueDate String null LNPrinAmtOnMaturityDate String null LNPrinAmtCcy String null IMMarketIdentifierTypes String null IMMarketIdentifierCodes String null LNTypeOfAsset String null LNSecId String null IMSecurityDescr String null LNClassOfASec String null LNBaseProd String null LNSubProd String null LNFurtherSubProd String null LNQuantityOrNominalAmt String null LNUnitOfMeasure String null LNCcyOfNominalAmt String null LNSecOrCommodityPrice String null LNSecOrCommodityPriceBasis String null LNSecOrCommodityPricePct String null LNSecOrCommodityPriceYield String null LNPriceCcy String null LNSecQuality String null LNMaturityOfSec Date null LNJurisdictionOfIssuer String null LNLeiOfIssuer String null LNSecType String null LNLoanValue String null LNMarketValue String null LNFixedRebRate String null LNFlotRebRate String null LNFlotRebRateRefPerTimePer String null LNFlotRebRateRefPerMultiplier String null LNFlotRebRatePaymentFreqTimePer String null LNFlotRebRatePaymentFreqMultiplier String null LNFlotRebRateResetFreqTimePer String null LNFlotRebRateResetFreqMultiplier String null LNSpreadOfRebRate String null LNLenFee String null LNExclusiveArrangements JBoolean null COUncollateralisedSlFlag JBoolean null COCollisationOfNetExposure JBoolean null COValueDateOfColl Date null COTypeOfCollComponent String null IMCollAssetIdentifierTypes String null IMCollAssetIdentifierCodes String null IMCollSecDescr String null COCashCollAmt String null COCashCollCcy String null COIdOfASecUsedAsColl String null COClassOfASecUsedAsColl String null COBaseProd String null COSubProd String null COFurtherSubProd String null COCollQuantityOrNominalAmt String null COCollUnitOfMeasure String null COCcyOfCollNominalAmt String null COPriceCcy String null COPricePerUnit String null COPricePerUnitBasis String null COPricePerUnitPct String null COPricePerUnitYield String null COCollMarketValue String null COHaircutOrMargin String null COCollQuality String null COMaturityOfSec Date null COJurisdictionOfIssuer String null COLeiOfIssuer String null COCollType String null COAvailabilityForCollReuse JBoolean null COCollBasketId String null COPortfolioCode String null COActionType String null COLevel String null IMDelegatedReporting String null IMOthrCptyAdditionalSecClass String null IMShellTradeRef String null IMShellTradeQttyNom String null IMCCPCodeType String null IMEEARptCpty JBoolean null IMMemberOfESCB JBoolean null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null IMUserDefined String null def toCSV String thisproductIteratormap case null case timestamp Timestamp DateTimeFormatterISOINSTANTformattimestamptoInstant case value valuetoStringreplace mkString object CtptyLoanColl val header String typeOf CtptyLoanColl memberscollect case m MethodSymbol if misCaseAccessor m mapnametoStringtoListreversemkString def printwriter PrintWriter records Seq String submitterID String feedType String Trade version String sequence Int timestamp String Unit writerprintlnsDataSuppliersubmitterIDFeedTypefeedTypeSchemaVersionversionSeqNosequenceDateProducedtimestampRecordCountrecordssize writerprintlnCtptyLoanCollheader recordsforeachwriterprintln Makes the following syntax instances valid classroomstudentseach map age should be classroomstudentseach map age map toString is notEmpty classroomstudentseach flatMap guardians is valid classroomstudentseach flatMap guardians map age should be classroomstudentseach flatMap guardiansheadOption map age should be classroomstudentseach flatMap guardians has sizebetween Im not entirely sure supporting flatMap or any other nonstructurepreserving operation is the right way to go Suppose you have val coll Seq and a function val extend i Int Seqi i coll flatMap extend would produce Seq Now if element Int is invalid colleach flatMap extend is valid would refer to at index after collection transformation This works but may overcomplicate validators Also replaced Traversable with Iterable because of collections rework Im trying to set up a validator based on the web site example Ive got import comwixaccorddsl case class Deck id Option UUID number Int name String code String isPax Boolean def safeId idgetOrElseUUIDrandomUUID object Deck val LOWEST val HIGHEST A validator defines all the business logic for validating attributes Validators can be called at any time with the validate function Typically validate is called right after creating a new instance implicit val deckValidator validator Deck p pcodelength is between The expression being validated is resolved automatically see below pcode should matchRegex Which generates the following errors error UserszbeckmanProjectsLightbendNCLzeroshipserviceshipapisrcmainscalacomnclzeroapishipDeckscala exception during macro expansion error javalangNoSuchMethodError scalacollectionimmutablecoloncolontl LscalacollectionimmutableList error at comwixaccordtransformFunctionDescriberclassdescribeFunctionExpressionDescriberscala error at comwixaccordtransformValidationTransformdescribeFunctionValidationTransformscala error at comwixaccordtransformValidationTransforminitValidationTransformscala error at comwixaccordtransformValidationTransformapplyValidationTransformscala error implicit val deckValidator validator Deck p error Im getting the following error exception during macro expansion javalangNoSuchMethodError scalacollectionimmutablecoloncolontl LscalacollectionimmutableList at comwixaccordtransformFunctionDescriberclassdescribeFunctionExpressionDescriberscala at comwixaccordtransformValidationTransformdescribeFunctionValidationTransformscala at comwixaccordtransformValidationTransforminitValidationTransformscala at comwixaccordtransformValidationTransformapplyValidationTransformscala When attempting to create the following validator object foo implicit val shipValidator validator Ship p psummarycodelength is between The expression being validated is resolved automatically see below psummarycode should matchRegex psummarypaxCapacity as ship code should be You can also explicitly describe the expression being validated For the following class case class Ship summary ShipSummary detail ShipDetail decks Decks fireZones FireZones shipsTime Option Instant def safeId summaryidgetOrElseUUIDrandomUUID object Ship type LegacyID Map String String type Attributes Map String String some other stuff implicit val optionString Format Ship Jsonformat Were using the newest version and tried pattern matching with guards as in the examples scala implicit val numericValidator validator NumericPair pair pairnumeric match case n if n pairstring should startWith case pairstring is equalTo case n if n pairstring is notEmpty Everything works fine with compiling and running but publishing fails as ScalaDoc seems to have a problem with the guards without the guard its fine scala sbt doc info This is a scaladoc compilation Linter is disabled error Accord not a legal formal parameter error Note Tuples cannot be directly destructured in method or function parameters error Either create a single parameter accepting the Tuple error or consider a pattern matching anonymous function case param param error n error error Accord illegal start of simple expression error n error info No documentation generated with unsuccessful compiler run error two errors found error compiledoc Scaladoc generation failed Any ideas what the problem is Many thanks workspacescalaaccord master sbt update info Loading global plugins from Usersharysbt plugins info Loading project definition from Usersharyworkspacescalaaccordproject info Set current project to root in build fileUsersharyworkspacescalaaccord info Updating fileUsersharyworkspacescalaaccordroot info Updating fileUsersharyworkspacescalaaccordapiJVM info Updating fileUsersharyworkspacescalaaccordapiJS info Resolving comlihaoyiammonite warn module not found comlihaoyiammonite warn local tried warn Usersharyivy localcomlihaoyiammonite ivysivyxml warn public tried warn warn localpreloadedivy tried warn Usersharysbtpreloadedcomlihaoyiammonite ivysivyxml warn localpreloaded tried warn fileUsersharysbtpreloadedcomlihaoyiammonite ammonite pom info Resolving jlinejline warn warn UNRESOLVED DEPENDENCIES warn warn comlihaoyiammonite not found warn warn warn Note Unresolved dependencies path warn comlihaoyiammonite Usersharysbt globalsbtL warn comwixaccordapi SNAPSHOT info Resolving comlihaoyiammonite warn module not found comlihaoyiammonite warn local tried warn Usersharyivy localcomlihaoyiammonite ivysivyxml warn public tried warn warn localpreloadedivy tried warn Usersharysbtpreloadedcomlihaoyiammonite ivysivyxml warn localpreloaded tried warn fileUsersharysbtpreloadedcomlihaoyiammonite ammonite pom info Resolving orgeclipsejettyjettycontinuation v warn warn UNRESOLVED DEPENDENCIES warn warn comlihaoyiammonite not found warn warn warn Note Unresolved dependencies path warn comlihaoyiammonite Usersharysbt globalsbtL warn comwixaccordapisjs SNAPSHOT info Resolving comlihaoyiammonite warn module not found comlihaoyiammonite warn local tried warn Usersharyivy localcomlihaoyiammonite ivysivyxml warn public tried warn warn localpreloadedivy tried warn Usersharysbtpreloadedcomlihaoyiammonite ivysivyxml warn localpreloaded tried warn fileUsersharysbtpreloadedcomlihaoyiammonite ammonite pom info Resolving jlinejline warn warn UNRESOLVED DEPENDENCIES warn warn comlihaoyiammonite not found warn warn warn Note Unresolved dependencies path warn comlihaoyiammonite Usersharysbt globalsbtL warn comwixroot SNAPSHOT sbtResolveException unresolved dependency comlihaoyiammonite not found The new spec for bean validation is in progress requesting comments from the community Would you mind sharing your views there so that all the issues accord solved would be incorporated in the newer version Thanks Its probably a stretch to expect something like Shapeless to play well with Accord but using Coproducts and HLists within your data types can lead to a more expressive domain model Id love to see Accord support some limited set of functionality on CoproductsHLists For instance Id really love to do something like this scala import shapeless import comwixaccord import comwixaccorddsl object Main case class Aa String case class Bb String type AB A B CNil implicit val aValidator Validator A implicit val bValidator Validator B implicit val abValidator Validator AB validator AB ab abselect A match case a if aisInstanceOf A abselect A get is valid A abselect B match case b if bisInstanceOf B abselect B get is valid B I would have expected this match statement in the abValidator to compile but instead I just get a cryptic coproduct is not an enclosing class error from the compiler My guess is the match statement isnt being processed properly by the macros in Accord although I must admit I havent dug too deeply yet to verify Pick a community coding convention whichever one Reformat all code in a big bang commit Enact the coding style going forward via appropriate sbt plugin