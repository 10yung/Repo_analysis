I am running into an issue where pgxpool returns partial rows I am using pgx v nil ERR Query args otelcol modulepgx pid sqlSELECT nil INF Dialing PostgreSQL server hostpostgresql modulepgx INF Query args otelcol modulepgx pid rowCount sqlSELECT nil ERR Query args otelcol modulepgx pid sqlSELECT nil INF Dialing PostgreSQL server hostpostgresql modulepgx I turned on trace but pgx only print ERR nothing else go poolConfig err pgxpoolParseConfigdburl if err nil return nil err poolConfigConnConfigLogLevel pgxLogLevelTrace poolConfigConnConfigLogger zerologadapterNewLoggerzerologNewzerologNewConsoleWriter return pgxpoolConnectConfigctx poolConfig query code go conn err poolAcquirectx if err nil logErrerrMsgerror acquire db connection from pool return nil defer connRelease var chunks string blobs of the index note last one is the time delta err connQueryRowctx SELECT chunksjson FROM header WHERE hid hidScan chunks if err nil logErrerrMsgselect bucket chunks error return nil return chunks The only thing I noticed is every ERR followed by this log file nil INF Dialing PostgreSQL server hostpostgresql modulepgx Any pointers on how to debug the error Im not sure if this issue assuming it is one lies here or in pgconn The Go standard library expects an ioEOF be returned by drivers when there are no more rows to be read under nonerror conditions The stdlib package correctly returns ioEOF when no error has occured during reading If an error is returned during reading this is then returned to the standard library verbatim We are experiencing circumstances where pgx RowsErr is returning ioEOF but the reading of rows did not complete The error is being returned to the standard library at The consequence of this is that from the clients perspective the row reading did complete but actually it only got part way through the result set this can be quite disasterous The circumstances are reproducable although perhaps a little offpiste we are sending a SIGKILL to a CockroachDB instance which uses pg protocol that is running inside a kubernetes cluster so dockerised If a client is busy reading rows whilst this occurs and happens to be connected to that particular instance the reading stops short and no error is returned Unfortunately I dont have an isolated reproduction case for this I could possibly try and piece something together if wanted So to trace this through a bit further pgx connRowsNext calls pgconn ResultReaderNextRow pgconn ResultReaderNextRow calls ResultReaderreceiveMessage If an error is returned by this function false is returned by NextRow stopping any further iteration pgconn ResultReaderreceiveMessage calls PgConnreceiveMessage If this returns an error this is set into ResultReadererr and this is the error value that is returned to the standard library via ResultReaderconcludeCommand Assuming bufferingReceive is false pgconn PgConnreceiveMessage calls FrontendReceive this is implemented by pgproto Frontend The error from this call is returned verbatim pgproto FrontendReceive calls ChunkReaderNext The implementation of ChunkReaderNext calls ChunkReaderappendAtLeast That then calls ioReadAtLeast which we are seeing return ioEOF as an error in circumstances where not all rows have been received I believe the underlying reader for what we are dealing with in our example is standard library net TCPConn wrapped with cryptotls Client My understanding of ioEOF is that it should be returned on graceful end of input which perhaps seems a bit odd given we are sending a SIGKILL to the server tcpdump shows a FIN ACK is being sent by the server which maybe suggests the kernel is slamming to door on the client the client sees this as graceful Quite unsure Either way should the libraries not protect against this occurring There are a couple of things that seemingly could help here Im not well versed in postgres protocol but it seems youd expect a CommandComplete to come through which it clearly wont be in this case pgconn could check for ioEOF and return ioUnexpectedEOF if the command did not complete Alternatively could the stdlib package do something similar If ioEOF is returned return ioUnexpectedEOF the the caller Given following code go package main import fmt githubcomjackcpgx func main dsn hostdb port cfg pgxParseConnectionStringdsn err pgxConnectcfg fmtPrintlnerr expected output is dial tcp lookup db no such host but if db directory is present in working directory we get following output dial unix dbsPGSQL connect no such file or directory Bug is caused by ConnConfignetworkAddresses method assuming that if osStatccHost returns no error given host is in fact socket file This error can easily occur in Docker environments where host such as db are common for database containers We currently use the googleuuid library for our UUIDs Itd be great if there was support for this either directly in UUIDArray or in an ext package like uuidfrs Provision of adding instrumentation to pgxv pgxpool Right now when using pgxpool instrumentation has to be manually added record errors etc I glanced through the pgxpool sourcecode though couldnt find any relevant interfaces or structs where I could plug in instrumentation I think it would be awesome to have provision of adding it as any production ready system at a decent scale would make use of monitoring Eg Connecting to PGBouncer without SSL and attempting to run any query fails with ERROR unsupported pkt type SQLSTATE P I also tried and it seems that this error is not new Looks quite similar to I attempted both the sqlDB interface and the native pgx interface to no avail Versions PGBouncer pgx error cant scan into dest unknown oid cannot be scanned into sql CREATE TYPE url AS url varchar status int CREATE TABLE publictiantangpage href varchar NOT NULL status int NOT NULL description varchar NOT NULL urls url NULL go rows err connQuerycontextBackground select hrefstatusdescriptionurls from publictiantangpage if err nil logFatalerr for rowsNext var row testData err rowsScan rowhref rowstatus rowdescription rowurls if err nil logFatalerr println I want to use pgxpool with sqlx and I am trying to adapt example from this comment for version v But seems like there is no stdlibOpenFromConnPool method now How I can get sqlDB from pgxpoolPool Thank you Running copyfromtestgo for CrateDB throws below error ERROR SQLParseException line mismatched input from expecting TO WHERE SQLSTATE XX Please find below table schema and go code taken from copyfromtestgo to test CopyFrom functionality in CrateDB CrateDB table schema create table foo a int b int c int CopyFrom Code func CopyFromTest conn err pgxConnectcontextBackground postgrescratecrate doc if err nil loggerFatalfUnable to establish connection v err inputRows interface int int int nil nil nil copyCount err connCopyFromcontextBackground pgxIdentifierfoo stringa b c pgxCopyFromRowsinputRows if err nil loggerErrorfUnexpected error for CopyFrom v err if intcopyCount leninputRows loggerErrorfExpected CopyFrom to return d copied rows but got d leninputRows copyCount Exception ERROR SQLParseException line mismatched input from expecting TO WHERE SQLSTATE XX I have the table that contains around k rows satisfying this query when I send it to the db directly sql SELECT bid priprovider FROM bookings AS b JOIN providerinformation AS pri ON bid priid WHERE priproviderinfosupplierid ID But when I do that via pgx I retrieve about k rows go config err pgxpoolParseConfigdbinfo if err nil return nil err configConnConfigPreferSimpleProtocol true configMaxConns pool err pgxpoolConnectConfigcontextBackground config if err nil return nil err const query SELECT bid priproviderdata FROM bookings AS b JOIN providerinformation AS pri ON bid priid WHERE priproviderinfosupplierid ID rows err poolQuerycontextBackground query if err nil panicerrorsWraperr query bookings for rowsNext if err rowsErr err nil logPrintlnnext row err continue some code 