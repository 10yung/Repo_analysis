Is there any documentation about the state of the system when start function is invoked by the bootloader For example what features are enabled what is the layout of memory what state are the processors in Is it always index Should this be passed in the BootInfo struct Would it be possible to have support to boot using PXE or iPXE with iPXE downloading the bootimagebin using TFTP for instance This would require changing the logic to load the files in memory which iPXE probably takes care of This could be poretty helpful for development on real hardware as it wuld allow to network boot instead of going through the write to USB manipulations We currently only test the bootloader without the SSE feature We should add an additional test kernel that makes use of it The bootloader currently sets up huge stack for the kernel by default pages MB Now that the stack size is configurable we should probably reduce the default cc The current entry point is hardcoded to start or the entrypoint macro This provides a single entry point to the code When bootstrapping SMP the new processor starts up at a given physical address in the IPI InterProcessor Interrupt in bit mode This requires us to start at bit code and enable bit mode again Please provide a way to define multiple entry points which defaults to the current start but can also be used to bootstrap SMP cc Mendess lets continue the discussion here This will need srcstage s to be adapted to stay in protected mode and to setup nonPAE page tables It will then need at least changes to the rust part to handle nonPAE page tables Currently we only provide some minimal build instructions in the Readme We should also document advanced patterns such as Creating a higher half kernel x Chainloading with GRUB see Completed in I think the best approach for now is to just create a doc folder with markdown files in it and link it from the Readme Hello all this PR checks if VESA or is supported and then enables it with fixed x This is very rough so please let me know what else we need to do TODO Proper color handling Query the framebuffer address from hardware instead of hardcoding it if possible Pass the framebuffer address in BootInfo Hello there I need to start by saying that this project is awesome and I strongly believe it will spark the creation of some very creative pieces of software Nevertheless I think it would have being awesome to add support for choosing one of the available VESA modes Right now you have to do it in realtime mode while bootloader switches the processor to go to bits and therefore if you need to work with it then you need to somehow go back to bits in the kernel or bits with emulation and do the setup Making bootloader do it might be the best idea as well as give it an option to automatically choose the highest option As far as I understand it can be quite a challenge considering you have to fit it into bit processor mode memory first bytes but as far as I know it is rather doable I think that this implementation from Redox OS can serve as a good example Cheers Alex