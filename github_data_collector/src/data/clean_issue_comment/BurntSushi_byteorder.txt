Building on this improves the ergonomics of i slice methods in two ways Changes ReadBytesExtreadi into to use a more strict unsafe cast While this does not change safety or optimized build performance at optlevel it does marginally improve debug code size godbolt diff Adds a ByteOrderwritei into method for completeness and parity with other types which prevents users having to write their own unsafe blocks or loops with writei for what is just a slice copy This parity with other types is especially convenient when macrogenerating code pertype since one can treat i like all other types example I write some kind of protocol parser and I use next code to read protocol data rust readerreadu intoLittleEndian mut buffer I would like to use the same logic for writer rust writerwriteu fromLittleEndian buffer Is that already possible Or it needs implementation I have a mini benchmark for a bit packingcompression algorithm which uses writeu from WriteBytesExt The benchmark results show about a x speedup when I replace writeu with an unsafe equivalent This issue is to track to understand why this is and if we canshould do anything abut it Repo Standard writeu code in branch ddeltasafe To invoke benchmark cargo bench nibblepack nibblepack varying bits time ns ns ns change p Performance has regressed Found outliers among measurements high mild high severe nibblepack varying bits time ns ns ns change p Performance has regressed Found outliers among measurements low severe low mild high mild high severe nibblepack varying bits time ns ns ns change p Performance has regressed Found outliers among measurements Note the bits and are the ones we care about basically where number of bits are divisible by as thats the path that uses writeu On another branch the unsafe code ddeltahist nibblepack varying bits time ns ns ns change p Performance has improved Found outliers among measurements high mild high severe nibblepack varying bits time ns ns ns change p Performance has improved Found outliers among measurements low severe low mild high mild high severe nibblepack varying bits time ns ns ns change p Performance has improved Found outliers among measurements The code is in byteutilsrsdirectwriteuintle The unsafe version is about x faster Its a little hard to tell from disassembly where the relevant asm is What I do though is that I comment out the inline above the directwriteuintle func and run cargo asm compressedvecbyteutilsdirectwriteuintle I believe Im doing this correctly Im trying to create an f from u s rust extern crate byteorder use byteorderLittleEndian ReadBytesExt WriteBytesExt hello fn main let mut cursor stdioCursornewvec cursorwriteu LittleEndian u unwrap cursorwriteu LittleEndian u unwrap cursorwriteu LittleEndian u unwrap cursorwriteu LittleEndian u unwrap println cursor let f cursorreadf LittleEndianunwrap println f My println outputs Cursor inner pos but the readf line panics with thread main panicked at called Resultunwrap on an Err value Custom kind UnexpectedEof error StringError failed to fill whole buffer libcoreresultrs Am I doing something wrong x so I believe the cursor has the correct number of bytes in it I see no reason why this would be erroring in this way It would be nice to support m m m d m i m d m i etc the same way the primitive integers are supported Hi there Ive been toying around with adding faster to a few encoding libraries and I noticed that I could get up to a x speed boost by using it in writeu into writeu into and writeu into The compiler does a pretty good job of vectorizing the read functions Would there be any interest in adding this behind a feature Benchmarks Ivy Bridge host bit integer vectors faster No difference between targetcpunative and targetcpux test sliceu writebigendian bench nsiter MBs test sliceu writebigendian bench nsiter MBs test sliceu writebigendian bench nsiter MBs master C targetcpunative test sliceu writebigendian bench nsiter MBs test sliceu writebigendian bench nsiter MBs test sliceu writebigendian bench nsiter MBs The release introduced slice methods for the ReadBytesExt trait readinto It would be useful to have the corresponding write methods for the WriteBytesExt trait From a discussion on rustbeginners there seems to be a need for ByteOrder implementation that dispatches to LEBE based on runtime information Essentially something like this rust enum Endianess Little Big impl ByteOrder for Endianess boilerplate methods with match that dispatch to LE or BE let endianess getendianessatruntime endianessreadi somebytes The byteorder docs dont seem to say that the crate is focused solely on statictypelevel checking so Im guessing this would be in scope for the library Of course this isnt strictly necessary as you can probably just write readingwriting code generically and simply move the LEBE decision to a higher level but it may simplify some use cases regardless write methods of ByteOrder trait accept a buffer and dont guarantee that they wouldnt read from it This has a drawback that strictly speaking the provided buffer shouldnt be uninitialized I suggest to provide some way of guaranteeing that the buffer wont be read from so its fine to pass uninitialized buffer