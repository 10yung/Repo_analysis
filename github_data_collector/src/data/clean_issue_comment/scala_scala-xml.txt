Came up in May not be used It could be deprecated in and removed in While working on I noticed that links to Javadoc dont work for JDK and later with Scala The warnings in the sbt console bear this out warn sharedsrcmainscalascalaxmlpackagescala Could not warn find any member to link for javaxxmlparsersSAXParser warn warn warn sharedsrcmainscalascalaxmlparsingFactoryAdapterscala warn Could not find any member to link for orgxmlsaxSAXException warn warn warn sharedsrcmainscalascalaxmlincludeXIncludeExceptionscala warn Could not find any member to link for warn javalangThrowablegetMessage warn warn warn sharedsrcmainscalascalaxmlincludesaxEncodingHeuristicsscala warn Could not find any member to link for javaioIOException warn warn In order to increase compatibility on JDK versions with modules consider adding AutomaticModuleName in the MANIFESTINF along the lines of akkaakka or perhaps even implement properly the moduleinfo descriptor Is this needed any longer Is the scalacompiler dependency an actual dependency If the point is to avoid getting a redundant scalaxml on the classpath in this build or downstream users that shouldnt be a problem with sbt or later I know there are compiler and reflection tests but maybe they can be moved elsewhere or sunset If the point is to avoid a redundant scalaxml dependency from the compiler for downstream users that was fixed in It seems it shouldnt be an issue with but it would take an investigation Hello everyone I am trying to implement xml validation through the use of an xsd schema I used a code similar to the one provided in the wiki however I find no way to handle the errors thrown during validation I think this is done normally through associating an ErrorHandler to the underlying XmlReader instance Is there a way to do this in scalaxml Putting an unclosed character ref in XML causes an infinite loop Example code import scalaioSource import scalaxmlparsingXhtmlParser val text htmlbodytest test bodyhtml XhtmlParserSourcefromStringtext When an XML file starts like this xmlstylesheet typetextxsl href alternateno titleDefault rootTag tag tag since there is no xml declaration it gives a warning whitespace expectedstylesheet typetextxsl href alternateno titleDefault expected instead of rootTag xmlnssomething xmlnsxsi expected instead of tag codeQQ And then it processes normally as if tag is the first tag It does not give any error but parse the file wrongly If an xml declaration is added it works fine xml version xmlstylesheet typetextxsl href alternateno titleDefault rootTag tag tag Shouldnt it be giving an error if xml declaration was the issue scala import scalaxml import scalaxmltransformRewriteRule RuleTransformer object TransformIssue def addNewElement RewriteRule new RewriteRule override def transformn Node Seq Node n match case elementelement elementnewnewelement def addThingElement RewriteRule new RewriteRule override def transformn Node Seq Node n match case element childrenelement element children element case newnew newthingthingnew def changenode Node Node new RuleTransformer addNewElement addThingElement transformnodehead def changeWorkaroundnode Node Node val out new RuleTransformer addNewElement transformnodehead new RuleTransformer addThingElement transformout head scala import orgscalatestFlatSpec FunSpec import orgscalatest class TransformIssueSpec extends FlatSpec with Matchers it should apply transform to created elements in val output TransformIssuechangeelementelement output should beelementnewthingthingnewelement fails it should work the same as the workaround imo in TransformIssuechangeelementelement should equalTransformIssuechangeWorkaroundelementelement fails When we apply a transform with two rewrite rules the first one adding a new element the second one adding children to the new element then the second rewrite rule does not match on the elements added in the first rule When we apply the same RewriteRules in two separate RuleTransformers it does add the children to the elements added in the first step We would expect the change and changeWorkaround functions to produce the same output after scalascala was merged in the community build we have scalaxml error homejenkinsworkspacescala xintegratecommunitybuildtarget projectbuildsscalaxmle a e a e f b e cd bed e ced eesharedsrcmainscalascalaxmlUtilityscala error during expansion of this match this is a scalac bug scalaxml error The underlying error was type mismatch scalaxml error found Seq scalaxmlNode in scalacollection scalaxml error required Seq scalaxmlNode in scalacollectionimmutable scalaxml error def trimx Node Node x match scalaxml error and a few more such errors does this indicate that there is code in scalaxml that needs to be adjusted to the new scheme for namebased extractors or is there a flaw in scalascala 