Hello all jondot I am trying to implement Sneakers in an existing web application and I am trying to reuse an existing amqp connection Ive passed it in the connection as a configuration option Sneakersconfigure connection InstantiateAMQPConnection heartbeat Im getting a timeout and i think its related to the forking for Sneakers Unexpected error TimeoutError gemsbunny libbunnyconcurrentcontinuationqueuerb in block in poll gemsbunny libbunnyconcurrentcontinuationqueuerb in synchronize gemsbunny libbunnyconcurrentcontinuationqueuerb in poll gemsbunny libbunnysessionrb in waitoncontinuations gemsbunny libbunnysessionrb in block in openchannel homevagrantrvmrubiesruby libruby monitorrb in monsynchronize gemsbunny libbunnysessionrb in openchannel gemsbunny libbunnychannelrb in open gemsbunny libbunnysessionrb in block in createchannel homevagrantrvmrubiesruby libruby monitorrb in monsynchronize gemsbunny libbunnysessionrb in createchannel gemssneakers libsneakersqueuerb in subscribe That means that it would be safer to pass connection details so that each worker can open their own connection to rabbit libsneakersworkerrb Rails gem capistranosneakers github inventionlabsSydneycapistranosneakers require false When I run bundle exec rake sneakersstart It wont go beyond this command I have daemonize true but it work like daemonize false Sneakers uses inconsistent log level for messages produced by worker and publisher worker uses debug but publisher uses info I think it makes sense for them to use the same log level so it will be easy to configure logger to the right log level Worker I have not found any docs on the subject and I have not found any sensible ways of stopping my sneaker workers except to run ps aux grep sneakers and then kill pid on workers by individual PID This sucks a lot and means that if I push any new code I have to ssh into my production server kill processes individually then restart each worker for each app Since I run several apps on the same OS and several of them use sneakers I have had to kill ALL workers in order to push new code instead of rebooting only workers belonging to the app I have a sneakers process running with the following config worker is run using bundle exec ruby sneakersrb ruby sneakersrb Sneakersconfigure heartbeat amqp amqpENV RABBITMQUSER ENV RABBITMQPASS ENV RABBITMQHOST daemonize ENV RACKENV production pidpath sneakerspid vhost exchange sneakers exchangetype direct timeoutjobafter minutes log logsneakerslog Sneakersloggerlevel LoggerINFO workers SneakersRunnernew WorkersJD workersrun and a worker module with the following ruby workerrb module Workers class JD include SneakersWorker fromqueue somequeue def workmsg ack end end end bash ps aux grep sneakers alilland S PM ruby sneakersrb alilland s S PM grep colorauto excludedirbzr excludedirCVS excludedirgit excludedirhg excludedirsvn sneakers alilland S PM ruby sneakersrb alilland S PM ruby sneakersrb alilland S PM ruby sneakersrb alilland S PM ruby sneakersrb kill kill kill kill kill there is no way that I can add that to a bash script and execute it in a git hook Middleware call needs to have access to the worker class for logging purposes at least I opened a PR with a minor change where middleware call method is being called a minor change to pass the worker object to the middleware call Hi Im just curious is it possible to implement such behaviour The case is that each of my workers establishes some connection to remote server Im fetching emails with IMAP protocol So Id like to have some kind of pool of established connections in advance I want this pool to be available to newly spawned worker so it could fetch connection instead of connecting again and again wasting time and resources Hello Ive found a bug that makes Sneakers not to report acknowledge state on error Wiki suggests to pass contexthash to error notification agents link ruby Sneakerserrorreporters proc exception worker contexthash Honeybadgernotifyexception contexthash Im using Sentry raven for error notifications Sometimes it fails to serialize contexthash to json because BunnyChannel instance in deliveryinfo of contexthash causes SystemStackError stack level too deep As result RabbitMQ keeps message as Unacked Such messages number may reach number of prefetched messages for worker Worker hangs without performing any workload Sneakers handles only StandardError and its descendants here and can not handle SystemStackError because it is not a StandardError Previously I fixed similar bug in another place And I would be happy to do the same here But I think that it would be better to rescue from Exception in both places and reraise exception in case of Interrupt NoMemoryError and other exceptions that should not be swallowed WDYT Is there a way to override or append to bunny client properties img width altScreen Shot at AM src Looks like I cant use RabbitMQ in production We are using IBM MQ and I was wondering if there is a drop in replacement or could I write a wrapper to work with sneakers