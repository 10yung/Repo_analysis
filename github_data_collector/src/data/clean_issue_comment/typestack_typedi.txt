Containerset type enhancement When trying to get services inside a scoped container that reference each other we get Maximum call stack size exceeded error Code required to reproduce ts import reflectmetadata import Container Service Inject from typedi Service class A Inject B b any Service class B Inject A a any Works consolelog a ContainergetA b ContainergetB const instance Containerofsomeinstance Throws Maximum call stack size exceeded error consolelog a instancegetA b instancegetB Output when running with tsnode PS D typeditest tsnode project tsconfigjson indexts a A b B a Circular b B a A b Circular D typeditest src ContainerInstancets return thisservicesfindservice RangeError Maximum call stack size exceeded at D typeditest src ContainerInstancets at Arrayfind anonymous at ContainerInstancefindService D typeditest src ContainerInstancets at ContainerInstanceget D typeditest src ContainerInstancets at Objectvalue D typeditest src decorators Injectts at D typeditest src ContainerInstancets at ArrayforEach anonymous at ContainerInstanceapplyPropertyHandlers D typeditest src ContainerInstancets at ContainerInstancegetServiceValue D typeditest src ContainerInstancets at ContainerInstanceget D typeditest src ContainerInstancets No idea why source paths are wrong there Error when running compiled code PS D typeditest node dist indexjs a A b B a Circular b B a A b Circular D typeditest nodemodules reflectmetadata Reflectjs function GetOrCreateMetadataMapO P Create RangeError Maximum call stack size exceeded at GetOrCreateMetadataMap D typeditest nodemodules reflectmetadata Reflectjs at OrdinaryHasOwnMetadata D typeditest nodemodules reflectmetadata Reflectjs at OrdinaryGetMetadata D typeditest nodemodules reflectmetadata Reflectjs at OrdinaryGetMetadata D typeditest nodemodules reflectmetadata Reflectjs at OrdinaryGetMetadata D typeditest nodemodules reflectmetadata Reflectjs at ObjectgetMetadata D typeditest nodemodules reflectmetadata Reflectjs at ContainerInstancegetServiceValue D typeditest nodemodules typedi ContainerInstancejs at ContainerInstanceget D typeditest nodemodules typedi ContainerInstancejs at Objectvalue D typeditest nodemodules typedi decorators Injectjs at D typeditest nodemodules typedi ContainerInstancejs Hello I have strange issue when injecting into constructor together custom decorated class Please read test case describeConstructor inject not working when double decorated function beforeEach Containerreset itshould inject service via constructor function function logClass return function T extends newargs any constructor T return class extends constructor constructorargs any consolelogCreating constructorname consolelogargs superargs consolelogDid something after the original constructor Service class TestService Service class SecondTestService Servicemegaservice class NamedService Service logClass class TestServiceWithParameters constructor public testClass TestService Injecttype SecondTestService public secondTest any Injectmegaservice public megaService any ContainergetTestServiceWithParameterstestClassshouldbeinstanceOfTestService ContainergetTestServiceWithParameterssecondTestshouldbeinstanceOfSecondTestService ContainergetTestServiceWithParametersmegaServiceshouldbeinstanceOfNamedService Result is Constructor inject not working when double decorated Creating TestServiceWithParameters TestService undefined undefined ContainerInstance services Object Object Object Object id undefined Did something after the original constructor should inject service via constructor But with commented logClass decorator everything works fine Could you help I have services that has level injections as follow ts interface IFoo foo string const foo new TokenIFoo interface IBar bar string const bar new TokenIBar Service class FooService implements IFoo foo string Service class BarService implements IBar Injectfoo fooService IFoo Service class FooBarService Injectbar barService IBar Containersetfoo new FooService Containersetbar new BarService ContainergetFooBarService Im trying to get FooBarService depends on IBar that has implementation depends on IFoo I get FooBarService instance with barService injected with instance but barServicefooService is undefined I can do class injection in multiple level including circular injection using Injecttype Classname easily But no hope for token Anyone has a suggestion to encounter this problem Hello all I have some issues in unit testing containergetservice checkout the below code import as from lodash import Service Inject Container from typedi import OTPService from otpindex Service export default class DevicechangeService constructorInjectdevicechangeModelprivate devicechangeModel InjectotpModelprivate otpModel Injectloggerprivate logger Service to change the device method deviceChange param number accountId param string deviceId param number mobile return object resolves after sending otp public async deviceChangeaccountId number deviceId string newdeviceId string created number mobile number Promise any try await this devicechangeModel addDeviceChangeDetailsaccountId let OTPServiceInstance ContainergetOTPService await this otpModel updateOTPtoInactiveForModuleDEVICECHANGE accountId get the new otp get the user details send the otp let result await OTPServiceInstancesendOTPserviceprovider mobile otpMessage isd if result instanceof Object return result return true else return field message errorCodeaccountgetMessage catch e throw e Here i am not able to set mock class for OTPService so not able to alter containergetOTPService from the above code I have tried below but still it doesnt come inside mocked service Service class OTPService public generateOTP any jest fn mockImplementationasyncaccountId number deviceId string status string new Promiseresolve any consolelogcalls here resolve public sendOTP any jest fn mockImplementationasyncserviceprovider string mobile number otpMessage string isd number new Promiseresolve any resolve describeAccount beforeEachdone ContainersetOTPService new OTPService done describedeviceChange itcheck everyting cool async done let logger let otpModel updateOTPtoInactiveForModule jest fn mockImplementationasyncdeviceChange string accountId number new Promiseresolve any resolvetrue getUserPhoneService jest fn mockResolvedValuetrue let devicechangeModel addDeviceChangeDetails jest fn mockResolvedValuetrue updateDeviceChangeToInactive jest fn mockResolvedValuetrue ContainersetOTPService new OTPService let DeviceChangeServiceInstance new DeviceChangeServicedevicechangeModel otpModel logger let deviceChangeStatus DeviceChangeServiceInstancedeviceChangeaccountId deviceId newdeviceId created mobile Guys any input how to solve this The remove is too simple its just dropping references But to properly manange the lifecycle of an allocated object there needs to be a complementary dispose or close or stop or whatever function on created objects The problem arises for me because one of my services uses setTimeout which ends up creating a global reference to the instance There is a stop function on my service which when called will clear the timeout and allow the object to be freed but there is nobody calling it In production it doesnt matter because I am only allocating all the instances in my container once but in tests I am regularly resetting the Container in the same process between tests We finally crossed over the bubble where we are running out of memory because of too many unfreed instances Instead remove and reset should iterate over all services and call an optional dispose method if it exists before dropping references to the service Psuedocode ts async void reset await Promiseallthisservicesmaps s sdispose sdispose thisservices return this Related to Is it possible to create instances of a class like in Spring Something like typescript Service export class DynamodbConfig BeanDocumentClientToken public createDocumentClientInjectAwsRegionTableToken region string DocumentClient return new DocumentClient region region According to the names used in the docs the library claims its implementing the Dependency Injection pattern However going through code examples most of them pull certain dependencies from an object that knows where they all are The dependencies are actually not injected but pulled Moreover from the constructor signature you cannot tell what the dependencies are This pattern is called a service locator and its targeting the same concern decoupling but is a completely different pattern In current shape the docs are confusing since claiming implementing a different pattern that it actually implements Perhaps there is a way to do this but I couldnt figure it out something like this ts Service export class Example constructorprivate worker Worker public check return thisworkerid I am having issues with circular dependencies and its really tempting to do private worker Worker but of course that doesnt work I have to do an extra layer of indirection and am not sure the best way to do it