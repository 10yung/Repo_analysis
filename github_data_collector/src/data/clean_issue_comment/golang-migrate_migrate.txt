This PR aims to solve DB inconsistency mentioned in by letting transactional DB drivers handle setting the version and dirty flag when running a migration Adds a method Transactional bool to the Driver interface Skips calling SetVersion in migratego for transactional drivers Adds a version argument to Run so that transactional drivers know which version to set upon success Updates the Postgres driver to make use of a transaction Try it out by following the alternative instructions in TODO Implement transactional migrations for transactional drivers SQLite MySQL others Clean up the string munging in postgresgo Describe the Bug When the migrate command is killed while a migration is running and the migration succeeds asynchronously inside Postgres the DB is left marked dirty when in reality its clean This is inconsistent and causes confusion This situation realistically occurs when a migration takes longer to run than the app is given to initialize by the supervisor eg Kubernetes and the supervisor restarts the app Steps to Reproduce Full repro at Expected Behavior For databases that support transactionsrollback specifically Postgres the DB should not be eagerly marked dirty until the migration has failed The DB should never be in a state where the migration succeeded but the DB has been marked dirty Migrate Version Loaded Source Drivers file Loaded Database Drivers postgres postgresql stub Go Version go version go darwinamd Stacktrace NA Discussion Are there any existing issues related to this Does anyone have other ideas on how to enforce the consistency This wont work for databases that dont support transactions but perhaps it could be an optional feature that transactional database drivers support Is your feature request related to a problem Please describe This has been a long standing todo from the original migrate implementation Describe the solution youd like Support for the Neo j graph database Describe alternatives youve considered I have implemented this solution Additional context My accompanying pull request is here Describe the Bug I am trying to implement the driver for Neo J The generic driver implementation instructions say that if you cant provide LockUnlock functionality those functions should return nil However if the Lock function returns nil it fails dtTest Steps to Reproduce Steps to reproduce the behavior Implement a driver with a noop Lock function Run dtTest with that driver observe failure Expected Behavior The new driver implementation guide shouldnt result in explicit test failure Migrate Version Latest Loaded Source Drivers Loaded Database Drivers Custom Neo J potentially and nonlocking driver Go Version Latest though not applicable Stacktrace testinggo lock expected err not to be nil Additional context None Is your feature request related to a problem Please describe We recently ran into an issue where there was no statement timeout in a migration This caused a down time We would like to specify a timeout and say that no migration statement should run for more than seconds say Describe the solution youd like Add postgres statement timeout to the connection session Describe alternatives youve considered Adding statement timeout to each migration hard since we need every engineer to remember this during reviews and writing migrations Additional context This PR adds validation to migration versions when creating migrations and improvesrefactors creation in general As a sideeffect it fixes Rationale migrate create doesnt validate migration versions when creating files This causes issues when creating files that results in sameversion migrations Its easy to replicate this behavior created sequentially too fast unix format for name in samesecondone samesecondtwo do migrate create dir migs ext sql format unix name done ls migs samesecondonedownsql samesecondoneupsql samesecondtwodownsql samesecondtwoupsql low precision time format stupid but valid format migrate create dir migs ext sql format samedayone migrate create dir migs ext sql format samedaytwo ls migs samedayonedownsql samedayoneupsql samedaytwodownsql samedaytwoupsql I accidentally hit the first case when converting an already existing database schema into migrations using a very similar loop iterating over table names creating migrations and redirecting the output of pgdump st table into each up migration It didnt occur to me that versions would be colliding When I tried to run migrate up a very obscure unable to parse file error popped up Reading the source code explained it Since its much harder to refactor the whole source package to show useful error messages MigrationsAppend isnt supposed to return error with useful messages instead of bool I went for the simpler warn the kids that the stove is hot solution Solution Improvements Validate migration version on creation to avoid creation of duplicated versions A refactoring of the migration creation code first generates the version component and then checks if any files with that version already exists on disk Heres the corresponding outputs to the commands above using the fixed version go build o tmpmigrate cmdmigrate cd mktemp d tmpmigrate create dir migs ext sql format samedayone migs samedayoneupsql migs samedayonedownsql tmpmigrate create dir migs ext sql format samedaytwo error duplicate migration version ls migs samedayonedownsql samedayoneupsql Use osOpenFile with OCREATEOEXCL to create files to avoid file collisions This would be very difficult to cause but I can imagine some bogus uses of parallel migrate that would case this to happen in cases someone want to generate hundreds of migrations faster but the script contains bugs for example Use filepath functions to manipulate paths making cleanPath not necessary I see that in the discussion of and the proposed fix for it in f c e fc ec c bb f bb a e aa and theres a lot of string manipulation gymnastics to handle crossplatform path manipulation filepath is the crossplatform solution for this and all its functions should be used when doing real on disk OS specific path manipulation So this PR properly fixes and supersedes Prints generated filenames This can be debatable but popular migration generators active record django etc print the filenames out so the developer knows which file was created Its also convenient to simply copypaste the name of the file to open it for editing Tests The PR updates the migration creation tests but Im not able to run the whole suite because Im on Fedora which ships the kernel with cgroupsv enabled and docker doesnt work with it as of now go test internalcli does work though And I quickly tested the built CLI on a Windows VM I see a commit from Nov to make a copy and move to cmdmigrate does it make sense to remove the cli folder at this point since has been been a year If so I can open a PR Is this possibly a feature which others want to see in here as well The idea is to keep the migration file count small when there will be frequent changes to views functions or bulk data inserts Tracking and undoing migrations in this case would be handled by version control only Here is an example of this concept Hi is there a way to define a Postgres databaseconnection using ident authentication I looked at which suggests using dbnamepostgres hosttmp but this doesnt seem to work with the URL syntax