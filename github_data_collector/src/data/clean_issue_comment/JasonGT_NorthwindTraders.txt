How can I use CQRS in the infrastructure layer when I have to communicate with an external API Im using a wrapper library SpotifyAPINET to simplify calling Spotify API In my Application layer I have ISpotifyService using SystemCollectionsGeneric using SystemThreadingTasks using LDRApplicationCommonModels namespace LDRApplicationCommonInterfaces public interface ISpotifyService TaskArtistsViewModel FindArtistsstring searchQuery TaskArtist GetArtiststring id More commands and queries below The models above are in the Application layer so I can reference them anywhere else And in the Infrastructure layer I implement SpotifyService using System using SystemCollectionsGeneric using SystemLinq using SystemThreadingTasks using LDRApplicationCommonInterfaces using LDRApplicationCommonModels using SpotifyAPIWeb using SpotifyAPIWebAuth using SpotifyAPIWebEnums using SpotifyAPIWebModels namespace LDRInfrastructure public class SpotifyService ISpotifyService private SpotifyWebAPI spotify private Token token private string clientId EnvironmentGetEnvironmentVariableSpotifyClientId private string secretId EnvironmentGetEnvironmentVariableSpotifySecretId public async TaskArtistsViewModel FindArtistsstring searchQuery await Authenticate var results spotifySearchItemsEscapedsearchQuery SearchTypeArtist var artists resultsArtistsItems Selectartist new Artist Name artistName SpotifyId artistId ToHashSet return new ArtistsViewModel Artists artists public async TaskArtist GetArtiststring id await Authenticate var result await spotifyGetArtistAsyncid return new Artist Name resultName SpotifyId resultId Popularity resultPopularity Genres resultGenres private async Task Authenticate If token is not null or is not expired do nothing if token null tokenIsExpired var auth new CredentialsAuthclientId secretId token await authGetToken spotify new SpotifyWebAPI AccessToken tokenAccessToken TokenType tokenTokenType This setup works but Id like to separate the queries similar to how its done with CQRS Mediatr in the app layer The reason being that I have more commands queries I have to implement and I want to add validation to each Id rather not have everything in one class With CQRS style I can inject SpotifyService via DI into my Handlers constructor and use it as shown above The problem comes when I have to reference the CommandHandler inside my controllers Right now trying to do that introduces a dependency on the Infrastructure layer which I want to avoid Perhaps CQRS is not the best approach here but Im after something similar in terms of simplicity and organization Im not sure how else to separate my interface implementation into separate files Hi I saw your video about clean architecture very nice job You mentioned all interfaces should be in Application layer and all entities in Domain layer but I need all my entities inherit form IEntity interfaces eg public interface IEntity in my case its just marker interface What should I do ps Im not here to discuss marker interfaces Why does the Application layer depend on external libraries for example MediatR and FluentValidation Is it Ok This layer contains all application logic It is dependent on the domain layer but has no dependencies on any other layer or project This layer defines interfaces that are implemented by outside layers For example if the application need to access a notification service a new interface would be added to application and an implementation would be created within infrastructure Bumps handlebars from to details summaryChangelogsummary Sourced from handlebarss changelog v November th Bugfixes fix add noprototypebuiltins eslintrule and fix all occurences f f d fix add more properties required to be enumerable Chores Build fix use instead of c b f add chai and dirtychai and sinon for cleaner testassertions and spies deprecate old assertionmethods e e ba dad a Security The properties proto defineGetter defineSetter and lookupGetter have been added to the list of properties that must be enumerable If a property by that name is found and not enumerable on its parent it will silently evaluate to undefined This is done in both the compiled template and the lookuphelper This will prevent new RemoteCodeExecution exploits that have been published recently Compatibility notes Due to the securityfixes The semantics of the templates using proto defineGetter defineSetter and lookupGetter in the respect that those expression now return undefined rather than their actual value from the proto The semantics have not changed in cases where the properties are enumerable as in js proto some string The change may be breaking in that respect but we still only increase the patchversion because the incompatible usecases are not intended undocumented and far less important than fixing RemoteCodeExecution exploits on existing systems Commits v November th Bugfixes fix use Stringfield in lookup when checking for constructor d test add fluent API for testing Handlebars c ac c Compatibility notes no incompatibility are to be expected trtable truncated details details summaryCommitssummary c c b v c d Update release notes f f d fix add noprototypebuiltins eslintrule and fix all occurences fix add more properties required to be enumerable ba testchore add chaiexpect and sinon to runtimeenvironment dad test add sinon as global variable to eslint in the specs a test add sinonjs for spies deprecate current assertions e e chore add chai and dirtychai for better test assertions c b f fix use instead of de d v Additional commits viewable in compare view details br Dependabot compatibility score Dependabot will resolve any conflicts with this PR as long as you dont alter it yourself You can also trigger a rebase manually by commenting dependabot rebase dependabotautomergestart dependabotautomergeend details summaryDependabot commands and optionssummary br You can trigger Dependabot actions by commenting on this PR dependabot rebase will rebase this PR dependabot recreate will recreate this PR overwriting any edits that have been made to it dependabot merge will merge this PR after your CI passes on it dependabot squash and merge will squash and merge this PR after your CI passes on it dependabot cancel merge will cancel a previously requested merge and block automerging dependabot reopen will reopen this PR if it is closed dependabot ignore this patchminormajor version will close this PR and stop Dependabot creating any more for this minormajor version unless you reopen the PR or upgrade to it yourself dependabot ignore this dependency will close this PR and stop Dependabot creating any more for this dependency unless you reopen the PR or upgrade to it yourself dependabot use these labels will set the current labels as the default for future PRs for this repo and language dependabot use these reviewers will set the current reviewers as the default for future PRs for this repo and language dependabot use these assignees will set the current assignees as the default for future PRs for this repo and language dependabot use this milestone will set the current milestone as the default for future PRs for this repo and language You can disable automated security fix PRs for this repo from the Security Alerts page details Inject AUTHBASEURL in the Angular app Add a permissive CORS policy while in development environment Updating the ValueObject tests to use the operator instead of explicitly calling Equals causes them to fail I had originally thought that testing Equals was sufficient but its not I added the following to fix it public static Boolean operator ValueObject left ValueObject right EqualOperatorleft right public static Boolean operator ValueObject left ValueObject right NotEqualOperatorleft right Example implementation as to how one can use NetArchTest to build an anticorruption layer to protect against improper coupling JasonGT Ive recently watched your NDC talk and noticed that you cautioned the audience that the WebUI layer has a reference to Infrastructure for the purpose of DI and if its used outside of the Startupcs hopefully youll pick that up during a code review The unit tests added here provide a mechanism to remove that ambiguity and use tests to validate this type of improper coupling doesnt occur The example included here is relatively simplistic however it could easily be enhanced further I thought it would be wise to implement and discuss it here before attempting to incorporate it anywhere else such as your CleanArchitectureSolutionTemplate project First Thank you for providing such an excellent reference Q How would you make use of database transactions in a mediator handler For example assuming I need a value object for ProductId which needs to be formated with some patterns with business rules I will change the type of ProductId in NorthwindDomainEntitiesProduct from int to ProductId value object How about the Dto and Vm classes used in queries and commands GetProductDetailQuery GetProductsListQuery How about the properties eg Id of GetProductDetailQuery But a request for information on how OidcConfigurationController works in Northwind trader any reference to articles would help have had not much luck finding any any other code snippets or application which use the above would help Kind regards Peter 