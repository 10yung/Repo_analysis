following discussion on discord TypedArray endianness is platform specific Malloc supports loading external arraybuffers that possibly was created used on a device with different endianness For example passing arraybuffer as binary data from server to client None Goal Fix the whole endianness issue for userspace values Possible things to do about it Nothing almost everything is LE Add a header flag that is readable in an endiannessagnostic way to tell on which endianness the pools arraybuffer was created on so we can make sanity check and bail Add static function on the lib to sniff the endianness on a given arraybuffer to use before passing to a new instance of pool let malloc sniff it when providing existing arraybuffer and failtransform the arraybuffer to the appropriate endianness Pros Will allow max heap size of and not only Cons Additional bytes overhead for each allocated block few more constant bytes for the state values Middle ground make it configurable Need to take into account The effect of the pointers on the block alignment Why not BigInt Not supported on many platforms Currently the baseline attribute values used by hdomcanvas remain untranslated when converting to SVG via convertTree Lets figure out a set of valid mappings incl any necessary math if any involving font size If the latter is required we might need a stack to track the currently active font size to support cases where font size is not defined on the text element itself but only defined via parent groupselements References Canvas SVG Hey so on the discord server postspectacular told me about the typesafe versions of paths I took a look and I was not so happy to see this giant mess its actually a lot more but if I make the text even smaller it becomes hard to read this Based on the fact those things are imported from thingapi Im pretty sure other packages contain code like this as well But we can do more Typescript has a pretty neat type system which allows us to write stuff like that without all the repetition Final result Before going into more details heres the final result of the refactor for the code above refactored code And the good thing is this works for any path length Building blocks To be able to achive that I had to write a few basic types Note In case you want to see the actual implementations of the types you can take a look at this typescript playground link Head returns the first element of a tuple ts type HeadTest Head type HeadTest Head never type HeadTest Headnot an array never Tail returns everything except the first element of a tuple ts type TailTest Tail type TailTest Tail type TailTest Tailnot an array never Concat Tried adding an item at the start of a tuple ts type ConcatTest Concat type ConcatTest Concat not an array never Reverse pretty explanatory name reverses the order of elements of a tuple ts type ReverseTest Reverse type ReverseTest Reverse type ReverseTest Reversenot an array never Those are the building blocks for a lot of more complex types Question where should I add these Im thinking of thingapi but Im not sure The actual path stuff Appying the same logic I was able to build a path validator and a path applier which work with any amount of nesting ts interface Nested a b c number type Test ValidatePathNested a b ab type Test ValidatePathNested a d never type Test RetrivePathNested Test c number type Test RetrivePathNested Test never Question Does this seem interesting Should I open a PR making the entire lib use it Note The paths package was just an example this could be applied to a lot of other stuff So lets discuss it What do yall think of this method of typing Should I open PRs with it Most transducers take a source sequence as a final argument Since strings are iterable so you can do this javascript txfilterx true abc abc However if you provide an empty string they will crash javascript txfilterx true TypeError txfilter is not iterable This is obviously because the transducer functions do a truthiness test on their final argument to determine whether a source was provided typescript export function mapA Bfn FnA B TransducerA B export function mapA Bfn FnA B src IterableA IterableIteratorB export function mapA Bfn FnA B src IterableA any return src iterator mapfn src rfn Reducerany B const r rfn return compRrfn acc x A racc fnx This could be corrected by replacing src with isIterablesrc using thingchecks This would incur the additional work of looking up Symboliterator but it would seem to be more correct I cant think of a case where this would be a breaking change ie values for src that work now but are not iterable by that test postspectacular Im willing to PR if you think this is actionable I understand theres a lot of branch work going on so whatever you think best A workaround for the time being is to wrap the string argument in s Similar blocks of code found in locations Consider refactoring Similar blocks of code found in locations Consider refactoring Similar blocks of code found in locations Consider refactoring This temporary documentation repo is meant for testing out the new doc toolchain to provide better crosspackage navigation and a hopefully generally improved experience This doc repo consist of over markdown files and I cannot check them all myself for issues of which there are still many So this issue here is used to collect a list of linkspages exhibiting serious formatting problems If you come across any eye sores please do paste the offending URL as comment and optionally if needed with a brief description Thanks vmuch in advance Hi postspectacular Im smashing my head against this and Im sure theres a simple explanation or Im just doing something dumb but In your hiccupmarkdown example Im trying to recreate it but when I try to use a file string read via fsreadFileSync call with utf encoding the result is an empty rather than a hiccup tree js const blog readFileSyncassetsblogmd utf consolelog iteratorparse blog It works perfectly both in console and rendered in hiccup within hdom start if the string is stored as a standard varletconst but not when I try to load it in as a file I cant figure out what Im doing wrong When I printlogreturn the variable wherein I store the result of readFileSync the markdown is printed I just cant figure out why the iterator isnt parsing it Why Im trying to figure out how best to script this up so that I can dynamically load static markdown files eg from assets as plain strings that can be used by iterator I also tried to use your Parcel setup js scripts is this global md where the magic happens buildparser yarn clean parcel build srcparserts d out global md publicurl nosourcemaps nocache experimentalscopehoisting detailedreport experimentalscopehoisting but I noticed you gitignored the js files Im stuck Two questions is there a better way than using readFile from node with Parcel to turn the file string into an iterable that can be consumed by iterator Should I forgo HDOMs start in favor of transducershdom I recall you mentioning you prefer using streams rather than RAFinterceptors It would help me if you have some guidance as what the proscons are for the various approaches 