I dont see the documentation The book link is broke Id like to explore the possibility of having a web framework support both HTTP and CoAP How suitable would Blueeyes be to support an extension that handles both CoAP and HTTP requests and responses for the same resources My idea would be to use Californium as the CoAP implementation Even though its written in Java Californium should be mostly friendly toward being wrapped in a functional style except for its pervasive use of mutable data CoAP is a RESTful protocol that mirrors a lot of the functionality of HTTP but as a compact binary protocol suitable for embedded devices It runs over UDP but the Californium implementation takes care of ACKs and resending messages The biggest incompatibility is the fact that there arent any custom CoAP headers and many of the normal HTTP headers dont have a CoAP analogy Id like to pursue this but I want to know your thoughts Would this be difficult Is blueeyes a suitable choice for this This is a slightly dodgy change but otherwise we break backwards API compatibility for clients of blueeyes services which is dodgier Eliminating a potential source of error due to use DefaultBijections The async parser was built to handle streams of many small JSON values It does poorly on very large json files containing one value for instance an array This could be improved by storing partial parse results but would require some serious thought When trying to develop a Specs v SNAPSHOT test using SNAPSHOT running the test fails with a strange class loading error This version of specs is the only one available for Scala When I downgrade to Scala and Specs v which is the version mentioned in blueeyescorebuildsbt in the x branch of the git repo the problem disappears I suspect this is because blueeyes is built against Specs and so causes some compatibility problems with the newer versions of Specs which are the only ones available for later versions of Scala If provided with a ContentType header with a value of applicationjsonstream blueeyes silently ignores the stream part of the header and simply returns applicationjson rather than a custom MimeType instance The process of decoding and reencoding the querystring does not correctly handle encoded occurrences of and and leaves them unencoded in the resulting URI For example clientgetfoobarbaz Dqux quux will result in the client making this request GET foobarbazqux quux HTTP It should be this GET foobarbaz Dqux quux HTTP 