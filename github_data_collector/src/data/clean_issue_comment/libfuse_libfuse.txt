Add meson option initscriptsdir to explicitly define location of system initialization scripts initscriptsdir is etcinitd by default Option usage meson prefixusrlocal Dinitscriptsdircustominitd libfusesrcdir builddir DESTDIRPWDinstalldir ninja C builddir As a result init script will be installed into PWDinstalldircustominitd location Fixes fuse init script was always installing to etc directory even if prefix variable is defined Now it is installing to sysconfdir directory Also updatercd was running even if using root permissins was explicitly disabled via useroot definition Fixes How to reproduce git clone meson prefixPWDprefix Duserootfalse DudevrulesdirPWDprefixlibudevrulesd libfuse build ninja C build install Installing homeubuntulibfusedocmountfuse to homeubuntuprefixsharemanman Installing homeubuntubuildmesonprivatefuse pc to homeubuntuprefixlibx linuxgnupkgconfig Running custom install script homeubuntulibfuseutilinstallhelpersh homeubuntuprefixetc homeubuntuprefixbin homeubuntuprefixlibudevrulesd false install cannot create regular file etcinitdfuse Permission denied Failed to run install script homeubuntulibfuseutilinstallhelpersh homeubuntuprefixetc homeubuntuprefixbin homeubuntuprefixlibudevrulesd false FAILED mesoninstall Problem installhelpersh is trying to install utilinitscript into etcinitdfuse even if prefix is specified It is possible to solve problem by adding DESTDIR environment variable but the installation of initdfuse becomes inconsitent with the installation of other configuration files All other configuration files are installing into sysconfdir directory and according to GNU coding standarts I assume that initdfuse is also should do this In a bunch of comments we say under the terms of the GNU GPL make it clear this is GPLv as LICENSE says Signedoffby Dr David Alan Gilbert dgilbertredhatcom I am encountering a failed test It seems to occur in the testpassthroughhp function venv algrebenode downloadslibfusebuild lsbrelease a No LSB modules are available Distributor ID Ubuntu Description Ubuntu LTS Release Codename bionic Im using the linux kernel no modifications built from source venv algrebenode downloadslibfusebuild uname r venv algrebenode downloadslibfusebuild python m pytest testtestexamplespytestpassthroughhp test session starts platform linux Python pytest py pluggy usersalgrebedownloadsminiconda envsvenvbinpython cachedir pytestcache rootdir usersalgrebedownloadslibfusebuildtest inifile pytestini collected items testtestexamplespytestpassthroughhp False PASSED testtestexamplespytestpassthroughhp True FAILED FAILURES testpassthroughhp True Traceback most recent call last File usersalgrebedownloadslibfusebuildtesttestexamplespy line in testpassthroughhp tstrmdirsrcdir mntdir File usersalgrebedownloadslibfusebuildtesttestexamplespy line in tstrmdir assert name in oslistdirmntdir AssertionError assert testfile in testfile testfile testfile testfile testfile testfile where testfile testfile testfile testfile testfile testfile builtin function listdirtmptmpftk dmnt where builtin function listdir oslistdir Captured stdout call warnings summary usersalgrebedownloadsminiconda envsvenvlibpython sitepackagespytestmarkstructurespy usersalgrebedownloadsminiconda envsvenvlibpython sitepackagespytestmarkstructurespy PytestUnknownMarkWarning Unknown pytestmarkusesfuse is this a typo You can register custom marks to avoid this warning for details see warningswarn Docs short test summary info FAILED testtestexamplespytestpassthroughhp True AssertionError assert testfile in testfile testfile testfile testfile testfile testfile stopping after failures failed passed warning in s venv algrebenode downloadslibfusebuild tstrmdir succeeds for passthroughhp tmptmprtpqz ttsrc tmptmprtpqz ttmnt nocache but not for passthroughhp tmptmpr vz sy src tmptmpr vz sy mnt Looking at passthroughhpcc the comment says we shouldnt be modifying the src directory and expect changes in the mnt directory immediately However the tstrmdir function does exactly that It makes a directory from the src and lists the directory from the mnt immediately after The cache returns the older value and the assert fails This isnt just limited to tstrmdir though I modified the cache timeout from a day to seconds and slept for seconds in the function It then failed in tstunlink Changing the parameters to just False also works but Im assuming we want to test the cached mode too Id like to start working on a fix for this but would like some guidance Would making modifications file creation deletion through the mnt rather than src be a viable solution However we would need this only for the cached mode when testing testpassthroughhp Starting from it became possible to implement FUSE filesystems with pipesocketlike files For this a filesystem server should set fileinfononseekable and the kernel will correspondingly use FMODENONSEEKABLE for opened file handle See commit cafdcb e c If open sets finonseekable libfuse will tell the kernel that the file is not seekable which added nonseekable support to libfuse Unfortunately in a kernel regression was introduced all file IO switched to be done under lock filefposlock with the idea that file position changes should be atomic However for streamlike files that were using nonseekable open it created possibility of deadlock in between read and write file read could be waiting for data from filesystem server filesystem server is generating data in reply to client write to that file write to that file is waiting for fposlock taken by read deadlock Unfortunately now the regression is not possible to fix on just kernel side because a it is already years after and b there are existing FUSE filesystems that use nonseekable open and position for corresponding file In other words because of backward compatibility today we cannot change the kernel to avoid taking fposlock and not to pass file position for filesystem server for nonseekable FUSE file handles The solution to the deadlock problem that is already merged to Linux kernel is to introduce new FUSE open flag FOPENSTREAM that is explicitly marking file handle as not having position at all and thus for such file handle the kernel will avoid taking fposlock gitkernelorglinus dce af gitkernelorglinusbbd f f When implementing streamlike files filesystem servers should be using both FOPENNONSEEKABLE and FOPENSTREAM on kernels released before since inkernel FUSE client ignores unknown FOPEN flags this will continue to work ok as before on kernels with FOPENSTREAM support this will avoid readwrite deadlock on kernels released after but without FOPENSTREAM support the deadlock will be there but using FOPENSTREAM does not make the situation worse FOPENSTREAM was merged into Linux see commits and was backported to all longterm stable Linux kernel versions that are taking their roots after kernel regression point Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv g bb a f ed Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv gfea caf Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv g f b c Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv gcfd d e Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv gc a f e Linux Linux gitkernelorgpubscmlinuxkernelgitstablelinuxgitcommitidv g d f d d f Note we cannot change libfuse to use use both FOPENNONSEEKABLE and FOPENSTREAM on just fileinfononseekable for the same backward compatibility reason why we cannot change the kernel to avoid using file position for nonseekable opens see again Thus lets introduce new flag fileinfostream and let filesystems that implement streamlike files set both fileinfostream and fileinfononseekableopen Even though examplepollc implements only read Ive changed that example to use fileinfostream too because file implemented there does not use file position at all and because that example is kind of canonical on how to implement pipelike files with libfuse Since this patch is trying to fix regression introduced in it should be applied to all libfuse branches covering time after that moment master current x development fuse bugfix fuse bugfix fuse bugfix cc Nikratio szmi gitkernelorglinus c f e eg gvfs see passthroughlls FUSEREADDIR implementation saves the last offset of a DIR object when it returns Subsequent calls check the provided offset and seekdir to if its different than the saved offset However thats not a valid use of seekdir seekdirs argument must be something that was previously returned by telldir The offset provided in the FUSEREADDIR command is a file offset something that should be used with lseek The impact of this bug is that readdir operations can skip entries Heres the general order of events user program calls readdir libc calls getdirentries on FreeBSD or getdents on Linux using a buffer of size X Kernel calls FUSEOPENDIR and FUSEREADDIR passthroughll calls readdir on the underlying file system libc calls getdirentries or getdents with a buffer of size Y on the underlying file system passthroughll returns to the kernel kernel fills up the user programs buffer but runs out of space before it adds all entries libc saves the actual offset of the last dirent structure user progam calls readdir again libc calls getdirentries or getdents using the saved offset Kernel calls FUSEREADDIR using the saved offset passthroughll sees that the provided offset is different than the saved one and calls seekdir seekdir does nothing at all since the offset was not previously returned by telldir passthroughll calls readdir on the underlying filesystem resuming where it left off previously The directory entries that didnt fit within the users first buffer are therefore lost At first glance it seems that there shouldnt be a problem because X Y However the problem arises because the structure used by getdirentries is different than the structure used by the FUSE protocol FUSEs fusedirent is not nulterminated but getdirentriess struct dirent and getdents s struct linuxdirent are Still the problem doesnt arise on Linux because struct linuxdirent is smaller than struct fusedirent Heres a chart summarizing the structure sizes for a name of length n OS struct size FreeBSD dirent n Linux linuxdirent n FUSE fusedirent n The solution is for passthroughll to use getdirentries and lseek directly instead of readdir and seekdir From I found that when building libfuse as a static library meson configure defaultlibrary static I invariably hit errors like this when trying to use it libtool link gcc shared fPIC DPIC libsprojfso libsprojfsvfsapio lfuse ldl lpthread g O Wlsoname Wllibprojfsso Wlversionscript Wllibslibprojfsver o libslibprojfsso usrbinld libslibprojfsso version node not found for symbol fuseloopmtFUSE usrbinld failed to set dynamic section sizes Bad value collect error ld returned exit status This is without adjusting the calling code at all Indeed even if I drop all calls to fuseloopmt in the calling code this still happens so I guess some versioning weirdness left inside libfusea is producing this when linking The void arg argument is not mentioned in the function description testexamplespytestpassthrough relies upon magic number parameter to skip or possibly select by omit the minus eg a particular test which happens to be the nd test in a long list of tests and relies upon a counter found in testtestsyscallsc testexamplespytestpassthrough if writeback When writeback caching is enabled kernel has to open files for reading even when userspace opens with OWDONLY This fails if the filesystem process doesnt have special permission syscalltestcmdappend A Macro helper in testsyscallsc is used to skip or select the test like this define starttestmsg args if selecttest testnum selecttest testnum skiptest testnum return starttestmsg args Logic is fatally flawed due to preprocessor defines possibly changing the number of tests performed testsyscallsc ifndef FreeBSD err testmknod err testmkfifo endif or if user is root testsyscallsc ifisroot err testopenaccORDONLY OTRUNC EACCES err testopenaccOWRONLY EACCES err testopenaccORDWR EACCES err testopenaccORDONLY EACCES err testopenaccORDWR EACCES err testopenaccORDONLY EACCES err testopenaccOWRONLY EACCES err testopenaccORDWR EACCES both of which occur in the middle of the list of tests This implies that the test script know compile options used in order to determine which test should be skipped Magic number should be removed from testexamplespy Test skippingselecting logic should be removed and test script should be rewritten to identify which tests may be called depending upon platform or user or rewritten to skip tests by name instead of number 