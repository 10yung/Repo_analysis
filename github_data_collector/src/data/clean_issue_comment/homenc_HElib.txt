The build fails on FreeBSD Nayna Jain Linuxx If my understanding is right CKKS scheme replaces bootstrapping with rescaling And the idea of rescaling is that we cannot predict value of L perfectly at the start itself In such case if at runtime L seems to be not sufficient we can try to rescale However I couldnt find any example on how to do rescale what function to call and what value is the recommended one Can someone help with this please Thanks Regards Nayna There are overflows of the LONG variable belowLVL Furhtermore if no ciphertext is below the level the function fails as well Implemented Binary Squaring It improves the performance of the operation in comparison with multiplication and it reduces the used capacity by one ciphertext multiplication depth Your Contact Your environment OSHWubuntu Detailed DescriptionAfter compiling helib I dont know how to run the program in the examples Execute cmake in BGVgeneralexample and display CMake Error at CMakeListstxt findpackage By not providing Findhelibcmake in CMAKEMODULEPATH this project has asked CMake to find a package configuration file provided by helib but CMake did not find one Could not find a package configuration file provided by helib requested version with any of the following names helibConfigcmake helibconfigcmake Add the installation prefix of helib to CMAKEPREFIXPATH or set helibDIR to a directory containing one of the above files If helib provides a separate development package or SDK be sure it has been installed Configuring incomplete errors occurred Thank you Your Contact Your environment OSHW ubuntu on VirtualBox Detailed Description Hi Im new to HElib I copied helibexamplecpp in example folder to src folder and successfully compiled it with make helibexamplex in src folder Then I copied the files in srcaes folder to src folder and compiled it with make TestAESx But I got the following error homAEScpp In constructor HomAESHomAESconst FHEcontext homAEScpp error no matching function for call to EncryptedArrayDerivedPAGF EncryptedArrayDerivedconst FHEcontext const NTLGF X const PAlgebraMod DoubleCRT ESHomAESconst FHEcontext contextea contextaesPolycontextalModaffVec Do I run this example in a wrong way Thanks Your Contact Flavio Your environment OSHW Detailed Description Create a INSTALLExperiemntalmd file to capture install instructions for the OSHW that are not part of the standard build test process mihaken gmailcom Your environment OSHW OS ubuntu Hello I am new to HElib and sorry if I am missing very basic of implementation in HELib I would like to basically set coefficient on plaintext polynomial and take an inner product by Forward Backward packing As is done in method in I put my entire code below which I am trying to work on so please take a look description is as follows If let u and u be encryptedarray u x u x x x under m found to be by findM method in HElib then if I multiply u and u I expected u u u x so u however I got instead u This means Ring is set as Z x x x instead of Z x x Is there any way to set the ring as Z x x instead of Z x x x or should I dive into NTL library for this If you could any comment or suggestion I would appreciate it Thank you in advance Sincerely to HElib developpers include iostream include cstddef include tuple include systimeh include FHEh include EncryptedArrayh include NTLZZXh include NTLZZh include vector using namespace std using namespace NTL int main Encryption Parameters Finding m Found m in this setting is mapped to is is etc long p Plaintext base default should be a prime number long r L long L long c Number of columns in keyswitching matrix default long w Hamming weight of secret key long d Degree of the field extension default long k Security parameter default long s cout Finding m flush long m FindMk L c p d s cout Found m m endl cout Initializing context stdflush FHEcontext context new FHEcontextmpr Initialize context buildModChaincontext L c Modify the context adding primes to the modulus chain cout OK endl cout Generating keys flush FHESecKey sk new FHESecKeycontext FHEPubKey pk sk skGenSecKeyw Actually generate a secret key with Hamming weight addSome DMatricessk Extra information for relinearization cout OK endl Prepare encrypted array for FB packing number of slots Get the number of slot phim const EncryptedArray ea contextea long nslots easize stdcout Number of slots nslots stdendl ZZX u u u SetLengthnslots u SetLengthnslots cout something endl Set coefficient of plaintext polynomial for example u x u x x x so basically we want when we multiply u and u u u x then I can use hayashi special however actually this gives me u u x x this means HELib uses the ring which is Z x x x instead of Z x x do you have any opinion or comment on this SetCoeffu SetCoeffu SetCoeffu nslots cout u endl cout u endl Ctxt c pk Ctxt c pk pkEncryptc u pkEncryptc u cout endl cout endl cout c and c before multiplication endl ZZX dec dec dec skDecryptdec c skDecryptdec c dec dec so we want u u however we instead get u u cout dec endl cout dec endl cout endl cout endl cout c and c after multiplication endl c c skDecryptdec c cout dec endl Hi I have noticed that the sample test which demonstrated applying the same or different transformations to slots has been removed in newer versions of HElib although the key functions still remain applyLinPoly applyLinPolyMany I am wondering is there now some more efficient way of applying transformations to slots to explain removal of this important demonstration Thank you Hi i am confused about bootstrping In Testbootstrpingcpp it choose the first set of parameters smallest m The result is good but Securty level So i choose latter set of parameters to make Securty level However the result is far from good Could someone tell me how to make bootstrpe working THX 