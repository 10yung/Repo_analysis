I would like to propose the following WIP roadmap of changes for a future release Code Nonbreaking Autogenerate unit tests benchmarks Efficient randomized initializers for ArrayVectorMatrix Efficient nonallocating columnrowbased Matrix iterators Potentially Breaking Migrate from FloatDouble to T FloatingPoint Breaking Migrate API to a more idiomatic naming scheme DeprecationRemoval of sqrt variant with custom output storage Operation Service Integrations Add CodeCov integration free for open source Add CodeClimate integration free for open source Bookkeeping Add CHANGESmd file Add CONTRIBUTINGmd file Add githubPULLREQUESTTEMPLATEmd githubISSUETEMPLATEmd file This is a meta issue intended for coordination and tracking of a release For technical discussions of specific proposals please use the corresponding issue page Edit Oct th Added Operation section for noncode tasks tldr Surges API naming scheme does not quite follow Swifts API Design Guidelines We might want to fix that What Swift and its stdlib have gone through several major changes since its initial release in Surges initial commit was shortly after on Aug The most notable change probably was the migration to the then new and more idiomatic naming scheme with Swift SE which resulted in the API Design Guidelines The most relevant part of them being Name functions and methods according to their sideeffects Those without sideeffects should read as noun phrases eg xdistanceto y isuccessor Those with sideeffects should read as imperative verb phrases eg printx xsort xappendy Name Mutatingnonmutating method pairs consistently A mutating method will often have a nonmutating variant with similar semantics but that returns a new value rather than updating an instance inplace When the operation is naturally described by a verb use the verb s imperative for the mutating method and apply the ed or ing suffix to name its nonmutating counterpart Mutating Nonmutating xsort z xsorted xappendy z xappendingy When the operation is naturally described by a noun use the noun for the nonmutating method and apply the form prefix to name its mutating counterpart Nonmutating Mutating x yunionz yformUnionz j csuccessori cformSuccessor i Why As mattt and I discussed in more depth in the current naming scheme of our public as well as internal API does not quite fit the idiomatic naming scheme as established with Swift Surge in its current state has the following naming scheme Mutating Nonmutating addInPlace a b z adda b Note For the sake of simplicity I will refer to T UnsafeMutableMemoryAccessible as simply Scalar for the remainder of this writing Surge contains APIs for working with lowlevel scalarbuffers Scalar as well as APIs for working with highlevel vectors VectorScalar and matrices MatrixScalar While both APIs are related by the fact of the latter being implemented in terms of the former from a users perspective they can be considered mostly unrelated ie it is unlikely that an expression will contain both a Scalar and a MatrixScalar A major release gives us the unique opportunity to make codebreaking changes How As such I would argue that both APIs can and possibly should be dealt with individually given their different constraints Scalar due to dealing with generic collection types public functions can end up polluting the global namespace adding needless noise to autocompletion and ambiguity eg Array already uses for concatenation forcing Surge to use instead etc VectorScalarMatrixScalar due to being tied to concrete and Surgeowned types there is no or at least less risk of namespace pollution nor ambiguity As mentioned earlier both APIs also differ in abstractness As such I would like to propose the following options going forward Option A Keep all of Surges API as free functions Change functions naming scheme Nonmutating Mutating Idiomatic Before z adda b addInPlace a b NO After z addinga b add a b YES Pro A semiidiomatic API for Scalar VectorScalarMatrixScalar By using available renamed Xcode would be able to provide a reasonably effortlessautomated migration path with easy fixits Contra Free functions dont quite feel at home with Swifts dominating OOP syntax Option B Keep Surges Scalar API as free functions changing their naming scheme to Nonmutating Mutating Idiomatic Before z adda b addInPlace a b NO After z addinga b add a b YES Turn Surges VectorScalarMatrixScalar APIs into OOP methods changing their naming scheme to Nonmutating Mutating Idiomatic Before z adda b addInPlace a b NO After z aaddingb aaddb YES Pro A semiidiomatic API for Scalar By using available renamed Xcode would be able to provide a reasonably effortlessautomated migration path for Scalar API changes with easy fixits A fully idiomatic API for VectorScalarMatrixScalar following the API Design Guidelines Contra Scalar and VectorScalarMatrixScalar would have different syntax However as mentioned earlier it is quite common to have lowlevel APIs use Cstyle free functions and highlevel APIs use OOP patterns ie methods Also both APIs as unlikely to get mixed as VectorScalarMatrixScalar generally work with instances of VectorScalar not Scalar It seems like available renamed does not provide Xcode fixits for changing an nary free function call into an n ary method call on the first argument We might want to ask the Swift Standard Library team for a recommendation here Deprecation vs Removal We would also have to decide whether we wanted to mark renamed functions as deprecated or go straight to unavailable tldr Surge currently provides separate implementations for each function for Float and Double respectively This makes Surge basically incompatible with Swifts T FloatingPoint generics By introducing a little bit of internal runtime dynamism we aim to migrate existing function pairs to their generic equivalent for T FloatingPoint What With the recent refactors we have managed to reduce the implementations of each computation into a function set consisting of a single internal coreimplementation acting as a single source of truth and a bunch of thin public convenience wrapper functions ScalarDivision Scalar Scalar is implemented like this swift public func Llhs L rhs Float Float where L UnsafeMemoryAccessible LElement Float return divlhs rhs public func divL lhs L rhs Float Float where L UnsafeMemoryAccessible LElement Float return withArrayfrom lhs divInPlace rhs func divInPlaceL lhs inout L rhs Float where L UnsafeMutableMemoryAccessible LElement Float lhswithUnsafeMutableMemory lm in var scalar rhs vDSPvsdivlmpointer numericCastlmstride scalar lmpointer numericCastlmstride numericCastlmcount with an almost identical copy existing for each of these functions for Double instead of Float Why While the projects current state is quite an improvement over its previous state it has a couple of remaining deficits We have literally everything in two nearidentical flavors Float and Double One cannot currently use Surge in contexts where one is using T FloatingPoint over FloatDouble So this got me thinking What if we migrated Surge from using FloatDouble to an API with T FloatingPoint and then internally make use of some dynamic language features to roll our own polymorphism over the closed set of Float and Double with a fatalError on typemismatch Aforementioned dynamism would add a certain amount of runtime overhead to Surge It is important to note however that we would be adding a constant overhead O vs ON as a single call of SurgedivInPlace over a pair of element arrays only adds a single branch per execution not branches in a loop as would be the case for a na ve nonparallel looping implementation How So how would this look like What would we need to change We would replace every existing pair of thin public wrapper functions for FloatDouble with a single equivalent function that is generic over T FloatingPoint instead We would merge every existing pair of internal InPlace coreimplementation functions for FloatDouble into a single equivalent function that is generic over T FloatingPoint on the outside and then performs a switch on Tself on the inside instead We would add func withMemoryReboundto to UnsafeMemoryT and UnsafeMutableMemoryT so that we can efficiently cast from UnsafeMemoryT FloatingPoint to UnsafeMemoryDouble without having to copycast any individual values We would add func withUnsafeMemoryas convenience functions for retrieving typecast variants of UnsafeMemoryT from instances of UnsafeMemoryAccessibleUnsafeMutableMemoryAccessible We would refactor the func InPlace implementations into something like this swift func divInPlaceL T lhs inout L rhs T where L UnsafeMutableMemoryAccessible LElement T T FloatingPoint ExpressibleByFloatLiteral let rhs CollectionOfOnerhs withUnsafeMemory lhs rhs float lhs rhs in vDSPvsdivlhspointer numericCastlhsstride rhspointer lhspointer numericCastlhsstride numericCastlhscount double lhs rhs in vDSPvsdivDlhspointer numericCastlhsstride rhspointer lhspointer numericCastlhsstride numericCastlhscount So far I have not been able to measure any noticeable performance regressions introduced by this change There also should be very little breakage from the changes as T FloatingPoint is for the most part a strict superset of either Float or Double I already have a proofofconcept for this on a local branch and will push it as a PR at some point tldr Weve gone way past the point where writingmaintaining highly redundant manual unit tests is any fun If writing unit tests becomes tedious and a maintenance hell people start neglecting them instead Lets thus make use of the fact that our APIs and such the tests almost all follow the pattern and automatically generate the tests for us allowing us to increase test coverage even more at actually far less overall cost What A quick look at the Tests reveals a suite of tests that all pretty much share the same pattern Our tests look something like this swift func testsomethingfloat Define a typealias for convenience typealias Scalar Float Create some dummy data let lhs Scalar monotonicNormalized let rhs Scalar monotonicNormalized Create a working copy of the dummy data var actual Scalar lhs Operate on the working copy SurgeeladdInPlace actual rhs Provide a groundtruth implementation to compare against let expected ziplhs rhsmap Compare the result XCTAssertEqualactual expected accuracy e only differentiating each other by a change in this line swift SurgeeladdInPlace actual rhs and this line swift let expected ziplhs rhsmap And our benchmarks look something like this swift benchmarks func testaddinplacearrayarrayfloat Call convenience function measureinoutarrayarrayof Floatself measure in Call XCTests measurement method measureMetrics wallClockTime automaticallyStartMeasuring false Perform the actual operations to be measured measureSurgeeladdInPlace which is semantically equivalent to the more verbose swift func testaddinplacearrayarrayfloat typealias Scalar T let lhs produceLhs let rhs produceRhs Call XCTests measurement method measureMetrics wallClockTime automaticallyStartMeasuring false var lhs lhs startMeasuring let SurgeeladdInPlace lhs rhs stopMeasuring again only differentiating each other by a change in this line swift let SurgeeladdInPlace actual rhs Why At now shy over tests and over benchmarks maintenance of our testsbenchmarks suites has become quite a chore So this got me thinking What if what if instead of writing and maintaining hundreds of highly redundant tests functions for a lack of macros in Swift we had a way to have the tests and even benchmarks generated automagically for us With this we could easily increase test coverage from just the functions containing nontrivial logic to basically every public function regardless of complexity allowing us to catch regressions for even the mosttrivial wrapper function currently not covered at hardly any additional maintenance burden How The basic idea is to get rid of all the existing unit tests and replace them with mere Sourcery annotations like this swift sourcery test floatAccuracy e expected addarrayarray public func addL R lhs L rhs R Float where L UnsafeMemoryAccessible R UnsafeMemoryAccessible LElement Float RElement Float given a fixture like this swift enum Fixture enum Argument func defaultScalar Scalar func defaultScalar Scalar func defaultScalar VectorScalar func defaultScalar MatrixScalar enum Accuracy func default Float func default Double enum Expected extension FixtureExpected func addScalararray lhs Scalar array rhs Scalar Scalar return ziplhs rhsmap Function Annotation Description test Generate test function Optional bench Generate benchmark function Optional expected function name The fixture function to use as groundtruth Required by test accuracy float literal A custom testing accuracy Optional used by test floatAccuracy float literal A custom Floatspecific testing accuracy Optional used by test doubleAccuracy float literal A custom Doublespecific testing accuracy Optional used by test argN function name The fixture factory function for the nth argument Optional used by test One would have Sourcery parse the ource code and generate a test suite per source file or type extension preferably looking for test and bench annotations The current unit tests make use of minimal customization of lhsrhs dummy values so argN will rarely find use but a few tests need custom data to test against Also given that Surge has a rather restricted set of types that are to be expected as function arguments we should be able to match against them Scalar Collection where Element Scalar VectorScalar MatrixScalar rather na vely allowing us to elide most data we would otherwise have to specify explicitly Currently MatrixScalar is rather opaque when in comes to accessing its contents A common access pattern of matrices is to iterate over them by either column or row order Being a performance framework however we would rather not have the lowestlevel matrix iterators allocate any temporary memory as would be necessary for columnwise iteration given that ArraySliceScalar does not allow for providing a stride I already have a proofofconcept for this on a local branch and will push it as a PR at some point tldr A pair of functions seems to have been marked as public at some point in the past that should have remained internal and have since been obsoleted We should remove them from the public API What Surge contains a somewhat odd function for calculating sqrt by providing a custom output buffer swift Elemenwise square root with custom output storage Warning does not support memory stride assumes stride is public func sqrtMI UnsafeMemoryAccessible MO UnsafeMutableMemoryAccessible lhs MI into results inout MO where MIElement Float MOElement Float return lhswithUnsafeMemory lhsMemory in resultswithUnsafeMutableMemory rm in preconditionlhsMemorystride rmstride sqrt doesnt support step values other than preconditionrmcount lhsMemorycount results doesnt have enough capacity to store the results vvsqrtfrmpointer lhsMemorypointer numericCastlhsMemorycount Source Why This pattern is nowhere else to be found in the framework and it looks to me like it was intended primarily for internal use as a baseimplementation of the noncustom variant and possibly marked as public by accident swift Elemenwise square root Warning does not support memory stride assumes stride is public func sqrtC UnsafeMemoryAccessible lhs C Double where CElement Double var results Double repeating count numericCastlhscount sqrtlhs into results return results Source The method in question was added in this commit How As such Id like to nominate both variants Float Double of this function for deprecation with the next minor release with removal on next major release What do you guys think mattt alejandroisaza Update with merged we now have a proper sqrtInPlace function for efficient nonallocating computation of sqrt swift func sqrtInPlaceC UnsafeMutableMemoryAccessible lhs inout C where CElement Float var elementCount Int numericCastlhscount lhswithUnsafeMutableMemory lm in preconditionlmstride function doesnt support step values other than vvsqrtflmpointer lmpointer elementCount Source Any plans for implementing ShortTime Fourier transform Im currently evaluating several FFT implementations and I tried out your implementation of the vDSP algorithm collection After some reading therere two things I dont fully understand and I hope you might help us out here Is there a reason youre not using vDSPfftzrip vDSPfftzripD I understand that your implementation works with real input vectors So whats the benefit of not using the packed implementation with the r in the middle of the function name The packed implementation needs some additional packing unpacking but thats it Im specifically referring to the statement in The little r somewhere in the middle of the function name is what designates it as the special fft designed to work with the packed up array vDSPfftzipD with no r is the complex version and is easier to use because there are no packing and unpacking steps but not as efficient beautiful or clever Certainly your implementation works but it seems using the different method it should run faster or at least more efficient On that note its worth exploring the inplace variants of the methods as well Your implementation calculates the normalized magnitudes of all input values But from my understanding of the so called conjugate symmetric fft half of the result could be discarded anyhow for real input values I am attempting to plot a periodogram in Swift of a signal using Surge Code var fftmat SurgepowSurgefftsignal var constmult Doublesignalcount for var i in fftmatcount multiply fftmat by constmult fftmat i Floatconstmult fftmat i var pgram fftmat Plotting pgram yields the following results iosperiodogram However after loading and creating the exact same periodogram in Python I get a very different periodogram Code pgram lensignal numpypowernumpyfftfftsignal purenumpyperiodogram Since I am using the exact same method to plot the periodogram and the same data as well I was wondering if there are some differences in the implementation of the Surge fft and numpy fft which might cause this issue do you plan support vDSPDCTExecute