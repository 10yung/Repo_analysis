This resolves by tracking mappings of superclass type vars to their materialized types in subclasses This is tested with some pathologically complex examples so hope its sturdy Other small bits This exposes an awkward case where type inference cant be relied upon at construction We could try to figure this out but the overhead of determining that at build time outweighs the cost of just being pedantic here so this effectively reverts Opportunistic suppression of RedundantExplicitType in known suppressions Kotlinreflect has been a longstanding thorn for KotlinJsonAdapter for a number of reasons It has a huge impact on binary size both in terms of the library and the compiler impact When removing it from the slack code base recently it saved us nearly k methods just by removing it even though only were used Its super slow and heavyweight It has a number of tricky proguard considerations This PR replaces kotlinreflect entirely with kotlinxmetadatareflect the lowlevel metadata library we use in code gen via kotlinpoetmetadata Its also what the kotlinxreflectlite project is in the process of being migrated to and used in a number of other major toolchains now Dagger R etc Effectively this skips past kotlinxreflectlite and replaces kotlinreflect with something closer to an ultralight setup set up specific to Moshis needs Its a significant change to the adapter but the core logic remains the same with one notable exception documented at the end This supersedes but effectively resolves in spirit Stats Quick androidxbenchmark on my serialization benchmarks project shows this is faster for buffer reads as well AndroidBenchmarkmoshikotlincodegenbuffertoJson minifiedtrue ns AndroidBenchmarkmoshikotlincodegenstringtoJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivemetadatabuffertoJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivebuffertoJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivestringtoJson minifiedtrue ns AndroidBenchmarkmoshikotlincodegenbufferfromJson minifiedtrue ns AndroidBenchmarkmoshikotlincodegenstringfromJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivemetadatabufferfromJson minifiedtrue ns AndroidBenchmarkmoshikotlincodegenbufferfromJson minifiedfalse ns AndroidBenchmarkmoshikotlinreflectivebufferfromJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivemetadatabufferfromJson minifiedfalse ns AndroidBenchmarkmoshikotlincodegenstringfromJson minifiedfalse ns AndroidBenchmarkmoshikotlinreflectivestringfromJson minifiedtrue ns AndroidBenchmarkmoshikotlinreflectivebufferfromJson minifiedfalse ns AndroidBenchmarkmoshikotlinreflectivestringfromJson minifiedfalse ns Two open questions The behavior change is that moshikotlin still allowed extending from and encoding nonkotlin superclasses and their properties I think this was an oversight when we stopped supporting mixing them in Moshi as this doesnt match the behavior of code gen What are the appropriate proguard rules for this Resolves Definitely open to feedback This wasnt actually running reflection before because the reflection adapter will use generated adapters anyway if available Ive added an overload that allows controlling this behavior default is enabled as Im not sure how else to set this up This also makes an opportunistic optimization to defer checking for generated classes until just before the ClassJsonAdapter as it avoids unnecessary reflection checks before other nongeneratabletypes like collectionsmapsarrays Moshi version on previous versions it works fine The following code causes Gradle build failed with exception kotlin open class ResponseT var data T null class Personval name String JsonClassgenerateAdapter true class PersonResponse ResponsePerson Exception kapt An exception occurred javalangIllegalStateException Unexpected type variable T at comsquareupmoshikotlincodegenapiAdapterGeneratorgenerateTypetypeRenderer renderTypeVariableAdapterGeneratorkt at comsquareupmoshikotlincodegenapiTypeRendererrenderTypeRendererkt at comsquareupmoshikotlincodegenapiTypeRendererrenderdefaultTypeRendererkt at comsquareupmoshikotlincodegenapiTypeRendererrenderObjectTypeTypeRendererkt at comsquareupmoshikotlincodegenapiTypeRendererrenderTypeRendererkt at comsquareupmoshikotlincodegenapiTypeRendererrenderdefaultTypeRendererkt Classes that are generated look like this SuppressDEPRECATION unused ClassName REDUNDANTPROJECTION class FooJsonAdapter moshi Moshi JsonAdapterFoo where Parameter moshi is never used is the warning Which then becomes an error in projects that has kotlinOptions allWarningsAsErrors true Im using PolymorphicJsonAdapterFactory in order to serializedeserialize a bit more complex data structure Here is my data structure kotlin open class DocumentData val documentType String open class FormDocument documentType String open val title String open val form ListString DocumentDatadocumentType data class SpecificFormDocument override val title String override val form ListString val info String val contributors ListString val description String FormDocumentFORMDOCUMENTSPECIFIC title form When Im trying to serialize some instances of these objects I receive Caused by javalangIllegalArgumentException Conflicting fields private final javautilList comappdocumentSpecificFormDocumentform private final javautilList comappdocumentFormDocumentform Which looks a bit odd as title does not cause any issues Am I doing something wrong kotlin inline class Inlineval i Int JsonClassgenerateAdapter true class InlineConsumerval i Inline Inline This leads to a exception when deserializing an InlineConsumer The problem is that the generated constructor call uses reflection The adapter tries to find the constructor based on the types of the arguments The argument in this case is Intit is inlined but the current version of moshi looks for Inline Also when passing the inline object to the constructor it needs to be unwrapped to Int or it will lead to a typecast exception I fixed this in a branch here a dff fa c f cb bd c d but the fix is kinda hacky and should probably not be used in a proper release so I wouldnt merge it The problematic part is figuring out which types to inline I do this by checking the jvm signature of the getter of each property and comparing this to the returnType of ImmutableKmProperty I use the same system to get the inlined type This should at least be properly refactored maybe needs support by kotlinpoet PS This is the issue I mention a few days ago So I hope its the last I submit at least in the near future wink PPS I know inline classes are not officaly supported by moshi but tracking this is still useful for the future I need to define the JsonAdapter for BigDecimal by the JsonQualifier annotation and use it on the items in a list kotlin JsonQualifier TargetAnnotationTargetTYPE RetentionAnnotationRetentionRUNTIME annotation class JsonCoordinates kotlin JsonClassgenerateAdapter true data class LocationData val coordinates ListJvmSuppressWildcards JsonCoordinates BigDecimal kotlin class LocationDataAdapterTest Test fun toJsonWithQualifier val moshi Moshi val adapter JsonAdapterLocationData moshi MoshiBuilder addBigDecimalclassjava JsonCoordinatesclassjava DecimalAdapter build adapter moshiadapterLocationDataclassjava val data LocationDatalistOfBigDecimal BigDecimal assertEquals coordinates adaptertoJsondata Test fun toJsonWithoutQualifier val moshi Moshi val adapter JsonAdapterLocationData moshi MoshiBuilder addBigDecimalclassjava DecimalAdapter build adapter moshiadapterLocationDataclassjava val data LocationDatalistOfBigDecimal BigDecimal assertEquals coordinates adaptertoJsondata The test toJsonWithoutQualifier has success The test toJsonWithQualifier fails with the following exception javalangIllegalArgumentException Platform class javamathBigDecimal with no annotations requires explicit JsonAdapter to be registered for class javamathBigDecimal for javautilListjavamathBigDecimal coordinates for class appklosedapimodelLocationData Here is the complete code These dont require kotlinreflect after all