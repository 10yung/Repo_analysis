This PR is allows truncatetables in the ActiveRecord adapter to take in a list of table names in two different ways as a regular array of tables truncatetables usersagents or as a list of arguments truncatetablesusersagents This is because when using DatabaseCleaner in conjunction with a connection adapter to imitate the truncatetables method as its implemented in the rails version of active record cleaning with truncation is broken as shown in an example error below An error occurred in a beforesuite hook FailureError DatabaseCleanercleanwithtruncation ActiveRecordStatementInvalid RandomAdapterMysqlError randomadapterqueryrecv Incorrect table name table table table usrlocalbundlegemsdatabasecleaner libdatabasecleaneractiverecordtruncationrb in block in clean usrlocalbundlegemsdatabasecleaner libdatabasecleaneractiverecordtruncationrb in clean usrlocalbundlegemsdatabasecleaner libdatabasecleanerbaserb in cleanwith usrlocalbundlegemsdatabasecleaner libdatabasecleanerconfigurationrb in block in cleanwith usrlocalbundlegemsdatabasecleaner libdatabasecleanerconfigurationrb in each usrlocalbundlegemsdatabasecleaner libdatabasecleanerconfigurationrb in cleanwith specrailshelperrb in block levels in top required As you can see here the truncatetables method is trying to the array of tables as one table name Let me know your thoughts on this Thanks Quick fix for the ActiveRecord adapter This was fixed for the Postgres adapter in Issue PR I wrote a spec but had problems building the mysql gem so was unable to run the spec sorry but I did load the gem in a project and verified the fix manually Your example must include after each clean code configaftereach do DatabaseCleanerclean end I created a SQLServerAdapter to so I could override the implementation of the databasecleanerviewcache method since sql server The other option was to change the underlying implementation of Im not sure why this is part of the base implementation ruby where tableschema currentdatabase Using autosavepoint for transactions allows any inner transactions defined by tested code to be rolled back independently and will also automatically catch SequelRollback exceptions as would be the case if no transactions were used Any code that relies on transactions will remain working as expected in the tests Coackroach DB doesnt use incremental sequence for row ids hence the RESTART IDENTITY bit isnt supported This adds a very simple test to disable it and make the truncation strategy works with cockroachdb Signedoffby Julien Lta BALLET contactltaio Hello I am trying to understand the implication of having an explicit although not recommended call to DatabaseCleanerclean inside an after block inside a spec which is being run in a suite with paralleltests gem From what I understand the paralleltests gem runs the specs in different processes each with its own database Looking at the DatabaseCleaner code I see that the clean method invokes cleaning on all the connections available Since I failed to trace back the code properly requesting some help in understand what the call to clean method will do Is it going to wipe out the database in the process or leak out to other processes somehow I kind of infer that such calls are causing flaky tests but I have not had a solid ground to claim that such method calls cause it NoMethodError undefined method urlwhitelist for DatabaseCleanerModule This is occurring because the latest gem version was released on April one day prior to these changes being merged in When specifying gem databasecleaner git ref c de ee afb e a e f f this fixes the issue mentioned above Please rerelease the newest gem version so I can remove the gemfile dependency on the commit SHA I have update rails version of my project form to Now I am getting following error on some of my tests randomly CountersDefectDistributionContext execute group by defect should group counters by defect FailureError DatabaseCleaner activerecord cleanwithtruncation ActiveRecordStatementInvalid PGConnectionBad connection is closed TRUNCATE TABLE publicalerts publicgvsubequipments publicmachinepartchanges publicsettings publicarticleattachments publicsystematicrejectmachines publicfurnaces publicattachments publicdefecttranslations publicgvequipmentfamilies publicgvequipments publicgvsquads publicarticlecheckspecificationtolerances publicgvareaequipments publicgvareas publicmachinedowntimes publicmachinegroups publicarticlemachinepartsettings publicchecks publiccomments publiccounters publiccustomers publicdefectgroups publicdefects publicdelayedjobs publicjobspecifications publicmachinepartchangereasons publicmachineparttranslations publicmachineparts publicmachinetypegroupmachinetypes publicmachinetypegroups publicmachinetypes publicmessages publiccheckspecificationpriorities publiccheckspecificationresponsibilityareas publicresponsibilityareas publiccheckspecificationmachinetypes publicgvcomponents publicgventries publicgvstopreasons publicgvsubequipmentcomponents publicjobs publiclabrecipeversions publiclabrecipes publiclines publicmoldsets publiccheckgroups publiccheckspecifications publicarticles publicpackingschemes publicrailsadminsettings publiccheckbatches publicreasons publicrejects publicroles publicshiftdefinitions publicshifts publicsystemlogentries publictaskstatuschanges publictasks publictresholds publicuserresponsibilityareas publicusers publicusersroles publicworkstations publicmachines publicsystematicrejects RESTART IDENTITY CASCADE What should I do to fix this I recently switched our config from transactional to truncation strategy as shown in the Rspec Capybara example in Readme However this seems to affect the data created in the beforeall With transaction strategy records created in beforeall were persisted and available between examples as expected With truncation strategy however records created within beforeall are only available in the first test and are then removed Is this an expected behavioursideeffect of transactional strategy