Original idea Suggested approach Solution Summary cargo expand should be able to expand the code of a test file somenamers in the tests directory of a given crate via test somename even though somenamers exists but somename is not part of the test targets listed for the given crate by cargometadata Technical Details The expansion should be done in a similar way as the trybuild crate handles building and testing of its tests pull out the code under test eg our somenamers into a temp directory run rustc against that just like trybuild would using prettyexpanded instead of building or testing anything Would be good to be able to only expand specific macros and leave other source as is ie cargo expand cratemycratederive or cargo expand deriveMyTraitAMyTraitB at the very least would be good to not expand macros that come from std Would it be possible to present a better error message to user when trying to export wasmbindgen project bash cargo expand target wasm unknownunknown Compiling procmacro v Compiling unicodexid v Compiling syn v Compiling wasmbindgenshared v Compiling cfgif v Compiling lazystatic v Compiling bumpalo v Compiling wasmbindgen v Compiling log v Compiling quote v Compiling wasmbindgenbackend v Compiling wasmbindgenmacrosupport v Compiling wasmbindgenmacro v error E can t find crate for core error aborting due to previous error For more information about this error try rustc explain E error Could not compile wasmbindgen To learn more run the command again with verbose This was solved by installing the Nightly toolchain bash rustup target add wasm unknownunknown toolchain nightly Would it be possible to give a warning or better error message in this case Currently the Cargo subprocess spawned by cargoexpand does not display Cargos usual progress bar I believe this is because we pipe the childs stderr to perform filtering here and that means Cargo does not get a winsize from this ioctl I tried a naive fix in but it didnt work the second ioctl fails with console Inappropriate ioctl for device os error Will need to figure out whats the correct way to provide a winsize to the child process Currently macrorules definitions are not visible in the expanded code Sometimes it can be useful to see them such as when you have a procedural macro whose job is to emit a macrorules macro Rustfmt can hit cases where code takes exponentially long to format particularly in macrogenerated code We may want to consider limiting rustfmt execution time to some small number of seconds after which we kill the rustfmt process and fall back to unformatted code I know this is probably very impossible unless rustc adds support for it but I think it would be useful to be able to expand code even when it doesnt compile especially when debugging procedural macros For now the easiest way Ive found is just to wrap your entire output into compileerror to see it When expanding a crate with hundreds of thousands of lines post expansion the progress can seem to pause for many seconds after printing console Finished dev unoptimized debuginfo targets in s and before the expanded output appears It is reasonable for users to expect that no further work needs to take place after something is Finished Lets print messages in the same style as Cargo to show that formatting and colorizing are taking place If the user has a crate like rust fn main println S We can inject the following code before compiling I guess similarly to how cargo clippy works but I havent looked at how that is rust featuretracemacros tracemacrostrue The output looks like note tracemacro srcmainrs println S note expanding println S note to print concat n S note expanding print concat n S note to crate io print formatargs concat n S It shows the intermediate expansion steps not just the final expanded result For example avoid expanding try and other macros inside the output of proc macros cc djc