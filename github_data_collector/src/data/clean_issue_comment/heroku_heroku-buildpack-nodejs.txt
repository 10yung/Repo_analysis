I have a starter application using angular no bells and whistles just ng new app using the new Angular CLI I then pushed it to Git and created a pipeline using the Heroku node build pack The Heroku build succeeds but when running the application using the Heroku link it fails with the below stack trace Can anyone help T app web JS stacktrace T app web Cannot get stack trace in GC T app web FATAL ERROR MarkCompactCollector semispace copy fallback in old gen Allocation failed JavaScript heap out of memory T app web T app web Writing Nodejs report to file report json T app web Nodejs report completed T app web x dab nodeAbort ng serve T app web x dbd nodeOnFatalErrorchar const char const ng serve T app web xb b e v UtilsReportOOMFailurev internalIsolate char const bool ng serve T app web xb b v internalV FatalProcessOutOfMemoryv internalIsolate char const bool ng serve T app web xce a ng serve T app web xd e v internalEvacuateNewSpaceVisitorVisitv internalHeapObject int ng serve T app web xd c c void v internalLiveObjectVisitorVisitBlackObjectsNoFailv internalEvacuateNewSpaceVisitor v internalMajorNonAtomicMarkingStatev internalMemoryChunk v internalMajorNonAtomicMarkingState v internalEvacuateNewSpaceVisitor v internalLiveObjectVisitorIterationMode ng serve T app web xd v internalFullEvacuatorRawEvacuatePagev internalMemoryChunk long ng serve T app web xd dfae v internalEvacuatorEvacuatePagev internalMemoryChunk ng serve T app web xd e v internalPageEvacuationTaskRunInParallelv internalItemParallelJobTaskRunner ng serve T app web xd v internalItemParallelJobTaskRunInternal ng serve T app web xd b v internalItemParallelJobRun ng serve T app web xd d void v internalMarkCompactCollectorBaseCreateAndExecuteEvacuationTasksv internalFullEvacuator v internalMarkCompactCollectorv internalMarkCompactCollector v internalItemParallelJob v internalMigrationObserver long ng serve T app web xd bbd v internalMarkCompactCollectorEvacuatePagesInParallel ng serve T app web xd c ea ng serve T app web xd d v internalMarkCompactCollectorCollectGarbage ng serve T app web xcf f v internalHeapMarkCompact ng serve T app web xcf v internalHeapPerformGarbageCollectionv internalGarbageCollector v GCCallbackFlags ng serve T app web xcf cd v internalHeapCollectGarbagev internalAllocationSpace v internalGarbageCollectionReason v GCCallbackFlags ng serve T app web xcf e v internalHeapAllocateRawWithRetryOrFailint v internalAllocationType v internalAllocationAlignment ng serve T app web xcbd v internalFactoryNewFillerObjectint bool v internalAllocationType ng serve T app web xff b v internalRuntimeAllocateInYoungGenerationint unsigned long v internalIsolate ng serve T app web x ng serve T app web Aborted T app web npm ERR code ELIFECYCLE T app web npm ERR errno T app web npm ERR herokung test start ng serve T app web npm ERR Exit status T app web npm ERR T app web npm ERR Failed at the herokung test start script T app web npm ERR This is probably not a problem with npm There is likely additional logging output above T app web T app web npm ERR A complete log of this run can be found in T app web npm ERR appnpmlogs T Zdebuglog T heroku web State changed from starting to crashed PACKAGEJSON name herokung test version scripts ng ng start ng serve build ng build test ng test lint ng lint e e ng e e private true dependencies angulardevkitbuildangular angularcli angularcompilercli angularanimations angularcommon angularcompiler angularcore angularforms angularplatformbrowser angularplatformbrowserdynamic angularrouter rxjs tslib zonejs devDependencies angularlanguageservice typesnode typesjasmine typesjasminewd codelyzer jasminecore jasminespecreporter karma karmachromelauncher karmacoverageistanbulreporter karmajasmine karmajasminehtmlreporter protractor tsnode tslint typescript ANGULARJSON schema nodemodulesangularclilibconfigschemajson version newProjectRoot projects projects herokung test projectType application schematics schematicsangularcomponent style scss root sourceRoot src prefix app architect build builder angulardevkitbuildangularbrowser options outputPath distherokung test index srcindexhtml main srcmaints polyfills srcpolyfillsts tsConfig tsconfigappjson aot false assets srcfaviconico srcassets styles srcstylesscss scripts configurations production fileReplacements replace srcenvironmentsenvironmentts with srcenvironmentsenvironmentprodts optimization true outputHashing all sourceMap false extractCss true namedChunks false aot true extractLicenses true vendorChunk false buildOptimizer true budgets type initial maximumWarning mb maximumError mb type anyComponentStyle maximumWarning kb maximumError kb serve builder angulardevkitbuildangulardevserver options browserTarget herokung testbuild configurations production browserTarget herokung testbuildproduction extracti n builder angulardevkitbuildangularextracti n options browserTarget herokung testbuild test builder angulardevkitbuildangularkarma options main srctestts polyfills srcpolyfillsts tsConfig tsconfigspecjson karmaConfig karmaconfjs assets srcfaviconico srcassets styles srcstylesscss scripts lint builder angulardevkitbuildangulartslint options tsConfig tsconfigappjson tsconfigspecjson e etsconfigjson exclude nodemodules e e builder angulardevkitbuildangularprotractor options protractorConfig e eprotractorconfjs devServerTarget herokung testserve configurations production devServerTarget herokung testserveproduction defaultProject herokung test If the SSLCERTFILE is set to an incorrect value the build will be unable to download the node yarn etc binaries Theres no message indicating the binaries cant be downloaded How hard would this be Can anyone see any major obstacles I might be willing to have a crack at it Hi the docs suggests that yarn caching works by default My builds consistently showed however that only nodemodules was being cached which is insufficient for yarn workspaces and also inconsistent with what the docs seems to specify above I tried setting cacheDirectory to the output of heroku run yarn cache dir but alas no avail After much digging I found out the buildpack sets the yarn cache dir to a temporary location I tried working around this by having the following in packagejson herokuprebuild export YARNCACHEFOLDERappcacheyarnv But this did not help the problem What would really help would have been the following PR which was never merged At Unsplash we use the popular tool patchpackage to apply patches to our Node modules after installation This works in the form of a postinstall script However this buildpack invokes yarn with the ignorescripts flag when pruning dev dependencies since v which means patchpackage will not run I can semiunderstand why the buildpack would want to avoid invoking scripts since the scripts were already run when yarn was invoked the first time prior to building However in this case we rely on scripts being invoked each time yarn is called as they significantly modify the contents of nodemodules It feels like we need an option to optin to running scripts after pruning Perhaps YARNPRUNESCRIPTS Seen in a customer app Procfile notweb node serverjs In this case the buildpack will still define a web process that defaults to npm start which creates some confusion We default to giving the created web process one dyno and the notweb process zero dynos which the user then has to go change In the example above there was not a start script so the created dyno would just crash with an error There are a couple of subtleties around this If we suddenly dont add a default process when a Procfile exist this could break users that are currently relying on this behavior without knowing it I need to think through the implications of changing this when multiple buildpacks are used Hi For one of our projects the durations of the nodejs buildpack part of our compile are as follows all times are with zero changes to yarnlock since the last build Prior to seconds log excerpt After and after an interim build to warm the cache with devDeps seconds log excerpt After and with setting YARNPRODUCTIONtrue interim build seconds log excerpt From both reading the last of the linked logs and from looking back over the PR It seems that even with YARNPRODUCTIONtrue the pruning step still happens and in our case takes quite a while likely in part due to yarnpkgyarn Is this intended I would have thought that for those installing only dependencies via YARNPRODUCTIONtrue the prune step would not need to run at all Many thanks From edmorley Does warnmissingdevdeps in failuresh need updating to also check for YARNPRODUCTION Can the NPMCONFIGPRODUCTION export now be removed from bintestcompile In environmentshs listnodeconfig should the mcount npmconfigproductiontrue also include YARNPRODUCTION or a new count be added This would allow users to customize where they get their node binaries such as from a local cache Ive made a similar pull request for python here and it is also available for ruby here 