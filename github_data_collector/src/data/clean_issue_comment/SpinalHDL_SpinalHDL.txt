Below is what I brought up on Gitter The questions asked point to places where new diagnostics could be printed I have set up a number of simulations for a component of mine and I have trouble interpreting the results I am getting Inside the component I have this assertion assertrecordWriteLock push first fire while holding record write lock FAILURE When I run it i might get this i seem to depend on random signals so assertions fail randomly as well info Progress Verilator compilation done in ms info Progress Start RecordFifo basic simulation with seed wave in homejoeFPGAprjhdlciscsimWorkspaceRecordFifobasicvcd info Done Simulation done in ms info Progress Start RecordFifo oneoverflow simulation with seed wave in homejoeFPGAprjhdlciscsimWorkspaceRecordFifooneoverflowvcd info FAILURE push first fire while holding record write lock info homejoeFPGAprjhdlcisctmpjob RecordFifov Verilog finish info FAILURE push first fire while holding record write lock info homejoeFPGAprjhdlcisctmpjob RecordFifov Verilog finish info homejoeFPGAprjhdlcisctmpjob RecordFifov Second verilog finish exiting success Total time s completed Jan AM I have set up different simulations however here I am only seeing two of them mentioned basicvcd and oneoverflowvcd Can I assume that the failure happened in trace oneoverflowvcd because its the last one printed before the error Because its a FAILURE simulation stops right when the assertion fails Time is not printed How would I spot the failed assertion when its just an ERROR Why is the overall process last line successful even if the simulation failed Hi Dolu Here is the pullrequest I mentioned in Pretty print for module instantiations Let me know if I did something incorrect WRT to the pullrequest The valid behavior of BusSlaveFactorydriveFlow is different for flows that fit within the bus data width and those that dont For the former valid is asserted for one clock cycle with a combinatorial signal For larger flows valid is asserted in the next clock cycle and never deasserted There is a regValid in driveFlow val regValid Regthatvalid initFalse which is set right below onWriteaddress wordCount wordAddressInc regValid True but never reset Maybe I misunderstood something but I believe that regValid should stay asserted for only one clock cycle Id like to change the name of my module when its compiled to Verilog This is especially relevant when including black box modules because it must name my class SOMECAPITALIZEDBULLSHIT so that it is instanciated correctly Id rather have something like setModuleNamestring to override the use of the class name and keep my camel case naming convention internally Just ignore for now Currently the output of the Travis CI when failing is very bloated There are many empty lines and progress information that dilute the actually interesting stuff I suspect this is because of interactive features that work well in user terminals but not when the output is written to a file I dont know much about sbt I couldnt find a name for this feature or how to disable it Example core Compile unmanagedSources inputFileStamps s error Failed tests empty lines core Compile unmanagedSources inputFileStamps s error spinaltesterscalatestMandelbrotTesterCocotbBoot empty lines core Compile unmanagedSources inputFileStamps s empty lines error tester Test test sbtTestsFailedException Tests unsuccessful error Total time s completed Jan PM I wondering if something like this can be adjusted Similar to If I have a Bundle that I use up a hierarchy outputs seem to get reassigned Here is an example scala class MyBundle extends Bundle val a in UInt bits val b in UInt bits val c out UInt bits class TestBundle extends Bundle val somein in Bool val someout out Bool class MyMod extends Component val io new MyBundle val tb new TestBundle ioc ioa iob tbsomeout False noIoPrefix class MyMod extends Component val io new MyBundle val tb new TestBundle val mod new MyMod modioa ioa modiob iob ioc ioa modioc tb modtb This will produce verilog module MyMod input a input b output c input tbsomein output tbsomeout assign c a b assign tbsomeout b endmodule module MyMod input ioa input iob output ioc input tbsomein output tbsomeout wire mod c wire mod tbsomeout MyMod mod aioa biob cmod c tbsomeintbsomein tbsomeoutmod tbsomeout assign ioc ioa mod c assign tbsomeout mod tbsomeout endmodule It would be ideal if it could do this verilog module MyMod input ioa input iob output ioc input tbsomein output tbsomeout wire mod c MyMod mod aioa biob cmod c tbsomeintbsomein tbsomeouttbsomeout assign ioc ioa mod c endmodule I know this is a byproduct of VHDL but is there a way to remove this intermediate variable A reason Im asking is that in ASIC flows you will often need to set a donttouch on a particular signal This keeps the synthesis tool from inserting a buffer or other logic These tools can often handle an assign statement but I know being able to only have signal name is ideal Ive only seen this on outputs and not on inputs I have dug through the SpinalHDL code some but Im pretty fresh with it and Scala in general so I dont really have much to offer in terms of what Ive tried But Im willing to try some things out if needed Im not sure how much effort this would be Thanks I focused mostly on the StreamFlow classes because I use these the most Fixed formatting where I went Added and improved some of the documentation Added a few helper objectsfunctions that I missed while using Spinal Changed the build system until it worked for me in Eclipse Changed default assertion severity to FATAL Normal Verilog backend generates formal assertions as well in an ifdef FORMAL block I want to put assertions into my hardware that get checked during simulation But currently I can only get simulationlevel assertions to work If I put assertcountervalue This is fine into my design this will fail during evaluation and not during simulation If I alternatively put GenerationFlagsformal assertcountervalue This is fine into my code the simulation will run through without ever failing which is obviously not what should be happening What works If I put an assertion into the dut testing code that drives the hardware it will work as expected But thats not really what I want