Labels can help in identifying a particular goroutine during debugging Fixes What version of Delve are you using dlv version Delve Debugger Version Build af eac f c ea e a e cc bda What version of Go are you using go version go version go linuxamd What operating system and processor architecture are you using Linux ndxps generic Ubuntu SMP Mon May UTC x x x GNULinux What did you do Debug from GoLand delve is started with dlv log logoutput rpc listenlocalhost headlesstrue apiversion checkgoversionfalse exec binary command The program itself doesnt matter result is the same Delve is started under the same user as the IDE What did you expect to see A successful connection What did you see instead Connection rejected Delve logs contain API server listening at sameuserlinuxgo cannot check remote address connection not found in procnettcp sameuserlinuxgo closing connection from different user connections to localhost are only accepted from the same UNIX user for security reasons Content of the procnettcp at the moment of connection failure my uid is sl localaddress remaddress st txqueue rxqueue tr tmwhen retrnsmt uid timeout inode F A A F EA A FA B A F AD A F D A CD A E ED A FF E A FF F A F A FAC A F A F A F A F B A C A F B E A F B F A FA A F EE A A D A A C AA FD A BB F EC F FA F A F AD F A FD AE FA B AF D FAC FB C F A FA FD FA B D F EE F FA B FD AE AF D A C E C BB B D A C E E C BB Ive distilled a lot of the conversation that came about the large refactor I submitted and have found a path to perform a more measured refactor This patch set serves as part of that refactor Introduce a new type procTarget which will build on top of the various backends to remove complexity and duplication The first step is removing procCommonProcess and pushing all that functionality further up the stack to procTarget Ensure the safety of data transmission during remote debugging by mtls or tls with token Fix I implement two ways about tls Tls should be L and token seem like L mtls Generate key pairs files for caclientserver no need to have token Maybe not friendly for goland and very complicated to me can use the following steps to test Generate Note the ip for server default use openssl by scriptsopensslgeneratemtlscertsh or go run scriptsopensslgeneratemtlscertgo host output mtls Server side dlv debug maingo mtlscacrt mtlscacrt mtlscrt mtlsservercrt mtlskey mtlsserverkey headless listen Client side dlv connect mtlscacrt mtlscacrt mtlscrt mtlsclientcrt mtlskey mtlsclientkey tlsOneWay SSL and token Just only need the machine of server side to generate one key pairs files crt is signed with itself without ca use openssl some parts are borrowed by tlstokensh mkdir tlstoken specity the ip that the server will listen or client will connect echo e req nx extensions v ca ndistinguishedname reqdistinguishedname n reqdistinguishedname n n v ca n nsubjectAltName altnames nbasicConstraints CAFALSE nkeyUsage nonRepudiation digitalSignature keyEncipherment n n n altnames nIP tlstokenconfigcnf openssl genrsa out tlstokenserverkey openssl req new x key tlstokenserverkey days subj CNgodelve config tlstokenconfigcnf out tlstokenservercrt or use go run GOROOTsrccryptotlsgeneratecertgo host to generate Be careful to the name and path of files maybe different with below Server side dlv debug maingo tlscrt tlstokenservercrt tlskey tlstokenserverkey tlstoken godelve headless listen Client side need to copy servercrt from server side dlv connect tlscrt tlstokenservercrt tlstoken godelve I think its possible that mtls can be removed because it is unfriendly to operate just save tls with token Need discussion dlsniper justinclift antong thx I think dlv could support more languates especially the msg for help include the children of cmd or specific error En but it looks like cobra does not support it the issues for cobra According to dlv should enable the user to dive into memory User can print binary data in specific memory address range But not support for sepecific variable name or structures temporarilyBecause I have no idea that modify print command Close Next some questions support the format for printcmd include address variable name and structuresno idea support the form about tbinary ffloat aaddress iinstruction cchar sstring support the negative position from address This is why also use x FMT address like gdb but not x FMT address I can close this pr if you against Executing go get u githubcomderekparkerdelvecmddlv on an up to date Windows Pro machine in a VS Code Terminal with newest version of git and go fails with the following errors C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use v type Thread as type procThread in append Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use th type Thread as type procThread in return argument Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use dbpcurrentThread type Thread as type procThread in return argument Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use trapthread type Thread as type procThread in return argument Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo impossible type assertion Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use thread type Thread as type procThread in argument to procGetG Thread does not implement procThread missing SetDX method C Users reneb go src githubcom godelve delve pkg proc native procgo cannot use dbpcurrentThread type Thread as type procThread in argument to procGetG Thread does not implement procThread missing SetDX method Something wrong in delve or on my side Support both relative path and symbolic link in location expressions Fixes Please answer the following before submitting your issue Note Please include any substantial examples debug session output stacktraces etc as linked gists What version of Delve are you using dlv version Version What version of Go are you using go version go version go darwinamd What operating system and processor architecture are you using macOS What did you do see below What did you expect to see see below What did you see instead see below Reproduce cd tmp ln s ago realpath ago Usersephtestago pwd Usersephtesttmp dlv debug ago Type help for list of commands dlv b Usersephtestago Command failed Location Usersephtestago not found dlv b Usersephtesttmpago Breakpoint set at x f db for mainmain ago pdb Python debugger can handle this situation Backtracing was greatly improved on linuxarm corefile backtraces Previously the backtrace of the goroutine that faulted and caused a core dump was quite truncated Now this goroutines backtrace is correctly printed out Faults cause exceptions Exceptions are taken on a different stack from the goroutine which caused the exception Further the exceptions stack frame is defined by the operating system linux in this case and not by golangs runtime environment Thus to correctly navigate a backtrace the stack unwinding code must have knowledge of how to process such exception stack frames On the amd architecture golang maintains explicit frame pointers easing this task On the arm architecture frame pointers are implicit complicating this task Following gdbs lead in processing exception frames code was added for the linuxarm implementation to discover that a stack frame is an exception frame If it discovers an exception stack frame it navigates to the stack frame that was interrupted This code is in the new source file arm linuxstackgo The procedure calls are now correctly printed out However if the go code was compiled with code optimization on local variables are often not printed out correctly This has not yet been investigated A tentative working hypothesis is that the localvariable backtracefollowing code also needs to notice the exception record and if one is detected fetch the requested register out of the exception records register save area For now the code has implicit knowledge of how to advance over an exception stack frame by having explicit constant offsets A better way would be to look up local stack symbols gos exception handlers code to fetch the correct stack pointer andor offset However this will need to wait until the fetching of local variables out of the stack frames is improved Finally about of the time the backtrace of a corefile was still truncated This turned out to because of original for i range framectxRegs loop in stackgo As framectxRegs is a map go can return indices in a pseudorandom order If the record for key is returned before the record for key something in DelveDwarfs registerfixup code is done incorrectly The code was changed to copy the keyvalue pairs into a slice The slice was then sorted the for loop was changed to range over the slice and the bug went away